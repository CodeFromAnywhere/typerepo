{
  "createdAt": 1671553275029,
  "updatedAt": 1671553275029,
  "deletedAt": 0,
  "createdFirstAt": 1671553275029,
  "classification": "const",
  "comments": [],
  "isExported": true,
  "name": "augmentMarkdown",
  "slug": "augment-markdown",
  "operationRelativeTypescriptFilePath": "src/augmentMarkdown.ts",
  "type": {
    "rawType": "<T extends string | null | undefined>(markdown: T, config?: { isAdmin?: boolean | undefined; augmentCode?: boolean | undefined; augmentWords?: boolean | undefined; augmentStatements?: boolean | undefined; augmentContextualPrompts?: boolean | undefined; augmentContextualPromptResults?: boolean | undefined; markdown_projectRelativeFilePath?: string | undefined; externalHost?: string | undefined; } | undefined) => Promise<{ augmentedMarkdown: T; contextualPromptResults?: import(\"/Users/king/King/operations/tools/ai/ai-types/build/ContextualPromptResult\").ContextualPromptResult[] | null | undefined; contextualPromptsObject?: any; }>",
    "typeDefinition": {
      "type": "object",
      "properties": {},
      "optional": false
    },
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": true,
    "isPrimitive": false,
    "isEnumLiteral": false,
    "simplifiedSchema": {
      "properties": [],
      "type": "object"
    }
  },
  "value": "async <T extends string | null | undefined>(\n  markdown: T,\n  config?: {\n    isAdmin?: boolean;\n    /**\n     * TODO: make this faster first by finding all codeblocks in the file first (if this is enabled) and taking a subset of the mapped object then (mapped object  from sdk) and then placing it into the md\n     */\n    augmentCode?: boolean;\n    augmentWords?: boolean;\n    augmentStatements?: boolean;\n    /**\n     * Useful for sites like dev.to and medium where I don't have the capability for creating my own context-menu\n     */\n    augmentContextualPrompts?: boolean;\n    augmentContextualPromptResults?: boolean;\n    markdown_projectRelativeFilePath?: string;\n    /**\n     * If given, all augmented hyperlinks will be absolute to this given domain. Useful for posting on other sites\n     */\n    externalHost?: string;\n  }\n): Promise<{\n  augmentedMarkdown: T;\n  /**\n   * Still needed if you want to show the variants and derivatives in your own way\n   */\n  contextualPromptResults?: ContextualPromptResult[] | null;\n  /**\n   * Still needed if you watn to make it possible to do prompts in another way\n   */\n  contextualPromptsObject?: Omit<\n    ContextualPromptsObject,\n    \"databaseContextualPromptSlugs\"\n  >;\n}> => {\n  if (!markdown || markdown.trim() === \"\") {\n    // no markdown, just return the input\n    return {\n      augmentedMarkdown: markdown,\n    };\n  }\n\n  const {\n    isAdmin,\n    augmentCode,\n    augmentContextualPrompts,\n    augmentContextualPromptResults,\n    augmentStatements,\n    augmentWords,\n    markdown_projectRelativeFilePath,\n    externalHost,\n  } = destructureOptionalObject(config);\n  // do stuff with this configuration here\n\n  const fileType = getFileTypeFromPath(markdown_projectRelativeFilePath);\n\n  const augmentedWordObject = augmentCode\n    ? await getAugmentedWordObject()\n    : undefined;\n  // we need all prompts that seem interesting for this type of content\n\n  const isDev = isAdmin || process.env.NODE_ENV !== \"production\";\n\n  // we can't augment this to the markdown because it's a much more interactive thing, it probably wouldn't work. unless I do something with hyperlinks to the original content, where I make a page that lets you sign up to prompt something ðŸ¤¯ this way I can integrate with any place that accepts hyperlinks in posts (linkedin, medium, dev.to, etc.)\n  const { databaseContextualPromptSlugs, ...contextualPromptsObject } =\n    await getContextualPrompts(\n      fileType === \"other\" ? undefined : fileType,\n      undefined,\n      isDev\n    );\n\n  //WordCombination, WordMatrix, Statement, AugmentedWord, and ContextualPromptResult\n\n  const contextualPromptResults = augmentContextualPromptResults\n    ? (\n        (await getContextualPromptResults({\n          promptSlugs: databaseContextualPromptSlugs,\n          prompt_projectRelativePath: markdown_projectRelativeFilePath,\n        })) || []\n      ).filter((x) => {\n        if (isDev) return true;\n        return !x.isFake && x.isFavorite;\n      })\n    : [];\n\n  const wordMatrixs = augmentWords\n    ? (await db.get(\"WordMatrix\")).map((x) =>\n        getSubsetFromObject(x, [\n          \"slug\",\n          \"name\",\n          \"description\",\n          \"descriptionAudio\",\n          \"emoji\",\n          \"image\",\n          \"rank\",\n          \"priorityLevel\",\n          \"type\",\n          \"usageCountCalculated\",\n          \"english\",\n        ])\n      )\n    : [];\n\n  const mappedWordMatrix = createMappedObject(wordMatrixs, \"slug\");\n\n  const wordCombinations = augmentWords ? await db.get(\"WordCombination\") : [];\n  const statements = augmentStatements ? await db.get(\"Statement\") : [];\n\n  // `tsFunctions, tsVariables, tsInterfaces`: find words between backticks, replace the word between `backticks` with `[\"term\"(---description and maybe code---)](url-to-file-or-#)`\n  //  to support multiline tooltips, the augmented markdown should contain `<br>` instead of newlines in the alt. It should be a configuration, and if newlines should be disabled, the tooltip should show only that that is capable of being on a single line.\n\n  const markdownWithCodespanAugmentation = markdown\n    .split(\" \")\n    .map((word) => {\n      if (!word.startsWith(\"`\") || !word.endsWith(\"`\")) {\n        return word;\n      }\n\n      const wordWithoutBackticks = word.slice(1, word.length - 1);\n\n      const augmentedWord = augmentedWordObject?.[wordWithoutBackticks];\n      if (!augmentedWord || !augmentedWord.spoiler) {\n        return word;\n      }\n\n      return makeMarkdownLink(\n        wordWithoutBackticks,\n        undefined,\n        augmentedWord.spoiler\n      );\n    })\n    .join(\" \");\n\n  const markdownAfterContextualPromptResults = contextualPromptResults.reduce(\n    (previousMarkdown, contextualPromptResult) => {\n      if (!contextualPromptResult.selectionString) {\n        // console.log(\"NO selectionString\");\n        return previousMarkdown;\n      }\n\n      const newMarkdown: string = previousMarkdown.replace(\n        contextualPromptResult.selectionString,\n        `${contextualPromptResult.selectionString} ${makeMarkdownLink(\n          \"?\",\n          undefined,\n          `${contextualPromptResult.selectionString}\\n\\n${contextualPromptResult.contextualPromptSlug}\\n\\n${contextualPromptResult.resultText}`\n        )}`\n      );\n\n      return newMarkdown;\n    },\n    markdownWithCodespanAugmentation\n  );\n  /**\n     `statements and selection results`: add [\"?\"(----reader-agreement, agreement, importancy, results----)](link-to-knowledge-base-or-#) at the end of the selection/statement\n     \n     Most expensive now are statements (selection results are limited because they are tied to the file already, but statements are not). We can later enhance the efficiency of statements to index which wordMatrix words they tie to, and filter out the unneeded ones this way.\n\n     */\n  const markdownAfterStatements = statements.reduce((previous, statement) => {\n    /**\n     * how to get this efficiently even if the propmt reulsts aren't always part of it? tough titty\n     */\n    const newMarkdown = previous.replace(\n      statement.description,\n      `${statement.description} ${makeMarkdownLink(\n        \"?\",\n        undefined,\n        `Statement: ${statement.description}.\\n\\nreaders-agreement: ${statement.readersAgreement}, agreement: ${statement.agreement}, importancy ${statement.importancy}`\n      )}`\n    );\n    return newMarkdown;\n  }, markdownAfterContextualPromptResults);\n\n  const markdownAfterWordCombinations = wordCombinations.reduce(\n    (previousMarkdown, wordCombination) => {\n      const words: Pick<\n        WordMatrix,\n        | \"english\"\n        | \"slug\"\n        | \"name\"\n        | \"description\"\n        | \"descriptionAudio\"\n        | \"emoji\"\n        | \"image\"\n        | \"rank\"\n        | \"priorityLevel\"\n        | \"type\"\n        | \"usageCountCalculated\"\n      >[] =\n        wordCombination.wordMatrixSlugs\n          ?.map((slug) =>\n            mappedWordMatrix[slug] ? mappedWordMatrix[slug] : undefined\n          )\n          .filter(notEmpty) || [];\n\n      // TODO: later I can add things like audio and statistics\n      const wordDefinitions = words\n        .map((word) => {\n          return `${word.name}: ${word.description}`;\n        })\n        .join(\"\\n\\n\");\n      const fullDescription = `${wordCombination.description}\\n\\n${wordDefinitions}`;\n      // `wordCombinations`: replace term with `[\"term\"(----description----)](link-to-website-or-#)` where description is the description of the term, but below that also all word definitions of the underlying wordmatrix words are explained\n      const newMarkdown = previousMarkdown.replace(\n        wordCombination.name,\n        makeMarkdownLink(wordCombination.name, undefined, fullDescription)\n      );\n\n      return newMarkdown;\n    },\n    markdownAfterStatements\n  );\n\n  /**\n  TODO:\n  LATER:\n\n  First I need to fix that I can either ADD things into a broader link that is already encapsulating something. Then I can do either that or create a new one. That will be the best solution\n\n  - `wordMatrixs`: if there is a wordcombination here already this doesn't matter. Otherwise, just replace the word with `[\"word\"(---description, audio, etc---)](#)`\n\n  - `prompts`: add the prompts like `[\"promptname\"(prompt-description)](link-to-execute-prompt?selection=abcdefg)` at the end of a header section for selection prompts, and at the end of a page for page-prompts\n\n  */\n  const augmentedMarkdown = markdownAfterWordCombinations as NonNullable<T>;\n\n  // console.log({ augmentedMarkdown });\n  return {\n    contextualPromptResults,\n    augmentedMarkdown,\n    contextualPromptsObject,\n  };\n}",
  "description": "Now that I've written this all down, it seems to be a quite an expensive operation, but we never need to do it for ensire websites, just for one page, and the result can easily be cached. I need to write a regex function that matches all text from a list of searchterms in markdown except if it's part of a link or image, and reduce the matches, creating a new markdown string every time. I think there are algorithms though that are more efficient because if there are like thousands of matches on a 2mb text, the thing would take much longer. Maybe it's more efficient to split up the text in smaller pieces and do the regex for every piece individually. This would have a limitation that you can't select cross-section, but I don't think that's my usecase anyway. If we later add support for making statements about a chapter or subsection and stuff like that, this limitation can also be resolved.\n\nAugments markdown in many ways for multiple purposes.\n\n- Parse the markdown instead of showing the results as React buttons. The link to \"#\" alt can become the same as a nice AugmentedWord hover, when it's found to be a selection result, we can highlight the selection whenever we hover over a link with that same text as alt as well, and add that hover as a note at the end of the selection.\n- ensure the parse parses `WordCombination`, `WordMatrix`, `Statement`, `AugmentedWord`, and `ContextualPromptResult`. It's a lot of work, but definitely worth it. Should be parsed as\n- remove the parsing of everything in the markdown render. This is also the end of sending `AugmentedWord`s to the frontend\n\nLATER:\n\n- CTA's, headers, footers, ads (check how I was planning to get those at codestorys-node or so)\n- Word frequency occurency styling\n- Subtexts and subwords",
  "id": "rjnteiepgnplelivgxggssvw"
}