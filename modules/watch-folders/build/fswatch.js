"use strict";var __awaiter=this&&this.__awaiter||function(e,n,t,r){return new(t||(t=Promise))((function(i,o){function a(e){try{l(r.next(e))}catch(e){o(e)}}function u(e){try{l(r.throw(e))}catch(e){o(e)}}function l(e){var n;e.done?i(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(a,u)}l((r=r.apply(e,n||[])).next())}))},__generator=this&&this.__generator||function(e,n){var t,r,i,o,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:u(0),throw:u(1),return:u(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function u(o){return function(u){return function(o){if(t)throw new TypeError("Generator is already executing.");for(;a;)try{if(t=1,r&&(i=2&o[0]?r.return:o[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,o[1])).done)return i;switch(r=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return a.label++,{value:o[1],done:!1};case 5:a.label++,r=o[1],o=[0];continue;case 7:o=a.ops.pop(),a.trys.pop();continue;default:if(!(i=a.trys,(i=i.length>0&&i[i.length-1])||6!==o[0]&&2!==o[0])){a=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){a.label=o[1];break}if(6===o[0]&&a.label<i[1]){a.label=i[1],i=o;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(o);break}i[2]&&a.ops.pop(),a.trys.pop();continue}o=n.call(e,a)}catch(e){o=[6,e],r=0}finally{t=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,u])}}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.watchFoldersFs=void 0;var fs_1=require("fs"),fs_util_1=require("fs-util"),log_1=require("log"),pending=[],noPending=function(){return 0===pending.length},isStillPending=function(){return __awaiter(void 0,void 0,void 0,(function(){return __generator(this,(function(e){switch(e.label){case 0:return noPending()?[2/*return*/,!1]:(
console.log("awaiting pending",pending),[4/*yield*/,new Promise((function(e,n){
// do this every 5 seconds
setInterval((function(){return __awaiter(void 0,void 0,void 0,(function(){return __generator(this,(function(n){return noPending()&&e(),[2/*return*/]}))}))}),5e3);
}))]);case 1:return e.sent(),[2/*return*/]}}))}))},watchFoldersFs=function(e){e.debug;var n=e.folders,t=e.onChange;e.takeLatest;return __awaiter(void 0,void 0,void 0,(function(){return __generator(this,(function(e){return n.map((function(e){(0,fs_1.watch)(e,{recursive:!0,encoding:"utf8"},(function(n,r){return __awaiter(void 0,void 0,void 0,(function(){var i,o,a,u,l,c;return __generator(this,(function(s){switch(s.label){case 0:
// if a file was just triggered and within a second triggered again, ignore it
// same file within a second
return i=pending.filter((function(e){return e.filename===r})),(o=i.pop())&&Date.now()-o.time<5e3?((0,log_1.log)("double trigger of ".concat(r,", ignoring"),{type:"warning"}),[2/*return*/]):i.length>0?((0,log_1.log)("multiple pending of this file, ignoring",{type:"warning"}),[2/*return*/]):(a=Date.now(),pending.push({filename:r,time:a}),u=e,l=fs_util_1.path.join(u,".."),c=fs_util_1.path.join(e,r),[4/*yield*/,t({operationBasePath:l,eventType:n,filePaths:[c]})]);case 1:
// TODO: Somehow, it would be great if we could batch changes from multiple files together, so it will execute after there are no changes for more than 30 seconds (or if you press the 'e' button). This will make it more efficient.
return s.sent(),
// after it's done, remove from the array
pending=pending.filter((function(e){return e.filename===r&&e.time===a})),[2/*return*/]}}))}))}))})),[2/*return*/]}))}))};exports.watchFoldersFs=watchFoldersFs;
//# sourceMappingURL=fswatch.js.map