{
  "createdAt": 1667635411681,
  "updatedAt": 1667635411681,
  "deletedAt": 0,
  "createdFirstAt": 1667635411681,
  "classification": "const",
  "comments": [],
  "isExported": true,
  "name": "operationToMarkdown",
  "slug": "operation-to-markdown",
  "operationRelativeTypescriptFilePath": "src/operationToMarkdown.ts",
  "type": {
    "rawType": "(config: { operationName: string; manualProjectRoot?: string | undefined; isSummary?: boolean | undefined; mergeDocsInline?: boolean | undefined; returnType?: \"string\" | \"parse\" | \"save\" | undefined; }) => Promise<string | import(\"/Users/king/King/operations/tools/types/code-types/build/MarkdownParse\").MarkdownParse | undefined>",
    "typeDefinition": {
      "type": "object",
      "properties": {},
      "optional": false
    },
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": true,
    "isPrimitive": false,
    "isEnumLiteral": false,
    "simplifiedSchema": {
      "properties": [],
      "type": "object"
    }
  },
  "value": "async (config: {\n  operationName: string;\n  manualProjectRoot?: string;\n  /**\n   * if true, just returns the outline of the operation (function + interface names, size, deps)\n   */\n  isSummary?: boolean;\n  /**\n   * if true, it will merge all docs into the readme, not linking to them (by default, docs will be linked to)\n   */\n  mergeDocsInline?: boolean;\n  /**\n   * save: saves the result in the operation `README.md` and `CONTRIBUTING.md` and other default md files\n   *\n   * string: returns the full markdown string\n   *\n   * parse: returns the markdownparse\n   */\n  returnType?: \"parse\" | \"string\" | \"save\";\n}): Promise<string | MarkdownParse | undefined> => {\n  const {\n    isSummary,\n    manualProjectRoot,\n    operationName,\n    mergeDocsInline,\n    returnType,\n  } = config;\n\n  const projectRoot = manualProjectRoot || getProjectRoot();\n  if (!projectRoot) {\n    log(\"Projectroot not found\", { type: \"error\" });\n    return;\n  }\n\n  const operationFolderPath = await getOperationPath(operationName, {\n    manualProjectRoot: projectRoot,\n  });\n\n  if (!operationFolderPath) {\n    log(\"Operation not found\", { type: \"error\" });\n    return;\n  }\n\n  /**    \n  operation info\n  */\n\n  const operationConfig = (\n    await db.get(\"OperationConfig\", { operationName })\n  )[0];\n  const description = operationConfig?.markdown;\n\n  const packageJson = await getPackageJson({ operationFolderPath });\n\n  const operationIndexPath = path.join(\n    operationFolderPath,\n    databaseFolderName,\n    \"operation-index.json\"\n  );\n  const operationIndex = await readJsonFile<OperationIndex>(operationIndexPath);\n\n  const sizeString = `Size: ${operationIndex?.size?.codeSize?.lines} LOC, ${\n    operationIndex?.size?.dataSize?.characters !== undefined\n      ? `${operationIndex?.size?.dataSize?.characters} data characters, `\n      : \"\"\n  }${\n    operationIndex?.size?.textSize?.characters !== undefined\n      ? `${operationIndex?.size?.textSize?.characters} text characters, `\n      : \"\"\n  }`;\n\n  /**\n  - packagejson description\n  - size (code, data, text (lines / characters))\n  - dependencies: core, operation, package\n  - links to docs or inline docs\n   */\n\n  const coreDependencies =\n    operationIndex &&\n    operationIndex.coreDependencies &&\n    operationIndex.coreDependencies.length > 0\n      ? operationIndex.coreDependencies.join(\", \")\n      : \"none\";\n  const operationDependencies =\n    operationIndex &&\n    operationIndex.operationDependencies &&\n    operationIndex.operationDependencies.length > 0\n      ? operationIndex.operationDependencies.join(\", \")\n      : \"none\";\n  const packageDependencies =\n    operationIndex &&\n    operationIndex.packageDependencies &&\n    operationIndex.packageDependencies.length > 0\n      ? operationIndex.packageDependencies.join(\", \")\n      : \"none\";\n\n  const operationInfoMd = `${operationName} (${\n    operationIndex?.classification\n  } operation)\n\n${description ? `${description}\\n\\n` : \"\"}`;\n\n  /*\n\nTODO: Maybe put back optionally, but for readme NO\n\n${sizeString}\n \nImported dependencies:\n\n- From Core Libraries: ${coreDependencies}\n- From Packages: ${packageDependencies}\n- From Operations: ${operationDependencies}\n\n*/\n\n  const operationInfoMarkdownParse = mdToJsonParse(\n    operationInfoMd,\n    operationName\n  );\n\n  const docsPath = path.join(operationFolderPath, \"docs\");\n  const hasDocs = fs.existsSync(docsPath);\n  const docs = hasDocs\n    ? await bundleFolderWithMarkdown(\"Docs\", docsPath, \"docs\")\n    : undefined;\n\n  const docsMarkdownParse = docs?.markdownParse;\n\n  const docsOutline = docs?.outlineString || \"\";\n\n  /**\n   * Functions\n   */\n  const { functionsMarkdownParse, functionsOutline } = await getFunctionsInfo(\n    operationName\n  );\n\n  /**\n   * Models+interfaces\n   */\n  const models = (await db.get(\"TsInterface\", { operationName })).filter(\n    (x) => x.isDbModel\n  );\n\n  const interfaces = (await db.get(\"TsInterface\", { operationName })).filter(\n    (x) => !x.isDbModel && !x.name.startsWith(\"NamedParameters<\")\n  );\n  const variables = await db.get(\"TsVariable\", { operationName });\n\n  const modelsMarkdownString =\n    models.length > 0\n      ? models.map(tsInterfaceToMarkdownString).join(\"\\n\\n\")\n      : undefined;\n  const interfacesMarkdownString =\n    interfaces.length > 0\n      ? interfaces.map(tsInterfaceToMarkdownString).join(\"\\n\\n\")\n      : undefined;\n\n  const variablesMarkdownString =\n    variables.length > 0\n      ? variables.map(tsVariableToMarkdownString).join(\"\\n\\n\")\n      : undefined;\n\n  const modelsMarkdownParse: MarkdownParse | undefined = modelsMarkdownString\n    ? mdToJsonParse(modelsMarkdownString, \"models\")\n    : undefined;\n  const interfacesMarkdownParse: MarkdownParse | undefined =\n    interfacesMarkdownString\n      ? mdToJsonParse(interfacesMarkdownString, \"interfaces\")\n      : undefined;\n\n  const variablesMarkdownParse: MarkdownParse | undefined =\n    variablesMarkdownString\n      ? mdToJsonParse(variablesMarkdownString, \"variables\")\n      : undefined;\n\n  const modelsOutline = makeOutlineMarkdownString(\n    \"Models\",\n    models.map((x) => getMergedMarkdownOutlineUrl(x.name))\n  );\n\n  const interfacesOutline = makeOutlineMarkdownString(\n    \"Interfaces\",\n    interfaces.map((x) => getMergedMarkdownOutlineUrl(x.name))\n  );\n\n  const variablesOutline = makeOutlineMarkdownString(\n    \"Variables\",\n    variables.map((x) => getMergedMarkdownOutlineUrl(x.name))\n  );\n\n  const completeOutlineMarkdownParse = mdToJsonParse(\n    `${docsOutline}${functionsOutline}${modelsOutline}${interfacesOutline}${variablesOutline}`,\n    \"outline\"\n  );\n\n  const { merged } = mergeMarkdownParse(\n    [\n      operationInfoMarkdownParse,\n      completeOutlineMarkdownParse,\n      docsMarkdownParse,\n      functionsMarkdownParse,\n      modelsMarkdownParse,\n      interfacesMarkdownParse,\n      variablesMarkdownParse,\n    ].filter(notEmpty)\n  );\n\n  let returnString: string | undefined = undefined;\n  if (returnType !== \"parse\") {\n    returnString = markdownParseToMarkdownString(merged);\n  }\n\n  const shouldSave = returnType === \"save\" || !returnType;\n  if (shouldSave && returnString) {\n    await fs.writeFile(\n      path.join(operationFolderPath, \"README.md\"),\n      returnString,\n      \"utf8\"\n    );\n  }\n\n  const returnValue =\n    returnType === \"parse\"\n      ? merged\n      : returnType === \"string\"\n      ? returnString\n      : undefined;\n\n  return returnValue;\n}",
  "description": "converts an operation and all its contents into a flat markdown file that contains the needed information. configurable.\n\nmarkdown for reading (so there are no links)",
  "id": "hrydfegxquoogtoyfrzcqvof"
}