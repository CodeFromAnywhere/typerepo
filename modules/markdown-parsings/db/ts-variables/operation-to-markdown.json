{
  "createdAt": 1667976869128,
  "updatedAt": 1667976869128,
  "deletedAt": 0,
  "createdFirstAt": 1667976869128,
  "classification": "const",
  "comments": [],
  "isExported": true,
  "name": "operationToMarkdown",
  "slug": "operation-to-markdown",
  "operationRelativeTypescriptFilePath": "src/operationToMarkdown.ts",
  "type": {
    "rawType": "(config: { operationName: string; manualProjectRoot?: string | undefined; isSummary?: boolean | undefined; mergeDocsInline?: boolean | undefined; returnType?: \"string\" | \"parse\" | \"save\" | undefined; }) => Promise<string | import(\"/Users/king/King/operations/tools/types/code-types/build/MarkdownParse\").MarkdownParse | undefined>",
    "typeDefinition": {
      "type": "object",
      "properties": {},
      "optional": false
    },
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": true,
    "isPrimitive": false,
    "isEnumLiteral": false,
    "simplifiedSchema": {
      "properties": [],
      "type": "object"
    }
  },
  "value": "async (config: {\n  operationName: string;\n  manualProjectRoot?: string;\n  /**\n   * if true, just returns the outline of the operation (function + interface names, size, deps)\n   */\n  isSummary?: boolean;\n  /**\n   * if true, it will merge all docs into the readme, not linking to them (by default, docs will be linked to)\n   */\n  mergeDocsInline?: boolean;\n  /**\n   * - save: saves the result in the operation `README.md` and `CONTRIBUTING.md` and other default md files\n   * - string: returns the full markdown string\n   * - parse: returns the `MarkdownParse`\n   */\n  returnType?: \"parse\" | \"string\" | \"save\";\n}): Promise<string | MarkdownParse | undefined> => {\n  const {\n    isSummary,\n    manualProjectRoot,\n    operationName,\n    mergeDocsInline,\n    returnType,\n  } = config;\n\n  const projectRoot = manualProjectRoot || getProjectRoot();\n  if (!projectRoot) {\n    log(\"Projectroot not found\", { type: \"error\" });\n    return;\n  }\n\n  const operationFolderPath = await getOperationPath(operationName, {\n    manualProjectRoot: projectRoot,\n  });\n\n  if (!operationFolderPath) {\n    log(\"Operation not found\", { type: \"error\" });\n    return;\n  }\n\n  /**    \n  operation info\n  */\n\n  const operationConfig = (\n    await db.get(\"OperationConfig\", { operationName })\n  )[0];\n  const description = operationConfig?.markdown;\n\n  const packageJson = await getPackageJson({ operationFolderPath });\n\n  const operationIndexPath = path.join(\n    operationFolderPath,\n    databaseFolderName,\n    \"operation-index.json\"\n  );\n  const operationIndex = await readJsonFile<OperationIndex>(operationIndexPath);\n\n  const sizeString = `Size: ${operationIndex?.size?.codeSize?.lines} LOC, ${\n    operationIndex?.size?.dataSize?.characters !== undefined\n      ? `${operationIndex?.size?.dataSize?.characters} data characters, `\n      : \"\"\n  }${\n    operationIndex?.size?.textSize?.characters !== undefined\n      ? `${operationIndex?.size?.textSize?.characters} text characters, `\n      : \"\"\n  }`;\n\n  /**\n  - packagejson description\n  - size (code, data, text (lines / characters))\n  - dependencies: core, operation, package\n  - links to docs or inline docs\n   */\n\n  const coreDependencies =\n    operationIndex &&\n    operationIndex.coreDependencies &&\n    operationIndex.coreDependencies.length > 0\n      ? operationIndex.coreDependencies.join(\", \")\n      : \"none\";\n  const operationDependencies =\n    operationIndex &&\n    operationIndex.operationDependencies &&\n    operationIndex.operationDependencies.length > 0\n      ? operationIndex.operationDependencies.join(\", \")\n      : \"none\";\n  const packageDependencies =\n    operationIndex &&\n    operationIndex.packageDependencies &&\n    operationIndex.packageDependencies.length > 0\n      ? operationIndex.packageDependencies.join(\", \")\n      : \"none\";\n\n  const operationInfoMd = `${operationName} (${\n    operationIndex?.classification\n  } operation)\n\n${description ? `${description}\\n\\n` : \"\"}`;\n\n  /*\n\nTODO: Maybe put back optionally, but for readme NO\n\n${sizeString}\n \nImported dependencies:\n\n- From Core Libraries: ${coreDependencies}\n- From Packages: ${packageDependencies}\n- From Operations: ${operationDependencies}\n\n*/\n\n  const operationInfoMarkdownParse = mdToJsonParse(\n    operationInfoMd,\n    operationName\n  );\n\n  const docsPath = path.join(operationFolderPath, \"docs\");\n  const hasDocs = fs.existsSync(docsPath);\n  const docs = hasDocs\n    ? await bundleFolderWithMarkdown(\"Docs\", docsPath, \"docs\")\n    : undefined;\n\n  /**\n   * all imports at other operations\n   */\n  const imports = (await db.get(\"TsImport\")).filter(\n    (x) => x.operationName !== operationName\n  );\n\n  const tsFunctions = (await db.get(\"TsFunction\", { operationName }))\n    .filter(onlyUnique2<TsFunction>((a, b) => a.name === b.name))\n    .filter((x) => x.isExported);\n\n  const variables = (await db.get(\"TsVariable\", { operationName })).filter(\n    (x) => x.isExported\n  );\n\n  const interfaces = (await db.get(\"TsInterface\", { operationName }))\n    .filter((x) => !x.name.startsWith(\"NamedParameters<\"))\n    .filter((x) => x.isExported);\n\n  const dependantTsFunctions: DependantCountObject[] = await Promise.all(\n    tsFunctions.map(addDependantCount(\"tsFunction\", imports))\n  );\n\n  const dependantTsInterfaces: DependantCountObject[] = await Promise.all(\n    interfaces.map(addDependantCount(\"tsInterface\", imports))\n  );\n\n  const dependantTsVariables: DependantCountObject[] = await Promise.all(\n    variables.map(addDependantCount(\"tsVariable\", imports))\n  );\n\n  // Sort it! :D\n  const sortedDependantCountArray = [\n    dependantTsFunctions,\n    dependantTsInterfaces,\n    dependantTsVariables,\n  ]\n    .flat()\n    .sort((a, b) =>\n      a.externalDependantFiles.length > b.externalDependantFiles.length ? -1 : 1\n    );\n\n  // writeToAssets(\n  //   __filename,\n  //   sortedDependantCountArray,\n  //   \"sortedDependantCountArray.json\"\n  // );\n\n  const externalItems = sortedDependantCountArray.filter(\n    (x) => x.externalDependantFiles.length > 0\n  );\n\n  const internalItems = sortedDependantCountArray.filter(\n    (x) => x.externalDependantFiles.length === 0\n  );\n\n  const [externalItemsMarkdown, internalItemsMarkdown] = [\n    externalItems,\n    internalItems,\n  ].map((countArray) => {\n    const res = countArray\n      .map((dependantCountObject) => {\n        if (dependantCountObject.tsFunction) {\n          return tsFunctionToMarkdownString(dependantCountObject.tsFunction);\n        }\n\n        if (dependantCountObject.tsInterface) {\n          return tsInterfaceToMarkdownString(dependantCountObject.tsInterface);\n        }\n\n        if (dependantCountObject.tsVariable) {\n          return tsVariableToMarkdownString(dependantCountObject.tsVariable);\n        }\n      })\n      .filter(notEmpty)\n      .join(\"\\n\\n\");\n\n    return res;\n  });\n\n  const apiReference = mdToJsonParse(externalItemsMarkdown!, \"api-reference\");\n\n  const internal = mdToJsonParse(\n    `<details><summary>Show internal (${internalItems.length})</summary>\n  \n  ${internalItemsMarkdown}\n  </details>`,\n    \"internal\"\n  );\n\n  const { merged } = mergeMarkdownParse(\n    [\n      operationInfoMarkdownParse,\n      mdToJsonParse(docs?.outlineString || \"\"),\n      docs?.markdownParse,\n      apiReference,\n      internal,\n    ].filter(notEmpty)\n  );\n\n  let returnString: string | undefined = undefined;\n  if (returnType !== \"parse\") {\n    returnString = markdownParseToMarkdownString(merged);\n  }\n\n  const shouldSave = returnType === \"save\" || !returnType;\n  if (shouldSave && returnString) {\n    await fs.writeFile(\n      path.join(operationFolderPath, \"README.md\"),\n      returnString,\n      \"utf8\"\n    );\n  }\n\n  const returnValue =\n    returnType === \"parse\"\n      ? merged\n      : returnType === \"string\"\n      ? returnString\n      : undefined;\n\n  return returnValue;\n}",
  "description": "converts an operation and all its contents into a flat markdown file that contains the needed information. configurable.\n\nmarkdown for reading (so there are no links)",
  "id": "aaznwnttservnomzxiodggkk"
}