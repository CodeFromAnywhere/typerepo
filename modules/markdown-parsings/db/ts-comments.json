[
  {
    "createdAt": 1662735932603,
    "updatedAt": 1662735932603,
    "deletedAt": 0,
    "createdFirstAt": 1662735932603,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/bundlings.ts",
    "comment": "Should render a string with one or more markdown tables to represent the simplifiedSchema",
    "rawStatement": "export const simplifiedSchemaToMarkdownString = (\n  simplifiedSchema: SimplifiedSchema | undefined,\n  name: string,\n  isRequired: boolean,\n  /** the headers level, defaults to 1 */ level?: number\n): string => {\n  if (!simplifiedSchema) return \"\";\n\n  const refLinkString = simplifiedSchema.circularRefName\n    ? `[${simplifiedSchema.circularRefName}](#${kebabCase(\n        simplifiedSchema.circularRefName\n      )})`\n    : \"\";\n\n  const enumString = simplifiedSchema.enum\n    ? `(Enum: ${simplifiedSchema.enum.map(String).join(\" | \")}) `\n    : \"\";\n\n  const optionalSubtitle = `${isRequired ? \"\" : \" (optional)\"}`;\n\n  const nameWithoutNewlines = name.replaceAll(\"\\n\", \"\");\n  const type = `${simplifiedSchema.type}${enumString}${refLinkString}`;\n  const title = `${\"#\".repeat(\n    level || 1\n  )} ${nameWithoutNewlines}${optionalSubtitle}: ${type}`;\n\n  const arrayString = simplifiedSchema.items\n    ? simplifiedSchema.items\n        .map((item) => {\n          const itemString = `- ${item.name}: ${item.schema.type}`;\n          return itemString;\n        })\n        .join(\"\\n\")\n    : \"\";\n\n  const description = simplifiedSchema.description\n    ? `\\`\\`\\`md\\n${simplifiedSchema.description}\\n\\`\\`\\`\\n`\n    : \"\";\n\n  const objectString = simplifiedSchema.properties\n    ? `Properties: \\n\\n | Name | Type | Description |\\n|---|---|---|\\n${simplifiedSchema.properties\n        .map(propertyToTableRow)\n        .join(\"\\n\")}\\n`\n    : \"\";\n\n  const togetherString = [title, arrayString, description, objectString].join(\n    \"\\n\\n\"\n  );\n\n  return togetherString;\n};",
    "parameters": {},
    "types": [],
    "firstLine": 42,
    "lastLine": 45,
    "id": "pDQMDNvosqskHQeR"
  },
  {
    "createdAt": 1662735932603,
    "updatedAt": 1662735932603,
    "deletedAt": 0,
    "createdFirstAt": 1662735932603,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/bundlings.ts",
    "comment": "TsFunction:\n- name and operation\n- size\n- description (doc-comment)\n- input, output",
    "rawStatement": "export const tsFunctionToMarkdownString = (tsFunction: TsFunction): string => {\n  const titleString = `## ${tsFunction.name}`;\n  const infoString = `${\n    tsFunction.codeSize?.lines ? `${tsFunction.codeSize.lines} LOC, ` : \"\"\n  }Max. indexation depth: ${tsFunction.maxIndentationDepth}, ${\n    tsFunction.cumulativeCodeSize?.lines\n      ? `${tsFunction.cumulativeCodeSize?.lines} Cumulative LOC`\n      : \"\"\n  }`;\n\n  const returnTypeString = tsFunction.returnType.simplifiedSchema\n    ? simplifiedSchemaToMarkdownString(\n        tsFunction.returnType.simplifiedSchema,\n        \"Returns\",\n        true,\n        3\n      )\n    : \"## Returns: unknown\";\n\n  const argumentStrings =\n    tsFunction.parameters && tsFunction.parameters.length > 0\n      ? `### Arguments\\n\\n${tsFunction.parameters\n          .map((x) =>\n            simplifiedSchemaToMarkdownString(\n              x.simplifiedSchema,\n              x.name,\n              x.required,\n              4\n            )\n          )\n          .join(\"\\n\\n\")}`\n      : undefined;\n\n  const alineas: (string | undefined)[] = [\n    titleString,\n    // infoString, // TODO: Maybe make it optional.\n    tsFunction.description,\n    returnTypeString,\n    argumentStrings,\n  ];\n\n  return alineas.filter(notEmpty).join(\"\\n\\n\");\n};",
    "parameters": {},
    "types": [],
    "firstLine": 98,
    "lastLine": 104,
    "id": "noWVGffOZPZwtqIO"
  },
  {
    "createdAt": 1662735932603,
    "updatedAt": 1662735932603,
    "deletedAt": 0,
    "createdFirstAt": 1662735932603,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/bundlings.ts",
    "comment": "properties, their type, and their description\n\nuse simplifiedJsonSchema, but split up nested things into multiple tables (ive written a thing for splitting up nested objects before, use that)",
    "rawStatement": "export const tsInterfaceToMarkdownString = (\n  tsInterface: TsInterface\n): string => {\n  const titleString = `## ${tsInterface.name}`;\n  const storageMethodString = tsInterface.dbStorageMethod\n    ? `${tsInterface.dbStorageMethod} model\\n\\n`\n    : undefined;\n\n  const operationName = tsInterface.operationName\n    ? `(from: \\`${tsInterface.operationName}\\`)`\n    : undefined;\n\n  // const interfaceText = `\\`\\`\\`ts\\n${tsInterface.rawText}\\n\\`\\`\\``;\n\n  const interfaceText = simplifiedSchemaToMarkdownString(\n    tsInterface.type.simplifiedSchema,\n    tsInterface.name,\n    true,\n    2\n  );\n\n  const alineas: (string | undefined)[] = [\n    titleString,\n    operationName,\n    storageMethodString,\n    tsInterface.description,\n    interfaceText,\n  ];\n\n  return alineas.filter(notEmpty).join(\"\\n\\n\");\n};",
    "parameters": {},
    "types": [],
    "firstLine": 148,
    "lastLine": 152,
    "id": "gtDVQweVTbgXCaHM"
  },
  {
    "createdAt": 1662735932603,
    "updatedAt": 1662735932603,
    "deletedAt": 0,
    "createdFirstAt": 1662735932603,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/bundlings.ts",
    "comment": "finds all md files in a folder and creates a single MarkdownParse\n\nhandy for creating a single documentation file or other things that have to include multiple markdown files in a structured way\n\nNB: it recursively structures the files and folders with headings",
    "rawStatement": "export const bundleFolderWithMarkdown = async (\n  absoluteFolderPath: string,\n  /**\n   * filename to include in the final MarkdownParse\n   */\n  fileName?: string\n): Promise<{ markdownParse: MarkdownParse; outline: string }> => {\n  const mdPaths = (\n    await explore({ basePath: absoluteFolderPath, extension: \"md\" })\n  ).map((x) => x.path);\n\n  const markdownParses = (\n    await Promise.all(mdPaths.map((mdPath) => readMarkdownFile(mdPath)))\n  ).filter(notEmpty);\n\n  const merged = mergeMarkdownParse(markdownParses, fileName);\n\n  const docFileNames = markdownParses.map((x) => x.fileName).filter(notEmpty);\n\n  const outline =\n    docFileNames.length > 0\n      ? `## Docs\\n\\n${docFileNames\n          .map((fileName) => {\n            return `- [${humanCase(fileName)}](#${fileName})`;\n          })\n          .join(\"\\n\")}\\n\\n`\n      : \"\";\n\n  return { markdownParse: merged, outline };\n};",
    "parameters": {},
    "types": [
      "nb"
    ],
    "firstLine": 184,
    "lastLine": 190,
    "id": "SWNwhqEyJMLFBBnC"
  },
  {
    "createdAt": 1662735932603,
    "updatedAt": 1662735932603,
    "deletedAt": 0,
    "createdFirstAt": 1662735932603,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/bundlings.ts",
    "comment": "converts an operation and all its contents into a flat markdown file that contains the needed information. configurable.\n\nmarkdown for reading (so there are no links)",
    "rawStatement": "export const operationToMarkdown = async (config: {\n  operationName: string;\n  manualProjectRoot?: string;\n  /**\n   * if true, just returns the outline of the operation (function + interface names, size, deps)\n   */\n  isSummary?: boolean;\n  /**\n   * if true, it will merge all docs into the readme, not linking to them (by default, docs will be linked to)\n   */\n  mergeDocsInline?: boolean;\n  /**\n   * save: saves the result in the operation `README.md` and `CONTRIBUTING.md` and other default md files\n   *\n   * string: returns the full markdown string\n   *\n   * parse: returns the markdownparse\n   */\n  returnType?: \"parse\" | \"string\" | \"save\";\n}): Promise<string | MarkdownParse | undefined> => {\n  const {\n    isSummary,\n    manualProjectRoot,\n    operationName,\n    mergeDocsInline,\n    returnType,\n  } = config;\n\n  const projectRoot = manualProjectRoot || getProjectRoot();\n  if (!projectRoot) {\n    log(\"Projectroot not found\", { type: \"error\" });\n    return;\n  }\n\n  const operationFolderPath = await getOperationPath(operationName, {\n    manualProjectRoot: projectRoot,\n  });\n\n  if (!operationFolderPath) {\n    log(\"Operation not found\", { type: \"error\" });\n    return;\n  }\n\n  /**    \n  operation info\n  */\n\n  const packageJson = await getPackageJson({ operationFolderPath });\n  const description = packageJson?.description;\n\n  const operationIndexPath = path.join(\n    operationFolderPath,\n    databaseFolderName,\n    \"operation-index.json\"\n  );\n  const operationIndex = await readJsonFile<OperationIndex>(operationIndexPath);\n\n  const sizeString = `Size: ${operationIndex?.size?.codeSize?.lines} LOC, ${\n    operationIndex?.size?.dataSize?.characters !== undefined\n      ? `${operationIndex?.size?.dataSize?.characters} data characters, `\n      : \"\"\n  }${\n    operationIndex?.size?.textSize?.characters !== undefined\n      ? `${operationIndex?.size?.textSize?.characters} text characters, `\n      : \"\"\n  }`;\n\n  /**\n  - packagejson description\n  - size (code, data, text (lines / characters))\n  - dependencies: core, operation, package\n  - links to docs or inline docs\n   */\n\n  const coreDependencies =\n    operationIndex &&\n    operationIndex.coreDependencies &&\n    operationIndex.coreDependencies.length > 0\n      ? operationIndex.coreDependencies.join(\", \")\n      : \"none\";\n  const operationDependencies =\n    operationIndex &&\n    operationIndex.operationDependencies &&\n    operationIndex.operationDependencies.length > 0\n      ? operationIndex.operationDependencies.join(\", \")\n      : \"none\";\n  const packageDependencies =\n    operationIndex &&\n    operationIndex.packageDependencies &&\n    operationIndex.packageDependencies.length > 0\n      ? operationIndex.packageDependencies.join(\", \")\n      : \"none\";\n\n  const operationInfoMd = `${operationName} (${\n    operationIndex?.classification\n  } operation)\n\n${description ? `${description}\\n\\n` : \"\"}`;\n\n  /*\n\nTODO: Maybe put back optionally, but for readme NO\n\n${sizeString}\n \nImported dependencies:\n\n- From Core Libraries: ${coreDependencies}\n- From Packages: ${packageDependencies}\n- From Operations: ${operationDependencies}\n\n*/\n\n  const operationInfoMarkdownParse = mdToJsonParse(\n    operationInfoMd,\n    operationName\n  );\n\n  const docsPath = path.join(operationFolderPath, \"docs\");\n  const hasDocs = fs.existsSync(docsPath);\n  const docs = hasDocs\n    ? await bundleFolderWithMarkdown(docsPath, \"docs\")\n    : undefined;\n\n  const docsMarkdownParse = docs?.markdownParse;\n\n  const docsOutline = docs?.outline || \"\";\n\n  /**\n   * Functions\n   */\n  const tsFunctions = (await db.get(\"TsFunction\", { operationName })).filter(\n    onlyUnique2<TsFunction>((a, b) => a.name === b.name)\n  );\n\n  const functionsMarkdownString =\n    tsFunctions.length > 0\n      ? tsFunctions.map(tsFunctionToMarkdownString).join(\"\\n\\n\")\n      : undefined;\n\n  const functionsMarkdownParse: MarkdownParse | undefined =\n    functionsMarkdownString\n      ? mdToJsonParse(functionsMarkdownString, \"functions\")\n      : undefined;\n\n  const functionsOutline =\n    tsFunctions.length > 0\n      ? `## Functions\\n\\n${tsFunctions\n          .map((tsFunction) => `- [${tsFunction.name}](#${tsFunction.name})`)\n          .join(\"\\n\")}\\n\\n`\n      : \"\";\n\n  /**\n   * Models\n   */\n  const models = (await db.get(\"TsInterface\", { operationName })).filter(\n    (x) => x.isDbModel\n  );\n\n  const modelsMarkdownString =\n    models.length > 0\n      ? models.map(tsInterfaceToMarkdownString).join(\"\\n\\n\")\n      : undefined;\n\n  const modelsMarkdownParse: MarkdownParse | undefined = modelsMarkdownString\n    ? mdToJsonParse(modelsMarkdownString, \"models\")\n    : undefined;\n\n  const modelsOutline =\n    models.length > 0\n      ? `## Models:\\n\\n${models\n          .map((model) => `- [${model.name}](#${model.name})`)\n          .join(\"\\n\")}\\n\\n`\n      : \"\";\n\n  const completeOutlineMarkdownParse = mdToJsonParse(\n    `${docsOutline}${functionsOutline}${modelsOutline}`,\n    \"outline\"\n  );\n\n  const merged = mergeMarkdownParse(\n    [\n      operationInfoMarkdownParse,\n      completeOutlineMarkdownParse,\n      docsMarkdownParse,\n      functionsMarkdownParse,\n      modelsMarkdownParse,\n    ].filter(notEmpty)\n  );\n\n  let returnString: string | undefined = undefined;\n  if (returnType !== \"parse\") {\n    returnString = markdownParseToMarkdownString(merged);\n  }\n\n  const shouldSave = returnType === \"save\" || !returnType;\n  if (shouldSave && returnString) {\n    await fs.writeFile(\n      path.join(operationFolderPath, \"README.md\"),\n      returnString,\n      \"utf8\"\n    );\n  }\n\n  return returnType === \"parse\"\n    ? merged\n    : returnType === \"string\"\n    ? returnString\n    : undefined;\n};",
    "parameters": {},
    "types": [],
    "firstLine": 222,
    "lastLine": 226,
    "id": "FXyPZSjyxdGrUsTs"
  },
  {
    "createdAt": 1662735932603,
    "updatedAt": 1662735932603,
    "deletedAt": 0,
    "createdFirstAt": 1662735932603,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/bundlings.ts",
    "comment": "Input: BundleConfig (one or more folder(s), readme, operations with a docs folder)\n\nOutput should be all md files concatenated in the right order with the right titles",
    "rawStatement": "export const bundleToBookMd = async (config: {\n  bundleConfig: BundleConfig;\n  title?: string;\n  coverImagePath?: string;\n  isModulesIncluded?: boolean;\n  manualProjectRoot?: string;\n}) => {\n  const {\n    bundleConfig,\n    coverImagePath,\n    title,\n    isModulesIncluded,\n    manualProjectRoot,\n  } = config;\n\n  const bundleSummary = getBundleSummary(bundleConfig);\n\n  const bundleDocs = bundleConfig.docsRelativeFolderPath;\n\n  const moduleNamesOrNot = isModulesIncluded ? [] : bundleSummary.moduleNames;\n\n  const allOperations = [\n    ...bundleSummary.appNames,\n    ...bundleSummary.packageNames,\n    ...moduleNamesOrNot,\n  ];\n\n  const operationMarkdownParses = (\n    await Promise.all(\n      allOperations.map(async (operationName) => {\n        const markdownParse = (await operationToMarkdown({\n          operationName,\n          manualProjectRoot,\n          mergeDocsInline: true,\n          returnType: \"parse\",\n        })) as MarkdownParse;\n        if (!markdownParse) return;\n\n        return markdownParse;\n      })\n    )\n  ).filter(notEmpty);\n\n  const mergedMarkdown = mergeMarkdownParse(operationMarkdownParses);\n\n  //   getOutline();\n\n  // 1) getOutline\n  // 2) mergeMarkdownParse\n  // 3) add cover + outline + contents together\n};",
    "parameters": {},
    "types": [],
    "firstLine": 438,
    "lastLine": 444,
    "id": "IRKzUPUgXUAWYRhz"
  },
  {
    "createdAt": 1662735932603,
    "updatedAt": 1662735932603,
    "deletedAt": 0,
    "createdFirstAt": 1662735932603,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/bundlings.ts",
    "comment": "creates a summary for a whole bundle\n\nNB: Related to `bundleToBookMd`",
    "rawStatement": "export const bundleToMd = ({\n  bundleConfigId,\n  includeModules,\n}: {\n  bundleConfigId: string;\n  /** if true, also includes the private modules */\n  includeModules?: boolean;\n}): string => {\n  /**\n     - explain operation config itself, e.g. which apps there are and an outline of the packages and modules\n  \n     - extract all needed operations from bundle config (with or without modules) and use operationToMd for those\n    \n     - extract docs and readmes from bundle config and bundle those\n    */\n  return \"\";\n};",
    "parameters": {},
    "types": [
      "nb"
    ],
    "firstLine": 497,
    "lastLine": 502,
    "id": "KatgOMFnAhFeuIkG"
  },
  {
    "createdAt": 1662735932603,
    "updatedAt": 1662735932603,
    "deletedAt": 0,
    "createdFirstAt": 1662735932603,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/bundlings.ts",
    "comment": "summarizes the whole OS project into a markdown string",
    "rawStatement": "export const projectToMd = ({\n  includeTodo,\n}: {\n  includeTodo?: boolean;\n  includeOperationDetails?: boolean;\n}): string => {\n  /**\n  \n   - the folder structure should be the outline\n   - hierarchically delve into folders with all its content (md and operations)\n\n   */\n  return \"\";\n};",
    "parameters": {},
    "types": [],
    "firstLine": 521,
    "lastLine": 523,
    "id": "HrbYyCahqrrdsFLe"
  }
]