[
  {
    "createdAt": 1671315098834,
    "updatedAt": 1671315098834,
    "deletedAt": 0,
    "createdFirstAt": 1671315098834,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/queue-functions.ts",
    "comment": "function `processPromptOnFile` to execute `processChatGptPrompt` for a file, so we don't need to store the whole file content and it can be executed later and still have the most recent file contents\n\nIn order to keep the file itself as a source of truth for its content, it's useful to have this because you can add this to the queue",
    "rawStatement": "export const processPromptOnFile = async (\n  projectRelativeFilePath: string,\n  contextualPromptSlug: string\n) => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No projectroot\" };\n  }\n\n  const absolutePath = path.join(projectRoot, projectRelativeFilePath);\n\n  const exists = fs.existsSync(absolutePath);\n\n  if (!exists) {\n    return { isSuccessful: false, message: \"File doesn't exist\" };\n  }\n\n  const contextContent = await fs.readFile(absolutePath, \"utf8\");\n  const result = await processChatGptPrompt({\n    contextContent,\n    contextualPromptSlug,\n    isDeferred: true,\n    prompt_projectRelativePath: projectRelativeFilePath,\n  });\n\n  return result;\n};",
    "parameters": {},
    "types": [],
    "firstLine": 11,
    "lastLine": 16,
    "id": "wgfdctnkdtrmhfghuspjjaoe"
  },
  {
    "createdAt": 1671315098834,
    "updatedAt": 1671315098834,
    "deletedAt": 0,
    "createdFirstAt": 1671315098834,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/queue-functions.ts",
    "comment": "function that can execute `processPromptOnFile` for all files in a folder, by just upserting the executions to the queue.",
    "rawStatement": "export const processPromptOnFolder = async (config: {\n  projectRelativeFolderPath: string;\n  promptSlug: string;\n  isRecursive?: boolean;\n  extension?: string | string[];\n}) => {\n  const { projectRelativeFolderPath, promptSlug, extension, isRecursive } =\n    config;\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No projectroot\" };\n  }\n  const absoluteFolderPath = path.join(projectRoot, projectRelativeFolderPath);\n\n  const exists = fs.existsSync(absoluteFolderPath);\n\n  if (!exists) {\n    return { isSuccessful: false, message: \"Folder not found\" };\n  }\n\n  const stats = await fs.stat(absoluteFolderPath);\n  if (!stats.isDirectory()) {\n    return { isSuccessful: false, message: \"That's not a folder\" };\n  }\n\n  // get files\n  const projectRelativeFilePaths = (\n    await explore({\n      basePath: absoluteFolderPath,\n      doNotExploreChildFolders: !isRecursive,\n      extension,\n      ignore: \".index\",\n    })\n  ).map((x) => makeRelative(x.path, projectRoot));\n\n  const queueItems: Creation<Queue>[] = projectRelativeFilePaths.map(\n    (projectRelativeFilePath) => {\n      return {\n        functionName: \"processPromptOnFile\",\n        parameters: [projectRelativeFilePath, promptSlug],\n        type: \"puppeteer\",\n      };\n    }\n  );\n\n  const upsertResult = await db.upsert(\"Queue\", queueItems);\n\n  return {\n    isSuccessful: upsertResult.isSuccesful,\n    message: upsertResult.isSuccesful ? \"Added to queue\" : upsertResult.message,\n  };\n};",
    "parameters": {},
    "types": [],
    "firstLine": 45,
    "lastLine": 47,
    "id": "kclmvziafnasizahozwmwrqo"
  },
  {
    "createdAt": 1671315098834,
    "updatedAt": 1671315098834,
    "deletedAt": 0,
    "createdFirstAt": 1671315098834,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/queue-functions.ts",
    "comment": "\ncron that runs every minute for executing new puppeteer queue items. It will open it as child process. You can set the amount of tabs it should have as a limit, and it will keep the tabs open afterwards, but after the thing is done it will just remove the item from the `Queue`.",
    "rawStatement": "export const checkQueue = async () => {\n  const queueItems = await db.get(\"Queue\");\n\n  // 1. check how many chrome tabs are available (according to OS settings / memory limit)\n\n  // 2. check how many queue items can be executed now, and sort by importancy\n\n  // 3. take the ones that are most important and execute those\n};",
    "parameters": {
      "runEveryPeriod": "minute"
    },
    "types": [],
    "firstLine": 102,
    "lastLine": 109,
    "id": "qycnfsgcqbphzecxvhgqqvdy"
  }
]