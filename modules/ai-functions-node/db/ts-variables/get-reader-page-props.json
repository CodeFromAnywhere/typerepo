{
  "createdAt": 1671105537510,
  "updatedAt": 1671105537510,
  "deletedAt": 0,
  "createdFirstAt": 1671105537510,
  "classification": "const",
  "comments": [],
  "isExported": true,
  "name": "getReaderPageProps",
  "slug": "get-reader-page-props",
  "operationRelativeTypescriptFilePath": "src/getReaderPageProps.ts",
  "type": {
    "rawType": "(projectRelativeFilePath: string, queryPath?: string | undefined, realBasePath?: string | undefined) => Promise<import(\"/Users/king/King/operations/tools/purpose/codebase-introspection/reader/next-types/build/types\").GetStaticPropsResult<import(\"/Users/king/King/operations/tools/ai/ai-types/build/ReaderProps\").ReaderProps>>",
    "typeDefinition": {
      "type": "object",
      "properties": {},
      "optional": false
    },
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": true,
    "isPrimitive": false,
    "isEnumLiteral": false,
    "simplifiedSchema": {
      "properties": [],
      "type": "object"
    }
  },
  "value": "async (\n  projectRelativeFilePath: string,\n  /**\n   * If given, knows how to redirect\n   */\n  queryPath?: string,\n  realBasePath?: string\n): Promise<GetStaticPropsResult<ReaderProps>> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { notFound: true };\n  }\n  const absoluteQueryPath = path.join(projectRoot, projectRelativeFilePath);\n  const pathExists = fs.existsSync(absoluteQueryPath);\n\n  if (!pathExists) {\n    console.log(\"path doesn't exist\", absoluteQueryPath);\n    return { notFound: true };\n  }\n\n  const prompt_projectRelativePath = makeRelative(\n    absoluteQueryPath,\n    projectRoot\n  );\n\n  const stat = await fs.stat(absoluteQueryPath);\n\n  const isFile = stat.isFile();\n  const isFolder = stat.isDirectory();\n\n  if (!isFile && !isFolder) {\n    // should never happen\n    console.log(\"Not file , not folder\");\n    return { notFound: true };\n  }\n\n  const folderPath = isFile\n    ? path.parse(absoluteQueryPath).dir\n    : absoluteQueryPath;\n\n  const dirents = await fs.readdir(folderPath, {\n    withFileTypes: true,\n    encoding: \"utf8\",\n  });\n\n  const isDev = process.env.NODE_ENV === \"development\";\n\n  const readmeDirent = dirents.find(\n    (x) => x.name.toLowerCase() === \"readme.md\"\n  );\n\n  const readmePath = readmeDirent\n    ? path.join(folderPath, readmeDirent.name)\n    : undefined;\n  const readmeFrontmatter = readmePath\n    ? (await readMarkdownFile(readmePath))?.parameters\n    : undefined;\n  const canSeeFolder = readmePath\n    ? canSeeFileContent(readmeFrontmatter, isDev)\n    : true;\n  // TODO: look in all readmes from basePath until the folder we are, to see if this should be allowed to see.\n\n  const navigation: FolderContent[] = (\n    await Promise.all(\n      dirents.map(async (dirent) => {\n        // TODO: think about it. Maybe we should do something with symbolic links because we don't want to go deep forever, it could actually be nice to use this feature of the OS as well!\"\n\n        const ignoredFilesFolders = [\".DS_Store\", \".index\"];\n        if (ignoredFilesFolders.includes(dirent.name)) return;\n\n        const fullPath = path.join(folderPath, dirent.name);\n\n        const type = dirent.isDirectory()\n          ? \"folder\"\n          : dirent.isSymbolicLink()\n          ? \"link\"\n          : dirent.isFile()\n          ? \"file\"\n          : \"unknown\";\n\n        /**\n         * If it's a markdown file, take its parameters\n         * If it's a folder, take the parameters of the REAMDE in that folder.\n         */\n        const frontmatter =\n          getExtension(dirent.name) === \"md\"\n            ? (await readMarkdownFile(fullPath))?.parameters\n            : type === \"folder\"\n            ? (await readMarkdownFile(path.join(fullPath, \"README.md\")))\n                ?.parameters\n            : undefined;\n        const folderContent: FolderContent = {\n          type,\n          name: dirent.name,\n          frontmatter,\n        };\n\n        return folderContent;\n      })\n    )\n  )\n    .filter(notEmpty)\n    .map(({ frontmatter, ...other }) => {\n      const folderContent: FolderContent = {\n        ...other,\n        ...expandFrontmatter(frontmatter),\n      };\n      return folderContent;\n    })\n    .filter((file) => {\n      // filter out the files that should be HIDDEN\n      return canSeeFile(file, isDev);\n    })\n    .map(omitUndefinedValues);\n\n  // if you opened a folder and there's a readme, redirect to that readme.\n  // NB: index isn't allowed to redirect, so we need to prerender it in another way. Potentially we can provide the markdown in the index as the only exception? only if it's there\n  if (isFolder && !!readmeDirent && queryPath !== \"\" && realBasePath) {\n    const readmePath = makeRelative(\n      path.join(folderPath, readmeDirent.name),\n      realBasePath\n    );\n    const destination = `/${readmePath}`;\n    console.log(\"REDIRECTING\");\n\n    // permanent is not possible since we are swithcing the basePath sometimes.\n    return { redirect: { destination, permanent: false } };\n  }\n\n  const markdownParse = isFile\n    ? await readMarkdownFile(absoluteQueryPath)\n    : null;\n\n  const canSeeContent = canSeeFileContent(markdownParse?.parameters, isDev);\n  const markdown =\n    isFile && canSeeContent && canSeeFolder && markdownParse\n      ? markdownParse.raw\n      : // TODO: in case of a folder, we might be able to show an indexed thing based on the information of this emptyness (just the files and folders around it). This could provide a lot of interesting content already.\n        null;\n\n  const {\n    augmentedMarkdown,\n    contextualPromptResults,\n    contextualPromptsObject,\n  } = await augmentMarkdown(markdown, {\n    // for now no code yet, it's too slow\n    augmentCode: false,\n    augmentContextualPrompts: false,\n    augmentContextualPromptResults: true,\n    augmentStatements: true,\n    augmentWords: true,\n    externalHost: undefined,\n    markdown_projectRelativeFilePath: prompt_projectRelativePath,\n  });\n\n  const props: ReaderProps = {\n    isFolder,\n    canSeeContent,\n    unauthorizedWarningMessage: canSeeContent\n      ? null\n      : \"You have to be premium to see this. [Click here to see our offers](/offers)\",\n    markdown: augmentedMarkdown,\n    navigation,\n    projectRelativeFilePath: prompt_projectRelativePath,\n    contextualPromptResults: contextualPromptResults || null,\n    contextualPromptsObject: contextualPromptsObject || null,\n  };\n\n  return { props };\n}",
  "description": "",
  "id": "lcwggrisfasbwesjyvveehrb"
}