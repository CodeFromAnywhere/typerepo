{
  "createdAt": 1669059722000,
  "updatedAt": 1669059722000,
  "deletedAt": 0,
  "createdFirstAt": 1669059722000,
  "isApiExposed": true,
  "isExported": true,
  "groupAuthorization": {},
  "operationRelativeTypescriptFilePath": "src/getNestedDatabaseMenu.ts",
  "commentsInside": [],
  "rawText": " async (config?: {\n  noOperationPath?: boolean;\n  noOperationName?: boolean;\n  noSrcRelativeFolder?: boolean;\n  noPrefix?: boolean;\n}): Promise<{ flat?: WebPage[]; nested?: NestedWebPage[] }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return {};\n  const { noOperationPath, noOperationName, noSrcRelativeFolder, noPrefix } =\n    destructureOptionalObject(config);\n  const dbModels = (await db.get(\"TsInterface\")).filter((x) => x.isDbModel);\n\n  const queryPaths = dbModels.map((dbModel) => {\n    const projectRelativeOperationPath =\n      operations[dbModel.operationName as keyof typeof operations];\n\n    const slicedProjectRelativeOperationPath = projectRelativeOperationPath\n      .split(\"/\")\n      // in bundles, we still want to make the distinction between modules and packages, so this is great.\n      .slice(isBundle(projectRoot) ? 0 : 2)\n      .join(\"/\");\n    const operationPart = noOperationName\n      ? \"\"\n      : noOperationPath\n      ? dbModel.operationName + \"/\"\n      : slicedProjectRelativeOperationPath + \"/\";\n\n    const folder = getFolder(\n      dbModel.operationRelativeTypescriptFilePath.slice(\"src/\".length)\n    );\n    const folderPart = noSrcRelativeFolder\n      ? \"\"\n      : folder.length === 0\n      ? \"\"\n      : folder + \"/\";\n\n    const prefixPart = noPrefix ? \"\" : \"db/\";\n    const url = `${prefixPart}${operationPart}${folderPart}${dbModel.name}`;\n\n    return url;\n  });\n\n  const dbPages: WebPage[] = queryPaths.map((queryPath) => {\n    return { queryPath, pageData: undefined };\n  });\n\n  const upsertPages: WebPage[] = dbModels.map((dbModel) => ({\n    queryPath: `upsert/${dbModel.name}`,\n    pageData: undefined,\n    isMenuHidden: true,\n  }));\n\n  const flat = dbPages.concat(upsertPages);\n\n  // NB: to make the NestedWebPage[], we don't want the pageData.\n  const flatWithoutPageData: WebPage[] = flat\n    .filter((x) => !x.isMenuHidden)\n    .map((x) => {\n      return { ...x, pageData: undefined, __check: true };\n    });\n\n  const nestedObject = makeNestedObjectFromQueryPathObject(\n    flatWithoutPageData,\n    {}\n  );\n\n  const keyToWebPage = (nestedObject: NestedObject<WebPage>, key: string) => {\n    return { pageData: undefined, queryPath: \"\" };\n  };\n\n  const nested: NestedWebPage[] = nestedObjectToChildObject(\n    nestedObject,\n    keyToWebPage\n  );\n\n  return {\n    flat,\n    nested,\n  };\n}",
  "name": "getNestedDatabaseMenu",
  "slug": "get-nested-database-menu",
  "parameters": [
    {
      "name": "config",
      "schema": {
        "type": "object",
        "properties": {
          "noOperationPath": {
            "type": "boolean"
          },
          "noOperationName": {
            "type": "boolean"
          },
          "noSrcRelativeFolder": {
            "type": "boolean"
          },
          "noPrefix": {
            "type": "boolean"
          }
        },
        "additionalProperties": false
      },
      "simplifiedSchema": {
        "properties": [
          {
            "name": "noOperationPath",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "noOperationName",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "noSrcRelativeFolder",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "noPrefix",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "type": "object"
      },
      "required": false
    }
  ],
  "description": "TODO: support search for bundles (but this can be augmented word based)",
  "returnType": {
    "rawType": "Promise<{ flat?: import(\"/Users/king/King/operations/tools/types/webpage-types/build/types\").WebPage<undefined>[] | undefined; nested?: import(\"/Users/king/King/operations/tools/types/webpage-types/build/types\").NestedWebPage[] | undefined; }>",
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": false,
    "isPrimitive": false,
    "isEnumLiteral": false
  },
  "maxIndentationDepth": 3,
  "size": {
    "characters": 2420,
    "lines": 80,
    "bytes": 2420,
    "bytesPerCharacter": 1,
    "charactersPerLine": 30,
    "linesPerFile": 80,
    "numberOfFiles": 1
  },
  "id": "mxwsryxecfqfwqmmgfajzqac"
}