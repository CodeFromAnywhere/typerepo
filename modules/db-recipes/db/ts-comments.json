[
  {
    "createdAt": 1669985935723,
    "updatedAt": 1669985935723,
    "deletedAt": 0,
    "createdFirstAt": 1669985935723,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/validateInput.ts",
    "comment": "import Ajv from \"ajv\";",
    "rawStatement": "import { notEmpty } from \"js-util\";",
    "parameters": {},
    "types": [],
    "firstLine": 3,
    "lastLine": 3,
    "id": "fbcwjwjohnvosjsjxwpfnrcu"
  },
  {
    "createdAt": 1669985935723,
    "updatedAt": 1669985935723,
    "deletedAt": 0,
    "createdFirstAt": 1669985935723,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/validateInput.ts",
    "comment": "const ajv = new Ajv();",
    "rawStatement": "type ValidationResult = {\n  isValid: boolean;\n  errors?: { fieldStack: string[]; error: string }[];\n};",
    "parameters": {},
    "types": [],
    "firstLine": 7,
    "lastLine": 7,
    "id": "hdjfivzzwsgfapufjurgtumo"
  },
  {
    "createdAt": 1669985935723,
    "updatedAt": 1669985935723,
    "deletedAt": 0,
    "createdFirstAt": 1669985935723,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/validateInput.ts",
    "comment": "wrapper function that takes that data but also the interface of the function and validates the parameters before it executes the function.",
    "rawStatement": "export const validateInput = <TFunctionName extends keyof typeof sdk>(\n  functionName: TFunctionName,\n  parameters: undefined | any[],\n  tsFunction: TsFunction\n): ValidationResult => {\n  const invalidParameters =\n    tsFunction.parameters\n      ?.map((parameter, index) => {\n        if (!parameter.schema) return;\n\n        // NB: we have a problem now because of the references missing. Recursively including all references every time can be hard though, that is another indexation step probably... May also become quite slow given the side of these schemas. We can either try and create a mapped validation object that includes the schemas for every function or we can try to use typescript-json instead, that may be easier, and better since we already need that for the backend as well. The last option would be to validate it ourselves using our own SimplifiedSchema. A validator for that would be useful anyway because it can also be used at the frontend with SimplifiedSchemaForm.\n        // const validate = ajv.compile(parameter.schema);\n        // const isValid = validate(value);\n\n        const value = parameters?.[index];\n\n        const isValid = true;\n        if (isValid) return;\n\n        return { isValid, parameter, value };\n      })\n      .filter(notEmpty) || [];\n\n  const isValid = invalidParameters.length === 0;\n  if (!isValid) {\n    log(\n      `According to the schema, you have given invalid arguments to the function`,\n      { type: \"warning\" }\n    );\n    console.dir({ invalidParameters }, { depth: 99 });\n  }\n\n  return { isValid };\n};",
    "parameters": {},
    "types": [],
    "firstLine": 14,
    "lastLine": 14,
    "id": "rljfhompjrgsynzpnglsonnh"
  }
]