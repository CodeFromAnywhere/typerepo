{
  "createdAt": 1662718706729,
  "updatedAt": 1662718706729,
  "deletedAt": 0,
  "createdFirstAt": 1662718706729,
  "apiAuthenticationStrategy": "admin",
  "isApiExposed": true,
  "isExported": true,
  "operationRelativeTypescriptFilePath": "src/createDb.ts",
  "commentsInside": [],
  "rawText": " <TModels extends AnyModelObject>(\n  dbConfig?: DbConfig<TModels>\n): Db<TModels> => {\n  const getByFile = async <TModelName extends Keys<TModels>>(\n    modelName: TModelName,\n    config?: CustomQueryConfig\n  ) => {\n    const mergedQueryConfig = mergeConfigs(modelName, dbConfig, config);\n    const dbFiles = await getDatabaseFiles(modelName, mergedQueryConfig);\n    //console.log(\"getByFile\", { modelName, mergedQueryConfig, dbFiles });\n\n    const dbContentPromises = dbFiles.map(async (dbFileLocation) => {\n      const items = await getAugmentedData<TModels[TModelName]>(\n        dbFileLocation,\n        mergedQueryConfig.dbStorageMethod\n      );\n      if (!items) return;\n      return { [dbFileLocation.absolutePath]: items };\n    });\n\n    const dbContent = (await Promise.all(dbContentPromises)).filter(notEmpty);\n    const dbContentObject = mergeObjectsArray(dbContent);\n\n    //console.log({ dbContentObject });\n    return dbContentObject;\n  };\n\n  const get: DbGet<TModels> = async <TModelName extends Keys<TModels>>(\n    modelName: TModelName,\n    config?: CustomQueryConfig\n  ) => {\n    const items = (\n      Object.values(\n        await getByFile(modelName, config)\n      ) as TModels[TModelName][][]\n    ).flat();\n    return items;\n  };\n\n  /**\n   *\n   */\n  const clear = async <TModelName extends Keys<TModels>>(\n    modelName: TModelName,\n    config?: CustomQueryConfig\n  ) => {\n    const mergedConfig = mergeConfigs(modelName, dbConfig, config);\n    const locations = await getDatabaseFiles(modelName, mergedConfig);\n\n    await mapMany(\n      locations,\n      async (loc) => fs.existsSync(loc.absolutePath) && fs.rm(loc.absolutePath),\n      maxConcurrency\n    );\n\n    return {\n      amountRemoved: locations.length,\n      isSuccesful: true,\n      message: `${locations.length} files removed`,\n    };\n  };\n\n  const set: DbSet<TModels> = async <TModelName extends Keys<TModels>>(\n    modelName: TModelName,\n    data: Creation<TModels[TModelName]>[],\n    config?: CustomQueryConfig\n  ) => {\n    const mergedConfig = mergeConfigs(modelName, dbConfig, config);\n    const { dbStorageMethod } = mergedConfig;\n    const itemsPerFile = await groupByFile(data, mergedConfig, modelName);\n    const locations = await getDatabaseFiles(modelName, mergedConfig);\n\n    const upsertResults = // NB: ensure not to open too many files at once\n      (\n        await mapMany(\n          locations,\n          async (dbFileLocation) => {\n            // First remove the file\n            if (fs.existsSync(dbFileLocation.absolutePath)) {\n              log(`Removing ${dbFileLocation.absolutePath}`, { type: \"debug\" });\n              await fs.rm(dbFileLocation.absolutePath);\n            }\n\n            // Then, if there are new items for that file location, also set that file to contain the new items\n            const itemsObject = itemsPerFile[dbFileLocation.absolutePath];\n            if (itemsObject) {\n              log(`set new values to there: ${itemsObject.items.length}`, {\n                type: \"debug\",\n              });\n\n              const result = await upsertItems<TModels, TModelName>(\n                dbStorageMethod,\n                dbFileLocation,\n                itemsObject.items\n              );\n              return result;\n            }\n          },\n          maxConcurrency\n        )\n      ).filter(notEmpty);\n\n    const amountInserted = sum(upsertResults.map((x) => x.amountInserted || 0));\n\n    return {\n      isSuccesful: true,\n      amountInserted,\n    };\n  };\n\n  const upsert: DbUpsert<TModels> = async <TModelName extends Keys<TModels>>(\n    modelName: TModelName,\n    data: Creation<TModels[TModelName]> | Creation<TModels[TModelName]>[],\n    config?: UpsertQueryConfig\n  ) => {\n    const mergedConfig = mergeConfigs(modelName, dbConfig, config);\n    const { dbStorageMethod } = mergedConfig;\n    const creationItems = makeArray(data);\n\n    //  splits the items into the needed files\n    const dataPerStorageFile = await groupByFile(\n      creationItems,\n      mergedConfig,\n      modelName\n    );\n\n    //  upserts items for every file, grouped, efficiently.\n    const result = await mapMany(\n      Object.keys(dataPerStorageFile),\n      async (absolutePath) => {\n        const itemsObject = dataPerStorageFile[absolutePath];\n        const { dbFileLocation, items } = itemsObject;\n        if (config?.removeUntouched && fs.existsSync(absolutePath)) {\n          await fs.rm(absolutePath);\n        }\n\n        const result = await upsertItems<TModels, TModelName>(\n          dbStorageMethod,\n          dbFileLocation,\n          items\n        );\n\n        return result;\n      },\n      maxConcurrency\n    );\n\n    return {\n      isSuccesful: true,\n      message: `Upserted into ${result.length} files`,\n    };\n  };\n\n  const remove: DbRemove<TModels> = async <TModelName extends Keys<TModels>>(\n    modelName: TModelName,\n    removeWhere: (content: TModels[TModelName]) => boolean,\n    config?: CustomQueryConfig\n  ) => {\n    const mergedQueryConfig = mergeConfigs(modelName, dbConfig, config);\n    const dbFiles = await getDatabaseFiles(modelName, mergedQueryConfig);\n\n    const amountRemovedArray = await mapMany(\n      dbFiles,\n      async (dbFileLocation) => {\n        const { amountRemoved } = await removeMultiple(\n          mergedQueryConfig.dbStorageMethod,\n          dbFileLocation,\n          (content) => removeWhere(content as TModels[TModelName])\n        );\n\n        return amountRemoved || 0;\n      },\n      maxConcurrency\n    );\n\n    const amountRemoved = sum(amountRemovedArray);\n\n    if (amountRemoved === 0) {\n      return { isSuccesful: false, message: \"Nothing removed\", amountRemoved };\n    }\n\n    return {\n      amountRemoved,\n      isSuccesful: true,\n      message: \"Items removed\",\n    };\n  };\n\n  const update: DbUpdate<TModels> = async <TModelName extends Keys<TModels>>(\n    modelName: TModelName,\n    updateWhere: undefined | ((content: TModels[TModelName]) => boolean),\n    map: (oldValue: TModels[TModelName]) => TModels[TModelName],\n    config?: CustomQueryConfig\n  ) => {\n    // `get` -> `update` -> `groupByFile(newItems)` -> set (overwrite those files, remove leftover files)\n\n    const data = await get(modelName, config);\n\n    let amountUpdated = 0;\n\n    const newData: Creation<TModels[TModelName]>[] = data.map((item) => {\n      const needsUpdate = updateWhere ? updateWhere(item) : true;\n      if (needsUpdate) {\n        amountUpdated++;\n      }\n      return needsUpdate ? map(item) : item;\n    });\n\n    const { isSuccesful, message } = await set(modelName, newData, config);\n\n    const result: DbQueryResult = {\n      amountUpdated,\n      message,\n      isSuccesful,\n    };\n\n    return result;\n  };\n\n  return {\n    get,\n    getByFile,\n    clear,\n    upsert,\n    set,\n    remove,\n    update,\n  };\n}",
  "name": "createDb",
  "slug": "create-db",
  "parameters": [],
  "description": "Create your database by passing your models as a generic and some optional configuration",
  "returnType": {
    "rawType": "import(\"/Users/king/King/operations/tools/control-fs/fs-orm/src/types\").Db<TModels>",
    "typeDefinition": {
      "type": "object",
      "properties": {
        "get": {
          "type": "object",
          "properties": {}
        },
        "getByFile": {
          "type": "object",
          "properties": {}
        },
        "set": {
          "type": "object",
          "properties": {}
        },
        "remove": {
          "type": "object",
          "properties": {}
        },
        "update": {
          "type": "object",
          "properties": {}
        },
        "clear": {
          "type": "object",
          "properties": {}
        },
        "upsert": {
          "type": "object",
          "properties": {}
        }
      },
      "required": [
        "get",
        "getByFile",
        "set",
        "remove",
        "update",
        "clear",
        "upsert"
      ],
      "optional": false
    },
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": true,
    "isPrimitive": false,
    "isEnumLiteral": false,
    "simplifiedSchema": {
      "properties": [
        {
          "name": "get",
          "required": true,
          "schema": {
            "properties": [],
            "type": "object"
          }
        },
        {
          "name": "getByFile",
          "required": true,
          "schema": {
            "properties": [],
            "type": "object"
          }
        },
        {
          "name": "set",
          "required": true,
          "schema": {
            "properties": [],
            "type": "object"
          }
        },
        {
          "name": "remove",
          "required": true,
          "schema": {
            "properties": [],
            "type": "object"
          }
        },
        {
          "name": "update",
          "required": true,
          "schema": {
            "properties": [],
            "type": "object"
          }
        },
        {
          "name": "clear",
          "required": true,
          "schema": {
            "properties": [],
            "type": "object"
          }
        },
        {
          "name": "upsert",
          "required": true,
          "schema": {
            "properties": [],
            "type": "object"
          }
        }
      ],
      "type": "object"
    }
  },
  "maxIndentationDepth": 8,
  "size": {
    "characters": 6834,
    "lines": 229,
    "bytes": 6834,
    "bytesPerCharacter": 1,
    "charactersPerLine": 30,
    "linesPerFile": 229,
    "numberOfFiles": 1
  },
  "id": "AaXGcmbxdSYyUnYW"
}