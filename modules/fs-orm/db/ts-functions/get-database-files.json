{
  "createdAt": 1662752195731,
  "updatedAt": 1662752195731,
  "deletedAt": 0,
  "createdFirstAt": 1662752195731,
  "apiAuthenticationStrategy": "admin",
  "isApiExposed": true,
  "isExported": true,
  "operationRelativeTypescriptFilePath": "src/convention/getDatabaseFiles.ts",
  "commentsInside": [],
  "rawText": " async (\n  modelName: string,\n  mergedConfig: MergedQueryConfig\n): Promise<DbFileLocation[]> => {\n  const manualProjectRoot = mergedConfig?.manualProjectRoot;\n  const projectRoot = manualProjectRoot || getProjectRoot();\n  if (!projectRoot) return [];\n  const dbStorageMethod = mergedConfig.dbStorageMethod;\n\n  const shouldSearchOperations = mergedConfig.operationName !== null;\n  const shouldSearchProject = !mergedConfig.operationName;\n\n  const pattern = getLocationPattern(dbStorageMethod, modelName, mergedConfig);\n\n  let operationPath: string | undefined = undefined;\n\n  if (mergedConfig.operationName) {\n    operationPath = await getOperationPath(mergedConfig.operationName, {\n      manualProjectRoot,\n      notUseSdk: !!manualProjectRoot,\n    });\n\n    if (operationPath === undefined) {\n      log(`Operation wasn't found ${mergedConfig.operationName}`, {\n        type: \"warning\",\n      });\n      return [];\n    }\n  }\n\n  const realOperations = manualProjectRoot\n    ? await calculateOperationsObject(manualProjectRoot)\n    : operations;\n\n  const operationFolders: RootDbFolder[] = shouldSearchOperations\n    ? mergedConfig.operationName && operationPath\n      ? [\n          {\n            basePath: operationPath,\n            operationName: mergedConfig.operationName,\n          },\n        ]\n      : Object.keys(realOperations).map((operationName) => ({\n          basePath: realOperations[operationName],\n          operationName,\n        }))\n    : [];\n  const projectFolder: RootDbFolder | undefined = shouldSearchProject\n    ? { operationName: null, basePath: projectRoot }\n    : undefined;\n\n  const rootFolders: RootDbFolder[] = [\n    projectFolder,\n    ...operationFolders,\n  ].filter(notEmpty);\n\n  /**\n  based on configuration and convention, we will fill this array with the files to get data from\n\n  NB: this should contain the actual files, not the patterns\n   */\n  let dbFiles: DbFileLocation[] = [];\n\n  const isOperationFile =\n    !!mergedConfig.operationName &&\n    !!operationPath &&\n    !!mergedConfig.operationRelativePath;\n\n  if (isOperationFile && !!operationPath) {\n    const exactAbsoluteOperationFilePath = path.join(\n      operationPath,\n      mergedConfig.operationRelativePath!\n    );\n    //make sure that extension matches `dbStorageMethod`, warn otherwise\n    const customExt = mergedConfig.operationRelativePath\n      ? path.parse(mergedConfig.operationRelativePath).ext\n      : undefined;\n    const isWrongExtension =\n      customExt !== getDbStorageMethodExtension(dbStorageMethod);\n\n    if (isWrongExtension) {\n      log(\n        `Incorrect extension found in operationRelativePath, found ${customExt}`,\n        { type: \"warning\" }\n      );\n    }\n\n    const projectRelativePath = exactAbsoluteOperationFilePath.substring(\n      projectRoot.length\n    );\n    const operationRelativePath = exactAbsoluteOperationFilePath.substring(\n      operationPath.length\n    );\n\n    dbFiles.push({\n      modelName,\n      absolutePath: exactAbsoluteOperationFilePath,\n      operationName: mergedConfig.operationName!,\n      projectRelativePath,\n      operationRelativePath,\n    });\n  }\n\n  if (!isOperationFile && mergedConfig.projectRelativePath) {\n    const absolutePath = path.join(\n      projectRoot,\n      mergedConfig.projectRelativePath\n    );\n    const operationName = null;\n    const projectRelativePath = mergedConfig.projectRelativePath;\n\n    dbFiles.push({\n      modelName,\n      absolutePath,\n      operationName,\n      projectRelativePath,\n    });\n  }\n\n  if (!mergedConfig.projectRelativePath && !isOperationFile && pattern) {\n    // no exact path\n\n    const conventionedPaths: DbFileLocation[] = (\n      await Promise.all(\n        rootFolders.map(async (rootFolder) => {\n          const absolutePathPattern = path.join(rootFolder.basePath, pattern);\n          const projectRelativePath = absolutePathPattern.substring(\n            projectRoot.length\n          );\n          const operationRelativePath = absolutePathPattern.substring(\n            rootFolder.basePath.length\n          );\n\n          const parsedPath = path.parse(absolutePathPattern);\n          const ext = parsedPath.ext;\n\n          if (parsedPath.name === \"*\") {\n            if (fs.existsSync(parsedPath.dir)) {\n              const fileNames: DbFileLocation[] = (\n                await fs.readdir(parsedPath.dir)\n              )\n                .filter((fileName) => fileName.endsWith(ext))\n                .map((fileName) => {\n                  const absolutePath = path.join(parsedPath.dir, fileName);\n                  const projectRelativePath = absolutePath.substring(\n                    projectRoot.length\n                  );\n                  const operationRelativePath = absolutePath.substring(\n                    rootFolder.basePath.length\n                  );\n                  const dbFileLocation: DbFileLocation = {\n                    modelName,\n                    absolutePath,\n                    operationName: rootFolder.operationName,\n                    projectRelativePath,\n                    operationRelativePath,\n                  };\n\n                  return dbFileLocation;\n                });\n\n              return fileNames;\n            }\n\n            return [];\n          } else {\n            const dbFileLocation: DbFileLocation = {\n              modelName,\n              absolutePath: absolutePathPattern,\n              operationName: rootFolder.operationName,\n              projectRelativePath,\n              operationRelativePath,\n            };\n            return [dbFileLocation];\n          }\n        })\n      )\n    ).flat();\n\n    dbFiles = dbFiles.concat(conventionedPaths);\n  }\n\n  return dbFiles;\n}",
  "name": "getDatabaseFiles",
  "slug": "get-database-files",
  "parameters": [],
  "description": "This function gets the files that the data can be stored, by convention, based on the model and the config\n\nOnly returns the file paths that actually exist.\n\nCONVENTION:\n\nWhen searching for data, `fs-orm` will look in:\n- `db/` in your project root\n- `db/` in any operation\n\nIn these folders, `fs-orm` will search for files based on your storage method.\n@see DbStorageMethod for more info\n\nReturns not only the file paths, but also where they were found (`operationName, projectRelativePath, operationRelativePath`)",
  "returnType": {
    "rawType": "Promise<import(\"/Users/king/King/operations/tools/types/model-types/build/any-model\").DbFileLocation[]>",
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": false,
    "isPrimitive": false,
    "isEnumLiteral": false
  },
  "maxIndentationDepth": 10,
  "size": {
    "characters": 6151,
    "lines": 197,
    "bytes": 6151,
    "bytesPerCharacter": 1,
    "charactersPerLine": 31,
    "linesPerFile": 197,
    "numberOfFiles": 1
  },
  "id": "fKGBtorgAdvYJVXu"
}