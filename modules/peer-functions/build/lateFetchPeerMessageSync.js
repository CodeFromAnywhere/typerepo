"use strict";var __assign=this&&this.__assign||function(){return __assign=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var a in t=arguments[n])Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a]);return e},__assign.apply(this,arguments)},__awaiter=this&&this.__awaiter||function(e,t,n,r){return new(n||(n=Promise))((function(a,o){function s(e){try{u(r.next(e))}catch(e){o(e)}}function i(e){try{u(r.throw(e))}catch(e){o(e)}}function u(e){var t;e.done?a(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,i)}u((r=r.apply(e,t||[])).next())}))},__generator=this&&this.__generator||function(e,t){var n,r,a,o,s={label:0,sent:function(){if(1&a[0])throw a[1];return a[1]},trys:[],ops:[]};return o={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function i(o){return function(i){return function(o){if(n)throw new TypeError("Generator is already executing.");for(;s;)try{if(n=1,r&&(a=2&o[0]?r.return:o[0]?r.throw||((a=r.return)&&a.call(r),0):r.next)&&!(a=a.call(r,o[1])).done)return a;switch(r=0,a&&(o=[2&o[0],a.value]),o[0]){case 0:case 1:a=o;break;case 4:return s.label++,{value:o[1],done:!1};case 5:s.label++,r=o[1],o=[0];continue;case 7:o=s.ops.pop(),s.trys.pop();continue;default:if(!(a=s.trys,(a=a.length>0&&a[a.length-1])||6!==o[0]&&2!==o[0])){s=0;continue}if(3===o[0]&&(!a||o[1]>a[0]&&o[1]<a[3])){s.label=o[1];break}if(6===o[0]&&s.label<a[1]){s.label=a[1],a=o;break}if(a&&s.label<a[2]){s.label=a[2],s.ops.push(o);break}a[2]&&s.ops.pop(),s.trys.pop();continue}o=t.call(e,s)}catch(e){o=[6,e],r=0}finally{n=a=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,i])}}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.lateFetchPeerMessageSync=void 0;var database_1=require("database"),api_1=require("api"),js_util_1=require("js-util"),port_conventions_1=require("port-conventions"),one_by_one_1=require("one-by-one"),lateFetchPeerMessageSync=function(){return __awaiter(void 0,void 0,void 0,(function(){var e,t,n;return __generator(this,(function(r){switch(r.label){case 0:return[4/*yield*/,database_1.db.get("Peer",{include:{referenceKey:"personId"}})];case 1:return e=r.sent(),[4/*yield*/,(0,one_by_one_1.oneByOne)(e,(function(e){return __awaiter(void 0,void 0,void 0,(function(){var t,n,r,a,o;return __generator(this,(function(s){switch(s.label){case 0:return t=e.lastSyncDatabaseAtObject.PeerMessage,[4/*yield*/,api_1.apiWithConfig.getDbModel({apiUrl:"http://".concat(e.name,":").concat(port_conventions_1.ports["function-server"]),authToken:e.authToken,timeout:2e3},"PeerMessage",{dataFilters:[{objectParameterKey:"peerSlug",operator:"equal",value:e.slug},{
// updatedAt is better than createdAt because it can also work if the model can be updated and if the messages can be edited for example. The id stays the same so upsert will overwrite it
objectParameterKey:"updatedAt",operator:"gt",value:t}]})];case 1:return n=s.sent(),(r=null===(o=n.result)||void 0===o?void 0:o.data)?[4/*yield*/,database_1.db.upsert("PeerMessage",r)]:[2/*return*/];case 2:return a=s.sent(),[4/*yield*/,database_1.db.update("Peer",(function(t){return t.name===e.name}),(function(e){return __assign(__assign({},e),{lastOnlineAt:Date.now(),lastSyncDatabaseAtObject:__assign(__assign({},e.lastSyncDatabaseAtObject),{PeerMessage:Date.now()})})}))];case 3:return s.sent(),[2/*return*/,a]}}))}))}))];case 2:return t=r.sent(),n=function(e,t){return e+t},[2/*return*/,{newMessagesAmount:t.filter(js_util_1.notEmpty).map((function(e){return e.amountInserted})).filter(js_util_1.notEmpty).reduce(n,0)}]}}))}))};exports.lateFetchPeerMessageSync=lateFetchPeerMessageSync;
//# sourceMappingURL=lateFetchPeerMessageSync.js.map