[
  {
    "createdAt": 1662732861762,
    "updatedAt": 1662732861762,
    "deletedAt": 0,
    "createdFirstAt": 1662732861762,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/getImportsExports.ts",
    "comment": "get the ImportSpecifier(s) of with a certain name.",
    "rawStatement": "const getImportSpecifiersWithNames = (\n  sourceFile: SourceFile,\n  names: string[]\n) => {\n  return sourceFile\n    .getImportDeclarations()\n    .map((x) => x.getNamedImports())\n    .flat()\n    .filter((x) => names.includes(x.getName()));\n};",
    "parameters": {},
    "types": [],
    "firstLine": 72,
    "lastLine": 74,
    "id": "CSwmswFDtSRNstAy"
  },
  {
    "createdAt": 1662732861762,
    "updatedAt": 1662732861762,
    "deletedAt": 0,
    "createdFirstAt": 1662732861762,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/getImportsExports.ts",
    "comment": "",
    "rawStatement": "const getImportSpecifiersWithNames = (\n  sourceFile: SourceFile,\n  names: string[]\n) => {\n  return sourceFile\n    .getImportDeclarations()\n    .map((x) => x.getNamedImports())\n    .flat()\n    .filter((x) => names.includes(x.getName()));\n};",
    "parameters": {},
    "types": [],
    "firstLine": 84,
    "lastLine": 84,
    "id": "zSKYxQipKxcOFMys"
  },
  {
    "createdAt": 1662732861762,
    "updatedAt": 1662732861762,
    "deletedAt": 0,
    "createdFirstAt": 1662732861762,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/getImportsExports.ts",
    "comment": "gets type of a symbol and if the type has a generic, without recursing.",
    "rawStatement": "const getDefaultSymbolType = (\n  symbol: Symbol,\n  debug?: boolean\n): TypeSpecifier => {\n  if (debug) {\n    console.log({\n      kinds: symbol\n        .getDeclarations()\n        .map((x) => ({ kind: x.getKindName(), name: x.getText() })),\n    });\n  }\n  const symbolTypeDeclarations = getSymbolTypeDeclarations(symbol);\n\n  const type = symbolTypeDeclarations.length > 0 ? \"type\" : \"value\";\n  /**\n   * checks whether the symbol contains a type declaration which has a generic parameter\n   */\n  const hasGeneric =\n    type === \"type\"\n      ? !!symbolTypeDeclarations.find(\n          // NB: type parameters gets the generics\n          (declaration) => getHasGeneric(declaration)\n        )\n      : undefined;\n\n  return { type, hasGeneric };\n};",
    "parameters": {},
    "types": [],
    "firstLine": 86,
    "lastLine": 88,
    "id": "JurGHQjwPAJKndTy"
  },
  {
    "createdAt": 1662732861762,
    "updatedAt": 1662732861762,
    "deletedAt": 0,
    "createdFirstAt": 1662732861762,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/getImportsExports.ts",
    "comment": "gets type of exportSymbols. recurses if it's an exportsymbol\n\nNB: exports that come from a destructured initialiser aren't found!\nTODO: fix this",
    "rawStatement": "const getExportSymbolType = (\n  symbol: Symbol,\n  sourceFile: SourceFile,\n  debug?: boolean\n): TypeSpecifier => {\n  const exportSpecifierNames = getExportSpecifierNames(symbol);\n\n  if (debug) console.log(exportSpecifierNames);\n\n  if (exportSpecifierNames.length > 0) {\n    // get the ImportSpecifier of this ExportSpecifier, and if one exists, recurse this function on it.\n\n    const importSpecifiers = getImportSpecifiersWithNames(\n      sourceFile,\n      exportSpecifierNames\n    );\n\n    if (importSpecifiers.length > 1) {\n      // NB: warn if there is more than one as that would be strange\n\n      log(\n        `More than one importsSpecifiers with that name: ${exportSpecifierNames.join(\n          \",\"\n        )} (imports: ${importSpecifiers\n          .map((x) => x.getName())\n          .join(\",\")})... file: ${sourceFile.getFilePath()}`,\n        {\n          type: \"warning\",\n        }\n      );\n    }\n\n    if (importSpecifiers.length > 0) {\n      return getTypeFromImportSpecifier(importSpecifiers[0], debug);\n    }\n\n    /* REmoved this.... seems that this will make it never do the default one\n    else {\n      if (debug) {\n        console.log(\n          \"Weird, we couldn't find the importspecifier for exportSpecifiers\"\n        );\n      }\n      return { type: undefined };\n    }\n    */\n  }\n\n  return getDefaultSymbolType(symbol, debug);\n};",
    "parameters": {},
    "types": [
      "todo",
      "nb"
    ],
    "firstLine": 117,
    "lastLine": 122,
    "id": "ZqCdJFSmgHwQppPS"
  },
  {
    "createdAt": 1662732861762,
    "updatedAt": 1662732861762,
    "deletedAt": 0,
    "createdFirstAt": 1662732861762,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/getImportsExports.ts",
    "comment": "Uses ts-morph to get all exports inside all files in a project or an array of source files.\nDoesn't use index, it actually looks in all files except index,\nso some of them may not be exported from the package itself depending on your indexing strategy!",
    "rawStatement": "export const getImportsExports = async ({\n  sourceFiles,\n  debug,\n  manualProjectRoot,\n}: {\n  /**\n   * if given, only these sourcefiles are used, otherwise takes all source files from project.\n   */\n  sourceFiles: SourceFile[];\n  debug?: boolean;\n  manualProjectRoot?: string;\n}): Promise<ImportsAndExports | undefined> => {\n  if (sourceFiles.length === 0) {\n    log(\"No source files provided\", { type: \"warning\" });\n    return;\n  }\n\n  const allOperationsPaths = await exploreOperationFolders({\n    basePath: manualProjectRoot,\n  });\n  const allOperations = allOperationsPaths.map(getLastFolder);\n  const firstFilePath = sourceFiles[0].getFilePath();\n  if (!firstFilePath) return;\n\n  const operationBasePath = findOperationBasePath(firstFilePath);\n  if (!operationBasePath) return;\n\n  const packageJson = await readJsonFile<PackageJson>(\n    path.join(operationBasePath, \"package.json\")\n  );\n\n  if (!packageJson) {\n    log(\"PackageJson could not be found\", { type: \"error\" });\n    return;\n  }\n\n  const importsAndExports = sourceFiles.reduce(\n    (importsAndExports, sourceFile) => {\n      const exportSymbols: Symbol[] = sourceFile.getExportSymbols();\n      let exports: Creation<TsExport>[] = exportSymbols\n        .map((symbol) => {\n          const name = symbol.getName();\n          const { type, hasGeneric } = getExportSymbolType(\n            symbol,\n            sourceFile,\n            debug\n          );\n\n          const absoluteFilePath = sourceFile.getFilePath();\n          if (!absoluteFilePath) return;\n          const operationPathParse = getOperationPathParse(absoluteFilePath);\n          if (!operationPathParse) return;\n\n          const exportObject: Creation<TsExport> = {\n            name,\n            slug: kebabCase(name),\n            operationRelativeTypescriptFilePath:\n              operationPathParse.operationRelativeTypescriptFilePath,\n            // TODO:\n            comments: [],\n            type,\n            hasGeneric,\n            // For testing purposes: kinds,\n          };\n          return exportObject;\n        })\n        .filter(notEmpty);\n\n      let imports: Creation<TsImport>[] = [];\n      const allImports: ImportDeclaration[] =\n        sourceFile.getImportDeclarations();\n\n      allImports.forEach((importDeclaration) => {\n        const module = String(\n          importDeclaration.getModuleSpecifier().getLiteralText()\n        );\n        const namedImports: NamedImport[] = importDeclaration\n          .getNamedImports()\n          .map((x) => {\n            const name = x.getName();\n            const namedImport: NamedImport = {\n              name,\n              slug: kebabCase(name),\n              ...getTypeFromImportSpecifier(x, debug),\n            };\n\n            return namedImport;\n          });\n\n        const newImports: Creation<TsImport>[] = namedImports\n          .map((namedImport) => {\n            const filePath = sourceFile.getFilePath();\n\n            const operationPathParse = getOperationPathParse(filePath);\n\n            if (!operationPathParse) return;\n\n            const nodeModules = [\"fs\", \"path\"];\n            const reactModules = [\"react\", \"react-dom\", \"react-native\", \"expo\"];\n            const classification: ImportClassification = nodeModules.includes(\n              module\n            )\n              ? \"node\"\n              : reactModules.includes(module)\n              ? \"react\"\n              : allOperations.includes(module)\n              ? \"operation\"\n              : !isAbsoluteImport(module)\n              ? \"internal\"\n              : \"package\";\n\n            const importObject: Creation<TsImport> = {\n              ...namedImport,\n              module,\n              // TODO\n              comments: [],\n              operationRelativeTypescriptFilePath:\n                operationPathParse.operationRelativeTypescriptFilePath,\n\n              classification,\n              isAbsolute: isAbsoluteImport(module),\n              isModuleFromMonorepo: allOperations.includes(module),\n              // NB: will not be resolved if build folder doesn't exist or if entry file doesn't exist\n              isModuleResolved:\n                !!importDeclaration.getModuleSpecifierSourceFile(),\n            };\n\n            return importObject;\n          })\n          .filter(notEmpty);\n\n        imports = imports.concat(newImports);\n      });\n\n      return {\n        imports: importsAndExports.imports.concat(imports),\n        exports: importsAndExports.exports.concat(exports),\n      };\n    },\n    { imports: [], exports: [] } as ImportsAndExports\n  );\n\n  return importsAndExports;\n};",
    "parameters": {},
    "types": [],
    "firstLine": 251,
    "lastLine": 255,
    "id": "YQDzQMnWFXSgdaMS"
  }
]