{
  "createdAt": 1663305106307,
  "updatedAt": 1663305106307,
  "deletedAt": 0,
  "createdFirstAt": 1663305106307,
  "apiAuthenticationStrategy": "admin",
  "isApiExposed": true,
  "isExported": true,
  "operationRelativeTypescriptFilePath": "src/getDocsMarkdownReaderPages.ts",
  "commentsInside": [],
  "rawText": " async (config?: {\n  manualProjectRoot?: string;\n}): Promise<undefined | MarkdownReaderPage[]> => {\n  const projectRoot = config?.manualProjectRoot || getProjectRoot();\n  if (!projectRoot) return;\n\n  // the docs folder with all its files\n  const docsPath = path.join(projectRoot, \"docs\");\n\n  const relativeDocsPages: MarkdownReaderPage[] = (\n    await getPublicMarkdownFilePaths(docsPath, false)\n  ).map((x) => {\n    const filePath = makeRelative(x.path, projectRoot);\n    const queryPath = removeExtensionsFromPath(filePath);\n\n    // NB: folders are no menu items because menu is built from paths recursively\n    return { queryPath, filePath, isMenuItem: !x.isFolder };\n  });\n\n  const hasDocs = !!relativeDocsPages.find(\n    (x) => x.queryPath.toLowerCase() === \"docs/readme\"\n  );\n  if (!hasDocs) {\n    const hasRootReadme = fs.existsSync(path.join(projectRoot, \"README.md\"));\n    if (hasRootReadme) {\n      relativeDocsPages.unshift({\n        queryPath: \"docs/readme\",\n        filePath: \"README.md\",\n        isMenuItem: true,\n      });\n    }\n  }\n\n  // and all operations (readmes)\n  const operationBasePaths = getPathsWithOperations({\n    manualProjectRoot: projectRoot,\n  });\n\n  const operationPagesPerType: { [key: string]: MarkdownReaderPage[] } =\n    mergeObjectsArray(\n      await Promise.all(\n        operationBasePaths.map(async (basePath) => {\n          const folders = (await exploreOperationFolders({ basePath })).map(\n            (result) => ({\n              projectRelativePath: makeRelative(result, projectRoot),\n            })\n          );\n\n          console.log({ folders });\n\n          const pages: MarkdownReaderPage[] = folders.map((folder) => {\n            const folderName = getLastFolder(folder.projectRelativePath);\n\n            return {\n              queryPath: folder.projectRelativePath,\n              // operation filePath is README.md\n              filePath: path.join(folder.projectRelativePath, \"README.md\"),\n              internalLinkWord: folderName,\n              isMenuItem: true,\n            };\n          });\n\n          const projectRelativeBasePath = makeRelative(basePath, projectRoot);\n\n          return { [projectRelativeBasePath]: pages };\n        })\n      )\n    );\n  // NB: we need to get the right order, so it needs to be done separately\n  const operationPages: MarkdownReaderPage[] = isSensibleProject(projectRoot)\n    ? [\n        ...operationPagesPerType.packages,\n        ...operationPagesPerType.apps,\n        ...operationPagesPerType.modules,\n      ]\n    : [\n        ...operationPagesPerType[\"operations/tools\"],\n        ...operationPagesPerType[\"operations/bundles\"],\n      ];\n\n  const tsVariables = await db.get(\"TsVariable\", {\n    manualProjectRoot: projectRoot,\n  });\n\n  const tsFunctions = await db.get(\"TsFunction\", {\n    manualProjectRoot: projectRoot,\n  });\n  const tsInterfaces = await db.get(\"TsInterface\", {\n    manualProjectRoot: projectRoot,\n  });\n\n  const typescriptPages: MarkdownReaderPage[] = [\n    ...tsVariables,\n    ...tsFunctions,\n    ...tsInterfaces,\n  ]\n    .map((item) => {\n      const operationPath = findOperationBasePath(\n        path.join(projectRoot, item.projectRelativePath)\n      );\n      if (!operationPath) return;\n      const projectRelativeOperationPath = makeRelative(\n        operationPath,\n        projectRoot\n      );\n      const page: MarkdownReaderPage = {\n        internalLinkWord: item.name,\n        queryPath: `${projectRelativeOperationPath}#${item.name}`,\n        filePath: path.join(projectRelativeOperationPath, \"README.md\"),\n        isMenuItem: false,\n      };\n      return page;\n    })\n    .filter(notEmpty);\n\n  // const wordInclude: Include[] = [\n  //   { referenceKey: \"english_wordSlug\" },\n  //   { referenceKey: \"root_wordSlug\" },\n  //   { referenceKey: \"common_wordSlug\" },\n  //   { referenceKey: \"definition_statementId\" },\n  // ];\n  const words = await db.get(\"Word\", {\n    manualProjectRoot: projectRoot,\n    // include: wordInclude,\n  });\n  const statements = await db.get(\"Statement\", {\n    manualProjectRoot: projectRoot,\n    // include: { referenceKey: \"wordSlugs\", items: words, include: wordInclude },\n  });\n\n  const statementPages: MarkdownReaderPage[] = statements.map((item) => {\n    const page: MarkdownReaderPage = {\n      queryPath: `statement/${item.slug}`,\n      statementId: item.id,\n    };\n    return page;\n  });\n\n  const wordPages: MarkdownReaderPage[] = words.map((item) => {\n    const page: MarkdownReaderPage = {\n      queryPath: `word/${item.slug}`,\n      wordSlug: item.slug,\n      internalLinkWord: item.name,\n      isMenuItem: false,\n    };\n\n    return page;\n  });\n\n  /*\n\n- variables, interfaces, functions lead to the operation readme with a hash\n- words lead to /word/[slug] and have internalLinkWord [name]\n- statements lead to /statement/[slug] but have no internalLinkWord. They are defined in `> markdown quote syntax or ==highlight syntax==` and should become clickable\n\n*/\n  const allPages: MarkdownReaderPage[] = [\n    { queryPath: \"\", filePath: \"README.md\", isMenuItem: true },\n    ...relativeDocsPages,\n    ...operationPages,\n    ...typescriptPages,\n    ...statementPages,\n    ...wordPages,\n  ].filter(\n    onlyUnique2<MarkdownReaderPage>((a, b) => a.queryPath === b.queryPath)\n  );\n\n  return allPages;\n}",
  "name": "getDocsMarkdownReaderPages",
  "slug": "get-docs-markdown-reader-pages",
  "parameters": [
    {
      "name": "config",
      "schema": {
        "type": "object",
        "properties": {
          "manualProjectRoot": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "simplifiedSchema": {
        "properties": [
          {
            "name": "manualProjectRoot",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "type": "object"
      },
      "required": false
    }
  ],
  "description": "- Gets all pages of a bundle based on the fs\n- README should always be on top in a folder.\n- numbers and extensions are omitted from paths, but still connected to the right file\n- If the docs doesn't have a readme, the /docs/readme path shows the root readme.\n\nDoes not include individual functions, interfaces, statements, word-definitions pages",
  "returnType": {
    "rawType": "Promise<import(\"/Users/king/King/operations/tools/deployment/bundling/bundle-util/src/types\").MarkdownReaderPage[] | undefined>",
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": false,
    "isPrimitive": false,
    "isEnumLiteral": false
  },
  "maxIndentationDepth": 7,
  "size": {
    "characters": 5593,
    "lines": 174,
    "bytes": 5593,
    "bytesPerCharacter": 1,
    "charactersPerLine": 32,
    "linesPerFile": 174,
    "numberOfFiles": 1
  },
  "id": "HFyefMEBdQNnEOnp"
}