{
  "createdAt": 1671225090374,
  "updatedAt": 1671225090374,
  "deletedAt": 0,
  "createdFirstAt": 1671225090374,
  "isApiExposed": true,
  "isExported": true,
  "groupAuthorization": {},
  "operationRelativeTypescriptFilePath": "src/upsertDevice.ts",
  "commentsInside": [],
  "rawText": " async (\n  serverContext: Context\n): Promise<Device | undefined> => {\n  // in your function\n  const executionId = generateUniqueId();\n  const performance: (PerformanceItem | undefined)[] = [];\n\n  performance.push(getNewPerformance(\"start\", executionId, true));\n\n  const authToken: string | undefined = serverContext.data?.authToken;\n  const ip = serverContext.ip;\n\n  if (!authToken || authToken.length < 24) {\n    console.log(\"warn upsert device: no authToken\");\n    return;\n  }\n\n  // NB: range: [ <low bound of IP block>, <high bound of IP block> ], the rest is described in the type interface\n  const ipLookup = (geoip.lookup(ip) || {}) as Partial<geoip.Lookup>;\n  const {\n    city,\n    area: positionRadiusKm,\n    ll,\n    country,\n    region,\n    timezone,\n  } = ipLookup;\n\n  const position: Position | undefined =\n    !!ll?.[0] && !!ll?.[1] ? { latitude: ll[0], longitude: ll[1] } : undefined;\n\n  const userAgent: IResult = parseUserAgent(\n    serverContext.req.get(\"User-Agent\")\n  );\n  performance.push(getNewPerformance(\"lookupIp\", executionId));\n\n  const devices = await db.get(\"Device\", { include: deviceInclude });\n  const alreadyDevices = devices.filter((x) => x.authToken === authToken);\n\n  if (alreadyDevices.length > 1) {\n    const idsToRemove = alreadyDevices.slice(1).map((x) => x.id);\n    const removeResult = await db.remove(\"Device\", (device) =>\n      idsToRemove.includes(device.id)\n    );\n    console.log(\"found multiple devices with the same authToken. removing:\", {\n      removeResult,\n    });\n  }\n\n  let alreadyDevice = alreadyDevices[0] ? alreadyDevices[0] : undefined;\n\n  performance.push(getNewPerformance(\"findAlreadyDevice\", executionId));\n\n  const ipInfo: IPInfo = {\n    ip,\n    city,\n    position,\n    positionRadiusKm,\n    country,\n    region,\n    timezone,\n  };\n\n  const origin = serverContext.req.get(\"Origin\") as string;\n  const referer = serverContext.req.get(\"Referrer\") as string;\n\n  performance.push(getNewPerformance(\"gatherIpInfo\", executionId));\n\n  if (!alreadyDevice) {\n    const upsertResult = await db.upsert(\"Device\", {\n      authToken,\n      id: generateId(),\n      authenticationMethods: [],\n      ...ipInfo,\n      lastOnlineAt: 0,\n      lastSyncDatabaseAtObject: {},\n      name: calculateDeviceName(ipInfo, userAgent),\n      origins: [origin],\n      previousIps: [],\n      userAgentString: userAgent.ua,\n      hasPapi: false,\n    });\n\n    alreadyDevice = (await db.get(\"Device\")).find(\n      (x) => x.authToken === authToken\n    );\n\n    // weird\n\n    if (!alreadyDevice) {\n      return undefined;\n    }\n  }\n\n  // NB: either a new device creation or updating an existing device\n  // console.log(\"device already\");\n  const currentIpInfo: IPInfo = {\n    ip: alreadyDevice.ip,\n    city: alreadyDevice.city,\n    position: alreadyDevice.position,\n    positionRadiusKm: alreadyDevice.positionRadiusKm,\n    country: alreadyDevice.country,\n    region: alreadyDevice.region,\n    timezone: alreadyDevice.timezone,\n  };\n\n  const previousIpsHasAlready =\n    !currentIpInfo.ip ||\n    alreadyDevice.previousIps.find((x) => x.ip === currentIpInfo.ip);\n  const newPreviousIps = previousIpsHasAlready\n    ? alreadyDevice.previousIps\n    : alreadyDevice.previousIps.concat(currentIpInfo);\n\n  const newIpStuff =\n    alreadyDevice.ip === ip ? {} : { ...ipInfo, previousIps: newPreviousIps };\n\n  const newOrigins = alreadyDevice.origins?.includes(origin)\n    ? alreadyDevice.origins\n    : alreadyDevice.origins.concat(origin);\n\n  const currentPersonCalculated = alreadyDevice.currentPersonId\n    ? alreadyDevice.persons?.find(\n        (x) => x.id === alreadyDevice?.currentPersonId\n      )\n    : undefined;\n\n  const updatedDevice: Device = {\n    ...alreadyDevice,\n    ...newIpStuff,\n    currentPersonCalculated,\n    origins: newOrigins,\n    userAgentString: userAgent.ua,\n  };\n\n  performance.push(\n    getNewPerformance(\"alreadyDevice_makeUpdatedDevice\", executionId)\n  );\n\n  await db.update(\n    \"Device\",\n    (item) => item.authToken === authToken,\n    () => updatedDevice\n  );\n\n  performance.push(\n    getNewPerformance(\"alreadyDevice_updateDevice\", executionId)\n  );\n\n  savePageVisit(alreadyDevice.id, ipInfo, referer);\n  // console.log(\"upsertDevice, already device\", performance);\n\n  return updatedDevice;\n}",
  "name": "upsertDevice",
  "slug": "upsert-device",
  "parameters": [],
  "description": "Returns device with all attached (logged in) `Person`s, and `currentPersonCalculated`\n\nEither finds the device and updates it according to the new request metadata, or creates a new device.\n\nShould never return `undefined` if the database functions...\n\nTODO: Use cookies (https://serverjs.io/documentation/reply/#cookie-) to login\n\nNeeded for having `authToken` with GET as well in a safe manner (e.g. for images)",
  "returnType": {
    "rawType": "Promise<import(\"/Users/king/King/operations/tools/purpose/p2p/peer-types/build/Device\").Device | undefined>",
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": false,
    "isPrimitive": false,
    "isEnumLiteral": false
  },
  "maxIndentationDepth": 4,
  "size": {
    "characters": 4652,
    "lines": 161,
    "bytes": 4652,
    "bytesPerCharacter": 1,
    "charactersPerLine": 29,
    "linesPerFile": 161,
    "numberOfFiles": 1
  },
  "id": "btsyimbeyhxroedzhhwikosp"
}