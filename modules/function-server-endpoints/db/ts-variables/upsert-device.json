{
  "createdAt": 1669055797769,
  "updatedAt": 1669055797769,
  "deletedAt": 0,
  "createdFirstAt": 1669055797769,
  "classification": "const",
  "comments": [],
  "isExported": true,
  "name": "upsertDevice",
  "slug": "upsert-device",
  "operationRelativeTypescriptFilePath": "src/upsertDevice.ts",
  "type": {
    "rawType": "(serverContext: import(\"/Users/king/King/operations/node_modules/@types/server/typings/common\").Context) => Promise<import(\"/Users/king/King/operations/tools/purpose/p2p/peer-types/build/Device\").Device | undefined>",
    "typeDefinition": {
      "type": "object",
      "properties": {},
      "optional": false
    },
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": true,
    "isPrimitive": false,
    "isEnumLiteral": false,
    "simplifiedSchema": {
      "properties": [],
      "type": "object"
    }
  },
  "value": "async (\n  serverContext: Context\n): Promise<Device | undefined> => {\n  // in your function\n  const executionId = generateUniqueId();\n  const performance: (PerformanceItem | undefined)[] = [];\n\n  performance.push(getNewPerformance(\"start\", executionId, true));\n\n  const authToken: string | undefined = serverContext.data?.authToken;\n  const ip = serverContext.ip;\n\n  if (!authToken || authToken.length < 24) {\n    console.log(\"warn upsert device: no authToken\");\n    return;\n  }\n\n  // NB: range: [ <low bound of IP block>, <high bound of IP block> ], the rest is described in the type interface\n  const ipLookup = (geoip.lookup(ip) || {}) as Partial<geoip.Lookup>;\n  const {\n    city,\n    area: positionRadiusKm,\n    ll,\n    country,\n    region,\n    timezone,\n  } = ipLookup;\n\n  const position: Position | undefined =\n    !!ll?.[0] && !!ll?.[1] ? { latitude: ll[0], longitude: ll[1] } : undefined;\n\n  const userAgent: IResult = parseUserAgent(\n    serverContext.req.get(\"User-Agent\")\n  );\n  performance.push(getNewPerformance(\"lookupIp\", executionId));\n\n  const devices = await db.get(\"Device\", { include: deviceInclude });\n\n  // HACK HACK HACK HACK HACK\n  // NB: Done because of the server crash that, probably, happens because there is no db-lock system yet\n  const firstDevice = devices[0];\n  if (firstDevice) return firstDevice;\n  // HACK HACK HACK HACK HACK\n\n  const alreadyDevice = devices.find((x) => x.authToken === authToken);\n\n  performance.push(getNewPerformance(\"findAlreadyDevice\", executionId));\n\n  const ipInfo: IPInfo = {\n    ip,\n    city,\n    position,\n    positionRadiusKm,\n    country,\n    region,\n    timezone,\n  };\n\n  const origin = serverContext.req.get(\"Origin\") as string;\n  const referer = serverContext.req.get(\"Referrer\") as string;\n\n  // server.reply\n  //   .cookie(\n  //     \"testje\",\n  //     authToken,\n\n  //     {\n  //       /**\n  //        * NB: VERY IMPORTANT In order to receive the cookie at other port or domain\n  //        */\n  //       sameSite: \"none\",\n  //       secure: true,\n  //       /**\n  //        * It turned out that Chrome won't set the cookie if the domain contains a port. Setting it for localhost (without port) is not a problem\n  //        */\n  //       domain: \"localhost\",\n  //     }\n  //   )\n\n  performance.push(getNewPerformance(\"gatherIpInfo\", executionId));\n\n  // NB: either a new device creation or updating an existing device\n  if (alreadyDevice) {\n    // console.log(\"device already\");\n    const currentIpInfo: IPInfo = {\n      ip: alreadyDevice.ip,\n      city: alreadyDevice.city,\n      position: alreadyDevice.position,\n      positionRadiusKm: alreadyDevice.positionRadiusKm,\n      country: alreadyDevice.country,\n      region: alreadyDevice.region,\n      timezone: alreadyDevice.timezone,\n    };\n\n    const previousIpsHasAlready =\n      !currentIpInfo.ip ||\n      alreadyDevice.previousIps.find((x) => x.ip === currentIpInfo.ip);\n    const newPreviousIps = previousIpsHasAlready\n      ? alreadyDevice.previousIps\n      : alreadyDevice.previousIps.concat(currentIpInfo);\n\n    const newIpStuff =\n      alreadyDevice.ip === ip ? {} : { ...ipInfo, previousIps: newPreviousIps };\n\n    const newOrigins = alreadyDevice.origins.includes(origin)\n      ? alreadyDevice.origins\n      : alreadyDevice.origins.concat(origin);\n\n    const currentPersonCalculated = alreadyDevice.currentPersonId\n      ? alreadyDevice.persons?.find(\n          (x) => x.id === alreadyDevice.currentPersonId\n        )\n      : undefined;\n\n    const updatedDevice: Device = {\n      ...alreadyDevice,\n      ...newIpStuff,\n      currentPersonCalculated,\n      origins: newOrigins,\n      userAgent,\n      userAgentString: userAgent.ua,\n    };\n\n    performance.push(\n      getNewPerformance(\"alreadyDevice_makeUpdatedDevice\", executionId)\n    );\n\n    await db.update(\n      \"Device\",\n      (item) => item.authToken === authToken,\n      () => updatedDevice\n    );\n\n    performance.push(\n      getNewPerformance(\"alreadyDevice_updateDevice\", executionId)\n    );\n\n    savePageVisit(alreadyDevice.id, ipInfo, referer);\n    // console.log(\"upsertDevice, already device\", performance);\n\n    return updatedDevice;\n  }\n\n  // console.log(\"new device\");\n  const newDevice: Creation<Device> = {\n    authToken,\n    authenticationMethods: [],\n    ...ipInfo,\n    lastOnlineAt: 0,\n    lastSyncDatabaseAtObject: {},\n    name: calculateDeviceName(ipInfo, userAgent),\n    origins: [origin],\n    previousIps: [],\n    userAgent,\n    userAgentString: userAgent.ua,\n    hasPapi: false,\n  };\n\n  performance.push(getNewPerformance(\"calculateNewDevice\", executionId));\n\n  //  console.log({ newDevice });\n  // Create new device\n  //@ts-ignore\n  const upsertResult = await db.upsert(\"Device\", newDevice, {\n    onlyInsert: true,\n  });\n\n  performance.push(getNewPerformance(\"upsertNewDevice\", executionId));\n\n  // console.log({ upsertResult });\n\n  const fullNewDevice = (\n    await db.get(\"Device\", { include: deviceInclude })\n  ).find((x) => x.authToken === authToken);\n\n  performance.push(getNewPerformance(\"getFullNewDevice\", executionId));\n\n  if (fullNewDevice) {\n    savePageVisit(fullNewDevice.id, ipInfo, referer);\n  }\n\n  const currentPersonCalculated = fullNewDevice?.currentPersonId\n    ? fullNewDevice.persons?.find((x) => x.id === fullNewDevice.currentPersonId)\n    : undefined;\n\n  const finalNewDevice: Device | undefined = fullNewDevice\n    ? { ...fullNewDevice, currentPersonCalculated }\n    : undefined;\n\n  performance.push(getNewPerformance(\"calculateMetadata\", executionId));\n\n  // console.log(\"upsertDevice\", performance);\n  return finalNewDevice;\n}",
  "description": "Returns device with all attached (logged in) `Person`s, and `currentPersonCalculated`\n\nEither finds the device and updates it according to the new request metadata, or creates a new device.\n\nShould never return `undefined` if the database functions...\n\nTODO: Use cookies (https://serverjs.io/documentation/reply/#cookie-) to login\n\nNeeded for having `authToken` with GET as well in a safe manner (e.g. for images)",
  "id": "xrxhqxkjccuxwidnsnykibtn"
}