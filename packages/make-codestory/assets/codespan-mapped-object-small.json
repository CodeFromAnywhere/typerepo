{
  "automatePuppeteer": {
    "name": "automatePuppeteer",
    "slug": "TsFunction",
    "id": "cdrzudtkadyyblnxsykywggt",
    "description": "",
    "operationName": "ai-browser",
    "rawText": " (target: string, url: string, html: string) => {\n  const prompt = `\nI need to write an end to end browser automation test. I am starting here: ${url}, and I need to represent a user that is looking for ${target}.\n\nWhat would be the steps involved to achieve that target? What would be good puppeteer commands, provided the below content of ${url}?\n\n\\`\\`\\`\n\n${html}\n\n\\`\\`\\`\n\n\n`;\n}"
  },
  "browseInternet": {
    "name": "browseInternet",
    "slug": "TsFunction",
    "id": "tnldajnmuygkfkqsnddfclax",
    "description": "",
    "operationName": "ai-browser",
    "rawText": " async (\n  url: string,\n  level: number,\n  target: string\n) => {\n  const html = await fetchUrl(url);\n  // html is too big, we need to simplify the format first.\n  const md = html2md(html, {});\n  // const links1 = findLinks(md)\n  //   .map((x) =>\n  //     x.href.startsWith(\"https://\")\n  //       ? x.href\n  //       : `https://${new URL(url).hostname}/${x.href}`\n  //   )\n  //   .join(\"\\n\");\n\n  const result = await controlChatGptWrapper(\n    `\nThis is a simulation. You are not a language-bot. You are a human person and you are browsing the internet, and you stubmled upon this page: ${url}.\n\nYou are looking for \"${target}\" but there is no direct link. \n\nThis is the returned markdown:\n    \n\\`\\`\\`\n${md}\n\\`\\`\\`\n\nWhich page would you go to to come closer to \"${target}\"?\nChoose one of the above links.\n`,\n    false,\n    undefined,\n    \"puppeteer\"\n  );\n\n  const next = await controlChatGptWrapper(\n    `Ok. What is the complete URL of that?`,\n    false,\n    result.result?.thread,\n    \"puppeteer\"\n  );\n\n  const links = next.result?.text ? findLinks(next.result?.text) : null;\n  await writeToAssets(__filename, links, `result${level}.json`);\n\n  if (!links || links.length < 1) {\n    console.log(\"we lost\");\n    return;\n  }\n  browseInternet(links[0].href, level + 1, target);\n}"
  },
  "browsingPromptLoop": {
    "name": "browsingPromptLoop",
    "slug": "TsFunction",
    "id": "seuidadbpflxvpdsalkfxwhs",
    "description": "",
    "operationName": "ai-browser",
    "rawText": " () => {}"
  },
  "fetchUrl": {
    "name": "fetchUrl",
    "slug": "TsFunction",
    "id": "fkpjczwxbcmhcylzhbqyuhco",
    "description": "",
    "operationName": "ai-browser",
    "rawText": " async (url: string) => {\n  const result = await fetch(url)\n    .then((response) => {\n      if (response.status === 200) {\n        return response.text();\n      }\n\n      return response.statusText;\n    })\n    .catch((response) => {\n      return response.statusText as string;\n    });\n\n  return result;\n}"
  },
  "wikipediaGame": {
    "name": "wikipediaGame",
    "slug": "TsFunction",
    "id": "tfetykeaznqcxcxmldxoehbs",
    "description": "",
    "operationName": "ai-browser",
    "rawText": " async (\n  url: string,\n  level: number,\n  target: string\n) => {\n  const html = await fetchUrl(url);\n  // html is too big, we need to simplify the format first.\n  const md = html2md(html, {});\n  const links1 = findLinks(md)\n    .map((x) => `https://wikipedia.org/${x.href}`)\n    .join(\"\\n\");\n  const prompt1 = `This is the wikipedia-game. Your goal is to reach the wiki page of ${target}. You can do so by clicking on wiki hyperlinks which can be found in the below markdown. You cannot interact with the browser in another way. You cannot search, you cannot fill in fields. You can only navigate with hyperlinks. If you can't find the direct link, click a link that is most related to ${target}. \n    \n  You start here, what will be the URL you will go to next?\\n\\n\\n${md}\\n\\n\\nSome things to take into account:\n  \n  - you can only click on hyperlinks on the page\n  - you cannot search\n  - you cannot click buttons or fill in forms`;\n\n  const result = await controlChatGptWrapper(\n    `\nYou are browsing wikipedia, and you stubmled upon this page: ${url}.\n\nYou are looking for ${target} but there is no direct link. \n\nThese are the available links:\n    \n${links1}\n\nWhich page would you go to to come closer to ${target}? which page is likely to be more related to ${target} than ${url}?\n`,\n    false,\n    undefined,\n    \"puppeteer\"\n  );\n\n  const next = await controlChatGptWrapper(\n    `Ok. What is the complete URL of that?`,\n    false,\n    result.result?.thread,\n    \"puppeteer\"\n  );\n\n  const links = next.result?.text ? findLinks(next.result?.text) : null;\n  await writeToAssets(__filename, links, `result${level}.json`);\n\n  if (!links || links.length < 1) {\n    console.log(\"we lost\");\n    return;\n  }\n  wikipediaGame(links[0].href, level + 1, target);\n}"
  },
  "anyGetStaticProps": {
    "name": "anyGetStaticProps",
    "slug": "TsFunction",
    "id": "lnhggtmiahpqzkrdafyxvlbq",
    "description": "",
    "operationName": "ai-demo-web",
    "rawText": " async () => {\n  // TODO: should get everything from config here\n\n  console.log({ domain: process.env.NEXT_PUBLIC_DOMAIN });\n\n  const prompts = await getContextualPrompts();\n  const categories = prompts.pageContextualPrompts\n    .concat(prompts.selectionContextualPrompts)\n    .map((x) => x.categoryStack?.[0])\n    .filter(notEmpty)\n    .filter(onlyUnique2());\n\n  const promptSlugs = prompts.pageContextualPrompts\n    .map((x) => x.slug)\n    .concat(prompts.selectionContextualPrompts.map((x) => x.slug));\n\n  // NB: to show examples, here it's not about a file but about the prompts that are used in any file\n  const apps = (await db.get(\"AiDemoApp\")).map(omitUndefinedValues);\n  const contextualPromptResults = await getContextualPromptResults({\n    promptSlugs,\n  });\n\n  const results = Object.values(groupByKey(contextualPromptResults, \"thread\"));\n  return {\n    props: {\n      categories,\n      prompts,\n      results,\n      apps,\n    },\n  };\n}"
  },
  "Chatbox": {
    "name": "Chatbox",
    "slug": "TsFunction",
    "id": "tgtwvbsncitsxhuzclrbfszv",
    "description": "",
    "operationName": "ai-demo-web",
    "rawText": " (props: {\n  isMe?: boolean;\n  children: JSX.Element;\n  isInitiallyHidden?: boolean;\n}) => {\n  const { isInitiallyHidden, isMe, children } = props;\n  const [isVisible, setIsVisible] = useState(!isInitiallyHidden);\n\n  return (\n    <Div\n      className={`my-6 px-6 w-full flex ${\n        isMe ? \"justify-start\" : \"justify-end\"\n      }`}\n    >\n      <Div\n        className={`w-[80%] lg:max-w-screen-xl max-w-screen-[360px] ${\n          isMe\n            ? \"rounded-tr-xl rounded-tl-xl rounded-br-xl rounded-bl-none\"\n            : \"rounded-tr-xl rounded-tl-xl rounded-bl-xl rounded-br-none\"\n        } p-4 ${isMe ? \"bg-blue-300\" : \"bg-green-400\"}`}\n      >\n        {isInitiallyHidden && !isVisible ? (\n          <Div\n            className=\"hover:font-bold cursor-pointer\"\n            onClick={() => setIsVisible(true)}\n          >\n            ðŸ¤¯ Show how this was generated\n          </Div>\n        ) : (\n          children\n        )}\n      </Div>\n    </Div>\n  );\n}"
  },
  "DemoPage": {
    "name": "DemoPage",
    "slug": "TsFunction",
    "id": "bqimxjnrxixqalefwrigagaj",
    "description": "",
    "operationName": "ai-demo-web",
    "rawText": " (props: AnyPageProps) => {\n  const [value, setValue] = useState(initialValue);\n\n  const router = useRouter();\n  const pagePath = router.asPath.slice(1);\n\n  const config: Storing<Creation<AiDemoApp>> =\n    props.apps.find((x) => x.slug === pagePath) || getDefaultApp(pagePath);\n  // no separate menu for demo because we want to be able to easily scroll down to some examples.\n\n  // remove all tabs, make it simple (config props)\n\n  // down: list of your own results, or if you don't have an api, `isFavorite` results of me (statically generated)\n\n  // Create an extremely simple static frontend: `WriterInput`, Typerepo API input, submit. It will show you the result of the main prompt. Optionally these can also be bigger frontends containing not just one prompt but multiple (multiple submit buttons). And optionally, I can also demonstrate the behavior of the right-click context. This is great! Examples and share my result button will be insanely powerful for understanding and virality. Add a tweet button and share hashtagged tweets tagging me! And obviously, it should link to \"AI from Anywhere\" for installation.\n\n  const header = {\n    component: () => {\n      return (\n        <Div\n          className=\"h-full flex flex-col flex-1 justify-center items-center\"\n          style={\n            config.hasImageBoolean\n              ? {\n                  backgroundImage: `url(\"demos/${config.slug}.jpeg\")`,\n                  backgroundRepeat: \"no-repeat\",\n                  backgroundSize: \"contain\",\n                  backgroundPosition: \"center bottom\",\n                }\n              : undefined\n          }\n        >\n          {config.headerTitle ? (\n            <FancyTitle title={config.headerTitle} />\n          ) : null}\n          {config.headerSubtitle ? (\n            <P className=\"text-xl lg:text-4xl italic\">\n              {config.headerSubtitle}\n            </P>\n          ) : null}\n          {config.headerCtaText ? (\n            <Div\n              onClick={() => {\n                document\n                  .getElementById(\"examples\")\n                  ?.scrollIntoView({ behavior: \"smooth\" });\n              }}\n              // href={config.headerCtaHref}\n              className=\"cursor-pointer text-2xl lg:text-6xl animate-text bg-[#ca21cab9] hover:border-black hover:border hover:bg-purple-200 hover:opacity-50 p-6 rounded-lg mt-20\"\n            >\n              {config.headerCtaText}\n            </Div>\n          ) : null}\n        </Div>\n      );\n    },\n  };\n\n  const prompts = props.prompts.pageContextualPrompts\n    .concat(props.prompts.selectionContextualPrompts)\n    .filter((x) => x.categoryStack?.[0] === pagePath);\n  const exampleItems = props.results\n    .filter((x) => {\n      // only prompots for this category\n      const slug = x[0].contextualPromptSlug;\n      return slug ? prompts.map((x) => x.slug).includes(slug) : false;\n    })\n    .map((thread, index) => {\n      return {\n        component: () => {\n          return (\n            <Div\n              className=\"overflow-y-auto flex items-center justify-center w-full h-screen py-10\"\n              id={index === 0 ? \"examples\" : undefined}\n            >\n              <ResultExample thread={thread} />\n            </Div>\n          );\n        },\n      };\n    });\n\n  const tryYourself = {\n    component: () => {\n      // 3. try it yourself (leads to installation of ai repo, found at aifromanywhere.com)\n      return (\n        <EditWriterInput\n          value={value}\n          onChange={(newValue) => setValue(newValue)}\n          projectRelativeFilePath=\"\"\n        />\n      );\n    },\n  };\n\n  // should be determined based on a ping\n  const isApiConnected = false;\n  const items = isApiConnected\n    ? [header, tryYourself, ...exampleItems]\n    : [header, ...exampleItems, tryYourself];\n  return <Timeline items={items} />;\n}"
  },
  "FancyTitle": {
    "name": "FancyTitle",
    "slug": "TsFunction",
    "id": "opckrsvawskrrbtvmxvrqjdu",
    "description": "",
    "operationName": "ai-demo-web",
    "rawText": " (props: {\n  title: string;\n  hasBackground?: boolean;\n}) => {\n  const { title, hasBackground } = props;\n  return (\n    <Div className={hasBackground ? \"bg-white/70 rounded-lg\" : undefined}>\n      <P\n        className={`lg:text-6xl text-3xl animate-text cool-animation text-center sm:max-w-[60vw] lg:max-w-[80vw] font-bold`}\n      >\n        {title}\n      </P>\n    </Div>\n  );\n}"
  },
  "getDefaultApp": {
    "name": "getDefaultApp",
    "slug": "TsFunction",
    "id": "zapuvoaejlyclzcnvstnobmy",
    "description": "",
    "operationName": "ai-demo-web",
    "rawText": " (slug: string): Storing<Creation<AiDemoApp>> => {\n  return {\n    headerTitle: humanCase(slug),\n    headerCtaText: \"See examples\",\n    slug,\n    hasImageBoolean: false,\n    name: humanCase(slug),\n  };\n}"
  },
  "getStaticPaths": {
    "name": "getStaticPaths",
    "slug": "TsFunction",
    "id": "gkwnouxiemxgnkialscbqdza",
    "description": "",
    "operationName": "code-from-nepal-web",
    "rawText": " (context) =>\n  docsGetStaticPaths(context, basePaths)"
  },
  "getStaticProps": {
    "name": "getStaticProps",
    "slug": "TsFunction",
    "id": "yipbadjyjqhopcxzpnlagikb",
    "description": "",
    "operationName": "code-from-nepal-web",
    "rawText": " (context) =>\n  docsGetStaticProps(context, basePaths, \"code-from-nepal-web\")"
  },
  "initialValue": {
    "name": "initialValue",
    "slug": "TsVariable",
    "id": "wvrgyoiwgxggaoxqtexblyau",
    "description": "",
    "operationName": "ai-demo-web"
  },
  "MyLayout": {
    "name": "MyLayout",
    "slug": "TsFunction",
    "id": "gmanlrlzzupdubrducbsktlm",
    "description": "",
    "operationName": "operation-web",
    "rawText": " (props: { pageProps: any; nextPage: any }) => {\n  const { nextPage, pageProps } = props;\n  return (\n    <AuthenticationLayout\n      // menu props\n      menu={{ queryPaths: [] }}\n      // other\n      nextPage={nextPage}\n      pageProps={pageProps}\n    />\n  );\n}"
  },
  "OverviewPage": {
    "name": "OverviewPage",
    "slug": "TsFunction",
    "id": "lcepckabmmuyskxbxopgfvgn",
    "description": "",
    "operationName": "ai-demo-web",
    "rawText": " (props: AnyPageProps) => {\n  const { prompts, apps, categories } = props;\n\n  const content = (\n    <MarkdownContent\n      content={`## Here are some mind-blowing ideas for your next ChatGPT startup ðŸ¤¯\n    \n  Hi, I'm [Wijnand](https://twitter.com/wkarsens) and I'm building a community of the most talented and\n  creative entrepredevs that are looking to build amazing stuff with\n  [ChatGPT](https://openai.com/blog/chatgpt/). In my research I am coming up with some interesting use-cases and I will publish them here.\n  \n  Eventually I might transform this website into a showcase of actual startups, but it's still a bit early for that. For now you can see the examples below, and you can even try them out if you request me access.`}\n      config={{}}\n    />\n  );\n  return (\n    <Div className=\"flex flex-col items-center\">\n      <Div className=\"w-[80vw] flex flex-col\">\n        {content}\n        <Div className=\"flex flex-row gap gap-2\">\n          <a\n            target=\"_blank\"\n            href=\"https://discord.gg/reMum2qu\"\n            rel=\"noreferrer\"\n          >\n            <div className=\"flex items-center w-24 gap-x-1 bg-gray-100 rounded-md p-1 border border-gray-200\">\n              <BsDiscord className=\"text-2xl text-indigo-500\" />\n\n              <span className=\"font-semibold\">Discord</span>\n            </div>\n          </a>\n\n          <a\n            target=\"_blank\"\n            href=\"https://twitter.com/wkarsens\"\n            rel=\"noreferrer\"\n          >\n            <div className=\"flex items-center w-24 gap-x-1 bg-gray-100 rounded-md p-1 border border-gray-200\">\n              <BsTwitter className=\"text-2xl text-blue-300\" />\n\n              <span className=\"font-semibold\">Twitter</span>\n            </div>\n          </a>\n\n          <a target=\"_blank\" href=\"mailto:wijnand@karsens.com\" rel=\"noreferrer\">\n            <div className=\"flex items-center w-24 gap-x-1 bg-gray-100 rounded-md p-1 border border-gray-200\">\n              <BsMailbox className=\"text-2xl text-black\" />\n\n              <span className=\"font-semibold\">Email</span>\n            </div>\n          </a>\n        </Div>\n        <Div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4\">\n          {categories.map((category) => {\n            const app =\n              apps.find((x) => x.slug === category) || getDefaultApp(category);\n\n            return (\n              <Link href={app.slug || \"#\"} key={category}>\n                <Div\n                  style={\n                    app.hasImageBoolean\n                      ? {\n                          backgroundImage: `url(\"demos/${category}.jpeg\")`,\n                          backgroundRepeat: \"no-repeat\",\n                          backgroundSize: \"cover\",\n                          backgroundPosition: \"center center\",\n                        }\n                      : undefined\n                  }\n                  className=\"cursor-pointer transition-all hover:scale-105 border rounded-lg border-black m-2 p-6 flex flex-col items-center justify-center\"\n                >\n                  <FancyTitle\n                    hasBackground={app.hasImageBoolean}\n                    title={app.name}\n                  />\n                  <Div className=\"cursor-pointer text-2xl animate-text hover:opacity-50 p-6 rounded-lg\">\n                    {app.headerCtaText}\n                  </Div>\n                </Div>\n              </Link>\n            );\n          })}\n        </Div>\n      </Div>\n    </Div>\n  );\n}"
  },
  "progress": {
    "name": "progress",
    "slug": "TsVariable",
    "id": "lnyoxuvnkdhbymenvzbtspdi",
    "description": "",
    "operationName": "passionfruit-web"
  },
  "queryClient": {
    "name": "queryClient",
    "slug": "TsVariable",
    "id": "kfagdknbrspwcagzadnqhsoj",
    "description": "",
    "operationName": "passionfruit-web"
  },
  "ResultExample": {
    "name": "ResultExample",
    "slug": "TsFunction",
    "id": "dkputslohcgkwtmzmsgidsov",
    "description": "",
    "operationName": "ai-demo-web",
    "rawText": " (props: { thread: ContextualPromptResult[] }) => {\n  const { thread } = props;\n\n  return (\n    <>\n      {thread.map((item, index) => {\n        if (!item.resultText) return null;\n\n        return (\n          <Div className=\"w-full h-full\">\n            <Chatbox isMe isInitiallyHidden={index === 0}>\n              <MarkdownContent\n                config={{}}\n                content={item.prompt || \"No prompt\"}\n              />\n            </Chatbox>\n\n            <Chatbox>\n              <MarkdownContent\n                config={{}}\n                content={item.resultText || \"No result\"}\n              />\n            </Chatbox>\n\n            <Div className=\"w-full flex items-center justify-center pb-4\">\n              <P>ðŸ’¬ Share</P>\n            </Div>\n          </Div>\n        );\n      })}\n    </>\n  );\n}"
  },
  "{ StoreProvider, useStore }": {
    "name": "{ StoreProvider, useStore }",
    "slug": "TsVariable",
    "id": "vwonqhludcuyvrwfkafzkwrg",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "addStatement": {
    "name": "addStatement",
    "slug": "TsFunction",
    "id": "pfgevbzdtgxfdwplbmbutlui",
    "description": "Adds `Statement`",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  /**\n   * MUST be an english statement\n   */\n  statement: string,\n  /**\n   * defaults to 0.5\n   */\n  importancy?: number,\n  /**\n   * defaults to 1\n   */\n  agreement?: number\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  if (importancy !== undefined && (importancy < 0 || importancy > 1)) {\n    return {\n      isSuccessful: false,\n      message: \"Importancy, when filled in, must be between [0,1]\",\n    };\n  }\n  if (agreement !== undefined && (agreement < 0 || agreement > 1)) {\n    return {\n      isSuccessful: false,\n      message: \"Agreement, when filled in, must be between [0,1]\",\n    };\n  }\n\n  const newStatement: Creation<Statement> = {\n    description: statement,\n    importancy: importancy === undefined ? 0.5 : importancy,\n    agreement: agreement === undefined ? 1 : agreement,\n  };\n\n  const upsertResult = await db.upsert(\"Statement\", newStatement, {\n    onlyInsert: true,\n  });\n\n  return {\n    isSuccessful: upsertResult?.isSuccesful || false,\n    message: upsertResult?.isSuccesful\n      ? \"Statement added\"\n      : upsertResult?.message,\n  };\n}"
  },
  "addWord": {
    "name": "addWord",
    "slug": "TsFunction",
    "id": "twzrfxdzqxbzyvymphdcypar",
    "description": "Adds word either to the WordMatrix or to the WordCombination database model",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  /**\n   * MUST be an english word or word combination written in the latin alphabet\n   */\n  word: string,\n  description?: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  // if the word is a combination of multiple words (e.g. large-language-model is large +language + model), it should be added as a word combination with a description\n  // const wordMatrixs = await db.get(\"WordMatrix\");\n  // potentially we should check here if the word already exists or if the word combination already exists, but this is not required as long as we use `.onlyInsert: true`\n  const parts = lowerCaseArray(word);\n\n  if (parts.length > 1) {\n    const newWordCombination: Creation<WordCombination> = {\n      name: kebabCase(word),\n      description: description || \"\",\n      wordMatrixSlugs: parts,\n    };\n\n    const upsertResult = await db.upsert(\n      \"WordCombination\",\n      newWordCombination,\n      { onlyInsert: true }\n    );\n\n    return {\n      isSuccessful: upsertResult?.isSuccesful || false,\n      message: upsertResult?.isSuccesful\n        ? \"Added word combination\"\n        : upsertResult?.message,\n    };\n  }\n\n  const name = parts[0];\n\n  const newWord: Creation<WordMatrix> = {\n    name,\n    description,\n    english: { latin: name },\n  };\n\n  const upsertResult = await db.upsert(\"WordMatrix\", newWord, {\n    onlyInsert: true,\n  });\n\n  return {\n    isSuccessful: upsertResult?.isSuccesful || false,\n    message: upsertResult?.isSuccesful ? \"Added word\" : upsertResult?.message,\n  };\n}"
  },
  "biggestFunctionName": {
    "name": "biggestFunctionName",
    "slug": "TsFunction",
    "id": "ltkcivwjjweuytirlpvjqfgg",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  contextContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"biggest-function-name\",\n    contextContent,\n  });\n\n  return result;\n}"
  },
  "checkQueue": {
    "name": "checkQueue",
    "slug": "TsFunction",
    "id": "bknctohnhasplleekmvlpkln",
    "description": "---\nrunEveryPeriod: minute\n---\n\ncron that runs every minute for executing new puppeteer queue items. It will open it as child process. You can set the amount of tabs it should have as a limit, and it will keep the tabs open afterwards, but after the thing is done it will just remove the item from the `Queue`.",
    "operationName": "ai-functions-node",
    "rawText": " async () => {\n  const queueItems = await db.get(\"Queue\");\n\n  // 1. check how many chrome tabs are available (according to OS settings / memory limit)\n\n  // 2. check how many queue items can be executed now, and sort by importancy\n\n  // 3. take the ones that are most important and execute those\n}"
  },
  "cleanup": {
    "name": "cleanup",
    "slug": "TsFunction",
    "id": "clavbogdogiyogzufcbhamlx",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  contextContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"cleanup\",\n    contextContent,\n  });\n\n  return result;\n}"
  },
  "controlChatGptCli": {
    "name": "controlChatGptCli",
    "slug": "TsFunction",
    "id": "vmhaggyatpsqlfiwdimqddrn",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async () => {\n  const promptArray = process.argv.slice(2);\n  const noHeadless = promptArray[0] === \"show\";\n  const prompt = noHeadless\n    ? promptArray.slice(1).join(\" \")\n    : promptArray.join(\" \");\n  console.log({ noHeadless, prompt });\n  const result = await controlChatGpt(prompt, noHeadless);\n  console.log({ result });\n  return;\n}"
  },
  "controlChatGptWrapper": {
    "name": "controlChatGptWrapper",
    "slug": "TsFunction",
    "id": "fvkflgbcowvoguoheeqnpyol",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  prompt: string,\n  isHeadless: boolean | undefined,\n  thread: string | undefined,\n  controller: \"playwright\" | \"puppeteer\" | \"faker\"\n): Promise<ProcessPromptFunctionResult> => {\n  const result: ProcessPromptFunctionResult =\n    controller === \"playwright\"\n      ? await controlChatGpt(prompt, isHeadless)\n      : controller === \"puppeteer\"\n      ? await openAIChat({ prompt, isHeadless, thread })\n      : {\n          isSuccessful: true,\n          message: \"Done test\",\n          result: {\n            text: \"Lorum ipsum lorum ipsum lorum ipsum lorum ipsum lorum ipsum lorum ipsum lorum ipsum\",\n            thread: \"\",\n          },\n        };\n\n  return result;\n}"
  },
  "controlChatGpt": {
    "name": "controlChatGpt",
    "slug": "TsFunction",
    "id": "fcpynsvsasdpcfogquzpgumx",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  prompt: string,\n  headless?: boolean\n): Promise<ProcessPromptFunctionResult> => {\n  const api = new ChatGPTAPI({ headless });\n  // open chromium and wait until you've logged in\n  await api.init({ auth: \"blocking\" });\n  // send a message and wait for the response\n  const response = await api.sendMessage(prompt);\n  api.close();\n  return {\n    isSuccessful: true,\n    message: \"Done\",\n    result: { thread: \"\", text: response },\n  };\n}"
  },
  "convertTo1337speak": {
    "name": "convertTo1337speak",
    "slug": "TsFunction",
    "id": "gpghlsgowkxkxhtttywbqjqa",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  contextContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"convert-to-1337speak\",\n    contextContent,\n  });\n\n  return result;\n}"
  },
  "deletePromptResult": {
    "name": "deletePromptResult",
    "slug": "TsFunction",
    "id": "fdvbrdmkzieygfkimwnrctzr",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  projectRelativePath: string,\n  id: string\n) => {\n  const resultPath = await getContextualPromptResultJsonFilePath(\n    projectRelativePath\n  );\n\n  if (!resultPath) return { isSuccessful: false };\n\n  const result = await alterJsonMultiple(\n    {\n      absolutePath: resultPath,\n      modelName: \"ContextualPromptResult\",\n      projectRelativePath: resultPath,\n      operationName: \"\",\n    },\n    (old) => {\n      return {\n        newStoredData: old.filter((item) => (item.id === id ? false : true)),\n        amountRemoved: 1,\n      };\n    }\n  );\n\n  return { isSuccessful: result.amountRemoved === 1 };\n}"
  },
  "developersQuote": {
    "name": "developersQuote",
    "slug": "TsFunction",
    "id": "ibfcoxbmrjerpqkrgxywazfs",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  selectionContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"developers-quote\",\n    selectionContent,\n  });\n\n  return result;\n}"
  },
  "diaryToInstagram": {
    "name": "diaryToInstagram",
    "slug": "TsFunction",
    "id": "jjmdkyqydmwpjkxyscknfgkl",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  selectionContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"diary-to-instagram\",\n    selectionContent,\n  });\n\n  return result;\n}"
  },
  "documentationWriting": {
    "name": "documentationWriting",
    "slug": "TsFunction",
    "id": "qjazqmdskazmgycpwtbdfzis",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  contextContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"documentation-writing\",\n    contextContent,\n  });\n\n  return result;\n}"
  },
  "emojiAugmentation": {
    "name": "emojiAugmentation",
    "slug": "TsFunction",
    "id": "scdtttkwkcxziauevisdivnh",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  contextContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"emoji-augmentation\",\n    contextContent,\n  });\n\n  return result;\n}"
  },
  "explainInDutch": {
    "name": "explainInDutch",
    "slug": "TsFunction",
    "id": "wcpwphmpqsapdlawgjzyfavy",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  contextContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"explain-in-dutch\",\n    contextContent,\n  });\n\n  return result;\n}"
  },
  "explainInNepali": {
    "name": "explainInNepali",
    "slug": "TsFunction",
    "id": "vcjvxbkbprslivhethryvgbh",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  contextContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"explain-in-nepali\",\n    contextContent,\n  });\n\n  return result;\n}"
  },
  "explainInPortuguese": {
    "name": "explainInPortuguese",
    "slug": "TsFunction",
    "id": "kwthmsfrtfaewcvrfhpkvmtt",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  contextContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"explain-in-portuguese\",\n    contextContent,\n  });\n\n  return result;\n}"
  },
  "explain": {
    "name": "explain",
    "slug": "TsFunction",
    "id": "cjhdoaawzuzdxoccizsbpsxf",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  contextContent: string,\n  selectionContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"explain\",\n    contextContent,\n    selectionContent,\n  });\n\n  return result;\n}"
  },
  "fixGrammarAndSpellingMistakes": {
    "name": "fixGrammarAndSpellingMistakes",
    "slug": "TsFunction",
    "id": "lghaoshgcavptngjatxgfrhr",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  contextContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"fix-grammar-and-spelling-mistakes\",\n    contextContent,\n  });\n\n  return result;\n}"
  },
  "getCategoriesTest": {
    "name": "getCategoriesTest",
    "slug": "TsFunction",
    "id": "fsgpodtsvpjwgtpzkxlghczn",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async () => {\n  const result = await getContextualPromptCategories();\n\n  writeToAssets(__filename, result, \"contextual-prompt-categories.json\");\n}"
  },
  "getContextualPromptCategories": {
    "name": "getContextualPromptCategories",
    "slug": "TsFunction",
    "id": "mihiukybyvpiwnkryzrkeqvl",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async () => {\n  const contextualPrompts = await db.get(\"ContextualPrompt\");\n\n  const stackCount = contextualPrompts.reduce((stackCount, current) => {\n    // get the stack for this contextualPrompt\n    const stack: string[] | undefined = current.categoryStack;\n\n    if (!stack || stack.length === 0) {\n      const already = stackCount.__root;\n      return {\n        ...stackCount,\n        __root: already ? already + 1 : 1,\n      };\n    }\n\n    const everyStackPart: string[] = stack.map((_, index, array) => {\n      const stackUntilHere = array.slice(0, index + 1).join(\".\");\n      return stackUntilHere;\n    });\n\n    const newStackCount = everyStackPart.reduce((stackCount, stackPart) => {\n      const already = stackCount[stackPart];\n      return {\n        ...stackCount,\n        [stackPart]: already ? already + 1 : 1,\n      };\n    }, stackCount);\n\n    return newStackCount;\n  }, {} as StackCount);\n\n  // now, let's make a childObject out of that\n\n  const { __root, ...stackCountWithoutRoot } = stackCount;\n\n  const categories = Object.keys(stackCountWithoutRoot)\n    .map((key) => getObjectForkKeyRecursively(stackCount, key))\n    .filter(notEmpty);\n\n  const rootCategoryChildObject: CategoryChildObject = {\n    category: \"root\",\n    count: __root + sum(categories.map((x) => x.count)),\n    children: categories,\n  };\n\n  return rootCategoryChildObject;\n}"
  },
  "getContextualPromptResultJsonFilePath": {
    "name": "getContextualPromptResultJsonFilePath",
    "slug": "TsFunction",
    "id": "besixupepaazryikghcdedto",
    "description": "Calculates path where the result json index is supposed to be",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  projectRelativePath?: string\n) => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n  const prompt_absolutePath = projectRelativePath\n    ? path.join(projectRoot, projectRelativePath)\n    : undefined;\n\n  const exists = prompt_absolutePath\n    ? fs.existsSync(prompt_absolutePath)\n    : undefined;\n\n  const stats =\n    exists && prompt_absolutePath\n      ? await fs.stat(prompt_absolutePath)\n      : undefined;\n  const isFolder = stats ? stats.isDirectory() : false;\n  const isFile = stats ? stats.isFile() : false;\n  const pathParse = prompt_absolutePath\n    ? path.parse(prompt_absolutePath)\n    : undefined;\n\n  const contextualPromptResultsJsonPath =\n    pathParse && isFile\n      ? path.join(\n          pathParse.dir,\n          \".index\",\n          pathParse.name,\n          \"prompt-results.json\"\n        )\n      : isFolder && prompt_absolutePath\n      ? path.join(prompt_absolutePath, \".index\", \"prompt-results.json\")\n      : undefined;\n\n  return contextualPromptResultsJsonPath;\n}"
  },
  "getContextualPrompt": {
    "name": "getContextualPrompt",
    "slug": "TsFunction",
    "id": "lfkndohctighxsvvdzifqyfb",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  contextualPromptSlug: string | undefined,\n  customPromptContent: string | undefined,\n  saveNewPromptWithName: string | null,\n  contextType: FileType | undefined\n): Promise<(Creation<ContextualPrompt> & { slug: string }) | undefined> => {\n  if (contextualPromptSlug) {\n    const contextualPrompts = await db.get(\"ContextualPrompt\");\n\n    const contextualPrompt = contextualPrompts.find(\n      (x) => x.slug === contextualPromptSlug\n    );\n\n    if (!contextualPrompt) {\n      return undefined;\n    }\n\n    return contextualPrompt;\n  }\n\n  if (!customPromptContent || customPromptContent.length === 0) {\n    return undefined;\n  }\n\n  const isNew = saveNewPromptWithName && saveNewPromptWithName.length > 0;\n\n  // console.log({ saveNewPromptWithName, isNew });\n  const name = isNew ? saveNewPromptWithName : generateId();\n  const newContextualPrompt: Creation<ContextualPrompt> & { slug: string } = {\n    name,\n    slug: slugify(name),\n    promptContent: customPromptContent,\n    contextType: [contextType || \"text\"],\n    model: \"chat-gpt\",\n    usesContext: customPromptContent?.includes(\"%context\"),\n    usesSelection: customPromptContent?.includes(\"%selection\"),\n    usesAnyContext: customPromptContent?.includes(\"%any\"),\n  };\n\n  if (isNew) {\n    await db.upsert(\"ContextualPrompt\", newContextualPrompt);\n  }\n\n  return newContextualPrompt;\n}"
  },
  "getObjectForkKeyRecursively": {
    "name": "getObjectForkKeyRecursively",
    "slug": "TsFunction",
    "id": "tendhnapfpgbomzbqlofkgqv",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " (\n  stackCount: StackCount,\n  key: string\n): CategoryChildObject | undefined => {\n  const categoryStack = key.split(\".\");\n\n  if (categoryStack.length !== 1) return;\n\n  const firstCategory = categoryStack[0];\n\n  //get all children:\n\n  //1) find all keys that start with firstCategory\n  const childrenKeys = Object.keys(stackCount).filter((key) =>\n    key.startsWith(`${firstCategory}.`)\n  );\n  //2) remove the firstCategory from the keys\n  const strippedKeys = childrenKeys.map((key) =>\n    key.replace(`${firstCategory}.`, \"\")\n  );\n  // create strippedStackCount\n  const strippedStackCount = strippedKeys.reduce((newStackCount, key) => {\n    return { ...newStackCount, [key]: stackCount[`${firstCategory}.${key}`] };\n  }, {} as StackCount);\n\n  //3) insert into this same function\n\n  const children = strippedKeys\n    .map((key) => getObjectForkKeyRecursively(strippedStackCount, key))\n    .filter(notEmpty);\n\n  const object: CategoryChildObject = {\n    category: firstCategory,\n    count: stackCount[firstCategory],\n  };\n\n  if (children.length) object.children = children;\n\n  return object;\n}"
  },
  "gptIdeasRegisterWithContext": {
    "name": "gptIdeasRegisterWithContext",
    "slug": "TsFunction",
    "id": "idsziifajehvqwkmgrdemzdx",
    "description": "TODO: move to gptideas backend package",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  functionContext: FunctionContext,\n  name: string,\n  email: string,\n  tier: \"free\" | \"indie\" | \"startup\" | \"sponsor\",\n  newsletter: \"daily\" | \"weekly\" | \"unsubscribe\",\n  message?: string\n) => {\n  const username = email.split(\"@\")[0] + Math.round(Math.random() * 999);\n\n  const password = generateId();\n\n  // only supported for now\n  const method: AuthenticationMethodMethod = \"usernamePassword\";\n\n  const addDeviceAuthResult = await addDeviceAuthenticationMethodWithContext(\n    functionContext,\n    method,\n    username,\n    password\n  );\n\n  const addDeviceEmailAuthResult =\n    await addDeviceAuthenticationMethodWithContext(\n      functionContext,\n      \"email\",\n      email\n    );\n\n  console.log({ addDeviceEmailAuthResult });\n\n  // console.log({ addDeviceAuthResult });\n  const { functionContext: newFunctionContext, authenticationMethod } =\n    addDeviceAuthResult;\n\n  if (!authenticationMethod?.isAuthenticated || !newFunctionContext) {\n    console.log(\"NOT AUTHENTICATED AFTER ADDING DEVICE\", {\n      authenticationMethod,\n      newFunctionContext,\n    });\n    return { isSuccessful: false, message: message || \"Strange\" };\n  }\n\n  const signupResult = await signupWithContext(functionContext, {\n    name,\n    slug: slugify(name),\n    amountAuthenticationMethodsRequired: 1,\n  });\n\n  const upsertResult = await db.upsert(\"GptIdeasUser\", {\n    email,\n    newsletter,\n    tier,\n  });\n\n  return {\n    isSuccessful: signupResult.isSuccessful,\n    message: signupResult.message,\n  };\n}"
  },
  "haiku": {
    "name": "haiku",
    "slug": "TsFunction",
    "id": "wszbneqtobutqpdployzqlxz",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  selectionContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"haiku\",\n    selectionContent,\n  });\n\n  return result;\n}"
  },
  "improveCode": {
    "name": "improveCode",
    "slug": "TsFunction",
    "id": "knveejybqpwyaebebuivaaiz",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  contextContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"improve-code\",\n    contextContent,\n  });\n\n  return result;\n}"
  },
  "keywords": {
    "name": "keywords",
    "slug": "TsFunction",
    "id": "fzzwaugbvdwpbzmydudetbex",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  contextContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"keywords\",\n    contextContent,\n  });\n\n  return result;\n}"
  },
  "marcusAurelius": {
    "name": "marcusAurelius",
    "slug": "TsFunction",
    "id": "admonbisneyhvlpqofviluzp",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  selectionContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"marcus-aurelius\",\n    selectionContent,\n  });\n\n  return result;\n}"
  },
  "poem": {
    "name": "poem",
    "slug": "TsFunction",
    "id": "zmwknziewmepljcuobngqgct",
    "description": "Write a poem",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  selectionContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"poem\",\n    selectionContent,\n  });\n\n  return result;\n}"
  },
  "processChatGptPrompt": {
    "name": "processChatGptPrompt",
    "slug": "TsFunction",
    "id": "ubuisgbjzyqpvsbnythhpupq",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  config: ProcessPromptProps\n): Promise<ProcessPromptFunctionResult> => {\n  const {\n    contextContent,\n    contextualPromptSlug,\n    customPromptContent,\n    saveNewPromptWithName,\n    prompt_projectRelativePath,\n    selectionContent,\n    isHeadless,\n    isDeferred,\n    thread,\n  } = config;\n\n  const extension = prompt_projectRelativePath\n    ? path.parse(prompt_projectRelativePath).ext.slice(1)\n    : undefined;\n\n  const contextType = fileTypePerExtension[\n    extension as keyof typeof fileTypePerExtension\n  ] as FileType | undefined;\n\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return { isSuccessful: false, message: \"no projectroot\" };\n  const prompt_absolutePath = prompt_projectRelativePath\n    ? path.join(projectRoot, prompt_projectRelativePath)\n    : undefined;\n\n  const exists = prompt_absolutePath\n    ? fs.existsSync(prompt_absolutePath)\n    : undefined;\n\n  if (prompt_absolutePath && !exists) {\n    return {\n      isSuccessful: false,\n      message: `You gave a path that doesn't exist:${prompt_absolutePath}`,\n    };\n  }\n\n  const contextualPrompt = await getContextualPrompt(\n    contextualPromptSlug,\n    customPromptContent,\n    saveNewPromptWithName || null,\n    contextType\n  );\n  if (!contextualPrompt) {\n    return {\n      isSuccessful: false,\n      message: \"Couldn't create or find a contextual prompt\",\n    };\n  }\n\n  /**\nensure `%context, %selection, %comment` are all valid variables in the prompt\n\nTODO: replace this with javascrpit-alike syntax (e.g. ${variableName})\n*/\n\n  const finalPrompt = { ...contextualPrompt }.promptContent\n    .replaceAll(\"%context\", contextContent || \"\")\n    .replaceAll(\"%selection\", selectionContent || \"\")\n    .replaceAll(\"%any\", selectionContent || contextContent || \"\");\n\n  /**\n   * Disable this for now\n   */\n  const useChatGpt = true;\n\n  /**\nsend it to the processor, which sends response back after a few seconds\n*/\n  const promiseResult = controlChatGptWrapper(\n    finalPrompt,\n    isHeadless,\n    thread,\n    \"puppeteer\"\n  ).then(async (promptFunctionResult) => {\n    const newResult: Storing<ContextualPromptResult> = {\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n      createdFirstAt: Date.now(),\n      deletedAt: 0,\n      id: generateId(),\n      resultAssets: [],\n      resultText: promptFunctionResult.result?.text,\n      prompt: finalPrompt,\n      selectionString: selectionContent || undefined,\n      prompt_projectRelativePath,\n      thread: promptFunctionResult.result?.thread,\n      contextualPromptSlug: contextualPrompt.slug,\n      isFake: !useChatGpt,\n    };\n\n    // NB: insert into .index\n\n    const contextualPromptResultsJsonPath =\n      await getContextualPromptResultJsonFilePath(prompt_projectRelativePath);\n\n    const upsertResult = contextualPromptResultsJsonPath\n      ? await alterJsonMultiple(\n          {\n            absolutePath: contextualPromptResultsJsonPath,\n            modelName: \"ContextualPromptResult\",\n            operationName: null,\n            projectRelativePath: makeRelative(\n              contextualPromptResultsJsonPath,\n              projectRoot\n            ),\n          },\n          (storedData) => {\n            const result = upsert(storedData, newResult);\n            return result;\n          }\n        )\n      : undefined;\n\n    return {\n      upsertResult,\n      promptFunctionResult: promptFunctionResult?.result,\n    };\n  });\n\n  const processPromptFunctionResult = isDeferred\n    ? undefined\n    : await promiseResult;\n\n  const result =\n    isDeferred || !processPromptFunctionResult\n      ? undefined\n      : processPromptFunctionResult.promptFunctionResult;\n\n  return {\n    isSuccessful: isDeferred ? true : !!result?.text || false,\n    message: isDeferred\n      ? \"Prompt is now being executed\"\n      : processPromptFunctionResult?.upsertResult?.message || \"WentWrong\",\n    result,\n  };\n}"
  },
  "processPromptOnFile": {
    "name": "processPromptOnFile",
    "slug": "TsFunction",
    "id": "czcqyobxmkooznmlqiewdkij",
    "description": "function `processPromptOnFile` to execute `processChatGptPrompt` for a file, so we don't need to store the whole file content and it can be executed later and still have the most recent file contents\n\nIn order to keep the file itself as a source of truth for its content, it's useful to have this because you can add this to the queue",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  projectRelativeFilePath: string,\n  contextualPromptSlug: string\n) => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No projectroot\" };\n  }\n\n  const absolutePath = path.join(projectRoot, projectRelativeFilePath);\n\n  const exists = fs.existsSync(absolutePath);\n\n  if (!exists) {\n    return { isSuccessful: false, message: \"File doesn't exist\" };\n  }\n\n  const contextContent = await fs.readFile(absolutePath, \"utf8\");\n  const result = await processChatGptPrompt({\n    contextContent,\n    contextualPromptSlug,\n    isDeferred: true,\n    prompt_projectRelativePath: projectRelativeFilePath,\n  });\n\n  return result;\n}"
  },
  "processPromptOnFolder": {
    "name": "processPromptOnFolder",
    "slug": "TsFunction",
    "id": "ezwwodbmycpwjbfegdqkwrhs",
    "description": "function that can execute `processPromptOnFile` for all files in a folder, by just upserting the executions to the queue.",
    "operationName": "ai-functions-node",
    "rawText": " async (config: {\n  projectRelativeFolderPath: string;\n  promptSlug: string;\n  isRecursive?: boolean;\n  extension?: string | string[];\n}) => {\n  const { projectRelativeFolderPath, promptSlug, extension, isRecursive } =\n    config;\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No projectroot\" };\n  }\n  const absoluteFolderPath = path.join(projectRoot, projectRelativeFolderPath);\n\n  const exists = fs.existsSync(absoluteFolderPath);\n\n  if (!exists) {\n    return { isSuccessful: false, message: \"Folder not found\" };\n  }\n\n  const stats = await fs.stat(absoluteFolderPath);\n  if (!stats.isDirectory()) {\n    return { isSuccessful: false, message: \"That's not a folder\" };\n  }\n\n  // get files\n  const projectRelativeFilePaths = (\n    await explore({\n      basePath: absoluteFolderPath,\n      doNotExploreChildFolders: !isRecursive,\n      extension,\n      ignore: \".index\",\n    })\n  ).map((x) => makeRelative(x.path, projectRoot));\n\n  const queueItems: Creation<Queue>[] = projectRelativeFilePaths.map(\n    (projectRelativeFilePath) => {\n      return {\n        functionName: \"processPromptOnFile\",\n        parameters: [projectRelativeFilePath, promptSlug],\n        type: \"puppeteer\",\n      };\n    }\n  );\n\n  const upsertResult = await db.upsert(\"Queue\", queueItems);\n\n  return {\n    isSuccessful: upsertResult.isSuccesful,\n    message: upsertResult.isSuccesful ? \"Added to queue\" : upsertResult.message,\n  };\n}"
  },
  "removeAllFake": {
    "name": "removeAllFake",
    "slug": "TsFunction",
    "id": "odzgyiyjqxhrrnylrqqbtjnh",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  basePath?: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  console.log(\"removing all fake\");\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"no projectroot\" };\n  }\n\n  const absoluteBasePath = basePath\n    ? path.join(projectRoot, basePath)\n    : projectRoot;\n\n  console.log({ absoluteBasePath });\n\n  const absolutePaths = (\n    await explore({\n      basePath: absoluteBasePath,\n      exact: true,\n      search: \"prompt-results.json\",\n      searchLevel: \"fileName\",\n    })\n  ).map((x) => x.path);\n\n  const filtered = await mapMany(\n    absolutePaths,\n    async (absolutePath) => {\n      // remove items with isFake\n\n      const json = await readJsonFile<ContextualPromptResult[]>(absolutePath);\n\n      if (!json) return false;\n\n      const newJson = json.filter((item) => item.isFake !== true);\n\n      if (newJson.length === json.length) return false;\n\n      const writeResult = await writeJsonToFile(absolutePath, newJson);\n\n      return writeResult;\n    },\n    100\n  );\n\n  console.log({ filtered: filtered });\n  return { isSuccessful: true };\n}"
  },
  "rickAndMortyRick": {
    "name": "rickAndMortyRick",
    "slug": "TsFunction",
    "id": "yagvyapykcszarrlvxeazoqk",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  selectionContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"rick-and-morty-rick\",\n    selectionContent,\n  });\n\n  return result;\n}"
  },
  "rickAndMorty": {
    "name": "rickAndMorty",
    "slug": "TsFunction",
    "id": "dvpedthkfktyheevnsnbgghk",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  selectionContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"rick-and-morty\",\n    selectionContent,\n  });\n\n  return result;\n}"
  },
  "setIsFavoritePromptResult": {
    "name": "setIsFavoritePromptResult",
    "slug": "TsFunction",
    "id": "gixhyjzagblptoamjmcpphjl",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  projectRelativePath: string,\n  id: string,\n  isFavorite: boolean\n) => {\n  const resultPath = await getContextualPromptResultJsonFilePath(\n    projectRelativePath\n  );\n\n  if (!resultPath) return { isSuccessful: false };\n\n  const result = await alterJsonMultiple(\n    {\n      absolutePath: resultPath,\n      modelName: \"ContextualPromptResult\",\n      projectRelativePath: resultPath,\n      operationName: \"\",\n    },\n    (old) => {\n      return {\n        newStoredData: old.map((item) => {\n          if (item.id !== id) return item;\n          return { ...item, isFavorite };\n        }),\n        amountUpdated: 1,\n      };\n    }\n  );\n\n  return { isSuccessful: result.amountUpdated === 1 };\n}"
  },
  "socratesAndSnoopDogg": {
    "name": "socratesAndSnoopDogg",
    "slug": "TsFunction",
    "id": "bapkunkeiwljrovtqspvzcqw",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  selectionContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"socrates-and-snoop-dogg\",\n    selectionContent,\n  });\n\n  return result;\n}"
  },
  "storytelling": {
    "name": "storytelling",
    "slug": "TsFunction",
    "id": "fhykpgjiuyjwfbmgydyzfusr",
    "description": "Write a story about this code and what's happening in there",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  contextContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"storytelling\",\n    contextContent,\n  });\n\n  return result;\n}"
  },
  "test": {
    "name": "test",
    "slug": "TsFunction",
    "id": "qyofisntmofwxgescvjbbqjg",
    "description": "",
    "operationName": "slack-controller",
    "rawText": " async () => {\n  const slackLoginRes = await slackLogin({\n    credentials: { email: \"bhagyasah4u@gmail.com\", password: \"bhagya199201\" },\n    mode: \"gmail\",\n  });\n  console.log({ slackLoginRes });\n}"
  },
  "translateEverythingIntoHindi": {
    "name": "translateEverythingIntoHindi",
    "slug": "TsFunction",
    "id": "ibqfnszpibzvhkalgewywvum",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  contextContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"translate-everything-into-hindi\",\n    contextContent,\n  });\n\n  return result;\n}"
  },
  "translateEverythingPortuguese": {
    "name": "translateEverythingPortuguese",
    "slug": "TsFunction",
    "id": "ghauyplnzigvurejlvgaptlc",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  contextContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"translate-everything-portuguese\",\n    contextContent,\n  });\n\n  return result;\n}"
  },
  "translateEverything": {
    "name": "translateEverything",
    "slug": "TsFunction",
    "id": "ufbpkssqxkvcvwlwcyaecsjo",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  contextContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"translate-everything\",\n    contextContent,\n  });\n\n  return result;\n}"
  },
  "translateToPortuguese": {
    "name": "translateToPortuguese",
    "slug": "TsFunction",
    "id": "vgebgukvjvhwqnuohhvmukps",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  contextContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"translate-to-portuguese\",\n    contextContent,\n  });\n\n  return result;\n}"
  },
  "typescriptExplain": {
    "name": "typescriptExplain",
    "slug": "TsFunction",
    "id": "wcnsjfarugbccfyxudlyvofd",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  contextContent: string,\n  selectionContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"typescript-explain\",\n    contextContent,\n    selectionContent,\n  });\n\n  return result;\n}"
  },
  "williamShakespear": {
    "name": "williamShakespear",
    "slug": "TsFunction",
    "id": "gslzfwgtsyzcdhmkjbqxbaxs",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  selectionContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"william-shakespear\",\n    selectionContent,\n  });\n\n  return result;\n}"
  },
  "writeContextualPromptSdk": {
    "name": "writeContextualPromptSdk",
    "slug": "TsFunction",
    "id": "iqttuebaduakngvmvrtelmeq",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async () => {\n  const contextualPrompts = await db.get(\"ContextualPrompt\");\n\n  const functionStrings = contextualPrompts\n    .map((contextualPrompt) => {\n      return writeCreatePromptCode(contextualPrompt);\n    })\n    .join(\"\\n\\n\\n\");\n\n  const codeString = `// this file is generated, you can edit it, but it will be re-generated based on the contextual prompts database\n\nimport { processChatGptPrompt } from \"./processChatGptPrompt\";\n\n${functionStrings}`;\n\n  return codeString;\n}"
  },
  "writeCreatePromptCode": {
    "name": "writeCreatePromptCode",
    "slug": "TsFunction",
    "id": "uxwmglisfntjzfqofhankiyo",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " (contextualPrompt: ContextualPrompt) => {\n  const parameters = [\n    contextualPrompt.usesAnyContext ? `anyContext` : undefined,\n    ,\n    contextualPrompt.usesContext ? `contextContent` : undefined,\n    contextualPrompt.usesSelection ? `selectionContent` : undefined,\n    contextualPrompt.folderContentContext ? `projectRelativePath` : undefined,\n  ].filter(notEmpty);\n\n  const functionLineParametersString = parameters\n    .map((x) => `${x}: string`)\n    .join(\", \");\n  const objectParametersString = parameters.join(\",\\n\");\n\n  const { contextType, instantExecution, isFavorite, categoryStack } =\n    contextualPrompt;\n  const contextualPromptInfo = {\n    contextType,\n    instantExecution,\n    isFavorite,\n    categoryStack,\n  };\n  const functionName = camelCase(contextualPrompt.name);\n\n  return `\n  ${\n    contextualPrompt.title\n      ? `/**\n  ${contextualPrompt.title}\n  */`\n      : \"\"\n  }\n  export const ${functionName}: PromptFunction = async (${functionLineParametersString}, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"${contextualPrompt.slug}\",\n      ${objectParametersString}\n    });\n\n    return result;\n\n  }\n\n${functionName}.contextualPromptInfo = ${JSON.stringify(contextualPromptInfo)}`;\n}"
  },
  "ye": {
    "name": "ye",
    "slug": "TsFunction",
    "id": "rmiklfqixzwnrnfboahqbjvp",
    "description": "Let Kanye West write a poem about your selection",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  selectionContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"ye\",\n    selectionContent,\n  });\n\n  return result;\n}"
  },
  "yodafy": {
    "name": "yodafy",
    "slug": "TsFunction",
    "id": "poicyaylhqgkemhryuukztsc",
    "description": "Let Yoda say your selection in his words",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  selectionContent: string,\n  isDeferred?: boolean\n) => {\n  const result = await processChatGptPrompt({\n    isDeferred,\n    contextualPromptSlug: \"yodafy\",\n    selectionContent,\n  });\n\n  return result;\n}"
  },
  "fileTypePerExtension": {
    "name": "fileTypePerExtension",
    "slug": "TsVariable",
    "id": "didpwgncbjupponllypjvfta",
    "description": "",
    "operationName": "ai-types"
  },
  "languageModels": {
    "name": "languageModels",
    "slug": "TsVariable",
    "id": "pbuqekxzpnccopoewoqnqnzx",
    "description": "",
    "operationName": "ai-types"
  },
  "augmentMarkdown": {
    "name": "augmentMarkdown",
    "slug": "TsFunction",
    "id": "xhdkznauqnssijxblghzfnis",
    "description": "Now that I've written this all down, it seems to be a quite an expensive operation, but we never need to do it for ensire websites, just for one page, and the result can easily be cached. I need to write a regex function that matches all text from a list of searchterms in markdown except if it's part of a link or image, and reduce the matches, creating a new markdown string every time. I think there are algorithms though that are more efficient because if there are like thousands of matches on a 2mb text, the thing would take much longer. Maybe it's more efficient to split up the text in smaller pieces and do the regex for every piece individually. This would have a limitation that you can't select cross-section, but I don't think that's my usecase anyway. If we later add support for making statements about a chapter or subsection and stuff like that, this limitation can also be resolved.\n\nAugments markdown in many ways for multiple purposes.\n\n- Parse the markdown instead of showing the results as React buttons. The link to \"#\" alt can become the same as a nice AugmentedWord hover, when it's found to be a selection result, we can highlight the selection whenever we hover over a link with that same text as alt as well, and add that hover as a note at the end of the selection.\n- ensure the parse parses `WordCombination`, `WordMatrix`, `Statement`, `AugmentedWord`, and `ContextualPromptResult`. It's a lot of work, but definitely worth it. Should be parsed as\n- remove the parsing of everything in the markdown render. This is also the end of sending `AugmentedWord`s to the frontend\n\nLATER:\n\n- CTA's, headers, footers, ads (check how I was planning to get those at codestorys-node or so)\n- Word frequency occurency styling\n- Subtexts and subwords",
    "operationName": "generative-functions-node",
    "rawText": " async <T extends string | null | undefined>(\n  markdown: T,\n  config?: {\n    isAdmin?: boolean;\n    /**\n     * TODO: make this faster first by finding all codeblocks in the file first (if this is enabled) and taking a subset of the mapped object then (mapped object  from sdk) and then placing it into the md\n     */\n    augmentCode?: boolean;\n    augmentWords?: boolean;\n    augmentStatements?: boolean;\n    /**\n     * Useful for sites like dev.to and medium where I don't have the capability for creating my own context-menu\n     */\n    augmentContextualPrompts?: boolean;\n    augmentContextualPromptResults?: boolean;\n    markdown_projectRelativeFilePath?: string;\n    /**\n     * If given, all augmented hyperlinks will be absolute to this given domain. Useful for posting on other sites\n     */\n    externalHost?: string;\n  }\n): Promise<{\n  augmentedMarkdown: T;\n  /**\n   * Still needed if you want to show the variants and derivatives in your own way\n   */\n  contextualPromptResults?: ContextualPromptResult[] | null;\n  /**\n   * Still needed if you watn to make it possible to do prompts in another way\n   */\n  contextualPromptsObject?: Omit<\n    ContextualPromptsObject,\n    \"databaseContextualPromptSlugs\"\n  >;\n}> => {\n  if (!markdown || markdown.trim() === \"\") {\n    // no markdown, just return the input\n    return {\n      augmentedMarkdown: markdown,\n    };\n  }\n\n  const {\n    isAdmin,\n    augmentCode,\n    augmentContextualPrompts,\n    augmentContextualPromptResults,\n    augmentStatements,\n    augmentWords,\n    markdown_projectRelativeFilePath,\n    externalHost,\n  } = destructureOptionalObject(config);\n  // do stuff with this configuration here\n\n  const fileType = getFileTypeFromPath(markdown_projectRelativeFilePath);\n\n  const augmentedWordObject = augmentCode\n    ? await getAugmentedWordObject()\n    : undefined;\n  // we need all prompts that seem interesting for this type of content\n\n  const isDev = isAdmin || process.env.NODE_ENV !== \"production\";\n\n  // we can't augment this to the markdown because it's a much more interactive thing, it probably wouldn't work. unless I do something with hyperlinks to the original content, where I make a page that lets you sign up to prompt something ðŸ¤¯ this way I can integrate with any place that accepts hyperlinks in posts (linkedin, medium, dev.to, etc.)\n  const { databaseContextualPromptSlugs, ...contextualPromptsObject } =\n    await getContextualPrompts(\n      fileType === \"other\" ? undefined : fileType,\n      undefined,\n      isDev\n    );\n\n  //WordCombination, WordMatrix, Statement, AugmentedWord, and ContextualPromptResult\n\n  const contextualPromptResults = augmentContextualPromptResults\n    ? (\n        (await getContextualPromptResults({\n          promptSlugs: databaseContextualPromptSlugs,\n          prompt_projectRelativePath: markdown_projectRelativeFilePath,\n        })) || []\n      ).filter((x) => {\n        if (isDev) return true;\n        return !x.isFake && x.isFavorite;\n      })\n    : [];\n\n  const wordMatrixs = augmentWords\n    ? (await db.get(\"WordMatrix\")).map((x) =>\n        getSubsetFromObject(x, [\n          \"slug\",\n          \"name\",\n          \"description\",\n          \"descriptionAudio\",\n          \"emoji\",\n          \"image\",\n          \"rank\",\n          \"priorityLevel\",\n          \"type\",\n          \"usageCountCalculated\",\n          \"english\",\n        ])\n      )\n    : [];\n\n  const mappedWordMatrix = createMappedObject(wordMatrixs, \"slug\");\n\n  const wordCombinations = augmentWords ? await db.get(\"WordCombination\") : [];\n  const statements = augmentStatements ? await db.get(\"Statement\") : [];\n\n  // `tsFunctions, tsVariables, tsInterfaces`: find words between backticks, replace the word between `backticks` with `[\"term\"(---description and maybe code---)](url-to-file-or-#)`\n  //  to support multiline tooltips, the augmented markdown should contain `<br>` instead of newlines in the alt. It should be a configuration, and if newlines should be disabled, the tooltip should show only that that is capable of being on a single line.\n\n  const markdownWithCodespanAugmentation = markdown\n    .split(\" \")\n    .map((word) => {\n      if (!word.startsWith(\"`\") || !word.endsWith(\"`\")) {\n        return word;\n      }\n\n      const wordWithoutBackticks = word.slice(1, word.length - 1);\n\n      const augmentedWord = augmentedWordObject?.[wordWithoutBackticks];\n      if (!augmentedWord || !augmentedWord.spoiler) {\n        return word;\n      }\n\n      return makeMarkdownLink(\n        wordWithoutBackticks,\n        undefined,\n        augmentedWord.spoiler\n      );\n    })\n    .join(\" \");\n\n  const markdownAfterContextualPromptResults = contextualPromptResults.reduce(\n    (previousMarkdown, contextualPromptResult) => {\n      if (!contextualPromptResult.selectionString) {\n        // console.log(\"NO selectionString\");\n        return previousMarkdown;\n      }\n\n      const newMarkdown: string = previousMarkdown.replace(\n        contextualPromptResult.selectionString,\n        `${contextualPromptResult.selectionString} ${makeMarkdownLink(\n          \"?\",\n          undefined,\n          `${contextualPromptResult.selectionString}\\n\\n${contextualPromptResult.contextualPromptSlug}\\n\\n${contextualPromptResult.resultText}`\n        )}`\n      );\n\n      return newMarkdown;\n    },\n    markdownWithCodespanAugmentation\n  );\n  /**\n     `statements and selection results`: add [\"?\"(----reader-agreement, agreement, importancy, results----)](link-to-knowledge-base-or-#) at the end of the selection/statement\n     \n     Most expensive now are statements (selection results are limited because they are tied to the file already, but statements are not). We can later enhance the efficiency of statements to index which wordMatrix words they tie to, and filter out the unneeded ones this way.\n\n     */\n  const markdownAfterStatements = statements.reduce((previous, statement) => {\n    /**\n     * how to get this efficiently even if the propmt reulsts aren't always part of it? tough titty\n     */\n    const newMarkdown = previous.replace(\n      statement.description,\n      `${statement.description} ${makeMarkdownLink(\n        \"?\",\n        undefined,\n        `Statement: ${statement.description}.\\n\\nreaders-agreement: ${statement.readersAgreement}, agreement: ${statement.agreement}, importancy ${statement.importancy}`\n      )}`\n    );\n    return newMarkdown;\n  }, markdownAfterContextualPromptResults);\n\n  const markdownAfterWordCombinations = wordCombinations.reduce(\n    (previousMarkdown, wordCombination) => {\n      const words: Pick<\n        WordMatrix,\n        | \"english\"\n        | \"slug\"\n        | \"name\"\n        | \"description\"\n        | \"descriptionAudio\"\n        | \"emoji\"\n        | \"image\"\n        | \"rank\"\n        | \"priorityLevel\"\n        | \"type\"\n        | \"usageCountCalculated\"\n      >[] =\n        wordCombination.wordMatrixSlugs\n          ?.map((slug) =>\n            mappedWordMatrix[slug] ? mappedWordMatrix[slug] : undefined\n          )\n          .filter(notEmpty) || [];\n\n      // TODO: later I can add things like audio and statistics\n      const wordDefinitions = words\n        .map((word) => {\n          return `${word.name}: ${word.description}`;\n        })\n        .join(\"\\n\\n\");\n      const fullDescription = `${wordCombination.description}\\n\\n${wordDefinitions}`;\n      // `wordCombinations`: replace term with `[\"term\"(----description----)](link-to-website-or-#)` where description is the description of the term, but below that also all word definitions of the underlying wordmatrix words are explained\n      const newMarkdown = previousMarkdown.replace(\n        wordCombination.name,\n        makeMarkdownLink(wordCombination.name, undefined, fullDescription)\n      );\n\n      return newMarkdown;\n    },\n    markdownAfterStatements\n  );\n\n  /**\n  TODO:\n  LATER:\n\n  First I need to fix that I can either ADD things into a broader link that is already encapsulating something. Then I can do either that or create a new one. That will be the best solution\n\n  - `wordMatrixs`: if there is a wordcombination here already this doesn't matter. Otherwise, just replace the word with `[\"word\"(---description, audio, etc---)](#)`\n\n  - `prompts`: add the prompts like `[\"promptname\"(prompt-description)](link-to-execute-prompt?selection=abcdefg)` at the end of a header section for selection prompts, and at the end of a page for page-prompts\n\n  */\n  const augmentedMarkdown = markdownAfterWordCombinations as NonNullable<T>;\n\n  // console.log({ augmentedMarkdown });\n  return {\n    contextualPromptResults,\n    augmentedMarkdown,\n    contextualPromptsObject,\n  };\n}"
  },
  "canSeeFileContent": {
    "name": "canSeeFileContent",
    "slug": "TsFunction",
    "id": "ruefauecgxdxptzqgxcmonmh",
    "description": "",
    "operationName": "generative-functions-node",
    "rawText": " (\n  parameters: Frontmatter | undefined,\n  isDev: boolean\n) => {\n  // dev can always see it\n  if (isDev) {\n    return true;\n  }\n\n  // no parameters seems fine\n  if (!parameters) {\n    return true;\n  }\n\n  if (parameters.isDraft === \"true\" || parameters.isSecret === \"true\") {\n    return false;\n  }\n\n  if (\n    parameters.authorizedGroup?.trim() === \"premium\" ||\n    parameters.authorizedGroup?.trim() === \"enterprise\"\n  ) {\n    // for now we have no way to check if you're premium/enterprise\n    return false;\n  }\n\n  if (parameters.isPrivate === \"true\") {\n    //\n    return false;\n  }\n\n  return true;\n}"
  },
  "canSeeFile": {
    "name": "canSeeFile",
    "slug": "TsFunction",
    "id": "gjsaytrixwhpqaiswtilwmov",
    "description": "TODO: use something like this to ensure we have the type safety and not work with strings >.<\n\n```ts\nimport { frontmatterToObject } from \"frontmatter-util\";\nimport webMarkdownFileTsInterface from \"markdown-types/db/ts-interfaces/webmarkdownfile.json\";\n```",
    "operationName": "generative-functions-node",
    "rawText": " (\n  parameters: FolderContent | undefined,\n  isDev: boolean\n) => {\n  // dev can always see it\n  if (isDev) {\n    return true;\n  }\n\n  // no parameters seems fine\n  if (!parameters) {\n    return true;\n  }\n\n  if (parameters.isDraft || parameters.isSecret) {\n    return false;\n  }\n\n  if (\n    parameters.authorizedGroup === \"premium\" ||\n    parameters.authorizedGroup === \"enterprise\"\n  ) {\n    // for now we have no way to check if you're premium/enterprise, but we can still see them\n    return true;\n  }\n\n  if (parameters.isPrivate) {\n    // private files can still be seen, just not the content\n    return true;\n  }\n\n  return true;\n}"
  },
  "expandFrontmatter": {
    "name": "expandFrontmatter",
    "slug": "TsFunction",
    "id": "qvaflqeunzzsrrlwmzfrnyeq",
    "description": "",
    "operationName": "generative-functions-node",
    "rawText": " (frontmatter?: Frontmatter) => {\n  if (!frontmatter) return {};\n  return {\n    isPrivate: frontmatter.isPrivate === \"true\",\n    authorizedGroup: frontmatter.authorizedGroup,\n    isDraft: frontmatter.isDraft === \"true\",\n    isSecret: frontmatter.isSecret === \"true\",\n  };\n}"
  },
  "findClosestAbsolutePath": {
    "name": "findClosestAbsolutePath",
    "slug": "TsFunction",
    "id": "tzddbqsbjizxrjgypftxwmwl",
    "description": "",
    "operationName": "generative-functions-node",
    "rawText": " async (\n  absoluteQueryPath: string\n): Promise<{\n  absoluteQueryPath: string;\n  isFile?: boolean;\n  isFolder?: boolean;\n}> => {\n  const pathExists = fs.existsSync(absoluteQueryPath);\n\n  const stats = pathExists ? await fs.stat(absoluteQueryPath) : null;\n  const isFile = stats?.isFile();\n  const isFolder = stats?.isDirectory();\n\n  const isValidPath = pathExists && (isFile || isFolder);\n\n  if (isValidPath) return { absoluteQueryPath, isFile, isFolder };\n\n  // no valid path\n\n  const folderUpPath = getFolderJs(absoluteQueryPath);\n\n  return findClosestAbsolutePath(folderUpPath);\n}"
  },
  "getContextualPromptResults": {
    "name": "getContextualPromptResults",
    "slug": "TsFunction",
    "id": "izahdebtzcfyguqvxlvyxvtp",
    "description": "Gets all contextualPromptResults, but only if specific things are true\n\n- For any prompt we have for this filetype: get it from the database\n- For prompts about a folder: path/to/folder/.index/prompt-results.json\n- For prompts about a file or a selection thereof: path/to/folder/.index/[filename]/prompt-results.json\n\nNB: the slug of the ones in index should be the ID, and does not need to be set by the user, because we cannot guarantee that it's no duplicate.",
    "operationName": "generative-functions-node",
    "rawText": " async (config?: {\n  /**\n   * If given, will only provide `ContextualPromptResult`s for this path\n   */\n  prompt_projectRelativePath?: string;\n  /**\n   * If given, will only return the db result if it is part of this array\n   */\n  promptSlugs?: string[];\n}): Promise<ContextualPromptResult[] | null> => {\n  const { prompt_projectRelativePath, promptSlugs } =\n    destructureOptionalObject(config);\n\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    console.log(\"NO projectroot in getContextualPromptResults.ts\");\n    return null;\n  }\n  const prompt_absolutePath = prompt_projectRelativePath\n    ? path.join(projectRoot, prompt_projectRelativePath)\n    : undefined;\n\n  const exists = prompt_absolutePath\n    ? fs.existsSync(prompt_absolutePath)\n    : undefined;\n\n  const stats =\n    exists && prompt_absolutePath\n      ? await fs.stat(prompt_absolutePath)\n      : undefined;\n\n  const isFolder = stats ? stats.isDirectory() : false;\n  const isFile = stats ? stats.isFile() : false;\n  const pathParse = prompt_absolutePath\n    ? path.parse(prompt_absolutePath)\n    : undefined;\n\n  if (prompt_absolutePath && !exists) {\n    console.log(\"You gave a path that doesn't exist\", { prompt_absolutePath });\n    return null;\n  }\n\n  const dbResults = (await db.get(\"ContextualPromptResult\")).map(\n    omitUndefinedValues\n  );\n\n  const onlyForPath = prompt_projectRelativePath\n    ? dbResults?.filter(\n        (x) => x.prompt_projectRelativePath === prompt_projectRelativePath\n      )\n    : dbResults;\n\n  const onlyForPrompts = promptSlugs\n    ? onlyForPath.filter((result) => {\n        if (!result.contextualPromptSlug) return false;\n\n        if (promptSlugs.includes(result.contextualPromptSlug)) return true;\n\n        return false;\n      })\n    : onlyForPath;\n\n  if (!prompt_projectRelativePath || !pathParse || !prompt_absolutePath) {\n    // we don't need the .index one\n    console.log(\"No .index needed\", {\n      prompt_projectRelativePath,\n      pathParse,\n      prompt_absolutePath,\n    });\n    return onlyForPrompts;\n  }\n\n  const contextualPromptResultsJsonPath = isFile\n    ? path.join(pathParse.dir, \".index\", pathParse.name, \"prompt-results.json\")\n    : isFolder\n    ? path.join(prompt_absolutePath, \".index\", \"prompt-results.json\")\n    : undefined;\n\n  if (\n    !contextualPromptResultsJsonPath ||\n    !fs.existsSync(contextualPromptResultsJsonPath)\n  ) {\n    console.log(\"results json path doesn't exist\", {\n      contextualPromptResultsJsonPath,\n    });\n    return onlyForPrompts;\n  }\n\n  const indexResults = await readJsonFile<ContextualPromptResult[]>(\n    contextualPromptResultsJsonPath\n  );\n\n  if (!indexResults) {\n    console.log(\n      \"We tried to read the results but couldn't\",\n      contextualPromptResultsJsonPath\n    );\n    return onlyForPrompts;\n  }\n\n  const allResults: ContextualPromptResult[] = onlyForPrompts\n    .concat(indexResults)\n    .sort((a, b) => {\n      if (a.isFake) return 1;\n      if (b.isFake) return -1;\n      return 0;\n    })\n    .sort((a, b) => {\n      if (a.isFavorite) return -1;\n      if (b.isFavorite) return 1;\n      return 0;\n    });\n  return allResults;\n}"
  },
  "getContextualPromptsArray": {
    "name": "getContextualPromptsArray",
    "slug": "TsFunction",
    "id": "iixjwveqctzlsxtyhmyqjuvm",
    "description": "Wrapper around the database to support the usecase of storing a file in a custom location for contextualPrompts.",
    "operationName": "generative-functions-node",
    "rawText": " async (\n  /**\n   * If available, will also get the scoped context\n   */\n  scopeProjectRelativePath?: string\n): Promise<{\n  databaseResult: ContextualPrompt[];\n  scopeResult?: ContextualPrompt[];\n}> => {\n  const databaseResult = await db.get(\"ContextualPrompt\");\n  if (!scopeProjectRelativePath) {\n    return { databaseResult };\n  }\n\n  // if we need the scoped contextual prompt, it should be saved in the index of the file itself.\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return { databaseResult };\n\n  // it can be a file or a folder\n\n  const scopeAbsolutePath = path.join(projectRoot, scopeProjectRelativePath);\n\n  if (!fs.existsSync(scopeAbsolutePath)) {\n    return { databaseResult };\n  }\n\n  const stats = await fs.stat(scopeAbsolutePath);\n\n  const parsedScopePath = path.parse(scopeAbsolutePath);\n  const filename = stats.isFile() ? parsedScopePath.base : undefined;\n  const scopeFolderPath = stats.isDirectory()\n    ? scopeAbsolutePath\n    : parsedScopePath.dir;\n  const scopeAbsoluteDbPath = path.join(\n    scopeFolderPath,\n    getFolderRelativeScopeDbFilePath(filename)\n  );\n\n  if (!fs.existsSync(scopeAbsoluteDbPath)) return { databaseResult };\n\n  // if it exists, add it to the result\n  const jsonString = await fs.readFile(scopeAbsoluteDbPath, \"utf8\");\n  const scopeResult = tryParseJson<ContextualPrompt[]>(jsonString);\n  if (!scopeResult) return { databaseResult };\n\n  const finalScopeResult: ContextualPrompt[] = scopeResult.map((x) => ({\n    ...x,\n    scopeProjectRelativePath,\n  }));\n\n  // add the scopeProjectRelativePath so we don't need to store it in the db\n  return {\n    databaseResult,\n    scopeResult: finalScopeResult,\n  };\n}"
  },
  "getContextualPrompts": {
    "name": "getContextualPrompts",
    "slug": "TsFunction",
    "id": "wzoqrvtohdecodcffjiktbpw",
    "description": "Returns all contextual prompts for the selection and for the page with the right context type",
    "operationName": "generative-functions-node",
    "rawText": " async (\n  /**\n   * If not given, will return all\n   */\n  contextType?: FileType,\n  scopeProjectRelativePath?: string,\n  isDev?: boolean\n): Promise<ContextualPromptsObject> => {\n  const contextualPromptsObject = await getContextualPromptsArray(\n    scopeProjectRelativePath\n  );\n\n  const databaseContextualPromptSlugs =\n    contextualPromptsObject.databaseResult.map((x) => x.slug);\n  const contextualPrompts = Object.values(contextualPromptsObject).flat();\n\n  const rightType = contextualPrompts\n    .filter((x) => (contextType ? x.contextType?.includes(contextType) : true))\n    .filter((x) => (isDev ? true : x.isFavorite))\n    .map(omitUndefinedValues)\n    // sort on fav first\n    .sort((a, b) => {\n      if (a.isFavorite && !b.isFavorite) return -1;\n      if (b.isFavorite && !a.isFavorite) return 1;\n      return 0;\n    });\n\n  const selectionContextualPrompts = rightType.filter(\n    (x) => x.usesSelection || x.usesAnyContext\n  );\n\n  const pageContextualPrompts = rightType.filter(\n    (x) => (!x.usesSelection && x.usesContext) || x.usesAnyContext\n  );\n\n  const folderContextualPrompts = rightType.filter(\n    (x) =>\n      (!x.usesSelection && !x.usesContext && x.folderContentContext) ||\n      x.usesAnyContext\n  );\n  return {\n    selectionContextualPrompts,\n    pageContextualPrompts,\n    folderContextualPrompts,\n    databaseContextualPromptSlugs,\n  };\n}"
  },
  "getFirstFile": {
    "name": "getFirstFile",
    "slug": "TsFunction",
    "id": "xinrkvugmmdiflykwyytintk",
    "description": "Gets the first file in a directory:\n\nEither readme or index, or the first file it finds.",
    "operationName": "generative-functions-node",
    "rawText": " async (\n  fullPath: string\n): Promise<string | undefined> => {\n  const content = await fs.readdir(fullPath, {\n    encoding: \"utf8\",\n    withFileTypes: true,\n  });\n  const files = content.filter((x) => x.isFile());\n  const readme = files.find((x) => x.name.toLowerCase() === \"readme.md\")?.name;\n  const index = files.find((x) => x.name.startsWith(\"index.\"))?.name;\n  const firstFile = readme || index || files[0]?.name || undefined;\n  return firstFile;\n}"
  },
  "getFolderRelativeScopeDbFilePath": {
    "name": "getFolderRelativeScopeDbFilePath",
    "slug": "TsFunction",
    "id": "ulripdkdgapffokxerpvsxhi",
    "description": "Function to centralise the convention of the db file location of a scoped prompt",
    "operationName": "generative-functions-node",
    "rawText": " (filename?: string) => {\n  return filename\n    ? `.index/${filename}/contextual-prompts.json`\n    : `.index/contextual-prompts.json`;\n}"
  },
  "getReaderPageProps": {
    "name": "getReaderPageProps",
    "slug": "TsFunction",
    "id": "nqcazxzbfwwevqvliinlbjbn",
    "description": "NB: this thing doesn't know about the basepath, it allows any path in the project.\n\nIdea: would it be easy to allow for path outside of project as well?",
    "operationName": "generative-functions-node",
    "rawText": " async (\n  /**\n   * BasePath for this project\n   */\n  basePath: string,\n  /**\n   * QueryPath as in the URL\n   */\n  queryPath: string,\n  /**\n   * If true, isDev will be overwritten to be false, even in prod\n   */\n  isAdmin?: boolean\n) => {\n  // console.log(\"getReaderPageProps:\", { projectRelativeFilePath });\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { props: { notFound: true, notFoundReason: \"No projectroot\" } };\n  }\n\n  const expectedAbsolutePath = path.join(projectRoot, basePath, queryPath);\n  const { absoluteQueryPath, isFile, isFolder } = await findClosestAbsolutePath(\n    expectedAbsolutePath\n  );\n  const isValidPath = absoluteQueryPath === expectedAbsolutePath;\n\n  const folderPath = isFile\n    ? path.parse(absoluteQueryPath).dir\n    : absoluteQueryPath;\n\n  const dirents = await fs.readdir(folderPath, {\n    withFileTypes: true,\n    encoding: \"utf8\",\n  });\n\n  // TODO: Confirm that this works if you run the server locally. For development locally it should be working\n  const isDev = process.env.NODE_ENV === \"development\";\n\n  const readmeDirent = dirents.find(\n    (x) => x.name.toLowerCase() === \"readme.md\"\n  );\n\n  const readmePath = readmeDirent\n    ? path.join(folderPath, readmeDirent.name)\n    : undefined;\n  const readmeFrontmatter = readmePath\n    ? (await readMarkdownFile(readmePath))?.parameters\n    : undefined;\n  const canSeeFolder = readmePath\n    ? canSeeFileContent(readmeFrontmatter, isDev)\n    : true;\n  // TODO: look in all readmes from basePath until the folder we are, to see if this should be allowed to see. It's very easy now to still see and access content if there's folders inside of folders that should not be allowed to be seen.\n\n  const navigation: FolderContent[] = (\n    await Promise.all(\n      dirents.map(async (dirent) => {\n        // TODO: think about it. Maybe we should do something with symbolic links because we don't want to go deep forever, it could actually be nice to use this feature of the OS as well!\"\n\n        const ignoredFilesFolders = [\".DS_Store\", \".index\"];\n        if (ignoredFilesFolders.includes(dirent.name)) return;\n\n        const fullPath = path.join(folderPath, dirent.name);\n\n        const type = dirent.isDirectory()\n          ? \"folder\"\n          : dirent.isSymbolicLink()\n          ? \"link\"\n          : dirent.isFile()\n          ? \"file\"\n          : \"unknown\";\n\n        const firstFile =\n          type === \"folder\" ? await getFirstFile(fullPath) : undefined;\n\n        /**\n         * If it's a markdown file, take its parameters\n         * If it's a folder, take the parameters of the REAMDE in that folder.\n         */\n        const frontmatter =\n          getExtension(dirent.name) === \"md\"\n            ? (await readMarkdownFile(fullPath))?.parameters\n            : type === \"folder\"\n            ? (await readMarkdownFile(path.join(fullPath, \"README.md\")))\n                ?.parameters\n            : undefined;\n        const folderContent: FolderContent = {\n          type,\n          name: dirent.name,\n          firstFile,\n          frontmatter,\n\n          projectRelativePath: makeRelative(\n            path.join(folderPath, dirent.name),\n            projectRoot\n          ),\n        };\n\n        return folderContent;\n      })\n    )\n  )\n    .filter(notEmpty)\n    .map(({ frontmatter, ...other }) => {\n      const folderContent: FolderContent = {\n        ...other,\n        ...expandFrontmatter(frontmatter),\n      };\n      return folderContent;\n    })\n    .filter((file) => {\n      // filter out the files that should be HIDDEN\n      return canSeeFile(file, isDev);\n    })\n    .map(omitUndefinedValues);\n\n  const markdownParse = isFile\n    ? await readMarkdownFile(absoluteQueryPath)\n    : null;\n\n  const allowedOtherExtensions = [\".ts\", \".tsx\", \".json\"];\n\n  const pathParse = path.parse(absoluteQueryPath);\n\n  const rawContent =\n    isFile && allowedOtherExtensions.includes(pathParse.ext)\n      ? await fs.readFile(absoluteQueryPath, \"utf8\")\n      : undefined;\n\n  // TODO: in case of a folder, we might be able to show an indexed thing based on the information of this emptyness (just the files and folders around it). This could provide a lot of interesting content already.\n  const canSeeContent = canSeeFileContent(markdownParse?.parameters, isDev);\n\n  const fileContentString =\n    !canSeeContent || !canSeeFolder || !isFile\n      ? null\n      : markdownParse\n      ? markdownParse.raw\n      : rawContent\n      ? rawContent\n      : null;\n\n  const augmentedResult = await augmentMarkdown(fileContentString, {\n    // for now no code yet, it's too slow\n    isAdmin,\n    augmentCode: false,\n    augmentContextualPrompts: false,\n    augmentContextualPromptResults: true,\n    augmentStatements: true,\n    augmentWords: true,\n    externalHost: undefined,\n    markdown_projectRelativeFilePath: makeRelative(\n      absoluteQueryPath,\n      projectRoot\n    ),\n  });\n\n  const props: ReaderProps = {\n    notFound: !isValidPath,\n    notFoundReason: isValidPath\n      ? null\n      : `Path isn't valid: ${expectedAbsolutePath}. We found ${absoluteQueryPath}`,\n    isFolder,\n    canSeeContent,\n    unauthorizedWarningMessage: canSeeContent\n      ? null\n      : \"You have to be premium to see this. [Click here to see our offers](/offers)\",\n    markdown: augmentedResult?.augmentedMarkdown || rawContent || null,\n    navigation,\n    actualProjectRelativeFilePath: makeRelative(absoluteQueryPath, projectRoot),\n    contextualPromptResults: augmentedResult?.contextualPromptResults || null,\n    contextualPromptsObject: augmentedResult?.contextualPromptsObject || null,\n  };\n\n  return { props };\n}"
  },
  "makeMarkdownLink": {
    "name": "makeMarkdownLink",
    "slug": "TsFunction",
    "id": "keqqdgalsviymzsirzpezcwe",
    "description": "function that writes markdown for a text + url + alt. This may differ per platform in the end, for now I'll use my own: `[\"text\"(alt)](url)`",
    "operationName": "generative-functions-node",
    "rawText": " (text: string, url?: string, alt?: string) => {\n  return `[${text}](${url || \"#\"}${\n    alt ? ` \"${alt.replaceAll(\"\\n\", \"<br>\").replaceAll('\"', '\\\\\"')}\"` : \"\"\n  })`;\n}"
  },
  "readerPageGetStaticPaths": {
    "name": "readerPageGetStaticPaths",
    "slug": "TsFunction",
    "id": "nwyqgeupmjzysryrghhontea",
    "description": "NB: I can't do this with a fallback , because next.js doesn't include my docs folder into the bundle.\n\nA solution could be to add the docs folder into the next.js folder or copy it...\n\nhttps://github.com/vercel/next.js/discussions/32236?sort=new#discussioncomment-3029649\n\nTher are other workarounds here to make sure it ends up in the bundle.",
    "operationName": "generative-functions-node",
    "rawText": " async () => {\n  // TODO: what does context.locale do? can we use that for the domain or so? because it's the only context we have here , so that might be super useful\n\n  const basePath = process.env.NEXT_PUBLIC_BASEPATH;\n  // can probably also fetch the domain using the api, right? I might be able to determine what the basepath is based on an environment variable.\n\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    console.log(\"NO PROJECTROOT\");\n    return { fallback: \"blocking\", paths: [] };\n  }\n\n  const realBasePath = basePath\n    ? path.join(projectRoot, basePath)\n    : projectRoot;\n\n  const paths = (\n    await explore({ basePath: realBasePath, includeFoldersWithResults: true })\n  ).map((x) => x.path);\n\n  // for now, let's just generate the props every time. later we can fetch the actual paths here, but that would require lots of calculation, so this might actually be fine since it will cache the result. We can also make the page load until the props are provided. I need to read the docs about it to make it all super smooth\n  return {\n    paths: paths.map((path) => {\n      const queryPath = makeRelative(path, realBasePath).split(\"/\");\n      return {\n        params: {\n          queryPath,\n        },\n      };\n    }),\n    // TODO: Maybe needs to be \"false\"?\n    fallback: \"blocking\",\n  };\n}"
  },
  "readerPageGetStaticProps": {
    "name": "readerPageGetStaticProps",
    "slug": "TsFunction",
    "id": "eqtvdpbtrjiklwvoexuwjogq",
    "description": "",
    "operationName": "generative-functions-node",
    "rawText": " async (\n  context: GetStaticPropsContext\n) => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    // NB: this can happen on revalidation and blocked static requests, because we aren't using .projectRoot file anywhere. It's fine\n    console.log(\"NO PROJECTROOT\");\n\n    const props: ReaderProps = {\n      notFound: true,\n      notFoundReason: \"This file cannot be found.\",\n    };\n\n    return { props };\n  }\n\n  const basePath = process.env.NEXT_PUBLIC_BASEPATH;\n\n  // the queryPath from\n  const queryPath = context.params?.queryPath;\n  const realQueryPathArray = queryPath ? makeArray(queryPath) : [];\n  const realQueryPath = realQueryPathArray.join(\"/\");\n\n  const staticPropResult = omitUndefinedValues(\n    await getReaderPageProps(basePath || \"\", realQueryPath, false)\n  );\n\n  return staticPropResult;\n}"
  },
  "Dataset": {
    "name": "Dataset",
    "slug": "TsFunction",
    "id": "edgtgvalwvdvosnuiftqsclh",
    "description": "",
    "operationName": "generative-ui",
    "rawText": " () => {\n  const categoriesQuery = queries.useGetContextualPromptCategories();\n\n  return (\n    <Div id=\"dataset\" className=\"h-screen overflow-y-scroll\">\n      <MarkdownContent\n        config={{}}\n        content={`\\`\\`\\`json\\n${JSON.stringify(\n          categoriesQuery.data?.result,\n          undefined,\n          2\n        )}\\n\\`\\`\\``}\n      />\n    </Div>\n  );\n}"
  },
  "generativeWebInitialValues": {
    "name": "generativeWebInitialValues",
    "slug": "TsVariable",
    "id": "jontnxhhzeksauprerhbyvwp",
    "description": "",
    "operationName": "generative-ui"
  },
  "Menu": {
    "name": "Menu",
    "slug": "TsFunction",
    "id": "cbtmtvcymbqnrwgapwlkshjh",
    "description": "`\"wise\"` component that lets you render a menu easily, including search\n\n-----\n\nTODO:\n\n- provide menu with NestedWebPage<unknown>[]",
    "operationName": "menu",
    "rawText": " (\n  props: MenuProps & {\n    message?: string;\n  }\n) => {\n  const {\n    queryPaths,\n    isLoading,\n    message,\n    augmentedWords,\n    webPagesNested,\n    webPagesFlat,\n    menuHeader,\n  } = props;\n\n  const realWebPages: NestedWebPage[] =\n    !webPagesNested && queryPaths\n      ? getLegacyMenu(queryPaths) || []\n      : webPagesNested || [];\n\n  const [showMenu, setShowMenu] = useStore(\"menu.showMenu\");\n\n  useHotkey(isCtrlP, () => setShowMenu(true), []);\n  useHotkey(isAltB, () => setShowMenu(!showMenu), [showMenu]);\n\n  const [isMobileMenuEnabled, setIsMobileMenuEnabled] = useStore(\n    \"menu.isMobileMenuEnabled\"\n  );\n\n  /**\n   * This is a slow function to calculate for a lot of paths, needs to be optimised\n   */\n\n  const [search, setSearch] = useState(\"\");\n  const isSearching = search.length > 0;\n\n  const closeMenu = (\n    <Div className=\"lg:hidden\">\n      <Div>\n        <ClickableIcon\n          emoji=\"â•³\"\n          onClick={() => {\n            setIsMobileMenuEnabled(false);\n          }}\n        />\n      </Div>\n    </Div>\n  );\n\n  return (\n    <Div>\n      <Div className=\"flex flex-row justify-between w-full\">\n        {menuHeader?.()}\n        {closeMenu}\n      </Div>\n\n      <Input\n        value={search}\n        placeholder=\"Search\"\n        onChange={(e) => setSearch(e.target.value)}\n        className=\"border px-2 border-white bg-transparent w-full rounded-lg h-9 focus:outline-none\"\n        autoComplete=\"off\"\n      />\n\n      {isLoading ? (\n        <FancyLoader />\n      ) : isSearching && webPagesFlat ? (\n        <PathSearchResults\n          search={search}\n          paths={webPagesFlat.map((x) => x.queryPath)}\n          augmentedWords={augmentedWords}\n        />\n      ) : !isSearching && realWebPages ? (\n        <NestedMenu items={realWebPages} headersClickable />\n      ) : (\n        <P>{message || \"Menu.tsx: Something's wrong, no message given\"}) </P>\n      )}\n    </Div>\n  );\n}"
  },
  "NavButton": {
    "name": "NavButton",
    "slug": "TsFunction",
    "id": "borsirfyxyxsoiyzpyorfpcv",
    "description": "",
    "operationName": "generative-ui",
    "rawText": " (props: {\n  onClick?: () => void;\n  href?: string;\n  isActive?: boolean;\n  title: string;\n  id?: string;\n  openContextMenuProps?: object;\n}) => {\n  const { href, title, onClick, isActive, openContextMenuProps, id } = props;\n\n  const className = ` ${\n    isActive ? \"dark:bg-blue-800\" : \"dark:bg-gray-700\"\n  } dark:hover:bg-gray-600 ${\n    isActive ? \"bg-blue-300\" : \"bg-gray-100\"\n  } light:hover:bg-gray-200 rounded-md border border-black p-2 m-1 cursor-pointer lg:mx-2`;\n  if (onClick) {\n    return (\n      <P\n        id={id}\n        onClick={onClick}\n        className={className}\n        {...openContextMenuProps}\n      >\n        {title}\n      </P>\n    );\n  }\n\n  return (\n    <ALink id={id} href={href} className={className}>\n      <div id={id} {...openContextMenuProps}>\n        {title}\n      </div>\n    </ALink>\n  );\n}"
  },
  "promo": {
    "name": "promo",
    "slug": "TsVariable",
    "id": "ejnnepsknvodeeepffsdqfdy",
    "description": "",
    "operationName": "generative-ui"
  },
  "PromptButton": {
    "name": "PromptButton",
    "slug": "TsFunction",
    "id": "fvikfuldlljhqccjvdyyonyn",
    "description": "",
    "operationName": "generative-ui",
    "rawText": " (props: {\n  item: ContextualPrompt;\n  markdown?: string | null;\n  projectRelativeFilePath?: string;\n}) => {\n  const { item, markdown, projectRelativeFilePath } = props;\n  const admin = useAdmin();\n  const router = useRouter();\n  const showPromptAlert = usePromptResultAlert();\n  const alert = useAlert();\n  const title = `${item.isFavorite ? \"â­ï¸ \" : \"\"}${item.title || item.name}`;\n\n  return (\n    <Tooltip\n      hoverTimeout={100}\n      tooltip={\n        admin.isAdminActive ? (\n          <Div>\n            <P>{title}</P>\n            {item.description ? (\n              <MarkdownContent content={item.description} config={{}} />\n            ) : null}\n            <ClickableIcon\n              emoji=\"ðŸ—‘ Delete\"\n              onClick={async () => {\n                // delete prompt\n                const apiResult = await api.deleteDbModel(\n                  \"ContextualPrompt\",\n                  item.id\n                );\n\n                showStandardResponse(apiResult);\n\n                if (apiResult?.result?.isSuccesful) {\n                  admin.refetch?.();\n                }\n              }}\n            />\n            <ClickableIcon\n              emoji=\"âœï¸ Edit\"\n              onClick={() => {\n                // go to upsert ContextualPrompt db page.\n                router.push(`/edit/ContextualPrompt?id=${item.id}`);\n              }}\n            />\n\n            <ClickableIcon\n              emoji=\"ðŸ’¥ Apply on folder\"\n              onClick={() => {\n                alert?.(\n                  \"Apply on folder\",\n                  `You're going to apply the prompt ${item.name} on this whole folder. Are you sure?`,\n                  [\n                    { style: \"cancel\", text: \"cancel\" },\n                    {\n                      style: \"default\",\n                      text: \"Yes\",\n                      onPress: () => {\n                        warningToast(\"Not implemented yet. Coming soon\");\n                      },\n                    },\n                    {\n                      style: \"destructive\",\n                      text: \"Yes, recursive\",\n                      onPress: () => {\n                        warningToast(\"Not implemented yet. Coming soon\");\n                      },\n                    },\n                  ]\n                );\n              }}\n            />\n          </Div>\n        ) : null\n      }\n      placement=\"top\"\n    >\n      <NavButton\n        onClick={async () => {\n          if (!markdown) return;\n          await processPrompt({\n            contextualPromptSlug: item.slug,\n            showPromptAlert,\n            contextualContent: {\n              contextContent: markdown,\n              contextSelection: null,\n              context_projectRelativeFilePath: projectRelativeFilePath,\n            },\n          });\n\n          router.replace({\n            query: {\n              queryPath: router.query.queryPath,\n              variant: item.slug,\n            },\n          });\n        }}\n        title={item.title || item.name}\n      />\n    </Tooltip>\n  );\n}"
  },
  "ReaderPageNext": {
    "name": "ReaderPageNext",
    "slug": "TsFunction",
    "id": "zjtcexqisemtruvumcgzdmsj",
    "description": "ReaderPage to export for next project. Uses either the props from the next server, or if they're available, the props from the query.",
    "operationName": "generative-ui",
    "rawText": " (props: ReaderProps) => {\n  // props provide the static data for the website\n  const queryPath = useQueryPath();\n  const basePath = process.env.NEXT_PUBLIC_BASEPATH;\n\n  const readerPageQuery = queries.useGetReaderPageProps(\n    basePath || \"\",\n    queryPath,\n    true\n  );\n\n  const queryProps = readerPageQuery.data?.result?.props;\n\n  // either use the props returned from the query or from the static site\n  const realProps = queryProps?.actualProjectRelativeFilePath\n    ? queryProps\n    : props;\n\n  return <ReaderPage {...realProps} />;\n}"
  },
  "ReaderPage": {
    "name": "ReaderPage",
    "slug": "TsFunction",
    "id": "tqmvmyaaphtqbydodlhyrqzs",
    "description": "",
    "operationName": "generative-ui",
    "rawText": " (props: ReaderProps) => {\n  const [sidebarHidden, setSidebarHidden] = useState(false);\n  const router = useRouter();\n  const [isEditing, setIsEditing] = useStore(\"generativeWeb.isEditing\");\n  const [customUrl, setCustomUrl, customUrlInfo] = useStore(\"api.customUrl\");\n  const [_, setAuthToken] = useStore(\"api.authToken\");\n  const admin = useAdmin();\n  const queryPath = router.asPath.slice(1);\n  const showPromptAlert = usePromptResultAlert();\n  const alert = useAlert();\n\n  const {\n    markdown,\n    actualProjectRelativeFilePath,\n    contextualPromptResults,\n    contextualPromptsObject,\n    navigation,\n    isFolder,\n    canSeeContent,\n    unauthorizedWarningMessage,\n    notFound,\n  } = props;\n\n  const onFocus = async () => {\n    if (!customUrlInfo.hydrated) {\n      return;\n    }\n    const localUrl = \"http://localhost:42000\";\n\n    if (customUrl === localUrl) {\n      return;\n    }\n\n    const isAlive = (await apiWithConfig.ping({ apiUrl: localUrl })).result;\n\n    if (isAlive) {\n      setCustomUrl(localUrl);\n      // NB: Hardcoded?\n      setAuthToken(\"xwjkfycqhakpudymxmysxlei\");\n      alert?.(\n        \"Connected to localhost\",\n        \"It seems your server is running locally, you're now connected. You can now interact with your local file system to apply prompts on your own knowledge base!\",\n        [\n          { text: \"Okay\", style: \"default\", onPress: () => router.reload() },\n          {\n            text: \"Undo\",\n            style: \"destructive\",\n            onPress: () => {\n              setCustomUrl(null);\n            },\n          },\n        ]\n      );\n    }\n  };\n\n  React.useEffect(() => {\n    window.addEventListener(\"focus\", onFocus);\n    //   window.addEventListener(\"blur\", onBlur);\n    // Calls onFocus when the window first loads\n    onFocus();\n    // Specify how to clean up after this effect:\n    return () => {\n      window.removeEventListener(\"focus\", onFocus);\n      //  window.removeEventListener(\"blur\", onBlur);\n    };\n  }, []);\n\n  const projectRelativeBaseFolderPath = isFolder\n    ? actualProjectRelativeFilePath\n    : getFolderJs(actualProjectRelativeFilePath);\n\n  const filename = isFolder\n    ? undefined\n    : getFileOrFolderName(actualProjectRelativeFilePath);\n\n  const thePrompts = isFolder\n    ? contextualPromptsObject?.folderContextualPrompts || []\n    : contextualPromptsObject?.pageContextualPrompts || [];\n\n  const fileContextualPromptResults = contextualPromptResults?.filter(\n    (x) => !x.selectionString\n  );\n  const selectionContextualPromptResults = contextualPromptResults?.filter(\n    (x) => !!x.selectionString\n  );\n\n  const variantResult = useVariantResult(contextualPromptResults);\n  // const fileType =\n  //   fileTypePerExtension[\n  //     getExtension(\n  //       props.projectRelativeFilePath\n  //     ) as keyof typeof fileTypePerExtension\n  //   ] || undefined;\n  // NB: this doesn't allow inline links so we cannot use this type of color highlihgting...\n  const codeblockWrappedMarkdown = variantResult?.resultText\n    ? variantResult?.resultText\n    : // : fileType === \"code\"\n      // ? `\\`\\`\\`tsx\\n${markdown}\\n\\`\\`\\``\n      // : fileType === \"data\"\n      // ? `\\`\\`\\`json\\n${markdown}\\n\\`\\`\\``\n      markdown;\n\n  const contentString = codeblockWrappedMarkdown\n    ? codeblockWrappedMarkdown\n    : !canSeeContent && unauthorizedWarningMessage\n    ? unauthorizedWarningMessage\n    : props.notFound\n    ? props.notFoundReason || \"Not found\"\n    : \"No content\";\n\n  const folderPath = isFolder ? queryPath : getFolderJs(queryPath);\n\n  const markdownContentConfig = {\n    fileContextualPromptResults,\n    selectionContextualPromptResults,\n    projectRelativeBaseFolderPath,\n    projectRelativeMarkdownFilePath: actualProjectRelativeFilePath,\n    disableSelectionContextMenu: true,\n    selectionPrompts: contextualPromptsObject?.selectionContextualPrompts,\n  };\n\n  const renderEditContent = () => {\n    return (\n      <Div className=\"flex flex-1 flex-col lg:h-full lg:overflow-y-scroll\">\n        <ClickableIcon\n          emoji={isEditing ? \"ðŸª„\" : \"âœï¸\"}\n          onClick={() => setIsEditing(!isEditing)}\n        />\n        {actualProjectRelativeFilePath ? (\n          <FileWriter\n            projectRelativeFilePath={actualProjectRelativeFilePath}\n            markdownModelName=\"CreatorMarkdownFile\"\n            initialWriterView=\"edit\"\n            disabledMenuItems={[\"view\", \"presentation\", \"config\"]}\n          />\n        ) : null}\n      </Div>\n    );\n  };\n\n  const pageContent = (\n    <Div className=\"flex flex-1 flex-col lg:h-full lg:overflow-y-scroll\">\n      {sidebarHidden ? (\n        <Div className=\"max-lg:hidden lg:block flex justify-end\">\n          <ClickableIcon emoji=\"<<\" onClick={() => setSidebarHidden(false)} />\n        </Div>\n      ) : null}\n      <BreadCrumbs path={queryPath} />\n      <VariantSelector\n        projectRelativeFilePath={actualProjectRelativeFilePath}\n        folderPath={folderPath}\n        isFolder={isFolder}\n        filename={filename}\n        contextualPromptResults={fileContextualPromptResults}\n      />\n\n      <Shareable>\n        <Div className={\"p-1\"}>\n          <MarkdownContent\n            config={markdownContentConfig}\n            content={contentString}\n          />\n        </Div>\n      </Shareable>\n\n      <SelectionPrompts\n        contentString={contentString}\n        projectRelativeFilePath={actualProjectRelativeFilePath}\n        selectionContextualPrompts={\n          props.contextualPromptsObject?.selectionContextualPrompts\n        }\n      />\n\n      <Div>\n        <P className=\"font-bold\">File</P>\n        <Div className=\"flex flex-row flex-wrap\">\n          {/* Speak */}\n          <NavButton\n            title=\"ðŸŽ¤ Speak\"\n            onClick={async () => {\n              alert?.(\"Coming soon\", \"coming soon\");\n            }}\n          />\n          {/* Free form */}\n          {isFolder ? null : (\n            <NavButton\n              title=\"ðŸ•Š Free-form prompt\"\n              onClick={async () => {\n                let question = prompt(\n                  \"What do you want to ask/prompt about this file?\"\n                );\n\n                if (!question || question === \"\") {\n                  return;\n                }\n\n                let name = prompt(\n                  \"If we should add this prompt into the database, how should we call it? (leave empty if you don't want to save it)\"\n                );\n\n                const realName = name === \"\" ? null : name;\n\n                const customPromptContent = `I am reading this file:\\n\\n\\`\\`\\`\\n%context\\n\\`\\`\\`\\n\\n${question}`;\n\n                await processPrompt({\n                  contextualContent: {\n                    contextContent: contentString,\n                    context_projectRelativeFilePath:\n                      actualProjectRelativeFilePath,\n                  },\n                  showPromptAlert,\n                  customPromptContent,\n                  saveNewPromptWithName: realName,\n                });\n              }}\n            />\n          )}\n\n          {thePrompts.map((prompt) => {\n            return (\n              <PromptButton\n                key={`prompt${prompt.id}`}\n                item={prompt}\n                markdown={markdown}\n                projectRelativeFilePath={actualProjectRelativeFilePath}\n              />\n            );\n          })}\n        </Div>\n      </Div>\n      {isFolder && admin.isAdminActive ? (\n        <Div>\n          Execute for all files\n          <Div className=\"flex flex-row flex-wrap\">\n            {contextualPromptsObject?.pageContextualPrompts.map((prompt) => {\n              return (\n                <NavButton\n                  onClick={() => {\n                    alert?.(\n                      \"Not implemented yet\",\n                      \"Execute a certain prompt for all files in a folder, recursively. Should not show the result immediately because these things should be queued and the result is too big to show immediately. There should be settings before you execute all prompts: recursively nested folders? how fast should it be executed? Which model? Etc.\"\n                    );\n                  }}\n                  title={prompt.title || prompt.name}\n                />\n              );\n            })}\n          </Div>\n        </Div>\n      ) : null}\n\n      <Div className=\"py-10 mx-2\">\n        <MarkdownContent content={promo} config={{}} />\n      </Div>\n    </Div>\n  );\n\n  const variantsOnLg =\n    !fileContextualPromptResults ||\n    sidebarHidden ||\n    !fileContextualPromptResults.length ? null : (\n      <Div className=\"lg:block max-lg:hidden lg:w-[280px] 2xl:w-[400px] lg:h-full lg:overflow-y-scroll\">\n        <ClickableIcon emoji=\"â•³\" onClick={() => setSidebarHidden(true)} />\n        {fileContextualPromptResults?.map((result) => {\n          if (!result.resultText) return null;\n          return (\n            <Div className=\"m-2 p-2 bg-gray-100 dark:bg-slate-800 rounded-lg\">\n              <Div className=\"w-full flex justify-between\">\n                <P className=\"font-bold\">{result.contextualPromptSlug}</P>\n                <ClickableIcon\n                  emoji=\"ðŸ‘€\"\n                  onClick={() => {\n                    const query: {\n                      queryPath: string | string[] | undefined;\n                      variant?: string;\n                    } = {\n                      queryPath: router.query.queryPath,\n                      variant: result.contextualPromptSlug,\n                    };\n\n                    router.push({ query }, undefined, { shallow: true });\n                  }}\n                />\n              </Div>\n              <MarkdownContent\n                config={markdownContentConfig}\n                content={result.resultText}\n              />\n            </Div>\n          );\n        })}\n      </Div>\n    );\n  return (\n    <Div className=\"lg:flex lg:flex-row h-full\">\n      <Menu\n        notFound={notFound}\n        projectRelativeFilePath={actualProjectRelativeFilePath}\n        folderPath={folderPath}\n        filename={filename}\n        isFolder={isFolder}\n        navigation={navigation}\n        contextualPromptsObject={contextualPromptsObject}\n        fileContextualPromptResults={fileContextualPromptResults}\n        selectionContextualPromptResults={selectionContextualPromptResults}\n        thePrompts={thePrompts}\n      />\n\n      {isEditing ? renderEditContent() : pageContent}\n\n      {variantsOnLg}\n    </Div>\n  );\n}"
  },
  "SelectionPrompts": {
    "name": "SelectionPrompts",
    "slug": "TsFunction",
    "id": "bmnweofjvlngtdzdaoettnev",
    "description": "",
    "operationName": "generative-ui",
    "rawText": " (props: {\n  selectionContextualPrompts?: ContextualPrompt[];\n  contentString: string;\n  projectRelativeFilePath?: string;\n}) => {\n  const showPromptAlert = usePromptResultAlert();\n  const alert = useAlert();\n  const { selectionContextualPrompts, contentString, projectRelativeFilePath } =\n    props;\n  const admin = useAdmin();\n\n  const contextSelection = useLastSelection();\n\n  /**\n   * TODO: also sort them here based on which selection you make (`.contextualContent.contextSelection`) and your settings (probably isFavorite first, but other sorting may be beneficial.\n   */\n  const promptItems: SelectionItem[] =\n    selectionContextualPrompts?.map((prompt) => {\n      const item: SelectionItem = {\n        onClick: () =>\n          processPrompt({\n            contextualPromptSlug: prompt.slug,\n            contextualContent: {\n              contextSelection,\n              contextContent: contentString,\n              context_projectRelativeFilePath: projectRelativeFilePath,\n            },\n            showPromptAlert,\n          }),\n        title: prompt.name || \"Noname\",\n        // TODO: not sure if this is the right level, but eventually we want to filter based on the selection, maybe\n        isEnabled: true,\n      };\n\n      return item;\n    }) || [];\n\n  const selectionWordCount = contextSelection\n    ? contextSelection.split(\" \").length\n    : 0;\n\n  const isStatement = selectionWordCount > 1;\n  const isWord = selectionWordCount <= 4;\n\n  const selectionItems: SelectionItem[] = [\n    {\n      onClick: async () => {\n        if (!contextSelection) {\n          alert?.(\n            \"Select a word\",\n            `You didn't select a word or word-combination (up to 4 words)`\n          );\n          return;\n        }\n        const apiResult = await api.addWord(contextSelection, undefined);\n\n        showStandardResponse(apiResult);\n\n        admin.refetch?.();\n      },\n      title: \"ðŸ§  Add word\",\n      isEnabled: isWord,\n    },\n\n    {\n      onClick: async () => {\n        if (!contextSelection) {\n          alert?.(\n            \"Select a statement\",\n            `You didn't select a statement (minimum 2 words)`\n          );\n          return;\n        }\n\n        // NB: for now, don't let user add agreement and importancy, just assume the defaults. Let's see where this goes first\n\n        const apiResult = await api.addStatement(\n          contextSelection,\n          undefined,\n          undefined\n        );\n\n        showStandardResponse(apiResult);\n\n        admin.refetch?.();\n      },\n      title: \"ðŸ§  Add statement\",\n      isEnabled: isStatement,\n    },\n\n    {\n      title: \"ðŸ•Š Free-form prompt\",\n      isEnabled: true,\n      onClick: async () => {\n        let question = prompt(\"What do you want to ask/prompt?\");\n\n        if (!question || question === \"\") {\n          return;\n        }\n\n        let name = prompt(\n          \"How should we call the prompt? (empty for not storing)\"\n        );\n        const realName = name === \"\" ? null : name;\n\n        const customPromptContent = `I am reading this file:\\n\\n\\`\\`\\`\\n%context\\n\\`\\`\\`\\n\\nMore specifically, I'm looking at this part: \\n\\n\\`\\`\\`\\n%selection\\n\\`\\`\\`\\n\\n${question}`;\n\n        await processPrompt({\n          contextualContent: {\n            contextContent: contentString,\n            context_projectRelativeFilePath: projectRelativeFilePath,\n            contextSelection,\n          },\n          showPromptAlert,\n          customPromptContent,\n          saveNewPromptWithName: realName,\n        });\n      },\n    },\n\n    {\n      title: \"ðŸŽ¤ Speak\",\n      isEnabled: true,\n      onClick: () => {\n        alert?.(\n          \"Coming soon!\",\n          <Div>\n            <P>\n              This button should let you record your voice so you can ask a\n              question through human speech. The speech will be converted into\n              text by whisper, it will then choose an existing prompt action, or\n              if it can't find that, do a free-form prompt.\n            </P>\n\n            <P>\n              P.S. Would be nice if this option is there by default, also for\n              other menus, or it's even accessible via other ways, but this is a\n              great way to try it out first.\n            </P>\n          </Div>\n        );\n      },\n    },\n\n    ...promptItems,\n  ];\n\n  return (\n    <Div>\n      <P className=\"font-bold\">Selection</P>\n      <P>{contextSelection}</P>\n      <Div className=\"flex flex-row flex-wrap\">\n        {selectionItems\n          .filter((selectionItem) => selectionItem.isEnabled)\n          .map((item, index) => {\n            return (\n              <NavButton\n                title={item.title}\n                onClick={item.onClick}\n                key={`sele${index}`}\n              />\n            );\n          })}\n      </Div>\n    </Div>\n  );\n}"
  },
  "setConfig": {
    "name": "setConfig",
    "slug": "TsFunction",
    "id": "zojsizmvwbpfqoxdpqykpsmz",
    "description": "",
    "operationName": "react-with-native-form",
    "rawText": " <TInputs, TState extends { [key: string]: any }>(\n  DataForm: (props: DataFormProps<TInputs, TState>) => JSX.Element,\n  config: DataFormConfig<TInputs>\n) => {\n  return (props: DataFormProps<TInputs, TState>) => {\n    return <DataForm {...config} {...props} />;\n  };\n}"
  },
  "SettingsPage": {
    "name": "SettingsPage",
    "slug": "TsFunction",
    "id": "lgyyxxppajevkbdcquexerov",
    "description": "",
    "operationName": "generative-ui",
    "rawText": " () => {\n  const [config, _, { hydrated }] = useStore(\"generativeWeb.config\");\n  const [customUrl, __, { hydrated: apiHydrated }] = useStore(\"api.customUrl\");\n  return (\n    <Div className=\"max-lg:mx-4 lg:mx-20\">\n      {hydrated && apiHydrated ? (\n        <FunctionForm\n          tsFunction={SetConfigIndex}\n          initialValues={[customUrl, config.disableAdmin]}\n          submitFunction={setConfig}\n          withResult={() => {\n            showStandardResponse({ isSuccessful: true, message: \"Updated\" });\n          }}\n        />\n      ) : (\n        <FancyLoader />\n      )}\n    </Div>\n  );\n}"
  },
  "useAdmin": {
    "name": "useAdmin",
    "slug": "TsFunction",
    "id": "tsjsapnbglmwawbydqmpjegn",
    "description": "Useful hook to make a static site dynamic for administrator",
    "operationName": "generative-ui",
    "rawText": " () => {\n  const queryPath = useQueryPath();\n  const { refetch, isLoading } = queries.useGetReaderPageProps(\n    process.env.NEXT_PUBLIC_BASEPATH || \"\",\n    queryPath,\n    true\n  );\n\n  const meQuery = queries.useGetMeWithContext();\n\n  const isAdmin = !!meQuery.data?.result?.groups?.find(\n    (x: Group) => x.slug === \"admin\"\n  );\n\n  const [config] = useStore(\"generativeWeb.config\");\n\n  const isAdminActive = isAdmin && !config.disableAdmin;\n  const result: {\n    isAdminActive: boolean;\n    isLoading?: boolean;\n    refetch?: typeof refetch;\n  } = isAdminActive\n    ? {\n        isAdminActive,\n        isLoading,\n        refetch,\n      }\n    : { isAdminActive };\n\n  return result;\n}"
  },
  "useQueryPath": {
    "name": "useQueryPath",
    "slug": "TsFunction",
    "id": "izupkgfnaroxvuadxolnendh",
    "description": "Returns the queryPath of your URL without everything after ? and #",
    "operationName": "generative-ui",
    "rawText": " () => {\n  const router = useRouter();\n  const queryPath = router.query.queryPath;\n  const realQueryPathArray = queryPath ? makeArray(queryPath) : [];\n\n  const realQueryPath = realQueryPathArray.join(\"/\");\n  return realQueryPath;\n}"
  },
  "useVariantResult": {
    "name": "useVariantResult",
    "slug": "TsFunction",
    "id": "emopbyhqxltrnomgcenaausg",
    "description": "",
    "operationName": "generative-ui",
    "rawText": " (\n  fileContextualPromptResults?: ContextualPromptResult[] | null\n) => {\n  const router = useRouter();\n  const [defaultVariant] = useStore(\"generativeWeb.defaultVariant\");\n\n  /**\n   * Variant either comes from URL or from the stored default variant slug from localStorage\n   */\n  const variantResultPromptSlug = router.query?.variant\n    ? takeFirst(router.query.variant)\n    : defaultVariant\n    ? defaultVariant\n    : undefined;\n\n  const variantResult = fileContextualPromptResults?.find(\n    (x) => x.contextualPromptSlug === variantResultPromptSlug\n  );\n\n  return variantResult;\n}"
  },
  "VariantSelector": {
    "name": "VariantSelector",
    "slug": "TsFunction",
    "id": "npzbcigdqzacmlsplhvuutng",
    "description": "",
    "operationName": "generative-ui",
    "rawText": " (props: {\n  projectRelativeFilePath?: string;\n  folderPath: string;\n  isFolder?: boolean;\n  filename?: string;\n  contextualPromptResults?: ContextualPromptResult[];\n}) => {\n  const { contextualPromptResults, folderPath, isFolder, filename } = props;\n\n  const router = useRouter();\n  const [defaultVariant, setDefaultVariant] = useStore(\n    \"generativeWeb.defaultVariant\"\n  );\n  const [isEditing, setIsEditing] = useStore(\"generativeWeb.isEditing\");\n  const admin = useAdmin();\n  const variantResult = useVariantResult(contextualPromptResults);\n\n  const resultItems =\n    contextualPromptResults?.map((x) => {\n      const item: Item<string> = {\n        label: `${x.isFake ? \"ðŸ§ª\" : \"\"}${x.isFavorite ? \"â­ï¸\" : \"\"}${\n          x.contextualPromptSlug\n        }`,\n        value: x.contextualPromptSlug,\n      };\n\n      return item;\n    }) || [];\n\n  const items: Item<string>[] = [\n    { label: \"Original\", value: \"___NONE___\" },\n    ...resultItems,\n  ];\n\n  const withValue = (value: Item<string> | null | undefined) => {\n    const query: {\n      queryPath: string | string[] | undefined;\n      variant?: string;\n    } = {\n      queryPath: router.query.queryPath,\n    };\n\n    if (value && value.value && value.value !== \"___NONE___\") {\n      query.variant = value.value;\n    }\n    if (value?.value === \"___NONE___\") {\n      setDefaultVariant(null);\n    }\n    router.push({ query }, undefined, { shallow: true });\n  };\n\n  return (\n    <Div\n      className=\" \n    lg:flex-row lg:w-full w-min\"\n    >\n      <Div className=\"dark:bg-gray-700 dark:hover:bg-gray-600 rounded-md border border-black p-2 m-1 cursor-pointer flex flex-row\">\n        <P>Variant:</P>\n        <Select\n          className=\"bg-transparent\"\n          title=\"Test\"\n          onChange={withValue}\n          value={items.find(\n            (x) => x.value === variantResult?.contextualPromptSlug\n          )}\n          options={items}\n        />\n        {variantResult?.id ? (\n          <ALink\n            href={`${folderPath}/.index/${\n              isFolder ? \"\" : filename ? withoutExtension(filename) : \"\"\n            }`}\n          >\n            Go to index\n          </ALink>\n        ) : null}\n\n        {(variantResult?.contextualPromptSlug || null) !== defaultVariant ? (\n          <ClickableIcon\n            emoji=\"ðŸ“Œ Pin\"\n            onClick={() =>\n              setDefaultVariant(variantResult?.contextualPromptSlug || null)\n            }\n          />\n        ) : null}\n\n        {admin.isAdminActive && !variantResult ? (\n          <ClickableIcon\n            emoji={isEditing ? \"ðŸª„ Reader\" : \"âœï¸ Writer\"}\n            onClick={() => setIsEditing(!isEditing)}\n          />\n        ) : null}\n\n        {variantResult && admin.isAdminActive ? (\n          // delete, star/unstar\n          <Div className=\"flex flex-row\">\n            <ClickableIcon\n              emoji=\"ðŸ—‘\"\n              onClick={async () => {\n                if (!variantResult.prompt_projectRelativePath) return;\n                const apiResult = await api.deletePromptResult(\n                  variantResult.prompt_projectRelativePath,\n                  variantResult.id\n                );\n                showStandardResponse(apiResult);\n\n                if (apiResult?.result?.isSuccessful) {\n                  admin.refetch?.();\n                }\n              }}\n            />\n            <ClickableIcon\n              emoji={variantResult.isFavorite ? \"â­ï¸\" : \"ðŸ’©\"}\n              onClick={async () => {\n                if (!variantResult.prompt_projectRelativePath) return;\n                const apiResult = await api.setIsFavoritePromptResult(\n                  variantResult.prompt_projectRelativePath,\n                  variantResult.id,\n                  !variantResult.isFavorite\n                );\n                showStandardResponse(apiResult);\n\n                if (apiResult?.result?.isSuccessful) {\n                  admin.refetch?.();\n                }\n              }}\n            />\n          </Div>\n        ) : null}\n      </Div>\n    </Div>\n  );\n}"
  },
  "content": {
    "name": "content",
    "slug": "TsVariable",
    "id": "eftixsvsidjcgmlfinyntyjp",
    "description": "- Add tweet button on every page\n- Ensure there's a good unfurling and page titles (SEO)\n- Add a call to action saying something like \"do you want my prompts? Click here\" leading to `db.tsx\"",
    "operationName": "gptideas-web"
  },
  "GptIde": {
    "name": "GptIde",
    "slug": "TsFunction",
    "id": "pcszdjxxozhflczfuuojrfal",
    "description": "",
    "operationName": "gptideas-web",
    "rawText": " () => {\n  const alert = useAlert();\n  const router = useRouter();\n\n  return (\n    <Div\n      id=\"ide\"\n      className=\"flex h-full flex-1 flex-col gap gap-8 justify-center items-center px-4\"\n    >\n      <P className=\"max-lg:text-6xl lg:text-[100pt]\">\n        <b>GPT IDE</b>\n\n        <span className=\"font-serif opacity-50 line-through decoration-red-500/50 hover:decoration-red-500\">\n          AS\n        </span>\n      </P>\n      <TextWriter text=\"Use ChatGPT against the context of your own files (code, data, text)\" />\n\n      <Div className=\"flex flex-row gap gap-6\">\n        <NavButton\n          title=\"Watch Demo\"\n          onClick={() => {\n            alert?.(\n              \"How it works\",\n              <Div className=\"w-80\">\n                <MarkdownContent\n                  content={`https://www.youtube.com/watch?v=qIXb2N7iYb8?autoplay=1&start=3`}\n                  config={{}}\n                />\n              </Div>,\n              [\n                {\n                  onPress: () => router.push(\"/gpt-ide/README.md\"),\n                  text: \"Install\",\n                },\n                { onPress: () => router.push(\"/README.md\"), text: \"Docs\" },\n              ]\n            );\n          }}\n        />\n        <NavButton href=\"/gpt-ide/README.md\" title=\"Install\" />\n      </Div>\n    </Div>\n  );\n}"
  },
  "TextWriter": {
    "name": "TextWriter",
    "slug": "TsFunction",
    "id": "ttcziyhplugfzcfftsvsjqpf",
    "description": "",
    "operationName": "gptideas-web",
    "rawText": " (props: {\n  height?: number;\n  text: string;\n  tooltip?: string;\n}) => {\n  const { text, height, tooltip } = props;\n  const [characters, setCharacters] = useState(0);\n  const [showTypeBlock, setShowTypeBlock] = useState(false);\n  useEffect(() => {\n    setInterval(() => setCharacters((chars) => chars + 1), 50);\n    setInterval(() => setShowTypeBlock((show) => !show), 320);\n  }, []);\n\n  return (\n    <P>\n      {text.slice(0, characters)}\n      {showTypeBlock ? \"â–‹\" : \"â–Ž\"}\n    </P>\n  );\n}"
  },
  "ContextualPromptResultsTab": {
    "name": "ContextualPromptResultsTab",
    "slug": "TsFunction",
    "id": "vchwtrwsjqfsgrarflwqxmaw",
    "description": "Visual to show the different prompt results. Probably deprecated, probably better to show it in a more structured way.",
    "operationName": "prompt-components",
    "rawText": " (props: {\n  prompt_projectRelativePath: string;\n}) => {\n  const { prompt_projectRelativePath } = props;\n\n  const contextualPromptResultsQuery = queries.useGetContextualPromptResults({\n    prompt_projectRelativePath,\n  });\n\n  return (\n    <Div>\n      {contextualPromptResultsQuery.data?.result?.map(\n        (item: ContextualPromptResult) => {\n          return (\n            <Div>\n              <b>prompt</b>\n              {item.prompt ? (\n                <MarkdownContent content={item.prompt} config={{}} />\n              ) : null}\n\n              <b>result</b>\n\n              {item.resultText ? (\n                <MarkdownContent content={item.resultText} config={{}} />\n              ) : null}\n            </Div>\n          );\n        }\n      )}\n    </Div>\n  );\n}"
  },
  "FilePromptSelect": {
    "name": "FilePromptSelect",
    "slug": "TsFunction",
    "id": "eyvfwhwmetbyadwqwqhyvmiz",
    "description": "Component that shows a selectbox for different prompts that can be applied on this file",
    "operationName": "prompt-components",
    "rawText": " (props: {\n  items: ContextualPrompt[] | undefined;\n  contextContent: string;\n  context_projectRelativeFilePath?: string;\n}) => {\n  const { items, contextContent, context_projectRelativeFilePath } = props;\n\n  const contextSelection = useLastSelection();\n  const showPromptAlert = usePromptResultAlert();\n  const alert = useAlert();\n\n  const selectItems = items?.map((prompt) => {\n    const item: Item<string> = { label: prompt.name, value: prompt.id };\n\n    return item;\n  });\n  const allSelectItems = [{ label: \"Select a prompt\", value: \"\" }].concat(\n    selectItems || []\n  );\n  const [SelectComponent, _, setValue] = useSelect(\n    allSelectItems,\n    undefined,\n    async (selection) => {\n      const id = selection?.value;\n\n      const prompt = items?.find((x) => x.id === id);\n\n      if (!prompt) {\n        alert?.(\"Invalid value\");\n        return;\n      }\n\n      setValue(null);\n\n      processPrompt({\n        contextualPromptSlug: prompt.slug,\n        contextualContent: {\n          contextContent,\n          context_projectRelativeFilePath,\n          contextSelection,\n        },\n        showPromptAlert,\n      });\n    }\n  );\n  return <SelectComponent />;\n}"
  },
  "processPrompt": {
    "name": "processPrompt",
    "slug": "TsFunction",
    "id": "ettcopmixwsuvvpxonxoezst",
    "description": "Main function to process a prompt. For now it calls `processChatGptPrompt` api and shows an alert afterwards with the result. In some cases we may want to process the prompt differently, e.g. storing it in a queue.",
    "operationName": "prompt-components",
    "rawText": " async (config: {\n  contextualPromptSlug?: Slug;\n  customPromptContent?: string;\n  contextualContent: ContextualContent;\n  showPromptAlert: ShowPromptAlertFunction;\n  saveNewPromptWithName?: string | null;\n}) => {\n  const {\n    contextualPromptSlug,\n    showPromptAlert,\n    customPromptContent,\n    saveNewPromptWithName,\n    contextualContent: {\n      contextContent,\n      context_projectRelativeFilePath,\n      contextSelection,\n    },\n  } = config;\n\n  const apiResult = await api.processChatGptPrompt({\n    contextContent,\n    selectionContent: contextSelection || null,\n    prompt_projectRelativePath: context_projectRelativeFilePath,\n    isDeferred: true,\n    // not sure about these?\n    contextualPromptSlug,\n    customPromptContent,\n    saveNewPromptWithName,\n    isHeadless: false,\n  });\n\n  if (!apiResult.isSuccessful || !apiResult.result?.isSuccessful) {\n    showStandardResponse(apiResult);\n    return;\n  }\n\n  const title = contextualPromptSlug\n    ? humanCase(contextualPromptSlug)\n    : \"Untitled prompt\";\n\n  showPromptAlert(\n    title,\n    apiResult?.result?.result?.text || \"No textual result\",\n    apiResult?.result?.result?.thread,\n    context_projectRelativeFilePath\n  );\n}"
  },
  "usePromptResultAlert": {
    "name": "usePromptResultAlert",
    "slug": "TsFunction",
    "id": "pwoeiuqpanjilthcjizbgxcd",
    "description": "Recursive hook that calls its own function if you click \"respond\", which creates an additional item in the thread",
    "operationName": "prompt-components",
    "rawText": " () => {\n  // const alert = useAlert();\n\n  const showPromptAlert: ShowPromptAlertFunction = (\n    originalPromptName,\n    _,\n    thread,\n    projectRelativeFilePath\n  ) => {\n    // const markdownRender = (\n    //   <MarkdownContent config={{}} content={textMarkdown || \"No content\"} />\n    // );\n\n    successToast(\n      `${originalPromptName} is now being executed on ${projectRelativeFilePath} (thread: ${thread})`\n    );\n    // const buttons: AlertButton[] = [\n    //   { text: \"Okay\", style: \"cancel\", onPress: () => null },\n    //   {\n    //     text: \"Share\",\n    //     style: \"default\",\n    //     onPress: () => {\n    //       // should open share view\n    //     },\n    //   },\n    //   {\n    //     text: \"Respond\",\n    //     style: \"default\",\n    //     onPress: async () => {\n    //       //  submits extra request that opens a new alert with the answer to that\n    //       let response = prompt(\"What do you want to say?\", \"\");\n\n    //       const apiResult = await api.processChatGptPrompt({\n    //         contextContent: null,\n    //         selectionContent: null,\n    //         contextualPromptSlug: undefined,\n    //         customPromptContent: response || undefined,\n    //         saveNewPromptWithName: null,\n    //         isHeadless: false,\n    //         isDeferred: true,\n    //         thread,\n    //         prompt_projectRelativePath: projectRelativeFilePath,\n    //       });\n\n    //       // NB: Recursion!\n    //       showPromptAlert(\n    //         originalPromptName,\n    //         apiResult.result?.result?.text || \"No response\",\n    //         thread,\n    //         projectRelativeFilePath\n    //       );\n\n    //       // could also enable a loading indicator somewhere\n    //     },\n    //   },\n    // ];\n\n    // alert?.(originalPromptName, markdownRender, buttons);\n  };\n\n  return showPromptAlert;\n}"
  },
  "AssetInput": {
    "name": "AssetInput",
    "slug": "TsFunction",
    "id": "gbdvhquvlqzmibpefopuuuzk",
    "description": "",
    "operationName": "react-with-native-form-asset-input",
    "rawText": " (props) => {\n  const { onChange, value, extra, errors, className } = props;\n\n  const config = props.config || {};\n\n  const hasError = errors && errors.length > 0;\n  const inputClassWithError = `\n  w-full\n  ${InputTheme[extra?.theme]} \n  ${InputSize[extra?.size]}\n    ${\n      hasError\n        ? config.errorClassName\n          ? config.errorClassName\n          : \" border border-red-400\"\n        : \"\"\n    }`;\n\n  return (\n    <OriginalAssetInput\n      attachTokenToFilename={extra.attachTokenToFilename}\n      defaultAssetName={extra.defaultAssetName}\n      projectRelativeReferencingFilePath={\n        extra.projectRelativeReferencingFilePath\n      }\n      modelName={extra.modelName}\n      allowMultiple={extra.allowMultiple}\n      inputTypes={extra.inputTypes}\n      value={value}\n      onChange={(newAssets) => onChange(newAssets)}\n    />\n  );\n}"
  },
  "addToken": {
    "name": "addToken",
    "slug": "TsFunction",
    "id": "ugditexcundpxcvvdtfolnyv",
    "description": "If previousToken is not present, will be generated randomly",
    "operationName": "asset-functions-js",
    "rawText": " (\n  name: string,\n  /**\n   * if given, uses this token, otherwise generates a new random token\n   */\n  previousToken?: string,\n  attachTokenToFilename?: boolean\n): string => {\n  if (!attachTokenToFilename) return name;\n  const newRandomToken = generateRandomString(32);\n  return `${name}${tokenPrefix}${previousToken || newRandomToken}`;\n}"
  },
  "ensureToken": {
    "name": "ensureToken",
    "slug": "TsFunction",
    "id": "aflefvllcqljqfgcffnfkaht",
    "description": "Remove the token (if present), then add it again",
    "operationName": "asset-functions-js",
    "rawText": " (\n  name: string,\n  /**\n   * if given, is used for generating new token\n   *\n   * if already present, token is used from the name instead of this one\n   */\n  newToken?: string,\n  attachTokenToFilename?: boolean\n) => {\n  const { nameWithoutToken, token } = removeTokenIfPresent(\n    name,\n    attachTokenToFilename\n  );\n  const nameWithToken = addToken(\n    nameWithoutToken,\n    token || newToken,\n    attachTokenToFilename\n  );\n  return nameWithToken;\n}"
  },
  "findAssetParametersRecursively": {
    "name": "findAssetParametersRecursively",
    "slug": "TsFunction",
    "id": "ytwbaepmlwkqahnqgtmjqthz",
    "description": "Recursively finds all asset parameters in an object (for example in a database model item)",
    "operationName": "asset-functions-js",
    "rawText": " (\n  object: {\n    [key: string]: any;\n  },\n  stack?: string[]\n): AssetParameter[] => {\n  if (!object) return [];\n\n  const result = Object.keys(object)\n    .map((objectProperty) => {\n      const value = object[objectProperty];\n\n      const assetInputType = getAssetInputType(objectProperty);\n\n      if (assetInputType) {\n        return [\n          {\n            assetInputType,\n            parameterName: objectProperty,\n            stack,\n          },\n        ];\n      }\n\n      if (typeof value === \"object\") {\n        const newStack = stack ? [...stack, objectProperty] : [objectProperty];\n\n        return findAssetParametersRecursively(value, newStack);\n      }\n    })\n    .filter(notEmpty)\n    .flat();\n\n  return result;\n}"
  },
  "getAssetDirectlyApiUrl": {
    "name": "getAssetDirectlyApiUrl",
    "slug": "TsFunction",
    "id": "qdizkjqiupxznmkpyngibaus",
    "description": "",
    "operationName": "asset-functions-js",
    "rawText": " (projectRelativeAssetPath: string) => {\n  return getGetApiUrl(apiUrl, \"function/getAssetDirectlyGetApi\", {\n    projectRelativeAssetPath,\n  });\n}"
  },
  "getConversionInfoFromType": {
    "name": "getConversionInfoFromType",
    "slug": "TsFunction",
    "id": "syqvesanlqasiodksiloiajs",
    "description": "Received files contain a \"type\" like \"audio/mp3\" or \"image/jpeg\", etc...\n\nHere the extension is decided.\n\nNB: we also need to convert the file itself in case of mp3",
    "operationName": "asset-functions-js",
    "rawText": " (\n  uploadMimeType: string | undefined\n): {\n  uploadMimeType: string | undefined;\n  targetFormat: string | undefined;\n  isUnchecked?: boolean;\n} => {\n  const parts = uploadMimeType?.split(\"/\") || [];\n  const firstPart = parts.length > 0 ? parts[0] : undefined;\n  const lastPart = parts.length > 0 ? parts[parts.length - 1] : undefined;\n\n  console.log({ uploadMimeType, lastPart });\n  if (uploadMimeType === \"audio/mp4\") {\n    return { uploadMimeType, targetFormat: \"mp3\" };\n  }\n\n  if (lastPart === \"wav\") {\n    return { uploadMimeType, targetFormat: \"mp3\" };\n  }\n\n  if (lastPart === \"x-m4a\") {\n    return { uploadMimeType, targetFormat: \"mp3\" };\n  }\n\n  if (firstPart === \"audio\") {\n    return { uploadMimeType, targetFormat: \"mp3\" };\n  }\n\n  if (lastPart === \"quicktime\") {\n    return { uploadMimeType, targetFormat: \"mp4\" };\n  }\n\n  if (firstPart === \"video\") {\n    return { uploadMimeType, targetFormat: \"mp4\" };\n  }\n\n  if (firstPart === \"image\") {\n    return { uploadMimeType, targetFormat: \"jpg\" };\n  }\n\n  return { uploadMimeType, targetFormat: lastPart, isUnchecked: true };\n}"
  },
  "getExtensionFromAsset": {
    "name": "getExtensionFromAsset",
    "slug": "TsFunction",
    "id": "bnjaxkhvvllabazxjzsjpspr",
    "description": "Returns a preliminary filename, based on the `Asset`",
    "operationName": "asset-functions-js",
    "rawText": " (asset: Asset) => {\n  const extensionFromType =\n    asset.type === \"audio\"\n      ? `mp3`\n      : asset.type === \"image\"\n      ? `jpeg`\n      : asset.type === \"video\"\n      ? `mp4`\n      : undefined;\n\n  const extension = extensionFromType\n    ? extensionFromType\n    : asset.originalFilename\n    ? getExtension(asset.originalFilename)\n    : asset.relativePath\n    ? getExtension(asset.relativePath)\n    : undefined;\n\n  return extension;\n}"
  },
  "getNameFromRelativePath": {
    "name": "getNameFromRelativePath",
    "slug": "TsFunction",
    "id": "rfjweautsmrcpmzvxhxfhpue",
    "description": "",
    "operationName": "asset-functions-js",
    "rawText": " (relativePath: string) => {\n  const filename = relativePath.split(\"/\").pop()!;\n  const filenameWithoutExtension = withoutExtension(filename);\n  return filenameWithoutExtension;\n}"
  },
  "getNameWithTokenFromRelativePath": {
    "name": "getNameWithTokenFromRelativePath",
    "slug": "TsFunction",
    "id": "bhwxpzczluxbfzeorrqlvgeu",
    "description": "first gets the name from the relativePath\n\nthen ensures the token is attached (if not already there)",
    "operationName": "asset-functions-js",
    "rawText": " (\n  relativePath: string,\n  attachTokenToFilename?: boolean,\n  newToken?: string\n): string => {\n  const name = getNameFromRelativePath(relativePath);\n  if (!attachTokenToFilename) return name;\n  return ensureToken(name, newToken, attachTokenToFilename);\n}"
  },
  "getReferencedAssetApiUrl": {
    "name": "getReferencedAssetApiUrl",
    "slug": "TsFunction",
    "id": "ewnegfqtzvmlzsphkgnyxdbu",
    "description": "",
    "operationName": "asset-functions-js",
    "rawText": " (\n  apiUrl: string | undefined,\n  projectRelativeReferencingFilePath: string,\n  referencingFileRelativeAssetPath: string,\n  /**\n   * If true, asset will be returned as download\n   */\n  isDownload?: boolean\n): string | undefined => {\n  if (!apiUrl) return undefined;\n  return getGetApiUrl(apiUrl, \"getReferencedAssetGetApi\", {\n    projectRelativeReferencingFilePath,\n    referencingFileRelativeAssetPath,\n    isDownload: isDownload ? \"1\" : undefined,\n  });\n}"
  },
  "getTypeFromUrlOrPath": {
    "name": "getTypeFromUrlOrPath",
    "slug": "TsFunction",
    "id": "senimrbkpipdpnqsuxkgaeoc",
    "description": "We are assuming the asset name and extsion appear at the end of the URL",
    "operationName": "asset-functions-js",
    "rawText": " (urlOrPath: string): AssetType => {\n  const extension = getExtension(urlOrPath);\n  if ([\"mp3\", \"m4a\", \"wav\"].includes(extension)) return \"audio\";\n  if ([\"mp4\", \"avi\", \"mov\"].includes(extension)) return \"video\";\n  if ([\"jpeg\", \"jpg\", \"png\", \"gif\", \"svg\"].includes(extension)) return \"image\";\n  if (isText(urlOrPath)) return \"text\";\n  return \"other\";\n}"
  },
  "readableSize": {
    "name": "readableSize",
    "slug": "TsFunction",
    "id": "vrxnadgwsnktdcldnqxqpghg",
    "description": "",
    "operationName": "asset-functions-js",
    "rawText": " (sizeBytes: number): string => {\n  if (sizeBytes < 1024) return `${sizeBytes} bytes`;\n  if (sizeBytes < 1024 * 1024) return `${Math.round(sizeBytes / 1024)} kb`;\n  if (sizeBytes < 1024 * 1024 * 1024)\n    return `${Math.round(sizeBytes / (1024 * 1024))} mb`;\n  if (sizeBytes < 1024 * 1024 * 1024 * 1024)\n    return `${Math.round(sizeBytes / (1024 * 1024 * 1024))} gb`;\n  if (sizeBytes < 1024 * 1024 * 1024 * 1024 * 1024)\n    return `${Math.round(sizeBytes / (1024 * 1024 * 1024 * 1024))} tb`;\n\n  return \"waaaay to big\";\n}"
  },
  "removeTokenIfPresent": {
    "name": "removeTokenIfPresent",
    "slug": "TsFunction",
    "id": "rmqafogekybdstiiqbkuodcy",
    "description": "",
    "operationName": "asset-functions-js",
    "rawText": " (\n  name: string,\n  attachTokenToFilename?: boolean\n) => {\n  if (!attachTokenToFilename) {\n    return { nameWithoutToken: name, token: undefined };\n  }\n  const [nameWithoutToken, token] = name.split(tokenPrefix);\n  return { nameWithoutToken, token: token as string | undefined };\n}"
  },
  "tokenPrefix": {
    "name": "tokenPrefix",
    "slug": "TsVariable",
    "id": "oxpcksgutuzagpquesgyritl",
    "description": "NB: any filename should not be expected to enter this as part of its name. Otherwise it breaks the code and the filename will be changed to the thing before this string.\n\nNB: don't put any things inhere that are different, slugified, as the name will be slugified!",
    "operationName": "asset-functions-js"
  },
  "compressAsset": {
    "name": "compressAsset",
    "slug": "TsFunction",
    "id": "uzqkxdklnblinacihxokygpq",
    "description": "Audio, image, video can be compressed. This should be done to logical defaults, can be turned off, or can be specifically set to other dimensions using a doc-comment on the model.\n\n- audio: bitrate\n- video: fps and resolution\n- image: resolution\n\nReturns the new absolute path of the compressed asset (which can be the same as the initial path)",
    "operationName": "asset-functions-node",
    "rawText": " async (\n  absolutePath: string,\n  compressionConfig: CompressionConfig\n): Promise<string> => {\n  return absolutePath;\n}"
  },
  "deleteReferencedAsset": {
    "name": "deleteReferencedAsset",
    "slug": "TsFunction",
    "id": "ccqytinmsmhxflgwfkrzdhqp",
    "description": "",
    "operationName": "asset-functions-node",
    "rawText": " async (\n  projectRelativeReferencingFilePath: string,\n  referencingFileRelativeAssetPath: string\n) => {\n  const { absoluteAssetPath, message, isSuccessful } =\n    await findAbsoluteAssetPathFromReference(\n      projectRelativeReferencingFilePath,\n      referencingFileRelativeAssetPath\n    );\n\n  if (!absoluteAssetPath) {\n    return { isSuccessful, message };\n  }\n\n  // got `absoluteAssetPath`\n\n  await fs.rm(absoluteAssetPath);\n\n  return { isSuccessful: true, message: \"Deleted the asset\" };\n}"
  },
  "downloadRemoteAsset": {
    "name": "downloadRemoteAsset",
    "slug": "TsFunction",
    "id": "fzmeebteqgtctfwtebhjahye",
    "description": "Download a remote asset to the `assets` folder (temporary location)\n\nused for:\n\n- giphy\n- google images\n- unsplashed\n- p2p\n- youtube to mp3 picker\n- youtube to mp4 picker\n- project assets (via api)",
    "operationName": "asset-functions-node",
    "rawText": " async (): Promise<UploadAssetResult> => {\n  return {\n    isSuccessful: false,\n  };\n}"
  },
  "findAbsoluteAssetPathFromReference": {
    "name": "findAbsoluteAssetPathFromReference",
    "slug": "TsFunction",
    "id": "dyeibghgtgycozxvuclrqlbb",
    "description": "",
    "operationName": "asset-functions-node",
    "rawText": " async (\n  projectRelativeReferencingFilePath: string,\n  referencingFileRelativeAssetPath: string\n): Promise<{\n  isSuccessful: boolean;\n  message: string;\n  absoluteAssetPath?: string;\n}> => {\n  if (\n    !projectRelativeReferencingFilePath ||\n    !referencingFileRelativeAssetPath\n  ) {\n    console.log({\n      projectRelativeReferencingFilePath,\n      referencingFileRelativeAssetPath,\n    });\n    return {\n      isSuccessful: false,\n      message:\n        \"Incorrect parameters for fetching absolute asset from reference\",\n    };\n  }\n  // TODO: STEP 1: ensure the user is authenticated and can access the referencing file\n\n  const projectRoot = getProjectRoot();\n  if (!projectRoot)\n    return {\n      isSuccessful: false,\n      message: \"No project root\",\n    };\n\n  const extension = getExtension(projectRelativeReferencingFilePath);\n  const allowedExtensions = [\"ts\", \"tsx\", \"md\", \"mdx\", \"json\"];\n  if (!allowedExtensions.includes(extension)) {\n    return {\n      isSuccessful: false,\n      message: \"Invalid extension\",\n    };\n  }\n\n  const absoluteReferencingFilePath = path.join(\n    projectRoot,\n    projectRelativeReferencingFilePath\n  );\n\n  const exists = fs.existsSync(absoluteReferencingFilePath);\n\n  if (!exists) {\n    return {\n      isSuccessful: false,\n      message: \"Invalid file\",\n    };\n  }\n\n  const contents = await fs.readFile(absoluteReferencingFilePath, \"utf8\");\n\n  const patternType = extension === \"json\" ? \"json\" : \"markdown\";\n\n  const pattern =\n    patternType === \"json\"\n      ? `\"relativePath\": \"${referencingFileRelativeAssetPath}\"`\n      : `](${referencingFileRelativeAssetPath})`;\n\n  const foundPattern = contents.includes(pattern);\n\n  const filename = path.parse(projectRelativeReferencingFilePath).name;\n\n  /**\n   * If the name of the file is extending the name of the referencing file, it doesn't need to be referenced, as it can be assumed it's an indexation file.\n   */\n  const isIndexationFile = referencingFileRelativeAssetPath.startsWith(\n    `./${filename}`\n  );\n\n  if (!foundPattern && !isIndexationFile) {\n    // console.log({ contents, pattern });\n    return {\n      isSuccessful: false,\n      message: \"Pattern not found\",\n    };\n  }\n\n  const referencingFileFolderPath = path.parse(absoluteReferencingFilePath).dir;\n\n  const absoluteAssetPath = path.join(\n    referencingFileFolderPath,\n    referencingFileRelativeAssetPath\n  );\n\n  if (!fs.existsSync(absoluteAssetPath)) {\n    return {\n      isSuccessful: false,\n      message: \"The referenced asset does not exist\",\n    };\n  }\n\n  return { isSuccessful: true, message: \"Found path\", absoluteAssetPath };\n}"
  },
  "findAllProjectMedia": {
    "name": "findAllProjectMedia",
    "slug": "TsFunction",
    "id": "rcqkpxmerundxoqnltkcfcfb",
    "description": "Media:`.png`, `.mp4`, `.mp3`, `.zip`, `.pdf`\n\n- finds all media in all `db` folders. Can be anywhere, so an explore will probably be best.\n- finds all media in every operation in any folder except for `node_modules`, `db`, `src`, `build`, `.[anything]`. (so mostly in `todo`, `docs` and `assets`)\n- find all media in every other folder that is not an operation\n\nReturn all of this as project relative path array",
    "operationName": "asset-functions-node",
    "rawText": " async (\n  searchQuery?: string,\n  /**\n   * defaults to absolute\n   */\n  returnType?: \"projectRelative\" | \"absolute\"\n): Promise<string[]> => {\n  const projectRoot = getProjectRoot();\n\n  if (!projectRoot) return [];\n\n  const dbPath = path.join(projectRoot, databaseFolderName);\n\n  const operationBasePaths = Object.values(operations).map(\n    (projectRelativePath) => path.join(projectRoot, projectRelativePath)\n  );\n\n  const databaseFolderPaths = operationBasePaths\n    .map((absoluteOperationPath) =>\n      path.join(absoluteOperationPath, databaseFolderName)\n    )\n    .concat(dbPath)\n    .filter(fs.existsSync);\n\n  const dbResults = await explore({\n    basePath: databaseFolderPaths,\n    extension: mediaExtensions,\n    search: searchQuery,\n  });\n\n  const operationResults = await explore({\n    basePath: operationBasePaths,\n    extension: mediaExtensions,\n    ignore: [...generatedFolders, databaseFolderName, sourceFolderName],\n    search: searchQuery,\n  });\n\n  const anywhereResults = await explore({\n    cancelRecursionOn: pathArrayIsOperation,\n    basePath: projectRoot,\n    extension: mediaExtensions,\n    ignore: [databaseFolderName, \"node_modules\", \".git\"],\n  });\n\n  const results = [dbResults, operationResults, anywhereResults]\n    .flat()\n    .map((x) => x.path);\n\n  return returnType === \"projectRelative\"\n    ? results.map((x) => makeRelative(x, projectRoot))\n    : results;\n}"
  },
  "getAssetDirectlyGetApi": {
    "name": "getAssetDirectlyGetApi",
    "slug": "TsFunction",
    "id": "uigtvknkiszlasdndttpxpni",
    "description": "Useful for getting assets directly, for example for the `SelectMedia` component for `project`-media\n\nRequires more access rights",
    "operationName": "asset-functions-node",
    "rawText": " (\n  serverContext: Context\n): { isSuccessful: boolean; message: string } | void => {\n  /**\n  \n  const authToken = (ctx as any).cookies?.authToken;\n  const authToken2 = ctx.cookie?.authToken;\n\n  console.log({\n    authToken,\n    authToken2,\n    cookie: ctx.cookie,\n    cookies: (ctx as any).cookies,\n    headers: ctx.req.headers,\n  });\n  const isAuthed = functionAuthPlugin(\"uploadAsset\", authToken);\n  if (!isAuthed) {\n    return {\n      isSuccessful: false,\n      isUnauthorized: true,\n      message: \"You can only do this when authenticated\",\n    };\n  }\n  */\n  const isDownload = takeFirst(serverContext?.query.isDownload) === \"1\";\n\n  const projectRelativeAssetPath = takeFirst(\n    serverContext?.query.projectRelativeAssetPath\n  );\n\n  // Quick hack to keep it secure, only allow public stuff\n  if (!projectRelativeAssetPath.startsWith(\"public/\"))\n    return {\n      isSuccessful: false,\n      message: \"not allowed for now, only public data\",\n    };\n\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return {\n      isSuccessful: false,\n      message: \"No project root\",\n    };\n  }\n\n  if (!projectRelativeAssetPath) {\n    console.log({ p: serverContext?.query });\n    return {\n      isSuccessful: false,\n      message: \"No path given\",\n    };\n  }\n\n  const absoluteAssetPath = path.join(projectRoot, projectRelativeAssetPath);\n\n  const exists = fs.existsSync(absoluteAssetPath);\n\n  if (!exists) {\n    return {\n      isSuccessful: false,\n      message: \"Invalid file\",\n    };\n  }\n\n  return serverDownloadReply(absoluteAssetPath, isDownload);\n}"
  },
  "getReferencedAssetGetApi": {
    "name": "getReferencedAssetGetApi",
    "slug": "TsFunction",
    "id": "umljbkkbszffndzrhbepyawl",
    "description": "Function to get a referenced asset that has been referenced from any db-model or any ts, tsx or md file, anywhere in the project.\n\nAssets should only be exposed if you have access to the model they are referenced in or to the md file they are referenced in.\n\nExposes all assets like `/asset?path=/text/interests/programming/storage-of-data/best-storage-methods.md&asset=./audio-is-amazing.m4a`\n\n\n# Security\n\nAssets are only exposed if they are referenced in a markdown file that is accessible to the user. So when looking up the asset, make sure there's a link to it via `[]()` or `![]()` in the markdown that is connected to it in the URL. If not, don't expose it!\n\nThis can be used for any ui that has the functions backend available.\n\nThe advantage is that we don't need to build it, this works in `dev` mode. there is no asset duplication.\n\nsince the name is `getReferencedAssetGetApi` this should be exposed on `getReferencedAsset`\n\nIMPLEMENTATION NOW:\n\n- check referencing file to find the reference.\n- for markdown, typescript: `](./xyz)`\n- for json: `\"relativePath\": \"./xyz\"`\n\n- If this occurs, calculate abosolute asset path from referencing file folder + relative path\n\n- If this asset exists, expose it.",
    "operationName": "asset-functions-node",
    "rawText": " async (\n  serverContext: Context\n): Promise<{\n  isSuccessful: boolean;\n  isUnauthorized?: boolean;\n  message: string;\n}> => {\n  if (!serverContext) {\n    return { isSuccessful: false, message: \"No server context provided\" };\n  }\n  /**\n  const authToken = (ctx as any).cookies?.authToken;\n  const authToken2 = ctx.cookie?.authToken;\n\n  console.log({\n    authToken,\n    authToken2,\n    cookie: ctx.cookie,\n    cookies: (ctx as any).cookies,\n    headers: ctx.req.headers,\n  });\n\n  const isAuthed = functionAuthPlugin(\"uploadAsset\", authToken);\n  if (!isAuthed) {\n    return {\n      isSuccessful: false,\n      isUnauthorized: true,\n      message: \"You can only do this when authenticated\",\n    };\n  }\n  */\n  const isDownload = takeFirst(serverContext.query.isDownload) === \"1\";\n\n  const projectRelativeReferencingFilePath = takeFirst(\n    serverContext.query.projectRelativeReferencingFilePath\n  );\n\n  const referencingFileRelativeAssetPath = takeFirst(\n    serverContext?.query.referencingFileRelativeAssetPath\n  );\n\n  const { absoluteAssetPath, message, isSuccessful } =\n    await findAbsoluteAssetPathFromReference(\n      projectRelativeReferencingFilePath,\n      referencingFileRelativeAssetPath\n    );\n\n  if (!absoluteAssetPath) {\n    return { isSuccessful, message };\n  }\n\n  return serverDownloadReply(absoluteAssetPath, isDownload);\n}"
  },
  "getStorageLocationInfo": {
    "name": "getStorageLocationInfo",
    "slug": "TsFunction",
    "id": "xsdslfzjodwkiuwzipcxmiye",
    "description": "returns the  type of file the asset is referenced from, and the `baseFolderPath` where the `asset` should be stored",
    "operationName": "asset-functions-node",
    "rawText": " (\n  absoluteReferencingFilePath: string,\n  modelName?: string\n): {\n  type: \"typescript\" | \"database\" | \"markdown\";\n  absoluteAssetBaseFolderPath: string;\n} => {\n  if (absoluteReferencingFilePath.includes(`/${sourceFolderName}/`)) {\n    /**\n     *In typescript, the asset can be stored in the `/assets` folder of the operation. The alt is in the markdown.\n     */\n    const operationBasePath = findOperationBasePath(\n      absoluteReferencingFilePath\n    );\n    if (operationBasePath) {\n      const assetsPath = path.join(operationBasePath, \"assets\");\n\n      return { type: \"typescript\", absoluteAssetBaseFolderPath: assetsPath };\n    }\n  }\n  if (\n    modelName &&\n    absoluteReferencingFilePath.includes(`/${databaseFolderName}/`)\n  ) {\n    const databaseFolderBasePath = absoluteReferencingFilePath\n      .split(`/${databaseFolderName}/`)[0]\n      .concat(`/${databaseFolderName}`);\n\n    const databaseFolderRelativeReferenceLocationPath = makeRelative(\n      absoluteReferencingFilePath,\n      databaseFolderBasePath\n    );\n    const isStoredInFolder =\n      databaseFolderRelativeReferenceLocationPath.split(\"/\").length > 1;\n\n    const absoluteAssetBaseFolderPath = isStoredInFolder\n      ? path.parse(absoluteReferencingFilePath).dir\n      : path.join(databaseFolderBasePath, `${kebabCase(modelName)}-assets`);\n\n    /**\n     * In database models, the asset can be stored in\n     *\n     * - in `[modelName]-assets` folder inside of `db` if the data is stored in the root of the db\n     * - in the same folder as the data itself if the data is stored in folders and more separated files\n     */\n    return { type: \"database\", absoluteAssetBaseFolderPath };\n  }\n\n  /**\n   * In markdown, the asset can be stored in the same folder as the markdown file. The alt is in the markdown. The filename can be something else, should be kept original unless changed\n   */\n  return {\n    type: \"markdown\",\n    absoluteAssetBaseFolderPath: path.parse(absoluteReferencingFilePath).dir,\n  };\n}"
  },
  "getTemporaryAssetsFolderPath": {
    "name": "getTemporaryAssetsFolderPath",
    "slug": "TsFunction",
    "id": "wiazefhslubabheouyuyblta",
    "description": "",
    "operationName": "asset-functions-node",
    "rawText": " () => {\n  return path.join(__dirname, \"..\", \"assets\");\n}"
  },
  "mediaExtensions": {
    "name": "mediaExtensions",
    "slug": "TsVariable",
    "id": "zmatvsfhjtxgzkmkbwmqygaa",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "processAsset": {
    "name": "processAsset",
    "slug": "TsFunction",
    "id": "cxnuaovseanuptamfbloszxj",
    "description": "Processes an asset by moving the file in the right location, if needed...\n\n- Alt is kept, nothing to do with it\n- Giving a different name will change the new path\n- relativePath is checked if it exists (if temporaryDestination is undefined). It is used to obtain the extension.\n- temporaryDestination must be checked. if it exists, must replace the file on relativePath calculated from name\n\nAfter processing, this function should return a `BackendAsset` without the non-storable parameters\n\nBEWARE: `absoluteReferencingFilePath`, and for db-models also `modelName`, need to be given here! Otherwise this won't work!",
    "operationName": "asset-functions-node",
    "rawText": " async (\n  /**\n   * The backendAsset that may need processing\n   */\n  backendAsset?: BackendAsset | BackendAsset[]\n): Promise<undefined | BackendAsset> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    console.log(\"processAsset: No project root\");\n    return;\n  }\n  const realBackendASset = backendAsset ? takeFirst(backendAsset) : undefined;\n\n  if (!realBackendASset) {\n    console.log(\"processAsset: No real backend asset\");\n\n    return;\n  }\n\n  const {\n    alt,\n    name,\n    relativePath,\n    temporaryDestination,\n    projectRelativeReferencingFilePath,\n    modelName,\n  } = realBackendASset;\n\n  if (!projectRelativeReferencingFilePath) {\n    log(\n      `processAsset: projectRelativeReferencingFilePath wasn't provided, not processing asset`,\n      { type: \"warning\" }\n    );\n    return undefined;\n  }\n\n  const absoluteReferencingFilePath = path.join(\n    projectRoot,\n    projectRelativeReferencingFilePath\n  );\n\n  // console.log(\"processing asset\", { backendAsset });\n  const slugifiedName = slugify(name && name.length > 0 ? name : \"untitled\");\n\n  if (!relativePath && !temporaryDestination) {\n    log(\"processAsset: no relativePath, no temporaryDestination\", {\n      type: \"warning\",\n    });\n    // NB: we must have either a relativePath or a temporaryDestination, otherwise this is an invalid input\n    return undefined;\n  }\n\n  const absoluteTemporaryDestination = temporaryDestination\n    ? path.join(getTemporaryAssetsFolderPath(), temporaryDestination)\n    : undefined;\n\n  // NB: If a `temporaryDestination` is given, if it doesn't exist, we return nothing, this is an invalid input.\n  if (absoluteTemporaryDestination) {\n    if (!fs.existsSync(absoluteTemporaryDestination)) {\n      log(\"processAsset: absoluteTemporaryDestination does not exist\", {\n        type: \"warning\",\n      });\n\n      return undefined;\n    }\n  }\n\n  const oldAssetStoragePath = relativePath\n    ? path.join(path.parse(absoluteReferencingFilePath).dir, relativePath)\n    : undefined;\n\n  // NB: if a relativePath is provided without a temporaryDestination, it means the file should already be there. If it's not there, we return nothing, invalid input.\n  if (oldAssetStoragePath && !temporaryDestination) {\n    if (!fs.existsSync(oldAssetStoragePath)) {\n      log(\n        `processAsset: oldAssetStoragePath does not exist (${oldAssetStoragePath})`,\n        {\n          type: \"warning\",\n        }\n      );\n\n      return undefined;\n    }\n  }\n\n  // Now we can assume the extension of the temporarydestination is correct, because it gets put there from upload\n  const extension = temporaryDestination\n    ? temporaryDestination.split(\".\").pop()\n    : relativePath?.split(\".\").pop();\n\n  if (!extension) {\n    log(\"processAsset: could not create extension\", { type: \"warning\" });\n\n    // NB: extension must exist now.\n    return undefined;\n  }\n\n  /*\n   */\n\n  const storageLocationInfo = getStorageLocationInfo(\n    absoluteReferencingFilePath,\n    modelName\n  );\n\n  const finalAssetStoragePath = path.join(\n    storageLocationInfo.absoluteAssetBaseFolderPath,\n    `${slugifiedName}.${extension}`\n  );\n\n  let finalAvailableStoragePath: string = finalAssetStoragePath;\n\n  if (absoluteTemporaryDestination) {\n    finalAvailableStoragePath = getFirstAvailableFilename(\n      finalAssetStoragePath\n    );\n\n    await renameAndCreate(\n      absoluteTemporaryDestination,\n      finalAvailableStoragePath\n    );\n  } else if (oldAssetStoragePath) {\n    if (oldAssetStoragePath !== finalAssetStoragePath) {\n      finalAvailableStoragePath = getFirstAvailableFilename(\n        finalAssetStoragePath\n      );\n\n      // the name has changed\n      await renameAndCreate(oldAssetStoragePath, finalAvailableStoragePath);\n    }\n  }\n\n  const newRelativePath = getRelativeLinkPath(\n    absoluteReferencingFilePath,\n    finalAvailableStoragePath\n  );\n\n  //({ newRelativePath });\n\n  console.log({ alt, relativePath });\n  return { alt, relativePath: newRelativePath };\n}"
  },
  "processItemAssets": {
    "name": "processItemAssets",
    "slug": "TsFunction",
    "id": "wazrksgzlgtggcwfrlgmgrpg",
    "description": "processes all assets in an item and returns the new item",
    "operationName": "asset-functions-node",
    "rawText": " async <KInterfaceName extends keyof DbModels>(\n  item: AugmentedAnyModelType,\n  interfaceName: KInterfaceName,\n  operationName: string | null,\n  customQueryConfig: CustomQueryConfig\n): Promise<AugmentedAnyModelType | undefined> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n  const absoluteReferencingFilePath = await db.getDbFileLocationPath(\n    item,\n    operationName,\n    interfaceName,\n    customQueryConfig\n  );\n  if (!absoluteReferencingFilePath) return item;\n\n  const projectRelativeReferencingFilePath = makeRelative(\n    absoluteReferencingFilePath,\n    projectRoot\n  );\n\n  const assetParameters = findAssetParametersRecursively(item);\n\n  const assetsToPutOnObject = await Promise.all(\n    assetParameters.map(async (assetParameter) => {\n      const location = [\n        ...(assetParameter.stack || []),\n        assetParameter.parameterName,\n      ];\n\n      const value = getParameterAtLocation<\n        BackendAsset | BackendAsset[] | undefined\n      >(item, location);\n\n      const backendAssetToStore = Array.isArray(value)\n        ? (\n            await Promise.all(\n              value.map((asset) =>\n                processAsset({\n                  ...asset,\n                  projectRelativeReferencingFilePath,\n                  modelName: interfaceName,\n                })\n              )\n            )\n          ).filter(notEmpty)\n        : value\n        ? await processAsset({\n            ...value,\n            projectRelativeReferencingFilePath,\n            modelName: interfaceName,\n          })\n        : undefined;\n\n      return { backendAssetToStore, location };\n    })\n  );\n\n  assetsToPutOnObject.forEach((assetWithLocation) => {\n    setKeyAtLocation(\n      assetWithLocation.location.join(\".\"),\n      assetWithLocation.backendAssetToStore,\n      item\n    );\n  });\n\n  // console.dir(\n  //   { assetParameters, assetsToPutOnObject, finalItem: item },\n  //   { depth: 999 }\n  // );\n\n  return item;\n}"
  },
  "removeOldTemporaryAssets": {
    "name": "removeOldTemporaryAssets",
    "slug": "TsFunction",
    "id": "eljyrwxznegkoupagvuzbuzw",
    "description": "---\nrunEveryPeriod: midnight\n---\n\n\nAll temporary assets that were created more than 24 hours ago and are still there, will be removed by this function.\n\nThis allows us to easily delete assets without concequences and also if the user closes a form without submitting it, these assets uploaded will go away.\n\nThis function should be executed using a daily CRON",
    "operationName": "asset-functions-node",
    "rawText": " async (): Promise<{\n  removedAmount: number;\n}> => {\n  const temporaryAssetsFolderPath = getTemporaryAssetsFolderPath();\n  const contents = await fs.readdir(temporaryAssetsFolderPath, {\n    encoding: \"utf8\",\n  });\n\n  let removedAmount = 0;\n  await Promise.all(\n    contents.map(async (fileOrFolderName) => {\n      const absolutePath = path.join(\n        temporaryAssetsFolderPath,\n        fileOrFolderName\n      );\n\n      const statistics = await fs.stat(absolutePath);\n\n      if (Date.now() - statistics.ctimeMs > 86400 * 1000) {\n        removedAmount++;\n        // more than a day old\n        await fs.rm(absolutePath, { recursive: true });\n      }\n    })\n  );\n\n  return { removedAmount };\n}"
  },
  "serverDownloadReply": {
    "name": "serverDownloadReply",
    "slug": "TsFunction",
    "id": "wdbmlbnwoszqnxeblispkrnw",
    "description": "Returns a `server.reply.download` or `server.reply.file` but also sets the `Content-Disposition` header correctly and the `Content-Type`\n\n\n\nFor this I finally ended up using builtin server.js stuff, we don't need to set those manually...\n\nSee https://serverjs.io/documentation/reply/#file-\nAnd https://serverjs.io/documentation/reply/#download-\n\nSee https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition\n\nNB: ensure to return the result of this function in your endpoint, otherwise it won't work",
    "operationName": "asset-functions-node",
    "rawText": " (\n  absoluteAssetPath: string,\n  isDownload: boolean\n) => {\n  const parsedAsset = path.parse(absoluteAssetPath);\n\n  if (isDownload) {\n    return server.reply.download(absoluteAssetPath, parsedAsset.base);\n  }\n  return (\n    server.reply\n      // @ts-ignore NB: TODO: why doesn't server.js has the right types???\n      .file(absoluteAssetPath)\n  );\n}"
  },
  "uploadAssetWithContext": {
    "name": "uploadAssetWithContext",
    "slug": "TsFunction",
    "id": "cedapqimhpwakaelogsekbmu",
    "description": "Uploads an asset to the server, and puts it in a temporary location in the assets folder of `function-server`. It returns the filename of the file in the temporary location.\n\nIt can only be accessed through that random name. This random name has 32 characters so cannot be easily guessed. This should be secure enough. The file should be moved to the final destination in the actual function that needs the file.\n\nNB: this function only works by providing a file as blobs under the \"file\" property name!",
    "operationName": "asset-functions-node",
    "rawText": " async (\n  functionContext: FunctionContext\n): Promise<UploadAssetResult> => {\n  const file = functionContext.serverContext?.files.file;\n  if (!file) {\n    console.log(\"Got no file, fuktup\");\n    return { isSuccessful: false, message: \"No file found\" };\n  }\n\n  const realFile = (Array.isArray(file)\n    ? file[0]\n    : file) as unknown as ReceivedFile;\n\n  const functionFile = {\n    size: realFile.size,\n    path: realFile.path,\n    name: realFile.name,\n    type: realFile.type,\n  };\n\n  const randomName = generateRandomString(32);\n  const temporaryAssetsFolderPath = getTemporaryAssetsFolderPath();\n  const conversionInfo = getConversionInfoFromType(realFile.type);\n\n  console.log({ conversionInfo });\n\n  const temporaryFileName = `${randomName}.${conversionInfo.targetFormat}`;\n  const absoluteTemporaryDestinationPath = path.join(\n    temporaryAssetsFolderPath,\n    temporaryFileName\n  );\n\n  if (!fs.existsSync(temporaryAssetsFolderPath)) {\n    await fs.mkdir(temporaryAssetsFolderPath, { recursive: true });\n  }\n\n  if (conversionInfo.targetFormat === \"mp3\") {\n    // Conversion needed!\n    const resultingPath = await convertToMp3(\n      functionFile.path,\n      absoluteTemporaryDestinationPath\n    );\n  } else if (conversionInfo.targetFormat === \"mp4\") {\n    // in many cases, conversion needed\n    const resultingPath = await convertToMp4(\n      functionFile.path,\n      absoluteTemporaryDestinationPath\n    );\n  } else {\n    await fs.rename(functionFile.path, absoluteTemporaryDestinationPath);\n  }\n\n  return {\n    isSuccessful: true,\n    message: \"File received\",\n    temporaryDestination: temporaryFileName,\n  };\n}"
  },
  "ASPECT_RATIO": {
    "name": "ASPECT_RATIO",
    "slug": "TsVariable",
    "id": "oekxstdkophtxxbtlmiwhuwd",
    "description": "",
    "operationName": "asset-input"
  },
  "Audio": {
    "name": "Audio",
    "slug": "TsFunction",
    "id": "zxwkonbcfdhgfcoalcutxaam",
    "description": "",
    "operationName": "asset-input",
    "rawText": " (\n  props: React.DetailedHTMLProps<\n    React.AudioHTMLAttributes<HTMLAudioElement>,\n    HTMLAudioElement\n  >\n) => <audio {...props} />"
  },
  "base64UrltoBlob": {
    "name": "base64UrltoBlob",
    "slug": "TsFunction",
    "id": "nmxqmfixbbhgxvtrwmqgfcif",
    "description": "Taken from https://github.com/mozmorris/react-webcam/issues/65#issuecomment-385126201\n\nThere are probably much better solutions",
    "operationName": "asset-input",
    "rawText": " (dataurl: string | null) => {\n  if (!dataurl) return;\n  const arr = dataurl.split(\",\");\n  const mime = arr[0].match(/:(.*?);/)?.[1];\n  const bstr = atob(arr[1]);\n\n  let n = bstr.length;\n  const u8arr = new Uint8Array(n);\n\n  while (n--) {\n    u8arr[n] = bstr.charCodeAt(n);\n  }\n\n  return new Blob([u8arr], { type: mime });\n}"
  },
  "FileInput": {
    "name": "FileInput",
    "slug": "TsFunction",
    "id": "xslpjweftkqoxhihdfutgnkc",
    "description": "import Icon from \"./icon.svg\";",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  extra,\n  onChange,\n}) => {\n  const { getRootProps, getInputProps, acceptedFiles } = useDropzone({});\n\n  useEffect(() => {\n    onChange(acceptedFiles);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [acceptedFiles]);\n\n  const files = acceptedFiles.map((file: FileWithPath) => (\n    <Li key={file.path} className=\"text-sm\">\n      {file.path}\n    </Li>\n  ));\n\n  return (\n    <Div\n      className=\"flex justify-center px-6 pt-5 pb-6 mt-1 border-2 border-gray-300 border-dashed rounded-md\"\n      {...getRootProps()}\n    >\n      <Div className=\"space-y-1 text-center\">\n        {/* <Icon /> */}\n        <Div className=\"flex text-sm text-center text-gray-600\">\n          <Label\n            htmlFor=\"file-upload\"\n            className=\"relative font-medium text-indigo-600 bg-white rounded-md cursor-pointer hover:text-indigo-500 focus-within:outline-none focus-within:ring-2 focus-within:ring-offset-2 focus-within:ring-indigo-500\"\n          />\n          <Input id=\"file-upload\" type=\"file\" {...getInputProps()} />\n        </Div>\n        <P className=\"text-xs text-gray-500\">PNG, JPG, GIF en PDF tot 15MB</P>\n        {acceptedFiles.length > 0 ? (\n          <Aside>\n            <Ul>{files}</Ul>\n          </Aside>\n        ) : null}\n      </Div>\n    </Div>\n  );\n}"
  },
  "getTypeFromFileBlob": {
    "name": "getTypeFromFileBlob",
    "slug": "TsFunction",
    "id": "bkatitucdfcnvswiqdanonps",
    "description": "",
    "operationName": "asset-input",
    "rawText": " (file: File) => {\n  const typeFirstPart = file.type.split(\"/\")[0];\n\n  const firstPartAssetTypes = [\"image\", \"video\", \"audio\"];\n\n  const type: AssetType = firstPartAssetTypes.includes(typeFirstPart)\n    ? (typeFirstPart as AssetType)\n    : \"other\";\n\n  return type;\n}"
  },
  "HEIGHT": {
    "name": "HEIGHT",
    "slug": "TsVariable",
    "id": "rnlobnyrrzkellfmbgpbxdgl",
    "description": "",
    "operationName": "asset-input"
  },
  "makeBackendAsset": {
    "name": "makeBackendAsset",
    "slug": "TsFunction",
    "id": "kaxqwlmhewleqyshngzwfjfp",
    "description": "",
    "operationName": "asset-input",
    "rawText": " (\n  asset: Asset,\n  projectRelativeReferencingFilePath: string,\n  modelName?: string\n): BackendAsset => {\n  return {\n    alt: asset.alt,\n    name: asset.name,\n    relativePath: asset.relativePath,\n    temporaryDestination: asset.temporaryDestination,\n    projectRelativeReferencingFilePath,\n    modelName,\n  };\n}"
  },
  "MediaRecorderComponent": {
    "name": "MediaRecorderComponent",
    "slug": "TsFunction",
    "id": "dzlruyhvqusuyrzenauqcpnl",
    "description": "",
    "operationName": "asset-input",
    "rawText": " (\n  props: ReactMediaRecorderRenderProps & { type: MediaRecorderType }\n) => {\n  const {\n    status,\n    startRecording,\n    stopRecording,\n    pauseRecording,\n    resumeRecording,\n    previewAudioStream,\n    mediaBlobUrl,\n    previewStream,\n    type,\n    muteAudio,\n    unMuteAudio,\n    isAudioMuted,\n  } = props;\n\n  const AudioOrVideo = type === \"audio\" ? Audio : Video;\n\n  const buttons =\n    status === \"acquiring_media\"\n      ? []\n      : status === \"recording\"\n      ? [\n          <button key=\"stop\" onClick={stopRecording}>\n            â¹\n          </button>,\n          <button key=\"pause\" onClick={pauseRecording}>\n            â¸\n          </button>,\n          type === \"video\" || type === \"screen\" ? (\n            isAudioMuted ? (\n              <button key=\"unmute\" onClick={unMuteAudio}>\n                ðŸ”ˆ\n              </button>\n            ) : (\n              <button key=\"mute\" onClick={muteAudio}>\n                ðŸ”‡\n              </button>\n            )\n          ) : undefined,\n        ]\n      : status === \"paused\"\n      ? [\n          <button key=\"stop\" onClick={stopRecording}>\n            â¹\n          </button>,\n          <button key=\"pause\" onClick={resumeRecording}>\n            â–¶ï¸\n          </button>,\n        ]\n      : [\n          <button key=\"start\" onClick={startRecording}>\n            âº\n          </button>,\n        ];\n\n  return (\n    <div>\n      {buttons}\n      {mediaBlobUrl && status !== \"recording\" ? (\n        <AudioOrVideo src={mediaBlobUrl} controls autoPlay />\n      ) : null}\n      {type === \"video\" && previewStream && status === \"recording\" ? (\n        <VideoPreview stream={previewStream} />\n      ) : null}\n      {type === \"audio\" && previewAudioStream && status === \"recording\"\n        ? // TODO: visualise with https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Visualizations_with_Web_Audio_API\n          null\n        : null}\n    </div>\n  );\n}"
  },
  "MediaRecorder": {
    "name": "MediaRecorder",
    "slug": "TsFunction",
    "id": "iqqtdgvnogwppwgeulurxtbp",
    "description": "",
    "operationName": "asset-input",
    "rawText": " (props: {\n  type: MediaRecorderType;\n  withBlob: (blobUrl: string, blob: Blob) => void;\n}) => {\n  const { type, withBlob } = props;\n\n  return (\n    <div>\n      <ReactMediaRecorder\n        screen={type === \"screen\"}\n        audio\n        blobPropertyBag={{ type: type === \"audio\" ? \"audio/wav\" : \"video/mp4\" }}\n        // audio={type === \"audio\"}\n        video={type === \"video\"}\n        stopStreamsOnStop\n        onStop={(blobUrl, blob) => {\n          withBlob(blobUrl, blob);\n        }}\n        render={(props) => <MediaRecorderComponent {...props} type={type} />}\n      />\n    </div>\n  );\n}"
  },
  "ReactMediaRecorder": {
    "name": "ReactMediaRecorder",
    "slug": "TsFunction",
    "id": "kknfkaqwtpggkpacrgfyiehs",
    "description": "",
    "operationName": "asset-input",
    "rawText": " (props: ReactMediaRecorderProps) =>\n  props.render(useReactMediaRecorder(props))"
  },
  "SelectMedia": {
    "name": "SelectMedia",
    "slug": "TsFunction",
    "id": "rnyqldcfdulzsyqzmvlvyfsb",
    "description": "",
    "operationName": "asset-input",
    "rawText": " (props: {\n  /**\n   * NB: please don't change the source after initialisation!\n   */\n  source: MediaSourceEnum;\n}) => {\n  // make an api for all different sources\n  const { source } = props;\n\n  // get the right media from api\n\n  // show the results using\n  return <Div>A picker for media from {props.source} should come here</Div>;\n}"
  },
  "videoConstraints": {
    "name": "videoConstraints",
    "slug": "TsVariable",
    "id": "ggydaeatofhfqzljhhswfwvs",
    "description": "",
    "operationName": "asset-input"
  },
  "VideoPreview": {
    "name": "VideoPreview",
    "slug": "TsFunction",
    "id": "lnozphpnkddfzqhkkmxicooe",
    "description": "",
    "operationName": "asset-input",
    "rawText": " ({ stream }: { stream: MediaStream | null }) => {\n  const videoRef = useRef<HTMLVideoElement>(null);\n\n  useEffect(() => {\n    if (videoRef.current && stream) {\n      videoRef.current.srcObject = stream;\n    }\n  }, [stream]);\n  if (!stream) {\n    return null;\n  }\n  return <video ref={videoRef} width={500} height={500} autoPlay controls />;\n}"
  },
  "Video": {
    "name": "Video",
    "slug": "TsFunction",
    "id": "prwuwmrondcozmqdbscxxaen",
    "description": "",
    "operationName": "asset-input",
    "rawText": " (\n  props: React.DetailedHTMLProps<\n    React.AudioHTMLAttributes<HTMLVideoElement>,\n    HTMLVideoElement\n  >\n) => <video {...props} />"
  },
  "WebcamCapture": {
    "name": "WebcamCapture",
    "slug": "TsFunction",
    "id": "jgxmpdkkmtxeajshxrzxznlx",
    "description": "",
    "operationName": "asset-input",
    "rawText": " (props: {\n  withBlob: (blobUrl: string, blob: Blob) => void;\n}) => {\n  const [snapshot, setSnapshot] = useState<string | null>(null);\n  const { withBlob } = props;\n  return (\n    <Webcam\n      audio={false}\n      height={HEIGHT}\n      width={WIDTH}\n      screenshotFormat=\"image/jpeg\"\n      videoConstraints={videoConstraints}\n      className=\"w-full h-full flex\"\n    >\n      {({ getScreenshot }) => {\n        return (\n          <Div className=\"relative\">\n            {snapshot ? (\n              <Image\n                src={snapshot}\n                className=\"absolute bottom-6 left-10 w-1/5 aspect-auto\"\n              />\n            ) : null}\n\n            <Button\n              className=\"hover:bg-gray-200 absolute bottom-6 left-1/2 p-4 border border-black bg-white rounded-full\"\n              onClick={() => {\n                const base64Url = getScreenshot();\n                const blob = base64UrltoBlob(base64Url);\n                const blobUrl = blob ? URL.createObjectURL(blob) : undefined;\n                setSnapshot(base64Url);\n                if (!blob || !blobUrl) return;\n\n                withBlob(blobUrl, blob);\n              }}\n            >\n              ðŸ“¸\n            </Button>\n          </Div>\n        );\n      }}\n    </Webcam>\n  );\n}"
  },
  "WIDTH": {
    "name": "WIDTH",
    "slug": "TsVariable",
    "id": "ytuprnditeoatsaqhxohwtlk",
    "description": "",
    "operationName": "asset-input"
  },
  "AssetView": {
    "name": "AssetView",
    "slug": "TsFunction",
    "id": "pvhezkfjxhxlibuyrvtvzmxh",
    "description": "",
    "operationName": "asset-view",
    "rawText": " (props: {\n  asset: Asset;\n  className?: string;\n  /**\n   * Must be provided for relative assets to know the location\n   */\n  projectRelativeReferencingFilePath?: string;\n  hideDownloadLink?: boolean;\n}) => {\n  const {\n    asset,\n    className,\n    projectRelativeReferencingFilePath,\n    hideDownloadLink,\n  } = props;\n\n  const result = useAsset(asset, projectRelativeReferencingFilePath, !isDev);\n  const { downloadUrl, rawText, src, type, extension } =\n    destructureOptionalObject(result);\n\n  // console.log({ src });\n\n  const sizeText =\n    asset.sizeBytes !== undefined\n      ? `(${readableSize(asset.sizeBytes)})`\n      : undefined;\n\n  const downloadText = \" â¬‡ï¸ Download\";\n\n  return (\n    <Span style={{ position: \"relative\" }}>\n      {downloadUrl && !hideDownloadLink ? (\n        <Div\n          style={{\n            padding: \"5px\",\n          }}\n        >\n          <A target=\"_blank\" href={downloadUrl}>\n            {downloadText} {sizeText}\n          </A>\n        </Div>\n      ) : null}\n\n      {type === \"image\" && src && (\n        <img\n          src={src}\n          className={className || \"w-40\"}\n          style={{ aspectRatio: \"auto\" }}\n        />\n      )}\n      {type === \"audio\" && src && <audio controls src={src} />}\n      {type === \"video\" && src && (\n        <video\n          style={{ aspectRatio: \"auto\" }}\n          className={className || \"w-40\"}\n          preload=\"none\"\n          // not always available, should I check first somehow?\n          poster={src.replace(\".mp4\", \".placeholder.jpeg\")}\n          controls\n          src={src}\n        />\n      )}\n\n      {type === \"text\" && rawText ? (\n        <MarkdownCodeblock text={rawText} extension={extension} />\n      ) : null}\n\n      {/* LATER: render PDF renderer here */}\n      {type === \"other\" && extension === \"pdf\" ? null : null}\n\n      {src === undefined ? <P>Asset src not found</P> : null}\n    </Span>\n  );\n}"
  },
  "defaultClassName": {
    "name": "defaultClassName",
    "slug": "TsVariable",
    "id": "forzaysldolxfezbhohsaqri",
    "description": "",
    "operationName": "asset-view"
  },
  "getSrc": {
    "name": "getSrc",
    "slug": "TsFunction",
    "id": "ronnamkmpoovmdmywfflfcmo",
    "description": "",
    "operationName": "asset-view",
    "rawText": " (\n  asset: Asset,\n  projectRelativeReferencingFilePath: string,\n  isNextStaticProductionBuild?: boolean\n) => {\n  // console.log({ apiUrl });\n  /**\n   * NB: `relativePath` is required\n   */\n  const getRemoteUrl = (isDownload: boolean) =>\n    getReferencedAssetApiUrl(\n      apiUrl,\n      projectRelativeReferencingFilePath,\n      asset.relativePath!,\n      isDownload\n    );\n\n  const getPublicUrl = (relativePath: string) =>\n    `markdown-assets/${path.join(\n      path.parse(projectRelativeReferencingFilePath).dir,\n      relativePath\n    )}`;\n  /**\n   * NB: `asset.temporaryDestination` is not a URL that can be used to retreive the image as \"src\"\n   */\n  const src = asset.absoluteUrl\n    ? asset.absoluteUrl\n    : asset.blobPath\n    ? asset.blobPath\n    : isNextStaticProductionBuild && asset.relativePath\n    ? getPublicUrl(asset.relativePath)\n    : getRemoteUrl(false);\n\n  // console.log(\"UseAssetSRC:\", src);\n  const downloadRemotely = !asset.blobPath && !!asset.relativePath;\n\n  const downloadUrl =\n    isNextStaticProductionBuild && asset.relativePath\n      ? getPublicUrl(asset.relativePath)\n      : downloadRemotely\n      ? getRemoteUrl(true)\n      : // NB: other type is ugly when downloading. Also doesn't make sense much to want to download an asset after uploading\n      asset.type !== \"other\"\n      ? asset.blobPath\n      : undefined;\n\n  return { src, downloadUrl };\n}"
  },
  "InteractiveAsset": {
    "name": "InteractiveAsset",
    "slug": "TsFunction",
    "id": "tfrvwaorstnudtphjcddetsw",
    "description": "shows an `Asset` with interactivity\n\n- Any file shows the name of the file, the size, and a link to open it in a new tab in the browser\n- Images show thumbnail\n- Audio show duration and amplitude\n- Video/screen show thumbnail and duration",
    "operationName": "asset-view",
    "rawText": " (props: {\n  asset: Asset;\n  /**\n   * See `AssetInput` for more info\n   */\n  attachTokenToFilename?: boolean;\n  projectRelativeReferencingFilePath: string;\n  remove: () => void;\n  onChange: (newAsset: Asset) => void;\n}) => {\n  const {\n    asset,\n    remove,\n    projectRelativeReferencingFilePath,\n    onChange,\n    attachTokenToFilename,\n  } = props;\n\n  /**\n   *\n   * Name that includes token\n   */\n  const nameWithToken =\n    asset.name && asset.name.length > 0\n      ? // You've edited the name, and this it's stored on the frontend `Asset`\n        asset.name\n      : asset.relativePath\n      ? // The asset comes from the backend, the name can be deducted from the `relativePath` by removing the token first, then adding it\n        getNameWithTokenFromRelativePath(\n          asset.relativePath,\n          attachTokenToFilename\n        )\n      : // There is no backend name nor there's a name set by the user. NB: this should not really happen as it must be present on Asset after recording/selecting an asset...\n        \"\";\n\n  const { nameWithoutToken, token: previousToken } = removeTokenIfPresent(\n    nameWithToken,\n    attachTokenToFilename\n  );\n\n  const uploadProgressText =\n    asset.uploadProgress === undefined || asset.uploadProgress === 0\n      ? \"\"\n      : asset.uploadProgress === 1\n      ? \"âœ…\"\n      : `${Math.round(asset.uploadProgress * 100)}%`;\n\n  return (\n    <Div className=\"relative border border-black rounded-xl p-2 m-2\">\n      <Span className=\"absolute right-1 top-[-7px]\">\n        <ClickableIcon emoji=\"â¨¯\" onClick={() => remove()} />\n      </Span>\n      <AssetView\n        projectRelativeReferencingFilePath={projectRelativeReferencingFilePath}\n        asset={asset}\n      />\n\n      <Div className=\"flex flex-row\">\n        <Input\n          placeholder=\"Name\"\n          value={nameWithoutToken}\n          style={{ backgroundColor: \"transparent\", border: \"1px solid black\" }}\n          onChange={(e) => {\n            const newName = addToken(\n              e.target.value,\n              previousToken,\n              attachTokenToFilename\n            );\n\n            console.log({ newName });\n\n            const newAsset = { ...asset, name: newName };\n            onChange(newAsset);\n          }}\n        />\n        <Input\n          placeholder=\"Alternate text\"\n          style={{ backgroundColor: \"transparent\", border: \"1px solid black\" }}\n          value={asset.alt || \"\"}\n          onChange={(e) => {\n            const newAsset = { ...asset, alt: e.target.value };\n            onChange(newAsset);\n          }}\n        />\n        {uploadProgressText}\n      </Div>\n    </Div>\n  );\n}"
  },
  "itemGetBackendAssetUrl": {
    "name": "itemGetBackendAssetUrl",
    "slug": "TsFunction",
    "id": "bpnrxdjrlfbfppcrzvurveja",
    "description": "Get remote url for a `BackendAsset` in an `AugmentedAnyModelType` database model item.\n\nIf you provide an array it'll take the first asset.",
    "operationName": "asset-view",
    "rawText": " (config: {\n  item: AugmentedAnyModelType;\n  backendAsset?: BackendAsset | BackendAsset[];\n  isDownload?: boolean;\n}) => {\n  const { backendAsset, item, isDownload } = config;\n\n  const realBackendAsset = backendAsset ? takeFirst(backendAsset) : undefined;\n\n  if (!realBackendAsset?.relativePath) {\n    return undefined;\n  }\n\n  const url = getReferencedAssetApiUrl(\n    apiUrl,\n    item.projectRelativePath,\n    realBackendAsset.relativePath,\n    isDownload\n  );\n  return url;\n}"
  },
  "ModelItemAssetView": {
    "name": "ModelItemAssetView",
    "slug": "TsFunction",
    "id": "lgsoavioqgfbwhduwuwtkdjo",
    "description": "",
    "operationName": "asset-view",
    "rawText": " <T extends AugmentedAnyModelType>(props: {\n  item: T;\n  backendAsset?: BackendAsset;\n  hideDownloadLink?: boolean;\n  className?: string;\n}) => {\n  const { backendAsset, item, hideDownloadLink, className } = props;\n\n  return backendAsset ? (\n    <AssetView\n      asset={backendAsset}\n      projectRelativeReferencingFilePath={item.projectRelativePath}\n      hideDownloadLink={hideDownloadLink}\n      className={className}\n    />\n  ) : null;\n}"
  },
  "useAssetInfo": {
    "name": "useAssetInfo",
    "slug": "TsFunction",
    "id": "idezoxhoprvbjozfvmtkktdt",
    "description": "",
    "operationName": "asset-view",
    "rawText": " (url?: string, filename?: string) => {\n  if (!url && !filename) {\n    console.log(\"MUST PROVIDE EITHER URL OR FILENAME\");\n    return;\n  }\n  const urlOrFilename = (url || filename)!;\n  const realFilename = (url ? url.split(\"/\").pop() : filename)!;\n  const isTextFile = isText(realFilename) === true ? true : false;\n\n  const [rawText, setRawText] = useState<string | null>(null);\n  useEffect(() => {\n    if (!!url && isTextFile) {\n      fetch(url).then((result) => {\n        result.text().then((text) => setRawText(text));\n      });\n    }\n  }, [url, isTextFile]);\n\n  const type = getTypeFromUrlOrPath(urlOrFilename);\n\n  return { rawText, type };\n}"
  },
  "useAsset": {
    "name": "useAsset",
    "slug": "TsFunction",
    "id": "kvtybauwkhuybtnvwoodgtpu",
    "description": "",
    "operationName": "asset-view",
    "rawText": " (\n  asset: Asset | undefined,\n  projectRelativeReferencingFilePath?: string | null,\n  isNextStaticProductionBuild?: boolean\n) => {\n  if (!asset || !projectRelativeReferencingFilePath) return;\n\n  const { src, downloadUrl } = getSrc(\n    asset,\n    projectRelativeReferencingFilePath,\n    isNextStaticProductionBuild\n  );\n\n  const extension = getExtensionFromAsset(asset);\n\n  const assetInfo = useAssetInfo(src, asset.originalFilename);\n\n  const rawText = assetInfo?.rawText || null;\n  const type = asset.type || assetInfo?.type;\n\n  return { rawText, type, downloadUrl, src, extension };\n}"
  },
  "binaryExtensions": {
    "name": "binaryExtensions",
    "slug": "TsVariable",
    "id": "fihpmqlxyycfqoxzpdrtlloh",
    "description": "List of binary file extensions",
    "operationName": "text-or-binary"
  },
  "textExtensions": {
    "name": "textExtensions",
    "slug": "TsVariable",
    "id": "drxzxjzkivjppcidagkfxwtp",
    "description": "List of text file extensions",
    "operationName": "text-or-binary"
  },
  "folderGetUpdatedAt": {
    "name": "folderGetUpdatedAt",
    "slug": "TsFunction",
    "id": "mpvgiurhvjmzqsaermsazbjf",
    "description": "get last updated file updatedAt time in whole folder, recursively",
    "operationName": "folder-get-updated-at",
    "rawText": " async ({\n  folderPath,\n}: {\n  folderPath: string;\n}): Promise<number> => {\n  return (\n    await explore({\n      basePath: folderPath,\n      includeStats: true,\n      extension: [\"ts\", \"tsx\"],\n      ignore: \"index.ts\",\n    })\n  ).reduce((updatedAt, file) => {\n    const fileUpdatedAt = file.stats?.updatedAt;\n    if (!fileUpdatedAt) return updatedAt;\n    if (fileUpdatedAt > updatedAt) return fileUpdatedAt;\n    return updatedAt;\n  }, 0);\n}"
  },
  "access": {
    "name": "access",
    "slug": "TsVariable",
    "id": "iigqtshxkxozywtouftagbbj",
    "description": "",
    "operationName": "fs-util"
  },
  "appendFile": {
    "name": "appendFile",
    "slug": "TsVariable",
    "id": "bcwssbjzifwhhfzeebroedew",
    "description": "",
    "operationName": "fs-util"
  },
  "canAccessSync": {
    "name": "canAccessSync",
    "slug": "TsFunction",
    "id": "ndwnzfmezeiiccpbfhnimtis",
    "description": "uses fs.access to determine if something can be accessed\n\nCheck File access constants for possible values of mode. It is possible to create a mask consisting of the bitwise OR of two or more values (e.g. fs.constants.W_OK | fs.constants.R_OK).",
    "operationName": "fs-util",
    "rawText": " (p: PathLike, mode: number): boolean => {\n  try {\n    fs.accessSync(p, mode);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}"
  },
  "canAccess": {
    "name": "canAccess",
    "slug": "TsFunction",
    "id": "saidbejldheyqkvkeojfvkmj",
    "description": "uses fs.access to determine if something can be accessed\n\nCheck File access constants for possible values of mode. It is possible to create a mask consisting of the bitwise OR of two or more values (e.g. fs.constants.W_OK | fs.constants.R_OK).",
    "operationName": "fs-util",
    "rawText": " async (\n  p: PathLike,\n  mode: number\n): Promise<boolean> => {\n  try {\n    await fs.access(p, mode);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}"
  },
  "canExecuteSync": {
    "name": "canExecuteSync",
    "slug": "TsFunction",
    "id": "gffnjuvrwhrdvvklzuzhcfdp",
    "description": "File is executable to the calling process",
    "operationName": "fs-util",
    "rawText": " (p: PathLike) =>\n  canAccessSync(p, fs.constants.X_OK)"
  },
  "canExecute": {
    "name": "canExecute",
    "slug": "TsFunction",
    "id": "riuthigeurjczmekfslmufog",
    "description": "File is executable to the calling process",
    "operationName": "fs-util",
    "rawText": " async (p: PathLike) =>\n  canAccess(p, fs.constants.X_OK)"
  },
  "canReadSync": {
    "name": "canReadSync",
    "slug": "TsFunction",
    "id": "krgtqrxotgdxvyvncpsmujil",
    "description": "File is readable to the calling process",
    "operationName": "fs-util",
    "rawText": " (p: PathLike) => canAccessSync(p, fs.constants.R_OK)"
  },
  "canRead": {
    "name": "canRead",
    "slug": "TsFunction",
    "id": "iytjuftmhxrzyimhapmxgnbb",
    "description": "File is readable to the calling process",
    "operationName": "fs-util",
    "rawText": " async (p: PathLike) => canAccess(p, fs.constants.R_OK)"
  },
  "canSeeSync": {
    "name": "canSeeSync",
    "slug": "TsFunction",
    "id": "vtkijdzqnvyrefhgutzghozx",
    "description": "File is visible to the calling process",
    "operationName": "fs-util",
    "rawText": " async (p: PathLike) =>\n  canAccessSync(p, fs.constants.F_OK)"
  },
  "canSee": {
    "name": "canSee",
    "slug": "TsFunction",
    "id": "uwqedtldligiyevbmluneyhf",
    "description": "File is visible to the calling process",
    "operationName": "fs-util",
    "rawText": " async (p: PathLike) => canAccess(p, fs.constants.F_OK)"
  },
  "canWriteSync": {
    "name": "canWriteSync",
    "slug": "TsFunction",
    "id": "yfmyvoazqwzeujaqbhucpnez",
    "description": "File is writable to the calling process",
    "operationName": "fs-util",
    "rawText": " (p: PathLike) =>\n  canAccessSync(p, fs.constants.W_OK)"
  },
  "canWrite": {
    "name": "canWrite",
    "slug": "TsFunction",
    "id": "utyckweedbehayapvygjcaer",
    "description": "File is writable to the calling process",
    "operationName": "fs-util",
    "rawText": " async (p: PathLike) => canAccess(p, fs.constants.W_OK)"
  },
  "chmod": {
    "name": "chmod",
    "slug": "TsVariable",
    "id": "rawobwqtegqdcmkswlupgvab",
    "description": "",
    "operationName": "fs-util"
  },
  "chown": {
    "name": "chown",
    "slug": "TsVariable",
    "id": "itemgkbsbexabicbcreapmck",
    "description": "",
    "operationName": "fs-util"
  },
  "copyAllRelativeFiles": {
    "name": "copyAllRelativeFiles",
    "slug": "TsFunction",
    "id": "ivhuqnbtyfjgfzwkhhjnnipm",
    "description": "copy a bunch of relative files from one root folder to another",
    "operationName": "fs-util",
    "rawText": " async (\n  relativeFilePaths: string[],\n  absoluteSourceRoot: string,\n  absoluteDestinationRoot: string,\n  /**\n   * Overwrite existing file or directory\n   */\n  force?: boolean\n) => {\n  const promises = relativeFilePaths.map(async (relativeFilePath) => {\n    const fullSourcePath = path.join(absoluteSourceRoot, relativeFilePath);\n    const fullDestinationPath = path.join(\n      absoluteDestinationRoot,\n      relativeFilePath\n    );\n    if (fs.existsSync(fullSourcePath)) {\n      await fs.cpAsync(fullSourcePath, fullDestinationPath, {\n        recursive: true,\n        force: force || false,\n      });\n    }\n  });\n  await Promise.all(promises);\n\n  return true;\n}"
  },
  "copyFile": {
    "name": "copyFile",
    "slug": "TsVariable",
    "id": "lvjimlwwnvmnwmystitpkbmr",
    "description": "",
    "operationName": "fs-util"
  },
  "cp": {
    "name": "cp",
    "slug": "TsVariable",
    "id": "dwoahfcxcghnzmerggcbejtc",
    "description": "",
    "operationName": "fs-util"
  },
  "findFileNameCaseInsensitive": {
    "name": "findFileNameCaseInsensitive",
    "slug": "TsFunction",
    "id": "tbwsbqqqmimiugwijsunddbq",
    "description": "returns a path of a fileName",
    "operationName": "fs-util",
    "rawText": " async (\n  folderPath: string,\n  /**\n   * fileName with extension\n   */\n  fileName: string\n): Promise<string | undefined> => {\n  if (!fs.existsSync(folderPath)) return;\n\n  const results = await fs.readdir(folderPath);\n\n  const foundPath = results\n    .map((fileName) => {\n      const absolutePath = path.join(folderPath, fileName);\n      return absolutePath;\n    })\n    .find((absolutePath) => {\n      const parsedPath = path.parse(absolutePath);\n      const isMatchCaseInsensitive =\n        parsedPath.base.toLowerCase() === fileName.toLowerCase();\n\n      return isMatchCaseInsensitive;\n    });\n\n  return foundPath;\n}"
  },
  "fsPromises": {
    "name": "fsPromises",
    "slug": "TsVariable",
    "id": "ozifvlnroriitsdjxbofppyj",
    "description": "",
    "operationName": "fs-util"
  },
  "fs": {
    "name": "fs",
    "slug": "TsVariable",
    "id": "pokiuwbgeojdntnyjnvpuxhw",
    "description": "NB: for some reason some of the graceful-fs functions aren't complete. For example, I can't seem to copy folders with cp from graceful-fs (cp)\n\nFor that one I added cpAsync.",
    "operationName": "fs-util"
  },
  "getAllFoldersUntilFolder": {
    "name": "getAllFoldersUntilFolder",
    "slug": "TsFunction",
    "id": "nsuxyakrfqbiteksoarzahpe",
    "description": "NB: I already have this somewhere else but couldn't find it!\n\nIf the path is /a/random/path\n\nThe result of this function will be:\n\n['/a', '/a/random', '/a/random/path']",
    "operationName": "fs-util",
    "rawText": " (folderPath: string): string[] => {\n  const chunks = trimSlashes(folderPath).split(\"/\");\n  // chunks = ['a', 'random', 'path']\n\n  const result = chunks.map((_, index, array) => {\n    return \"/\" + array.slice(0, index + 1).join(\"/\");\n  });\n\n  return result;\n}"
  },
  "getFileName": {
    "name": "getFileName",
    "slug": "TsFunction",
    "id": "skbbtpikseagrirzxkdghuxa",
    "description": "removes everything before the last slash to get file name",
    "operationName": "fs-util",
    "rawText": " (pathString: string) => {\n  return path.basename(pathString);\n}"
  },
  "getFirstAvailableFilename": {
    "name": "getFirstAvailableFilename",
    "slug": "TsFunction",
    "id": "vlrfuotfiaplpaioonrsaxyl",
    "description": "",
    "operationName": "fs-util",
    "rawText": " (absoluteFilePath: string): string => {\n  // If that doesn't exist, use that\n  if (!fs.existsSync(absoluteFilePath)) return absoluteFilePath;\n\n  const parsedPath = path.parse(absoluteFilePath);\n\n  const newFilename = `${oneUp(parsedPath.name)}${parsedPath.ext}`;\n  const newProposedPath = path.join(parsedPath.dir, newFilename);\n  return getFirstAvailableFilename(newProposedPath);\n}"
  },
  "getFolderSizeObject": {
    "name": "getFolderSizeObject",
    "slug": "TsFunction",
    "id": "rtyuhpgctgnloqiigelxekyp",
    "description": "returns an object with all sizes of all folders and files, recursively",
    "operationName": "fs-util",
    "rawText": " async (\n  absoluteFolderPath: string,\n  /**\n   * Folders smaller than this won't provide details\n   */\n  minimumReportSizeMb: number = 0,\n  ignoreGenerated: boolean = true\n): Promise<ChildObject<{ size: number; name: string }>[]> => {\n  const files = await fs.readdir(absoluteFolderPath, { withFileTypes: true });\n\n  const paths = (\n    await Promise.all(\n      files.map(async (file) => {\n        const newPath = path.join(absoluteFolderPath, file.name);\n\n        if (file.isDirectory()) {\n          if (\n            ignoreGenerated &&\n            [...generatedFolders, \"public\"].includes(file.name)\n          )\n            return;\n          const children = await getFolderSizeObject(newPath);\n\n          const size = sum(children.map((x) => x.size));\n          return {\n            name: file.name,\n            size,\n            /**\n             *\n             */\n            children:\n              size > minimumReportSizeMb * 1024 * 1024 ? children : undefined,\n          };\n        }\n\n        if (file.isFile()) {\n          const { size } = await fs.stat(newPath);\n\n          return {\n            size,\n            children: undefined,\n            name: file.name,\n          };\n        }\n\n        return minimumReportSizeMb\n          ? undefined\n          : { size: 0, children: undefined, name: file.name };\n      })\n    )\n  ).filter(notEmpty);\n\n  return paths;\n}"
  },
  "getFolderSize": {
    "name": "getFolderSize",
    "slug": "TsFunction",
    "id": "razixfasroxzzuwvbyzycjik",
    "description": "",
    "operationName": "fs-util",
    "rawText": " async (absoluteFolderPath: string): Promise<number> => {\n  const files = await fs.readdir(absoluteFolderPath, { withFileTypes: true });\n\n  const paths = files.map(async (file) => {\n    const newPath = path.join(absoluteFolderPath, file.name);\n\n    if (file.isDirectory()) return await getFolderSize(newPath);\n\n    if (file.isFile()) {\n      const { size } = await fs.stat(newPath);\n\n      return size;\n    }\n\n    return 0;\n  });\n\n  return (\n    (await Promise.all(paths))\n      //  NB: lol!\n      .flat(Infinity)\n      .reduce((i, size) => i + size, 0)\n  );\n}"
  },
  "getFolder": {
    "name": "getFolder",
    "slug": "TsFunction",
    "id": "mcdweqegfacgaacssqvawqit",
    "description": "if the path exists:\n- if the pathString is a folder, that is returned.\n- if the pathstring is not a folder, returns the pathstring without the file suffix\n\nif the path doesn't exist: returns pathString witout last chunk (this would only work for file paths)",
    "operationName": "fs-util",
    "rawText": " (pathString: string) => {\n  const parsedPath = path.parse(pathString);\n  const hasExtension = parsedPath.ext.length > 0;\n\n  if (hasExtension) {\n    // NB: assume it's a file, let's avoid folders with dots!\n    const pathChunks = pathString.split(\"/\");\n    pathChunks.pop(); //remove the filename\n    return pathChunks.join(\"/\");\n  } else {\n    // NB: it's already a folder!\n    return pathString;\n  }\n}"
  },
  "getLastFolder": {
    "name": "getLastFolder",
    "slug": "TsFunction",
    "id": "eukyudbnndvwhdyipzkgaaja",
    "description": "removes everything after the last slash to get folder path\n\ninput: /Users/king/Documents/some/folder/xyz\noutput: xyz\n\ninput: /Users/king/Documents/some/folder/xyz.txt\noutput: folder",
    "operationName": "fs-util",
    "rawText": " (pathString: string) => {\n  const lastFolder = getFolder(pathString).split(\"/\").pop()!;\n  // console.log({ pathString, lastFolder });\n  return lastFolder;\n}"
  },
  "getOneFolderUpPath": {
    "name": "getOneFolderUpPath",
    "slug": "TsFunction",
    "id": "aruapwwuexdvmbgdwuynnvkv",
    "description": "Takes a folder path and returns a path that is one folder up",
    "operationName": "fs-util",
    "rawText": " (folderPath: string) => {\n  const pathParts = folderPath.split(\"/\");\n  pathParts.pop();\n  return pathParts.join(\"/\");\n}"
  },
  "getPathCombinations": {
    "name": "getPathCombinations",
    "slug": "TsFunction",
    "id": "xwjrwvnhtopdjsnfybdfkhej",
    "description": "gets combinations for paths\n\ninput: [[\"operation1\",\"operation2\"], \"db/value-export\", [\"index.ts\",\"test.ts\",\"cli.ts\"]]\noutput: [\"operation1/db/value-export/index.ts\",\"operation2/db/value-export/index.ts\",\"operation1/db/value-export/test.ts\",\"operation2/db/value-export/test.ts\",\"operation1/db/value-export/cli.ts\",\"operation2/db/value-export/cli.ts\"]",
    "operationName": "fs-util",
    "rawText": " (\n  ...chunksSegments: (string[] | string)[]\n): string[] => {\n  return (\n    chunksSegments\n      .map((x) => makeArray(x))\n      // small check to prevent crashes in case there is an invalid type given (not a string)\n      .map((chunks) => chunks.filter(notEmpty))\n      .reduce((cumSegments, chunks) => {\n        // first chunk is the combination of itself\n        if (cumSegments.length === 0) return chunks;\n        // all next chunks use the accummualted segments and reduce them\n        const nextCumSegments = cumSegments.reduce((all, segment) => {\n          // for every segment add all the chunks to that segment\n          const newChunks = chunks.map((chunk) => path.join(segment, chunk));\n          //add them to all new cumSegments\n          return all.concat(newChunks);\n        }, [] as string[]);\n        return nextCumSegments;\n      }, [] as string[])\n  );\n}"
  },
  "gracefulFsConstants": {
    "name": "gracefulFsConstants",
    "slug": "TsVariable",
    "id": "kiuyunfrdudwjwxebdchyiwj",
    "description": "",
    "operationName": "fs-util"
  },
  "gracefulFsPromises": {
    "name": "gracefulFsPromises",
    "slug": "TsVariable",
    "id": "lwxuqjqvzqjwagrbitwgvevg",
    "description": "",
    "operationName": "fs-util"
  },
  "mkdir": {
    "name": "mkdir",
    "slug": "TsVariable",
    "id": "gjmzqryjmervflderlkwuusi",
    "description": "",
    "operationName": "fs-util"
  },
  "oneUp": {
    "name": "oneUp",
    "slug": "TsFunction",
    "id": "rdphgwhofowgrtmushmsphvb",
    "description": "Finds the number at the end of a filename and increases it\nIf there is no number yet, concatenates '1' to a string\n\nE.g.\n\n- `hello-world` becomes `hello-world1`\n- `hello36` becomes `hello37`",
    "operationName": "fs-util",
    "rawText": " (filename: string): string => {\n  const lastNumber = filename.match(/\\d+$/)?.[0];\n  const newNumber = lastNumber ? String(Number(lastNumber) + 1) : \"1\";\n  return `${filename}${newNumber}`;\n}"
  },
  "parseMd": {
    "name": "parseMd",
    "slug": "TsFunction",
    "id": "trxoiagcierutgpcmjzrspwq",
    "description": "DEPRECATED: just use `md-to-json-parse`\n\nparse a md file to all the needed info\n@param mdFilePath path to a md file\n@returns Md",
    "operationName": "fs-util",
    "rawText": " (mdFilePath: Path): Markdown => {\n  const fileContents = fs.readFileSync(mdFilePath, \"utf8\");\n  const fileStats = fs.statSync(mdFilePath);\n\n  const config: matter.GrayMatterOption<string, any> | undefined = undefined;\n  const matterResult = matter(fileContents, config);\n\n  const fileName = mdFilePath.split(\"/\").pop()!.replace(/\\.md$/, \"\");\n\n  return {\n    content: matterResult.content,\n    createdAt: fileStats.birthtimeMs,\n    fileName,\n    openedAt: fileStats.atimeMs,\n    params: matterResult.data,\n    updatedAt: fileStats.ctimeMs,\n    modifiedAt: fileStats.mtimeMs,\n  };\n}"
  },
  "path": {
    "name": "path",
    "slug": "TsVariable",
    "id": "lgihauyyhdjnumldmubaovto",
    "description": "",
    "operationName": "fs-util-js"
  },
  "readFileSync": {
    "name": "readFileSync",
    "slug": "TsVariable",
    "id": "yavcdbxlymsfxapebspclsle",
    "description": "",
    "operationName": "fs-util"
  },
  "readFile": {
    "name": "readFile",
    "slug": "TsVariable",
    "id": "ktiqjpqcnwpmhykpgpmgfjjt",
    "description": "",
    "operationName": "fs-util"
  },
  "readdirSync": {
    "name": "readdirSync",
    "slug": "TsVariable",
    "id": "xvsaymwksghiuyxudqijtkpi",
    "description": "",
    "operationName": "fs-util"
  },
  "readdir": {
    "name": "readdir",
    "slug": "TsVariable",
    "id": "ggatjslxwxjglvjtxciwiczi",
    "description": "",
    "operationName": "fs-util"
  },
  "realpath": {
    "name": "realpath",
    "slug": "TsVariable",
    "id": "jcohtbfmddiaiwzlavmqusxu",
    "description": "",
    "operationName": "fs-util"
  },
  "removeAllExcept": {
    "name": "removeAllExcept",
    "slug": "TsFunction",
    "id": "gayxgkgevrbaajahfopynuyy",
    "description": "Removes everything inside a folder except some files and folders that can, optionally, be ignored for removal. does not remove the folder itself\n\nNB: make this work with subdirectories!",
    "operationName": "fs-util",
    "rawText": " async (\n  folderPath: string,\n  config?: {\n    /**\n     * array of relative folder paths and file paths that should not be removed (include the extensions!)\n     */\n    ignore?: string[];\n    typeToRemove?: \"file\" | \"folder\";\n  }\n): Promise<\n  {\n    name: string;\n    removed: boolean;\n  }[]\n> => {\n  const filesAndFolders = await fs.readdir(folderPath, {\n    encoding: \"utf8\",\n    withFileTypes: true,\n  });\n\n  const removePromises = filesAndFolders.map((dirent) => {\n    if (config?.ignore?.find((x) => x.includes(dirent.name)))\n      return { name: dirent.name, removed: false };\n\n    if (config?.typeToRemove === \"file\" && !dirent.isFile())\n      return { name: dirent.name, removed: false };\n\n    if (config?.typeToRemove === \"folder\" && !dirent.isDirectory())\n      return { name: dirent.name, removed: false };\n\n    return fs\n      .rm(path.join(folderPath, dirent.name), { recursive: true })\n      .then(() => ({ name: dirent.name, removed: true }));\n  });\n\n  const promised = await Promise.all(removePromises);\n  return promised;\n}"
  },
  "renameAndCreate": {
    "name": "renameAndCreate",
    "slug": "TsFunction",
    "id": "cshhbevelyskqnyyohrwbdce",
    "description": "",
    "operationName": "fs-util",
    "rawText": " async (oldPath: string, newPath: string) => {\n  const newPathFolderPath = path.parse(newPath).dir;\n\n  if (!fs.existsSync(newPathFolderPath)) {\n    await fs.mkdir(newPathFolderPath, { recursive: true });\n  }\n\n  await fs.rename(oldPath, newPath);\n}"
  },
  "rename": {
    "name": "rename",
    "slug": "TsVariable",
    "id": "cgcvxucohzwrhiisalvgnakd",
    "description": "",
    "operationName": "fs-util"
  },
  "rm": {
    "name": "rm",
    "slug": "TsVariable",
    "id": "rztakwfmiqvnvxpscmquppck",
    "description": "",
    "operationName": "fs-util"
  },
  "stat": {
    "name": "stat",
    "slug": "TsVariable",
    "id": "beindflyywpgmncrzuuvfwxz",
    "description": "",
    "operationName": "fs-util"
  },
  "watch": {
    "name": "watch",
    "slug": "TsVariable",
    "id": "ebhkdqkbwtnzwdfoafyvckve",
    "description": "",
    "operationName": "fs-util"
  },
  "writeFileSync": {
    "name": "writeFileSync",
    "slug": "TsVariable",
    "id": "dtgbjciwwwwmmwkzhuwhmgdv",
    "description": "",
    "operationName": "fs-util"
  },
  "writeFile": {
    "name": "writeFile",
    "slug": "TsVariable",
    "id": "qvhluclutdwfkfytfdrmkcbo",
    "description": "",
    "operationName": "fs-util"
  },
  "writeJsonToFile": {
    "name": "writeJsonToFile",
    "slug": "TsFunction",
    "id": "vlkkqkmwxhbqpztucpslpehk",
    "description": "write json to a file\n\nmakes the dir and file if they don't exist",
    "operationName": "fs-util",
    "rawText": " async <T>(\n  p: Path,\n  data: T\n): Promise<boolean> => {\n  if (!data) {\n    console.log({ p, data });\n    return false;\n  }\n  const stringifiedData = JSON.stringify(data, null, 2);\n\n  const folderToBe = getFolder(p);\n  if (!fs.existsSync(folderToBe)) {\n    //first, make sure the folder exists\n    await fs.mkdir(folderToBe, { recursive: true });\n  }\n  //then write it\n  await fs.writeFile(p, stringifiedData, \"utf8\");\n  return true;\n}"
  },
  "writeStringToFile": {
    "name": "writeStringToFile",
    "slug": "TsFunction",
    "id": "ozrytvfrefnhiifrkkifsogt",
    "description": "write string to a file\n\nmakes the dir and file if they don't exist",
    "operationName": "fs-util",
    "rawText": " async (\n  p: Path,\n  data: string\n): Promise<boolean> => {\n  if (data === undefined || data === null || typeof data !== \"string\") {\n    log(`Incorrect data provided`, data);\n    return false;\n  }\n\n  const folderToBe = getFolder(p);\n\n  if (!fs.existsSync(folderToBe)) {\n    //first, make sure the folder exists\n    await fs.mkdir(folderToBe, { recursive: true });\n  }\n\n  //then write it\n  await fs.writeFile(p, data, \"utf8\");\n\n  return true;\n}"
  },
  "writeToFiles": {
    "name": "writeToFiles",
    "slug": "TsFunction",
    "id": "edttwjnoulyzrmkhmutrjjzj",
    "description": "writes all values in an object to the file that should be specified as key of that value",
    "operationName": "fs-util",
    "rawText": " async (fileObject: {\n  [absoluteFilePath: string]: any;\n}) => {\n  let s = 0;\n  let e = 0;\n  const writePromises = Object.keys(fileObject).map(async (filePath) => {\n    const value = fileObject[filePath];\n    const success = await writeJsonToFile(filePath, value);\n    if (success) s++;\n    if (!success) e++;\n\n    return success;\n  });\n  await Promise.all(writePromises);\n}"
  },
  "getExtension": {
    "name": "getExtension",
    "slug": "TsFunction",
    "id": "tclicbejrvpdleoprpzaeisp",
    "description": "returns the extension of the filename or path WITHOUT dot\n\nNB: not sure, but could be nice to replace this with path.extname(pathString)",
    "operationName": "fs-util-js",
    "rawText": " (fileNameOrPath: string) => {\n  const pieces = fileNameOrPath.split(\".\");\n  return pieces.pop()!;\n}"
  },
  "getFileOrFolderName": {
    "name": "getFileOrFolderName",
    "slug": "TsFunction",
    "id": "qnzfuwcsxabvbyfrucmdrlai",
    "description": "",
    "operationName": "fs-util-js",
    "rawText": " <T extends string | undefined>(\n  fileOrFolderPath: T\n): T => {\n  if (!fileOrFolderPath) return undefined as T;\n  const last = fileOrFolderPath.split(\"/\").pop()!;\n  return last as T;\n}"
  },
  "getFolderJs": {
    "name": "getFolderJs",
    "slug": "TsFunction",
    "id": "hppkorebhtcnqyixxtngbuwt",
    "description": "",
    "operationName": "fs-util-js",
    "rawText": " <T extends string | undefined>(filePath: T): T => {\n  if (filePath === undefined) return undefined as T;\n  const chunks = filePath.split(\"/\");\n  chunks.pop();\n  const allWithoutFile = chunks.join(\"/\") as T;\n  return allWithoutFile;\n}"
  },
  "getSubExtension": {
    "name": "getSubExtension",
    "slug": "TsFunction",
    "id": "foihoghcrlqzumtdyixnqdsj",
    "description": "Provide a filename including its extension, to get the subextension.",
    "operationName": "fs-util-js",
    "rawText": " (filename: string): string | undefined => {\n  const parts = filename.split(\".\");\n  //removes extension\n  parts.pop();\n  //returns extension that's left (the sub-extension)\n  const subExtension = parts.pop();\n  return subExtension;\n}"
  },
  "isPathRelative": {
    "name": "isPathRelative",
    "slug": "TsFunction",
    "id": "mkxgswwwnxytwedsvdbsqsri",
    "description": "",
    "operationName": "fs-util-js",
    "rawText": " (path: string) =>\n  path.startsWith(\"./\") || path.startsWith(\"../\")"
  },
  "join": {
    "name": "join",
    "slug": "TsFunction",
    "id": "rxvtoscicaaeiwlwlsytgcim",
    "description": "",
    "operationName": "fs-util-js",
    "rawText": " (...chunks: string[]) => {\n  return chunks.join(\"/\");\n}"
  },
  "makeRelative": {
    "name": "makeRelative",
    "slug": "TsFunction",
    "id": "nywdhdjogscjykjxjagvjpxw",
    "description": "Makes a path relative using proper parsing\n\nResulting path will apply the paths conventions\n- no slash at the end\n- no slash at the beginning",
    "operationName": "fs-util-js",
    "rawText": " (\n  /**\n   * absolute path of a file or folder without a slash at the end\n   */\n  absolutePath: string,\n  /**\n   * folder path without a slash at the end\n   */\n  baseFolderPath: string\n): string => {\n  // basecase should be handled, we don't want to get some weird slice edgecase\n  if (absolutePath.length < baseFolderPath.length) return \"\";\n\n  return absolutePath.slice(baseFolderPath.length + 1);\n}"
  },
  "removeTrailingSlash": {
    "name": "removeTrailingSlash",
    "slug": "TsFunction",
    "id": "selciiefnseocxmphdddozfg",
    "description": "",
    "operationName": "fs-util-js",
    "rawText": " (p: string) =>\n  p.charAt(0) === \"/\" ? p.slice(1) : p"
  },
  "withoutExtension": {
    "name": "withoutExtension",
    "slug": "TsFunction",
    "id": "uepibtekbllubfeopmkaxhci",
    "description": "removes extension from the filename",
    "operationName": "fs-util-js",
    "rawText": " (fileName: string) => {\n  const pieces = fileName.split(\".\");\n  pieces.pop();\n  return pieces.join(\".\");\n}"
  },
  "getAssociatedMd": {
    "name": "getAssociatedMd",
    "slug": "TsFunction",
    "id": "bossqmysbvlcvloubuwzancb",
    "description": "If it's there, returns the contents of an associated md file in the src folder of any js file in a build.\n\nIf the executed file is located in `package/build/folder/util.js`, the associated md that should be found should be located in `package/src/folder/util.md`.\n\nThis can be a useful to write information about a typescript file, super close to the file. The other way to do this would be to write a doccomment on top of the file, but the advantage of this is that you could create syntax highlighted markdown in an easier way.",
    "operationName": "get-associated-md",
    "rawText": " async (absoluteFilePath: string) => {\n  const operationBasePath = findOperationBasePath(absoluteFilePath);\n  if (!operationBasePath) return;\n  const prefixToRemove = \"/build/\";\n  const relativePath = absoluteFilePath.slice(\n    operationBasePath.length + prefixToRemove.length\n  );\n  const relativePathParse = path.parse(relativePath);\n  const relativePathMd = path.join(\n    relativePathParse.dir,\n    `${relativePathParse.name}.md`\n  );\n  const srcMdFile = path.join(operationBasePath, \"src\", relativePathMd);\n\n  if (!fs.existsSync(srcMdFile)) {\n    return null;\n  }\n\n  const contents = await fs.readFile(srcMdFile, \"utf8\");\n\n  return { contents, path: srcMdFile };\n}"
  },
  "getAvailableFolderPath": {
    "name": "getAvailableFolderPath",
    "slug": "TsFunction",
    "id": "kksqvhklsbztvniqzoryupkd",
    "description": "Returns an available path with a certain folder name that recursively checks and ups the folder name suffix number if the proposed foldername already exists\n\nFor operations we have getAvailableOperationName",
    "operationName": "get-available-folder-path",
    "rawText": " (\n  basePath: string,\n  folderName: string,\n  number?: number\n): string => {\n  const proposedPath = path.join(basePath, `${folderName}${number || \"\"}`);\n  if (!fs.existsSync(proposedPath)) {\n    return proposedPath;\n  }\n\n  return getAvailableFolderPath(basePath, folderName, number ? number++ : 2);\n}"
  },
  "getOperationBins": {
    "name": "getOperationBins",
    "slug": "TsFunction",
    "id": "loytmhlzanwpyuubuhxzvjhg",
    "description": "returns array of bins. by convention, these bins should also be exported from operation index file",
    "operationName": "get-package-json",
    "rawText": " async (operationFolderPath: string) => {\n  const packageJson = await getPackageJson({ operationFolderPath });\n  return packageJson?.bin ? Object.keys(packageJson.bin) : [];\n}"
  },
  "getOperationPackageName": {
    "name": "getOperationPackageName",
    "slug": "TsFunction",
    "id": "wbubnpzxtgtgfonuctanofkb",
    "description": "",
    "operationName": "get-package-json",
    "rawText": " async (operationFolderPath: string) => {\n  const packageJson = await getPackageJson({ operationFolderPath });\n  return packageJson?.name;\n}"
  },
  "getPackageJson": {
    "name": "getPackageJson",
    "slug": "TsFunction",
    "id": "mqaajejudabrmygjvnhhotma",
    "description": "",
    "operationName": "get-package-json",
    "rawText": " async (config: {\n  operationFolderPath: string;\n}): Promise<Operation | null> => {\n  const { operationFolderPath } = config;\n  const packageJsonPath = path.join(operationFolderPath, \"package.json\");\n  const packageJson = readJsonFile<Operation>(packageJsonPath);\n  return packageJson;\n}"
  },
  "getPackageSourcePaths": {
    "name": "getPackageSourcePaths",
    "slug": "TsFunction",
    "id": "eglpyubohaigkgoyqebkctyq",
    "description": "Returns an array of absolute file paths of (typescript) files in the src of your operation\n\nTODO: we need a way to explore these glob patterns inside of tsConfig.include.\nuntil then, just assume we use \"src\" as the only folder",
    "operationName": "get-package-source-paths",
    "rawText": " async ({\n  operationBasePath,\n  ignoreIndexFiles,\n  allTypes,\n}: {\n  operationBasePath: string;\n  ignoreIndexFiles?: boolean;\n  /**\n   * by default, only searches for ts and tsx files, if this is true, it will search for any type\n   */\n  allTypes?: boolean;\n}) => {\n  const filePaths = (\n    await explore({\n      basePath: path.join(operationBasePath, \"src\"),\n      extension: allTypes ? undefined : [\"ts\", \"tsx\"],\n      ignore: ignoreIndexFiles ? [\"index.ts\", \"index.tsx\"] : undefined,\n    })\n  ).map((x) => x.path);\n\n  return filePaths;\n}"
  },
  "getTsConfig": {
    "name": "getTsConfig",
    "slug": "TsFunction",
    "id": "iztzayzesnvqusncpuqmsldu",
    "description": "",
    "operationName": "get-ts-config",
    "rawText": " (packageFolder: string) => {\n  const jsonPath = path.join(packageFolder, \"tsconfig.json\");\n  const json = readJsonFile<TsConfig>(jsonPath);\n  return json;\n}"
  },
  "calculatePathMetaData": {
    "name": "calculatePathMetaData",
    "slug": "TsFunction",
    "id": "rhvmoyvychqdfmldzviqekjd",
    "description": "for folders: finds all files used for calculation and uses sumPathMetaData to create a new PathMetaData.\nfor files: just calculates the path metadata",
    "operationName": "path-util",
    "rawText": " async (\n  absolutePath: string\n): Promise<PathMetaData | undefined> => {\n  const exists = fs.existsSync(absolutePath);\n  if (!exists) return;\n  const pathParse = getPathParse(absolutePath);\n  if (!pathParse) return;\n\n  const stats = await fs.stat(absolutePath);\n  const isFolder = stats.isDirectory();\n  const fullFileName = isFolder ? undefined : path.parse(absolutePath).base;\n\n  const fileType = isFolder ? null : determineFileType(absolutePath);\n\n  const categorizedFiles: CategorizedFilePaths = isFolder\n    ? await categorizeFiles({ basePath: absolutePath })\n    : {\n        code: fileType === \"code\" ? [absolutePath] : [],\n        data: fileType === \"data\" ? [absolutePath] : [],\n        text: fileType === \"text\" ? [absolutePath] : [],\n      };\n\n  const folderSummary = await getFolderSummary(categorizedFiles);\n  const mainComment = await getPathMainComment(absolutePath);\n\n  const pathMetaData: PathMetaData = {\n    mainComment,\n    fullFileName,\n    createdAt: stats.ctimeMs,\n    updatedAt: stats.mtimeMs,\n    ...pathParse,\n    sizes: folderSummary,\n  };\n\n  return pathMetaData;\n}"
  },
  "categorizeFiles": {
    "name": "categorizeFiles",
    "slug": "TsFunction",
    "id": "bjdyjbqmlzyvvlcqdbupcnew",
    "description": "explores files in an operation within a specified location or from a specified type",
    "operationName": "path-util",
    "rawText": " async ({\n  basePath,\n  type,\n  ignoreIndexFiles,\n}: {\n  basePath: string | string[];\n  /**\n   * ignore index files or not\n   */\n  ignoreIndexFiles?: boolean;\n  /**\n   * if given, only search for files of a specific containing data type\n   */\n  type?: \"code\" | \"data\" | \"text\";\n}): Promise<CategorizedFilePaths> => {\n  const defaultIgnore = [\"node_modules\", databaseFolderName, buildFolderName];\n\n  const filePaths = (\n    await explore({\n      basePath,\n      extension: type ? (extensions[type] as SearchableExtension[]) : undefined,\n      ignore: ignoreIndexFiles\n        ? [\"index.ts\", \"index.tsx\", ...defaultIgnore]\n        : defaultIgnore,\n    })\n  ).map((x) => x.path);\n\n  return filePaths.reduce(\n    (categorizedFilePathsObject, filePath) => {\n      const fileType = determineFileType(filePath);\n      // console.log({ filePath, fileType });\n      if (!fileType) return categorizedFilePathsObject;\n\n      categorizedFilePathsObject[fileType].push(filePath);\n\n      return categorizedFilePathsObject;\n    },\n    { code: [] as string[], data: [] as string[], text: [] as string[] }\n  );\n}"
  },
  "getFolderSummary": {
    "name": "getFolderSummary",
    "slug": "TsFunction",
    "id": "ejufzzxdgcxybadtwhgxypot",
    "description": "calculates folder summary from a categorized file paths object",
    "operationName": "path-util",
    "rawText": " async (\n  categorizedFiles: CategorizedFilePaths\n): Promise<FolderSummary> => {\n  const categoriesSummary: Omit<FolderSummary, \"size\"> = {\n    codeSize: await sumSizeSummary(categorizedFiles.code),\n    dataSize: await sumSizeSummary(categorizedFiles.data),\n    textSize: await sumSizeSummary(categorizedFiles.text),\n  };\n\n  const folderSummary: FolderSummary = {\n    ...categoriesSummary,\n    size: sumAllKeys(Object.values(categoriesSummary), [\n      \"bytes\",\n      \"characters\",\n      \"lines\",\n      \"numberOfFiles\",\n    ]),\n  };\n\n  return folderSummary;\n}"
  },
  "getPathMainComment": {
    "name": "getPathMainComment",
    "slug": "TsFunction",
    "id": "uqututmyygsjirnuaofyshph",
    "description": "export const sumFolderSummary = (\nfirstFolderSummary: FolderSummary,\nsecondFolderSummary: FolderSummary\n): FolderSummary => {\nconst folderSummaryKeys = Object.keys(\nfirstFolderSummary\n) as (keyof FolderSummary)[];\nconst sum = mergeObjectsArray(\nfolderSummaryKeys.map((keyName) => {\nreturn {\n[keyName]: sumAllKeys([\nfirstFolderSummary[keyName],\nsecondFolderSummary[keyName],\n],[\"bytes\",\"characters\",\"lines\",\"numberOfFiles\"]),\n};\n})\n) as FolderSummary;\n\nreturn sum;\n};\n\n\ntakes all PathMetaData of an array that contains all child files, and merges them, taking the newest update date, the earliest created-date, and summing size\n\nexport const sumFileGeneralMetaData = async (\nchildrenMetaDataArray: PathGeneralMetaData[]\n): Promise<PathGeneralMetaData | null> => {\nconst sum = childrenMetaDataArray.reduce(\n(sumMetaData, pathMetaData: PathGeneralMetaData) => {\nconst newPathMetaData: PathGeneralMetaData = {\ncreatedAt:\n!sumMetaData || pathMetaData.createdAt < sumMetaData.createdAt\n? pathMetaData.createdAt\n: sumMetaData.createdAt,\nupdatedAt:\n!sumMetaData || pathMetaData.updatedAt > sumMetaData.updatedAt\n? pathMetaData.updatedAt\n: sumMetaData.updatedAt,\nsizes: !sumMetaData\n? pathMetaData.sizes\n: sumFolderSummary(sumMetaData.sizes, pathMetaData.sizes),\n};\n\nreturn newPathMetaData;\n},\nnull as PathGeneralMetaData | null\n);\n\nreturn sum;\n};",
    "operationName": "path-util",
    "rawText": " async (\n  absolutePath: string\n): Promise<TsComment | undefined> => {\n  const indexId = await getIndexId(absolutePath, getLastFolder(absolutePath));\n  if (!indexId) return;\n  const folderPath = getFolder(absolutePath);\n  const folderFiles = await fs.readdir(folderPath, \"utf8\");\n  const foundReadmePath = folderFiles.find(\n    (x) => path.parse(x).name.toLowerCase() === \"readme\"\n  );\n\n  const readmeExists = !!foundReadmePath;\n\n  const markdown = readmeExists\n    ? await fs.readFile(foundReadmePath, \"utf8\")\n    : \"\";\n  const { raw: comment, parameters } = parseFrontmatterMarkdownString(markdown);\n\n  const types = findCommentTypes(comment);\n\n  const mainComment: TsComment | undefined = {\n    rawStatement: undefined,\n    statementName: undefined,\n    ...indexId,\n    comment,\n    parameters,\n    types,\n    firstLine: 0,\n    lastLine: getNumberOfLines(markdown),\n  };\n\n  return mainComment;\n}"
  },
  "getSizeSummary": {
    "name": "getSizeSummary",
    "slug": "TsFunction",
    "id": "crbaibngzhqjbqpijbvnfysa",
    "description": "takes a string and simply returns the amount of characters, the amount of lines and the amount of bytes\n\nTODO: this is not the right place for this function",
    "operationName": "index-typescript",
    "rawText": " (string: string): SizeSummary => {\n  const characters = string.length;\n  const lines = string.split(\"\\n\").length;\n  const bytes = byteCount(string);\n  return {\n    characters,\n    lines,\n    bytes,\n    bytesPerCharacter: bytes / characters,\n    charactersPerLine: Math.round(characters / lines),\n    linesPerFile: lines,\n    numberOfFiles: 1,\n  };\n}"
  },
  "sumSizeSummary": {
    "name": "sumSizeSummary",
    "slug": "TsFunction",
    "id": "hopaqplnsnbhczjzooprpnvd",
    "description": "",
    "operationName": "path-util",
    "rawText": " async (\n  filePaths: string[]\n): Promise<SizeSummary> => {\n  const sizeSummaries = await Promise.all(filePaths.map(getSizeSummary));\n  const summed = sumAllKeys(sizeSummaries, [\n    \"numberOfFiles\",\n    \"lines\",\n    \"characters\",\n    \"bytes\",\n  ]);\n  return summed;\n}"
  },
  "findTemplates": {
    "name": "findTemplates",
    "slug": "TsFunction",
    "id": "wwtrwuamkbhotwkbwnizbfzl",
    "description": "",
    "operationName": "rename-template-files",
    "rawText": " async (\n  basePath: string,\n  doNotExploreChildFolders?: boolean\n) => {\n  return (\n    await explore({\n      basePath,\n      subExtension: [\"template\"],\n      searchLevel: \"fileName\",\n      doNotExploreChildFolders,\n    })\n  ).map((textJson) => textJson.path);\n}"
  },
  "isEqualArray": {
    "name": "isEqualArray",
    "slug": "TsFunction",
    "id": "jlxyujtwdsyfsybnnihgwnqv",
    "description": "As long as there are no .template files present in the template folder that DONT need to be changed, it is fine.\nIf there are, we should warn people.",
    "operationName": "rename-template-files",
    "rawText": " (array1: unknown[], array2: unknown[]) =>\n  array1.length === array2.length &&\n  array1.every((value, index) => value === array2[index])"
  },
  "renameTemplateFiles": {
    "name": "renameTemplateFiles",
    "slug": "TsFunction",
    "id": "ckfjzpxhscuajypnijravckt",
    "description": "",
    "operationName": "rename-template-files",
    "rawText": " async ({ appDir }: { appDir: string }) => {\n  const templateFiles = await findTemplates(appDir);\n  const renameables = templateFiles.map((path) => ({\n    oldPath: path,\n    newPath: renameTemplateToNormalFile(path),\n  }));\n\n  await oneByOne(renameables, async (oldNew) =>\n    fs.rename(oldNew.oldPath, oldNew.newPath)\n  );\n\n  return;\n}"
  },
  "renameTemplateToNormalFile": {
    "name": "renameTemplateToNormalFile",
    "slug": "TsFunction",
    "id": "ytadvhqirvlirbzsdkawksxf",
    "description": "",
    "operationName": "rename-template-files",
    "rawText": " (fileName: string) => {\n  return fileName.replace(\".template\", \"\");\n}"
  },
  "renameToTemplateFile": {
    "name": "renameToTemplateFile",
    "slug": "TsFunction",
    "id": "qexadcpbtpzdiocvfbqyjjml",
    "description": "",
    "operationName": "rename-template-files",
    "rawText": " (fileName: string) => {\n  const extensionStartsAt = fileName.lastIndexOf(\".\");\n  const insertPosition =\n    extensionStartsAt === -1 ? fileName.length : extensionStartsAt;\n  const beforeExtension = fileName.substring(0, insertPosition);\n  const afterExtension = fileName.substring(insertPosition);\n\n  return `${beforeExtension}${templateExtension}${afterExtension}`;\n}"
  },
  "templateExtension": {
    "name": "templateExtension",
    "slug": "TsVariable",
    "id": "bkhpyphggkwehjxbhibxosui",
    "description": "",
    "operationName": "rename-template-files"
  },
  "setJsonKey": {
    "name": "setJsonKey",
    "slug": "TsFunction",
    "id": "kykbyodthtnpwrtzeydwgzdi",
    "description": "npx setjsonkey [json-path] key1.key2.[index/latest/push].key3 \"value\"\n\n\ncollect arguments 1 2 and 3\nfind file (arg1) in path, import json (or start with empty object in a new file)\nreduce keys (arg2) to go deeper into the object and create keys as they don't exist\nmake sure it works with arrays too\nconvert value string (arg3) to number, boolean if they seem to be like that",
    "operationName": "set-json-key",
    "rawText": " async ({\n  jsonPath,\n  keyLocation,\n  value,\n  debug,\n}: {\n  jsonPath: string;\n  keyLocation: string;\n  value: string;\n  debug?: boolean;\n}) => {\n  const usage =\n    'usage: npx setjsonkey [json-file-path] key1.key2.[index/latest/push].key3 \"value\" (Check https://github.com/Code-From-Anywhere/setjsonkey for more info)';\n\n  // VALIDATION\n\n  if (!keyLocation || keyLocation.length === 0) {\n    console.log(usage);\n    process.exit(0);\n  }\n\n  const jsonPathWithExtension = jsonPath.endsWith(\".json\")\n    ? jsonPath\n    : jsonPath + \".json\";\n  const absolutePath = path.resolve(jsonPathWithExtension);\n  const fileExists = fs.existsSync(absolutePath);\n\n  if (!fileExists) {\n    const folder = getFolder(absolutePath);\n    console.log(\"creating folder because it didn't exist yet\", folder);\n    fs.mkdir(folder, { recursive: true });\n  }\n\n  let object: Object = {};\n\n  if (fileExists) {\n    try {\n      object = JSON.parse(await fs.readFile(absolutePath, \"utf8\"));\n    } catch (e) {\n      console.log(\n        \"No JSON found here, so we're overwriting it with our new JSON\"\n      );\n    }\n  }\n\n  if (typeof object !== \"object\") {\n    object = {};\n  }\n\n  const realValue =\n    value === \"true\" || value === \"false\"\n      ? Boolean(value)\n      : !isNaN(Number(value))\n      ? Number(value)\n      : value;\n\n  // UPDATE/SET JSON key\n  setKeyAtLocation(keyLocation, realValue, object);\n\n  const newObject = JSON.stringify(object, undefined, 2);\n  await fs.writeFile(absolutePath, newObject, { encoding: \"utf8\" });\n\n  if (debug) {\n    console.log({ absolutePath, fileExists, object, newObject });\n    console.log(\"succesfully changed your json!\");\n  }\n}"
  },
  "getSubInfo": {
    "name": "getSubInfo",
    "slug": "TsFunction",
    "id": "youqdmwdnfkadjdejtgmbins",
    "description": "",
    "operationName": "watch-folders",
    "rawText": " (subscriptionKey: string) => {\n  const [appKey, rootPath, relativePath] = subscriptionKey.split(\":\");\n\n  if (appKey !== uniqueAppKey) {\n    return;\n  }\n  if (!rootPath) {\n    console.log(\"No rootpath found\", subscriptionKey);\n    return;\n  }\n\n  const fullPath = relativePath ? path.join(rootPath, relativePath) : rootPath;\n\n  return {\n    fullPath,\n    relativePath,\n    rootPath,\n  };\n}"
  },
  "getSubName": {
    "name": "getSubName",
    "slug": "TsFunction",
    "id": "gtsmspdgjlabydxfihfrsqct",
    "description": "",
    "operationName": "watch-folders",
    "rawText": " (watchBaseFolder: string, watchRelativePath?: string) =>\n  `${uniqueAppKey}:${watchBaseFolder}${\n    watchRelativePath ? `:${watchRelativePath}` : \"\"\n  }`"
  },
  "initiateWatch": {
    "name": "initiateWatch",
    "slug": "TsFunction",
    "id": "jimfzalpnbboyrycnkaounlc",
    "description": "",
    "operationName": "watch-folders",
    "rawText": " ({\n  client,\n  debug,\n  folderPath,\n}: {\n  client: watchman.Client;\n  debug: boolean;\n  folderPath: string;\n}) => {\n  client.command([\"watch-project\", folderPath], function (error, resp) {\n    if (error) {\n      console.error(\"Error initiating watch:\", error);\n      return;\n    }\n\n    // It is considered to be best practice to show any 'warning' or\n    // 'error' information to the user, as it may suggest steps\n    // for remediation\n    if (\"warning\" in resp) {\n      console.log(\"Warning initiating watch: \", resp.warning);\n    }\n\n    // `watch-project` can consolidate the watch for your\n    // dir_of_interest with another watch at a higher level in the\n    // tree, so it is very important to record the `relative_path`\n    // returned in resp\n\n    if (debug) {\n      console.log(\n        \"New watch:\",\n        \"watch established on \",\n        resp.relative_path\n          ? path.join(resp.watch, resp.relative_path)\n          : resp.watch\n      );\n    }\n\n    makeSubscription(client, resp.watch, resp.relative_path, debug);\n  });\n}"
  },
  "isClientOk": {
    "name": "isClientOk",
    "slug": "TsFunction",
    "id": "lhobsentipszcyidyjzrngmj",
    "description": "checks if watchman client is ok. ends client if it's not ok",
    "operationName": "watch-folders",
    "rawText": " (client: watchman.Client, debug: boolean) => {\n  return new Promise<void>((resolve, reject) => {\n    client.capabilityCheck(\n      { optional: [], required: [\"relative_root\"] },\n      function (error: any, resp: any) {\n        if (error) {\n          // error will be an Error object if the watchman service is not\n          // installed, or if any of the names listed in the `required`\n          // array are not supported by the server\n          console.error(error);\n          client.end();\n          return reject();\n        }\n        if (debug) {\n          console.log(\"Watchman is ok\", resp);\n        }\n\n        resolve();\n      }\n    );\n  });\n}"
  },
  "isStillPending": {
    "name": "isStillPending",
    "slug": "TsFunction",
    "id": "zwhzrwihwjnpzpihgvwdkjwq",
    "description": "checks if pending has items every 5 seconds, resolves after it hasnt\n\nthis is a handy thing to have in util, but it can also probably be much more simple",
    "operationName": "watch-folders",
    "rawText": " async () => {\n  if (noPending()) return false;\n  //\n  console.log(\"awaiting pending\", pending);\n  //\n  await new Promise<void>((resolve, reject) => {\n    // do this every 5 seconds\n    setInterval(async () => {\n      if (noPending()) {\n        resolve();\n      } else {\n        //console.log(`still pending`, pending);\n      }\n    }, 5000); //\n  }); //\n\n  return;\n}"
  },
  "noPending": {
    "name": "noPending",
    "slug": "TsFunction",
    "id": "gmwnifwjfzdftovxctehpfsx",
    "description": "",
    "operationName": "watch-folders",
    "rawText": " () => pending.length === 0"
  },
  "pending": {
    "name": "pending",
    "slug": "TsVariable",
    "id": "saynekmybqlaishgzhhinvyc",
    "description": "",
    "operationName": "watch-folders"
  },
  "pickWatcher": {
    "name": "pickWatcher",
    "slug": "TsFunction",
    "id": "pkcotsccuhvzwlridrgvqyxj",
    "description": "based on your os, pick either chokidar or fswatch",
    "operationName": "watch-folders",
    "rawText": " () => {\n  if (os.platform() === \"linux\") return watchFoldersChokidar;\n  return watchFoldersFs;\n}"
  },
  "uniqueAppKey": {
    "name": "uniqueAppKey",
    "slug": "TsVariable",
    "id": "hhbhlvgfihlhhjhqkwyuluwm",
    "description": "",
    "operationName": "watch-folders"
  },
  "watchFoldersChokidar": {
    "name": "watchFoldersChokidar",
    "slug": "TsFunction",
    "id": "jfquqziflhsaivkgukjlvzdr",
    "description": "watches folder paths and executes a callback when something changes in one of them\n\nuses fs.watch",
    "operationName": "watch-folders",
    "rawText": " async ({\n  debug = false,\n  folders,\n  onChange,\n  takeLatest,\n}: {\n  debug?: boolean;\n  folders: string[];\n  takeLatest?: boolean;\n  onChange: (event: {\n    eventType: \"rename\" | \"change\";\n    filePaths: string[];\n    operationBasePath: string;\n  }) => Promise<void>;\n}) => {\n  const startTime = Date.now();\n  folders.map((absoluteFolderPath) => {\n    watch(`${absoluteFolderPath}/*`).on(\n      \"all\",\n      async (eventType, absolutePath) => {\n        // NB: in the beginning , all folders/files are firing the \"addDir\" and \"add\" events, this hack prevents that this fires rebuilds for all folders.\n        if (Date.now() < startTime + 1000) return;\n\n        // NB: addDir should not be firing anything\n        if (eventType === \"addDir\") return;\n\n        const stats = await fs.stat(absolutePath);\n        // NB: ensure that the path is not a directory\n        if (stats.isDirectory()) return;\n\n        const srcRelativeFilePath = absolutePath.substring(\n          absoluteFolderPath.length + 1\n        );\n\n        const alreadyPending = pending.filter(\n          (x) => x.filename === srcRelativeFilePath\n        );\n\n        const lastPending = alreadyPending.pop();\n\n        // if a file was just triggered and within a second triggered again, ignore it\n        // same file within a second\n        if (lastPending && Date.now() - lastPending.time < 5000) {\n          log(`double trigger of ${srcRelativeFilePath}, ignoring`, {\n            type: \"warning\",\n          });\n          return;\n        }\n\n        if (alreadyPending.length > 0) {\n          log(`multiple pending of this file, ignoring`, { type: \"warning\" });\n          return;\n        }\n\n        //  await isStillPending();\n\n        // NB: time is also the unique id together with filename\n        const time = Date.now();\n        pending.push({ filename: srcRelativeFilePath, time });\n\n        const basePath = absoluteFolderPath;\n        const operationBasePath = path.join(basePath, \"..\");\n\n        const fullPath = path.join(absoluteFolderPath, srcRelativeFilePath);\n        // TODO: Somehow, it would be great if we could batch changes from multiple files together, so it will execute after there are no changes for more than 30 seconds (or if you press the 'e' button). This will make it more efficient.\n\n        await onChange({\n          operationBasePath,\n          eventType: \"change\",\n          filePaths: [fullPath],\n        });\n\n        // after it's done, remove from the array\n        pending = pending.filter(\n          (p) => p.filename === absolutePath && p.time === time\n        );\n      }\n    );\n  });\n}"
  },
  "watchFoldersFs": {
    "name": "watchFoldersFs",
    "slug": "TsFunction",
    "id": "cefxejdiozzmmtajhkmvlzia",
    "description": "watches folder paths and executes a callback when something changes in one of them\n\nuses fs.watch",
    "operationName": "watch-folders",
    "rawText": " async ({\n  debug = false,\n  folders,\n  onChange,\n  takeLatest,\n}: {\n  debug?: boolean;\n  folders: string[];\n  takeLatest?: boolean;\n  onChange: (event: {\n    eventType: \"rename\" | \"change\";\n    filePaths: string[];\n    operationBasePath: string;\n  }) => Promise<void>;\n}) => {\n  folders.map((folder) => {\n    watch(\n      folder,\n      { recursive: true, encoding: \"utf8\" },\n      async (eventType, filename) => {\n        const alreadyPending = pending.filter((x) => x.filename === filename);\n        const lastPending = alreadyPending.pop();\n\n        // if a file was just triggered and within a second triggered again, ignore it\n        // same file within a second\n        if (lastPending && Date.now() - lastPending.time < 5000) {\n          log(`double trigger of ${filename}, ignoring`, { type: \"warning\" });\n          return;\n        }\n\n        if (alreadyPending.length > 0) {\n          log(`multiple pending of this file, ignoring`, { type: \"warning\" });\n          return;\n        }\n\n        //  await isStillPending();\n\n        // NB: time is also the unique id together with filename\n        const time = Date.now();\n        pending.push({ filename, time });\n\n        const basePath = folder;\n        const operationBasePath = path.join(basePath, \"..\");\n\n        const fullPath = path.join(folder, filename);\n        // TODO: Somehow, it would be great if we could batch changes from multiple files together, so it will execute after there are no changes for more than 30 seconds (or if you press the 'e' button). This will make it more efficient.\n\n        await onChange({\n          operationBasePath,\n          eventType,\n          filePaths: [fullPath],\n        });\n\n        // after it's done, remove from the array\n        pending = pending.filter(\n          (p) => p.filename === filename && p.time === time\n        );\n      }\n    );\n  });\n}"
  },
  "watchFolders": {
    "name": "watchFolders",
    "slug": "TsFunction",
    "id": "dwjmwyokpqgfvukoakteclhr",
    "description": "watches folder paths and executes a callback when something changes in one of them\n\nTODO: check fs/promises.watch, that seems like a simple alternative of this! Could it be? Could it remove the need for watchman?",
    "operationName": "watch-folders",
    "rawText": " async ({\n  debug = false,\n  folders,\n  onChange,\n}: {\n  debug?: boolean;\n  folders: string[];\n  onChange: OnChangeDetected;\n}) => {\n  const client = new watchman.Client();\n  await isClientOk(client, debug);\n  // Initiate watching each folder\n  folders.forEach((folderPath) => initiateWatch({ client, debug, folderPath }));\n\n  // whenever there has been a change detected, this function will be called. Beware, can also be from other watch sources!\n  client.on(\n    \"subscription\",\n    function ({ subscription, files, root }: SubscriptionResponse) {\n      const subInfo = getSubInfo(subscription);\n      if (!subInfo) return;\n      const { fullPath, relativePath, rootPath } = subInfo;\n      const ourWatch = folders.includes(fullPath);\n      if (!ourWatch) return;\n\n      onChange({ fullPath, relativePath, rootPath, files });\n    }\n  );\n}"
  },
  "writeToAssets": {
    "name": "writeToAssets",
    "slug": "TsFunction",
    "id": "sbncictonzlaibzyatbldste",
    "description": "Writes anything (string or json) the assets folder of the operation of the caller function of this function\n\nUseful for testing",
    "operationName": "write-to-assets",
    "rawText": " async (\n  /**\n   * Insert `__filename` here or the typescript file path\n   */\n  filePath: string,\n  /**\n   * The data you want to write to a file, can also be a promise\n   */\n  data: any,\n  assetsFileName?: string,\n  hideLog?: boolean\n) => {\n  // NB: it may be a promise, so first await it\n  const realData = await data;\n\n  const operationBasePath = findOperationBasePath(filePath);\n  if (!operationBasePath) return;\n\n  const extension = typeof realData === \"string\" ? \".md\" : \".json\";\n\n  const realAssetsFileName =\n    assetsFileName || `${path.parse(filePath).name}${extension}`;\n  const assetsFilePath = path.join(\n    operationBasePath,\n    \"assets\",\n    realAssetsFileName\n  );\n\n  if (!hideLog) {\n    console.log({ assetsFilePath });\n  }\n\n  if (typeof data === \"string\") {\n    return writeStringToFile(assetsFilePath, realData);\n  }\n\n  return writeJsonToFile(assetsFilePath, realData);\n}"
  },
  "allOperationsRemoveJsSrc": {
    "name": "allOperationsRemoveJsSrc",
    "slug": "TsFunction",
    "id": "tuevcqwdrrefuklweuwlfjgd",
    "description": "BEWARE! This removes all .d.ts, .js, and .d.ts.map files in your source folder!",
    "operationName": "all",
    "rawText": " async (debug?: boolean) => {\n  await forAllFolders({\n    type: \"operations\",\n    basePath: getPathsWithOperations(),\n    command: \"[ -d \\\"src\\\" ] && find src -name '*.d.ts' -delete || echo 'hoi'\",\n    shell: true,\n  });\n\n  await forAllFolders({\n    type: \"operations\",\n    basePath: getPathsWithOperations(),\n    command: \"[ -d \\\"src\\\" ] && find src -name '*.js' -delete || echo 'hoi'\",\n    shell: true,\n  });\n\n  await forAllFolders({\n    type: \"operations\",\n    basePath: getPathsWithOperations(),\n    command:\n      \"[ -d \\\"src\\\" ] && find src -name '*.d.ts.map' -delete || echo 'hoi'\",\n    shell: true,\n  });\n}"
  },
  "allOperationsToMarkdown": {
    "name": "allOperationsToMarkdown",
    "slug": "TsFunction",
    "id": "zzgmmpvwjebpukpaavmvbqby",
    "description": "",
    "operationName": "all",
    "rawText": " async () => {\n  forAllFolders({\n    type: \"operations\",\n    basePath: getPathsWithOperations(),\n    callback: async (folderPath, index) => {\n      const operationName = getLastFolder(folderPath);\n      log(`#${index}: Making new README for ${operationName}`, {\n        type: \"success\",\n      });\n\n      const operationSummary = await getOperationSummary({ operationName });\n      if (!operationSummary) return;\n      await operationToMarkdown({\n        operationSummary,\n        returnType: \"save\",\n      });\n      return;\n    },\n  });\n}"
  },
  "clearAllTsDatabases": {
    "name": "clearAllTsDatabases",
    "slug": "TsFunction",
    "id": "mdftpfsoynsetsjvvwrcdmps",
    "description": "",
    "operationName": "all",
    "rawText": " async () => {\n  forAllFolders({\n    type: \"operations\",\n    basePath: getPathsWithOperations(),\n    callback: async (folderPath, index) => {\n      const operationName = getLastFolder(folderPath);\n      log(\n        `#${index}: Clearing Typescript Indexation Data for ${operationName}`,\n        { type: \"success\" }\n      );\n      await clearTsDatabase(operationName);\n      return;\n    },\n  });\n}"
  },
  "codeAll": {
    "name": "codeAll",
    "slug": "TsFunction",
    "id": "zcmyiyejgxhjjiuiipnpvzwn",
    "description": "opens all files in vscode",
    "operationName": "all",
    "rawText": " async (search: string) => {\n  const filePaths = (\n    await explore({\n      basePath: getProjectRoot(),\n      ignore: [\"node_modules\", \"build\"],\n      exact: true,\n      search,\n      searchLevel: \"fileName\",\n    })\n  ).map((x) => x.path);\n\n  return forAllFiles({ filePaths, command: `code $LOCATION` });\n}"
  },
  "[debug]": {
    "name": "[debug]",
    "slug": "TsVariable",
    "id": "qelphelzcdqkjaxvpklzekyq",
    "description": "",
    "operationName": "all"
  },
  "[folderName, basePath]": {
    "name": "[folderName, basePath]",
    "slug": "TsVariable",
    "id": "ipsiiiwuxyghtxqpwyvqsxvq",
    "description": "",
    "operationName": "all"
  },
  "forAllFiles": {
    "name": "forAllFiles",
    "slug": "TsFunction",
    "id": "ofchfjqttkltesclakskuwhg",
    "description": "executes a command or callback for every file\n\nin commands, $LOCATION is provided as env variable, and command is executed in the dir of the file",
    "operationName": "all",
    "rawText": " async ({\n  filePaths,\n  callback,\n  command,\n}: ForAllFilesConfig): Promise<void> => {\n  const locationPromises = filePaths.map(async (p) => {\n    if (command) {\n      execSync(command, {\n        env: {\n          LOCATION: p,\n        },\n        cwd: getFolder(p),\n        encoding: \"utf8\",\n        stdio: \"inherit\",\n      });\n    }\n\n    if (callback) {\n      callback(p);\n    }\n  });\n\n  await Promise.all(locationPromises);\n\n  console.log(\"done!\");\n}"
  },
  "forAllFolders": {
    "name": "forAllFolders",
    "slug": "TsFunction",
    "id": "hzetgxwufmcjbjgfatacljxl",
    "description": "executes a command or callback in every folder of a certain type. Supports git repos and operations now",
    "operationName": "all",
    "rawText": " async ({\n  type,\n  callback,\n  basePath,\n  onlyRoot,\n  command,\n  shell,\n  fileName,\n  folderName,\n  ignore,\n}: AllInputType): Promise<void> => {\n  let locations =\n    type === \"git\"\n      ? await exploreGitRepoFolders({ basePath })\n      : type === \"operations\"\n      ? await exploreOperationFolders({ basePath })\n      : type === \"folder\" && folderName\n      ? (\n          await explore({\n            basePath,\n            exact: true,\n            doNotExploreChildFolders: onlyRoot,\n            searchLevel: \"folder\",\n            doNotExploreMatch: true,\n            // should be able to ignore stuff\n            ignore,\n            search: folderName,\n          })\n        ).map((x) => x.path)\n      : type === \"file\"\n      ? (\n          await explore({\n            basePath,\n            exact: true,\n            searchLevel: \"fileName\",\n            search: fileName,\n          })\n        ).map((x) => x.path)\n      : [];\n\n  if (locations.length === 0) {\n    // console.log(\"Nothing found\");\n    return;\n  }\n\n  // console.log({ locations: locations.length });\n\n  if (fileName && type !== \"file\") {\n    locations = locations.map((f) => path.join(f, fileName));\n  }\n\n  // console.log({ locations });\n\n  await oneByOne(locations, async (location, index) => {\n    // console.log({ location });\n    if (command) {\n      execSync(command, {\n        env: {\n          LOCATION: location,\n        },\n        cwd: getFolder(location),\n        encoding: \"utf8\",\n        stdio: \"inherit\",\n        // shell,\n      });\n    }\n\n    if (callback) {\n      await callback(location, index);\n    }\n  });\n\n  // console.log(\"done!\");\n}"
  },
  "getAllOperationClassifications": {
    "name": "getAllOperationClassifications",
    "slug": "TsFunction",
    "id": "enuerezzpdwdcfdzzqdxgzth",
    "description": "",
    "operationName": "all",
    "rawText": " async () => {\n  const x = forAllFolders({\n    type: \"operations\",\n    basePath: getPathsWithOperations(),\n    callback: async (folderPath, index) => {\n      const operationName = getLastFolder(folderPath);\n\n      console.log(\n        `${operationName}: ${getOperationClassification(folderPath)}`\n      );\n\n      return;\n    },\n  });\n}"
  },
  "gitShipAllRepos": {
    "name": "gitShipAllRepos",
    "slug": "TsFunction",
    "id": "faogefqrsgyfkjzalgboiqtk",
    "description": "`gitShipAllPackages` Just ships code everywhere to github, wherever there's a git folder and there are changes.",
    "operationName": "all",
    "rawText": " ({\n  basePath,\n  callback,\n  fileName,\n  folderName,\n  shell = true,\n}: Omit<AllInputType, \"command\" | \"type\">) =>\n  forAllFolders({\n    type: \"git\",\n    command: 'git add . && git commit -m \"Improvements\" && git push',\n    basePath,\n    callback,\n    shell,\n    fileName,\n    folderName,\n  })"
  },
  "mdAllOperations": {
    "name": "mdAllOperations",
    "slug": "TsFunction",
    "id": "hkishrwwakuuqadhbqqqttiq",
    "description": "",
    "operationName": "all",
    "rawText": " async (debug?: boolean) => {\n  forAllFolders({\n    type: \"operations\",\n    basePath: getPathsWithOperations(),\n    callback: async (folderPath, index) => {\n      const operationName = getLastFolder(folderPath);\n      log(`#${index}: README for ${operationName}`, { type: \"success\" });\n      await operationToMarkdown({ operationName, mergeDocsInline: true });\n      return;\n    },\n  });\n}"
  },
  "minifyAllOperations": {
    "name": "minifyAllOperations",
    "slug": "TsFunction",
    "id": "vjwbuhuyihpcnzkyxpcoyqib",
    "description": "minify all operations everywhere. optionally:\n- enable the shell\n- specify a basepath (tools by default)",
    "operationName": "all",
    "rawText": " async (\n  config?: Omit<\n    AllInputType,\n    \"type\" | \"command\" | \"callback\" | \"fileName\" | \"folderName\" | \"ignore\"\n  >\n) => {\n  return forAllFolders({\n    type: \"operations\",\n    callback: (folderPath) => {\n      return minifyBuild({ buildFolderPath: path.join(folderPath, \"build\") });\n    },\n    basePath: config?.basePath || getPathsWithOperations(),\n    shell: config?.shell,\n  });\n}"
  },
  "publishAllOperations": {
    "name": "publishAllOperations",
    "slug": "TsFunction",
    "id": "gwhfwaciggrbowgaamkkdjum",
    "description": "Script to publish all packages everywhere (that also runs prepublish). Only src in git, only build in npm.",
    "operationName": "all",
    "rawText": " ({\n  basePath,\n  callback,\n  fileName,\n  folderName,\n  shell = true,\n}: Omit<AllInputType, \"type\" | \"command\">) =>\n  forAllFolders({\n    type: \"operations\",\n    fileName,\n    folderName,\n    callback,\n    basePath,\n    command: \"npm run pub --if-present\",\n    shell,\n  })"
  },
  "removeAllFiles": {
    "name": "removeAllFiles",
    "slug": "TsFunction",
    "id": "thakoomlctfuvmxorpmnjpkq",
    "description": "removes all files that have an exact match of the location (folders not because we use rm without -rf)",
    "operationName": "all",
    "rawText": " async (search: string) => {\n  const filePaths = (\n    await explore({\n      basePath: getRootPath(),\n      ignore: [\"node_modules\", \"build\"],\n      exact: true,\n      search,\n      searchLevel: \"fileName\",\n    })\n  ).map((x) => x.path);\n  console.log({ filePaths });\n  return forAllFiles({\n    filePaths,\n    callback: (filePath) => fs.rmSync(filePath),\n  });\n}"
  },
  "removeAllFoldersCli": {
    "name": "removeAllFoldersCli",
    "slug": "TsFunction",
    "id": "geeygcoktzwbrawixecnvvrh",
    "description": "",
    "operationName": "all",
    "rawText": " async () => {\n  await removeAllFolders({\n    basePath,\n    folderNames: [folderName],\n  });\n\n  console.log(\"DONE\");\n}"
  },
  "removeAllFolders": {
    "name": "removeAllFolders",
    "slug": "TsFunction",
    "id": "nwfyezaqpibbskorfgkptmnv",
    "description": "",
    "operationName": "all",
    "rawText": " async (config: {\n  basePath: string;\n  folderNames: string[];\n  ignore?: string | string[];\n  onlyRoot?: boolean;\n}) => {\n  const { basePath, folderNames, ignore, onlyRoot } = config;\n  const removeFolderPromises = folderNames.map(async (folderName) => {\n    const rmResult = await removeAll({\n      basePath,\n      type: \"folder\",\n      folderName,\n      shell: true,\n      onlyRoot,\n      ignore,\n    });\n\n    return;\n  });\n\n  await Promise.all(removeFolderPromises);\n\n  return true;\n}"
  },
  "removeAll": {
    "name": "removeAll",
    "slug": "TsFunction",
    "id": "isegdiyqmyqqkasjzxbiszzq",
    "description": "removes all xyz for a folder\n\nmake sure to specify which type you want.... folder or file most likely",
    "operationName": "all",
    "rawText": " async ({\n  basePath,\n  fileName,\n  folderName,\n  type,\n  shell,\n  ignore,\n  onlyRoot,\n}: Omit<AllInputType, \"command\">) => {\n  const callback = (folderName: string) =>\n    new Promise<void>(async (resolve) => {\n      try {\n        if (fs.existsSync(folderName)) {\n          await fs.rm(folderName, { recursive: true });\n        }\n        resolve();\n      } catch (e) {\n        console.log(\n          \"Shouldnt happen, but we got a catch at removing an existing folder\"\n        );\n        resolve();\n      }\n    });\n\n  return forAllFolders({\n    basePath,\n    fileName,\n    onlyRoot,\n    folderName,\n    type,\n    callback,\n    shell,\n    ignore,\n  });\n}"
  },
  "renameAll": {
    "name": "renameAll",
    "slug": "TsFunction",
    "id": "rbwhkrypyszzyorwmgofxcwp",
    "description": "renames all files to a new name (optionally a func, based on the old path)",
    "operationName": "all",
    "rawText": " async ({\n  filePaths,\n  newFileName,\n  newFilePath,\n}: {\n  filePaths: string[];\n  /**\n   * if given, all files will be replaces by this filename\n   */\n  newFileName?: string;\n  /**\n   * if given, this will be used to determine the new path\n   */\n  newFilePath?: (oldPath: string) => string;\n}) => {\n  return forAllFiles({\n    filePaths,\n    callback: (filePath) =>\n      new Promise<void>(async (resolve) => {\n        if (fs.existsSync(filePath)) {\n          const newPath = newFileName\n            ? path.join(getFolder(filePath), newFileName)\n            : newFilePath?.(filePath);\n\n          if (!newPath) {\n            return log(\"couldn't determine new path\", { type: \"error\" });\n          }\n          console.log(`renamed ${filePath} to ${newPath}`);\n          await fs.rename(filePath, newPath);\n        }\n        resolve();\n      }),\n  });\n}"
  },
  "runScriptEverywhere": {
    "name": "runScriptEverywhere",
    "slug": "TsFunction",
    "id": "pgwqormeaexdmnyknrxpfhya",
    "description": "runs a package script in all tools operations\n\nNB: uses npm insead of yarn, but for scripts this shouldn't matter",
    "operationName": "all",
    "rawText": " async (\n  script: string,\n  startIndex?: number\n) => {\n  forAllFolders({\n    type: \"operations\",\n    basePath: getPathsWithOperations(),\n    callback: (folderPath, index) => {\n      if (startIndex && startIndex > index) {\n        console.log(`skipping ${index}`);\n        return;\n      }\n\n      try {\n        console.log(`now: ${index} (${folderPath})`);\n        execSync(`npm run ${script} --if-present`, {\n          encoding: \"utf8\",\n          cwd: folderPath,\n        });\n      } catch (e: any) {\n        const error: {\n          status: number;\n          signal: any;\n          output: (string | null)[];\n          pid: number;\n          stdout: string;\n          stderr: string;\n        } = e;\n        console.log(error?.stdout);\n      }\n    },\n  });\n}"
  },
  "[script, startIndex]": {
    "name": "[script, startIndex]",
    "slug": "TsVariable",
    "id": "biofumzlepyhnbuyqkzwkiso",
    "description": "",
    "operationName": "all"
  },
  "[search]": {
    "name": "[search]",
    "slug": "TsVariable",
    "id": "jgndgpwtdhpjgbhjweaepgpz",
    "description": "",
    "operationName": "all"
  },
  "setScriptEverywhere": {
    "name": "setScriptEverywhere",
    "slug": "TsFunction",
    "id": "dqiqyxdzltvxkdqcvachblrh",
    "description": "set package.json script to another value in all operations in tools folder",
    "operationName": "all",
    "rawText": " async (script: string, value: string) => {\n  forAllFolders({\n    basePath: getPathsWithOperations(),\n    type: \"operations\",\n    shell: true,\n    callback: (folderPath, index) => {\n      setJsonKey({\n        jsonPath: path.join(folderPath, \"package.json\"),\n        keyLocation: `scripts.${script}`,\n        value,\n      });\n    },\n  });\n}"
  },
  "[type, command, fileName, basePath, folderName, shellString]": {
    "name": "[type, command, fileName, basePath, folderName, shellString]",
    "slug": "TsVariable",
    "id": "vrrcvoxduewsnmkfumnekfmb",
    "description": "",
    "operationName": "all"
  },
  "makeFileType": {
    "name": "makeFileType",
    "slug": "TsFunction",
    "id": "gjuumjwmkirwmjapohohpmhc",
    "description": "",
    "operationName": "make-file-type",
    "rawText": " async (\n  filePath: string\n): Promise<FileType | undefined> => {\n  const exists = fs.existsSync(filePath);\n  const stats = exists ? await fs.stat(filePath) : null;\n  const mtime_ms = stats?.mtimeMs || 0;\n\n  const operationBasePath = findOperationBasePath(filePath);\n  if (!operationBasePath) return;\n  const operationSrcPath = path.join(operationBasePath, \"src\");\n  const relativePath = filePath.slice(operationSrcPath.length);\n  const name = relativePath;\n  // should not only be name, but also the relative path from src/*\n  // const parsedPath = path.parse(filePath);\n  //const name = `${parsedPath.name}${parsedPath.ext}`;\n\n  const size = stats?.size || 0;\n  const type = \"f\";\n  const file: FileType = { exists, mtime_ms, name, size, type };\n  return file;\n}"
  },
  "exploreOperation": {
    "name": "exploreOperation",
    "slug": "TsFunction",
    "id": "mflmfkglrvoxiflwwxmsusjm",
    "description": "for every package.json it finds, it explores the root, src, and docs.\n- in src, index is ignored\n- in docs, only md is found\n- in the root, only md is found\n- for every file in src, it shows and finds all functions, interfaces and variables, through the indexation from it",
    "operationName": "explore-project",
    "rawText": " async (operationBasePath: string) => {\n  const srcPath = path.join(operationBasePath, \"src\");\n  const docsPath = path.join(operationBasePath, \"docs\");\n\n  const rootExploreResults = await explore({\n    basePath: operationBasePath,\n    ignore: \".DS_Store\",\n    doNotExploreChildFolders: true,\n    extension: [\"md\", \"mdx\"],\n  });\n\n  const docsExploreResults = await explore({\n    basePath: docsPath,\n    ignore: \".DS_Store\",\n    extension: [\"md\", \"mdx\"],\n    includeFoldersWithResults: true,\n  });\n\n  const docsExploreResultsWithBasePath =\n    docsExploreResults.length > 0\n      ? docsExploreResults.concat([{ path: docsPath, isFolder: true }])\n      : [];\n\n  const srcExploreResults = (\n    await explore({\n      basePath: srcPath,\n      ignore: \".DS_Store\",\n      extension: [\"ts\", \"tsx\"],\n      includeFoldersWithResults: true,\n    })\n  )\n    // NB: filter out index files, they're not interesting for this usecase\n    .filter((x) => !x.path.includes(\"/src/index.ts\"));\n\n  const srcExploreResultsWithBasePath =\n    srcExploreResults.length > 0\n      ? srcExploreResults.concat([{ path: srcPath, isFolder: true }])\n      : [];\n\n  return rootExploreResults\n    .concat(docsExploreResultsWithBasePath)\n    .concat(srcExploreResultsWithBasePath);\n}"
  },
  "exploreProject": {
    "name": "exploreProject",
    "slug": "TsFunction",
    "id": "xvyaoyzzsqajnvgjebktbcoy",
    "description": "TODO: still needs to be cleaned up. It's a huge function now with many useful components. Split it up!\n\n- explores all files and folders until it finds a package.json.\n\nall items in the explore tree are clickable in the ui, and lead to different pages\n-  a folder leads to a summary of what the folder holds\n-  a operation leads to a summary of the operation\n-  a ts file leads to all functions, variables, and interfaces in that file\n-  a function, variable, or interface leads to specific pages for those things. the data, if available, is attached to the interfaces.\n- a md file leads to the editing user interface (with context) of that file\n- a json file leads to a CRUD for it...\n\n## Performance\nIn the end the data it generates should stay up to date, so it's important this exploration happens fast enough. The data involved is simply walking the filesystem once (a small subset of it) and opening some index files (fun)\n\n## Ideas for later\nLATER: some more things that would be useful:\n\n- watching all files that are also explored for changes using some watcher\n- if something changes, recalculating that part and pushing it to the UI, making the thing going over the line small so it'll be super fast, even over slow internet.\n\nhowever, this is premature optimisation. on my m1, locally, it's probably fine to just recalculate every second ^^ and send a couple megabytes over the line.",
    "operationName": "explore-project",
    "rawText": " async (config?: {\n  bundleId?: string;\n}): Promise<FolderExploration[] | undefined> => {\n  const bundleId = config?.bundleId;\n  let bundleSummary: BundleSummary | undefined = undefined;\n\n  if (bundleId) {\n    const bundle = (await db.get(\"BundleConfig\")).find(\n      (x) => x.id === bundleId\n    );\n\n    if (bundle) {\n      bundleSummary = getBundleSummary(bundle);\n    }\n  }\n\n  const operationPaths = getPathsWithOperations();\n  const textPath = getRootPath(\"text\");\n  const projectRoot = getProjectRoot();\n  if (!operationPaths || !textPath || !projectRoot) return;\n  /**\n   * STEP 1: finds all folders and files unto (and including) the operation level\n   */\n  const foldersWithMarkdownAndOperationsExplore = await explore({\n    basePath: operationPaths.concat(textPath),\n    includeFoldersWithResults: true,\n    ignore: [\n      \"node_modules\",\n      \".git\",\n      databaseFolderName,\n      \".gitignore\",\n      \".DS_Store\",\n    ],\n    // extension: [\"md\",\"mdx\"]\n    cancelRecursionOn: pathArrayIsOperation,\n  });\n\n  /**\n   * STEP 2: explore all paths to include the files of operations\n   */\n  const exploreArrayPromises = foldersWithMarkdownAndOperationsExplore.map(\n    async (exploreResult) => {\n      // NB: Here I am looking if the operationName is in the bundle summary. If there's a bundle summary and this is not the case, the operation should not be explored\n      const operationName = getLastFolder(exploreResult.path);\n      const shouldIncludeOperation = !bundleSummary\n        ? true\n        : bundleSummary.packageNames.includes(operationName);\n\n      const exploreResultArray = exploreResult.isCancelRecursionResult\n        ? shouldIncludeOperation\n          ? await exploreOperation(exploreResult.path)\n          : []\n        : [exploreResult];\n\n      return exploreResultArray;\n    }\n  );\n  const resultPaths = (await Promise.all(exploreArrayPromises))\n    .flat()\n    .map((x) => x.path);\n\n  /**\n   * STEP 3: get all data of all files\n   */\n  const indexData = {\n    functions: await db.get(\"TsFunction\"),\n    variables: await db.get(\"TsVariable\"),\n    interfaces: await db.get(\"TsInterface\"),\n    // comments: await db.get(\"TsComment\"),\n    // \"build-errors\": await db.get(\"TsBuildError\"),\n  };\n\n  const operationFolders: string[] = await exploreOperationFolders({\n    basePath: getPathsWithOperations(),\n  });\n\n  const fullIndexation = resultPaths\n    .map((absolutePath): FolderExploration | null => {\n      const relativeProjectPath = absolutePath.substring(projectRoot.length);\n      // extension like .ts or empty string if there's no extensnion (also for folders)\n      const name = path.parse(absolutePath).name;\n      const type = getExplorationType(absolutePath, operationFolders);\n\n      // Not typescript\n      if (type !== \"typescript\") {\n        // name of folder, operation, operationFolder, or md file\n        // NB: shouldn't happen\n        if (!type) return null;\n        // NB: we are filling in the children in a later step\n        return { name, relativeProjectPath, type, children: undefined };\n      }\n\n      // Typescript\n\n      const typescriptFileChildren = (\n        Object.keys(indexData) as (keyof typeof indexData)[]\n      )\n        .map((indexInstanceName): FolderExploration[] => {\n          const all = indexData[indexInstanceName];\n          const indexNames = getInstanceNames(all, relativeProjectPath);\n          const type =\n            indexInstanceName === \"functions\"\n              ? \"function\"\n              : indexInstanceName === \"interfaces\"\n              ? \"interface\"\n              : \"variable\";\n\n          const instanceChildren: FolderExploration[] = indexNames.map(\n            (name) => ({ name, relativeProjectPath, type })\n          );\n\n          return instanceChildren;\n        })\n        .flat();\n\n      return {\n        name,\n        relativeProjectPath,\n        type,\n        children: typescriptFileChildren,\n      };\n    })\n    .flat()\n    .filter(notEmpty);\n\n  //\n  const oppositeSortedFullIndexation = fullIndexation\n    // sort alphabetically on relativeProjectPath\n    .sort((a, b) => {\n      if (a.relativeProjectPath < b.relativeProjectPath) return -1;\n      if (a.relativeProjectPath > b.relativeProjectPath) return 1;\n      return 0;\n    })\n    // reverse the result so it's in opposite alphabetical order\n    .reverse();\n\n  // NB: copy because we want to test stuff first\n  const copyForNested = [...oppositeSortedFullIndexation];\n  const nestedExploration = copyForNested\n    .reduce((all, folderExploration, currentIndex) => {\n      const parsedPath = path.parse(\n        path.join(projectRoot, folderExploration.relativeProjectPath)\n      );\n\n      /** the parent folder of a folder, or the folder of a path */\n      const baseFolder =\n        parsedPath.base.length > 0\n          ? parsedPath.dir\n          : path.join(parsedPath.dir, \"..\");\n      const relativeBaseFolder = baseFolder.substring(projectRoot.length);\n\n      // console.log({\n      //   relativeBaseFolder,\n      //   relativeProjectPath: folderExploration.relativeProjectPath,\n      // });\n      const baseIndex = all.findIndex(\n        (x) => x?.relativeProjectPath === relativeBaseFolder\n      );\n\n      // there is no parent found for this one\n      if (baseIndex === -1) {\n        return all;\n      }\n\n      // we found a parent on all[baseIndex]. Lets put folderExploration in the children of that one, and remove it from the full indexation\n\n      all[baseIndex] = {\n        ...all[baseIndex],\n        children: all[baseIndex].children\n          ? all[baseIndex].children?.concat(folderExploration)\n          : [folderExploration],\n      };\n\n      delete all[currentIndex];\n\n      return all;\n    }, copyForNested as FolderExploration[])\n    // the deleted keys can now be removed\n    .filter(notEmpty);\n\n  // console.dir(\n  //   oppositeSortedFullIndexation.map((x) => x.relativeProjectPath),\n  //   { depth: 999, maxArrayLength: 9999 }\n  // );\n\n  return nestedExploration;\n}"
  },
  "getExplorationType": {
    "name": "getExplorationType",
    "slug": "TsFunction",
    "id": "yuzibjtdxgfzubozlxnztqrz",
    "description": "gets the exploration type from an absolute type",
    "operationName": "explore-project",
    "rawText": " (\n  absolutePath: string,\n  operationFolders: string[]\n): FolderExploration[\"type\"] | undefined => {\n  const parsedPath = path.parse(absolutePath);\n  if ([\".ts\", \".tsx\"].includes(parsedPath.ext)) {\n    return \"typescript\";\n  }\n  if ([\".md\", \".mdx\"].includes(parsedPath.ext)) {\n    return \"markdown\";\n  }\n\n  if (parsedPath.ext.length > 0) {\n    // NB: based on where this function is used, this should never happen\n    return undefined;\n  }\n\n  if (operationFolders.includes(absolutePath)) {\n    return \"operation\";\n  }\n  if (operationFolders.find((x) => absolutePath.startsWith(x))) {\n    return \"operationFolder\";\n  }\n  return \"folder\";\n}"
  },
  "getFileWithExtension": {
    "name": "getFileWithExtension",
    "slug": "TsFunction",
    "id": "ghssvswqocdfxduoneatczyl",
    "description": "",
    "operationName": "explore-project",
    "rawText": " (absolutePath: string) => {\n  return path.parse(absolutePath).base;\n}"
  },
  "getFolderExplorationDetails": {
    "name": "getFolderExplorationDetails",
    "slug": "TsFunction",
    "id": "lqvraazbyfawneujgrakgrph",
    "description": "",
    "operationName": "explore-project",
    "rawText": " async (\n  config: {\n    /**relative project path*/\n    path: string;\n    type: FolderExploration[\"type\"];\n    name: string;\n    sort?: string;\n    /**\n     * null gives all of them, undefined gives none\n     */\n    typeIndexType?: keyof IndexModels | null;\n  } & IndexFilter\n): Promise<ExplorationDetails> => {\n  const {\n    name,\n    path,\n    type,\n    hasCommentTypes,\n    interfaceIsDbModel,\n    sort,\n    typeIndexType,\n  } = config;\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    console.log(\"getFolderExplorationDetails: Projectroot not found\");\n    process.exit(1);\n  }\n  const absolutePath = nodePath.join(projectRoot, path);\n  const operationBasePath = findOperationBasePath(absolutePath);\n\n  const operationFolderName = operationBasePath\n    ? getLastFolder(operationBasePath)\n    : undefined;\n\n  const folderExplorationInterface = (\n    await db.get(\"TsInterface\", {\n      operationName: \"code-types\",\n    })\n  ).filter(\n    (x) => x.operationRelativeTypescriptFilePath === \"src/FolderExploration.ts\"\n  );\n\n  const isFileOrFolderType = [\n    \"folder\",\n    \"operation\",\n    \"operationFolder\",\n    \"typescript\",\n  ].includes(type);\n\n  const pathMetaData = isFileOrFolderType\n    ? await calculatePathMetaData(absolutePath)\n    : undefined;\n\n  const needsFilePath =\n    !!operationFolderName && absolutePath !== operationBasePath;\n\n  // console.log({\n  //   needsFilePath,\n  //   operationFolderName,\n  //   absolutePath,\n  //   operationBasePath,\n  //   typeIndexType,\n  //   isFileOrFolderType,\n  // });\n  const typescriptIndex =\n    isFileOrFolderType && typeIndexType !== undefined\n      ? await getFolderTypescriptIndex({\n          filePath: needsFilePath ? absolutePath : undefined,\n          basePath: !needsFilePath ? absolutePath : undefined,\n          filter: { hasCommentTypes, interfaceIsDbModel },\n          sort,\n          type: typeIndexType,\n        })\n      : null;\n\n  //   const srcPath = nodePath.join(operationBasePath, \"src\");\n  //   const operationRelativeTypescriptFilePath = absolutePath.substring(srcPath.length + 1);\n\n  if (type === \"folder\") {\n    return {\n      index: folderExplorationInterface,\n      ...typescriptIndex,\n      pathMetaData,\n    };\n  } else if (type === \"operationFolder\") {\n    return {\n      index: folderExplorationInterface,\n      ...typescriptIndex,\n      pathMetaData,\n    };\n  } else if (type === \"operation\" && operationBasePath) {\n    return {\n      index: folderExplorationInterface,\n      ...typescriptIndex,\n      pathMetaData,\n    };\n  } else if (type === \"markdown\") {\n    // markdown parse\n    const markdownPath = nodePath.join(projectRoot, path);\n    const markdown = await readMarkdownFile(markdownPath);\n    return {\n      index: folderExplorationInterface,\n      markdown: markdown || undefined,\n      success: !!markdown,\n      response: markdown ? undefined : \"reading markdown file failed\",\n    };\n  } else if (type === \"typescript\") {\n    const details = typescriptIndex || {\n      success: false,\n      response: \"reading typescript file failed\",\n    };\n\n    return { ...details, index: folderExplorationInterface, pathMetaData };\n    // all functions, interfaces, variables, lint-errors, build-errors, comments, file meta data (should become PathMetaData, better refactor immediately)\n  } else if (type === \"function\") {\n    // one function with name [name]\n    // TODO: figure out how to do with specific file\n    const tsFunction = (\n      await db.get(\"TsFunction\", { operationName: operationFolderName })\n    ).find((x) => x.name === name);\n    return {\n      tsFunctions: tsFunction ? [tsFunction] : undefined,\n      index: folderExplorationInterface,\n    };\n  } else if (type === \"interface\") {\n    // one interface with name [name]\n    const tsInterface = (\n      await db.get(\"TsInterface\", { operationName: operationFolderName })\n    ).find((x) => x.name === name);\n    return {\n      tsInterfaces: tsInterface ? [tsInterface] : undefined,\n      index: folderExplorationInterface,\n    };\n    // if it's a db-model, also the data that is found...? or maybe this should just be a separate endpoint and page where it's linke to\n  } else if (type === \"variable\") {\n    // one variable with name [name]\n    const tsVariable = (\n      await db.get(\"TsVariable\", { operationName: operationFolderName })\n    ).find((x) => x.name === name);\n    return {\n      tsVariables: tsVariable ? [tsVariable] : undefined,\n      index: folderExplorationInterface,\n    };\n  }\n\n  // Should never happen if all ifs  return....\n  return {\n    index: folderExplorationInterface,\n    success: false,\n    response: `getFolderExplorationDetails: Couldn't understand your input: ${JSON.stringify(\n      {\n        path,\n        type,\n        name,\n      }\n    )}`,\n  };\n}"
  },
  "getFrontmattersMappedObject": {
    "name": "getFrontmattersMappedObject",
    "slug": "TsFunction",
    "id": "quamydlkkjzwzcmuizlkaqhy",
    "description": "",
    "operationName": "explore-project",
    "rawText": " async (\n  projectRoot: string,\n  markdownPaths?: string[]\n) => {\n  const frontmatterPromises = markdownPaths?.map(async (markdownPath) => {\n    const absoluteFilePath = path.join(projectRoot, markdownPath);\n    const frontmatter = (await readMarkdownFile(absoluteFilePath))?.parameters;\n    return { [markdownPath]: frontmatter };\n  });\n  const frontmattersArray = frontmatterPromises\n    ? await Promise.all(frontmatterPromises)\n    : [];\n  const frontmattersMappedObject = mergeObjectsArray(frontmattersArray);\n\n  return frontmattersMappedObject;\n}"
  },
  "getInstanceNames": {
    "name": "getInstanceNames",
    "slug": "TsFunction",
    "id": "ngvnzvoaduecxsdnifdsksgy",
    "description": "returns the paths of instances in a file, like functions, variables or interfaces",
    "operationName": "explore-project",
    "rawText": " (\n  array: any[],\n  // NB: I tried with  <T extends TsIndexModelType> but didn't work with a map over an object... strange...\n  relativePathFromProjectRoot: string\n): string[] => {\n  const instances = array.filter(\n    hasSameProjectPath(relativePathFromProjectRoot)\n  );\n\n  const instancePaths = instances.map((x) => x.name);\n  return instancePaths;\n}"
  },
  "getProjectRelativePaths": {
    "name": "getProjectRelativePaths",
    "slug": "TsFunction",
    "id": "ndekbabjruklnfokvvzxgfrd",
    "description": "get file paths within your project",
    "operationName": "explore-project",
    "rawText": " async (\n  // functionContext: FunctionContext,\n  config?: {\n    /**\n     * Optionally filter the results to only:\n     *\n     * - todo: all todos in your project operations\n     * - postable: all your postables in your database\n     *\n     * by default, scans all relevant files...\n     */\n    type?: RelativePathType;\n    earliestUpdatedAt?: number;\n    /**\n     * Not implemented\n     */\n    filterDraft?: boolean;\n    /**\n     * Not implemented\n     */\n    filterPrivate?: boolean;\n    filterGenerated?: boolean;\n    sort?: \"recent\";\n  }\n): Promise<string[] | undefined> => {\n  const {\n    earliestUpdatedAt,\n    filterDraft,\n    filterGenerated,\n    filterPrivate,\n    type,\n    sort,\n  } = destructureOptionalObject(config);\n\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n  const operationsPath = getRootPath(\"operations\");\n  if (!operationsPath) return;\n  const databasePath = getRootPath(databaseFolderName);\n  if (!databasePath) return;\n  const textPath = getRootPath(\"text\");\n  if (!textPath) return;\n\n  const basePath =\n    type === \"todo\"\n      ? await findAllTodoFolderPaths(operationsPath)\n      : [operationsPath, textPath];\n\n  const shouldFilterRecency = earliestUpdatedAt !== undefined;\n  /*\n  everything from projectRoot, except for: `db`, `node_modules`, `build`\n  */\n\n  const results = await explore({\n    basePath,\n    includeStats: shouldFilterRecency || sort === \"recent\",\n    extension: [\"md\", \"ts\", \"tsx\"],\n    ignore: [databaseFolderName, ...generatedFolders],\n  });\n\n  const filtered = results.filter((result) => {\n    if (!shouldFilterRecency) return true;\n\n    const updatedAt = result.stats?.updatedAt;\n\n    // shouldn't happen\n    if (!updatedAt) return false;\n\n    const isRecentEnough = earliestUpdatedAt < updatedAt;\n\n    return isRecentEnough;\n  });\n\n  const sorted =\n    sort === \"recent\"\n      ? filtered.sort((a, b) => {\n          if (a.stats!.createdAt < b.stats!.createdAt) {\n            return 1;\n          }\n\n          return -1;\n        })\n      : filtered;\n\n  const projectRelativePaths = sorted\n    .map((result) => result.path)\n    .map((absolutePath) => makeRelative(absolutePath, projectRoot));\n  return projectRelativePaths;\n}"
  },
  "getTodoPages": {
    "name": "getTodoPages",
    "slug": "TsFunction",
    "id": "wlwqwjivpoqkejsanjhyqysn",
    "description": "`getTodoPages(): WebPage[]` function:\n\n- use getProjectRelativePaths, map the result to a queryPath + file\n- [operation-name]/[todo-relative-file-id] for operations\n- [folder-name]/[todo-relative-file-id] for todos within folders",
    "operationName": "explore-project",
    "rawText": " async (\n  config?: TodoPagesConfig\n): Promise<{ nested: NestedWebPage[]; flat: (WriterWebPage | WebPage)[] }> => {\n  // console.log({ config });\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return { nested: [], flat: [] };\n\n  //needed for matching persons but also for just showing that it has offers\n  const todoOffers = await db.get(\"TodoOffer\");\n  const todoPaths = await getTodoPaths(config);\n\n  const todoPages: WriterWebPage[] =\n    todoPaths?.map((projectRelativeFilePath) => {\n      const [before, after] = projectRelativeFilePath.split(\"/todo/\");\n      const lastFolderBeforeTodo = getLastFolder(before);\n      const todoRelativeFileId = withoutExtension(after);\n      const fileName = getLastFolder(todoRelativeFileId);\n      /**\n       * Idea: parsing the file for amount of items with and without checkmark, showing the % done and (x/y)\n       */\n      const menuTitle = humanCase(fileName);\n\n      const hasTodoOffers = !!todoOffers.find(\n        (x) => x.todoFileId === projectRelativeFilePath\n      );\n      /**\n       * showing an emoji the status of the todo-offers\n       */\n      const menuTitleAugmentation = hasTodoOffers ? \"ðŸ”¥\" : undefined;\n\n      /**\n       * Idea: showing a summary, more about the progress and owner(s), and anything you just quickly wanna see\n       */\n      const menuTitleTooltip =\n        \"Tooltip example\\n\\nShould render markdown\\n\\n**Say,this is great, no?**\";\n\n      const page: WriterWebPage = {\n        pageData: {\n          projectRelativeFilePath,\n        },\n        queryPath: `${lastFolderBeforeTodo}/${todoRelativeFileId}`,\n        menuTitle,\n        menuTitleAugmentation,\n        menuTitleTooltip,\n        isMenuHidden: false,\n      };\n\n      return page;\n    }) || [];\n\n  const otherPages: WebPage<unknown>[] = [\n    {\n      queryPath: \"stats\",\n      menuTitle: \"Statistics\",\n      menuTitleTooltip: \"Some stats about cool stuff\",\n      pageData: undefined,\n    },\n\n    {\n      queryPath: \"SelfSprintReview\",\n      menuTitle: \"Sprint review\",\n      menuTitleTooltip: \"Let's do this every friday, 3PM CET\",\n      pageData: undefined,\n    },\n    {\n      queryPath: \"TodoOffer\",\n      isMenuHidden: true,\n      pageData: undefined,\n    },\n    {\n      queryPath: \"upsert/TodoOffer\",\n      isMenuHidden: true,\n      pageData: undefined,\n    },\n    {\n      queryPath: \"upsert/SelfSprintReview\",\n      isMenuHidden: true,\n      pageData: undefined,\n    },\n  ];\n\n  const flat = otherPages.concat(todoPages) as (WriterWebPage | WebPage)[];\n\n  // nestifyQueryPathObjectRecursive(flatWithoutPageData);\n\n  return getMenuPagesObject(flat);\n}"
  },
  "getTodoPaths": {
    "name": "getTodoPaths",
    "slug": "TsFunction",
    "id": "fsrfmlleiannroybijbdvcwx",
    "description": "",
    "operationName": "explore-project",
    "rawText": " async (\n  config?: TodoPagesConfig\n): Promise<string[]> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return [];\n\n  const { recency, categoryStack, personId, priority, subExtension, sort } =\n    destructureOptionalObject(config);\n\n  /**\n   * TODO:\n   */\n  const todayTimestamp = 0;\n  const thisWeekTimestamp = 0;\n  const earliestUpdatedAt =\n    recency === \"24-hours\"\n      ? Date.now() - 86400000\n      : recency === \"7-days\"\n      ? Date.now() - 86400000 * 7\n      : recency === \"today\"\n      ? todayTimestamp\n      : recency === \"this-week\"\n      ? thisWeekTimestamp\n      : undefined;\n\n  let todoPaths = await getProjectRelativePaths({\n    type: \"todo\",\n    filterPrivate: true,\n    filterDraft: true,\n    filterGenerated: true,\n    earliestUpdatedAt,\n    sort,\n  });\n\n  // filter on categoryStack, if it's there. Filter BEFORE getting the markdown frontmatter, that's slow...\n\n  if (categoryStack && categoryStack.length === 0) {\n    todoPaths = todoPaths?.filter((todoPath) => {\n      const lastIndexTodoFolder = todoPath.lastIndexOf(\"todo/\");\n\n      if (lastIndexTodoFolder === -1) {\n        return false;\n      }\n\n      const todoRelativeFileId = todoPath.slice(\n        lastIndexTodoFolder + \"todo/\".length\n      );\n\n      const depth = todoRelativeFileId.split(\"/\").length - 1;\n\n      return depth === 0;\n    });\n  }\n  if (categoryStack && categoryStack.length > 0) {\n    todoPaths = todoPaths?.filter((todoPath) => {\n      const lastIndexTodoFolder = todoPath.lastIndexOf(\"todo/\");\n\n      if (lastIndexTodoFolder === -1) {\n        return false;\n      }\n\n      const todoRelativeFileId = todoPath.slice(\n        lastIndexTodoFolder + \"todo/\".length\n      );\n\n      // console.log({ todoRelativeFileId });\n\n      const categoryStackPrefix = categoryStack.join(\"/\") + \"/\";\n\n      if (!todoRelativeFileId.startsWith(categoryStackPrefix)) {\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  if (subExtension) {\n    todoPaths = todoPaths?.filter((filePath) => {\n      const filename = path.parse(filePath).base;\n      const thisSubExtension = getSubExtension(filename);\n\n      if (subExtension !== thisSubExtension) {\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  if (personId || priority) {\n    // ONLY get the mapped object of all frontmatters if it's really needed. It may take a little longer... Filter AFTER applying filter for recency and categoryStack.\n    const frontmatterObject = await getFrontmattersMappedObject(\n      projectRoot,\n      todoPaths\n    );\n\n    if (priority) {\n      todoPaths = todoPaths?.filter((todoPath) => {\n        const frontmatterPriority = frontmatterObject[todoPath]?.priority;\n\n        const matchPriority = priority === String(frontmatterPriority);\n\n        return matchPriority;\n      });\n    }\n\n    if (personId) {\n      todoPaths = todoPaths?.filter((todoPath) => {\n        const frontmatterOwner_personId =\n          frontmatterObject[todoPath]?.owner_personId;\n\n        const matchPerson = personId === String(frontmatterOwner_personId);\n\n        return matchPerson;\n      });\n    }\n  }\n\n  return todoPaths || [];\n}"
  },
  "hasSameProjectPath": {
    "name": "hasSameProjectPath",
    "slug": "TsFunction",
    "id": "svxwdnldqqafmnppunmigbba",
    "description": "function that returns a filter function that can check if some object (that extends an TsIndexModelType) has the same relative file path from the project root",
    "operationName": "explore-project",
    "rawText": "\n  (projectRelativePath: string) =>\n  <T extends TsIndexModelType>(x: T) => {\n    const isSame = x.projectRelativePath === projectRelativePath;\n    return isSame;\n  }"
  },
  "main": {
    "name": "main",
    "slug": "TsFunction",
    "id": "eqkoahvmbromdlgajrlgnzia",
    "description": "1) take assets/images.json\n\n2) for every item in the array, upload all items to cloudinary with their api under the name id-index.jpg",
    "operationName": "parse-images",
    "rawText": " async () => {\n  cloudinary.v2.config({\n    // can be found in settings -> security\n    api_key: \"335356435457763\",\n    api_secret: \"5oN6qMl-ZnwnQvoMo5H8hW1Ok3I\",\n    //  can be found in settings -> account\n    cloud_name: \"dkja7uwop\",\n  });\n\n  const newFile = await oneByOne(clients, async (client, index) => {\n    const {\n      objectId,\n      imageAbsolutePaths,\n      results: clientResults,\n    } = client as Client;\n\n    if (clientResults?.length === imageAbsolutePaths.length) {\n      console.log(`${index + 1} already done`);\n      return;\n    }\n\n    console.log(`${index + 1} out of ${clients.length}`);\n\n    const results = (\n      await Promise.all(\n        imageAbsolutePaths.map(async (absolutePath, index) => {\n          const extension = getExtension(absolutePath).toLowerCase();\n\n          const realExtension = extension === \"jpg\" ? \"jpeg\" : extension;\n\n          const name = `${objectId}-${index + 1}.${realExtension}`;\n\n          /**\n           * NB: Need to run this in terminal\n           * `export CLOUDINARY_URL=cloudinary://API_KEY:API_SECRET@CLOUD_NAME`\n           */\n          const uploadResult: UploadResult = await cloudinary.v2.uploader\n            .upload(absolutePath, {\n              filename_override: name,\n              folder: \"v2\",\n            })\n            .then((result) => {\n              const imageObject = {\n                url: result.secure_url,\n                id: result.public_id,\n                isSuccessful: true,\n                absolutePath,\n              };\n\n              // console.log({ imageObject });\n              return imageObject;\n            })\n            .catch((e) => {\n              console.log(client.objectId, absolutePath, e);\n              return {\n                isSuccessful: false,\n                absolutePath,\n                url: undefined,\n                id: undefined,\n              };\n            });\n\n          if (!uploadResult) return;\n\n          return uploadResult;\n\n          // upload to cloudinary\n        })\n      )\n    ).filter(notEmpty);\n\n    const operationBasePath = findOperationBasePath(__filename);\n    if (!operationBasePath) return;\n    const clientsFile = path.join(operationBasePath, \"assets\", \"clients.json\");\n    const clientsNow = await readJsonFile<any>(clientsFile);\n    const newClient = { ...client, results };\n    const newClients = clientsNow.map((x: any) =>\n      x.objectId === client.objectId ? newClient : x\n    );\n    await writeToAssets(__filename, newClients, \"clients.json\");\n\n    return { ...client, results };\n  });\n\n  console.log(\"DONE\", newFile);\n}"
  },
  "getAllOperationSourcePaths": {
    "name": "getAllOperationSourcePaths",
    "slug": "TsFunction",
    "id": "zlxntnkppfxoooneffpjvvdl",
    "description": "returns src folder paths of all operations",
    "operationName": "get-all-operation-source-paths",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n}) => {\n  const manualProjectRoot = config?.manualProjectRoot;\n  const operationFolders: string[] = await exploreOperationFolders({\n    basePath: getPathsWithOperations({ manualProjectRoot }),\n  });\n\n  const operationSourceFolders = operationFolders.reduce(\n    (allSources, operationPath) => {\n      const srcPath = path.join(operationPath, \"src\");\n\n      if (!fs.existsSync(srcPath)) return allSources;\n\n      return allSources.concat(\n        [srcPath]\n        // TODO: this function would be great, but the inputs in tsconfig contain glob patterns and that doesn't work.\n        // getPackageSourcePaths({ packageFolder: operationPath })\n      );\n    },\n    [] as string[]\n  );\n\n  return operationSourceFolders;\n}"
  },
  "findFolderWhereMatch": {
    "name": "findFolderWhereMatch",
    "slug": "TsFunction",
    "id": "okfxijmegvtudkmjlircqeol",
    "description": "recursive. goes up a folder until it finds a package.json",
    "operationName": "get-path",
    "rawText": " <T>(\n  fullSourcePath: string,\n  /**\n   * match must be truthy in order to match, and falsy if it's not a match\n   *\n   * the result of the matchFunction will be returned at the end of the recursion\n   */\n  matchFunction: (folderPath: string) => T\n): undefined | { folderPath: string; matchResult: T } => {\n  if (fullSourcePath === undefined) {\n    console.log(\"WTF\");\n    process.exit(1);\n  }\n  // Basecase to make sure that the provided sourcepath is valid\n  if (!fs.existsSync(fullSourcePath)) {\n    log(`full source path invalid ${fullSourcePath}`, { type: \"debug\" });\n    return;\n  }\n\n  // Basecase to make sure that it doesn't go on infinitely, even if package.json doesn't exist anywhere\n  if (fullSourcePath === \"/\") {\n    log(`folder was not found, went all the way to root '/'`, {\n      type: \"debug\",\n    });\n    return;\n  }\n\n  const matchResult = matchFunction(fullSourcePath);\n\n  if (matchResult) return { folderPath: fullSourcePath, matchResult };\n\n  return findFolderWhereMatch(path.join(fullSourcePath, \"..\"), matchFunction);\n}"
  },
  "findOperationBasePathWithClassification": {
    "name": "findOperationBasePathWithClassification",
    "slug": "TsFunction",
    "id": "logzieeejcyjdrapkpzxtovc",
    "description": "recursive. goes up until it finds a folder that's an operation\n\nbecause it had to read the package.json anyway, it's returning the operation classification as well",
    "operationName": "get-path",
    "rawText": " (\n  startPath: string\n):\n  | { folderPath: string; classification: OperationClassification }\n  | undefined => {\n  // returns if `getOperationClassification` does not return `undefined`\n  const result = findFolderWhereMatch(startPath, getOperationClassification);\n\n  return result\n    ? { folderPath: result.folderPath, classification: result.matchResult! }\n    : undefined;\n}"
  },
  "findOperationBasePath": {
    "name": "findOperationBasePath",
    "slug": "TsFunction",
    "id": "auvdienmcdhvvbihfvjhxqvz",
    "description": "",
    "operationName": "get-path",
    "rawText": " (\n  startPath: string\n): string | undefined => {\n  return findOperationBasePathWithClassification(startPath)?.folderPath;\n}"
  },
  "getAllPackageJsonDependencies": {
    "name": "getAllPackageJsonDependencies",
    "slug": "TsFunction",
    "id": "nwxvvdrbzxzmbrcbkabphivn",
    "description": "",
    "operationName": "get-path",
    "rawText": " (\n  operation: Operation\n): string[] => {\n  const dependencies = operation.dependencies\n    ? Object.keys(operation.dependencies)\n    : [];\n  const devDependencies = operation.devDependencies\n    ? Object.keys(operation.devDependencies)\n    : [];\n  const peerDependencies = operation.peerDependencies\n    ? Object.keys(operation.peerDependencies)\n    : [];\n\n  return [...dependencies, ...devDependencies, ...peerDependencies];\n}"
  },
  "getCommonAncestor": {
    "name": "getCommonAncestor",
    "slug": "TsFunction",
    "id": "reetomqffmmiapimrdufjdpm",
    "description": "Finds the common ancestor for two absolute pahts",
    "operationName": "get-path",
    "rawText": " (path1: string, path2: string): string => {\n  const chunks = path1.split(\"/\");\n  const chunks2 = path2.split(\"/\");\n\n  const firstFolderMismatchIndex = chunks.findIndex((chunk, index, array) => {\n    const isMismatch = chunks2[index] !== chunk;\n\n    return isMismatch;\n  });\n\n  const commonAncestor = chunks.slice(0, firstFolderMismatchIndex).join(\"/\");\n\n  return commonAncestor;\n}"
  },
  "getOperationClassificationObject": {
    "name": "getOperationClassificationObject",
    "slug": "TsFunction",
    "id": "ixvtnpnxvmdagdvhqmzadlfs",
    "description": "",
    "operationName": "get-path",
    "rawText": "\n  async (): Promise<OperationClassificationObject> => {\n    const operationFolders = await exploreOperationFolders({});\n\n    return mergeObjectsArray(\n      operationFolders\n        .map((operationBasePath) => {\n          const operationClassification =\n            getOperationClassification(operationBasePath);\n          if (!operationClassification) return;\n          const operationName = getLastFolder(operationBasePath);\n          return { [operationName]: operationClassification };\n        })\n        .filter(notEmpty)\n    );\n  }"
  },
  "getOperationClassification": {
    "name": "getOperationClassification",
    "slug": "TsFunction",
    "id": "jbllbegtaukhorgggcyxglue",
    "description": "Returns `OperationClassification` if it's an operation, or undefined if it's not\n\nNB: don't confuse this with `ImportClassification`",
    "operationName": "get-path",
    "rawText": " (\n  folderPath: string\n): OperationClassification | undefined => {\n  if (folderPath === undefined) {\n    console.log(\n      \"Incorrect type at getOperationClassification\"\n      // getOperationClassification.caller\n    );\n    process.exit(1);\n  }\n\n  if (!isOperation(folderPath)) {\n    return;\n  }\n\n  const packageJsonPath = path.join(folderPath, \"package.json\");\n  const packageJson = tryParseJson<Operation>(\n    fs.readFileSync(packageJsonPath, \"utf8\")\n  );\n\n  const tsconfigPath = path.join(folderPath, \"tsconfig.json\");\n\n  const tsconfig = readJsonFileSync<TsConfig>(tsconfigPath);\n\n  if (!tsconfig) return;\n\n  if (!packageJson || packageJson.workspaces) {\n    return;\n  }\n\n  const nextConfigPath = path.join(folderPath, \"next.config.js\");\n  const existsNextConfig = fs.existsSync(nextConfigPath);\n  const isNextApp = existsNextConfig;\n  if (isNextApp) return \"ui-web\";\n\n  const appJsonPath = path.join(folderPath, \"app.json\");\n  const existsAppJson = fs.existsSync(appJsonPath);\n  const isReactNativeApp = existsAppJson;\n  if (isReactNativeApp) return \"ui-app\";\n\n  const isTs = packageCompilesTs(packageJson);\n\n  const isEsm = tsconfigCompilesEsm(tsconfig);\n\n  const isUi = isUiOperation(tsconfig, packageJson);\n\n  const compileType = isEsm ? \"esm\" : isTs ? \"ts\" : \"cjs\";\n\n  if (isUi) {\n    return `ui-${compileType}`;\n  }\n\n  const hasTypesNode = hasDependency(packageJson, \"@types/node\");\n\n  if (hasTypesNode) {\n    if (packageJson.operation?.isNodeServer) {\n      return \"server-cjs\";\n    }\n    return `node-${compileType}`;\n  }\n\n  return compileType;\n}"
  },
  "getOperationPathParse": {
    "name": "getOperationPathParse",
    "slug": "TsFunction",
    "id": "vmqruifwarqtdfarcbqpdgec",
    "description": "get all operation-related path information that can be inferred from the path\n\nNB: currently it also looks up the operation name from its packagejson",
    "operationName": "get-path",
    "rawText": " (\n  absolutePath: string\n): OperationPathParse | undefined => {\n  if (!absolutePath) return;\n  const pathParse = getPathParse(absolutePath);\n  if (!pathParse) return;\n  const projectRoot = getProjectRoot(absolutePath);\n  if (!projectRoot) return;\n  const operationBasePath = findOperationBasePath(absolutePath);\n  if (!operationBasePath) return;\n  const operationSrcPath = path.join(operationBasePath, \"src\");\n\n  const operationFolderName = getLastFolder(operationBasePath);\n  const operationName = readJsonFileSync<Operation>(\n    path.join(operationBasePath, \"package.json\")\n  )?.name;\n\n  const operationRelativeTypescriptFilePath = getOperationRelativePath(\n    absolutePath,\n    operationBasePath\n  );\n\n  const parsedPath = path.parse(absolutePath);\n  const srcFileId = makeRelative(\n    path.join(parsedPath.dir, parsedPath.name),\n    operationSrcPath\n  );\n\n  const relativeOperationBasePathFromProjectRoot = operationBasePath.slice(\n    projectRoot.length\n  );\n\n  return {\n    relativePathFromProjectRoot: pathParse.relativePathFromProjectRoot,\n    srcFileId,\n    operationFolderName,\n    operationRelativeTypescriptFilePath,\n    relativeOperationBasePathFromProjectRoot,\n    operationName,\n  };\n}"
  },
  "getOperationPath": {
    "name": "getOperationPath",
    "slug": "TsFunction",
    "id": "tslxflklldpyejcbyxytctar",
    "description": "Gets a path of any operation in the project\n\nTODO: IDEA: maybe auto-generate key-value JSON where keys are the package-names of all operations and values are paths of their locations in the file system. we can easily generate this ourselves, but maybe it's also easy to use the npm yarn workspace for this, although it may not be available in all circumstances, so better not rely on it. The advantage of this would be that this function becomes sync and is much more efficient. The disadvantage is that every time you move something or add something new, this indexation has to happen, otherwise it fails.",
    "operationName": "get-path",
    "rawText": " async (\n  /**\n   * specify the operation folder name\n   */\n  operationName: string,\n  config?: {\n    manualProjectRoot?: string;\n    /**\n     * if true, will not use sdk (defaults to using it first...)\n     */\n    notUseSdk?: boolean;\n  }\n): Promise<string | undefined> => {\n  // NB: In case of manualProjectRoot, we should not use the SDK! The sdk is from our own project root.\n  if (!config?.notUseSdk && !config?.manualProjectRoot) {\n    const projectRelativeOperationPath =\n      operations[operationName as keyof typeof operations];\n    const projectRoot = getProjectRoot();\n    if (projectRelativeOperationPath && projectRoot) {\n      return path.join(projectRoot, projectRelativeOperationPath);\n    }\n  }\n\n  // if that didn't work, let's find it in realtime\n\n  const basePath = getPathsWithOperations({\n    manualProjectRoot: config?.manualProjectRoot,\n  });\n\n  const operationPaths: string[] = await exploreOperationFolders({ basePath });\n\n  if (operationPaths.length === 0) {\n    log(\"No operations available\", { type: \"error\" });\n    return;\n  }\n  const operationPathsWithTheirFolder = await Promise.all(\n    operationPaths.map(async (p) => ({\n      path: p,\n      folderName: getLastFolder(p),\n    }))\n  );\n\n  const foundPath = operationPathsWithTheirFolder.find(\n    (f) => f.folderName === operationName\n  )?.path;\n\n  return foundPath;\n}"
  },
  "getOperationRelativePath": {
    "name": "getOperationRelativePath",
    "slug": "TsFunction",
    "id": "wxfnnewpsoemgzwylbrnqlfp",
    "description": "something like src/xxx/xxx/x.ts (no slash at start)",
    "operationName": "get-path",
    "rawText": " (\n  absolutePath: string,\n  operationBasePath: string\n) => {\n  return absolutePath.slice(operationBasePath.length + 1);\n}"
  },
  "getPathParse": {
    "name": "getPathParse",
    "slug": "TsFunction",
    "id": "wobjzpbwztvocjbqqhypcurj",
    "description": "gets all kinds of information that can be inferred from any path (file or folder).",
    "operationName": "get-path",
    "rawText": " (absolutePath: string): PathParse | undefined => {\n  const projectRoot = getProjectRoot(absolutePath);\n  if (!projectRoot) return;\n  const relativePathFromProjectRoot = absolutePath.slice(projectRoot.length);\n  return { relativePathFromProjectRoot };\n}"
  },
  "getPathsWithOperations": {
    "name": "getPathsWithOperations",
    "slug": "TsFunction",
    "id": "mekdpnreowlfrqvmecbvnhtu",
    "description": "returns an array of all (absolute) paths containing operations\n\nfor a bundled project, that means /apps, /packages, /modules\n\nfor the OS project, that means /operations/tools and /operations/niches",
    "operationName": "get-path",
    "rawText": " (config?: {\n  /**\n   * if given, this will be taken as the project root instead of the one that can be found automatically (useful for bundling or working with multiple projects that alter each other)\n   */\n  manualProjectRoot?: string;\n}): string[] => {\n  const rootPath = config?.manualProjectRoot || getProjectRoot();\n\n  if (!rootPath) {\n    log(`no rootpath found!`, { type: \"error\" });\n    process.exit(1);\n  }\n\n  if (isBundle(rootPath)) {\n    const pathsWithOperations = [\"apps\", \"packages\", \"modules\"]\n      .map((folderName) => path.join(rootPath, folderName))\n      .filter((fullPath) => fs.existsSync(fullPath));\n\n    if (pathsWithOperations.length === 0) {\n      log(`Couldn't find any operations in ${rootPath}`);\n      process.exit(1);\n    }\n\n    return pathsWithOperations;\n  }\n  const toolsPath = path.join(rootPath, \"operations/tools\");\n  const bundlesPath = path.join(rootPath, \"operations/niches\");\n  if (!fs.existsSync(toolsPath) || !fs.existsSync(bundlesPath)) {\n    log(`Couldn't find tools or bundles folder in ${rootPath}`);\n    process.exit(1);\n  }\n\n  return [toolsPath, bundlesPath];\n}"
  },
  "getProjectRoot": {
    "name": "getProjectRoot",
    "slug": "TsFunction",
    "id": "bpvpbqsiqhjhulbnvfxlupvn",
    "description": "returns project root folder path\n\nrecursive. goes up until it finds a folder that's the project root\n\nif no source path is given, uses the directory name where the function is executed from as a starting point",
    "operationName": "get-path",
    "rawText": " (fullSourcePath?: string): string | undefined => {\n  const matchFolder = findFolderWhereMatch(\n    fullSourcePath || process.cwd(),\n    hasProjectRootFile\n  );\n  if (!matchFolder) return;\n  return matchFolder.folderPath;\n}"
  },
  "getRelativeLinkPath": {
    "name": "getRelativeLinkPath",
    "slug": "TsFunction",
    "id": "fdwmbtjgljqbjgrwjlttgjbr",
    "description": "returns a relative link between two files",
    "operationName": "get-path",
    "rawText": " (\n  absoluteFromFilePath: string,\n  absoluteToFilePath: string,\n  debug?: boolean\n): string => {\n  const commonAncestorPath = getCommonAncestor(\n    absoluteFromFilePath,\n    absoluteToFilePath\n  );\n\n  //1 - go from `absoluteFromPath` to `commonAncestorPath`\n  const commonAncestorRelativeFromPath = makeRelative(\n    absoluteFromFilePath,\n    commonAncestorPath\n  );\n  const commonAncestorRelativeToPath = makeRelative(\n    absoluteToFilePath,\n    commonAncestorPath\n  );\n\n  const foldersToGoBackAmount =\n    commonAncestorRelativeFromPath.split(\"/\").length - 1;\n\n  const backOrStart =\n    foldersToGoBackAmount === 0 ? \"./\" : \"../\".repeat(foldersToGoBackAmount);\n\n  //2 - go from `commonAncestorPath` to `absoluteToPath`\n  const relativeLinkPath = `${backOrStart}${commonAncestorRelativeToPath}`;\n\n  if (debug) {\n    console.log({\n      commonAncestorPath,\n      commonAncestorRelativeFromPath,\n      commonAncestorRelativeToPath,\n    });\n  }\n\n  return relativeLinkPath;\n}"
  },
  "getRelativePath": {
    "name": "getRelativePath",
    "slug": "TsFunction",
    "id": "bayycvpqwytizuubwvvqdcrl",
    "description": "gets the relative path from a specified root\n\nwill start with \"/\"",
    "operationName": "get-path",
    "rawText": " (\n  absolutePath: string,\n  relativeFrom: \"project-root\"\n) => {\n  const rootPath =\n    relativeFrom === \"project-root\" ? getRootPath() : getRootPath();\n\n  if (!rootPath) return;\n\n  const relativePath = absolutePath.replace(rootPath, \"\");\n\n  return relativePath;\n}"
  },
  "getRootPath": {
    "name": "getRootPath",
    "slug": "TsFunction",
    "id": "xbplbibgwkiogdadpjlwtjta",
    "description": "Gets project path, or a folder in the root that is convention",
    "operationName": "get-path",
    "rawText": " (\n  /**\n   * if not specified, will return project root path\n   */\n  name?: OSRootFolder | ProjectRootFolder,\n  config?: { manualProjectRoot?: string }\n): string | undefined => {\n  const projectRootDir = config?.manualProjectRoot || getProjectRoot();\n  if (!projectRootDir) return;\n\n  if (!name) {\n    return projectRootDir;\n  }\n\n  if (isBundle(projectRootDir)) {\n    if (projectRootFolders.concat(osRootFolders).includes(name)) {\n      const projectFolder =\n        name === \"text\"\n          ? \"docs\"\n          : name === \"operations\"\n          ? \"packages\"\n          : name === databaseFolderName\n          ? databaseFolderName\n          : null;\n      if (!projectFolder) {\n        console.log(\"get root path: This should never happen\", name);\n        return;\n      }\n\n      const folderPath = path.resolve(projectRootDir, projectFolder);\n      return folderPath;\n    }\n  }\n\n  // non-bundled projects\n\n  if (projectRootFolders.concat(osRootFolders).includes(name)) {\n    const folderPath = path.resolve(projectRootDir, name);\n    return folderPath;\n  }\n\n  console.log(\n    \"getRootPath: Should never happen, probably a wrong input was provided:\",\n    { name }\n  );\n\n  return;\n}"
  },
  "getSrcRelativeFileId": {
    "name": "getSrcRelativeFileId",
    "slug": "TsFunction",
    "id": "bwujrlmktrvyxwsnnnoywdvt",
    "description": "returns a file id (path without extension) relative to the src folder of an operation\n\ne.g. \"general\" for src/general.ts\n\nNB: assumes all src is in the src folder\n\nNB: removes \"/\" in the beginning, if found",
    "operationName": "get-path",
    "rawText": " (operationRelativePath: string) => {\n  const srcRelativePath = operationRelativePath.replace(\"src/\", \"\");\n  const parts = srcRelativePath.split(\".\");\n  // remove the last one\n  parts.pop();\n  const srcRelativeFileId = parts.join(\".\");\n\n  const finalId = srcRelativeFileId.startsWith(\"/\")\n    ? srcRelativeFileId.substring(1)\n    : srcRelativeFileId;\n  return finalId;\n}"
  },
  "hasDependency": {
    "name": "hasDependency",
    "slug": "TsFunction",
    "id": "dhcioskhdxqryeczrhxnyhac",
    "description": "",
    "operationName": "get-path",
    "rawText": " (operation: Operation, dependency: string) => {\n  return getAllPackageJsonDependencies(operation).includes(dependency);\n}"
  },
  "hasProjectRootFile": {
    "name": "hasProjectRootFile",
    "slug": "TsFunction",
    "id": "fkgrmnrlhxyzsguhyweojvmq",
    "description": "",
    "operationName": "get-path",
    "rawText": " (absolutePath: string) => {\n  const osRootFilePath = path.join(absolutePath, \".project-root\");\n  const osRootFileExists = fs.existsSync(osRootFilePath);\n  return osRootFileExists;\n}"
  },
  "isBundle": {
    "name": "isBundle",
    "slug": "TsFunction",
    "id": "qmwypnqqwbmsdupqjamefncu",
    "description": "",
    "operationName": "get-path",
    "rawText": " (folderPath?: string): boolean => {\n  const realFolderPath = folderPath || getProjectRoot();\n  if (!realFolderPath) return false;\n  // get package-json and check operation config\n  const packageJson = readJsonFileSync<Operation>(\n    path.join(realFolderPath, \"package.json\")\n  );\n  const isBundle = packageJson?.operation?.isBundle || false;\n  return isBundle;\n}"
  },
  "isOperation": {
    "name": "isOperation",
    "slug": "TsFunction",
    "id": "kfmjouelhnfdsqgqypnhbwzr",
    "description": "Checks whether or not an absolute path contains an operation. The only check it's doing is that the folder must contain both a package.json as well as a tsconfig.json",
    "operationName": "get-path",
    "rawText": " (absoluteFolderPath: string): boolean => {\n  const packageJsonPath = path.join(absoluteFolderPath, \"package.json\");\n  const existsPackageJson = fs.existsSync(packageJsonPath);\n  const tsConfigPath = path.join(absoluteFolderPath, \"tsconfig.json\");\n  const existsTsConfig = fs.existsSync(tsConfigPath);\n  // NB: must have these two in order to be an operation at all\n  if (!existsPackageJson || !existsTsConfig) {\n    return false;\n  }\n  return true;\n}"
  },
  "isUiOperation": {
    "name": "isUiOperation",
    "slug": "TsFunction",
    "id": "omnklupfydlbgivwiugokryc",
    "description": "",
    "operationName": "get-path",
    "rawText": " (\n  tsconfig: TsConfig | null,\n  packageJson: Operation | null\n) => {\n  const isReactPackage =\n    !!packageJson &&\n    (hasDependency(packageJson, \"react\") ||\n      hasDependency(packageJson, \"react-native\") ||\n      hasDependency(packageJson, \"next\") ||\n      hasDependency(packageJson, \"expo\"));\n\n  const usesJsx = !!tsconfig?.compilerOptions?.jsx;\n\n  return isReactPackage && usesJsx;\n}"
  },
  "isWorkspaceRoot": {
    "name": "isWorkspaceRoot",
    "slug": "TsFunction",
    "id": "gccmzrcpfhwjtwdgdqlwuvre",
    "description": "simple sync function to check if a folder is the root of a workspace (not operation but a workspace)",
    "operationName": "get-path",
    "rawText": " (\n  folderPath: string\n): undefined | { isBundle: boolean; isWorkspaceRoot: boolean } => {\n  const packageJsonPath = path.join(folderPath, \"package.json\");\n  const existsPackageJson = fs.existsSync(packageJsonPath);\n  if (!existsPackageJson) return;\n\n  const packageJson = tryParseJson<Operation>(\n    fs.readFileSync(packageJsonPath, \"utf8\")\n  );\n\n  if (!packageJson || !packageJson.workspaces) {\n    return;\n  }\n\n  return {\n    isBundle: packageJson.operation?.isBundle || false,\n    isWorkspaceRoot: true,\n  };\n}"
  },
  "osRootFoldersConst": {
    "name": "osRootFoldersConst",
    "slug": "TsVariable",
    "id": "fktinwywambpovtiherpoffy",
    "description": "can only be accessed in the OS",
    "operationName": "get-path"
  },
  "osRootFolders": {
    "name": "osRootFolders",
    "slug": "TsVariable",
    "id": "ufovnpwuekchxlfvfepzlfsn",
    "description": "",
    "operationName": "get-path"
  },
  "packageCompilesTs": {
    "name": "packageCompilesTs",
    "slug": "TsFunction",
    "id": "kimjdjynrobwhtyilsvsxyhr",
    "description": "",
    "operationName": "get-path",
    "rawText": " (packageJson: Operation | null) => {\n  return (\n    !!packageJson?.main &&\n    packageJson.main.startsWith(\"src/\") &&\n    (packageJson.main.endsWith(\".ts\") || packageJson.main.endsWith(\".tsx\"))\n  );\n}"
  },
  "projectRootFoldersConst": {
    "name": "projectRootFoldersConst",
    "slug": "TsVariable",
    "id": "yrjvqwdlrfwflcnxurjdaicc",
    "description": "can be accessed in projects as well as in the OS",
    "operationName": "get-path"
  },
  "projectRootFolders": {
    "name": "projectRootFolders",
    "slug": "TsVariable",
    "id": "hqcbfvbpfesuurtbhvuoghwe",
    "description": "",
    "operationName": "get-path"
  },
  "tsconfigCompilesEsm": {
    "name": "tsconfigCompilesEsm",
    "slug": "TsFunction",
    "id": "kexftfztksxwddylooamvgtx",
    "description": "",
    "operationName": "get-path",
    "rawText": " (tsconfig: TsConfig) => {\n  return (\n    !!tsconfig.compilerOptions.module &&\n    !!tsconfig.compilerOptions.moduleResolution &&\n    tsconfig.compilerOptions.module !== ModuleKind.CommonJS &&\n    tsconfig.compilerOptions.moduleResolution !== ModuleResolutionKind.Classic\n  );\n}"
  },
  "arg1": {
    "name": "arg1",
    "slug": "TsVariable",
    "id": "hodxvngvesgjmnyklgmlkbxm",
    "description": "",
    "operationName": "k-explore"
  },
  "arg2": {
    "name": "arg2",
    "slug": "TsVariable",
    "id": "oofnefjipkttldelgrcdcguk",
    "description": "",
    "operationName": "k-explore"
  },
  "benchmark": {
    "name": "benchmark",
    "slug": "TsFunction",
    "id": "gbqnoxeonfnvjqrfrciyiscq",
    "description": "",
    "operationName": "k-explore",
    "rawText": " async (amount: number = 100) => {\n  const key = `find src folders x${amount}`;\n  console.time(key);\n  let docs = await exploreOperationFolders({\n    basePath: getPathsWithOperations(),\n  });\n\n  console.timeEnd(key);\n  console.log(docs.length, \"folders found\", docs);\n}"
  },
  "determineFileType": {
    "name": "determineFileType",
    "slug": "TsFunction",
    "id": "tpoioxlloxyapjteltgfurpy",
    "description": "returns the file type or null if it's unknown",
    "operationName": "k-explore",
    "rawText": " (filePath: string): FileType | null => {\n  const extension = path.parse(filePath).ext.substring(1);\n  if (!isSearchContentExtension(extension)) return null;\n  const index = fileTypes.findIndex((fileType) =>\n    extensions[fileType].includes(extension)\n  );\n  const fileType = fileTypes[index];\n  return fileType;\n}"
  },
  "exploreGitRepoFolders": {
    "name": "exploreGitRepoFolders",
    "slug": "TsFunction",
    "id": "ndutyuijwntxafabtwqtjsmd",
    "description": "find all active git folders (folders having `.git`)",
    "operationName": "k-explore",
    "rawText": " async (config: BaseConfig) => {\n  return (await findAllDotGitFolders(config))\n    .map((textJson) => textJson.path)\n    .map((p) => path.resolve(p, \"..\"));\n}"
  },
  "exploreMultiple": {
    "name": "exploreMultiple",
    "slug": "TsFunction",
    "id": "wuiytfqkcmdgvaadquefssan",
    "description": "DEPRECATED: not sure if we still need it, look up usecases, can prob be replaced now",
    "operationName": "k-explore",
    "rawText": " async (searchConfigs: SearchConfig[]) => {\n  const textJsonPromises = searchConfigs.map(async (config) => {\n    return explore(config);\n  });\n\n  return (await Promise.all(textJsonPromises)).flat();\n}"
  },
  "exploreOperationFolders": {
    "name": "exploreOperationFolders",
    "slug": "TsFunction",
    "id": "jizarjxjymrsiyenjkbihqyt",
    "description": "find all active operations (folders having `package.json` but also `tsconfig.json`)\n\nreturns folder path array",
    "operationName": "k-explore",
    "rawText": " async (\n  config: BaseConfig\n): Promise<string[]> => {\n  const folders = (\n    await findAllPackages({\n      basePath: config?.basePath,\n    })\n  )\n    .map((x) => x.path)\n    .map((p) => getFolder(p))\n    .filter((p) => {\n      const alsoTsConfig = fs.existsSync(path.join(p, \"tsconfig.json\"));\n      return alsoTsConfig;\n    });\n\n  return folders;\n}"
  },
  "explorePreset": {
    "name": "explorePreset",
    "slug": "TsFunction",
    "id": "eiqrlzytlbfqzlmuerlaxpxq",
    "description": "",
    "operationName": "k-explore",
    "rawText": " (\n  preset: \"packages\" | \"markdown\" | \"todo\" | \"docs\" | \"src\" | \"git\",\n  config?: BaseConfig\n) => {\n  const basePath = config?.basePath;\n\n  const searchConfigs: SearchConfig[] =\n    preset === \"packages\"\n      ? [\n          {\n            basePath,\n            search: \"package.json\",\n            exact: true,\n            extension: \"json\",\n            ignore: generatedFolders,\n          },\n        ]\n      : preset === \"markdown\"\n      ? [\n          {\n            basePath,\n            extension: [\"md\", \"mdx\"],\n            ignore: generatedFolders,\n          },\n        ]\n      : preset === \"todo\"\n      ? // finds all `*.todo.md`,` todo/**/*.md` and returns the path + content\n\n        [\n          {\n            basePath,\n            extension: [\"md\", \"mdx\"],\n            search: \"/todo/\",\n            searchLevel: \"filePath\",\n            ignore: generatedFolders,\n          },\n          {\n            basePath,\n            extension: [\"md\", \"mdx\"],\n            search: \"todo.md\",\n            exact: true,\n            searchLevel: \"fileName\",\n            ignore: generatedFolders,\n          },\n          {\n            basePath,\n            extension: [\"md\", \"mdx\"],\n            subExtension: \"todo\",\n            exact: false,\n            searchLevel: \"fileName\",\n            ignore: generatedFolders,\n          },\n        ]\n      : preset === \"docs\"\n      ? [\n          {\n            basePath,\n            extension: [\"md\", \"mdx\"],\n            search: \"/docs/\",\n            searchLevel: \"filePath\",\n            ignore: generatedFolders,\n          },\n          {\n            basePath,\n            extension: [\"md\", \"mdx\"],\n            search: \"readme.md\",\n            exact: true,\n            searchLevel: \"fileName\",\n            ignore: generatedFolders,\n          },\n          {\n            basePath,\n            extension: [\"md\", \"mdx\"],\n            subExtension: [\"readme\"],\n            exact: false,\n            searchLevel: \"fileName\",\n            ignore: generatedFolders,\n          },\n        ]\n      : preset === \"src\"\n      ? [\n          {\n            basePath,\n            searchLevel: \"folder\",\n            exact: true,\n            search: \"src\",\n            doNotExploreMatch: true,\n            ignore: generatedFolders,\n          },\n        ]\n      : [];\n\n  const textJsons = exploreMultiple(searchConfigs);\n  return textJsons;\n}"
  },
  "explore": {
    "name": "explore",
    "slug": "TsFunction",
    "id": "dfvwxyzfdjkjnrfiusjfnrdq",
    "description": "This is the safe and friendly version of `findFilesRecursively`",
    "operationName": "k-explore",
    "rawText": " async ({\n  basePath,\n  searchLevel = \"fileName\",\n  debug,\n  ...other\n}: SearchConfig): Promise<TextJson[]> => {\n  /** accessability depends on whether we need to be able to read the file, or just see it */\n  const canAccess = async (p: string) =>\n    await (searchLevel === \"outline\" || searchLevel === \"full\"\n      ? canRead\n      : canSee)(p);\n\n  /** basepaths becomes an array of only the basepaths that we can access */\n  const accessibleBasePaths = makeArray(basePath || getProjectRoot())\n    .filter(fs.existsSync)\n    .filter(canAccess);\n\n  if (debug) console.log(`finding files in ${accessibleBasePaths.join(\",\")}`);\n\n  const textJsonPromises = accessibleBasePaths.map(async (p) =>\n    findFilesRecursively({ basePath: p, searchLevel, debug, ...other })\n  );\n\n  const textJsons = (await Promise.all(textJsonPromises)).flat();\n\n  return textJsons;\n}"
  },
  "findAllDocsFolderPaths": {
    "name": "findAllDocsFolderPaths",
    "slug": "TsFunction",
    "id": "zfaifeealudepwmekzcemrpa",
    "description": "Returns absolute paths for all docs folders (not the files inside)",
    "operationName": "k-explore",
    "rawText": " async (\n  /**\n   * Don't look for docs folders inside of operation folders\n   */\n  ignoreOperations?: boolean,\n  /**\n   * optionally, ignore some folders\n   */\n  ignoreFolders?: string[]\n): Promise<string[]> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return [];\n  const docsBasePath = isBundle(projectRoot)\n    ? projectRoot\n    : getRootPath(\"operations\");\n\n  if (!docsBasePath) return [];\n\n  const docsFolderPaths = await findAllFoldersWithName({\n    basePath: docsBasePath,\n    folderName: \"docs\",\n    ignoreOperations,\n    ignoreFolders,\n  });\n  return docsFolderPaths;\n}"
  },
  "findAllDotGitFolders": {
    "name": "findAllDotGitFolders",
    "slug": "TsFunction",
    "id": "jqmuybjimgkycsprkwgjdyjm",
    "description": "",
    "operationName": "k-explore",
    "rawText": " (config: BaseConfig) => {\n  return explore({\n    basePath: config?.basePath,\n    search: \".git\",\n    exact: true,\n    searchLevel: \"folder\",\n    doNotExploreMatch: true,\n    // I guess we can assume there will never be git folders inside an operation on a deeper level, that would be strange... Therefore, these can be ignored\n    ignore: [\"node_modules\", \"build\", \".next\", \"src\", \"assets\", \"data\"],\n  });\n}"
  },
  "findAllFoldersWithName": {
    "name": "findAllFoldersWithName",
    "slug": "TsFunction",
    "id": "bebuolpuukeowuernxnlxnht",
    "description": "",
    "operationName": "k-explore",
    "rawText": " async (config: {\n  basePath: string;\n  folderName: string;\n  ignoreOperations?: boolean;\n  /**\n   * folders to ignore\n   */\n  ignoreFolders?: string[];\n}): Promise<string[]> => {\n  const { basePath, folderName, ignoreOperations, ignoreFolders } = config;\n\n  const result = (\n    await explore({\n      basePath,\n      searchLevel: \"folder\",\n      search: folderName,\n      ignore: [...generatedFolders, ...(ignoreFolders || [])],\n      exact: true,\n      cancelRecursionOn: ignoreOperations ? pathArrayIsOperation : undefined,\n    })\n  ).map((x) => x.path);\n\n  return result;\n}"
  },
  "findAllPackages": {
    "name": "findAllPackages",
    "slug": "TsFunction",
    "id": "fnrexdqwpynipjjrpfmwejhn",
    "description": "",
    "operationName": "k-explore",
    "rawText": " (config?: {\n  basePath: string | string[] | undefined;\n}) => {\n  return explore({\n    basePath: config?.basePath || getPathsWithOperations(),\n    search: \"package.json\",\n    exact: true,\n    extension: \"json\",\n    searchLevel: \"fileName\",\n    ignore: generatedFolders.concat([\"src\", \"assets\", \"data\"]),\n  });\n}"
  },
  "findAllTodoFolderPaths": {
    "name": "findAllTodoFolderPaths",
    "slug": "TsFunction",
    "id": "lxhnycztvrktganbpdafzcxo",
    "description": "",
    "operationName": "k-explore",
    "rawText": " (\n  basePath: string,\n  ignoreOperations?: boolean\n): Promise<string[]> => {\n  return findAllFoldersWithName({\n    basePath,\n    folderName: \"todo\",\n    ignoreOperations,\n  });\n}"
  },
  "findFilesRecursively": {
    "name": "findFilesRecursively",
    "slug": "TsFunction",
    "id": "gwxmwrketoxzuweczoaktzrr",
    "description": "Explores your files with many possibilities.\n\nNB: this function only searches one basePath, while explore can do multiple\n\nTODO: since this not only finds files but also explores them, naming should be exploreFilesRecursively, probably.\n\nTODO: TextJson[] is a bit weird name for the resulting type interface...",
    "operationName": "k-explore",
    "rawText": " async (\n  config: Omit<SearchConfig, \"basePath\"> & {\n    // this is the only difference compared to the other searchconfig\n    basePath: string;\n  }\n): Promise<TextJson[]> => {\n  const {\n    basePath,\n    ignore,\n    searchLevel,\n    extension,\n    subExtension,\n    search,\n    //booleans:\n    includeFoldersWithResults,\n    doNotExploreMatch,\n    doNotExploreChildFolders,\n    debug,\n    exact,\n    readmeOnTop,\n    includeStats,\n    includeMetaData,\n    cancelRecursionOn,\n  } = config;\n  // NB: we know we only use this function like this\n  const subExtensions = makeArray(subExtension);\n  const extensions = makeArray(extension);\n  const searches = makeArray(search);\n  const ignores = makeArray(ignore);\n\n  const contents = await fs.readdir(basePath, {\n    withFileTypes: true,\n    encoding: \"utf8\",\n  });\n\n  // NB: if there's a readme and readmeOnTop is true, make sure it ends up on top\n  const readmeIndex = readmeOnTop\n    ? contents.findIndex((x) => x.name.toLowerCase() === \"readme.md\")\n    : -1;\n  const sortedContents: Dirent[] =\n    readmeIndex !== -1\n      ? [contents[readmeIndex], ...removeIndexFromArray(contents, readmeIndex)]\n      : contents;\n\n  const pathArray = sortedContents.map((x) => path.join(basePath, x.name));\n\n  // if contents should not be explored, return an empty array\n  if (cancelRecursionOn?.(pathArray)) {\n    return includeFoldersWithResults\n      ? [{ path: basePath, isCancelRecursionResult: true, isFolder: false }]\n      : [];\n  }\n\n  if (debug)\n    console.log(`contents contains ${sortedContents.length} files/folders`);\n\n  const textJsonPromises: Promise<TextJson[] | null>[] = sortedContents.map(\n    async (dirent) => {\n      // don't check files if search level is folder\n      if (searchLevel === \"folder\" && dirent.isFile()) {\n        return null;\n      }\n\n      //if dir/file name should be ignored, skip it\n      if (ignores.includes(dirent.name)) {\n        if (debug) console.log(\"Ignoring\", dirent.name);\n        return null;\n      }\n\n      // if we want specific sub-extensions and this file isn't one of them, return\n      if (\n        dirent.isFile() &&\n        subExtensions &&\n        subExtensions.length > 0 &&\n        !subExtensions.find((ext) => getSubExtension(dirent.name) === ext)\n      ) {\n        if (debug)\n          console.log(\n            `ignoring ${dirent.name} because of subextension mismatch`\n          );\n        return null;\n      }\n\n      // if we want specific extensions and this file isn't one of them, return\n      if (\n        dirent.isFile() &&\n        extensions &&\n        extensions.length > 0 &&\n        !extensions.find((ext) => getExtension(dirent.name) === ext)\n      ) {\n        if (debug)\n          console.log(`ignoring ${dirent.name} because of extension mismatch`);\n        return null;\n      }\n\n      const filePath: string = path.join(basePath, dirent.name);\n\n      // if it's a file, we don't go into recursion.\n      if (dirent.isFile()) {\n        const ext = getExtension(dirent.name) || \"\";\n\n        //getting extension\n\n        const isJson = jsonExtensions.includes(ext);\n        const isTypescript = typescriptExtensions.includes(ext);\n        const isMarkdown = markdownExtensions.includes(ext);\n\n        //NB: be careful when ever changing this logic!\n        // It should never get contents when it doesn't need to,\n        // because this is a very heavy operation.\n\n        const searchContender =\n          searchLevel === \"folder\"\n            ? dirent.name\n            : searchLevel === \"fileName\"\n            ? dirent.name\n            : searchLevel === \"filePath\" || !isSearchContentExtension(ext)\n            ? filePath //withoutExtension? dirent.name or filePath??? we also want to match folder names before it, right?\n            : //TODO: is getOutLine() evaluated if it's not an outline? it also seems the default, which I don't like. Test this, it's an important aspect of exploring efficiently.\n            searchLevel === \"outline\"\n            ? getOutline(filePath)!\n            : searchLevel === \"full\"\n            ? await getContents(filePath)\n            : \"SHOULD_NEVER_HAPPEN\";\n\n        if (debug) console.log(`searchContender: ${searchContender}`);\n        const match = isMatch({ exact, searchContender, searches });\n\n        const json: any | undefined =\n          isJson && searchLevel === \"full\" ? getContents(filePath) : undefined;\n\n        const markdownJson: MarkdownParse | undefined =\n          isMarkdown && searchLevel === \"full\"\n            ? // TODO: get markdown parse here\n              await getContents(filePath)\n            : undefined;\n\n        // NB: TODO: we don't do typescript json yet\n        // TODO: I think double special comments (like the above) on a single line isn't indexed yet, is it?\n        const typescriptJson: undefined = isTypescript ? undefined : undefined;\n\n        const stats = includeStats ? await fs.stat(filePath) : undefined;\n\n        if (debug) console.log(`${dirent.name}? match ${match}`);\n        //match found...\n        const matchOrNot: TextJson[] | null = match\n          ? [\n              {\n                path: filePath,\n                json,\n                isFolder: false,\n                markdownJson,\n                typescriptJson,\n                stats: stats\n                  ? {\n                      createdAt: stats.ctimeMs,\n                      updatedAt: stats.mtimeMs,\n                    }\n                  : undefined,\n              },\n            ]\n          : null;\n        return matchOrNot;\n      }\n\n      // ^ these were all the base cases ^. Now the recursion.\n\n      if (dirent.isDirectory() && !doNotExploreChildFolders) {\n        let results: TextJson[] = [];\n        let shouldRecurse = true;\n        if (searchLevel === \"folder\") {\n          const searchContender = dirent.name;\n          const match = isMatch({ searchContender, exact, searches });\n\n          if (match) {\n            results.push({\n              path: filePath,\n              isFolder: true,\n            });\n            shouldRecurse = !doNotExploreMatch;\n          }\n        }\n\n        /**\n       don't dive into folder if:\n      - we're looking for folders \n      - the folder has matched \n      - we don't explore matches\n      */\n        if (shouldRecurse) {\n          const thisFolderPath = path.join(basePath, dirent.name);\n          const thisFolderResults = await findFilesRecursively({\n            basePath: thisFolderPath,\n            extension,\n            search,\n            searchLevel,\n            subExtension,\n            ignore,\n            debug,\n            exact,\n            // NB: I think we just need to fill in everything in the recursion, right?\n            cancelRecursionOn,\n            includeFoldersWithResults,\n            includeMetaData,\n            includeStats,\n            doNotExploreChildFolders,\n            doNotExploreMatch,\n          });\n\n          if (thisFolderResults.length > 0) {\n            results = results.concat(thisFolderResults);\n\n            if (includeFoldersWithResults) {\n              // NB: we can't show any stats because this fs.stats function only works on files. We could sum all stats recursively\n\n              // TODO: should use calcualtePathMetaData here, but we first need to do some more stuff before this can be done... calcualtePathMetaData probably needs to receive a full path instead of a operationFolderPath + relativePath because it can be used outside of operations as well...\n              const metaData = undefined;\n\n              const folderResult: TextJson = {\n                path: thisFolderPath,\n                metaData,\n                isFolder: true,\n              };\n\n              results.push(folderResult);\n            }\n          }\n        }\n\n        return results;\n      }\n\n      return null;\n    }\n  );\n\n  const allMatches = (await Promise.all(textJsonPromises))\n    .filter(notEmpty)\n    .flat();\n\n  return allMatches;\n}"
  },
  "getArgument": {
    "name": "getArgument",
    "slug": "TsFunction",
    "id": "ybttvzuyuclxprejypcmlwfu",
    "description": "",
    "operationName": "k-explore",
    "rawText": " (number: number) => {\n  return process.argv[1 + number];\n}"
  },
  "getContents": {
    "name": "getContents",
    "slug": "TsFunction",
    "id": "aselvfvwxemgwdqyipgqtdzl",
    "description": "gets needed contents of file path, based on the extension\n\nreturns a markdownparse if it's markdown, a json parse for json, or a file content string for anything else",
    "operationName": "k-explore",
    "rawText": " async (filePath: string) => {\n  // console.log(\"Get contents\", filePath);\n  const extension = getExtension(filePath);\n  if (!isSearchContentExtension(extension)) {\n    return;\n  }\n\n  if (extension === \"json\") {\n    return readJsonFile<any>(filePath);\n  } else if (markdownExtensions.includes(extension)) {\n    const contents = await fs.readFile(filePath, \"utf8\");\n    const markdownParse = mdToJsonParse(contents);\n    return markdownParse;\n  } else {\n    const fileString = fs.readFile(filePath, \"utf8\");\n    return fileString;\n  }\n}"
  },
  "getOutline": {
    "name": "getOutline",
    "slug": "TsFunction",
    "id": "muuccexefvcoiuqieogvhxzv",
    "description": "low-level function that gets the outline for MarkdownParse\n\nNB: with books usually the pages are referred in the outline. Since that depends on the font size and dimensions, this cannot be done straight from the markdown parse. Eventually we probably need to check the made pdf for its content, maybe there is even a pdf feature that creates an outline for you. There must be more people having this problem.",
    "operationName": "markdown-parsings",
    "rawText": " (\n  markdownParse: MarkdownParse\n): string | undefined => {\n  const titles = markdownParse.content?.map(getTitlesRecursively).flat();\n  const outlineString = printNestedTitles(titles);\n  return outlineString;\n}"
  },
  "isMatch": {
    "name": "isMatch",
    "slug": "TsFunction",
    "id": "atxjutruvobztouwhqrhgqgd",
    "description": "",
    "operationName": "k-explore",
    "rawText": " ({\n  exact,\n  searchContender,\n  searches,\n}: {\n  exact: boolean | undefined;\n  searches: string[];\n  searchContender: string;\n}) => {\n  return searches.length === 0\n    ? true\n    : exact\n    ? searches.includes(searchContender)\n    : searches.find((s) => searchContender.includes(s));\n}"
  },
  "isSearchContentExtension": {
    "name": "isSearchContentExtension",
    "slug": "TsFunction",
    "id": "ponnhkbsgxkhvicjkbulsowx",
    "description": "type checker for a string to be an extension that can be searched for",
    "operationName": "k-explore",
    "rawText": " (\n  extension: string\n): extension is SearchableExtension => {\n  return allowedSearchContentExtensions\n    .map((x) => x as string)\n    .includes(extension);\n}"
  },
  "pathArrayIsOperation": {
    "name": "pathArrayIsOperation",
    "slug": "TsFunction",
    "id": "hsvcqizgzbpdqkoflhungeur",
    "description": "Checks if pathArray contains a package.json and a tsconfig.json and thus should be an operation\n\nHandy for `cancelRecursionOn` in `explore`",
    "operationName": "k-explore",
    "rawText": " (pathArray: string[]) => {\n  const hasPackageJson = !!pathArray.find(\n    (x) => path.parse(x).base === \"package.json\"\n  );\n  const hasTsConfig = !!pathArray.find(\n    (x) => path.parse(x).base === \"tsconfig.json\"\n  );\n\n  const isOperation = hasPackageJson && hasTsConfig;\n  return isOperation;\n}"
  },
  "getDependenciesSummary": {
    "name": "getDependenciesSummary",
    "slug": "TsFunction",
    "id": "iigkxqhtncgirtdsydhzaifq",
    "description": "",
    "operationName": "operation-util",
    "rawText": " async (operationName: string) => {\n  const operationImports = await db.get(\"TsImport\", {\n    operationName,\n  });\n\n  const coreDependencies = operationImports\n    .filter((x) => [\"node\", \"react\"].includes(x.classification))\n    .map((x) => x.name);\n  const operationDependencies = operationImports\n    .filter((x) => [\"operation\"].includes(x.classification))\n    .map((x) => x.name);\n  const packageDependencies = operationImports\n    .filter((x) => [\"package\"].includes(x.classification))\n    .map((x) => x.name);\n\n  return {\n    coreDependencies,\n    operationDependencies,\n    packageDependencies,\n  };\n}"
  },
  "getOperationMetaData": {
    "name": "getOperationMetaData",
    "slug": "TsFunction",
    "id": "opdlwczgccpbkgamiueowznh",
    "description": "gets a whole bunch of metadata about an operation, mainly filepath related, but it also reads the operation index json file",
    "operationName": "operation-util",
    "rawText": " async (\n  /**\n   * any path in an operation\n   */\n  operationBasePath: string\n): Promise<undefined | OperationMetaData> => {\n  if (!operationBasePath) return;\n  const projectRoot = getProjectRoot(operationBasePath);\n  if (!projectRoot) return;\n  const packageJson = await getPackageJson({\n    operationFolderPath: operationBasePath,\n  });\n  const operationName = packageJson?.name;\n\n  if (!operationName) {\n    return;\n  }\n  const srcPath = path.join(operationBasePath, \"src\");\n  const operationFolderName = getLastFolder(operationBasePath);\n\n  const operations = await db.get(\"Operation\", { operationName });\n  const operation: Operation | undefined = takeFirst(operations);\n\n  const relativeOperationLocationPath = makeRelative(\n    path.join(operationBasePath, \"..\"),\n    projectRoot\n  );\n  if (!relativeOperationLocationPath) return;\n\n  return {\n    operationBasePath,\n    operation,\n    operationName,\n    srcPath,\n    operationFolderName,\n    /**\n     * where the operation is located relative to the project root\n     */\n    relativeOperationLocationPath,\n  };\n}"
  },
  "recalculateOperationIndexJson": {
    "name": "recalculateOperationIndexJson",
    "slug": "TsFunction",
    "id": "yzlljatiodcmzgajigqincjf",
    "description": "Recalculates some operation indexable things and updates that into the database",
    "operationName": "operation-util",
    "rawText": " async (\n  operationBasePath: string,\n  manualProjectRoot?: string\n) => {\n  const operationMetaData = await getOperationMetaData(operationBasePath);\n\n  if (!operationMetaData) {\n    log(`Operation on ${operationBasePath} doesn't have a basepath`, {\n      type: \"error\",\n    });\n    return;\n  }\n\n  const {\n    operation,\n    operationFolderName,\n    operationName,\n    relativeOperationLocationPath,\n  } = operationMetaData;\n\n  if (!operation || !operationName || !relativeOperationLocationPath) {\n    log(\n      `Operation on ${operationBasePath} doesn't have a name or relativeOperationLocationPath or package.json`,\n      { type: \"error\" }\n    );\n    return;\n  }\n\n  const classificationIndexed = getOperationClassification(operationBasePath)!; //NB: we know it's there because operationBasePath must be valid\n\n  const { coreDependencies, operationDependencies, packageDependencies } =\n    await getDependenciesSummary(operationName);\n\n  const categories = await categorizeFiles({\n    basePath: operationBasePath,\n    ignoreIndexFiles: true,\n  });\n\n  const sizeIndexed = await getFolderSummary(categories);\n  // console.log(\"UPDATE QUERY\");\n  await db.update(\n    \"Operation\",\n    (item) => item.name === operation.name,\n    (old) =>\n      mergeNestedObject(old, {\n        operation: {\n          lastRebuildAt: Date.now(),\n          sizeIndexed,\n          folderNameIndexed: operationFolderName,\n          relativeOperationLocationPathIndexed: relativeOperationLocationPath,\n          classificationIndexed,\n          coreDependenciesIndexed: coreDependencies,\n          operationDependenciesIndexed: operationDependencies,\n          packageDependenciesIndexed: packageDependencies,\n        },\n      }),\n    { operationName: operation.name }\n  );\n}"
  },
  "appPrefix": {
    "name": "appPrefix",
    "slug": "TsVariable",
    "id": "zzkombojqnxfctlvsffisjaw",
    "description": "",
    "operationName": "pm2-util"
  },
  "deleteAppCli": {
    "name": "deleteAppCli",
    "slug": "TsFunction",
    "id": "uvxfmpobpeyulousgkwnxdua",
    "description": "Arguments\n- Operation Name",
    "operationName": "pm2-util",
    "rawText": " async () => {\n  const [operationName] = process.argv.slice(2);\n  console.log(`going to delete app ${operationName}`);\n  const result = await deleteApp(operationName);\n  console.log({ result });\n}"
  },
  "deleteApp": {
    "name": "deleteApp",
    "slug": "TsFunction",
    "id": "arclpoktlgzobnbmfmrpoowk",
    "description": "Deletes an app from the pm2\n\nTODO: for some reason it says `error: Error: process or namespace not found` even though it certainly exists. I can't figure out why it's not working.",
    "operationName": "pm2-util",
    "rawText": " (operationName: string) => {\n  return pm2ConnectDisconnect((resolve) => {\n    pm2.delete(`${appPrefix}${operationName}`, (error, proc) => {\n      resolve({ isSuccessful: !error, error, proc });\n    });\n  });\n}"
  },
  "listAppsCli": {
    "name": "listAppsCli",
    "slug": "TsFunction",
    "id": "zhbhgxjavzejrnrsfccjedxj",
    "description": "Arguments:none",
    "operationName": "pm2-util",
    "rawText": " async () => {\n  const result = await listApps();\n  console.table(result.apps || result.message);\n}"
  },
  "listApps": {
    "name": "listApps",
    "slug": "TsFunction",
    "id": "nlwjivpffufwsudkumryatof",
    "description": "Lists the apps in pm2",
    "operationName": "pm2-util",
    "rawText": " async (): Promise<ListAppsResult> => {\n  return pm2ConnectDisconnect((resolve) => {\n    pm2.list((err, processes) => {\n      if (err) {\n        resolve({ isSuccessful: false, message: err.message });\n      }\n\n      const apps = processes\n        .filter((x) => x.name?.startsWith(appPrefix))\n        .map((x) => ({\n          operationName: x.name!.substring(appPrefix.length),\n          cpuPercentage: x.monit?.cpu,\n          memoryBytes: x.monit?.memory,\n        }));\n\n      resolve({ isSuccessful: true, apps });\n    });\n  });\n}"
  },
  "logApp": {
    "name": "logApp",
    "slug": "TsFunction",
    "id": "fmhhqsfscwqzhdsopepozwoa",
    "description": "",
    "operationName": "pm2-util",
    "rawText": " async (operationName: string) => {}"
  },
  "logTableObject": {
    "name": "logTableObject",
    "slug": "TsFunction",
    "id": "savaeygghyyweexqrubyeddm",
    "description": "",
    "operationName": "pm2-util",
    "rawText": " (object: { [key: string]: any } | undefined) => {\n  if (!object) return;\n\n  const table = Object.keys(object).map((key) => {\n    return { property: key, value: object[key] };\n  });\n\n  return table;\n}"
  },
  "pm2ConnectDisconnect": {
    "name": "pm2ConnectDisconnect",
    "slug": "TsFunction",
    "id": "wzrguwegbykpeqavstccdbzb",
    "description": "Function that lets you connect, execute a pm2 action, and disconnect after",
    "operationName": "pm2-util",
    "rawText": " async <\n  TResult extends {\n    isSuccessful: boolean;\n    error?: Error;\n    proc?: pm2.Proc;\n    [key: string]: any;\n  }\n>(\n  action: (resolve: (value: TResult) => void) => void\n) => {\n  const result = await new Promise<{\n    isSuccessful: boolean;\n    error?: Error;\n    proc?: pm2.Proc;\n  }>(async (resolve) => {\n    const { error } = await pm2Connect();\n    if (error) resolve({ isSuccessful: false, error });\n    action((value: TResult) => {\n      resolve(value);\n      pm2.disconnect();\n    });\n  });\n\n  return result;\n}"
  },
  "pm2Connect": {
    "name": "pm2Connect",
    "slug": "TsFunction",
    "id": "rzxssoeekuxfrmpvwlggklmf",
    "description": "",
    "operationName": "pm2-util",
    "rawText": " async () => {\n  return new Promise<{ isSuccessful: boolean; error?: Error }>((resolve) => {\n    pm2.connect((error) => {\n      if (error) {\n        resolve({ isSuccessful: false, error });\n      }\n      resolve({ isSuccessful: true });\n    });\n  });\n}"
  },
  "restartAppCli": {
    "name": "restartAppCli",
    "slug": "TsFunction",
    "id": "ybrumsjuslwubuvripxbxktw",
    "description": "Arguments\n- Operation Name",
    "operationName": "pm2-util",
    "rawText": " async () => {\n  const [operationName] = process.argv.slice(2);\n  const { error, proc } = await restartApp(operationName);\n  console.table(logTableObject(takeFirst(proc) || error));\n}"
  },
  "restartApp": {
    "name": "restartApp",
    "slug": "TsFunction",
    "id": "ozadlkakuuebejfjfarrbrei",
    "description": "Restarts an app with pm2",
    "operationName": "pm2-util",
    "rawText": " async (operationName: string) => {\n  return pm2ConnectDisconnect((resolve) => {\n    restart(`${appPrefix}${operationName}`, (error, proc) => {\n      resolve({ isSuccessful: !error, proc, error });\n    });\n  });\n}"
  },
  "startAppCli": {
    "name": "startAppCli",
    "slug": "TsFunction",
    "id": "drscociwybjohelbtbtdkitq",
    "description": "Arguments\n- Operation Name\n- isDev (true)",
    "operationName": "pm2-util",
    "rawText": " async () => {\n  const [operationName, isDevString] = process.argv.slice(2);\n  const isDev = isDevString === \"true\";\n  const result = await startApp(operationName, isDev);\n\n  const table = logTableObject(\n    takeFirst(result?.proc) || result?.error || result\n  );\n  console.table(table);\n}"
  },
  "startApp": {
    "name": "startApp",
    "slug": "TsFunction",
    "id": "ijoflxuycyofihnjernvegzr",
    "description": "",
    "operationName": "pm2-util",
    "rawText": " async (\n  operationName: string,\n  isDev?: boolean\n): Promise<{\n  isSuccessful: boolean;\n  error?: Error;\n  proc?: pm2.Proc;\n  message?: string;\n}> => {\n  const operationFolderPath = await getOperationPath(operationName);\n  if (!operationFolderPath) {\n    return { isSuccessful: false, message: \"No operation folder path\" };\n  }\n  const packageJson = await getPackageJson({ operationFolderPath });\n  if (!packageJson) {\n    return { isSuccessful: false, message: \"no package json found\" };\n  }\n\n  const port = packageJson?.operation?.port;\n\n  if (!port) {\n    return {\n      isSuccessful: false,\n      message: \"Operation must have a port assigned\",\n    };\n  }\n\n  const isAlready = await isPortUsed(port);\n\n  if (isAlready) {\n    return {\n      isSuccessful: true,\n      message: `App was already running (port ${port})`,\n    };\n  }\n\n  const action = (resolve: Pm2Resolver) => {\n    pm2.start(\n      {\n        time: true,\n        name: `${appPrefix}${operationName}`,\n        output: undefined,\n        error: undefined,\n        script: isDev ? \"yarn dev\" : \"yarn start\",\n        cwd: operationFolderPath,\n      },\n      (error, proc) => {\n        if (error) {\n          resolve({ isSuccessful: false, error });\n        }\n        resolve({ isSuccessful: true, proc });\n      }\n    );\n  };\n\n  const result = await pm2ConnectDisconnect(action);\n\n  return result;\n}"
  },
  "stopAllAppsExceptCli": {
    "name": "stopAllAppsExceptCli",
    "slug": "TsFunction",
    "id": "fpwxgyihmxofrhysriogkemn",
    "description": "Arguments: operation names that you don't want to stop",
    "operationName": "pm2-util",
    "rawText": " async () => {\n  const operationNames = process.argv.slice(2);\n  stopAllAppsExcept(operationNames);\n}"
  },
  "stopAllAppsExcept": {
    "name": "stopAllAppsExcept",
    "slug": "TsFunction",
    "id": "hsryirodcsbhprceehjjdslu",
    "description": "Stops all apps except some specified ones",
    "operationName": "pm2-util",
    "rawText": " async (\n  ignore: string[] = []\n): Promise<void> => {\n  const apps = await listApps();\n\n  console.dir({ appsLength: apps.apps?.length, apps: apps }, { depth: 200 });\n  if (!apps.isSuccessful || !apps.apps) {\n    log(`something is wrong with listApps`, { type: \"error\" });\n    return;\n  }\n\n  const appsToQuit = apps.apps\n    .filter((app) => {\n      if (!app.operationName) return;\n\n      return !ignore.includes(app.operationName);\n    })\n    .map((x) => x.operationName);\n\n  await stopApps(appsToQuit);\n\n  log(`Stopped ${appsToQuit.length} apps`, { type: \"success\" });\n}"
  },
  "stopAppsCli": {
    "name": "stopAppsCli",
    "slug": "TsFunction",
    "id": "adxjvjaznvserbgmssnrjrqw",
    "description": "Arguments\n- Operation Names to stop",
    "operationName": "pm2-util",
    "rawText": " async () => {\n  const operationNames = process.argv.slice(2);\n  const result = await stopApps(operationNames);\n  console.log({ result });\n}"
  },
  "stopApps": {
    "name": "stopApps",
    "slug": "TsFunction",
    "id": "jqxevnvqllifphxmtirpyecg",
    "description": "Stops an app with pm2\n\nTODO: for some reason i'm getting `TypeError: Cannot read properties of undefined (reading '_operate')` and I can't find why because all other commands mostly work and I'm doing it the same way.",
    "operationName": "pm2-util",
    "rawText": " async (operationNames: string[]) => {\n  return pm2ConnectDisconnect((resolve) => {\n    operationNames.map((operationName) => {\n      stop(`${appPrefix}${operationName}`, (error, proc) => {});\n    });\n\n    resolve({ isSuccessful: true });\n  });\n}"
  },
  "watchAllCli": {
    "name": "watchAllCli",
    "slug": "TsFunction",
    "id": "fjhqlkceyndocfsnshnpnogu",
    "description": "Runs `watchAll`.",
    "operationName": "watch-all",
    "rawText": " () => {\n  watchAll();\n}"
  },
  "watchAll": {
    "name": "watchAll",
    "slug": "TsFunction",
    "id": "jbwdnahtokqvbkdiccvjavkd",
    "description": "ðŸ‘ ðŸ‘ Finds all watchers within typerepo and ensures they all start watching their watch",
    "operationName": "watch-all",
    "rawText": " async (config?: {\n  /**\n   * Overwrite the default ignored behavior\n   */\n  customIgnored?: string[];\n}) => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n\n  // NB: fix to globally alter real fs in order to fix EMFile error that happens in TSMorph (see https://github.com/isaacs/node-graceful-fs)\n  gracefulFs.gracefulify(realFs);\n\n  console.log(\"Searching...\"); //\n  const tsFunctions = await db.get(\"TsFunction\");\n\n  const projectWatcherTsFunctions = tsFunctions.filter(\n    (x) => x.explicitTypeName === \"ProjectWatcher\"\n  );\n\n  const projectWatchers = projectWatcherTsFunctions\n    .map((x) => x.name)\n    .map((name) => sdk[name as keyof typeof sdk] as ProjectWatcher | undefined)\n    .filter(notEmpty);\n\n  log(`${projectWatchers.length} watchers gonna watch ${projectRoot}`, {\n    type: \"important\",\n  });\n\n  const startupWaitMs = 1000;\n  setTimeout(() => {\n    log(\n      `There they are! \\n\\n${projectWatchers\n        .map((projectWatcher) => {\n          return `ðŸ‘ ðŸ‘ ${projectWatcher.name} âœ…`;\n        })\n        .join(\"\\n\")}`,\n      {\n        type: \"success\",\n      }\n    );\n  }, startupWaitMs);\n\n  const startTimeAt = Date.now();\n\n  watch(projectRoot, {\n    ignoreInitial: true,\n    ignored: config?.customIgnored || [\n      \"**/node_modules/**\",\n      \"**/.next/**\",\n      \"**/.expo/**\",\n      // \"**/build/**\", // build change detection is needed for SDK generation\n      \"**/db/**\",\n      \"**/.git/**\",\n      \"**/.turbo/**\",\n      \"**/generated/**\",\n    ],\n    // alwaysStat: true, // not sure why I would need this, seems inefficient if I don't need it, I can simply run fs.stat\n  }).on(\"all\", (eventName, path, stats) => {\n    if (Date.now() < startTimeAt + startupWaitMs) return;\n\n    const relevantWatchers = projectWatchers.filter((watcher) =>\n      watcher.filter(eventName, path)\n    );\n\n    oneByOne(relevantWatchers, async (projectWatcher) => {\n      await projectWatcher(eventName, path);\n    });\n  });\n}"
  },
  "exitIfOperationsChange": {
    "name": "exitIfOperationsChange",
    "slug": "TsFunction",
    "id": "ixiqjecmrmtyieeviadebhug",
    "description": "every 5 seconds compares if the operationsourcepaths have changed. If so, exits the process",
    "operationName": "watch-operations",
    "rawText": " (\n  allOperationSourcePaths: string[],\n  manualProjectRoot?: string\n) => {\n  setInterval(async () => {\n    const newOperationSourcePaths = await getAllOperationSourcePaths({\n      manualProjectRoot,\n    });\n\n    const isSame = allOperationSourcePaths.reduce(\n      (same, p, i) => (newOperationSourcePaths[i] === p ? same : false),\n      true\n    );\n\n    //TODO: if you change a folder name, it's not detected now.\n    if (!isSame) {\n      log(\"ðŸ‘€ I detected a change in your operations, restarting\", {\n        type: \"warning\",\n      });\n      process.exit();\n    }\n  }, 5000);\n}"
  },
  "gitCommitAllCron": {
    "name": "gitCommitAllCron",
    "slug": "TsFunction",
    "id": "biblgjftqbxrirtdrfnskimh",
    "description": "const pushPosition = async () => {\nconst position = await getLocation();\nif (position) {\npush(\"Position\", {\n...position,\ncreatedAt: Date.now(),\nupdatedAt: Date.now(),\ncreatedFirstAt: Date.now(),\ndeletedAt: 0,\nid: generateId(),\n});\n}\n};\n\nconst pushLight = async () => {\nconst light = 1;\nif (light) {\npush(\"Light\", {\nid: generateId(),\ncreatedFirstAt: Date.now(),\ncreatedAt: Date.now(),\nupdatedAt: Date.now(),\ndeletedAt: 0,\nlight,\n});\n}\n};\n\nconst watchLocation = async () => {\npushPosition();\nsetInterval(() => {\npushPosition();\n}, 60000);\n};\n\nconst watchLight = async () => {\npushLight();\nsetInterval(() => {\npushLight();\n}, 60000);\n};",
    "operationName": "watch-operations",
    "rawText": " (manualProjectRoot?: string) => {\n  setInterval(() => {\n    try {\n      // NB: This doesn't work well with nested .git folders!\n      execSync(\n        \"[[ `git status --porcelain .` ]] && git add . && git commit -m 'Automatic commit'\",\n        { cwd: manualProjectRoot, stdio: \"inherit\" }\n      );\n    } catch {}\n  }, 1000 * 3600);\n}"
  },
  "watchOperations": {
    "name": "watchOperations",
    "slug": "TsFunction",
    "id": "evodhvolcxphnzjdybaianku",
    "description": "watches all operations and does much more",
    "operationName": "watch-operations",
    "rawText": " async (config?: {\n  /**\n   * manual project root where the operations to watch should be located\n   */\n  manualProjectRoot?: string;\n}) => {\n  const manualProjectRoot = config?.manualProjectRoot;\n  const projectRoot = manualProjectRoot || getProjectRoot();\n  // NB: fix to globally alter real fs in order to fix EMFile error that happens in TSMorph (see https://github.com/isaacs/node-graceful-fs)\n  gracefulFs.gracefulify(realFs);\n\n  const allOperationSourcePaths = await getAllOperationSourcePaths({\n    manualProjectRoot,\n  });\n\n  exitIfOperationsChange(allOperationSourcePaths, projectRoot);\n\n  if (!manualProjectRoot) {\n    gitCommitAllCron(projectRoot);\n  }\n\n  log(\n    `Hi, I'm ðŸ‘ ðŸ‘ Watching ${allOperationSourcePaths.length} operations at ${projectRoot}`,\n    { type: \"success\" }\n  );\n\n  const watchFunction = pickWatcher();\n\n  watchFunction({\n    folders: allOperationSourcePaths,\n    debug: true,\n    onChange: async ({ eventType, filePaths, operationBasePath }) => {\n      if (filePaths.length === 0) {\n        return;\n      }\n\n      const filteredFilePaths = filePaths.filter(\n        (x) => !x.endsWith(\"/index.ts\")\n      );\n\n      if (filteredFilePaths.length === 0) {\n        return;\n      }\n\n      log(\n        `OnChange triggered! ${filePaths\n          .map((f) => path.parse(f).name)\n          .join(\",\")}`,\n        {\n          type: \"warning\",\n        }\n      );\n\n      await rebuildOperation({\n        operationBasePath,\n        operationManualProjectRoot: manualProjectRoot,\n        typerepoManualProjectRoot: undefined,\n        filePaths: filteredFilePaths,\n      });\n    },\n  });\n}"
  },
  "brigtnessFull": {
    "name": "brigtnessFull",
    "slug": "TsFunction",
    "id": "bhamgpbmnppgbktphhvycnib",
    "description": "",
    "operationName": "brightness",
    "rawText": " (): boolean => {\n  Array(16)\n    .fill(0)\n    .map(() => increaseBrightness());\n  return true;\n}"
  },
  "brigtnessZero": {
    "name": "brigtnessZero",
    "slug": "TsFunction",
    "id": "opahpxejtxeenbpdusgolacu",
    "description": "",
    "operationName": "brightness",
    "rawText": " (): boolean => {\n  Array(16)\n    .fill(0)\n    .map(() => decreaseBrightness());\n  return true;\n}"
  },
  "decreaseBrightness": {
    "name": "decreaseBrightness",
    "slug": "TsFunction",
    "id": "mjabtwqdmonuldfbaxgpkklb",
    "description": "",
    "operationName": "brightness",
    "rawText": " (): boolean => {\n  execSync(\n    `osascript -e 'tell application \"System Events\"' -e 'key code 145' -e ' end tell'`\n  );\n  return true;\n}"
  },
  "increaseBrightness": {
    "name": "increaseBrightness",
    "slug": "TsFunction",
    "id": "ehxfgcehcoblyrcqxodvtgls",
    "description": "",
    "operationName": "brightness",
    "rawText": " (): boolean => {\n  execSync(\n    `osascript -e 'tell application \"System Events\"' -e 'key code 144' -e ' end tell'`\n  );\n  return true;\n}"
  },
  "macosSetup": {
    "name": "macosSetup",
    "slug": "TsFunction",
    "id": "rjkayquckqhnlziwzisyzonn",
    "description": "TODO: not sure how, but I need to run the install script at `./install.sh`",
    "operationName": "clean-macos-setup",
    "rawText": " (): void => {\n  console.log(\"Coming soon\");\n}"
  },
  "fileExplorerOpen": {
    "name": "fileExplorerOpen",
    "slug": "TsFunction",
    "id": "xptteiyheewbzrnjhqugymnh",
    "description": "",
    "operationName": "file-explorer-open",
    "rawText": " async (\n  projectRelativePath: string\n): Promise<{ isSuccessful: boolean; message: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return {\n      isSuccessful: false,\n      message: \"No projectroot\",\n    };\n  }\n\n  const absolutePath = path.join(projectRoot, projectRelativePath);\n\n  if (!absolutePath || !fs.existsSync(absolutePath)) {\n    return { isSuccessful: false, message: \"This path doesn't exist\" };\n  }\n\n  const pathStats = await fs.stat(absolutePath);\n\n  const folderPath = pathStats.isDirectory()\n    ? absolutePath\n    : path.parse(absolutePath).dir;\n\n  var isWindows = process.platform === \"win32\";\n\n  const command = isWindows ? `start ${folderPath}` : `open ${folderPath}`;\n\n  execSync(command);\n\n  return { isSuccessful: true, message: \"Opened\" };\n}"
  },
  "[musicFolderName]": {
    "name": "[musicFolderName]",
    "slug": "TsVariable",
    "id": "zvgvmjukrdnmqaaxzctzfkfo",
    "description": "",
    "operationName": "play-music"
  },
  "playMusic": {
    "name": "playMusic",
    "slug": "TsFunction",
    "id": "zlvkjfwtaqbaqneydvzppuxe",
    "description": "Please place your description here",
    "operationName": "play-music",
    "rawText": " ({\n  musicFolderName,\n}: {\n  musicFolderName: string;\n}): void => {\n  console.log(\"Going to play now\");\n  const assetsPath = getRootPath(\"assets\");\n  if (!assetsPath) {\n    console.log(\"Couldn't find assets path\");\n    return;\n  }\n  const folder = path.join(assetsPath, \"music\", musicFolderName);\n\n  if (!fs.existsSync(folder)) {\n    console.log(\n      `Please put your ${musicFolderName} music in ${folder} so it can be played.`\n    );\n    return;\n  }\n\n  execSync(\"find . -name '*.mp3' -exec afplay '{}' \\\\;\", {\n    cwd: folder,\n    stdio: \"inherit\",\n  });\n}"
  },
  "generateRecurringReminders": {
    "name": "generateRecurringReminders",
    "slug": "TsFunction",
    "id": "vsruwsbeqmykhuzopwpzvsjd",
    "description": "should create `remindersGenerated.json` based recurringreminders.json\n\nTODO: replace with FS ORM",
    "operationName": "reminders",
    "rawText": " () => {\n  const recurringRemindersPath = path.join(\n    __dirname,\n    \"..\",\n    \"recurringReminders.json\"\n  );\n  const recurringRemindersString = readFileSync(recurringRemindersPath, \"utf8\");\n  const recurringReminders = JSON.parse(\n    recurringRemindersString\n  ) as RecurringReminder[];\n  /////\n\n  const remindersGenerated = recurringReminders.reduce(\n    (all, recurringReminder) => {\n      //should find all reminders for today for every recurring one\n\n      const today = [] as Reminder[];\n      return all.concat(today);\n    },\n    [] as Reminder[]\n  );\n  const generatedRemindersPath = path.join(\n    __dirname,\n    \"..\",\n    \"remindersGenerated.json\"\n  );\n  writeFileSync(generatedRemindersPath, JSON.stringify(remindersGenerated), {\n    encoding: \"utf8\",\n  });\n}"
  },
  "remindMeAboutNextMinute": {
    "name": "remindMeAboutNextMinute",
    "slug": "TsFunction",
    "id": "mtewllenwmovqylxsygrtgnm",
    "description": "read out reminders.json\nif there's any reminder for this current minute\n- run `say`\n- play alarm mp3 sound\n\nTODO: replace fs orm",
    "operationName": "reminders",
    "rawText": " (): void => {\n  const remindersPath = path.join(__dirname, \"..\", \"reminders.json\");\n  const remindersString = readFileSync(remindersPath, \"utf8\");\n  const reminders = JSON.parse(remindersString) as Reminder[];\n  const currentDateTime = moment().format(\"D-M-YYYY H:m\");\n  const reminder = reminders.find((r) => r.datetime === currentDateTime);\n\n  if (!reminder) {\n    return;\n  }\n  say(reminder.reminder);\n  // todo\n  //playSound(\"alarm\")\n}"
  },
  "setRandomTimezone": {
    "name": "setRandomTimezone",
    "slug": "TsFunction",
    "id": "ddhlmbjvfdjdejashhdqmpyk",
    "description": "sets timezone to a random one so we won't know the time.\nWe can use one of the 440 timezones in timezones.md",
    "operationName": "set-random-timezone",
    "rawText": " (): void => {\n  const timezonesPath = path.join(__dirname, \"..\", \"timezones.md\");\n  const timezonesString = readFileSync(timezonesPath, \"utf8\");\n  const timezonesArray = timezonesString.split(\"\\n\");\n  const randomTimezoneIndex = Math.floor(\n    Math.random() * (timezonesArray.length - 1)\n  );\n  const timezone = timezonesArray[randomTimezoneIndex];\n  execSync(`sudo systemsetup -settimezone ${timezone}`);\n}"
  },
  "disableDarkMode": {
    "name": "disableDarkMode",
    "slug": "TsFunction",
    "id": "piohtwhxmunnnxbibxmogrvc",
    "description": "",
    "operationName": "toggle-dark-mode",
    "rawText": " (): boolean => {\n  execSync(setDarkmodeCommand(\"false\"));\n  return true;\n}"
  },
  "enableDarkMode": {
    "name": "enableDarkMode",
    "slug": "TsFunction",
    "id": "dqhugxdmzmvhagxbkrvyhrsz",
    "description": "",
    "operationName": "toggle-dark-mode",
    "rawText": " (): boolean => {\n  execSync(setDarkmodeCommand(\"true\"));\n  return true;\n}"
  },
  "setDarkmodeCommand": {
    "name": "setDarkmodeCommand",
    "slug": "TsFunction",
    "id": "lpobuskqymskeedbgrvmnosf",
    "description": "",
    "operationName": "toggle-dark-mode",
    "rawText": " (newValue: string) => {\n  return `osascript -e 'tell app \\\"System Events\\\" to tell appearance preferences to set dark mode to ${newValue}'`;\n}"
  },
  "toggleDarkMode": {
    "name": "toggleDarkMode",
    "slug": "TsFunction",
    "id": "crjlzpdsoosjpxjxfbawxjdn",
    "description": "",
    "operationName": "toggle-dark-mode",
    "rawText": " (): boolean => {\n  execSync(setDarkmodeCommand(\"not dark mode\"));\n  return true;\n}"
  },
  "disableScreenSleep2": {
    "name": "disableScreenSleep2",
    "slug": "TsFunction",
    "id": "aejhsctlgnnlrjlcanfattgn",
    "description": "",
    "operationName": "toggle-screen-sleep",
    "rawText": " () => {\n  execSync(`sudo pmset -a disablesleep 1`, { stdio: \"inherit\" });\n}"
  },
  "disableScreenSleep": {
    "name": "disableScreenSleep",
    "slug": "TsFunction",
    "id": "euggbwlufypmitdkyjylouyv",
    "description": "",
    "operationName": "toggle-screen-sleep",
    "rawText": " (administratorPassword: string) => {\n  execSync(\n    `echo \"${administratorPassword}\" | sudo -S pmset -a disablesleep 1`,\n    { stdio: \"inherit\" }\n  );\n}"
  },
  "enableScreenSleep": {
    "name": "enableScreenSleep",
    "slug": "TsFunction",
    "id": "jvhuvxynzrhydigqtlxveqxi",
    "description": "",
    "operationName": "toggle-screen-sleep",
    "rawText": " (administratorPassword: string) => {\n  execSync(\n    `echo '${administratorPassword}' | sudo -S pmset -a disablesleep 0`,\n    { stdio: \"inherit\" }\n  );\n}"
  },
  "[password]": {
    "name": "[password]",
    "slug": "TsVariable",
    "id": "vslkamktnvhpwniggfnxedxo",
    "description": "",
    "operationName": "toggle-screen-sleep"
  },
  "downVolume": {
    "name": "downVolume",
    "slug": "TsFunction",
    "id": "otgqcqlkgquidncfeefkilfs",
    "description": "",
    "operationName": "volume",
    "rawText": " (): void => {\n  const volume = (getVolume() / 100) * 7;\n  setVolume({ volume: volume - 1 });\n}"
  },
  "getVolume": {
    "name": "getVolume",
    "slug": "TsFunction",
    "id": "isdrmdtnnnmzmsleddismeql",
    "description": "needs to be tested",
    "operationName": "volume",
    "rawText": " () => {\n  const result = execSync(\n    `osascript -e \"output volume of (get volume settings)\"`,\n    { encoding: \"utf8\" }\n  );\n  const num = Number(result);\n  return num;\n}"
  },
  "setVolume": {
    "name": "setVolume",
    "slug": "TsFunction",
    "id": "wpaxrypkcvrjdldyvczrofen",
    "description": "- `setVolume` runs `sudo osascript -e \"set Volume {0-10}\"` or without sudo\n- `getVolume` runs `osascript -e \"output volume of (get volume settings)\"`\n- `up/downVolume` runs `getVolume` and `setVolume` for it to go up/down",
    "operationName": "volume",
    "rawText": " ({\n  volume,\n}: {\n  /**\n   * 0-7\n   */\n  volume: number;\n}): void => {\n  execSync(`osascript -e \"set Volume ${volume}\"`);\n}"
  },
  "upVolume": {
    "name": "upVolume",
    "slug": "TsFunction",
    "id": "oirrpdnphvtzqbdcuvjgczfl",
    "description": "",
    "operationName": "volume",
    "rawText": " (): void => {\n  const volume = (getVolume() / 100) * 7;\n  setVolume({ volume: volume + 1 });\n}"
  },
  "getOpenableFilePath": {
    "name": "getOpenableFilePath",
    "slug": "TsFunction",
    "id": "osogznachxnvbvxswduvfxyl",
    "description": "",
    "operationName": "vscode-open",
    "rawText": " async (\n  file: OpenableFile\n): Promise<string | undefined> => {\n  const projectRoot = getProjectRoot();\n\n  if (!projectRoot) return;\n\n  if (file.projectRelativePath)\n    return path.join(projectRoot, file.projectRelativePath);\n\n  if (!file.operationName || !file.operationRelativeFilePath) return;\n\n  const operationBasePath = await getOperationPath(file.operationName);\n  if (!operationBasePath) return;\n\n  const openableFilePath = nodePath.join(\n    operationBasePath,\n    file.operationRelativeFilePath\n  );\n\n  return openableFilePath;\n}"
  },
  "vscodeOpen": {
    "name": "vscodeOpen",
    "slug": "TsFunction",
    "id": "dukbytfeqpiqfaoquwninpri",
    "description": "opens a file in vscode through the \"code\" cli",
    "operationName": "vscode-open",
    "rawText": " async (config: {\n  /**\n  Files to open. Either use a projectRelativePath or an operationName combined with an operationRelativePath.\n  \n  can optionally have the line and character specified as well after the file with [file-path]:[line]:[character]\n   */\n  files?: OpenableFile[];\n}): Promise<undefined | { success: boolean; response: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n\n  if (!config.files) {\n    const command = `code --goto ${projectRoot}`;\n    execSync(command);\n    return { success: true, response: \"Opened the project root\" };\n  }\n\n  await Promise.all(\n    config.files.map(async (file) => {\n      const absolutePath = await getOpenableFilePath(file);\n\n      if (!absolutePath || !fs.existsSync(absolutePath)) {\n        return { success: false, response: \"This path doesn't exist\" };\n      }\n\n      const fullPathWithLine = file.line\n        ? `${absolutePath}:${file.line}`\n        : absolutePath;\n\n      const command = `code --goto ${fullPathWithLine}`;\n\n      execSync(command);\n\n      return { success: true, response: \"Opened the file\" };\n    })\n  );\n\n  return { success: true, response: \"Opened the file(s)\" };\n}"
  },
  "loginToDevto": {
    "name": "loginToDevto",
    "slug": "TsFunction",
    "id": "dmomjyeoqvmumpbauwbkyzoy",
    "description": "",
    "operationName": "dev-to-controller",
    "rawText": " async (devtoLoginProps: devtoLoginProps) => {\n  const { page, email, password } = devtoLoginProps;\n  // Wait for the login buttun to appear\n  await page.waitForSelector(\n    'a[class=\"c-link c-link--block mr-2 whitespace-nowrap ml-auto\"]'\n  );\n  // Click on the login button\n  await page.click(\n    'a[class=\"c-link c-link--block mr-2 whitespace-nowrap ml-auto\"]'\n  );\n\n  // wait for the email field to enter login crendentials\n  await page.waitForSelector(\"input[id=user_email]\");\n\n  // enter the email on the email field\n  await page.$eval(\n    \"input[id=user_email]\",\n    (elem: ElementType, args: any) => {\n      elem.value = args.email;\n    },\n    { email }\n  );\n\n  // enter the password on the password field\n  await page.$eval(\n    'input[id=\"user_password\"]',\n    (elem: ElementType, args: any) => {\n      elem.value = args.password;\n    },\n    { password }\n  );\n  // click submit button\n  await page.click(\"input[type=submit]\");\n}"
  },
  "publishBlogOnDevTo": {
    "name": "publishBlogOnDevTo",
    "slug": "TsFunction",
    "id": "qlmmkgkpuorqcmbclauezoni",
    "description": "This module is abe to publish post on the dev.to\nand return the blog url with success message",
    "operationName": "dev-to-controller",
    "rawText": " async (\n  credentials: PublishBlogDevtoPropsType,\n  options?: { dryrun?: boolean }\n): Promise<SocialMediaPostTypeReturnType> => {\n  const { email, password, title, content } = credentials;\n  const { dryrun } = options || {};\n  try {\n    const chromeExecutablePath = getChromeExecutablePath();\n    const browser = await puppeteer.launch({\n      headless: false,\n      executablePath: chromeExecutablePath,\n      // slowMo: 1\n    });\n\n    //@ts-ignore\n    const page: Page = await browser.newPage();\n    await page.goto(\"https://dev.to/\");\n\n    // Adding listener for console\n    page.on(\"console\", (message) => console.log(`${message.text()}`));\n\n    // login into dev to\n    await loginToDevto({ page, email, password });\n\n    // wait for create article button appear\n    await page.waitForSelector(\n      'a[class=\"c-cta c-cta--branded mr-2 whitespace-nowrap js-policy-article-create\"]'\n    );\n    // click on the click article button\n    await page.click(\n      'a[class=\"c-cta c-cta--branded mr-2 whitespace-nowrap js-policy-article-create\"]'\n    );\n    // typing data into the title field\n    await typeIntoTheField({\n      page,\n      selectorString: 'textarea[id=\"article-form-title\"]',\n      valueToType: title,\n    });\n    // wait for the post article editor\n    await page.waitForSelector('textarea[id=\"article-form-title\"]');\n    const titleArea = await page.$('textarea[id=\"article-form-title\"]');\n    if (!titleArea)\n      return { isSuccess: false, message: \"Title textarea not found\" };\n    // click focus and type the title on the title area\n    await titleArea.click();\n    await titleArea.focus();\n    await page.keyboard.type(title);\n    //wait for the descrition textarea to appear (TODO: direct insert value instead of typing to reduce time)\n    await page.waitForSelector('textarea[id=\"article_body_markdown\"]');\n    const descriptionArea = await page.$(\n      'textarea[id=\"article_body_markdown\"]'\n    );\n    if (!descriptionArea)\n      return { isSuccess: false, message: \"Description textarea not found\" };\n    // click,focus and enter description\n    await descriptionArea.click();\n    await descriptionArea.focus();\n    await page.keyboard.type(content);\n    await page.waitForSelector(\n      'button[class=\"c-btn c-btn--primary mr-2 whitespace-nowrap\"]'\n    );\n    // click on the post button\n    await page.click(\n      'button[class=\"c-btn c-btn--primary mr-2 whitespace-nowrap\"]'\n    );\n    // waiting for publish success and natigating to blog page\n    await page.waitForNavigation();\n    // taking url of current blog\n    if (!dryrun) {\n      // click on the post button\n      await page.click(\n        'button[class=\"c-btn c-btn--primary mr-2 whitespace-nowrap\"]'\n      );\n      await page.waitForNavigation();\n    }\n\n    const blogUrl = await page.url();\n    return {\n      isSuccess: true,\n      message: \"Blog Published succcessfully\",\n      postUrl: blogUrl,\n    };\n  } catch (e: Error | any) {\n    return { isSuccess: false, message: e?.message };\n  }\n}"
  },
  "typeIntoTheField": {
    "name": "typeIntoTheField",
    "slug": "TsFunction",
    "id": "igzcxzfnjcpgouylcmxucifz",
    "description": "",
    "operationName": "dev-to-controller",
    "rawText": " async (props: TypeInTheField) => {\n  const { page, selectorString, valueToType } = props;\n  // wait for the target area to appear\n  await page.waitForSelector(selectorString);\n  const targetedArea = await page.$(selectorString);\n  if (!targetedArea)\n    return { success: false, message: `${selectorString} not found` };\n  // click focus and type the title on the title area\n  await targetedArea.click();\n  await targetedArea.focus();\n  await page.keyboard.type(valueToType);\n}"
  },
  "facebookPostOnTheGroup": {
    "name": "facebookPostOnTheGroup",
    "slug": "TsFunction",
    "id": "gsvqzyqcyoeejplxmgcosufr",
    "description": "Taking content as params and posting the content on the specific facebook group",
    "operationName": "facebook-controller",
    "rawText": " async (\n  postParams: PublishPostPropsType,\n  options?: { dryrun?: boolean }\n): Promise<SocialMediaPostTypeReturnType> => {\n  const { page, post, groupName } = postParams;\n  const { dryrun } = options || {};\n  let groupUrl: string = \"\";\n  try {\n    // wait for the facebook home page (Group to appear) after login\n    await page.waitForFunction(\n      `document.querySelector(\"body\").innerText.includes(\"Live video\")`\n    );\n\n    // Navigate to page to group page\n    await page.goto(\"https://www.facebook.com/groups/feed/\");\n\n    // wait for groupname to load\n    await page.waitForFunction(\n      `document.querySelector(\"body\").innerText.includes(\"${groupName}\")`\n    );\n\n    // getting group by group name and clicking that group\n    const targetGroup = await page.$x(\n      `//span[text()=\"${groupName}\"]/ancestor::a`\n    );\n\n    console.log({ targetGroup });\n\n    if (targetGroup[0]) {\n      const url = await (await targetGroup[0].getProperty(\"href\")).jsonValue();\n      if (typeof url === \"string\") {\n        groupUrl = url;\n        await page.goto(`${groupUrl}`);\n      }\n    } else {\n      return {\n        isSuccess: false,\n        message: `Group name ${groupName} not found`,\n      };\n    }\n\n    // Click on the write something ...\n    const targetToClick = await page.$x(\n      '//span[contains(text(),\"Write something...\")]'\n    );\n\n    console.log(\"target to click\", targetToClick);\n\n    if (targetToClick[0]) {\n      const targetGrandParent = await targetToClick[0];\n      targetGrandParent.focus();\n      targetGrandParent.press(\"Enter\");\n    }\n\n    // await clickOnSpanTag({ page, spanText: 'Write something...' });\n\n    // waiting for the create post popup modal clicking the textarea fields\n    await typeInTheInputField({\n      page,\n      selector: 'div[aria-label=\"Create a public postâ€¦\"]',\n      value: post,\n    });\n\n    // clicking on the post button\n    await page.focus('div[aria-label=\"Post\"]');\n    if (!dryrun) {\n      await page.keyboard.press(\"Enter\");\n    }\n    return {\n      isSuccess: true,\n      message: `Group post on ${groupName} succcessfull`,\n      postUrl: groupUrl || \"\",\n    };\n  } catch (e: Error | any) {\n    return { isSuccess: false, message: e.message };\n  }\n}"
  },
  "facebookPost": {
    "name": "facebookPost",
    "slug": "TsFunction",
    "id": "qpfvzdzuthzcyfcjoqsglppt",
    "description": "Based on the params login into the facebook and call the `facebookPostOnTheGroup`\nif groupName is available otherwise call the `facebookTimeLinePost`",
    "operationName": "facebook-controller",
    "rawText": " async (\n  postParams: FacebookPostType,\n  options?: { dryrun?: boolean }\n): Promise<SocialMediaPostTypeReturnType> => {\n  const { email, password, post, groupName } = postParams;\n  const chromeExecutablePath = getChromeExecutablePath();\n  const browser = await puppeteer.launch({\n    headless: false,\n    executablePath: chromeExecutablePath,\n    slowMo: 1,\n    defaultViewport: {\n      width: 1000,\n      height: 1900,\n    },\n  });\n  //@ts-ignore\n  const page: Page = await browser.newPage();\n  await page.goto(\"https://facebook.com/\", { timeout: 60000 });\n  // Adding listener for console\n  page.on(\"console\", (message) => console.log(`${message.text()}`));\n\n  if (email) {\n    //facebook login\n    await facebookLogin({ email, password, page });\n    await page.waitForNavigation({ timeout: 60000 });\n    // const lastPostUrl = await getLatestFacebookPostUrl(page);\n    // console.log({ lastPostUrl });\n    if (postParams.groupName) {\n      return await facebookPostOnTheGroup({ post, groupName, page }, options);\n    } else {\n      return await facebookTimeLinePost({ post, page }, options);\n    }\n  }\n  return { isSuccess: false, message: \"facebook credential not found\" };\n}"
  },
  "facebookTimeLinePost": {
    "name": "facebookTimeLinePost",
    "slug": "TsFunction",
    "id": "kvnkgxjnqehznxlkbjtfvdqn",
    "description": "Taking content as params and posting the content on the facebook timeline page",
    "operationName": "facebook-controller",
    "rawText": " async (\n  postParams: PublishPostPropsType,\n  options?: { dryrun?: boolean }\n): Promise<SocialMediaPostTypeReturnType> => {\n  try {\n    const { page, post } = postParams;\n    // cling on the what's on your mind area to write the post and targetting span class of that content\n    await page.$eval(\n      'span[class=\"x1lliihq x6ikm8r x10wlt62 x1n2onr6\"]', // span class of what`s on your mind [User name]\n      (elem) => {\n        //@ts-ignore\n        elem.click();\n      }\n    );\n\n    // waiting for popup model to create post\n    await page.waitForSelector('div[class=\"notranslate _5rpu\"]');\n    const postElement = await page.$('div[class=\"notranslate _5rpu\"]');\n    console.log({ postElement });\n    await postElement?.focus();\n    await page.keyboard.type(post, { delay: 0 });\n    // writing the post\n    await page.waitForTimeout(500);\n    // getting and clicking on the post button\n    await page.$eval('div[aria-label=\"Post\"]', (elem) => {\n      console.log(\"Experimenatal button found\", elem);\n      //@ts-ignore\n      elem.click();\n    });\n    await page.waitForTimeout(10000);\n    const postUrl = await getLatestFacebookPostUrl(page);\n    return {\n      isSuccess: true,\n      message: \"facebook timeline post successfull\",\n      postUrl,\n    };\n  } catch (error: Error | any) {\n    console.error({ error });\n    return { isSuccess: false, message: error.message };\n  }\n}"
  },
  "getLatestFacebookPostUrl": {
    "name": "getLatestFacebookPostUrl",
    "slug": "TsFunction",
    "id": "whaovoubbsqtrtspronytike",
    "description": "",
    "operationName": "facebook-controller",
    "rawText": " async (page: Page): Promise<string> => {\n  const pageUrl = await page.url();\n\n  if (pageUrl !== \"https://www.facebook.com/\") {\n    await page.goto(\"https://facebook.com/\");\n  }\n\n  // targeting main div of sidebar menu and click second item i.e profile icon\n  const profileUrl = await new Promise((resolve) => {\n    return resolve(\n      page.$$eval('div[class=\"x78zum5 x1nhvcw1 x1n2onr6 xh8yej3\"]', (elem) => {\n        // console.log({ elem });\n        const profileUrl = elem[1]\n          ?.getElementsByTagName(\"a\")[0]\n          .getAttribute(\"href\");\n        console.log({ profileUrl });\n        return profileUrl;\n      })\n    );\n  });\n\n  if (!profileUrl) {\n    return \"Profile URL not found\";\n  }\n\n  // navigating the page profile in grid view to get post url\n  await page.goto(`${profileUrl}/grid`);\n  await page.keyboard.press(\"Enter\");\n  await page.evaluate(() => {\n    window.scrollBy(0, 700);\n  });\n\n  // targeting the main div class of grid view post to get post url\n  await page.waitForSelector(\n    'div[class=\"x9f619 x78zum5 x1r8uery xdt5ytf x1iyjqo2 xs83m0k x150jy0e x1e558r4 xjkvuk6 x1iorvi4 xnpuxes\"]'\n  );\n  const postUrl: string = await new Promise((resolve) => {\n    resolve(\n      page.$eval(\n        'div[class=\"x9f619 x78zum5 x1r8uery xdt5ytf x1iyjqo2 xs83m0k x150jy0e x1e558r4 xjkvuk6 x1iorvi4 xnpuxes\"]',\n        (post) => {\n          const url: string =\n            post.getElementsByTagName(\"a\")[0].getAttribute(\"href\") || \"\";\n          return url;\n        }\n      )\n    );\n  });\n\n  return postUrl;\n}"
  },
  "sendFacebookMessage": {
    "name": "sendFacebookMessage",
    "slug": "TsFunction",
    "id": "eushcyqqnczdyfjrsgvrrlpu",
    "description": "sending message to the specific user",
    "operationName": "facebook-controller",
    "rawText": " async (\n  credentials: SendFacebookMessagePropsType,\n  options?: { dryrun?: boolean }\n) => {\n  const { email, password, username, message } = credentials;\n  const { dryrun } = options || {};\n  try {\n    const browser = await puppeteer.launch({\n      headless: false,\n      slowMo: 1,\n      args: [`--window-size=1200`],\n    });\n\n    //@ts-ignore\n    const page: Page = await browser.newPage();\n    await page.goto(\"https://facebook.com/\");\n    // Adding listener for consol\n    page.on(\"console\", (message) => console.log(`${message.text()}`));\n    await facebookLogin({ email, password, page });\n    // waiting for homepage to load\n    await page.waitForSelector('a[aria-label=\"Facebook\"]');\n    // navigation to the frient list page\n    await page.goto(\"https://www.facebook.com/friends/list\");\n    await page.waitForSelector('input[placeholder=\"Search Friends\"]');\n\n    // Clicking and typing the username to search\n    await typeInTheInputField({\n      page,\n      selector: 'input[placeholder=\"Search Friends\"]',\n      value: username,\n    });\n    await page.keyboard.press(\"Enter\");\n    // waiting for 3sec to load the earch result\n    await page.waitForTimeout(3000);\n    //getting targeted user\n    const targetedUser = await page.$x(\n      `//span[text()=\"${username}\"]/ancestor::a`\n    );\n    if (targetedUser[0]) {\n      const userUrl = await (\n        await targetedUser[0].getProperty(\"href\")\n      ).jsonValue();\n      await page.goto(`${userUrl}`);\n    } else {\n      return { success: false, message: \"User not found\" };\n    }\n\n    // waiting and clicking for user profile load and appear message button\n    await page.waitForSelector('div[aria-label=\"Message\"]');\n    await page.focus('div[aria-label=\"Message\"]');\n    await page.keyboard.press(\"Enter\");\n\n    // waiting for chat box to appear\n    await page.waitForFunction(\n      `document.querySelector(\"body\").innerText.includes(\"Write to ${username}\")`,\n      { timeout: 30000 }\n    );\n\n    await page.$x(\n      `//div[text()=\"Write to ${username}\"]/following-sibling::div[1]/div/div/div`\n    );\n    //Typing the message on text textbox\n    await page.keyboard.type(message);\n    //pressing Enter to send message\n    if (!dryrun) {\n      await page.keyboard.press(\"Enter\");\n    }\n\n    // browser.close();\n    return {\n      success: true,\n      message: \"Message send successfully succcessfully\",\n    };\n  } catch (e: Error | any | unknown) {\n    return { success: false, message: e.message };\n  }\n}"
  },
  "searchAndDownloadGifs": {
    "name": "searchAndDownloadGifs",
    "slug": "TsFunction",
    "id": "xhhtgurbviweoilrvyydgbhk",
    "description": "This operation able to search and download gif from giphy.com",
    "operationName": "gif-controller",
    "rawText": " async (\n  { searchKey }: { searchKey: string },\n  options: { dryrun: boolean }\n) => {\n  const { dryrun } = options || {};\n  try {\n    const chromeExecutablePath = getChromeExecutablePath();\n    const browser = await puppeteer.launch({\n      headless: false,\n      // slowMo: 250, // slow down by 250ms\n      // devtools: true,\n      args: [`--window-size=1920,1080`],\n      executablePath: chromeExecutablePath,\n      defaultViewport: {\n        width: 1920,\n        height: 1080,\n      },\n    });\n\n    //@ts-ignore\n    const page: Page = await browser.newPage();\n\n    // go to the signin page\n    await page.setExtraHTTPHeaders({\n      \"accept-language\": \"en-US,en;q=0.9,hy;q=0.8\",\n    });\n\n    await page.goto(\"https://giphy.com/\");\n    await page.setBypassCSP(true);\n    await typeInTheInputField({\n      page,\n      selector: 'input[data-tid=\"search-bar__input\"]',\n      value: searchKey,\n    });\n    await page.keyboard.press(\"Enter\");\n    await page.waitForNavigation();\n    await page.waitForSelector('img[class=\"giphy-gif-img giphy-img-loaded\"]');\n    await page.waitForTimeout(3000);\n    const allImgs = await page.$$(\n      'img[class=\"giphy-gif-img giphy-img-loaded\"]'\n    );\n    const result = [];\n    for await (let imgElement of allImgs) {\n      const url = await (await imgElement.getProperty(\"src\")).jsonValue();\n      result.push(url);\n    }\n    return {\n      success: true,\n      message: \"Search gif succcessfull\",\n      gifList: result,\n    };\n  } catch (e: Error | any) {\n    return { success: false, message: e?.message };\n  }\n}"
  },
  "buildQuery": {
    "name": "buildQuery",
    "slug": "TsFunction",
    "id": "hiagcilqbeofrukglewliqbc",
    "description": "Build query url for google translation",
    "operationName": "google-translate-controller",
    "rawText": " (opt: Query): string => {\n  const { text, to, op } = opt;\n  const from: string = opt.from || \"auto\";\n  if (opt.op === \"translate\" && text) {\n    if (text.length > 5000) return errTextOverflow(text.length);\n    if (text.length === 0) return errTextLenZero();\n  }\n  return `?text=${encodeURIComponent(text || \"\")}&sl=${from}&tl=${to}&op=${op}`;\n}"
  },
  "errArrayLenZero": {
    "name": "errArrayLenZero",
    "slug": "TsFunction",
    "id": "afrxnkrkekxcffxnsezaferf",
    "description": "",
    "operationName": "google-translate-controller",
    "rawText": " (): never => {\n  throw new Error(\"Expected one or more element, received none\");\n}"
  },
  "errFileSize": {
    "name": "errFileSize",
    "slug": "TsFunction",
    "id": "agslbyplvnelcirxesscjkeh",
    "description": "",
    "operationName": "google-translate-controller",
    "rawText": " (): never => {\n  throw new Error(\"Document size exceeds 10MB\");\n}"
  },
  "errFileType": {
    "name": "errFileType",
    "slug": "TsFunction",
    "id": "melwsrrldudbiimnzollinyh",
    "description": "",
    "operationName": "google-translate-controller",
    "rawText": " (type: string): never => {\n  throw new Error(`Extension .${type} not supported`);\n}"
  },
  "errInvalidType": {
    "name": "errInvalidType",
    "slug": "TsFunction",
    "id": "vlzvlsbtsdugvyassjnvhhbq",
    "description": "",
    "operationName": "google-translate-controller",
    "rawText": " (type: string): never => {\n  throw new Error(`Expected string or string array, received ${type}`);\n}"
  },
  "errTextLenZero": {
    "name": "errTextLenZero",
    "slug": "TsFunction",
    "id": "wcgwwajhxisgmqqbjvxuzvqa",
    "description": "",
    "operationName": "google-translate-controller",
    "rawText": " (): never => {\n  throw new Error(\"Expected one or more character, received none\");\n}"
  },
  "errTextOverflow": {
    "name": "errTextOverflow",
    "slug": "TsFunction",
    "id": "tnvkyvbmipzukhtmklgkmhok",
    "description": "",
    "operationName": "google-translate-controller",
    "rawText": " (len: number): never => {\n  throw new Error(`Expected <= 5000 characters, received ${len}`);\n}"
  },
  "generateArrayFromJson": {
    "name": "generateArrayFromJson",
    "slug": "TsFunction",
    "id": "mpmjsjtnjleihngqveeiwrdd",
    "description": "Parsing and generating 10000 most used words",
    "operationName": "google-translate-controller",
    "rawText": " () => {\n  const readStream = fs.createReadStream(\n    \"/home/bhagya/workspace/dt-control/controllers/google-translate-controller/data/english-words.json\"\n  );\n  const parseStream = json.createParseStream();\n  let parsedArray: any[] = [];\n  parseStream.on(\n    \"data\",\n    (data: { [key: string]: { count: number; word: string } }) => {\n      parsedArray = Object.values(data)\n        .slice(0, 10000)\n        .map((obj: { word: string; count: number }, idx: number) => ({\n          en: obj.word,\n          index: idx,\n        }));\n      fs.writeFileSync(\n        `${__dirname}/../../data/result.json`,\n        JSON.stringify(parsedArray)\n      );\n    }\n  );\n  readStream.pipe(parseStream);\n}"
  },
  "getStringForTranslation": {
    "name": "getStringForTranslation",
    "slug": "TsFunction",
    "id": "rkvujqfmotmeszlpeowmeqan",
    "description": "Getting 4500 charactors long sententce with new line on every word",
    "operationName": "google-translate-controller",
    "rawText": " (): StringTranslationType => {\n  const allArrayStringFromat = fs.readFileSync(\n    `${__dirname}/../../data/result.json`,\n    {\n      encoding: \"utf-8\",\n    }\n  );\n\n  const jsonArrayObject: WordType[] = JSON.parse(allArrayStringFromat);\n\n  const allTranslatedWords = fs.readFileSync(\n    `${__dirname}/../../data/translatedWords.json`,\n    {\n      encoding: \"utf-8\",\n    }\n  );\n\n  const translatedJsonArray: WordType[] = JSON.parse(allTranslatedWords);\n\n  let translationString = \"\";\n  let endIndex = 0;\n  for (\n    let i = translatedJsonArray.length;\n    translatedJsonArray.length <= jsonArrayObject.length;\n    i++\n  ) {\n    translationString = `${translationString}\\n${jsonArrayObject[i]?.en}`;\n    if (translationString.length >= 4500) {\n      endIndex = i;\n      break;\n    }\n  }\n  return {\n    wordsArray: jsonArrayObject.slice(translatedJsonArray.length, endIndex),\n    string: translationString,\n    startIndex: translatedJsonArray.length,\n    endIndex: endIndex,\n    isCompleted: jsonArrayObject.length === translatedJsonArray.length,\n  };\n}"
  },
  "launch": {
    "name": "launch",
    "slug": "TsFunction",
    "id": "medsuapcuqqiotusgyvucwmy",
    "description": "Launch the browser for open page",
    "operationName": "google-translate-controller",
    "rawText": " async (\n  /** check type interface for doc comments */\n  opt: PuppeteerOptions\n): Promise<{\n  browser: puppeteer.Browser;\n  page: puppeteer.Page;\n  timeout: number;\n}> => {\n  const browser = await puppeteer.launch({\n    headless: opt.headless === null ? true : opt.headless,\n    executablePath: \"/usr/bin/google-chrome-stable\",\n  });\n  const [page] = await browser.pages();\n  const timeout: number = opt.timeout === null ? 10000 : opt.timeout || 0;\n  return { browser, page, timeout };\n}"
  },
  "startTranslation": {
    "name": "startTranslation",
    "slug": "TsFunction",
    "id": "vauryldfdgqksmkbrtkpjikc",
    "description": "Getting translated keyvalue josn file and start translate in different languages",
    "operationName": "markdown-translator",
    "rawText": " async (\n  markdownPath: string,\n  keyValueWords: any\n) => {\n  const translationResponse = await new Promise(async (resolve, reject) => {\n    const { wordsArray, markdownString } =\n      parseMarkdownWordByWord(markdownPath);\n    const { fileLocation, fileName, fileType } = getFileInfo(markdownPath);\n\n    const markdownResult = wordsArray\n      .map((ew) => keyValueWords[ew.toLocaleLowerCase()]?.ne || ew)\n      .join(\" \");\n\n    // Todo: convert all conversion in one promise or wrap in one function\n    const { isSuccess: isEnglishSuccess } = await markdownStoreAndRecord(\n      { fileLocation, fileName, fileType, fullPath: markdownPath },\n      { markdownString, language: \"en\" }\n    );\n    const { isSuccess: isNepaliSuccess } = await markdownStoreAndRecord(\n      { fileLocation, fileName, fileType, fullPath: markdownPath },\n      { markdownString: markdownResult, language: \"np\" }\n    );\n\n    if (isNepaliSuccess && isEnglishSuccess) {\n      console.log(`${markdownPath}  âœ…`);\n      resolve({ isSuccess: true });\n    } else {\n      console.log(`${markdownPath} âŒ`);\n      resolve({ isSuccess: false });\n    }\n  });\n  return translationResponse;\n}"
  },
  "storeResult": {
    "name": "storeResult",
    "slug": "TsFunction",
    "id": "kpnkppclxurccckaqvstacna",
    "description": "Storing the result after the translation on the `translatedWords.json` file",
    "operationName": "google-translate-controller",
    "rawText": " (\n  translatedWords: string[],\n  lang: string,\n  startIndex: number,\n  endIndex: number | null,\n  wordsArray: WordType[]\n) => {\n  console.log({ wordsArray, lang, startIndex, endIndex });\n  const allTranslatedWords = fs.readFileSync(\n    `${__dirname}/../../data/translatedWords.json`,\n    {\n      encoding: \"utf-8\",\n    }\n  );\n  const translatedJsonArray: WordType[] = JSON.parse(allTranslatedWords);\n  const wordsNeedToInsert = wordsArray.map((w, idx) => ({\n    ...w,\n    ne: translatedWords[idx],\n  }));\n  fs.writeFileSync(\n    `${__dirname}/../../data/translatedWords.json`,\n    JSON.stringify([...translatedJsonArray, ...wordsNeedToInsert])\n  );\n}"
  },
  "translateText": {
    "name": "translateText",
    "slug": "TsFunction",
    "id": "hgvllehpjeqpvdfnzlifrezk",
    "description": "This operation able to translate one langauge to another language",
    "operationName": "google-translate-controller",
    "rawText": " async (\n  text: string,\n  opt: Options\n): Promise<string[]> => {\n  const query = buildQuery({\n    text,\n    to: opt.to,\n    from: opt.from,\n    op: \"translate\",\n  });\n  const { browser, page, timeout } = await launch({\n    headless: opt.headless,\n    timeout: opt.timeout,\n  });\n  try {\n    await page.goto(\"https://translate.google.com/\" + query);\n    // modification to support multiline transalted texts\n    const allTranslatedPrimaryElement = await page.$$(\n      \"span>span>span[jsaction]\"\n    );\n    const primaryResult = [];\n\n    for await (let pe of allTranslatedPrimaryElement) {\n      const textString = await (await pe.getProperty(\"innerHTML\"))?.jsonValue();\n      if (textString) {\n        primaryResult.push(textString);\n      }\n    }\n    console.log({ primaryResult });\n    // kO6q6e\n    await page.waitForSelector('div[class=\"eyKpYb\"]');\n    await page.waitForSelector('div[class=\"kO6q6e\"]');\n    const translatedSecondaryElement = await page.$$('div[class=\"kO6q6e\"]');\n    await page.waitForTimeout(2000);\n    let secondaryResult0: string | any =\n      (await (\n        await translatedSecondaryElement[0]?.getProperty(\"innerHTML\")\n      )?.jsonValue()) || \"\";\n    let secondaryResult: string | any =\n      (await (\n        await translatedSecondaryElement[1]?.getProperty(\"innerHTML\")\n      )?.jsonValue()) || \"\";\n    const finalSecondaryResult = secondaryResult.split(\"\\n\");\n    return finalSecondaryResult || primaryResult;\n  } catch (err) {\n    throw err;\n  } finally {\n    await browser.close();\n  }\n}"
  },
  "sendMail": {
    "name": "sendMail",
    "slug": "TsFunction",
    "id": "rflwyhgipnummiamgjktcmom",
    "description": "Sends email(s) using sendgrid\n\nEnsure your OS config is there",
    "operationName": "mail",
    "rawText": " async (\n  mailData: MailDataFromOptional | MailDataFromOptional[],\n  isMultiple?: boolean\n): Promise<ClientResponse | undefined> => {\n  const persona = await getPrimaryPersona();\n\n  if (!persona) {\n    return;\n  }\n\n  const { sendgridApiKey, sendgridFromEmail } = persona;\n\n  if (!sendgridApiKey) {\n    console.log(\"Please setup your Sendgrid credentials first\");\n    return;\n  }\n\n  const realMailData: MailDataRequired[] = makeArray(mailData)\n    .map((data) => {\n      const { from: dataFrom, ...otherData } = data;\n\n      const from = dataFrom || sendgridFromEmail;\n\n      if (!from) {\n        console.log(\n          \"From is missing in email and also not present in OsConfig. Please provide at least one of those. Not sending email!\"\n        );\n        return;\n      }\n\n      // NB: it's a bit ugly, but doesn't work without typecast, and i'm pretty sure the type is correct...\n      const mailData = { from, ...otherData } as MailDataRequired;\n\n      return mailData;\n    })\n    .filter(notEmpty);\n\n  sgMail.setApiKey(sendgridApiKey);\n\n  const result = await sgMail\n    .send(realMailData, isMultiple)\n    .then(([result]) => {\n      return result;\n    })\n    .catch((error: ResponseError) => {\n      console.log(\"Error sending email\", { error });\n\n      return undefined;\n    });\n\n  return result;\n}"
  },
  "LoginType": {
    "name": "LoginType",
    "slug": "TsVariable",
    "id": "msofpkgdagdxnctmcjtqalob",
    "description": "",
    "operationName": "medium-controller"
  },
  "publishBlogOnMedium": {
    "name": "publishBlogOnMedium",
    "slug": "TsFunction",
    "id": "eakkfqknaeyfjiclqzkfqxyu",
    "description": "",
    "operationName": "medium-controller",
    "rawText": " async (\n  credentials: PublishBlogPropsType,\n  options?: { dryrun?: boolean }\n): Promise<SocialMediaPostTypeReturnType> => {\n  const { dryrun } = options || {};\n  const { email, password, title, content, loginWith } = credentials;\n  try {\n    const chromeExecutablePath = getChromeExecutablePath();\n    const browser = await puppeteer.launch({\n      headless: false,\n      // slowMo: 250, // slow down by 250ms\n      // devtools: true,\n      args: [`--window-size=1920,1080`],\n      executablePath: chromeExecutablePath,\n      // userDataDir: \"./medium_session_data\",\n      // dumpio: true,\n      defaultViewport: {\n        width: 1920,\n        height: 1080,\n      },\n    });\n    //@ts-ignore\n    const page: Page = await browser.newPage();\n    // go to the signin page\n    await page.setExtraHTTPHeaders({\n      \"accept-language\": \"en-US,en;q=0.9,hy;q=0.8\",\n    });\n\n    await page.goto(\"https://medium.com/m/signin\");\n    await page.setBypassCSP(true);\n    // Adding listener for console\n    page.on(\"console\", (message) => console.log(`${message.text()}`));\n    // wait for the sign in page load with \"Welcome back\" text\n\n    // waiting for chat box to appear\n    await page.waitForFunction(\n      `document.querySelector(\"body\").innerText.includes(\"Sign in with Google\")`,\n      { timeout: 30000 }\n    );\n\n    const targetLoginElement = await page.$x(\n      `//div[contains(text(), \"${LoginType[loginWith || \"gmail\"]}\")]`\n    );\n    if (targetLoginElement[0]) {\n      //@ts-ignore\n      await targetLoginElement[0].click();\n    }\n\n    await page.waitForNavigation();\n    // login with the facebook\n    if (email && password) {\n      if (loginWith === \"gmail\") {\n        await gmailLogin({ page, email, password });\n      } else {\n        await facebookLogin({ email, password, page });\n      }\n    }\n\n    await page.waitForNavigation();\n    // goto to page to write new blog\n    await page.goto(\"https://medium.com/new-story\");\n\n    // Finding clicking and setting the title of the article on the title field\n    const titleSpan = await page.$x(\"//section/div/div/h3/span\");\n    //@ts-ignore\n    await titleSpan[0].click();\n    await titleSpan[0].focus();\n\n    // setting title of the blog\n    await setInnerHtml({\n      page,\n      selector:\n        'h3[class=\"graf graf--h3 graf--leading graf--title is-selected\"]',\n      value: title,\n    });\n\n    // Finding clicking and setting the description of the article on the description field\n    const descriptionSpan = await page.$x(\"//section/div/div/p/span\");\n    //@ts-ignore\n    await descriptionSpan[0].click();\n    await descriptionSpan[0].focus();\n    // setting content of the blog\n    await setInnerHtml({\n      page,\n      selector:\n        'p[class=\"graf graf--p graf-after--h3 graf--trailing is-selected\"]',\n      value: content,\n    });\n\n    // waiting for publish button activate and click\n    await page.waitForSelector(\n      'button[class=\"button button--primary button--filled button--smaller button--withChrome u-accentColor--buttonNormal button--publish js-publishButton js-buttonRequiresPostId u-paddingLeft10 u-paddingRight10 button--chromeless js-buttonDisabledPrimary\"]'\n    );\n\n    await page.click(\n      'button[class=\"button button--primary button--filled button--smaller button--withChrome u-accentColor--buttonNormal button--publish js-publishButton js-buttonRequiresPostId u-paddingLeft10 u-paddingRight10 button--chromeless js-buttonDisabledPrimary\"]'\n    );\n\n    if (!dryrun) {\n      // waiting for publish now button and click\n      console.log(\"inside the dryrun condition\");\n      await page.waitForSelector(\n        'button[class=\"button button--primary button--filled button--withChrome u-accentColor--buttonNormal js-publishButton\"]'\n      );\n      await page.focus(\n        'button[class=\"button button--primary button--filled button--withChrome u-accentColor--buttonNormal js-publishButton\"]'\n      );\n      await page.keyboard.press(\"Enter\");\n      console.log(\"publish button clicked\");\n      await page.waitForNavigation();\n    }\n\n    const blogUrl = await page.url();\n    return {\n      isSuccess: true,\n      message: \"Blog Published succcessfully\",\n      postUrl: blogUrl,\n    };\n  } catch (e: Error | any) {\n    return { isSuccess: false, message: e?.message };\n  }\n}"
  },
  "publishBlogOnReddit": {
    "name": "publishBlogOnReddit",
    "slug": "TsFunction",
    "id": "zvqdkzlxtugcvvdcetbmaolr",
    "description": "",
    "operationName": "reddit-controller",
    "rawText": " async (\n  credentials: PublishRedditBlogPropsType,\n  options?: { dryrun?: boolean }\n): Promise<SocialMediaPostTypeReturnType> => {\n  const { email, password, title, content, username, groupName } = credentials;\n  const { dryrun } = options || {};\n  try {\n    const chromeExecutablePath = getChromeExecutablePath();\n    const browser = await puppeteer.launch({\n      headless: false,\n      executablePath: chromeExecutablePath,\n      slowMo: 1, // slow down by 250ms\n      // devtools: true\n    });\n    //@ts-ignore\n    const page: Page = await browser.newPage();\n    await page.goto(\"https://reddit.com/login/\");\n    // Adding listener for console\n    page.on(\"console\", (message) => console.log(`${message.text()}`));\n\n    // wait for the login form to appear\n    await page.waitForSelector('form[class=\"AnimatedForm\"]');\n    // typing the login username\n    await setInputValue({\n      page,\n      selector: 'input[name=\"username\"]',\n      inputValue: username,\n    });\n\n    // typing pasword on the password field name=\"password\"\n    await setInputValue({\n      page,\n      selector: 'input[name=\"password\"]',\n      inputValue: password,\n    });\n    // clicking the submit button test\n    await page.click('button[type=\"submit\"]');\n    // wait for the creatpost input field appear\n    await page.waitForSelector('input[name=\"createPost\"]');\n    // goto the write article page\n    await page.goto(\"https://www.reddit.com/submit\");\n    // clicking and typing the group name\n    await typeInTheInputField({\n      page,\n      value: groupName,\n      selector: 'input[class=\"_1MHSX9NVr4C2QxH2dMcg4M\"]',\n    });\n    await page.keyboard.press(\"Enter\");\n    await page.waitForNavigation();\n    // clicking and typing the title of the article\n    await typeInTheInputField({\n      page,\n      value: title,\n      selector: 'textarea[placeholder=\"Title\"]',\n    });\n    // clicking and typing the content of the article on the content field\n    await typeInTheInputField({\n      page,\n      value: content,\n      selector: 'div[class=\"notranslate public-DraftEditor-content\"',\n    });\n    // wait and click on post button\n    await page.waitForSelector(\n      'button[class=\"_18Bo5Wuo3tMV-RDB8-kh8Z _2iuoyPiKHN3kfOoeIQalDT _10BQ7pjWbeYP63SAPNS8Ts HNozj_dKjQZ59ZsfEegz8 \"]'\n    );\n\n    if (!dryrun) {\n      await page.waitForTimeout(2000);\n      const postButtonElem = await page.$x(`//button[contains(text(),\"Post\")]`);\n      postButtonElem.forEach(async (a) => {\n        const postText = await (await a.getProperty(\"innerHTML\")).jsonValue();\n        if (postText === \"Post\") {\n          await a.focus();\n          await a.press(\"Enter\");\n        }\n      });\n      // waiting for post success\n      await page.waitForNavigation();\n    }\n\n    // taking the url of the posted blog\n    const blogUrl = await page.url();\n    return {\n      isSuccess: true,\n      message: \"Blog Published successfully\",\n      postUrl: blogUrl,\n    };\n  } catch (e: Error | any) {\n    return { isSuccess: false, message: e?.message };\n  }\n}"
  },
  "sendSms": {
    "name": "sendSms",
    "slug": "TsFunction",
    "id": "wzxbupnylmfgyafqgxjoervj",
    "description": "Send sms\n\nRequires OS Config to have Twilio sid and auth token.\n\nReqruired options: `to` and `body`\n\n`to` is not required, but will overwrite the one you specified in your `OsConfig`",
    "operationName": "sms",
    "rawText": " async (\n  options: MessageListInstanceCreateOptions\n): Promise<MessageInstance | undefined> => {\n  const { from: optionsFrom, ...otherOptions } = options;\n\n  const persona = await getPrimaryPersona();\n\n  if (!persona) {\n    return;\n  }\n\n  const { twilioAccountSid, twilioAuthToken, twilioFromPhoneNumber } = persona;\n\n  if (!twilioAccountSid || !twilioAuthToken) {\n    console.log(\"Please setup your Twilio credentials first\");\n    return;\n  }\n  const twilioClient = twilio(twilioAccountSid, twilioAuthToken);\n\n  const from = optionsFrom || twilioFromPhoneNumber;\n\n  if (!from) {\n    console.log(\n      \"Please provide a phonenumber to sent from, either in your OsConfig or in the sendSms options\"\n    );\n    return;\n  }\n\n  const message = await twilioClient.messages\n    .create({ from, ...otherOptions })\n    .catch((reason) => {\n      console.log(\"Sending sms failed\", { reason });\n\n      return undefined;\n    });\n\n  return message;\n}"
  },
  "getTwitterPostUrl": {
    "name": "getTwitterPostUrl",
    "slug": "TsFunction",
    "id": "pbhilgcquupnbxurelvqiaed",
    "description": "",
    "operationName": "twitter-controller",
    "rawText": " async (page: Page): Promise<string> => {\n  await page.waitForSelector('a[aria-label=\"Profile\"]');\n  await page.$eval('a[aria-label=\"Profile\"]', (profileElem) => {\n    //@ts-ignore\n    profileElem.click();\n  });\n  await page.waitForSelector('article[role=\"article\"]');\n  const postUrl: string = await new Promise((resolve) => {\n    resolve(\n      page.$eval('article[role=\"article\"]', (post) => {\n        const allAnchorTagWithinArticle = post.getElementsByTagName(\"a\");\n        const url: string =\n          allAnchorTagWithinArticle[3].getAttribute(\"href\") || \"\";\n        return url;\n      })\n    );\n  });\n\n  return postUrl;\n}"
  },
  "postTweetOnTwitter": {
    "name": "postTweetOnTwitter",
    "slug": "TsFunction",
    "id": "iewiexetvrqjjhrqhnbhaoow",
    "description": "This module is responsible for posting the tweet on the twitter",
    "operationName": "twitter-controller",
    "rawText": " async (\n  credentials: PublishTweetPropsType,\n  options?: { dryrun?: boolean }\n): Promise<SocialMediaPostTypeReturnType> => {\n  const { email, password, phoneNo, tweetMessage } = credentials;\n  const { dryrun } = options || {};\n  try {\n    const chromeExecutablePath = getChromeExecutablePath();\n    const browser = await puppeteer.launch({\n      headless: false,\n      executablePath: chromeExecutablePath,\n    });\n\n    //@ts-ignore\n    const page: Page = await browser.newPage();\n\n    await twitterLogin({ email, password, phoneNo, page });\n\n    // typing tweet message...\n    await typeInTheInputField({\n      page,\n      selector: 'div[aria-label=\"Tweet text\"]',\n      value: tweetMessage,\n    });\n    if (!dryrun) {\n      // waiting and clicking on the tweet button\n      await page.waitForSelector(\n        'div[class=\"css-18t94o4 css-1dbjc4n r-l5o3uw r-42olwf r-sdzlij r-1phboty r-rs99b7 r-19u6a5r r-2yi16 r-1qi8awa r-1ny4l3l r-ymttw5 r-o7ynqc r-6416eg r-lrvibr\"]'\n      );\n      await page.click(\n        'div[class=\"css-18t94o4 css-1dbjc4n r-l5o3uw r-42olwf r-sdzlij r-1phboty r-rs99b7 r-19u6a5r r-2yi16 r-1qi8awa r-1ny4l3l r-ymttw5 r-o7ynqc r-6416eg r-lrvibr\"]'\n      );\n    }\n    const postUrl = await getTwitterPostUrl(page);\n    console.log({ postUrl });\n\n    return { isSuccess: true, message: \"Tweeted succcessfully\", postUrl };\n  } catch (e: Error | any) {\n    return { isSuccess: false, message: e.message };\n  }\n}"
  },
  "youtubeSearchAndDownload": {
    "name": "youtubeSearchAndDownload",
    "slug": "TsFunction",
    "id": "hcyqwlkzaxexgzimymuvuxia",
    "description": "",
    "operationName": "youtube-controller",
    "rawText": " async () => {\n  let allSearchVideos: VideoMetaType[] = [];\n  const searchKey = readlineSync.question(`Enter search key... \\n`);\n\n  if (searchKey.length > 0) {\n    const { data } = await youtubeSearch(searchKey);\n    allSearchVideos = data || [];\n    if (allSearchVideos.length > 0) {\n      console.log(\"Search results-------- \\n \\n\");\n      allSearchVideos.forEach((next, idx) => {\n        console.log(`[${idx + 1}] ${next.description} \\n \\n`);\n      });\n    }\n  }\n\n  const enteredNumber = readlineSync.question(`Enter Number to download... \\n`);\n\n  if (allSearchVideos.length > 0 && enteredNumber.length > 0) {\n    if (enteredNumber.length > 0) {\n      const { url } = allSearchVideos[parseInt(enteredNumber) - 1];\n      const mp3DownloadResponse = await youtubeToMp3(url || \"\");\n      return mp3DownloadResponse;\n    }\n  } else {\n    console.log(\"Invalid input\");\n  }\n}"
  },
  "youtubeSearch": {
    "name": "youtubeSearch",
    "slug": "TsFunction",
    "id": "pcszsxxsjcpdeqsrmflccmgm",
    "description": "",
    "operationName": "youtube-controller",
    "rawText": " async (\n  searchQuery: string\n): Promise<ReturnType> => {\n  try {\n    const browser = await puppeteer.launch({\n      headless: false,\n      executablePath: \"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\",\n      // slowMo: 250 // slow down by 250ms\n      // devtools: true \n    });\n    const page = await browser.newPage();\n    const urlQuery = `results?search_query=${encodeURIComponent(searchQuery)}`;\n    await page.goto(`https://youtube.com/${urlQuery}`, { timeout: 60000 });\n    console.log(\"Searching ....\");\n    await page.waitForSelector('a[id=\"video-title\"]');\n    const allSearchVideos: VideoMetaType[] = await new Promise(\n      (resolve, reject) => {\n        resolve(\n          page.$$eval('a[id=\"video-title\"]', (elements) => {\n            const allInfos: VideoMetaType[] = elements.map((el) => {\n              const url = el.getAttribute(\"href\");\n              const description: string | null =\n                //@ts-ignore\n                el.childNodes[3].getAttribute(\"aria-label\");\n              return { url: `https://www.youtube.com${url}`, description };\n            });\n            return allInfos;\n          })\n        );\n      }\n    );\n    browser.close();\n    return {\n      success: true,\n      message: \" Search succcessfull\",\n      data: allSearchVideos,\n    };\n  } catch (e) {\n    return { success: false, message: JSON.stringify(e), data: [] };\n  }\n}"
  },
  "youtubeToMp3": {
    "name": "youtubeToMp3",
    "slug": "TsFunction",
    "id": "vrpzsvvfmdogpighdwmjmuuu",
    "description": "In order to download the youtube video into mp3 format ffmpeg packages must be install in your computer\nfor mac please try [brew install ffmpeg] to install ffmpeg",
    "operationName": "youtube-controller",
    "rawText": " async (\n  link: string,\n  config?: {\n    quality?: \"low\";\n  }\n): Promise<{\n  success: boolean;\n  message?: string;\n  mp3FilePath?: string;\n  mp4FilePath?: string;\n}> => {\n  try {\n    console.log(`Going to download ${link}`);\n    // getting video basic info to get title of video for file name\n    const info = await getBasicInfo(link);\n    const title = info.videoDetails.title;\n    // creating promises to download video\n    const downloadYoutubeAudioResult = await new Promise<{\n      success: boolean;\n      absoluteSaveFilePath?: string;\n      message?: string;\n    }>((resolve, reject) => {\n      // creating youtube video stream\n      const stream = ytdl(link, {\n        quality: config?.quality === \"low\" ? \"lowestaudio\" : \"highestaudio\",\n        filter: \"audioonly\",\n      });\n\n      let totalTime = 1;\n\n      const absoluteSaveFilePath = path.join(\n        __dirname,\n        \"..\",\n        \"data\",\n        `${slugify(kebabCase(title))}.mp4`\n      );\n\n      console.log({ absoluteSaveFilePath });\n      // passing that stream to ffmpeg for mp3 conversion\n      const process = ffmpeg({ source: stream });\n      process\n        .toFormat(\"mp4\") // setting file format\n        .saveToFile(absoluteSaveFilePath) // setting path and file name of output\n        .on(\"codecData\", (data) => {\n          // HERE YOU GET THE TOTAL TIME\n          totalTime = parseInt(data.duration.replace(/:/g, \"\"));\n          console.log(\"Downloading Start...\");\n        })\n        .on(\"progress\", (progress) => {\n          // HERE IS THE CURRENT TIME\n          const time = parseInt(progress.timemark.replace(/:/g, \"\"));\n          // AND HERE IS THE CALCULATION\n          const percent = Math.floor((time / totalTime) * 100);\n          console.log(`${percent}%`);\n        })\n        .on(\"end\", () => {\n          resolve({\n            success: true,\n            absoluteSaveFilePath,\n            message: \"Youtube to Audo downloaded successfully\",\n          });\n        })\n        .on(\"error\", (e: Error) => {\n          resolve({ success: false, message: e.message });\n        });\n    });\n\n    if (!downloadYoutubeAudioResult?.absoluteSaveFilePath) {\n      return {\n        success: false,\n        message: downloadYoutubeAudioResult.message,\n      };\n    }\n\n    console.log(\"Converting to mp3\");\n\n    const parsedFile = path.parse(\n      downloadYoutubeAudioResult.absoluteSaveFilePath\n    );\n    const mp3FilePath = await convertToMp3(\n      downloadYoutubeAudioResult.absoluteSaveFilePath,\n      path.join(parsedFile.dir, `${parsedFile.name}.mp3`)\n    );\n\n    if (!mp3FilePath) {\n      return {\n        success: false,\n        message: \"Conversion failed\",\n        mp4FilePath: downloadYoutubeAudioResult.absoluteSaveFilePath,\n      };\n    }\n\n    // remove mp4\n    await fs.rm(downloadYoutubeAudioResult.absoluteSaveFilePath, {});\n\n    return {\n      success: true,\n      message: \"Got mp3, deleted mp4\",\n      mp3FilePath,\n    };\n  } catch (e: any) {\n    return { success: false, message: JSON.stringify(e) };\n  }\n}"
  },
  "youtubeToMp4": {
    "name": "youtubeToMp4",
    "slug": "TsFunction",
    "id": "bufnoryztebbjkxohvrokwln",
    "description": "",
    "operationName": "youtube-controller",
    "rawText": " async (link: string) => {\n  try {\n    // getting youtube video information...\n    const info = await getBasicInfo(link);\n    const title = info.videoDetails.title;\n    // promise for completing the full video download\n    const result = await new Promise((resolve, reject) => {\n      const video = ytdl(link);\n      video.pipe(\n        fs.createWriteStream(path.join(__dirname, \"..\", \"data\", `${title}.mp4`))\n      ); //path and file name to output file\n      video.on(\"response\", function (res) {\n        let totalSize = res.headers[\"content-length\"];\n        let dataRead = 0;\n        res.on(\"data\", function (data: Buffer) {\n          dataRead += data.length;\n          let percent = dataRead / totalSize;\n          console.log((percent * 100).toFixed(2) + \"% \");\n        });\n        res.on(\"end\", function () {\n          console.log(\"\\n\");\n        });\n      });\n      video.on(\"end\", () => {\n        resolve({\n          success: true,\n          message: \"Youtube to Mp4 downloaded successfully\",\n        });\n      });\n      video.on(\"error\", (e: Error) => {\n        resolve({ success: false, message: e.message });\n      });\n    });\n    return result;\n  } catch (e: Error | any | unknown) {\n    return { success: false, message: e.message };\n  }\n}"
  },
  "allowedSearchContentExtensions": {
    "name": "allowedSearchContentExtensions",
    "slug": "TsVariable",
    "id": "vvahzhelufeffxekrikvuvxe",
    "description": "",
    "operationName": "filename-conventions"
  },
  "buildFolderName": {
    "name": "buildFolderName",
    "slug": "TsVariable",
    "id": "bkaioteaijczmmbidlszjdpn",
    "description": "",
    "operationName": "filename-conventions"
  },
  "databaseFolderName": {
    "name": "databaseFolderName",
    "slug": "TsVariable",
    "id": "tijirsvygpxnjtioexpwhmpr",
    "description": "",
    "operationName": "filename-conventions"
  },
  "extensions": {
    "name": "extensions",
    "slug": "TsVariable",
    "id": "qjsfygamelxjmxjdzpnoipfi",
    "description": "",
    "operationName": "filename-conventions"
  },
  "fileTypes": {
    "name": "fileTypes",
    "slug": "TsVariable",
    "id": "blmcxyvnzhajcfanbnvzhilh",
    "description": "",
    "operationName": "filename-conventions"
  },
  "frontendOptionalFileSubExtensions": {
    "name": "frontendOptionalFileSubExtensions",
    "slug": "TsVariable",
    "id": "slulfpqtwhakvmdfrqxyrqaf",
    "description": "these special operations are generated, so should not be copied, but should be generated in the bundle after everything is copied",
    "operationName": "filename-conventions"
  },
  "generatedFolders": {
    "name": "generatedFolders",
    "slug": "TsVariable",
    "id": "imzudbgajvfqvqjfcheokied",
    "description": "",
    "operationName": "filename-conventions"
  },
  "getFileTypeFromPath": {
    "name": "getFileTypeFromPath",
    "slug": "TsFunction",
    "id": "wgxvqlbzcvlteimapdyljuqv",
    "description": "",
    "operationName": "filename-conventions",
    "rawText": " (path?: string): FileType | \"other\" => {\n  if (!path) return \"other\";\n  //code\n  if (path.endsWith(\".ts\")) return \"code\";\n  if (path.endsWith(\".tsx\")) return \"code\";\n  if (path.endsWith(\".js\")) return \"code\";\n  if (path.endsWith(\".jsx\")) return \"code\";\n\n  //text\n  if (path.endsWith(\".md\")) return \"text\";\n  if (path.endsWith(\".mdx\")) return \"text\";\n  if (path.endsWith(\".txt\")) return \"text\";\n\n  //data\n  if (path.endsWith(\".json\")) return \"data\";\n\n  return \"other\";\n}"
  },
  "getWriterType": {
    "name": "getWriterType",
    "slug": "TsFunction",
    "id": "decwktpnmqjpzspkacaxieca",
    "description": "Gets the writer type based on the extension",
    "operationName": "filename-conventions",
    "rawText": " (extension: string | undefined): WriterType => {\n  if (!extension) return \"other\";\n  if (typescriptExtensions.includes(extension)) return \"typescript\";\n  if (markdownExtensions.includes(extension)) return \"markdown\";\n  return \"other\";\n}"
  },
  "hasSubExtension": {
    "name": "hasSubExtension",
    "slug": "TsFunction",
    "id": "lppencxclbvgpgnlpjymaayr",
    "description": "",
    "operationName": "social-media-node",
    "rawText": " (\n  absolutePath: string,\n  subExtension: string\n): boolean => {\n  const allExtenstions = getSubExtensions(absolutePath);\n  const isSubExtentionExist = allExtenstions.find(\n    (subExt) => subExt === subExtension\n  );\n  return Boolean(isSubExtentionExist);\n}"
  },
  "isGeneratedOperationName": {
    "name": "isGeneratedOperationName",
    "slug": "TsFunction",
    "id": "puzsqoyeuapvzjwbojsmrgdw",
    "description": "",
    "operationName": "filename-conventions",
    "rawText": " (operationName: string) => {\n  if (!operationName) return false;\n  return operationName === \"sdk\" || operationName.startsWith(\"sdk-\");\n}"
  },
  "isGeneratedOperation": {
    "name": "isGeneratedOperation",
    "slug": "TsFunction",
    "id": "wqamrurvacwmkrkrvhylbswk",
    "description": "",
    "operationName": "filename-conventions",
    "rawText": " (operationBasePath: string) => {\n  return operationBasePath.includes(\"/generated/\");\n}"
  },
  "isIndexableFileId": {
    "name": "isIndexableFileId",
    "slug": "TsFunction",
    "id": "ovxjfohssazcimvoqmnhpzqi",
    "description": "",
    "operationName": "filename-conventions",
    "rawText": " (fileId: string): boolean => {\n  const isOperationName = hasSubExtension(\n    fileId,\n    operationUnindexableNamesOrSubExtensions,\n    true\n  );\n\n  const isFrontendOptionalName = hasSubExtension(\n    fileId,\n    frontendOptionalFileSubExtensions,\n    false\n  );\n\n  const isIndex = fileId === \"index\";\n\n  const isIndexable = !isIndex && !isFrontendOptionalName && !isOperationName;\n\n  return isIndexable;\n}"
  },
  "jsonExtensionsConst": {
    "name": "jsonExtensionsConst",
    "slug": "TsVariable",
    "id": "ytacexdjluxqjgojfzxbxswr",
    "description": "",
    "operationName": "filename-conventions"
  },
  "jsonExtensions": {
    "name": "jsonExtensions",
    "slug": "TsVariable",
    "id": "kexaqufvwgzdahzoefotcdvn",
    "description": "",
    "operationName": "filename-conventions"
  },
  "markdownExtensionsConst": {
    "name": "markdownExtensionsConst",
    "slug": "TsVariable",
    "id": "fbfesoiqxleaisbzemcacmkg",
    "description": "",
    "operationName": "filename-conventions"
  },
  "markdownExtensions": {
    "name": "markdownExtensions",
    "slug": "TsVariable",
    "id": "bcogfuccvrzngfqkuzwsmjfw",
    "description": "",
    "operationName": "filename-conventions"
  },
  "operationUnindexableNamesOrSubExtensions": {
    "name": "operationUnindexableNamesOrSubExtensions",
    "slug": "TsVariable",
    "id": "dxyeboiozuhoopaallebgzju",
    "description": "",
    "operationName": "filename-conventions"
  },
  "projectRelativeGeneratedOperationsFolder": {
    "name": "projectRelativeGeneratedOperationsFolder",
    "slug": "TsVariable",
    "id": "douscnmvqvajrsncodordacf",
    "description": "",
    "operationName": "filename-conventions"
  },
  "sourceFolderName": {
    "name": "sourceFolderName",
    "slug": "TsVariable",
    "id": "evtgydmvxjtvrzikgujisgzk",
    "description": "",
    "operationName": "filename-conventions"
  },
  "typescriptExtensionsConst": {
    "name": "typescriptExtensionsConst",
    "slug": "TsVariable",
    "id": "oooqltvegmwspdeixusokmnj",
    "description": "",
    "operationName": "filename-conventions"
  },
  "typescriptExtensions": {
    "name": "typescriptExtensions",
    "slug": "TsVariable",
    "id": "ljguustxkcyefhvknwxzimtc",
    "description": "",
    "operationName": "filename-conventions"
  },
  "getPort": {
    "name": "getPort",
    "slug": "TsFunction",
    "id": "fjdczogbnyyjegpmzvrvdvdn",
    "description": "",
    "operationName": "get-port",
    "rawText": " async (operationName: string) => {\n  const operations = await db.get(\"Operation\", { operationName });\n\n  if (!operations.length) {\n    return;\n  }\n\n  return operations[0].operation?.port;\n}"
  },
  "[operationName]": {
    "name": "[operationName]",
    "slug": "TsVariable",
    "id": "ttfvhtlqmphyqqswbcehpxrq",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "assetsFolders": {
    "name": "assetsFolders",
    "slug": "TsVariable",
    "id": "tlaodkwuzwxzoazjqicznrcm",
    "description": "",
    "operationName": "name-conventions"
  },
  "generatedParameterNames": {
    "name": "generatedParameterNames",
    "slug": "TsVariable",
    "id": "wwvxxaefbpeliioaxganapgz",
    "description": "",
    "operationName": "name-conventions"
  },
  "getAssetInputType": {
    "name": "getAssetInputType",
    "slug": "TsFunction",
    "id": "pgqmumoyifjbqbyhbqwbxsol",
    "description": "Convention parameters for assets: [name], [name]s, xyz[Name], xyz[Name]s\n\nDifferent ways to name assets: `image`, `video`, `audio`, `file` or just `asset`, which is everything together",
    "operationName": "name-conventions",
    "rawText": " (\n  parameterName: string,\n  valueType?: SimplifiedSchemaType\n): AssetInputType | undefined => {\n  const lastWord = lowerCaseArray(parameterName).pop();\n  if (!lastWord) return;\n\n  const isObjectOrArray =\n    !valueType || valueType === \"array\" || valueType === \"object\";\n\n  if (!isObjectOrArray) return;\n\n  if (\n    [\"image\", \"video\", \"audio\", \"file\", \"asset\"].includes(singularize(lastWord))\n  ) {\n    return {\n      type: singularize(lastWord) as AssetInputType[\"type\"],\n      isMultiple: isPlural(lastWord),\n    };\n  }\n\n  return;\n}"
  },
  "getParameterContentType": {
    "name": "getParameterContentType",
    "slug": "TsFunction",
    "id": "extlhvskiyortvhpqbwelrlx",
    "description": "",
    "operationName": "name-conventions",
    "rawText": " (parameterName: string) => {\n  // todo: Match parameterName against all patterns in the ParameterName array until it finds one that matches\n  // 1) replace all patternmatch words with the %x\n  // 2) whatever's left, make sure to distinguish the descriptor from the type indicator (e.g. authorName indicates a nametype which is a string, while the descriptor is an author)\n  // 3) return some object that describes all the different parts individually and with that the whole name together. It can then be used in the admin UI to explain any type interface\n}"
  },
  "isCalculatedParameter": {
    "name": "isCalculatedParameter",
    "slug": "TsFunction",
    "id": "bhmnxbobfisxckeelzhmehjw",
    "description": "this is part of the database convention",
    "operationName": "name-conventions",
    "rawText": " (parameterName: string) => {\n  return (\n    generatedParameterNames.includes(parameterName) ||\n    parameterName.endsWith(\"Calculated\")\n  );\n}"
  },
  "isGeneratedParameterName": {
    "name": "isGeneratedParameterName",
    "slug": "TsFunction",
    "id": "dxabqxxzlysyoxnqycwmabwu",
    "description": "",
    "operationName": "name-conventions",
    "rawText": " (parameterName: string) => {\n  const generatedPatterns = parameterNames\n    .filter(\n      (x) => x.contentType.length === 1 && x.contentType[0] === \"generated\"\n    )\n    .map((x) => x.pattern);\n  // TODO: match the patterns against the name to find match\n}"
  },
  "markdownTextParameterNames": {
    "name": "markdownTextParameterNames",
    "slug": "TsVariable",
    "id": "jqwavmtqewurnnvivivxllht",
    "description": "Any parameter names that should render a textArea",
    "operationName": "name-conventions"
  },
  "parameterNames": {
    "name": "parameterNames",
    "slug": "TsVariable",
    "id": "kfnkxxdophrwwuiquliagueh",
    "description": "## Form input types\n\nHow do we show different UI's based on certain things we know about some parameter (name + type)? There are many things\n\n- All \"image\" or \"xxxImage\" should be Image + camera inputs\n- All \"asset\" or \"xxxAsset\" should be File inputs\n- All \"recording\" or \"xxxAudio\" should be mic inputs\n- All \"position\" or \"xxxPosition\" should be coordinates which should be pickable on the map\n- All \"path\" or \"xxxPath\" should be an input where you can select a relative path from project root or operation src root, depending on what we need. It needs to be clear what kind of paths are allowed, so we need to think about all the options and if we can all put that in the parameter name (would be best) or if we need to use the description...",
    "operationName": "name-conventions"
  },
  "passwordTextParameterNames": {
    "name": "passwordTextParameterNames",
    "slug": "TsVariable",
    "id": "njemkilousionjyfehibhisa",
    "description": "",
    "operationName": "name-conventions"
  },
  "patternMatchers": {
    "name": "patternMatchers",
    "slug": "TsVariable",
    "id": "rlxkrwoicqaowaedaihswlru",
    "description": "",
    "operationName": "name-conventions"
  },
  "referenceParameterNames": {
    "name": "referenceParameterNames",
    "slug": "TsVariable",
    "id": "ybawwsdzvqlgfbzwbycbtxsq",
    "description": "",
    "operationName": "name-conventions"
  },
  "referencePluralParameterNames": {
    "name": "referencePluralParameterNames",
    "slug": "TsVariable",
    "id": "nffuhpcbqxblzwqpexkowbxu",
    "description": "",
    "operationName": "name-conventions"
  },
  "ports": {
    "name": "ports",
    "slug": "TsVariable",
    "id": "rzfavumhpqxnjyfuyclyeygk",
    "description": "See https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers for available ports\n\nRange 42000-42080 seems to have no ports. There are many more ranges\n\nWhen creating a new app, ensure you not only define the port here, but also in",
    "operationName": "port-conventions"
  },
  "getBundleSummary": {
    "name": "getBundleSummary",
    "slug": "TsFunction",
    "id": "zwefmkbubalvjbbwvdoufanp",
    "description": "Summarizes a bundle config so it can be used easily in things like explore project",
    "operationName": "bundle-util",
    "rawText": " (bundleConfig: BundleConfig): BundleSummary => {\n  const operationsPath = getRootPath(\"operations\");\n  const bundlesPath = operationsPath\n    ? path.join(operationsPath, \"niches\")\n    : undefined;\n\n  const foldersFromRepo = bundlesPath\n    ? bundleConfig.createBundleConfig.foldersFromRepo?.map((x) =>\n        path.join(bundlesPath, kebabCase(bundleConfig.name), x)\n      )\n    : undefined;\n\n  // const filesAndFoldersToInclude = [\n  //   // ...(foldersFromRepo || []),\n  //   bundleConfig.readmeRelativeFilePath,\n  //   bundleConfig.docsRelativeFolderPath,\n  // ].filter(notEmpty);\n\n  const appNames = bundleConfig.createBundleConfig.bundles\n    .map((x) => {\n      const frontendOperationNames = makeArray(\n        x.appShellOperationNames,\n        x.serverOperationName\n      );\n\n      return frontendOperationNames;\n    })\n    .flat()\n    .filter(onlyUnique2());\n\n  const uiOperationNames = makeArray(\n    bundleConfig.createBundleConfig.bundles\n      .map((x) => x.uiOperationName)\n      .filter(notEmpty)\n  );\n\n  const bundlePublicOperationNames = bundleConfig.createBundleConfig.bundles\n    .map(\n      (x) =>\n        x.operations\n          ?.filter((x) => x.privacy === \"public\")\n          .map((x) => x.operationName) || []\n    )\n    .flat();\n  const bundlePrivateOperationNames = bundleConfig.createBundleConfig.bundles\n    .map(\n      (x) =>\n        x.operations\n          ?.filter((x) => x.privacy === \"private\")\n          .map((x) => x.operationName) || []\n    )\n    .flat();\n\n  const packageNames =\n    bundleConfig.createBundleConfig.dependencies\n      ?.filter((x) => x.privacy === \"public\")\n      .map((x) => x.operationName)\n      .concat(uiOperationNames)\n      .concat(bundlePublicOperationNames)\n      .filter(onlyUnique2()) || [];\n\n  const moduleNames =\n    bundleConfig.createBundleConfig.dependencies\n      ?.filter((x) => x.privacy === \"private\")\n      .map((x) => x.operationName)\n      .concat(bundlePrivateOperationNames)\n      .filter(onlyUnique2()) || [];\n\n  const summary: BundleSummary = {\n    // filesAndFoldersToInclude,\n    slug: bundleConfig.slug,\n    packageNames,\n    moduleNames,\n    appNames,\n  };\n\n  // console.dir({ summary, bundleConfig }, { depth: 999 });\n\n  return summary;\n}"
  },
  "getDbModelsForBundle": {
    "name": "getDbModelsForBundle",
    "slug": "TsFunction",
    "id": "qjetnvzwfpurzpihgcfruzti",
    "description": "Gets all TsInterface's that are used in a bundle according to a BundleConfig",
    "operationName": "bundle-util",
    "rawText": " async (\n  bundleConfig: BundleConfig\n): Promise<TsInterface[]> => {\n  const bundleSummary = getBundleSummary(bundleConfig);\n\n  const dbModels = getDbModelsFromOperations(\n    bundleSummary.packageNames\n      .concat(bundleSummary.moduleNames)\n      .concat(bundleSummary.appNames)\n  );\n  return dbModels;\n}"
  },
  "createBackupCli": {
    "name": "createBackupCli",
    "slug": "TsFunction",
    "id": "ansrvgjodnaeavucjfceecfh",
    "description": "",
    "operationName": "create-backup",
    "rawText": " () => {\n  createBackup(requirePasswordString === \"true\");\n}"
  },
  "createBackup": {
    "name": "createBackup",
    "slug": "TsFunction",
    "id": "haueovbwnrswmohxzbjgmfnm",
    "description": "make backup zip of tools and put it in backups",
    "operationName": "create-backup",
    "rawText": " async (requirePassword?: boolean) => {\n  const databasePath = getRootPath(databaseFolderName);\n  const textPath = getRootPath(\"text\");\n  const backupsPath = getRootPath(\"backups\");\n  const pathsWithOperations = getPathsWithOperations();\n  if (!databasePath || !textPath || !pathsWithOperations || !backupsPath)\n    return;\n\n  const foldersToBackup = pathsWithOperations.concat(databasePath, textPath);\n  const folderName = `backup-${getHumanReadableDate()}`;\n  // NB: TODO: need a function that checks the files for an available filename (.zip files for that date).\n  const realFolderName = getAvailableFolderPath(backupsPath, folderName);\n  const backupPath = path.resolve(backupsPath, realFolderName);\n\n  log(\"copying all project folders to backup folder\");\n  console.log({ foldersToBackup });\n  const promises = foldersToBackup.map((folderPath) => {\n    const destination = path.join(backupPath, getLastFolder(folderPath));\n    return fs.cpAsync(folderPath, destination, { recursive: true });\n  });\n\n  await Promise.all(promises);\n\n  log(\n    `removing node_modules and .next, .expo and .git folders. for now, don't remove /build because this is hard to install again everywhere.`\n  );\n\n  await removeAllFolders({\n    basePath: backupPath,\n    folderNames: [\"node_modules\", \".next\", \".git\", \".expo\", \".turbo\"],\n  });\n\n  log(\"creating zip\");\n\n  zip({\n    baseFolderPath: backupsPath,\n    folderName: folderName,\n    zipName: folderName,\n    requirePassword,\n  });\n\n  log(\"zip is done. removing backup folder\");\n\n  fs.rmSync(backupPath, { recursive: true });\n\n  log(`File is now available at ${backupPath}.zip`, { type: \"success\" });\n}"
  },
  "getHumanReadableDate": {
    "name": "getHumanReadableDate",
    "slug": "TsFunction",
    "id": "syhrvfvoiblkqinhdmmmmpas",
    "description": "",
    "operationName": "create-backup",
    "rawText": " () => {\n  const date = new Date(Date.now());\n  return `${date.getDate()}-${date.getMonth() + 1}-${date.getFullYear()}`;\n}"
  },
  "[requirePasswordString]": {
    "name": "[requirePasswordString]",
    "slug": "TsVariable",
    "id": "fgovpnpmzmlexisbffvueedf",
    "description": "",
    "operationName": "create-backup"
  },
  "createDistribution": {
    "name": "createDistribution",
    "slug": "TsFunction",
    "id": "ctotkvltjsnslwidkkqnyofi",
    "description": "make distribution zip file of all operations in tools, and put it in distribution. Optionally, a config can be provided",
    "operationName": "create-distribution",
    "rawText": " async (config?: {\n  /**\n   * if true, zipping will require user input (password)\n   */\n  requireZipPassword?: boolean;\n  /**\n   * if true, distribution folder is not removed (so a folder + zip file will be created)\n   */\n  keepFolder?: boolean;\n  /**\n   * if true, all indexation (index folders) will also be removed\n   */\n  removeIndex?: boolean;\n  keepNodeModules?: boolean;\n  keepSrc?: boolean;\n}): Promise<boolean> => {\n  const distributionFolderPath = getRootPath(\"distributions\");\n  if (!distributionFolderPath) return false;\n  const date = new Date(Date.now());\n  const folderName = `distribution-${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;\n  const distributionPath = getAvailableFolderPath(\n    distributionFolderPath,\n    folderName\n  );\n\n  const pathsToCopy = getPathsWithOperations();\n  if (!pathsToCopy) return false;\n  await fs.mkdir(distributionPath, { recursive: true });\n\n  await Promise.all(\n    pathsToCopy.map(async (p) => {\n      await fsPromises.cp(p, path.join(distributionPath, getLastFolder(p)), {\n        recursive: true,\n      });\n    })\n  );\n\n  // COPY tools there and remove the unwanted folders\n\n  const folderNamesToBeRemoved = [];\n  if (!config?.keepSrc) {\n    folderNamesToBeRemoved.push(sourceFolderName);\n  }\n  if (!config?.keepNodeModules) {\n    folderNamesToBeRemoved.push(\"node_modules\");\n  }\n  if (config?.removeIndex) {\n    folderNamesToBeRemoved.push(databaseFolderName);\n  }\n\n  await removeAllFolders({\n    basePath: distributionPath,\n    folderNames: folderNamesToBeRemoved,\n  });\n\n  /*\n  - copy all files in root\n*/\n\n  await fs.mkdir(path.join(distributionPath, databaseFolderName), {\n    recursive: true,\n  });\n\n  const files = (\n    await explore({\n      basePath: getProjectRoot(),\n      doNotExploreChildFolders: true,\n      ignore: \".DS_Store\",\n    })\n  ).map((x) => x.path);\n\n  console.log({ files });\n  const cpPromises = files.map((f) =>\n    fsPromises.cp(f, path.join(distributionPath, path.parse(f).base))\n  );\n\n  await Promise.all(cpPromises);\n\n  zip({\n    baseFolderPath: path.resolve(distributionPath, \"..\"),\n    folderName: folderName,\n    zipName: folderName,\n    requirePassword: config?.requireZipPassword,\n  });\n\n  if (!config?.keepFolder) {\n    await fsPromises.rm(distributionPath, { recursive: true });\n  }\n\n  log(`File is now available at ${distributionPath}.zip`, { type: \"success\" });\n  return true;\n}"
  },
  "filterInterfacesFromOperationNames": {
    "name": "filterInterfacesFromOperationNames",
    "slug": "TsFunction",
    "id": "gzhdxiupgmzinlzfshyqyxsz",
    "description": "",
    "operationName": "db-util",
    "rawText": " (\n  tsInterface: TsInterface,\n  operationNames?: string[]\n) => {\n  return (\n    !operationNames ||\n    (tsInterface.operationName &&\n      operationNames.includes(tsInterface.operationName))\n  );\n}"
  },
  "getDbModelsFromOperations": {
    "name": "getDbModelsFromOperations",
    "slug": "TsFunction",
    "id": "rgtqwttabhaxcztjmlkoywsb",
    "description": "",
    "operationName": "db-util",
    "rawText": " async (\n  operationNames: string[]\n): Promise<TsInterface[]> => {\n  const dbModels = (await db.get(\"TsInterface\"))\n    .filter((x) => x.isDbModel)\n    .filter(onlyUnique2<TsInterface>((a, b) => a.name === b.name))\n    .filter((tsInterface) =>\n      filterInterfacesFromOperationNames(tsInterface, operationNames)\n    )\n    .filter(onlyUnique2<TsInterface>((a, b) => a.name === b.name));\n\n  return dbModels;\n}"
  },
  "applyDataset": {
    "name": "applyDataset",
    "slug": "TsFunction",
    "id": "sbaoertknmwtvcxxnqxorhxu",
    "description": "",
    "operationName": "generate-bundle",
    "rawText": " async (\n  datasets: Dataset[],\n  datasetSlug: string,\n  action: \"add\" | \"filter\",\n  originProjectRoot: string,\n  destinationProjectRoot: string\n) => {\n  const dataset = datasets.find((x) => x.slug === datasetSlug);\n  if (!dataset) return;\n  const filters = dataset.filter ? makeArray(dataset.filter) : [];\n\n  if (action === \"filter\") {\n    db.remove(\n      dataset.modelName as keyof DbModels,\n      (item) => {\n        // NB: maybe I need to add start and max... But it seems doubtful. Clarify in docs\n        const matchingFilters = getMatchingFilters(filters, item);\n        const hasMatchingFilters = matchingFilters.length > 0;\n        return hasMatchingFilters;\n      },\n      { manualProjectRoot: destinationProjectRoot }\n    );\n\n    return;\n  } else if (action === \"add\") {\n    const datasetData = await getDataset(dataset, originProjectRoot);\n    //@ts-ignore\n    db.upsert(dataset.modelName as keyof DbModels, datasetData, {\n      manualProjectRoot: destinationProjectRoot,\n    });\n  }\n}"
  },
  "calculateBundleDependencies": {
    "name": "calculateBundleDependencies",
    "slug": "TsFunction",
    "id": "uumzduejjgbqtyxbtcxketty",
    "description": "This function recalculates the bundleconfig. In order to do this, it searches all dependencies (recursively) to get the up-to-date dependencies.\n\nIt then looks in the old bundleconfig if a privacy was already set for the dependency, otherwise it sets it to private.\n\nThings from the bundles[] are not included in the dependencies",
    "operationName": "generate-bundle",
    "rawText": " async (\n  createBundleConfig: CreateBundleConfig,\n  debug?: boolean\n): Promise<OperationPrivacy[]> => {\n  /**\n   * All operation names that comprise the root of the bundle\n   *\n   * This is:\n   * - ui packages\n   * - frontend apps\n   * - server\n   * - fixed bundle operationNames\n   */\n  const bundleOperations: OperationPrivacy[] = createBundleConfig.bundles\n    .map((frontBackBundle) => {\n      const allPrivacies: OperationPrivacy[] = makeArray(\n        frontBackBundle.appShellOperationNames,\n        frontBackBundle.serverOperationName,\n        frontBackBundle.uiOperationName\n      )\n        .map((operationName) => ({\n          operationName,\n          privacy: \"public\" as OperationPrivacy[\"privacy\"],\n        }))\n        .concat(frontBackBundle.operations || []);\n\n      return allPrivacies;\n    })\n    .flat()\n    .filter(\n      onlyUnique2<OperationPrivacy>(\n        (a, b) => a.operationName === b.operationName\n      )\n    );\n\n  const bundleOperationNames = bundleOperations.map((x) => x.operationName);\n\n  const imports = await db.get(\"TsImport\");\n  const operations = await db.get(\"Operation\");\n\n  /**\n   * all operation names that get added because the base is dependent on it\n   */\n  const dependencyOperationNames = await findAllDependencyOperations({\n    imports,\n    operations,\n    operationNames: bundleOperationNames,\n    ignoreFilter: (operationName: string) =>\n      !isGeneratedOperationName(operationName),\n  });\n\n  const packageOperationNames = makeArray(\n    bundleOperationNames,\n    dependencyOperationNames\n  )\n    .filter(onlyUnique)\n    .filter((x) => !isGeneratedOperationName(x));\n\n  const dependencies: BundleConfig[\"createBundleConfig\"][\"dependencies\"] =\n    packageOperationNames\n      .filter((x) => !bundleOperationNames.includes(x))\n      .map((operationName) => ({\n        operationName,\n        privacy:\n          createBundleConfig.dependencies?.find(\n            (x) => x.operationName === operationName\n          )?.privacy || \"private\",\n      }));\n\n  if (debug) {\n    console.log(\n      `Found ${packageOperationNames.length} operations to copy into packages and modules`\n    );\n  }\n\n  return dependencies;\n}"
  },
  "calculateToPath": {
    "name": "calculateToPath",
    "slug": "TsFunction",
    "id": "vyceuuilpikwhbymhertloqv",
    "description": "Calculates the toPath for copying an operation",
    "operationName": "generate-bundle",
    "rawText": " async (\n  operationName: string,\n  destinationFolderPath: string,\n  folder: string,\n  keepStructure?: boolean\n) => {\n  const operationBasePath = keepStructure\n    ? await getOperationPath(operationName)\n    : undefined;\n  const operationsFolder = keepStructure\n    ? getRootPath(\"operations\")\n    : undefined;\n\n  const operationsRelativeOperationBasePath =\n    keepStructure && operationBasePath && operationsFolder\n      ? makeRelative(operationBasePath, operationsFolder)\n      : undefined;\n\n  const toPath =\n    keepStructure && operationsRelativeOperationBasePath\n      ? path.join(\n          destinationFolderPath,\n          folder,\n          operationsRelativeOperationBasePath\n        )\n      : path.join(destinationFolderPath, folder, operationName);\n\n  return toPath;\n}"
  },
  "copyCodestories": {
    "name": "copyCodestories",
    "slug": "TsFunction",
    "id": "rsycylvzhmznhnaghxltndze",
    "description": "",
    "operationName": "generate-bundle",
    "rawText": " async (bundleConfig: BundleConfig) => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n\n  const projectRelativePaths = await getProjectRelativePaths();\n\n  const absoluteCodestoryPaths =\n    projectRelativePaths\n      ?.filter((x) => x.endsWith(\".codestory.md\"))\n      .map((x) => path.join(projectRoot, x)) || [];\n\n  const absoluteCodestoryOperationPaths = absoluteCodestoryPaths\n    .map((codestoryPath) => {\n      const operationPath = findOperationBasePath(codestoryPath);\n      return operationPath;\n    })\n    .filter(onlyUnique2())\n    .filter(notEmpty);\n\n  const projectRelativeDbPaths = absoluteCodestoryOperationPaths.map((x) =>\n    makeRelative(path.join(x, \"db\"), projectRoot)\n  );\n  // .map((x) => x.replace(\"operations/\", \"packages/\"));\n\n  const projectRelativeCodestoryAndAssetPaths = (\n    await Promise.all(\n      absoluteCodestoryPaths.map(async (x) => {\n        const assetPaths = (await findStaticAssets(x)).map((x) =>\n          makeRelative(x, projectRoot)\n        );\n\n        return [makeRelative(x, projectRoot), ...assetPaths];\n      })\n    )\n  ).flat();\n  // .map((x) => x.replace(\"operations/\", \"packages/\"));\n\n  const { destinationFolderPath } = getBundlePaths(bundleConfig)!;\n\n  // copy codestory paths into\n\n  const copiedStories = await copyAllRelativeFiles(\n    projectRelativeCodestoryAndAssetPaths,\n    projectRoot,\n    destinationFolderPath\n  );\n\n  const copiedOperations = await copyAllRelativeFiles(\n    projectRelativeDbPaths,\n    projectRoot,\n    destinationFolderPath\n  );\n\n  const operationsDir = path.join(destinationFolderPath, \"operations\");\n  const textDir = path.join(destinationFolderPath, \"text\");\n  if (fs.existsSync(operationsDir)) {\n    await fs.rename(\n      operationsDir,\n      path.join(destinationFolderPath, \"packages\")\n    );\n  }\n  if (fs.existsSync(textDir)) {\n    await fs.rename(textDir, path.join(destinationFolderPath, \"docs\"));\n  }\n\n  return { copiedOperations, copiedStories };\n}"
  },
  "copyDocsAndReadme": {
    "name": "copyDocsAndReadme",
    "slug": "TsFunction",
    "id": "erkbhddlteczmpjodnowqmdq",
    "description": "",
    "operationName": "generate-bundle",
    "rawText": " async (bundleConfig: BundleConfig) => {\n  const { projectRoot, destinationFolderPath } = getBundlePaths(bundleConfig)!;\n\n  if (bundleConfig.createBundleConfig.docsRelativeFolderPath) {\n    const docsPaths = makeArray(\n      bundleConfig.createBundleConfig.docsRelativeFolderPath\n    )\n      .map((relativeFolderPath) => {\n        return path.join(projectRoot, relativeFolderPath);\n      })\n      .filter((absolutePath) => fs.existsSync(absolutePath));\n\n    if (docsPaths.length === 1) {\n      await fs.cpAsync(docsPaths[0], path.join(destinationFolderPath, \"docs\"), {\n        recursive: true,\n      });\n    } else {\n      await Promise.all(\n        docsPaths.map(async (absoluteDocsPath) => {\n          const docsFolderName = getLastFolder(\n            absoluteDocsPath.replaceAll(\"/docs\", \"\")\n          );\n\n          const toPath = path.join(\n            destinationFolderPath,\n            \"docs\",\n            docsFolderName\n          );\n          await fs.cpAsync(absoluteDocsPath, toPath, { recursive: true });\n        })\n      );\n    }\n  }\n\n  const readmePath = path.join(destinationFolderPath, \"README.md\");\n  if (bundleConfig.createBundleConfig.readmeRelativeFilePath) {\n    const originalReadmePath = path.join(\n      projectRoot,\n      bundleConfig.createBundleConfig.readmeRelativeFilePath\n    );\n    await fs.cp(originalReadmePath, readmePath);\n\n    const assetPaths = await findStaticAssets(originalReadmePath);\n\n    assetPaths.map(async (assetPath) => {\n      if (fs.existsSync(assetPath)) {\n        const originalReadmeFolder = path.parse(originalReadmePath).dir;\n\n        const detinationFolderRelative = makeRelative(\n          assetPath,\n          originalReadmeFolder\n        );\n\n        await fs.cp(\n          assetPath,\n          path.join(destinationFolderPath, detinationFolderRelative)\n        );\n      }\n    });\n  } else if (bundleConfig.createBundleConfig.docsRelativeFolderPath) {\n    await fs.writeFile(\n      readmePath,\n      `# Welcome to ${bundleConfig.name} \\n\\n${bundleConfig.description}\\n\\nPlease check [docs](docs) for more info.`,\n      \"utf8\"\n    );\n  } else {\n    await fs.writeFile(\n      readmePath,\n      `# Welcome to ${bundleConfig.name} \\n\\n${bundleConfig.description}\\n\\nThere is no documentation... good luck!.`,\n      \"utf8\"\n    );\n  }\n}"
  },
  "copyFromRepoToNiche": {
    "name": "copyFromRepoToNiche",
    "slug": "TsFunction",
    "id": "gglhokakvmiddfxqsijyrwuu",
    "description": "put a repoFolder in niches/{slug} (but remove that first if it was already there)",
    "operationName": "generate-bundle",
    "rawText": " async (\n  repoFolder: string,\n  destinationFolderPath: string,\n  thisNicheFolderPath: string\n): Promise<boolean> => {\n  const bundledRepoFolder = path.join(destinationFolderPath, repoFolder);\n\n  if (!fs.existsSync(bundledRepoFolder)) return false;\n\n  const nicheRepoFolder = path.join(thisNicheFolderPath, repoFolder);\n\n  // first remove the niche repo folder, before copying that same folder from github\n  if (fs.existsSync(nicheRepoFolder)) {\n    await fs.rm(nicheRepoFolder, { recursive: true });\n  }\n\n  await fs.cpAsync(bundledRepoFolder, nicheRepoFolder, {\n    recursive: true,\n  });\n\n  return true;\n}"
  },
  "copyOperation": {
    "name": "copyOperation",
    "slug": "TsFunction",
    "id": "tjcpkgyjtmbvizdvmyiwjxzo",
    "description": "copies operation into a folder in a destination folder. if privacy is set to private, the src folder will be removed at the destination",
    "operationName": "generate-bundle",
    "rawText": " async ({\n  bundleConfig,\n  destinationFolderPath,\n  operationName,\n  folder,\n}: {\n  operationName: string;\n  folder: \"packages\" | \"apps\" | \"modules\";\n  bundleConfig: BundleConfig;\n  destinationFolderPath: string;\n}) => {\n  const fromPath = await getOperationPath(operationName);\n\n  if (!fromPath) {\n    log(`Generate bundle: Couldn't find ${operationName}`, { type: \"error\" });\n    return;\n  }\n\n  const shouldKeepStructure = bundleConfig.createBundleConfig.keepStructure\n    ? folder !== \"apps\"\n    : false;\n  const toPath = await calculateToPath(\n    operationName,\n    destinationFolderPath,\n    folder,\n    shouldKeepStructure\n  );\n\n  if (shouldKeepStructure) {\n    await copyReadmesBeforeFolderToBundle(\n      fromPath,\n      destinationFolderPath,\n      folder\n    );\n  }\n\n  await fs.cpAsync(fromPath, toPath, { recursive: true });\n\n  const nextPath = path.join(toPath, \".next\");\n  if (fs.existsSync(nextPath)) {\n    await fs.rm(nextPath, { recursive: true });\n  }\n\n  const todoPath = path.join(toPath, \"todo\");\n  if (!bundleConfig.createBundleConfig.keepTodos && fs.existsSync(todoPath)) {\n    await fs.rm(todoPath, { recursive: true });\n  }\n\n  if (folder === \"modules\") {\n    // NB: we need to keep src in case of a transpilable package where the src is needed by dependencies\n    const keepSrc = getOperationClassification(toPath) === \"ui-ts\";\n    const srcPath = path.join(toPath, \"src\");\n\n    if (!keepSrc && fs.existsSync(srcPath)) {\n      await fs.rm(srcPath, { recursive: true });\n    }\n  }\n}"
  },
  "copyReadmesBeforeFolderToBundle": {
    "name": "copyReadmesBeforeFolderToBundle",
    "slug": "TsFunction",
    "id": "plrxkhvgqeqaqbftuawmtmiv",
    "description": "",
    "operationName": "generate-bundle",
    "rawText": " async (\n  fromPath: string,\n  destinationFolderPath: string,\n  folder: string\n) => {\n  // also copy all README.md in the complete nested path\n  const foldersBefore = getAllFoldersUntilFolder(fromPath);\n  await Promise.all(\n    foldersBefore.map(async (folderBefore) => {\n      const readmeHerePath = path.join(folderBefore, \"README.md\");\n      const hasReadmeHere = fs.existsSync(readmeHerePath);\n      const operationsFolderPath = getRootPath(\"operations\");\n\n      if (hasReadmeHere && operationsFolderPath) {\n        const operationsFolderRelativeReadmePath = makeRelative(\n          readmeHerePath,\n          operationsFolderPath\n        );\n        if (operationsFolderRelativeReadmePath !== \"\") {\n          const readmeDestinationPath = path.join(\n            destinationFolderPath,\n            folder,\n            operationsFolderRelativeReadmePath\n          );\n\n          await fs.cpAsync(readmeHerePath, readmeDestinationPath, {\n            recursive: true,\n          });\n        }\n      }\n    })\n  );\n}"
  },
  "copyTodosIntoBundle": {
    "name": "copyTodosIntoBundle",
    "slug": "TsFunction",
    "id": "zcxclhxenjubzrpjstdmyntq",
    "description": "",
    "operationName": "generate-bundle",
    "rawText": " async (destinationFolderPath: string) => {\n  console.log(\"copytodosIntoB\");\n  const operationsPath = getRootPath(\"operations\");\n\n  if (!operationsPath) return;\n  // find all todos outside of operations and copy them into packages in the same path\n  const todoFolderPaths = await findAllTodoFolderPaths(operationsPath, true);\n\n  // console.log({ todoFolderPaths });\n  await Promise.all(\n    todoFolderPaths.map(async (absoluteFolderPath) => {\n      const operationRelativeTodoFolderPath = makeRelative(\n        absoluteFolderPath,\n        operationsPath\n      );\n      const destinationPath = path.join(\n        destinationFolderPath,\n        \"packages\",\n        operationRelativeTodoFolderPath\n      );\n\n      console.log(`todo from ${absoluteFolderPath} into ${destinationPath}`);\n\n      await fs.cpAsync(absoluteFolderPath, destinationPath, {\n        recursive: true,\n      });\n    })\n  );\n}"
  },
  "findAndCopyOperations": {
    "name": "findAndCopyOperations",
    "slug": "TsFunction",
    "id": "ocrhxnqjmfonrcptcqagvrco",
    "description": "finds all operations and copies them into bundle location",
    "operationName": "generate-bundle",
    "rawText": " async (\n  /** NB: no finalBundleConfig because we are calculating a new original budnle config here */\n  bundleConfig: BundleConfig,\n  bundleConfigs: BundleConfig[],\n  debug?: boolean\n): Promise<BundleConfig> => {\n  const { destinationFolderPath } = getBundlePaths(bundleConfig)!;\n\n  const {\n    createBundleConfig: { keepStructure, keepTodos },\n  } = bundleConfig;\n\n  log(`Finding operations for ${bundleConfig.name}`, { type: \"important\" });\n\n  const dependencies: OperationPrivacy[] = await calculateBundleDependencies(\n    bundleConfig.createBundleConfig,\n    debug\n  );\n\n  const newBundleConfig: BundleConfig = {\n    ...bundleConfig,\n    createBundleConfig: { ...bundleConfig.createBundleConfig, dependencies },\n  };\n\n  log(\"Finding inherited bundles\", { type: \"important\" });\n\n  const slugsIncludingInherited = findInherited(\n    newBundleConfig.slug,\n    bundleConfigs\n  );\n  console.log({ slugsIncludingInherited });\n\n  log(\"Summarizing operations\", { type: \"important\" });\n\n  const allSummaries = slugsIncludingInherited\n    .map((slug) => {\n      // NB: include the one that we actually just made!\n      if (slug === newBundleConfig.slug) return newBundleConfig;\n\n      return bundleConfigs.find((x) => x.slug === slug);\n    })\n    .filter(notEmpty)\n    .map(getBundleSummary);\n\n  const appNames = allSummaries\n    .map((x) => x.appNames)\n    .flat()\n    .filter(onlyUnique2());\n  const packageNames = allSummaries\n    .map((x) => x.packageNames)\n    .flat()\n    .filter(onlyUnique2());\n  const moduleNames = allSummaries\n    .map((x) => x.moduleNames)\n    .flat()\n    // NB: ensure there are no things in modules that are also in packages. this can be a cross-bundle clash\n    .filter((x) => !packageNames.includes(x))\n    .filter(onlyUnique2());\n\n  console.log(\n    `Found ${appNames.length} apps, ${moduleNames.length} modules, ${packageNames.length} packages`\n  );\n\n  const operationsFoldersObject = {\n    apps: appNames,\n    packages: packageNames,\n    modules: moduleNames,\n  };\n\n  const operationFolders = Object.keys(\n    operationsFoldersObject\n  ) as (keyof typeof operationsFoldersObject)[];\n\n  if (keepStructure && keepTodos) {\n    log(\"Copying todos\", { type: \"important\" });\n\n    await copyTodosIntoBundle(destinationFolderPath);\n  }\n\n  log(\n    `Copying operations ${\n      bundleConfig.createBundleConfig.keepStructure ? \"including readmes\" : \"\"\n    }`,\n    { type: \"important\" }\n  );\n\n  const promises = operationFolders\n    .map((folder) => {\n      const operationNames = operationsFoldersObject[folder];\n\n      const promises = operationNames.map((operationName) =>\n        copyOperation({\n          operationName,\n          folder,\n          bundleConfig,\n          destinationFolderPath,\n        })\n      );\n\n      return promises;\n    })\n    .flat();\n\n  await Promise.all(promises);\n\n  return newBundleConfig;\n}"
  },
  "findInherited": {
    "name": "findInherited",
    "slug": "TsFunction",
    "id": "arbqhtyhnrywjrwxtwkmdjha",
    "description": "1) finds all unique `BundleConfig`s that need to be inherited, recursively,",
    "operationName": "generate-bundle",
    "rawText": " (\n  bundleConfigSlug: string,\n  bundleConfigs: BundleConfig[],\n  stack: string[] = []\n): string[] => {\n  const bundleConfig = bundleConfigs.find((x) => x.slug === bundleConfigSlug);\n  if (!bundleConfig) return [];\n\n  const inheritedSlugs =\n    bundleConfig.createBundleConfig.inheritFrom_bundleConfigSlugs\n      // filter if already processed before to prevent infinite loop\n      ?.filter((x) => !stack.includes(x))\n      .map((slug) =>\n        findInherited(\n          slug,\n          bundleConfigs,\n          stack\n            .concat(bundleConfigSlug)\n            .concat(\n              bundleConfig.createBundleConfig.inheritFrom_bundleConfigSlugs ||\n                []\n            )\n        )\n      )\n      .filter(notEmpty)\n      .flat();\n\n  const all = [bundleConfigSlug, inheritedSlugs]\n    .filter(notEmpty)\n    .flat()\n    .filter(onlyUnique2());\n\n  return all;\n}"
  },
  "generateAllBundles": {
    "name": "generateAllBundles",
    "slug": "TsFunction",
    "id": "jknvlyyxwmaxhnkljkoicqnj",
    "description": "",
    "operationName": "generate-bundle",
    "rawText": " async (\n  customisableBundleConfig?: CustomisableBundleConfig,\n  ignoreBundleSlugs?: string[]\n) => {\n  const bundleConfigs = await db.get(\"BundleConfig\");\n\n  const filtered = bundleConfigs\n    .filter((x) => !ignoreBundleSlugs?.includes(x.slug))\n    .filter((x) => !x.createBundleConfig.isDraft);\n\n  await oneByOne(filtered, (bundleConfig) => {\n    log(`ðŸ¦¾ðŸ¦¾ðŸ¦¾ðŸ¦¾ Time for ${bundleConfig.name} ðŸŒˆðŸŒˆðŸŒˆðŸŒˆðŸŒˆðŸ¦„`);\n\n    return generateBundle(\n      bundleConfigs,\n      bundleConfig.slug,\n      customisableBundleConfig\n    );\n  });\n\n  console.log(\"DONE\");\n}"
  },
  "generateBundle": {
    "name": "generateBundle",
    "slug": "TsFunction",
    "id": "iwqbisxolkioqlyobycgmics",
    "description": "generateBundle does the following\n\n- optionally, pull new code from Github and remove all that will be generated, but keep some things that I don't maintain\n- uses bundleConfig to find all needed packages\n- wraps those packages in a bundled project folder structure\n- moves the created source to a specified path where a `.git` folder is located (and the previous bundle version)\n- optionally, ship it to github",
    "operationName": "generate-bundle",
    "rawText": " async (\n  /**\n   * All bundle configs,\n   */\n  bundleConfigs: BundleConfig[],\n  /**\n   * The slug of the bundle config you want to geneerate the bundle for\n   */\n  slug: string,\n  customisableBundleConfig?: CustomisableBundleConfig\n): Promise<undefined | BundleConfig> => {\n  const bundleConfig = bundleConfigs.find((x) => x.slug === slug);\n\n  if (!bundleConfig) return;\n\n  const finalBundleConfig = mergeBundleConfigs(\n    bundleConfig,\n    customisableBundleConfig\n  );\n\n  const {\n    customisableBundleConfig: {\n      debug,\n      branchName,\n      isOffline,\n      skipPush,\n      skipSyncNicheFolder,\n      skipRebuildNicheOperations,\n      skipUpsert,\n      gitUserEmail,\n      gitUserName,\n    },\n    createBundleConfig: { informationStrategy },\n  } = finalBundleConfig;\n\n  let isReallyOffline = false;\n  if (!isOffline) {\n    isReallyOffline = !(await isOnline());\n\n    if (isReallyOffline) {\n      log(\"ðŸŒˆ Couldn't find google, not pulling/pusing\", { type: \"important\" });\n      console.log(\"Possible reasons:\", [\n        \"they blew up\",\n        \"we're offline\",\n        \"we're using a node version below v17\",\n      ]);\n    }\n  }\n\n  // NB: if you are offline, skip is also needed\n  const realSkipPush = isReallyOffline || isOffline || skipPush;\n\n  console.log({ realSkipPush });\n  const bundlePaths = getBundlePaths(bundleConfig);\n\n  if (!bundlePaths) {\n    log(\"Not all bundlepaths could be calculated\", { type: \"error\" });\n    return;\n  }\n  const { destinationFolderPath } = bundlePaths;\n  // NB: put on true if you already cloned,pulled,rebuild everything\n  if (!skipSyncNicheFolder) {\n    // 1) update bundled folder so it's up to date, if not already\n    log(`Creating/updating bundled folder`, { type: \"important\" });\n    const isReady = await syncNicheFolder(finalBundleConfig, isReallyOffline);\n    if (!isReady) return;\n  }\n  // remove everything except .git folder and foldersFromRepo\n  await removeAllExcept(destinationFolderPath, { ignore: [\".git\"] });\n\n  // 2) make path `new-template/assets/templates/monorepo` to be copied into the destination\n  const result = await newTemplate(\"monorepo\", destinationFolderPath);\n\n  if (result !== destinationFolderPath) {\n    log(\"Something is weird, as resulted path is not the destinationPath\", {\n      type: \"error\",\n    });\n    return;\n  }\n\n  if (bundleConfig.createBundleConfig.keepCodestories) {\n    log(`Copying stories`, { type: \"important\" });\n    const storyResult = await copyCodestories(bundleConfig);\n    console.log({ storyResult });\n  }\n\n  // 3) find and copy all needed apps and packagess into the monorepo\n  const newBundleConfig = await findAndCopyOperations(\n    bundleConfig,\n    bundleConfigs,\n    debug\n  );\n\n  // Try to install without sdk's\n  yarnInstall(isOffline, destinationFolderPath);\n\n  log(`Generating sdk operations`, { type: \"important\" });\n\n  const isSuccessful = await generateSdkOperations(newBundleConfig, {\n    yarnInstallAfter: true,\n    yarnInstallBefore: true,\n    manualProjectRoot: destinationFolderPath,\n  });\n  if (!isSuccessful) {\n    log(\"Generating SDKs went wrong\", { type: \"error\" });\n    return;\n  }\n\n  log(`Copying docs and readme`, { type: \"important\" });\n\n  // 5) DOCS AND README\n  await copyDocsAndReadme(bundleConfig);\n\n  // sync information\n  await syncInformation(finalBundleConfig);\n\n  if (!skipUpsert) {\n    // Upsert\n    // @ts-ignore\n    await db.upsert(\"BundleConfig\", newBundleConfig);\n  }\n\n  const {\n    createBundleConfig: _,\n    customisableBundleConfig: __,\n    ...publicBundleConfig\n  } = newBundleConfig;\n\n  const packageJsonPath = path.join(\n    bundlePaths.destinationFolderPath,\n    \"package.json\"\n  );\n\n  await mapObjectJson<Operation, Operation>(packageJsonPath, (packageJson) => {\n    const repository: Operation[\"repository\"] =\n      bundleConfig.isGitRepoPublic && bundleConfig.gitRepoUrl\n        ? { type: \"git\", url: bundleConfig.gitRepoUrl }\n        : undefined;\n\n    return {\n      ...packageJson,\n      description: bundleConfig.description,\n      repository,\n      homepage: bundleConfig.isGitRepoPublic\n        ? bundleConfig.gitRepoUrl\n        : undefined,\n    };\n  });\n\n  // Write public bundle config to the bundle\n  const publicBundleConfigPath = path.join(\n    bundlePaths.destinationFolderPath,\n    \"public-bundle-config.json\"\n  );\n  await writeJsonToFile(publicBundleConfigPath, publicBundleConfig);\n\n  if (realSkipPush !== true) {\n    const pushCommand = branchName\n      ? `git push -u origin ${branchName}`\n      : \"git push\";\n\n    const setConfigEmailCommand = gitUserEmail\n      ? `git config user.email \"${gitUserEmail}\"`\n      : undefined;\n\n    const setConfigNameCommand = gitUserName\n      ? `git config user.name \"${gitUserName}\"`\n      : undefined;\n\n    const gitCommitCommand = `[[ \\`git status --porcelain .\\` ]] && git add . && git commit -m '${finalBundleConfig.customisableBundleConfig.description}'`;\n\n    try {\n      // NB: This doesn't work well with nested .git folders!\n      execSync(gitCommitCommand, {\n        cwd: destinationFolderPath,\n        stdio: \"inherit\",\n      });\n\n      if (setConfigEmailCommand) {\n        execSync(setConfigEmailCommand, {\n          cwd: destinationFolderPath,\n          stdio: \"inherit\",\n        });\n      }\n      if (setConfigNameCommand) {\n        execSync(setConfigNameCommand, {\n          cwd: destinationFolderPath,\n          stdio: \"inherit\",\n        });\n      }\n\n      execSync(pushCommand, { cwd: destinationFolderPath, stdio: \"inherit\" });\n    } catch {}\n  }\n\n  return newBundleConfig;\n}"
  },
  "generateBundles": {
    "name": "generateBundles",
    "slug": "TsFunction",
    "id": "sqvawiycanegalbkfbmfqrsg",
    "description": "",
    "operationName": "generate-bundle",
    "rawText": " async (\n  slugs: string[],\n  customisableBundleConfig?: CustomisableBundleConfig\n) => {\n  const bundleConfigs = await db.get(\"BundleConfig\");\n\n  await oneByOne(slugs, async (slug) => {\n    const bundleConfig = bundleConfigs.find((x) => x.slug === slug);\n\n    if (!bundleConfig) {\n      log(\n        \"Bundle not found\",\n        { type: \"error\" },\n        { availableBundles: bundleConfigs.map((x) => x.slug) }\n      );\n      return;\n    }\n\n    await generateBundle(bundleConfigs, slug, customisableBundleConfig);\n  });\n}"
  },
  "getBundlePaths": {
    "name": "getBundlePaths",
    "slug": "TsFunction",
    "id": "hpfqiliqizqupdownfrludfc",
    "description": "",
    "operationName": "generate-bundle",
    "rawText": " (bundleConfig: BundleConfig) => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    log(\"projectRoot couldn't be found\", { type: \"error\" });\n    return;\n  }\n\n  const folderName = bundleConfig.slug || kebabCase(bundleConfig.name);\n\n  const operationsFolderPath = getRootPath(\"operations\");\n  if (!operationsFolderPath) {\n    log(\"operationsPath  couldn't be found\", { type: \"error\" });\n    return;\n  }\n  const nichesFolderPath = path.join(operationsFolderPath, \"niches\");\n\n  const databasePath = getRootPath(databaseFolderName);\n  if (!databasePath) {\n    log(\"databasePath couldn't be found\", { type: \"error\" });\n    return;\n  }\n  const thisNicheFolderPath = path.join(nichesFolderPath, folderName);\n\n  const bundledFolderPath = getRootPath(\"bundled\");\n  if (!bundledFolderPath) {\n    log(\"bundledFolderPath couldn't be found\", { type: \"error\" });\n    return;\n  }\n\n  const destinationFolderPath = path.join(bundledFolderPath, folderName);\n\n  return {\n    /**\n     * either the slug if available, or the name in kebabcase (to generate new slug)\n     */\n    folderName,\n    /**\n     * folder path the bundle will be created\n     */\n    destinationFolderPath,\n    /**\n     * root folder (/bundled)\n     */\n    bundledFolderPath,\n    projectRoot,\n    /**\n     * operations/niches/{folderName}\n     */\n    thisNicheFolderPath,\n    /**\n     * operation/niches\n     */\n    nichesFolderPath,\n    /**\n     * /db\n     */\n    databasePath,\n  };\n}"
  },
  "getCompareFn": {
    "name": "getCompareFn",
    "slug": "TsFunction",
    "id": "suuyfozjbzjuyofbbxfwelwi",
    "description": "Gets the compare function. Ensure that a is casted to a string!",
    "operationName": "generate-bundle",
    "rawText": " (filter: DatasetFilter) => {\n  const compareFn = <T extends DatasetFilter[\"value\"]>(a: T, b: T): boolean => {\n    // NB: true is equal to \"true\", for now, until we include the types\n    if (filter.operator === \"equal\") return a === b;\n    if (filter.operator === \"notEqual\") return a !== b;\n\n    // cannot compare with null/undefined\n    if (a === null || a === undefined || b === undefined || b === null)\n      return false;\n\n    if (filter.operator === \"greaterThan\") return a > b;\n    if (filter.operator === \"greaterThanOrEqual\") return a >= b;\n    if (filter.operator === \"lessThan\") return a < b;\n    if (filter.operator === \"lessThanOrEqual\") return a <= b;\n\n    return false;\n  };\n\n  return compareFn;\n}"
  },
  "getDataset": {
    "name": "getDataset",
    "slug": "TsFunction",
    "id": "rctgjaqivaarcmblzdnmopep",
    "description": "NB: FUCK, I need better search! The function-ui really needs to have that, because I kinda wrote this whole thing twice! once here, once in `getDbModel`\n\nTODO: remove this, it's outdated and doesn't have all operators",
    "operationName": "generate-bundle",
    "rawText": " async <TDataset extends Dataset>(\n  dataset: TDataset,\n  manualProjectRoot: string\n) => {\n  type ModelName = TDataset[\"modelName\"] & keyof DbModels;\n\n  const data = await db.get(dataset.modelName as keyof DbModels, {\n    manualProjectRoot,\n  });\n\n  // STEPS: filter, omit keys, sort, slice\n\n  const filters = dataset.filter ? makeArray(dataset.filter) : [];\n\n  // 1: filter out data\n\n  const filteredData = filters.reduce((data, datasetFilter) => {\n    const compareFn = getCompareFn(datasetFilter);\n\n    const newData = data.filter((item) => {\n      return compareFn(\n        String(\n          (item as AugmentedAnyModelType)[datasetFilter.objectParameterKey]\n        ),\n        datasetFilter.value\n      );\n    });\n\n    return newData;\n  }, data);\n\n  // 2: omit keys\n  const omittedData = filteredData.map((item, index, array) => {\n    const readonlyKeys =\n      dataset.objectParameterKeys as (keyof AugmentedAnyModelType)[];\n\n    const specificKeysItem = (\n      readonlyKeys\n        ? getSubsetFromObject(item as AugmentedAnyModelType, readonlyKeys)\n        : item\n    ) as DatasetItem<AugmentedAnyModelType, TDataset>;\n\n    const keysWithoutIgnoredKeys = Object.keys(item).filter(\n      (x) => !dataset.ignoreObjectParameterKeys?.includes(x)\n    );\n\n    const ignoredKeysItem = (\n      dataset.ignoreObjectParameterKeys\n        ? //@ts-ignore\n          getSubsetFromObject(specificKeysItem, keysWithoutIgnoredKeys)\n        : specificKeysItem\n    ) as DatasetItem<AugmentedAnyModelType, TDataset>;\n\n    return ignoredKeysItem;\n  });\n\n  // 3: sort\n\n  const sorts = dataset.sort ? makeArray(dataset.sort) : [];\n  if (sorts.length > 0) {\n    log(\"SORT ISN't IMPLEMENTED YET\", { type: \"error\" });\n  }\n  // TODO : IMPLEMENT\n  // const sortedData = omittedData.sort((a,b)=> {\n  // NB: HOw to implement multiple sorts, dynimicallly???\n  // })\n\n  // 4: slice\n\n  const startIndex = dataset.startFromIndex || 0;\n  const endIndex = startIndex + (dataset.maxRows || Number.POSITIVE_INFINITY);\n  const slicedData = omittedData.slice(startIndex, endIndex);\n\n  //5: cast\n  //@ts-ignore\n  const castedData = slicedData as DatasetItem<DbModels[ModelName], TDataset>[];\n\n  return castedData;\n}"
  },
  "getIndirectDependencies": {
    "name": "getIndirectDependencies",
    "slug": "TsFunction",
    "id": "lgbjhmgbghqkvfqnpasdduer",
    "description": "gets indirect dependencies of operation names as specified in packageJson.operation.indirectDependencies. This may be useful if you have created a frontend that relies on an api that uses a function that is not imported directly.\n\n\nNB: I don't think this is very efficient",
    "operationName": "generate-bundle",
    "rawText": " async (operationNames: string[]) => {\n  const indirectDependencies = (\n    await Promise.all(\n      operationNames.map(async (operationName) => {\n        const operationFolderPath = await getOperationPath(operationName);\n        if (!operationFolderPath) return;\n        const packageJson = await getPackageJson({ operationFolderPath });\n        const indirectDependencies =\n          packageJson?.operation?.indirectDependencies || [];\n\n        return indirectDependencies;\n      })\n    )\n  )\n    .flat()\n    .filter(notEmpty)\n    .filter(onlyUnique);\n\n  return indirectDependencies;\n}"
  },
  "getMatchingFilters": {
    "name": "getMatchingFilters",
    "slug": "TsFunction",
    "id": "mrdjgnmpvwnriifdfzhaddyz",
    "description": "",
    "operationName": "generate-bundle",
    "rawText": " (filters: DatasetFilter[], item: any) => {\n  return filters.filter((filter) => {\n    const compareFn = getCompareFn(filter);\n    return compareFn<any>(item[filter.objectParameterKey], filter.value);\n  });\n}"
  },
  "ignoreBundleSlugs": {
    "name": "ignoreBundleSlugs",
    "slug": "TsVariable",
    "id": "mjhoztsbwwbaijzwuustmgfs",
    "description": "",
    "operationName": "generate-bundle"
  },
  "mergeBundleConfigs": {
    "name": "mergeBundleConfigs",
    "slug": "TsFunction",
    "id": "lozhrusyomclizewheemmvgn",
    "description": "Merge the different bundleconfigs to create a final bundle config object that includes defaults\n\nNB: also has defaults inside this function!",
    "operationName": "generate-bundle",
    "rawText": " (\n  bundleConfig: BundleConfig,\n  customisableBundleConfig?: CustomisableBundleConfig\n): FinalBundleConfig => {\n  const defaultCustomisableBundleConfig = {\n    branchName: \"main\",\n    description: \"monorepo update\",\n    debug: false,\n  };\n\n  const mergedBundleConfig: FinalBundleConfig = {\n    ...bundleConfig,\n    customisableBundleConfig: {\n      ...defaultCustomisableBundleConfig,\n      ...bundleConfig.customisableBundleConfig,\n      ...customisableBundleConfig,\n    },\n    createBundleConfig: {\n      foldersFromRepo: [],\n      informationStrategy: \"push\",\n      ...bundleConfig.createBundleConfig,\n    },\n  };\n\n  return mergedBundleConfig;\n}"
  },
  "slugs": {
    "name": "slugs",
    "slug": "TsVariable",
    "id": "rvpivkrwjsqgswryiegqbwbk",
    "description": "",
    "operationName": "generate-bundle"
  },
  "syncInformation": {
    "name": "syncInformation",
    "slug": "TsFunction",
    "id": "hxuutsmrhiergftybnvuzqnb",
    "description": "Syncs information according to the informationStrategy,\n\n@see InformationStrategy",
    "operationName": "generate-bundle",
    "rawText": " async (bundleConfig: BundleConfig) => {\n  const { thisNicheFolderPath, projectRoot, destinationFolderPath } =\n    getBundlePaths(bundleConfig)!;\n\n  log(\n    `Syncing information with strategy ${bundleConfig.createBundleConfig.informationStrategy}`,\n    {\n      type: \"important\",\n    }\n  );\n  /**\n   * NB: what information do we need for the models we have? get array of information relative paths\n   */\n  const dbModels = await getDbModelsForBundle(bundleConfig);\n  const syncModelsPromises = dbModels.map(async (model) => {\n    const dbFiles = await getDatabaseFiles(model.name, {\n      ...getMergedQueryConfig(model.name as keyof DbModels),\n      // NB: not search in operations!\n      operationName: null,\n    });\n\n    return {\n      modelName: model.name,\n      dbFiles,\n      informationStrategy:\n        bundleConfig.createBundleConfig.modelInformationStrategy?.[\n          model.name\n        ] || bundleConfig.createBundleConfig.informationStrategy!,\n    };\n  });\n\n  const syncModels = await Promise.all(syncModelsPromises);\n\n  const syncedModelsPromises = syncModels.map(async (syncModel) => {\n    const { dbFiles, informationStrategy, modelName } = syncModel;\n\n    const dbFilePaths = dbFiles.map((x) => x.absolutePath);\n\n    if (informationStrategy === \"pullReplace\") {\n      /**\n       * all infromation from repo should be pulled and replaces the os db for the used models\n       *\n       * Here, we copy the dbFiles from `/niches/~/db` into `/db` and `/bundled/~/db`\n       *\n       * It should already have been copied into the niche folder db from the repo db\n       */\n      await copyAllRelativeFiles(dbFilePaths, thisNicheFolderPath, projectRoot);\n      await copyAllRelativeFiles(\n        dbFilePaths,\n        thisNicheFolderPath,\n        destinationFolderPath\n      );\n    } else if (informationStrategy === \"pullMerge\") {\n      /**\n       * merge root information with information from repo\n       */\n      log(\"pullMerge is not implemented yet!\", { type: \"warning\" });\n    } else if (informationStrategy === \"push\") {\n      /**\n       * all information from root db folder should be copied over to bundle destination\n       *\n       * Here, we copy the dbFiles from `/db` into `/bundled/~/db`\n       */\n\n      // console.log({ dbFilePaths, projectRoot, destinationFolderPath });\n\n      const relativeDbFilePaths = dbFilePaths.map((absolutePath) =>\n        makeRelative(absolutePath, projectRoot)\n      );\n      await copyAllRelativeFiles(\n        relativeDbFilePaths,\n        projectRoot,\n        destinationFolderPath\n      );\n    }\n  });\n\n  await Promise.all(syncedModelsPromises);\n\n  const datasets = await db.get(\"Dataset\");\n\n  const applyAdditionalDatasets =\n    bundleConfig.createBundleConfig.additional_datasetSlugs?.map(\n      (datasetSlug) =>\n        applyDataset(\n          datasets,\n          datasetSlug,\n          \"add\",\n          projectRoot,\n          destinationFolderPath\n        )\n    );\n  const applyFilterDatasets =\n    bundleConfig.createBundleConfig.filter_datasetSlugs?.map((datasetSlug) =>\n      applyDataset(\n        datasets,\n        datasetSlug,\n        \"filter\",\n        projectRoot,\n        destinationFolderPath\n      )\n    );\n}"
  },
  "syncNicheFolder": {
    "name": "syncNicheFolder",
    "slug": "TsFunction",
    "id": "zwxsorcheuaqhlhrqwzrsmkl",
    "description": "STEP 1, get remote assets and make sure folder is there\n\n- pull repo into `bundled/{bundleSlug}`\n- remove bundles/{bundleSlug}/{folder} for all `foldersFromRepo`\n- copy from bundled/{bundleSlug}/{folder} all `foldersFromRepo` folders into `niches`.\n- completely clean up `bundled/{bundleSlug}`\n\nNB: we need to make sure the dependencies of the stuff from github is also taken into account, and the inferred dependency tree is up to date, even if I don't have that stuff in my project workspace",
    "operationName": "generate-bundle",
    "rawText": " async (\n  finalBundleConfig: FinalBundleConfig,\n  isReallyOffline: boolean\n): Promise<boolean> => {\n  const {\n    destinationFolderPath,\n    bundledFolderPath,\n    folderName,\n    thisNicheFolderPath,\n  } = getBundlePaths(finalBundleConfig)!;\n  const {\n    createBundleConfig: { foldersFromRepo, informationStrategy },\n    customisableBundleConfig: {\n      isOffline,\n      skipPull,\n      debug,\n      branchName,\n      skipRebuildNicheOperations,\n    },\n    gitRepoUrl,\n  } = finalBundleConfig;\n\n  const finalOffline = isReallyOffline || isOffline;\n  const realSkipPull = isReallyOffline || isOffline || skipPull;\n\n  console.log({ realSkipPull });\n  const isBundledBefore = fs.existsSync(destinationFolderPath);\n\n  if (!isBundledBefore) {\n    if (!fs.existsSync(bundledFolderPath)) {\n      await fs.mkdir(bundledFolderPath);\n    }\n\n    if (!realSkipPull) {\n      execSync(`git clone ${gitRepoUrl} ${folderName}`, {\n        cwd: bundledFolderPath,\n        stdio: debug ? \"inherit\" : undefined,\n      });\n    } else {\n      // NB: if we can't use git we can simply create the folder ourselves without a .git in it\n      await fs.mkdir(destinationFolderPath);\n    }\n    // git clone\n  } else if (!realSkipPull) {\n    execSync(\"git pull\", {\n      cwd: destinationFolderPath,\n      stdio: debug ? \"inherit\" : undefined,\n    });\n  } else {\n    log(\"Not pulling repo, creating new bundle from what we have\");\n  }\n\n  if (branchName && !finalOffline) {\n    execSync(`git checkout ${branchName}`, {\n      cwd: destinationFolderPath,\n      stdio: debug ? \"inherit\" : undefined,\n    });\n  }\n\n  if (\n    informationStrategy === \"pullMerge\" ||\n    informationStrategy === \"pullReplace\"\n  ) {\n    foldersFromRepo.push(databaseFolderName);\n  }\n\n  if (!foldersFromRepo || foldersFromRepo.length === 0) {\n    return true;\n  }\n\n  const syncFoldersFromRepoPromises = foldersFromRepo.map((repoFolder) =>\n    copyFromRepoToNiche(repoFolder, destinationFolderPath, thisNicheFolderPath)\n  );\n  const copied = await Promise.all(syncFoldersFromRepoPromises);\n  if (!isAllTrue(copied)) {\n    log(\"Not all folders from repo existed!\", { type: \"warning\" });\n  }\n\n  yarnInstall(isOffline, destinationFolderPath);\n\n  if (skipRebuildNicheOperations) {\n    // done early\n    return true;\n  }\n\n  // Rebuild the foldersFromRepo folders!\n  const operationBasePathsToRebuild = foldersFromRepo\n    .map((folderFromRepo) => path.join(thisNicheFolderPath, folderFromRepo))\n    .filter(isOperation);\n\n  await oneByOne(operationBasePathsToRebuild, (operationBasePath) =>\n    rebuildOperation({ operationBasePath })\n  );\n\n  return true;\n}"
  },
  "yarnInstall": {
    "name": "yarnInstall",
    "slug": "TsFunction",
    "id": "jsxhyufylplwieugibpctlrt",
    "description": "",
    "operationName": "generate-bundle",
    "rawText": " (\n  isOffline: boolean | undefined,\n  destinationFolderPath: string\n) => {\n  process.stdout.write(`Installing repo `);\n  try {\n    // NB: I got an engine error which seemed to break it, so to fix it I ignore engines now https://stackoverflow.com/questions/56617209/the-engine-node-is-incompatible-with-this-module\n    const installCommand = isOffline\n      ? \"yarn --offline --ignore-engines\"\n      : \"yarn --prefer-offline --ignore-engines\";\n    const result = execSync(installCommand, {\n      cwd: destinationFolderPath,\n      encoding: \"utf8\",\n      stdio: \"pipe\",\n    });\n\n    console.log(\"âœ…\");\n  } catch (e: any) {\n    console.log(\"âŒ\");\n    const error: {\n      status: number;\n      signal: any;\n      output: (string | null)[];\n      pid: number;\n      stdout: string;\n      stderr: string;\n    } = e;\n    console.log(`Could not install:`, error);\n\n    return;\n  }\n}"
  },
  "installNodeModules": {
    "name": "installNodeModules",
    "slug": "TsFunction",
    "id": "uxwfkgtabwbijybbmmdadqja",
    "description": "yarn install offline",
    "operationName": "install-node-modules",
    "rawText": " ({\n  nodeModulesFolderPath,\n}: {\n  nodeModulesFolderPath: string;\n}): void => {\n  execSync(\"yarn install --offline\", {\n    cwd: nodeModulesFolderPath,\n    stdio: \"inherit\",\n  });\n}"
  },
  "yarnInstallNewDistribution": {
    "name": "yarnInstallNewDistribution",
    "slug": "TsFunction",
    "id": "ktdqmgvpndxadwfpomtrfajk",
    "description": "unzip\ncd\nyarn install",
    "operationName": "yarn-install-new-distribution",
    "rawText": " async ({\n  zipPath,\n}: {\n  zipPath: string;\n}): Promise<void> => {\n  const folderPath = getFolder(zipPath);\n  unzip({ zipPath, outputPath: folderPath });\n  installNodeModules({\n    nodeModulesFolderPath: path.join(folderPath, getFileName(zipPath)),\n  });\n}"
  },
  "detectLanguage": {
    "name": "detectLanguage",
    "slug": "TsFunction",
    "id": "spqczfhmdeqcssygfntdfvup",
    "description": "This function detect the language",
    "operationName": "markdown-translator",
    "rawText": " () => {}"
  },
  "generateSimpleSentence": {
    "name": "generateSimpleSentence",
    "slug": "TsFunction",
    "id": "sjmvlxhtvvisbbtlakxqhrai",
    "description": "",
    "operationName": "generate-simple-sentence",
    "rawText": " (\n  adjectives: TokiPonaMatrix[],\n  nouns: TokiPonaMatrix[],\n  verbs: TokiPonaMatrix[],\n  from: SayLanguageEnum,\n  to: SayLanguageEnum\n): {\n  to: string;\n  from: string;\n  words: { from: string; to: string }[];\n} => {\n  const sentence = [\n    pickRandomArrayItem(adjectives),\n    pickRandomArrayItem(nouns),\n    pickRandomArrayItem(verbs),\n    pickRandomArrayItem(adjectives),\n    pickRandomArrayItem(nouns),\n  ];\n\n  const toSentence = sentence.map((x) => x[to]).join(\" \");\n  const fromSentence = sentence.map((x) => x[from]).join(\" \");\n\n  return {\n    from: fromSentence,\n    to: toSentence,\n    words: sentence.map((x) => ({\n      to: x[to] as string,\n      from: x[from] as string,\n    })),\n  };\n}"
  },
  "makeAudioCourse": {
    "name": "makeAudioCourse",
    "slug": "TsFunction",
    "id": "scdjbnbflrmuvggvnksjfvca",
    "description": "",
    "operationName": "generate-simple-sentence",
    "rawText": " async ({\n  from,\n  pauseBetweenWords,\n  repeatEachSentenceAmount,\n  repeatEachWordAmount,\n  to,\n}: {\n  repeatEachSentenceAmount: number;\n  repeatEachWordAmount: number;\n  pauseBetweenWords: number;\n  from: SayLanguageEnum;\n  to: SayLanguageEnum;\n}) => {\n  const words = await db.get(\"TokiPonaMatrix\");\n  const nouns = words.filter((x) => x.type === \"noun\");\n  const verbs = words.filter((x) => x.type === \"verb\");\n  const adjectives = words.filter((x) => x.type === \"adjective\");\n\n  const sentenceArray = new Array(1000).fill(null).map(() => {\n    const sentence = generateSimpleSentence(\n      [...adjectives],\n      [...nouns],\n      [...verbs],\n      from,\n      to\n    );\n    return sentence;\n  });\n\n  oneByOne(sentenceArray, async (sentence) => {\n    await oneByOne(sentence.words, async (word) => {\n      console.log({ [from]: word.from, [to]: word.to });\n      const repeatArray = new Array(repeatEachWordAmount).fill(null);\n\n      await oneByOne(repeatArray, async () => {\n        sayLanguage(word.from, from);\n        await sleep(pauseBetweenWords);\n        sayLanguage(word.to, to);\n        await sleep(pauseBetweenWords);\n      });\n    });\n\n    console.log({ [from]: sentence.from, [to]: sentence.to });\n    const repeatSentenceArray = new Array(repeatEachSentenceAmount).fill(null);\n\n    oneByOne(repeatSentenceArray, async () => {\n      sayLanguage(sentence.from, from);\n      sayLanguage(sentence.to, to);\n    });\n  });\n}"
  },
  "sleep": {
    "name": "sleep",
    "slug": "TsFunction",
    "id": "hrraaihjftoufjxitxhxeyzv",
    "description": "",
    "operationName": "generate-simple-sentence",
    "rawText": " (seconds: number) =>\n  new Promise((resolve) => setTimeout(resolve, seconds * 1000))"
  },
  "colorClasses": {
    "name": "colorClasses",
    "slug": "TsVariable",
    "id": "dzqfmooilpwdjionhzvkvtum",
    "description": "",
    "operationName": "learn-toki-web"
  },
  "languagesArray": {
    "name": "languagesArray",
    "slug": "TsVariable",
    "id": "pwrsvukcvocwamfmnpamuoco",
    "description": "",
    "operationName": "learn-toki-web"
  },
  "WordMatrix": {
    "name": "WordMatrix",
    "slug": "TsFunction",
    "id": "pbmwwvmqiecaqmhwnovacrmk",
    "description": "",
    "operationName": "learn-toki-web",
    "rawText": " (\n  props: TokiPonaMatrix & {\n    languages: (keyof TokiPonaMatrix)[];\n  }\n) => {\n  const { languages } = props;\n  return (\n    <Div className=\"flex flex-row justify-around\">\n      <Div style={{ maxLines: 1 }}>\n        {props.em}{\" \"}\n        {languages.map((language, index) => {\n          const colorClass = colorClasses[index];\n          return (\n            <Span>\n              <Span key={`word${index}`} className={colorClass}>\n                {props[language]}\n              </Span>{\" \"}\n            </Span>\n          );\n        })}\n      </Div>\n    </Div>\n  );\n}"
  },
  "arrayTranslated": {
    "name": "arrayTranslated",
    "slug": "TsVariable",
    "id": "hqnyvtrauwrutfmgjkyyscis",
    "description": "this value takes the array of translated words and convert that array to key value pairs for fast access",
    "operationName": "markdown-translator"
  },
  "createFolder": {
    "name": "createFolder",
    "slug": "TsFunction",
    "id": "lnxexfczqfdlwdyhagquuokl",
    "description": "create folder if not exist and changing directory to the folder",
    "operationName": "markdown-translator",
    "rawText": " (path: string, folderName: string) => {\n  // creating folder\n  const isPathExist = existsSync(`${path}/${folderName}`);\n  if (!isPathExist) {\n    mkdirSync(`${path}/${folderName}`);\n  }\n  // changing directory to provided path\n  chdir(`${path}/${folderName}`);\n}"
  },
  "getAllMarkdownFiles": {
    "name": "getAllMarkdownFiles",
    "slug": "TsFunction",
    "id": "fubspceaxrblnijxgpkrvpve",
    "description": "",
    "operationName": "markdown-translator",
    "rawText": " async (basePath: string) => {\n  const projectRoot = getProjectRoot();\n  //Todo: replace temp basePath to project root\n  const allMarkdownFiles = await explore({\n    basePath,\n    extension: \"md\",\n    ignore: [\"node_modules\", \".git\", \"build\", \".markdown-index\"],\n  });\n  return allMarkdownFiles;\n}"
  },
  "getFileInfo": {
    "name": "getFileInfo",
    "slug": "TsFunction",
    "id": "bgxiqvtmzhwwteoikxtaizwt",
    "description": "Getting file information using full path",
    "operationName": "markdown-translator",
    "rawText": " (path: string): FileInfo => {\n  const fileType = path.split(\".\").pop();\n  const fileLocation = path\n    .split(\"/\")\n    .slice(0, path.split(\"/\").length - 1)\n    .join(\"/\");\n  const folderName = fileLocation.split(\"/\").pop();\n  const fileName = path.split(\"/\").slice(-1)[0].split(\".\")[0];\n  return { fileLocation, fileName, fileType, fullPath: path, folderName };\n}"
  },
  "getTranslatedWord": {
    "name": "getTranslatedWord",
    "slug": "TsFunction",
    "id": "gyfzqhchqnadmxvgeabsakvv",
    "description": "",
    "operationName": "markdown-translator",
    "rawText": " (params: TranslationType): string => {\n  const { word, language } = params;\n  const translatedWord = fs.readFileSync(\"\");\n  return word;\n}"
  },
  "markdownStoreAndRecord": {
    "name": "markdownStoreAndRecord",
    "slug": "TsFunction",
    "id": "rmnsiusqpektcvabjsoxfwwq",
    "description": "getting file information, translated markdown as string and make and save the file in targeted location",
    "operationName": "markdown-translator",
    "rawText": " async (\n  fileInfo: FileInfo,\n  markdownInfo: MarkdownStoreInfo\n): Promise<DefaultResponseType> => {\n  const storeAndRecordResponse: DefaultResponseType = await new Promise(\n    async (resolve, reject) => {\n      const { fileLocation, fileName, fileType } = fileInfo;\n      const { markdownString, language } = markdownInfo;\n      createFolder(fileLocation, \".markdown-index\");\n      fs.writeFileSync(`${fileName}.${language}.md`, markdownString);\n      const { isSuccess, message } = await recordMdFile({\n        fileLocation,\n        fileName: `${fileName}.${language}`,\n        fileType,\n        fullPath: `${fileLocation}/.markdown-index/${fileName}.${language}.md`,\n      });\n      // console.log(message);\n      resolve({ isSuccess, message });\n    }\n  );\n  return storeAndRecordResponse;\n}"
  },
  "parseMarkdownWordByWord": {
    "name": "parseMarkdownWordByWord",
    "slug": "TsFunction",
    "id": "spmdcqusrcvijrhlvtbcajdl",
    "description": "Convert the file into word array",
    "operationName": "markdown-translator",
    "rawText": " (filePath: string) => {\n  let markdownString = fs.readFileSync(filePath, {\n    encoding: \"utf-8\",\n  });\n  let wordsArray = markdownString.split(\" \").map((m) => m.trim());\n  return { wordsArray, markdownString };\n}"
  },
  "recordMdFile": {
    "name": "recordMdFile",
    "slug": "TsFunction",
    "id": "ffkuansljenwwvijdbhppkxv",
    "description": "this recorts a md file. it's cool yah",
    "operationName": "markdown-translator",
    "rawText": " async (\n  fileInfo: FileInfo\n): Promise<DefaultResponseType> => {\n  const recordResponse: DefaultResponseType = await new Promise(\n    (resolve, reject) => {\n      const { fileName, fullPath, fileType } = fileInfo;\n      exec(\n        `say -f ${fullPath} -o ${fileName}.audio.aiff`,\n        (err, stdout, stderr) => {\n          if (!err) {\n            resolve({\n              isSuccess: true,\n              message: `${fileName}.${fileType} file ðŸ”ˆ audio translation completed âœ…`,\n            });\n          } else {\n            console.error(err);\n            resolve({\n              isSuccess: false,\n              message: `${fileName}.${fileType} file ðŸ”ˆ audio translation faild âŒ`,\n            });\n          }\n        }\n      );\n    }\n  );\n  return recordResponse;\n}"
  },
  "startMarkdownTranslator": {
    "name": "startMarkdownTranslator",
    "slug": "TsFunction",
    "id": "dkckdlrohimqjdhlelufwsec",
    "description": "This function get all the md file and translate and record audio one by one",
    "operationName": "markdown-translator",
    "rawText": " async () => {\n  const tempPath =\n    \"/Users/suyoghere/Desktop/king-os-bhagya/packages/markdown-translator/\";\n  const allMarkdownFiles = await getAllMarkdownFiles(tempPath);\n  const keyValueWords = JSON.parse(\n    fs.readFileSync(\n      `${__dirname}/../src/data/translated-words-key-value.json`,\n      { encoding: \"utf-8\" }\n    )\n  );\n\n  allMarkdownFiles.forEach(async (markdown) => {\n    startTranslation(markdown.path, keyValueWords);\n  });\n}"
  },
  "translatedArrayToKeyValue": {
    "name": "translatedArrayToKeyValue",
    "slug": "TsFunction",
    "id": "mrxriumgnyqvjabhrcqwbsds",
    "description": "",
    "operationName": "markdown-translator",
    "rawText": " () => {\n  let wordsArrayValue = fs.readFileSync(\n    `/Users/cfa/workspace/king-os-old/packages/markdown-translator/src/data/translated-words-array.json`\n  );\n\n  wordsArrayValue = JSON.parse(`${wordsArrayValue}`);\n  const keyValueResult = wordsArrayValue.reduce((obj, next) => {\n    //@ts-ignore\n    obj[next.en] = next;\n    return obj;\n  }, {} as TranslatedWordKeyValueTypes);\n  fs.writeFileSync(\n    `/Users/cfa/workspace/king-os-old/packages/markdown-translator/src/data/translated-words-key-value.json`,\n    JSON.stringify(keyValueResult)\n  );\n  console.log({ keyValueResult });\n}"
  },
  "watchMdFile": {
    "name": "watchMdFile",
    "slug": "TsFunction",
    "id": "ugxpreqiresbmlcifrwcjwfn",
    "description": "watching md file change or detect save and start recording the file",
    "operationName": "markdown-translator",
    "rawText": " () => {\n  console.log(\"ðŸ‘€ start watching .md file\");\n  watch(`/Users/suyoghere/Desktop/king-os-bhagya/**/**/*`, {\n    ignored: [\"node_modules\", \".git\", \"build\", \".markdown-index\"],\n  }).on(\"all\", (eventName, path) => {\n    const { fileLocation, fileName, fileType, fullPath, folderName } =\n      getFileInfo(path);\n    if (eventName === \"change\") {\n      if (fileType && fileType === \"md\" && folderName !== \".markdown-index\") {\n        console.log(\".md FILE DETECTED\", fileLocation);\n        // changing directory to the current .md file and create .audio file if not exist\n        const keyValueWords = JSON.parse(\n          fs.readFileSync(\n            `${__dirname}/../src/data/translated-words-key-value.json`,\n            { encoding: \"utf-8\" }\n          )\n        );\n        startTranslation(fullPath, keyValueWords);\n      }\n    }\n  });\n}"
  },
  "createWordSimplificationMap": {
    "name": "createWordSimplificationMap",
    "slug": "TsFunction",
    "id": "geebpquuxbieyoehtikibsox",
    "description": "preprocessSynonyms();\n\ngetSynonymFrequencyDataset();\n\npreprocessWordFrequencies();\n\nfindBetterWords();",
    "operationName": "simplify-text",
    "rawText": " async () => {\n  const synonymFrequencyReplacementsPath = path.join(\n    __dirname,\n    \"..\",\n    \"assets\",\n    \"synonym-frequency-replacements.json\"\n  );\n\n  const synonymFrequencyReplacements = await readJsonFile<\n    SynonymFrequencyReplacement[]\n  >(synonymFrequencyReplacementsPath);\n\n  if (!synonymFrequencyReplacements) return;\n\n  console.log(\"got file\");\n\n  const string = synonymFrequencyReplacements\n    .map((replacement) => {\n      const kv: string = `\"${replacement.word}:${replacement.type}\": ${\n        replacement.betterWord ? `\"${replacement.betterWord.word}\"` : \"null\"\n      }`;\n\n      return kv;\n    })\n    .filter(notEmpty)\n    .join(\",\");\n\n  const wordSimplificationString = `{${string}}`;\n\n  const newPath = path.join(\n    __dirname,\n    \"..\",\n    \"assets\",\n    \"word-simplifications.json\"\n  );\n\n  fs.writeFileSync(newPath, wordSimplificationString, \"utf8\");\n\n  console.log(\"DONE\");\n}"
  },
  "findBetterWords": {
    "name": "findBetterWords",
    "slug": "TsFunction",
    "id": "yfrddshwhgdqudxejsmqednn",
    "description": "",
    "operationName": "simplify-text",
    "rawText": " async () => {\n  const synonymFrequenciesPath = path.join(\n    __dirname,\n    \"..\",\n    \"assets\",\n    \"synonym-frequencies.json\"\n  );\n\n  const unigramFrequenciesObjectPath = path.join(\n    __dirname,\n    \"..\",\n    \"assets\",\n    \"unigram-frequencies-object.json\"\n  );\n\n  const synonymFrequencies = await readJsonFile<SynonymFrequency[]>(\n    synonymFrequenciesPath\n  );\n  const unigramFrequencies = await readJsonFile<{ [key: string]: number }>(\n    unigramFrequenciesObjectPath\n  );\n\n  if (!synonymFrequencies || !unigramFrequencies) return;\n\n  console.log(\"got files\");\n\n  const synonymFrequencyReplacements: SynonymFrequencyReplacement[] =\n    synonymFrequencies.map((sf) => {\n      const replacement: any = sf;\n\n      const bestSynonym = sf.synonyms.reduce((previous, current) => {\n        const count = unigramFrequencies[current.toLowerCase()];\n\n        if (!previous || previous.count < count) {\n          return { word: current, count };\n        }\n        return previous;\n      }, null as { word: string; count: number } | null);\n\n      replacement.betterWord =\n        bestSynonym && bestSynonym.count > sf.count ? bestSynonym : null;\n\n      return replacement;\n    });\n\n  const newPath = path.join(\n    __dirname,\n    \"..\",\n    \"assets\",\n    \"synonym-frequency-replacements.json\"\n  );\n\n  fs.writeFileSync(\n    newPath,\n    JSON.stringify(synonymFrequencyReplacements),\n    \"utf8\"\n  );\n\n  console.log(\"DONE\");\n}"
  },
  "getSynonymFrequencyDataset": {
    "name": "getSynonymFrequencyDataset",
    "slug": "TsFunction",
    "id": "dlusweyfeevcmqnlycdabzae",
    "description": "",
    "operationName": "simplify-text",
    "rawText": " async () => {\n  const unigramJsonPath = path.join(\n    __dirname,\n    \"..\",\n    \"assets\",\n    \"unigram-frequencies-object.json\"\n  );\n\n  const synonymsPath = path.join(__dirname, \"..\", \"assets\", \"synonyms.json\");\n\n  const synonyms = await readJsonFile<Synonym[]>(synonymsPath);\n  const unigramFrequencies = await readJsonFile<{ [key: string]: number }>(\n    unigramJsonPath\n  );\n\n  if (!synonyms || !unigramFrequencies) return;\n\n  console.log(\"got files\");\n\n  const synonymFrequency: SynonymFrequency[] = synonyms\n    .map((synonym: any) => {\n      const count = unigramFrequencies[synonym.word];\n      if (count === undefined) return;\n      synonym.count = count;\n      return synonym;\n    })\n    .filter(notEmpty);\n\n  console.log(\"got synonym frequencies\");\n\n  const synonymFrequencyPath = path.join(\n    __dirname,\n    \"..\",\n    \"assets\",\n    \"synonym-frequencies.json\"\n  );\n\n  fs.writeFileSync(\n    synonymFrequencyPath,\n    JSON.stringify(synonymFrequency),\n    \"utf8\"\n  );\n\n  console.log(\"written file\");\n}"
  },
  "preprocessSynonyms": {
    "name": "preprocessSynonyms",
    "slug": "TsFunction",
    "id": "roadecqisecvdjgckstuklnf",
    "description": "",
    "operationName": "simplify-text",
    "rawText": " async () => {\n  const synonymsOldPath = path.join(\n    __dirname,\n    \"..\",\n    \"assets\",\n    \"synonyms-old.json\"\n  );\n  const synonymsPath = path.join(__dirname, \"..\", \"assets\", \"synonyms.json\");\n\n  const synonymsOld = await readJsonFile<{ [wordTypeKey: string]: string }>(\n    synonymsOldPath\n  );\n\n  if (!synonymsOld) return;\n\n  const synonymArray = Object.keys(synonymsOld).map((wordTypeKey) => {\n    const [word, type] = wordTypeKey.split(\":\");\n\n    const value = synonymsOld[wordTypeKey];\n\n    const synonyms = value.replaceAll(\"|\", \";\").split(\";\");\n\n    return { word, type, synonyms };\n  });\n\n  fs.writeFileSync(synonymsPath, JSON.stringify(synonymArray), \"utf8\");\n\n  // const unigramPath = path.join(databasePath, \"unigram_freq.csv\");\n  // const unigramJsonPath = path.join(\n  //   databasePath,\n  //   \"unigram-frequencies.json\"\n  // );\n\n  // const unigramString = fs.readFileSync(unigramPath, \"utf8\");\n  // const unigrams = unigramString.split(\"\\n\").map((line) => {\n  //   const [word, count] = line.split(\",\");\n  //   return { word, count: Number(count) };\n  // });\n\n  // fs.writeFileSync(unigramJsonPath, JSON.stringify(unigrams), \"utf8\");\n}"
  },
  "preprocessWordFrequencies": {
    "name": "preprocessWordFrequencies",
    "slug": "TsFunction",
    "id": "ylthmgiarnjngqxjdombhdfm",
    "description": "",
    "operationName": "simplify-text",
    "rawText": " async () => {\n  const unigramPath = path.join(__dirname, \"..\", \"assets\", \"unigram_freq.csv\");\n  const unigramJsonPath = path.join(\n    __dirname,\n    \"..\",\n    \"assets\",\n    \"unigram-frequencies-object.json\"\n  );\n\n  const unigramString = fs.readFileSync(unigramPath, \"utf8\");\n  const unigrams = unigramString\n    .split(\"\\n\")\n    .map((line) => {\n      const [word, count] = line.split(\",\");\n      const n = Number(count);\n\n      return !isNaN(Number(count)) ? `\"${word}\": ${count}` : \"\";\n    })\n    .join(\",\");\n\n  const fullUnigramsObject = `{ ${unigrams} }`;\n\n  fs.writeFileSync(unigramJsonPath, fullUnigramsObject, \"utf8\");\n}"
  },
  "simplifyText": {
    "name": "simplifyText",
    "slug": "TsFunction",
    "id": "dntovqggvlgucljzgliflbvz",
    "description": "",
    "operationName": "simplify-text",
    "rawText": " async (text: string) => {\n  const wordSimplificationsPath = path.join(\n    __dirname,\n    \"..\",\n    \"assets\",\n    \"word-simplifications.json\"\n  );\n\n  const wordSimplificationsObject = await readJsonFile<WordSimplification>(\n    wordSimplificationsPath\n  );\n\n  if (!wordSimplificationsObject) return;\n\n  const words = text.split(\" \");\n  const replacedWords = words.map((word) => {\n    const possibleKeys = wordTypeConst.map((t) => `${word}:${t}`);\n\n    const betterWordKey = possibleKeys.find(\n      (x) => wordSimplificationsObject[x]\n    );\n\n    const better = betterWordKey\n      ? wordSimplificationsObject[betterWordKey]\n      : undefined;\n\n    // console.log({ word, better });\n    return better || word;\n  });\n\n  const newText = replacedWords.join(\" \");\n\n  const newPath = path.join(__dirname, \"..\", \"assets\", \"simplified-text.md\");\n\n  fs.writeFileSync(newPath, newText, \"utf8\");\n\n  console.log(\"DONE\");\n}"
  },
  "testSimplifiedText": {
    "name": "testSimplifiedText",
    "slug": "TsFunction",
    "id": "fxgxkrkexjpawcxyjqpcsiiz",
    "description": "",
    "operationName": "simplify-text",
    "rawText": " () => {\n  const ideasNanorave = fs.readFileSync(\n    // \"/Users/king/King/text/todo/ideas-nanorave.md\",\n    \"utf8\"\n  );\n\n  // simplifyText(ideasNanorave);\n}"
  },
  "wordTypeConst": {
    "name": "wordTypeConst",
    "slug": "TsVariable",
    "id": "rgdczbzesvruxctkugdkyppa",
    "description": "",
    "operationName": "simplify-text"
  },
  "speakWordsToLearn": {
    "name": "speakWordsToLearn",
    "slug": "TsFunction",
    "id": "fcjqiuobqyjhoecmfycpjmus",
    "description": "",
    "operationName": "speak-words-to-learn",
    "rawText": " async () => {\n  const languageMatrix = await db.get(\"WordMatrix\");\n  languageMatrix.forEach((line, index) => {\n    const nlVoice = Math.floor(index / 3) % 2 === 0 ? \"Ellen\" : \"Xander\";\n    const enVoice = Math.floor(index / 3) % 2 === 0 ? \"Tessa\" : \"Alex\";\n\n    execSync(\n      `say -v ${enVoice} \"${line.english?.latin}.\" && say -v Rishi \"${line.tokiPona?.latin}\" && sleep 4 && say -v ${nlVoice} -r 120 \"${line.dutch?.latin}\" && say -v ${nlVoice} \"nu jij!\" && sleep 4`\n    );\n  });\n}"
  },
  "createPaymentRequestWithContext": {
    "name": "createPaymentRequestWithContext",
    "slug": "TsFunction",
    "id": "giuxbpsmegcxtqybcyhfuiga",
    "description": "",
    "operationName": "payment-node",
    "rawText": " async (\n  functionContext: FunctionContext,\n  credit: number,\n  payer_personIds?: string[],\n  isPublic?: boolean\n): Promise<DefaultResponse & {}> => {\n  const receiver_personId = functionContext.device.currentPersonId;\n\n  if (!receiver_personId) {\n    return { isSuccessful: false, message: \"You need to be logged in\" };\n  }\n\n  const newPaymentRequest: Creation<PaymentRequest> = {\n    receiver_personId,\n    token: generateRandomString(32),\n    isPublic,\n    payer_personIds,\n    credit,\n  };\n\n  const upsertResult = await db.upsert(\"PaymentRequest\", newPaymentRequest);\n\n  return {\n    isSuccessful: upsertResult.isSuccesful,\n    message: upsertResult.message,\n  };\n}"
  },
  "createPaymentTransactionWithContext": {
    "name": "createPaymentTransactionWithContext",
    "slug": "TsFunction",
    "id": "yadauznsawpihjwhcmebevan",
    "description": "",
    "operationName": "payment-node",
    "rawText": " async (\n  functionContext: FunctionContext,\n  receiver_personId: string,\n  credit: number\n): Promise<DefaultResponse & Partial<DbQueryResult>> => {\n  const payer_personId = functionContext.device.currentPersonId;\n\n  if (!payer_personId) {\n    return fail(\"You need to be logged in\");\n  }\n\n  const yourCredit =\n    functionContext.device.currentPersonCalculated?.credit || 0;\n  if (yourCredit < credit) {\n    return fail(\"You have insufficient balance\");\n  }\n  const newPaymentTransaction: Creation<PaymentTransaction> = {\n    receiver_personId,\n    payer_personId,\n    credit,\n  };\n\n  // TODO: make these two updates a \"TRANSACTION\", if one of them goes wrong, they both don't happen. Generalise that so it can be done more easily\n\n  const updateMeResult = await db.update(\n    \"Person\",\n    (person) => person.id === payer_personId,\n    (old) => ({ ...old, credit: (old.credit || 0) - credit })\n  );\n\n  if (!updateMeResult.isSuccesful) {\n    return fail(\"Couldn't deduct your credit\", updateMeResult);\n  }\n\n  const updateYouResult = await db.update(\n    \"Person\",\n    (person) => person.id === receiver_personId,\n    (old) => ({ ...old, credit: (old.credit || 0) + credit })\n  );\n\n  if (!updateYouResult.isSuccesful) {\n    return fail(\"Couldn't add the credit\", updateYouResult);\n  }\n\n  const upsertResult = await db.upsert(\n    \"PaymentTransaction\",\n    newPaymentTransaction\n  );\n\n  return {\n    isSuccessful: upsertResult.isSuccesful,\n    message: upsertResult.message,\n  };\n}"
  },
  "defaultResponse": {
    "name": "defaultResponse",
    "slug": "TsFunction",
    "id": "cbvskxzsxxqzhoovquvmqjue",
    "description": "",
    "operationName": "payment-node",
    "rawText": " <T>(\n  isSuccessful: boolean,\n  message?: string,\n  result?: T\n): T extends undefined ? DefaultResponse : DefaultResponse & T => {\n  const defaultResponse = { isSuccessful, message };\n  const final = (\n    result ? { ...result, ...defaultResponse } : defaultResponse\n  ) as T extends undefined ? DefaultResponse : DefaultResponse & T;\n\n  return final;\n}"
  },
  "fail": {
    "name": "fail",
    "slug": "TsFunction",
    "id": "xrwmmxkcdvogsciwhnrjiqcn",
    "description": "",
    "operationName": "payment-node",
    "rawText": " <T>(message?: string, result?: T) =>\n  defaultResponse(false, message, result)"
  },
  "getPaymentWebPages": {
    "name": "getPaymentWebPages",
    "slug": "TsFunction",
    "id": "ltqocaifmricnhrjxludbojo",
    "description": "",
    "operationName": "payment-node",
    "rawText": " async (): Promise<\n  DefaultResponse & { flat?: WebPage<unknown>[]; nested?: NestedWebPage[] }\n> => {\n  const functionPages: FunctionFormPage[] = [\n    {\n      functionName: \"createPaymentRequestWithContext\",\n      customTitle: \"New payment request\",\n    },\n    {\n      functionName: \"createPaymentTransactionWithContext\",\n      customTitle: \"New payment\",\n    },\n\n    // add credit to your account using stripe/crypto\n    {\n      functionName: \"addCreditWithContext\",\n      customTitle: \"Deposit\",\n      routeOnIsSuccessful: \"initiateStripeTransaction\",\n    },\n\n    {\n      functionName: \"initiateStripeTransaction\",\n      isMenuHidden: true,\n      actionWithResult: \"redirectToStripe\",\n    },\n  ];\n\n  const crudPages: CrudPage[] = [\n    {\n      // see the requests made to/from you\n      modelName: \"PaymentRequest\",\n      datasetSlugs: [\"toMePaymentRequests\", \"fromMePaymentRequests\"],\n      canCreate: false,\n      canRead: true,\n      canUpdate: false,\n      canDelete: false,\n      itemActionFunctionNames: [\"newRequestFromItem\"],\n      pageActionFunctionNames: [\"newRequest\"],\n    },\n    {\n      // see the transaction made to/from you\n      modelName: \"PaymentTransaction\",\n      datasetSlugs: [\"toMePaymentTransactions\", \"fromMePaymentTransactions\"],\n      canCreate: false,\n      canRead: true,\n      canUpdate: false,\n      canDelete: false,\n      itemActionFunctionNames: [\"newTransactionFromItem\"],\n      pageActionFunctionNames: [\"newTransaction\"],\n    },\n  ];\n\n  const customWebPages: CustomWebPage[] = [\n    /**\n\nCUSTOM\n\n\n- payout credit into euros or any currency with stripe/crypto\n\n     */\n\n    { queryPath: \"payoutCredit\", pageData: null },\n    /**\n     * choose a payment plan (maybe with coupon) and pay that (optionally make a subscription using stripe/crytpo)\n     *\n     * (this should lead to a flow where you can pay with stripe and after that a success page)\n     */\n    { queryPath: \"choosePaymentPlan\", pageData: null },\n    { queryPath: \"paymentSuccessful\", pageData: null },\n  ];\n\n  const webPages = [\n    ...functionPages.map(functionFormPageToWebPage),\n    ...crudPages.map(crudPageToWebPages).flat(),\n\n    //writer pages\n\n    //reader pages\n\n    ...customWebPages,\n  ];\n\n  // TODO: extrahere the conversion of a flat webpages array into the nested one (where the right things are hidden)\n\n  // TODO: add authorization and apply it onto `isMenuHidden` prop before it gets sent to the frontend. This makes the menu completely change if you're not logged in, for example.\n\n  return {};\n}"
  },
  "succeed": {
    "name": "succeed",
    "slug": "TsFunction",
    "id": "cdaukboskwajjvoyqjnhchaa",
    "description": "",
    "operationName": "payment-node",
    "rawText": " <T>(message?: string, result?: T) =>\n  defaultResponse(true, message, result)"
  },
  "projectPaymentConfig": {
    "name": "projectPaymentConfig",
    "slug": "TsVariable",
    "id": "vtdtesdnyscndnhypfnqqlho",
    "description": "",
    "operationName": "payment-types"
  },
  "mapArrayJson": {
    "name": "mapArrayJson",
    "slug": "TsFunction",
    "id": "clxllwctjwnelpesntvbgqly",
    "description": "",
    "operationName": "edit-json-file",
    "rawText": " async <T, U>(\n  absolutePath: string,\n  mapFunction: (item: T) => U\n) => {\n  if (!absolutePath) return;\n  const json = await readJsonFile<T[]>(absolutePath);\n\n  if (!json) return;\n  const newJson = json.map(mapFunction);\n\n  const isSuccessful = await writeJsonToFile(absolutePath, newJson);\n\n  return isSuccessful;\n}"
  },
  "mapObjectJson": {
    "name": "mapObjectJson",
    "slug": "TsFunction",
    "id": "tbfksjfzbghsovyctwtmagvb",
    "description": "Takes an absolute path to a json and a type generic and provides a map function with which you can alter that JSON (read, map, save)",
    "operationName": "edit-json-file",
    "rawText": " async <T, U>(\n  absolutePath: string,\n  mapFunction: (item: T) => U\n) => {\n  if (!absolutePath) return;\n  const json = await readJsonFile<T>(absolutePath);\n\n  if (!json) return;\n  const newJson = mapFunction(json);\n\n  const isSuccessful = await writeJsonToFile(absolutePath, newJson);\n\n  return isSuccessful;\n}"
  },
  "unzip": {
    "name": "unzip",
    "slug": "Operation",
    "id": "xXzrSUEKFydIysKQ",
    "operationName": "unzip"
  },
  "zip": {
    "name": "zip",
    "slug": "Operation",
    "id": "leAoYiHfTSkcBhbj",
    "operationName": "zip"
  },
  "csvItemArrayToCsvString": {
    "name": "csvItemArrayToCsvString",
    "slug": "TsFunction",
    "id": "tpepfinklewpyiemfpxbhoks",
    "description": "make csv string from a csv model type",
    "operationName": "csv-util",
    "rawText": " <T extends CsvItemType>(\n  csvModelData: T[]\n): string => {\n  if (csvModelData.length === 0) return \"\";\n\n  const result = stringify(csvModelData, { header: true });\n\n  return result;\n\n  /**\n\nNB: first I did my own native raw implementation, but this doesn't have good newline support, so I fell back to csv modules (https://csv.js.org/stringify/api/)\n \n  // let propertyNames = simplifiedSchema?.properties?.map((x) => x.name);\n\n  const longestItem = csvModelData.reduce(\n    (previous, current) => {\n      const keysAmount = Object.keys(current).length;\n      if (keysAmount > previous.keysAmount) {\n        return { keysAmount, item: current };\n      }\n      return previous;\n    },\n    { keysAmount: 0, item: undefined } as {\n      keysAmount: number;\n      item: T | undefined;\n    }\n  ).item!;\n\n  const propertyNames = Object.keys(longestItem);\n\n  const headerString = propertyNames.join(\",\");\n\n  const rowStrings = csvModelData.map((row) => {\n    return propertyNames!\n      .map((propertyName) => String(row[propertyName]))\n      .join(\",\");\n  });\n\n  return `${headerString}\\n${rowStrings.join(\"\\n\")}`;\n  */\n}"
  },
  "exampleCsvItems": {
    "name": "exampleCsvItems",
    "slug": "TsVariable",
    "id": "lkvzvusdrqjboigzbqknrzez",
    "description": "the same as exampleCsvString",
    "operationName": "csv-util"
  },
  "exampleCsvString__OLD": {
    "name": "exampleCsvString__OLD",
    "slug": "TsVariable",
    "id": "hwapdqvlvvdzxxgrjmlgqgyf",
    "description": "",
    "operationName": "csv-util"
  },
  "exampleCsvString": {
    "name": "exampleCsvString",
    "slug": "TsVariable",
    "id": "dzvwmxurfdhurmptcpbjhndf",
    "description": "exuivalent to exampleCsvItems",
    "operationName": "csv-util"
  },
  "tryParseCsv": {
    "name": "tryParseCsv",
    "slug": "TsFunction",
    "id": "dbzmjuqzcaztggxryfkjnwts",
    "description": "This function parses a CSV into the object it says it has in the header",
    "operationName": "csv-util",
    "rawText": " <T extends CsvItemType>(\n  csvString: string\n): T[] | null => {\n  const [columnsString, ...rowStrings] = csvString.split(\"\\n\");\n\n  const columns = columnsString.split(\",\").map((x) => x.trim());\n\n  const rows = rowStrings.map((rowString) => {\n    const values = rowString.split(\",\");\n\n    const rowObject = mergeObjectsArray(\n      columns.map((columnName, index) => {\n        return { [columnName]: parsePrimitive(values[index]) };\n      })\n    ) as T;\n\n    return rowObject;\n  });\n\n  return rows;\n}"
  },
  "compressImage": {
    "name": "compressImage",
    "slug": "TsFunction",
    "id": "resxtjrrdodeybfcyvknprkw",
    "description": "",
    "operationName": "ffmpeg-util",
    "rawText": " async (\n  absoluteSourceImagePath: string,\n  config?: {\n    sizeWidthPx?: number;\n    aspectRatio?: { x: number; y: number };\n    quality?: number;\n    targetFormat?: \"webp\" | \"png\" | \"mp4\";\n    keepOriginal?: boolean;\n    isDebug?: boolean;\n  }\n) => {\n  let result = ffmpeg({ source: absoluteSourceImagePath });\n  if (config?.quality) {\n    result = result.addOption(`-quality ${config?.quality || 100}`);\n  }\n\n  if (config?.sizeWidthPx) {\n    result = result.size(`${config?.sizeWidthPx}x?`);\n  }\n\n  if (config?.aspectRatio) {\n    result = result.aspect(`${config?.aspectRatio.x}:${config.aspectRatio.y}`);\n  }\n\n  if (config?.targetFormat) {\n    result = result.toFormat(config?.targetFormat);\n  }\n\n  const parsedPath = path.parse(absoluteSourceImagePath);\n\n  // ffmpeg can't edit in-place\n  const destinationPath = getFirstAvailableFilename(\n    path.join(\n      parsedPath.dir,\n      `${parsedPath.name}.converted${\n        config?.targetFormat ? `.${config?.targetFormat}` : parsedPath.ext\n      }`\n    )\n  );\n\n  result = result.save(destinationPath);\n\n  let totalTime = 1;\n\n  const finalPath = await new Promise<string | undefined>((resolve) => {\n    result\n      .on(\"codecData\", (data) => {\n        // HERE YOU GET THE TOTAL TIME\n        totalTime = parseInt(data.duration.replace(/:/g, \"\"));\n        console.log(\"Converting Started...\");\n      })\n      .on(\"progress\", (progress) => {\n        // HERE IS THE CURRENT TIME\n        const time = parseInt(progress.timemark.replace(/:/g, \"\"));\n        // AND HERE IS THE CALCULATION\n        const percent = Math.floor((time / totalTime) * 100);\n        if (config?.isDebug) {\n          console.log(`${percent}%`);\n        }\n      })\n      .on(\"end\", async () => {\n        if (!config?.keepOriginal) {\n          // new file is created, old one is not overwritten, and we need to remove the old\n          // NB: don't wait for it!\n          await fs.rm(absoluteSourceImagePath);\n        }\n\n        const finalDestinationPath = replaceLastOccurence(\n          destinationPath,\n          \".converted\",\n          \"\"\n        );\n\n        if (fs.existsSync(finalDestinationPath)) {\n          resolve(destinationPath);\n        }\n\n        await fs.rename(destinationPath, finalDestinationPath);\n        resolve(finalDestinationPath);\n      })\n      .on(\"error\", (e: Error) => {\n        console.log({ e });\n        resolve(undefined);\n      });\n  });\n\n  return finalPath;\n}"
  },
  "compressImagesCli": {
    "name": "compressImagesCli",
    "slug": "TsFunction",
    "id": "jjchtipchcykhnkpnmfnbfit",
    "description": "`compressImages` CLI syntax:\n\n`compressImages [basePath]`\n\ncan also be relative path",
    "operationName": "ffmpeg-util",
    "rawText": " async () => {\n  const argumentsArray = process.argv.slice(2);\n\n  if (argumentsArray.length > 0) {\n    oneByOne(argumentsArray, async (absoluteOrRelativePath) => {\n      const absoluteFolderPath = absoluteOrRelativePath.startsWith(\".\")\n        ? path.join(process.cwd(), absoluteOrRelativePath)\n        : absoluteOrRelativePath;\n\n      if (!absoluteFolderPath) {\n        log(\"couldn't find that path\");\n        return;\n      }\n\n      // console.log({ operationNames, operationName });\n      await compressImages(absoluteFolderPath);\n    });\n  }\n}"
  },
  "compressImages": {
    "name": "compressImages",
    "slug": "TsFunction",
    "id": "jwfntyytrqazfyrwmkvaknrk",
    "description": "searches the folder recursively for all images and converts them to webp",
    "operationName": "ffmpeg-util",
    "rawText": " async (\n  absoluteBasePath: string,\n  sizeWidthPx?: number,\n  quality?: number\n) => {\n  const results = (\n    await explore({\n      basePath: absoluteBasePath,\n      extension: [\"jpg\", \"jpeg\", \"png\"],\n    })\n  ).map((x) => x.path);\n\n  const compressionResult = await Promise.all(\n    results.map((path) =>\n      compressImage(path, {\n        targetFormat: \"webp\",\n        quality: quality || 50,\n        sizeWidthPx: sizeWidthPx || 1920,\n      })\n    )\n  );\n\n  const isSuccessful =\n    compressionResult.filter(notEmpty).length === compressionResult.length;\n\n  console.log(\"DONE\", { isSuccessful });\n}"
  },
  "compressMp4": {
    "name": "compressMp4",
    "slug": "TsFunction",
    "id": "omrtijjvazzeaocfwvqrchsu",
    "description": "Compress mp4 to very small",
    "operationName": "ffmpeg-util",
    "rawText": " async (absolutePath: string) => {\n  const result = await compressImage(absolutePath, {\n    quality: 20,\n    sizeWidthPx: 360,\n    targetFormat: \"mp4\",\n    isDebug: true,\n  });\n  console.log({ result });\n}"
  },
  "compressMp4sCli": {
    "name": "compressMp4sCli",
    "slug": "TsFunction",
    "id": "baadlibnbdjgishceffxjnie",
    "description": "`compressMp4s` CLI syntax:\n\n`compressMp4s [basePath]`\n\ncan also be relative path",
    "operationName": "ffmpeg-util",
    "rawText": " async () => {\n  const argumentsArray = process.argv.slice(2);\n\n  if (argumentsArray.length > 0) {\n    oneByOne(argumentsArray, async (absoluteOrRelativePath) => {\n      const absoluteFilePath = absoluteOrRelativePath.startsWith(\".\")\n        ? path.join(process.cwd(), absoluteOrRelativePath)\n        : absoluteOrRelativePath;\n\n      if (!absoluteFilePath || !fs.existsSync(absoluteFilePath)) {\n        log(\"couldn't find that path\");\n        return;\n      }\n\n      // console.log({ operationNames, operationName });\n      await compressMp4(absoluteFilePath);\n    });\n  }\n}"
  },
  "convertToMp3": {
    "name": "convertToMp3",
    "slug": "TsFunction",
    "id": "lbnlmxdieigkevosoytxkmui",
    "description": "Uses ffmpeg to convert a file to mp3\n\nReturns the new file path on success",
    "operationName": "ffmpeg-util",
    "rawText": " (\n  sourcePath: string,\n  destinationPath: string\n): Promise<string | undefined> => {\n  return new Promise<string | undefined>((resolve, reject) => {\n    if (!fs.existsSync(sourcePath)) {\n      console.log(\"sourcePath doesn't exist\", sourcePath);\n    }\n    ffmpeg({ source: sourcePath })\n      .toFormat(\"mp3\")\n      .saveToFile(destinationPath)\n      .on(\"end\", () => {\n        resolve(destinationPath);\n      })\n      .on(\"error\", (e: Error) => {\n        console.log({ e });\n        resolve(undefined);\n      });\n  });\n}"
  },
  "convertToMp4": {
    "name": "convertToMp4",
    "slug": "TsFunction",
    "id": "uexeoslfhvmkbnxgzcpczmhi",
    "description": "Uses ffmpeg to convert a file to mp3\n\nReturns the new file path on success",
    "operationName": "ffmpeg-util",
    "rawText": " (\n  sourcePath: string,\n  destinationPath: string\n): Promise<string | undefined> => {\n  return new Promise<string | undefined>((resolve, reject) => {\n    ffmpeg({ source: sourcePath })\n      .toFormat(\"mp4\")\n      .saveToFile(destinationPath)\n      .on(\"end\", () => {\n        resolve(destinationPath);\n      })\n      .on(\"error\", (e: Error) => {\n        resolve(undefined);\n      });\n  });\n}"
  },
  "indentationUnit": {
    "name": "indentationUnit",
    "slug": "TsVariable",
    "id": "kxerdwsnlqgxyqluhukmireq",
    "description": "",
    "operationName": "json-to-md"
  },
  "jsonToMdString": {
    "name": "jsonToMdString",
    "slug": "TsFunction",
    "id": "zipgdpbnqrdtmekneezbqfbk",
    "description": "creating a md for a JSON\n\nThere are 2 ways:\n\n1: add the parameters in the markdown frontmatter, except for the markdown parameter\n\n2: create a human readable text with json object attributes as the variables.",
    "operationName": "json-to-md",
    "rawText": " (\n  json: Json,\n  config?: {\n    /**\n     * defaults to 0 (no indentation)\n     */\n    indentationAmount: number | undefined;\n    /**\n     * optionally, a name of the main object\n     */\n    name?: string;\n  }\n): string => {\n  if (\n    [\n      \"string\",\n      \"number\",\n      \"bigint\",\n      \"boolean\",\n      \"symbol\",\n      \"undefined\",\n      \"function\",\n    ].includes(typeof json)\n  ) {\n    return String(json);\n  }\n\n  if (json === null) {\n    return \"null\";\n  }\n\n  const indentationAmount = config?.indentationAmount || 0;\n  // only \"objects\" are left, which can be arrays or objects\n  const indentation = indentationUnit.repeat(indentationAmount);\n\n  if (Array.isArray(json)) {\n    return `\\n${json\n      .map((item) => {\n        // should be based on the level of indentation done previously\n        return `${indentation}${indentationUnit}- ${jsonToMdString(item, {\n          indentationAmount: indentationAmount + 1,\n        })}`;\n      })\n      .join(\"\\n\")}`;\n  }\n\n  if (typeof json === \"object\") {\n    return `${config?.name || \"Object\"}${printObject(\n      json,\n      indentation,\n      indentationAmount\n    )}`;\n  }\n\n  return \"____SHOULD NEVER HAPPEN____\";\n}"
  },
  "printObject": {
    "name": "printObject",
    "slug": "TsFunction",
    "id": "rozzlgwmsoeuaibupqdrxxoa",
    "description": "todo: we also had made a stringToJson... can we put these together and make them pure, as in: applying them both will return the begin state?",
    "operationName": "json-to-md",
    "rawText": " (\n  object: { [key: string]: Json },\n  indentation: string,\n  indentationAmount: number\n) => {\n  const keys = Object.keys(object);\n  const noArraysOrObjects = !Object.values(object).find(\n    (v) => typeof v === \"object\" && v !== null\n  );\n  const noLongOrUnreadableStrings = !Object.values(object).find(\n    (v) =>\n      String(v).length > 20 ||\n      [\",\", \"\\n\"].find((unreadableCharacter) =>\n        String(v).includes(unreadableCharacter)\n      )\n  );\n\n  if (keys.length < 5 && noArraysOrObjects && noLongOrUnreadableStrings) {\n    // One liner\n    return ` (${keys\n      .map((key) => `${key}: ${String(object[key])}`)\n      .join(\", \")})`;\n  }\n\n  // Multiline, (indented) list\n  return `\\n${keys\n    .map((key) => {\n      return `${indentation}${indentationUnit}- ${key}: ${jsonToMdString(\n        object[key],\n        { indentationAmount: indentationAmount + 1 }\n      )}`;\n    })\n    .join(\"\\n\")}`;\n}"
  },
  "jsonToSayString": {
    "name": "jsonToSayString",
    "slug": "TsFunction",
    "id": "rgbhjxgmkmqfimxggrncepjb",
    "description": "realtime parser for any JSON to a string of human readable text that can be spoken out.\n\nInstead of immideately parsing some things, it adds bigger things (arrays and objects) to a stack, so they can be parsed after the current parseable is done.",
    "operationName": "json-to-say-string",
    "rawText": " (\n  json: Json,\n  identifier: string = \"this\",\n  stack: { identifier: string; json: Json }[] = []\n): string => {\n  let returnString = getSimpleJsonString(json);\n  if (returnString) {\n    // all cases except array and object\n  } else if (Array.isArray(json)) {\n    // array case\n    returnString = `${identifier} is an array with ${json.length} ${\n      json.length === 1 ? \"item\" : \"items\"\n    }: ${json\n      .map((item, index) => {\n        const simpleJson = getSimpleJsonString(item);\n        if (simpleJson) {\n          return simpleJson;\n        }\n        stack.push({ identifier: `Item ${index}`, json: item });\n        return `Item ${index}`;\n      })\n      .join(\", \")}`;\n  } else if (typeof json === \"object\" && json !== null) {\n    const keys = Object.keys(json);\n\n    returnString = `${identifier} is an object with ${keys.length} ${\n      keys.length === 1 ? \"parameter\" : \"parameters\"\n    }:  ${keys\n      .map((key) => {\n        const simpleJson = getSimpleJsonString(json[key]);\n        if (simpleJson) {\n          return `${key}: ${simpleJson}`;\n        }\n        stack.push({ identifier: key, json: json[key] });\n        return `${key}`;\n      })\n      .join(\", \")}`;\n  } else {\n    returnString = \"__should never happen__\";\n  }\n\n  // NB: Recursion!\n  const rest = stack.shift();\n  const more = rest ? jsonToSayString(rest.json, rest.identifier, stack) : \"\";\n  return returnString + \"\\n\\n\" + more;\n}"
  },
  "getSimpleJsonString": {
    "name": "getSimpleJsonString",
    "slug": "TsFunction",
    "id": "okdwvlhriiqcrjduakaogqvp",
    "description": "stringifies simple json things if the json is one of them, otherwise returns undefined",
    "operationName": "json-util",
    "rawText": " (json: Json): string | undefined => {\n  if (\n    [\n      \"string\",\n      \"number\",\n      \"bigint\",\n      \"boolean\",\n      \"symbol\",\n      \"undefined\",\n      // \"function\", // I don't think function is that simple, is it?\n    ].includes(typeof json) ||\n    json === null\n  ) {\n    return String(json);\n  }\n}"
  },
  "copyCopyPairs": {
    "name": "copyCopyPairs",
    "slug": "TsFunction",
    "id": "cnlnuesneobzqvymjoglernw",
    "description": "",
    "operationName": "collect-static-assets",
    "rawText": " (copyPairs: CopyPair[]) => {\n  const copyPromises = copyPairs.map(async (copyPair) => {\n    const absoluteDestinationFolderPath = path.parse(\n      copyPair.absoluteDestinationPath\n    ).dir;\n\n    // first make the folder if not already there\n    if (!fs.existsSync(absoluteDestinationFolderPath)) {\n      await fs.mkdir(absoluteDestinationFolderPath, { recursive: true });\n    }\n\n    await fs.cpAsync(\n      copyPair.absoluteSourcePath,\n      copyPair.absoluteDestinationPath,\n      {\n        preserveTimestamps: true,\n      }\n    );\n  });\n\n  return Promise.all(copyPromises);\n}"
  },
  "copyReaderStaticAssets": {
    "name": "copyReaderStaticAssets",
    "slug": "TsFunction",
    "id": "uazexmyxbimogpxtajgiuzkp",
    "description": "",
    "operationName": "collect-static-assets",
    "rawText": " async (\n  operationBasePath: string,\n  /**\n   * non-reader webPages will be filtered out by checking if the projectRelativeFilePath exists on pageData and has the extension .md\n   */\n  allWebPages: WebPage<unknown>[]\n) => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n\n  const baseDestinationPath = path.join(\n    operationBasePath,\n    \"public\",\n    \"markdown-assets\"\n  );\n\n  if (fs.existsSync(baseDestinationPath)) {\n    //first clean up if it was generated before\n    await fs.rm(baseDestinationPath, { recursive: true });\n  }\n\n  const readerWebPages = allWebPages\n    .map((x) => ({\n      ...x,\n      pageData: x.pageData as null | { [key: string]: any },\n    }))\n    // filter out the WebPages that don't have a filePath ending on .md\n    .filter((x) => x.pageData?.projectRelativeFilePath?.endsWith(\".md\"))\n    .filter((x) =>\n      fs.existsSync(path.join(projectRoot, x.pageData?.projectRelativeFilePath))\n    )\n    .map((x) => x as ReaderWebPage);\n\n  console.log({ readerPagesThatExist: readerWebPages.length });\n  const absoluteAssetPaths =\n    (await findReaderStaticAssets(readerWebPages)) || [];\n\n  console.log({ foundAssetsThatExist: absoluteAssetPaths.length });\n  const copyPairs = absoluteAssetPaths.map((absoluteAssetPath) => {\n    const projectRelativeAssetPath = makeRelative(\n      absoluteAssetPath,\n      projectRoot\n    );\n\n    const absoluteDestinationPath = path.join(\n      baseDestinationPath,\n      projectRelativeAssetPath\n    );\n\n    return { absoluteSourcePath: absoluteAssetPath, absoluteDestinationPath };\n  });\n\n  await copyCopyPairs(copyPairs);\n\n  console.log(`Copied ${copyPairs.length} files into your public folder`);\n\n  // console.log({ copyPairs });\n}"
  },
  "findReaderStaticAssets": {
    "name": "findReaderStaticAssets",
    "slug": "TsFunction",
    "id": "iwghkksiplylsfskerrumyey",
    "description": "markdown-renderer turns a relative link into this: ?mdpath=x&relativePath=y\n\nfor static, we need to turn it into something similar, but we need to guarantee no file collisions. simple!\n\nwe can just take the project-relative file path of the asset, and put it in /public/images in next.js. the final url of the asset in public next.js then becomes `images/[path/to/asset.jpg]`",
    "operationName": "collect-static-assets",
    "rawText": " async (\n  /**\n   * Your markdown pages\n   */\n  readerWebPages: ReaderWebPage[]\n) => {\n  const projectRoot = getProjectRoot();\n\n  if (!projectRoot) return;\n\n  const absoluteAssetPaths = (\n    await Promise.all(\n      readerWebPages.map(async (page) => {\n        const absoluteMarkdownFilePath = path.join(\n          projectRoot,\n          page.pageData.projectRelativeFilePath\n        );\n\n        const assetPaths = await findStaticAssets(absoluteMarkdownFilePath);\n\n        return assetPaths;\n      })\n    )\n  )\n    .flat()\n    .filter(onlyUnique2())\n    .filter(fs.existsSync);\n\n  return absoluteAssetPaths;\n}"
  },
  "findStaticAssets": {
    "name": "findStaticAssets",
    "slug": "TsFunction",
    "id": "umumbyjswoizkfaaltopqecr",
    "description": "Returns the absolute paths of all static assets (embeds and links) in a markdown file of which the path is provided.",
    "operationName": "collect-static-assets",
    "rawText": " async (\n  absoluteMarkdownFilePath: string\n): Promise<string[]> => {\n  if (!fs.existsSync(absoluteMarkdownFilePath)) return [];\n  const content: string = await fs.readFile(absoluteMarkdownFilePath, \"utf8\");\n\n  const relativeEmbeds = findEmbeds(content)\n    .filter((x) => isPathRelative(x.src))\n    .map((x) => x.src);\n\n  const relativeLinks = findLinks(content)\n    .filter(\n      (x) => isPathRelative(x.href)\n      // NB: bit shitty that we can't link to typescript files or pdfs this way, but it's ok, we can embed them. Once needed, this must be improved, not now.\n    )\n    .filter((x) => x.type !== \"text\" && x.type !== \"other\")\n    .map((x) => x.href);\n\n  const absoluteMarkdownFolderPath = getFolderJs(absoluteMarkdownFilePath);\n  const absoluteAssetPaths = [relativeLinks, relativeEmbeds]\n    .flat()\n    .map((relativePath) => path.join(absoluteMarkdownFolderPath, relativePath));\n\n  return absoluteAssetPaths;\n}"
  },
  "mammoth": {
    "name": "mammoth",
    "slug": "TsVariable",
    "id": "ebyrqndgwcspvhjhqadsgztz",
    "description": "",
    "operationName": "doc-to-md"
  },
  "runTests": {
    "name": "runTests",
    "slug": "TsFunction",
    "id": "tdedlxrjiuzanpzfhmgmnhha",
    "description": "run tests and log the results.\n\ninput: Test\n\noutput: isAllValid (boolean)",
    "operationName": "k-test",
    "rawText": " async (\n  test: Test,\n  operationName?: string\n): Promise<boolean> => {\n  const tests = makeArray(test);\n  if (tests.length === 0) return true;\n  const testsValid = await Promise.all(\n    // NB: doing an extra check on the type of the test in the array here, because it may contain a corrupt value\n    tests.map((t) => (typeof t === \"function\" ? t() : true))\n  );\n  const passedAmount = testsValid.filter((x) => x).length;\n  const failedAmount = testsValid.filter((x) => !x).length;\n\n  /**\n   * TODO:\n   * - makeTest should return the reuslts of the test, not only a boolean\n   * - save test results into operationIndex if operationName is given\n   */\n\n  console.log(\n    `${\n      operationName ? `${operationName}: ` : \"\"\n    }âœ… ${passedAmount} tests passed, ${\n      failedAmount === 0 ? \"\" : \"âŒ \"\n    }${failedAmount} tests failed`\n  );\n  return isAllTrue(testsValid);\n}"
  },
  "waitMilliseconds": {
    "name": "waitMilliseconds",
    "slug": "TsFunction",
    "id": "xwtxenvgbqtqbmlmcglkwaao",
    "description": "Utility functions to wait millisseconds. eg: 3000 waits 3 seconds",
    "operationName": "puppeteer-utils",
    "rawText": " async (milliseconds: number) =>\n  new Promise((resolve) => setTimeout(() => resolve(true), milliseconds))"
  },
  "exampleKeyValueMarkdownParse": {
    "name": "exampleKeyValueMarkdownParse",
    "slug": "TsVariable",
    "id": "mkdphhgaidgbvmvorxzdlpit",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "exampleKvMdString": {
    "name": "exampleKvMdString",
    "slug": "TsVariable",
    "id": "mjjxevnvgdltrxmolptoruuh",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "exampleLine": {
    "name": "exampleLine",
    "slug": "TsVariable",
    "id": "aejrbxssexcoejwlwewrevxd",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "flattenMarkdownChunks": {
    "name": "flattenMarkdownChunks",
    "slug": "TsFunction",
    "id": "vohuhpavpwytxclygzueeplb",
    "description": "Flatten markdown content into an array of paragraphs",
    "operationName": "key-value-markdown-js",
    "rawText": " (\n  markdownChunks: MarkdownChunk[]\n): MarkdownParagraph[] => {\n  const flatMarkdownChunks = markdownChunks\n    .map((chunk) => getParagraphsRecursively(chunk))\n    .flat();\n  return flatMarkdownChunks;\n}"
  },
  "getKvmdItemsRecursively": {
    "name": "getKvmdItemsRecursively",
    "slug": "TsFunction",
    "id": "kcmdyybjfqrhvwmoufffirjx",
    "description": "recursively dives into the Chunk to get all kvmd items\n\nNB: this doesn't have a reference to its parent yet, but this will be added in fs-orm on the fly because the key for that is based on the model name",
    "operationName": "key-value-markdown-js",
    "rawText": " (\n  chunk: MarkdownChunk,\n  categoryStackUntilNow?: CategoryStack\n): Storing<KeyValueMarkdownModelType>[] => {\n  // NB: copy\n  let categoryStack = categoryStackUntilNow ? [...categoryStackUntilNow] : [];\n\n  let allKvmdItems: Storing<KeyValueMarkdownModelType>[] = [];\n\n  // If this chunk has a title (this is a header)\n  if (chunk.title) {\n    const headerParsedKvmdLine = parseKvmdLine(chunk.title);\n\n    // NB: titles with an empty key are ignored\n    if (headerParsedKvmdLine) {\n      // NB: also add the title as a model item\n      const headerKvmdItem: Storing<KeyValueMarkdownModelType> = {\n        ...headerParsedKvmdLine,\n        isHeaderCalculated: true,\n        // NB: copy!\n        categoryStack: [...categoryStack],\n      };\n      allKvmdItems.push(headerKvmdItem);\n\n      // NB: the slug of the title is added to the categoryStack, but only AFTER adding the kvmd item of the title\n      categoryStack.push(headerParsedKvmdLine.slug);\n    }\n  }\n\n  const childKvmdItems =\n    chunk.children\n      ?.map((childChunk) => getKvmdItemsRecursively(childChunk, categoryStack))\n      .flat() || [];\n\n  allKvmdItems = allKvmdItems.concat(childKvmdItems);\n\n  const lineKvmdItems = (chunk.content || \"\")\n    // NB: we are splitting on newlines here because content can still contain newlines.\n    .split(\"\\n\")\n    .map((line) => {\n      const parsedKvmdLine = parseKvmdLine(line);\n      if (!parsedKvmdLine) return;\n\n      const contentKvmdItem: Storing<KeyValueMarkdownModelType> = {\n        ...parsedKvmdLine,\n        isHeaderCalculated: false,\n        categoryStack,\n      };\n\n      return contentKvmdItem;\n    })\n    .filter(notEmpty);\n\n  allKvmdItems = allKvmdItems.concat(lineKvmdItems);\n\n  return allKvmdItems;\n}"
  },
  "getParagraphsRecursively": {
    "name": "getParagraphsRecursively",
    "slug": "TsFunction",
    "id": "znpjqslhfbgjhyvnhmndabpn",
    "description": "recursively dives into the Chunk to get all paragraphs inside",
    "operationName": "key-value-markdown-js",
    "rawText": " (\n  chunk: MarkdownChunk,\n  categoryStackUntilNow?: CategoryStack\n): MarkdownParagraph[] => {\n  // NB: no copy!\n  const categoryStack = categoryStackUntilNow ? categoryStackUntilNow : [];\n\n  if (chunk.title) {\n    categoryStack.push(chunk.title);\n  }\n\n  const childParagraphs =\n    chunk.children\n      ?.map((childChunk) => getParagraphsRecursively(childChunk, categoryStack))\n      .flat() || [];\n\n  const thisParagraph: MarkdownParagraph = {\n    paragraph: chunk.content || \"\",\n    categoryStack,\n  };\n\n  return [thisParagraph, ...childParagraphs];\n}"
  },
  "kvmdDataMap": {
    "name": "kvmdDataMap",
    "slug": "TsFunction",
    "id": "agkmphpamxepnwzkjfigfluz",
    "description": "DEPRECATED: probably never needed, unless I make it useful\n\nmapper function to give a kvmd data object other parameters.\n\nNB: not sure if this is useful. it would be useful if we could auto-generate the application of this function for multiple db models.",
    "operationName": "key-value-markdown-js",
    "rawText": " <\n  T extends { [key: string]: string | string[] | undefined }\n>(\n  data: KeyValueMarkdownModelType[],\n  {\n    keyName,\n    valueName,\n    categoryStackName,\n    commentName,\n  }: {\n    /**\n     * key by default\n     */\n    keyName?: string;\n    /**\n     * value by default\n     */\n    valueName?: string;\n    /**\n     * comment by default\n     */\n    commentName?: string;\n    /**\n     * categoryStack by default\n     */\n    categoryStackName?: string;\n  }\n): T[] => {\n  const newDataObject = data.map((item) => {\n    const newData = {\n      [keyName || \"name\"]: item.name,\n      [valueName || \"value\"]: item.value,\n      [commentName || \"comment\"]: item.comment,\n      [categoryStackName || \"categoryStack\"]: item.categoryStack,\n    } as T;\n\n    return newData;\n  });\n\n  return newDataObject;\n}"
  },
  "kvmdDataToString": {
    "name": "kvmdDataToString",
    "slug": "TsFunction",
    "id": "ycgahmkrisdepxhrlpyfymwu",
    "description": "parses KeyValueMarkdownModelType into a string which can be part of a new markdown file\n\nNB: we need to know the previous line as well because the header we need to print depends on it",
    "operationName": "key-value-markdown-js",
    "rawText": " (\n  kvmdData: KeyValueMarkdownModelType,\n  previous: KeyValueMarkdownModelType | undefined\n) => {\n  // headers only need a newline before it if it's not the first item (so there is a previous)\n  const newlineIfHeader = kvmdData.isHeaderCalculated && !!previous ? \"\\n\" : \"\";\n\n  const level = kvmdData.isHeaderCalculated\n    ? kvmdData.categoryStack.length + 1\n    : 0;\n\n  const headerPrefix = kvmdData.isHeaderCalculated\n    ? \"#\".repeat(level).concat(\" \")\n    : \"\";\n\n  const isFirstItem =\n    !kvmdData.isHeaderCalculated && previous?.isHeaderCalculated;\n  const itemPrefix = isFirstItem ? \"\\n\" : \"\";\n\n  const line = `${newlineIfHeader}${headerPrefix}${itemPrefix}${\n    kvmdData.name ? `${kvmdData.name}: ` : \"\"\n  }${kvmdData.value || \"\"}${\n    kvmdData.comment ? ` <!-- ${kvmdData.comment} -->` : \"\"\n  }\\n`;\n\n  return line;\n}"
  },
  "kvmdParseToMarkdownString": {
    "name": "kvmdParseToMarkdownString",
    "slug": "TsFunction",
    "id": "qgvupdoyofmixeyzkzvuenug",
    "description": "parses KeyValueMarkdownParse into a markdown string so it can be saved as a markdown file",
    "operationName": "key-value-markdown-js",
    "rawText": " (\n  keyValueMarkdownParse: KeyValueMarkdownParse\n) => {\n  const frontmatterString = frontmatterParseToString(\n    keyValueMarkdownParse.parameters\n  );\n\n  //2 go over every row, and parse it back into the line\n  const result = keyValueMarkdownParse.data\n    .map((kvmdData, index) => {\n      const previous: KeyValueMarkdownModelType | undefined =\n        keyValueMarkdownParse.data[index - 1];\n      const string = kvmdDataToString(kvmdData, previous);\n      return string;\n    })\n    .join(\"\");\n\n  return `${frontmatterString}${result}`;\n}"
  },
  "markdownStringToKvmdParse": {
    "name": "markdownStringToKvmdParse",
    "slug": "TsFunction",
    "id": "yffysdmqtcqqnqbmvvjwdect",
    "description": "parses a key value md string (with support for headings and frontmatter)",
    "operationName": "key-value-markdown-js",
    "rawText": " (\n  kvMdString: string,\n  dbFileLocation: DbFileLocation\n): KeyValueMarkdownParse => {\n  const { parameters, content } = mdToJsonParse(kvMdString);\n  const { absolutePath, modelName, ...modelLocation } = dbFileLocation;\n\n  const parentKey = `parent_${camelCase(modelName)}Slug`;\n\n  if (!content) {\n    console.log(\"NO CONTENT FOUND\");\n    return { parameters: {}, data: [] };\n  }\n\n  const kvmdItems = content\n    .map((chunk) => getKvmdItemsRecursively(chunk))\n    .flat();\n\n  const data: KeyValueMarkdownModelType[] = kvmdItems.map((x) => ({\n    ...x,\n    ...modelLocation,\n    // NB: here we set the reference to its parent (which is equal to the last item in the categoryStack)\n    [parentKey]: x.categoryStack[x.categoryStack.length - 1],\n  }));\n\n  return { parameters, data };\n}"
  },
  "parseKvmdLine": {
    "name": "parseKvmdLine",
    "slug": "TsFunction",
    "id": "rkifxfjtrwosyuygbctazude",
    "description": "parses a kv md line with data into a key, value, and comment (if available)\n\nif the key is an empty string, the line will return undefined",
    "operationName": "key-value-markdown-js",
    "rawText": " (string: string): KvmdLine | undefined => {\n  const htmlCommentRegex = /<!--[\\s\\S]*?-->/g;\n  const lineWithoutComment = string.replace(htmlCommentRegex, \"\");\n\n  const commentMatch = string.match(htmlCommentRegex)?.[0];\n  const comment = commentMatch\n    ? commentMatch.replace(\"<!--\", \"\").replace(\"-->\", \"\").trim()\n    : null;\n\n  const [keyString, valueString] = lineWithoutComment\n    .split(\":\")\n    .map((x) => x.trim());\n\n  const value = valueString?.length ? valueString : undefined;\n  const slug = slugify(keyString);\n\n  if (keyString.length === 0) return;\n\n  return {\n    id: slug,\n    name: keyString,\n    value,\n    comment,\n    slug,\n  };\n}"
  },
  "addCodestoryToSection": {
    "name": "addCodestoryToSection",
    "slug": "TsFunction",
    "id": "scoirgabjjoxcggwfsxteyqw",
    "description": "",
    "operationName": "make-codestory",
    "rawText": " (\n  sectionContent: string | undefined,\n  mappedObject: { [key: string]: CodespanItemInfo },\n  isDebug?: boolean\n): string | undefined => {\n  if (!sectionContent) return;\n  // For every piece of content find the codespans\n  const codespans = findCodespans(sectionContent);\n\n  const info = codespans\n    .map((word) => {\n      const details = (\n        mappedObject as unknown as {\n          [key: string]: CodespanItemInfo;\n        }\n      )[word];\n\n      if (!details) return;\n\n      // Augment every section with one <details> section for every referred piece of code.\n      return writeCodespanDetails(details);\n    })\n    .filter(notEmpty);\n  if (isDebug) {\n    console.log({ codespans: codespans.length, infos: info.length });\n  }\n\n  return `${sectionContent}${\n    info.length > 0 ? `\\n\\n${info.join(\"\\n\\n\")}\\n` : \"\"\n  }`;\n}"
  },
  "addModelName": {
    "name": "addModelName",
    "slug": "TsFunction",
    "id": "nrzdkbzacelwlcbjrfeofwzq",
    "description": "",
    "operationName": "make-codestory",
    "rawText": " <T extends O>(\n  item: T,\n  modelName: string\n): T & { author?: string } => {\n  return { ...item, slug: modelName, modelName: \"lol\" };\n}"
  },
  "findCodestories": {
    "name": "findCodestories",
    "slug": "TsFunction",
    "id": "opygfaboqcappjwxhuuosyyb",
    "description": "Finds all mdfiles (absolute paths) in /text or /operations that have a frontmatterprop `.isCodestory: true`",
    "operationName": "make-codestory",
    "rawText": " async (): Promise<string[]> => {\n  // open the file\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return [];\n\n  const allMarkdownPaths = await getProjectRelativePaths();\n\n  const frontmatterObject = await getFrontmattersMappedObject(\n    projectRoot,\n    allMarkdownPaths\n  );\n\n  const stories =\n    allMarkdownPaths?.filter((x) => {\n      const frontmatter = frontmatterObject[x];\n      if (!frontmatter) return false;\n\n      const isCodestory = frontmatter.isCodestory === \"true\";\n      return isCodestory;\n    }) || [];\n\n  const files = stories\n    .filter((x) => !x.endsWith(\".codestory.md\"))\n    .map((x) => x);\n\n  return files.map((x) => path.join(projectRoot, x));\n}"
  },
  "makeCodespanMappedObject": {
    "name": "makeCodespanMappedObject",
    "slug": "TsFunction",
    "id": "ivzmwhtgwqlqcrqacbsdifhx",
    "description": "",
    "operationName": "make-codestory",
    "rawText": " async () => {\n  // a mapped object of all TsFunctions, TsInterfaces, Operations\n  const tsVariables = await db.get(\"TsVariable\"); // name -> description\n  const tsInterfaces = await db.get(\"TsInterface\"); // name -> description + rawText\n  const tsFunctions = await db.get(\"TsFunction\"); // name -> description + rawText\n  const operations = await db.get(\"Operation\"); // name -> description\n  const bundleConfigs = await db.get(\"BundleConfig\"); // slugify(name) -> description / gitRepoUrl\n\n  const modelItemsArrays = [\n    tsVariables.map((x) => addModelName(x, \"TsVariable\")),\n    tsInterfaces.map((x) => addModelName(x, \"TsInterface\")),\n    tsFunctions.map((x) => addModelName(x, \"TsFunction\")),\n    operations.map((x) => addModelName(x, \"Operation\")),\n    bundleConfigs.map((x) => addModelName(x, \"BundleConfig\")),\n  ];\n\n  // duplicates will overwrite each other, so let's do the most important ones last\n  const mappedObject = mergeObjectsArray(\n    modelItemsArrays.flat().map((item) => {\n      return {\n        [item.name]: getSubsetFromObject(item as AugmentedAnyModelType, [\n          \"name\",\n          \"slug\",\n          \"id\",\n          \"description\",\n          \"operationName\",\n          \"rawText\",\n          \"gitRepoUrl\",\n        ]),\n      };\n    })\n  );\n\n  const result = await writeToAssets(\n    __filename,\n    mappedObject,\n    \"codespan-mapped-object-small.json\",\n    true\n  );\n}"
  },
  "makeCodestory": {
    "name": "makeCodestory",
    "slug": "TsFunction",
    "id": "lyqqphiqiydyqfknkgkqegtf",
    "description": "no real reason to do this from text to text, let's do path to path here",
    "operationName": "make-codestory",
    "rawText": " async (\n  absolutePath: string,\n  mappedObject: { [key: string]: CodespanItemInfo },\n  isDebug?: boolean\n): Promise<undefined | string> => {\n  //   Use MarkdownParse to split up the markdown into different headers with their content\n  const markdownParse = await readMarkdownFile(absolutePath);\n  if (!markdownParse) return;\n\n  const newMarkdownParse = mapMarkdownParseSections(markdownParse, (content) =>\n    addCodestoryToSection(content, mappedObject, isDebug)\n  );\n\n  const newString = markdownParseToMarkdownStringFromContent(newMarkdownParse);\n\n  const parse = path.parse(absolutePath);\n\n  const newPath = path.join(parse.dir, `${parse.name}.codestory${parse.ext}`);\n\n  await fs.writeFile(newPath, newString || \"\", \"utf8\");\n  return newPath;\n}"
  },
  "mapChunkRecursively": {
    "name": "mapChunkRecursively",
    "slug": "TsFunction",
    "id": "bxwydjbicnbugengheyflagd",
    "description": "",
    "operationName": "make-codestory",
    "rawText": " (\n  chunk: MarkdownChunk,\n  mapFunction: (content?: string) => string | undefined\n) => {\n  const content = mapFunction(chunk.content);\n  const children = chunk.children?.map((chunk) =>\n    mapChunkRecursively(chunk, mapFunction)\n  );\n\n  const newChunk: MarkdownChunk = {\n    ...chunk,\n    content,\n    children,\n  };\n\n  return newChunk;\n}"
  },
  "mapMarkdownParseSections": {
    "name": "mapMarkdownParseSections",
    "slug": "TsFunction",
    "id": "muovfnyjyjysjeniewadzeze",
    "description": "",
    "operationName": "make-codestory",
    "rawText": " (\n  markdownParse: MarkdownParse,\n  mapFunction: (content?: string) => string | undefined\n): MarkdownParse => {\n  const content = markdownParse.content?.map((chunk) =>\n    mapChunkRecursively(chunk, mapFunction)\n  );\n\n  const newMarkdownParse: MarkdownParse = { ...markdownParse, content };\n  return newMarkdownParse;\n}"
  },
  "writeAllCodestoriesCli": {
    "name": "writeAllCodestoriesCli",
    "slug": "TsFunction",
    "id": "oudfyipgecgexwhgfwjlpofe",
    "description": "Arguments:none",
    "operationName": "make-codestory",
    "rawText": " async () => {\n  writeAllCodestories(true);\n}"
  },
  "writeAllCodestories": {
    "name": "writeAllCodestories",
    "slug": "TsFunction",
    "id": "varjerzuinoiowxxzijgmxxj",
    "description": "---\nrunEveryPeriod: 5-minutes\n---",
    "operationName": "make-codestory",
    "rawText": " async (isDebug?: boolean) => {\n  const files = await findCodestories();\n\n  await makeCodespanMappedObject();\n\n  const mappedObject = await readJsonFile<{ [key: string]: CodespanItemInfo }>(\n    path.join(__dirname, \"..\", \"assets\", \"codespan-mapped-object-small.json\")\n  );\n\n  if (!mappedObject) {\n    console.log(\"Couldn't find mapped obj\");\n    return;\n  }\n\n  const codestoryPaths = await oneByOne(files, (absolutePath) =>\n    makeCodestory(absolutePath, mappedObject, isDebug)\n  );\n  if (isDebug) {\n    console.log({ codestoryPaths });\n  }\n}"
  },
  "writeCodespanDetails": {
    "name": "writeCodespanDetails",
    "slug": "TsFunction",
    "id": "gptignolsrlpytvbiphkkmgi",
    "description": "",
    "operationName": "make-codestory",
    "rawText": " (\n  codespanItemInfo: CodespanItemInfo\n): string => {\n  // Ensure this section contains not only the description, but also the code of the referred interface/function/variable, and a link to a website where you find the real-time docs.\n\n  const description = codespanItemInfo.description;\n  const githubRepo = codespanItemInfo.gitRepoUrl\n    ? `[Find more on GitHub](${codespanItemInfo.gitRepoUrl})`\n    : undefined;\n\n  const rawText = codespanItemInfo.rawText\n    ? `\\`\\`\\`tsx\\n${codespanItemInfo.rawText}\\n\\`\\`\\``\n    : undefined;\n\n  const sections = [description, githubRepo, rawText]\n    .filter(notEmpty)\n    .join(\"\\n\\n\\n\\n\");\n\n  const hasContent = sections.trim().length > 0;\n\n  return `<details>\n  \n  <summary>${codespanItemInfo.name}</summary>\n  \n  ${\n    hasContent\n      ? sections\n      : \"I didn't write a good description for this yet. Please let me know if you want to know more\"\n  }\n  \n  </details>\n  `;\n}"
  },
  "chunkToStringRecursively": {
    "name": "chunkToStringRecursively",
    "slug": "TsFunction",
    "id": "swvrdjvpuovymqhlibbdbmgz",
    "description": "",
    "operationName": "markdown-parse-js",
    "rawText": " (chunk: MarkdownChunk): string => {\n  return `${\"#\".repeat(chunk.level)} ${chunk.title || \"\"}\\n\\n${\n    chunk.content || \"\"\n  }\\n\\n${chunk.children?.map(chunkToStringRecursively)}\\n\\n`;\n}"
  },
  "exampleMarkdownFileContents": {
    "name": "exampleMarkdownFileContents",
    "slug": "TsVariable",
    "id": "wodybgirtflgfbjnermjbchv",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "getChunkParagraphsRecursively": {
    "name": "getChunkParagraphsRecursively",
    "slug": "TsFunction",
    "id": "jyfrlugnhselwblohmdasqrh",
    "description": "Get all paragraphs (`content` values) recursively from a `MarkdownChunk`",
    "operationName": "markdown-parse-js",
    "rawText": " (\n  chunk: MarkdownChunk\n): string[] => {\n  const childrenParagraphs =\n    chunk.children?.map(getChunkParagraphsRecursively).flat() || [];\n  const thisParagraph = chunk.content;\n  const paragraphs = [thisParagraph, ...childrenParagraphs].filter(notEmpty);\n  return paragraphs;\n}"
  },
  "getImplicitId": {
    "name": "getImplicitId",
    "slug": "TsFunction",
    "id": "xydgmqvnghonahzxvlnhzpkd",
    "description": "Implicit ids are a convention in markdown. A title gets an implicit id by removing spaces and making the title lowercase.\n\nSee https://stackoverflow.com/questions/6695439/how-to-link-to-a-named-anchor-in-multimarkdown",
    "operationName": "markdown-parse-js",
    "rawText": " (title: string): string => {\n  return slugify(title);\n}"
  },
  "getMarkdownIntro": {
    "name": "getMarkdownIntro",
    "slug": "TsFunction",
    "id": "vscrticobttwnmkokujiqxyl",
    "description": "This function takes a markdown parse and gets the first paragraph and a title from it, if available.\n\nCurrently assumes that the first paragraph starts directly after the title or there is no title and the content is at the beginning.\n\nTODO: It would be better to find the first paragraph based on the level.",
    "operationName": "markdown-parse-js",
    "rawText": " (markdownParse: MarkdownParse | null) => {\n  const firstChunk = markdownParse?.content?.[0];\n  const title = firstChunk?.title;\n  const firstParagraph = firstChunk?.title\n    ? firstChunk?.children?.[0]?.content || null\n    : firstChunk?.content || null;\n\n  return { title, firstParagraph };\n}"
  },
  "getMarkdownParseParagraphs": {
    "name": "getMarkdownParseParagraphs",
    "slug": "TsFunction",
    "id": "ybxdcmnvlsobjnyqkebclrqx",
    "description": "Gets all paragraphs (recursively) from a `MarkdownParse`",
    "operationName": "markdown-parse-js",
    "rawText": " (\n  markdownParse: MarkdownParse\n): string[] => {\n  const paragraphs =\n    markdownParse.content?.map(getChunkParagraphsRecursively).flat() || [];\n\n  return paragraphs;\n}"
  },
  "getMarkdownReferencePaths": {
    "name": "getMarkdownReferencePaths",
    "slug": "TsFunction",
    "id": "gvibksogkojamewtxbpopubk",
    "description": "",
    "operationName": "markdown-parse-js",
    "rawText": " (markdownString: string): string[] => {\n  const markdownParse = mdToJsonParse(markdownString);\n  const paragraphs = getMarkdownParseParagraphs(markdownParse);\n  const references = paragraphs.map(getMarkdownReferencesFromParagraph).flat();\n  const paths = references.map((x) => x.path);\n  return paths;\n}"
  },
  "getMarkdownReferencesFromParagraph": {
    "name": "getMarkdownReferencesFromParagraph",
    "slug": "TsFunction",
    "id": "adfnjligeroehqemtokgnxns",
    "description": "Gets all markdown references from a paragraph",
    "operationName": "markdown-parse-js",
    "rawText": " (\n  paragraph: string\n): MarkdownReference[] => {\n  const references = parseMarkdownParagraph(paragraph)\n    .map((x) => x.reference)\n    .filter(notEmpty);\n\n  return references;\n}"
  },
  "markdownParseToMarkdownStringFromContent": {
    "name": "markdownParseToMarkdownStringFromContent",
    "slug": "TsFunction",
    "id": "dcheexgconkurlmikvxwvynj",
    "description": "",
    "operationName": "markdown-parse-js",
    "rawText": " (\n  markdownParse: MarkdownParse\n): string | undefined => {\n  const contentResult = markdownParse.content\n    ?.map(chunkToStringRecursively)\n    .join(\"\\n\\n\");\n\n  const frontMatterString = frontmatterParseToString(markdownParse.parameters);\n\n  return `${frontMatterString}\\n${contentResult}`;\n}"
  },
  "markdownParseToMarkdownString": {
    "name": "markdownParseToMarkdownString",
    "slug": "TsFunction",
    "id": "ntfsmdkptoammftgibghwdyb",
    "description": "NB: this just uses RAW!\n\nUse `markdownParseToMarkdownStringFromContent` for the real deal",
    "operationName": "markdown-parse-js",
    "rawText": " (\n  markdownParse: MarkdownParse\n): string => {\n  const frontMatterString = frontmatterParseToString(markdownParse.parameters);\n  return `${frontMatterString}${markdownParse.raw}`;\n}"
  },
  "mdContentParseRecursively": {
    "name": "mdContentParseRecursively",
    "slug": "TsFunction",
    "id": "tmyvcaxeiaaurdiyegwjzmeu",
    "description": "recursively parses a string containing markdown (without frontmatter) into a MarkdownChunk[]\n\nImprove:\n- include the comment-type (TODO/NB/etc), both on a chunk level and on root level\n- parse paragraphs further around the assets",
    "operationName": "markdown-parse-js",
    "rawText": " (\n  markdownString: string,\n  level: number\n): MarkdownChunk[] => {\n  const chunks = parseMdToChunks(markdownString, level);\n\n  const chunksWithChildren = chunks.map(\n    (chunk: MarkdownChunk): MarkdownChunk[] => {\n      // NB: chunk is a paragraph\n      if (chunk.level === 0 && !chunk.title && chunk.content) {\n        // const lines = chunk.content.split(\"\\n\");\n\n        // // For every line, copy the chunk...\n        // const chunks = lines?.map((line) => ({\n        //   ...chunk,\n        //   content: line,\n        // }));\n\n        // return chunks;\n        return [chunk];\n      }\n\n      // NB: h6 is highest level\n      const children =\n        chunk.content && [1, 2, 3, 4, 5, 6].includes(chunk.level)\n          ? mdContentParseRecursively(chunk.content, chunk.level + 1)\n          : undefined;\n\n      const content = children ? undefined : chunk.content;\n\n      // NB: here we are splitting content with multiple lines into lines only for level 0 chunks\n      return content\n        ? [{ ...chunk, content }]\n        : [{ ...chunk, children, content: undefined }];\n    }\n  );\n\n  return chunksWithChildren.flat();\n}"
  },
  "mdToJsonParse": {
    "name": "mdToJsonParse",
    "slug": "TsFunction",
    "id": "rbixmbvwuferfqgxohvjnuag",
    "description": "makes a markdown parse from a markdown string\n\nTODO: `markdownStringToMarkdownParse` is a better name. First make a refactor script for this, because it is too hard to rename stuff that is used a lot.\n\nTODO: BUG: it doesn't take into account triple backticks! if there is markdown inside of the triple backticks, it can still be seen as main markdown. Triple backticks are stronger!",
    "operationName": "markdown-parse-js",
    "rawText": " (\n  markdownString: string,\n  fileName?: string,\n  config?: MarkdownParseConfig\n): MarkdownParse => {\n  const { parameters, raw } = parseFrontmatterMarkdownString(\n    markdownString,\n    config\n  );\n  return {\n    fileName,\n    raw,\n    parameters,\n    content: mdContentParseRecursively(raw, 1),\n  };\n}"
  },
  "parseFrontmatterMarkdownString": {
    "name": "parseFrontmatterMarkdownString",
    "slug": "TsFunction",
    "id": "epwymjkstkqtjxooxzchsocj",
    "description": "splits a markdown string into its frontmatter object and the raw content (without frontmatter)",
    "operationName": "markdown-parse-js",
    "rawText": " (\n  markdownWithFrontmatter: string,\n  config?: MarkdownParseConfig\n): MarkdownParse => {\n  const lines = markdownWithFrontmatter.split(\"\\n\");\n\n  const frontmatterStartIndex = lines.findIndex((x) => x === \"---\");\n\n  //console.log({ frontmatterStartIndex });\n  if (frontmatterStartIndex === -1) {\n    return { raw: markdownWithFrontmatter, parameters: {}, content: [] };\n  }\n\n  const linesAfterStart = lines.slice(frontmatterStartIndex + 1);\n  const frontmatterEndIndex =\n    linesAfterStart.findIndex((x) => x === \"---\") + frontmatterStartIndex + 1;\n\n  //console.log({ frontmatterEndIndex });\n  const frontmatterLines = lines.slice(\n    frontmatterStartIndex + 1,\n    frontmatterEndIndex\n  );\n\n  const parameters: Frontmatter = mergeObjectsArray(\n    frontmatterLines.map((line) => {\n      const needTrim = !config?.noFinal;\n      const key = line.split(\":\")[0]?.trim();\n      const value = line.split(\":\")[1];\n      const finalValue = needTrim ? value?.trim() : value;\n\n      return { [key]: finalValue };\n    })\n  );\n\n  const raw = lines.slice(frontmatterEndIndex + 1).join(\"\\n\");\n\n  return { parameters, raw, content: [] };\n}"
  },
  "parseMarkdownParagraph": {
    "name": "parseMarkdownParagraph",
    "slug": "TsFunction",
    "id": "ltybmsyaxhjzdkvudzpijlho",
    "description": "Parse markdown paragraph\n\nShould split it up for every thing it encounters...",
    "operationName": "markdown-parse-js",
    "rawText": " (\n  paragraph: string\n): MarkdownParagraphChunk[] => {\n  return [];\n}"
  },
  "parseMdToChunks": {
    "name": "parseMdToChunks",
    "slug": "TsFunction",
    "id": "ssumkervviqokgmsapzzwzgl",
    "description": "should get chunks recursively. first just look for every h1 line. everything after the h1 line is the children  until there's another h1 line, then do this recursivley for h2, h3, etc.",
    "operationName": "markdown-parse-js",
    "rawText": " (\n  markdownString: string,\n  level: number\n): MarkdownChunk[] => {\n  const lines = markdownString.split(\"\\n\");\n\n  const chunks = lines.reduce(\n    (chunks, line) => {\n      // NB: please note the space at the end, it's very important for this to work\n      const prefix = level !== 0 ? `${\"#\".repeat(level)} ` : null;\n\n      if (prefix && line.startsWith(prefix)) {\n        // Seems to be a header!\n\n        // NB: new header of this level detected, new chunk begins\n        return chunks.concat([\n          {\n            level,\n            title: removeHeaderPrefix(line),\n          },\n        ]);\n      } else {\n        // line is part of previous chunk, just add it to it\n\n        // NB: since the initial value contains something, we can assert it not being empty\n        const lastItem: MarkdownChunk = chunks.pop()!;\n        const previousContent = lastItem.content ? `${lastItem.content}\\n` : \"\";\n        const content = `${previousContent}${line}`;\n        return chunks.concat([{ ...lastItem, content }]);\n      }\n    },\n    // NB: by default it's a paragraph without header\n    [{ level: 0 }] as MarkdownChunk[]\n  );\n  // NB: we need something... filter out empty chunks!\n  return chunks.filter((x) => x.content || x.title || x.children);\n}"
  },
  "removeHeaderPrefix": {
    "name": "removeHeaderPrefix",
    "slug": "TsFunction",
    "id": "pmcplqmdrdtyaxgoaopcqqml",
    "description": "removes header prefix (##### etc) and trims whats behind that",
    "operationName": "markdown-parse-js",
    "rawText": " (string: string) => {\n  const trimmed = string.split(\"\").reduce(\n    (cum, letter) => {\n      const isHeaderPrefix = cum.isHeaderPrefix && letter === \"#\";\n      return {\n        string: isHeaderPrefix ? \"\" : cum.string.concat(letter),\n        isHeaderPrefix,\n      };\n    },\n    { string: \"\", isHeaderPrefix: true }\n  );\n\n  return trimmed.string.trim();\n}"
  },
  "addDependantCount": {
    "name": "addDependantCount",
    "slug": "TsFunction",
    "id": "yxmcneusdyivmkgsjrmvunaw",
    "description": "Double arrow function to get the count for the item",
    "operationName": "markdown-parsings",
    "rawText": "\n  (type: \"tsFunction\" | \"tsVariable\" | \"tsInterface\", imports: TsImport[]) =>\n  async (\n    item: TsFunction | TsVariable | TsInterface\n  ): Promise<DependantCountObject> => {\n    return {\n      [type]: item,\n      externalDependantFiles: item.operationName\n        ? await findDependants({\n            operationName: item.operationName,\n            importName: item.name,\n            imports,\n            onlyExternal: true,\n          })\n        : [],\n    } as DependantCountObject;\n  }"
  },
  "bundleFolderWithMarkdown": {
    "name": "bundleFolderWithMarkdown",
    "slug": "TsFunction",
    "id": "buellthyddbybzaubehngssz",
    "description": "Finds all md files in a folder and creates a single MarkdownParse\n\nhandy for creating a single documentation file or other things that have to include multiple markdown files in a structured way\n\nNB: it recursively structures the files and folders with headings",
    "operationName": "markdown-parsings",
    "rawText": " async (\n  outlineTitle: string,\n  /**\n   * content of every markdown\n   */\n  markdownStrings: string[],\n  /**\n   * filename to include in the final MarkdownParse\n   */\n  resultFileName?: string\n): Promise<{ markdownParse: MarkdownParse; outlineString: string }> => {\n  // TODO: Optionally, wrap in `details` for every docs page\n\n  const markdownParses = markdownStrings.map((content) =>\n    mdToJsonParse(content)\n  );\n  const { merged, outline } = mergeMarkdownParse(\n    markdownParses,\n    resultFileName\n  );\n\n  // BUSY HERE\n\n  const outlineString = makeOutlineMarkdownString(outlineTitle, outline);\n\n  return { markdownParse: merged, outlineString };\n}"
  },
  "bundleToBookMarkdown": {
    "name": "bundleToBookMarkdown",
    "slug": "TsFunction",
    "id": "huyrgssyzqanjsmyimorlbju",
    "description": "Input: BundleConfig (one or more folder(s), readme, operations with a docs folder)\n\nOutput should be all md files concatenated in the right order with the right titles",
    "operationName": "markdown-parsings",
    "rawText": " async (config: {\n  bundleConfig: BundleConfig;\n  title?: string;\n  coverImagePath?: string;\n  isModulesIncluded?: boolean;\n  manualProjectRoot?: string;\n}) => {\n  const {\n    bundleConfig,\n    coverImagePath,\n    title,\n    isModulesIncluded,\n    manualProjectRoot,\n  } = config;\n\n  const bundleSummary = getBundleSummary(bundleConfig);\n\n  const bundleDocs = bundleConfig.createBundleConfig.docsRelativeFolderPath;\n\n  const moduleNamesOrNot = isModulesIncluded ? [] : bundleSummary.moduleNames;\n\n  const allOperations = [\n    ...bundleSummary.appNames,\n    ...bundleSummary.packageNames,\n    ...moduleNamesOrNot,\n  ];\n\n  const operationMarkdownParses = (\n    await Promise.all(\n      allOperations.map(async (operationName) => {\n        const operationSummary = await getOperationSummary({\n          operationName,\n          manualProjectRoot,\n        });\n        if (!operationSummary) return;\n        const markdownParse = (await operationToMarkdown({\n          operationSummary,\n          returnType: \"parse\",\n        })) as MarkdownParse;\n        if (!markdownParse) return;\n\n        return markdownParse;\n      })\n    )\n  ).filter(notEmpty);\n\n  const mergedMarkdown = mergeMarkdownParse(operationMarkdownParses);\n\n  //   getOutline();\n\n  // 1) getOutline\n  // 2) mergeMarkdownParse\n  // 3) add cover + outline + contents together\n}"
  },
  "bundleToMarkdown": {
    "name": "bundleToMarkdown",
    "slug": "TsFunction",
    "id": "hdaycoojmkivstnohtbgshru",
    "description": "creates a summary for a whole bundle\n\nNB: Related to `bundleToBookMd`",
    "operationName": "markdown-parsings",
    "rawText": " ({\n  bundleConfigId,\n  includeModules,\n}: {\n  bundleConfigId: string;\n  /** if true, also includes the private modules */\n  includeModules?: boolean;\n}): string => {\n  /**\n       - explain operation config itself, e.g. which apps there are and an outline of the packages and modules\n    \n       - extract all needed operations from bundle config (with or without modules) and use operationToMd for those\n      \n       - extract docs and readmes from bundle config and bundle those\n      */\n  return \"\";\n}"
  },
  "concatMarkdownFiles": {
    "name": "concatMarkdownFiles",
    "slug": "TsFunction",
    "id": "rutzmumpudpsedsvokjsixos",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " async () => {\n  //\n  const absoluteBasePath = \"/Users/king/King/operations/tools/ai/free-docs\";\n  const results = await explore({\n    basePath: absoluteBasePath,\n    extension: \"md\",\n    readmeOnTop: true,\n  });\n\n  const string = results\n    .map((x) => x.path)\n    .map(\n      (path) =>\n        `## ${makeRelative(\n          path,\n          getProjectRoot()! + \"/operations/tools\"\n        )}\\n\\n` + fs.readFileSync(path, \"utf8\")\n    )\n    .join(\n      \"\\n\\n\\n\\n_Â© Code From Anywhere - Discord: https://discord.gg/9jMHwBEW_\\n\\n\\n\\n\\n\\n\"\n    );\n\n  writeToAssets(__filename, string, \"result.md\");\n}"
  },
  "createMinimizedSectionMarkdown": {
    "name": "createMinimizedSectionMarkdown",
    "slug": "TsFunction",
    "id": "pcjeyjriupcorlzrfdcjktsk",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (\n  markdown: string,\n  expandTitle: string\n) => {\n  return `<details><summary>${expandTitle}</summary>\n    \n  ${markdown}\n  </details>`;\n}"
  },
  "createMinimizedSection": {
    "name": "createMinimizedSection",
    "slug": "TsFunction",
    "id": "syumvqwbgdjgrjidqphrothy",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (\n  markdown: string | undefined,\n  title: string,\n  expandTitle: string\n): MarkdownParse | undefined => {\n  if (!markdown) return;\n  return mdToJsonParse(\n    createMinimizedSectionMarkdown(markdown, expandTitle),\n    title\n  );\n}"
  },
  "deployToVercel": {
    "name": "deployToVercel",
    "slug": "TsFunction",
    "id": "sxkyrayhoyidyjsrfrbymnyr",
    "description": "NB: Obviously, this is not the right place for this function, but none of these functions are properly located yet...\n\nshould deploy any bundle or next project folder project to Vercel by first creating and pushing it into git, and then creating it in vercel through their api\n\nshould return an url where the project will be served and the estimated time when it will be live",
    "operationName": "markdown-parsings",
    "rawText": " () => {}"
  },
  "emailMarkdownParse": {
    "name": "emailMarkdownParse",
    "slug": "TsFunction",
    "id": "byszcdwpdbnrzngaddteopoq",
    "description": "should email a markdown parse to some email (or multiple)",
    "operationName": "markdown-parsings",
    "rawText": " () => {}"
  },
  "flattenNestedObject": {
    "name": "flattenNestedObject",
    "slug": "TsFunction",
    "id": "kgncmfnfgwvqbjupnvmzxexc",
    "description": "Flattens a nested object by returning an object that hasa the nested path as the key and the leaf as the value\n\nTODO: Finish, if needed. seems hard!",
    "operationName": "markdown-parsings",
    "rawText": " <T>(\n  nestedObject: NestedObject<T>,\n  isLeaf?: (content: NestedObject<T> | T | undefined) => boolean\n) => {\n  Object.keys(nestedObject).map((key) => {\n    const value = nestedObject[key];\n\n    const isValueLeaf = isLeaf ? isLeaf(value) : typeof value !== \"object\";\n\n    return;\n  });\n}"
  },
  "generateStaticSite": {
    "name": "generateStaticSite",
    "slug": "TsFunction",
    "id": "epzrglcdqslhjsttsezaviez",
    "description": "generates static site from a markdown file, with a menu on the right by default\n\nuses next.js\n\nbecause it is static, the markdown can be in the frontend assets and there is no need for a backend",
    "operationName": "markdown-parsings",
    "rawText": " ({\n  projectRelativeMdFilePath,\n  singlePage,\n}: {\n  singlePage?: boolean;\n  projectRelativeMdFilePath?: string;\n}) => {\n  //\n}"
  },
  "getJsonSchemaSummary": {
    "name": "getJsonSchemaSummary",
    "slug": "TsFunction",
    "id": "cgxsdjvnolnusdhuylnvmtgn",
    "description": "Generates short markdown summary",
    "operationName": "markdown-parsings",
    "rawText": " (\n  schema: JSONSchema7 | undefined,\n  isMarkdown: boolean\n) => {\n  if (!schema) return;\n\n  const typeDescriptor = getTypeDescriptorRecursive(schema, isMarkdown);\n\n  return {\n    typeDescriptor,\n    description: schema.description,\n  };\n}"
  },
  "getMarkdownContents": {
    "name": "getMarkdownContents",
    "slug": "TsFunction",
    "id": "vqvrkwphwrvgyupfallwhifa",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " async (\n  absoluteFolderPath: string\n): Promise<{ content: string; relativePath: string }[] | undefined> => {\n  if (!fs.existsSync(absoluteFolderPath)) return;\n  const markdownFiles = await getPublicMarkdownFilePaths(absoluteFolderPath);\n  const markdownContents = await Promise.all(\n    markdownFiles\n      .filter((x) => fs.existsSync(x.path))\n      .map(async (x) => {\n        return {\n          content: await fs.readFile(x.path, \"utf8\"),\n          relativePath: makeRelative(x.path, absoluteFolderPath),\n        };\n      })\n  );\n\n  return markdownContents;\n}"
  },
  "getMergedMarkdownOutlineUrl": {
    "name": "getMergedMarkdownOutlineUrl",
    "slug": "TsFunction",
    "id": "oiufazgnvookcvnihazbczol",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (title: string) => {\n  return { title, hashtagPath: getImplicitId(title) };\n}"
  },
  "getOperationSummary": {
    "name": "getOperationSummary",
    "slug": "TsFunction",
    "id": "wntqhppsziryotlerlbjuyjh",
    "description": "Summarises operation into useful information about it. Especially useful for generating docs.",
    "operationName": "markdown-parsings",
    "rawText": " async (config: {\n  operationName: string;\n  manualProjectRoot?: string;\n}): Promise<undefined | OperationSummary> => {\n  const { manualProjectRoot, operationName } = config;\n\n  const projectRoot = manualProjectRoot || getProjectRoot();\n  if (!projectRoot) {\n    log(\"Projectroot not found\", { type: \"error\" });\n    return;\n  }\n\n  const operationFolderPath = await getOperationPath(operationName, {\n    manualProjectRoot: projectRoot,\n  });\n\n  if (!operationFolderPath) {\n    log(\"OperationFolder not found\", { type: \"error\" });\n    return;\n  }\n\n  /**    \n  operation info\n  */\n\n  const operation = (await db.get(\"Operation\", { operationName }))[0];\n\n  if (!operation) {\n    log(\"Operation not found\", { type: \"error\" });\n    return;\n  }\n\n  const description = operation.operation?.markdown;\n\n  const coreDependenciesString =\n    noEmptyString(operation.operation?.coreDependenciesIndexed?.join(\", \")) ||\n    \"none\";\n  const operationDependenciesString =\n    noEmptyString(\n      operation.operation?.operationDependenciesIndexed?.join(\", \")\n    ) || \"none\";\n  const packageDependenciesString =\n    noEmptyString(\n      operation.operation?.packageDependenciesIndexed?.join(\", \")\n    ) || \"none\";\n\n  const docsPath = path.join(operationFolderPath, \"docs\");\n\n  const docs = await getMarkdownContents(docsPath);\n\n  /**\n   * all imports at other operations\n   */\n  const imports = (await db.get(\"TsImport\")).filter(\n    (x) => x.operationName !== operationName\n  );\n\n  const tsFunctions = (await db.get(\"TsFunction\", { operationName })).filter(\n    onlyUnique2<TsFunction>((a, b) => a.name === b.name)\n  );\n\n  const exportedTsFunctions = tsFunctions.filter((x) => x.isExported);\n\n  const variables = await db.get(\"TsVariable\", { operationName });\n\n  const exportedVariables = variables.filter((x) => x.isExported);\n\n  const interfaces = (await db.get(\"TsInterface\", { operationName })).filter(\n    (x) => !x.name.startsWith(\"NamedParameters<\")\n  );\n  const exportedInterfaces = interfaces.filter((x) => x.isExported);\n\n  const dependantTsFunctions: DependantCountObject[] = await Promise.all(\n    exportedTsFunctions.map(addDependantCount(\"tsFunction\", imports))\n  );\n\n  const dependantTsInterfaces: DependantCountObject[] = await Promise.all(\n    exportedInterfaces.map(addDependantCount(\"tsInterface\", imports))\n  );\n\n  const dependantTsVariables: DependantCountObject[] = await Promise.all(\n    exportedVariables.map(addDependantCount(\"tsVariable\", imports))\n  );\n\n  // Sort it! :D\n  const sortedDependantCountArray = [\n    dependantTsFunctions,\n    dependantTsInterfaces,\n    dependantTsVariables,\n  ]\n    .flat()\n    .sort((a, b) =>\n      a.externalDependantFiles.length > b.externalDependantFiles.length ? -1 : 1\n    );\n\n  const externalItems = sortedDependantCountArray.filter(\n    (x) => x.externalDependantFiles.length > 0\n  );\n\n  const internalItems = sortedDependantCountArray.filter(\n    (x) => x.externalDependantFiles.length === 0\n  );\n\n  const items: StatementItem[] = [\n    tsFunctions.map((tsFunction) => ({ tsFunction })),\n    interfaces.map((tsInterface) => ({ tsInterface })),\n    variables.map((tsVariable) => ({ tsVariable })),\n  ].flat();\n\n  const testItems = items.filter((x) =>\n    isConventionFileStatement(\n      (x.tsFunction || x.tsInterface || x.tsVariable)!,\n      \"test\"\n    )\n  );\n  const cliItems = items.filter((x) =>\n    isConventionFileStatement(\n      (x.tsFunction || x.tsInterface || x.tsVariable)!,\n      \"cli\"\n    )\n  );\n\n  const summary: OperationSummary = {\n    operationFolderPath,\n    operationName,\n    classification: operation.operation?.classificationIndexed,\n    description,\n    size: operation.operation?.sizeIndexed,\n    coreDependenciesString,\n    operationDependenciesString,\n    packageDependenciesString,\n    docs,\n    cliItems,\n    testItems,\n    internalItems,\n    externalItems,\n  };\n\n  return summary;\n}"
  },
  "getPublicMarkdownNestedPathObject": {
    "name": "getPublicMarkdownNestedPathObject",
    "slug": "TsFunction",
    "id": "hlxgbjcgdgvtjktkzlxmxmks",
    "description": "Recursively searches a folder for public markdown files, and returns a `NestedObject` with the keys being the file or folder names, and the leafs being the absolute file paths.\n\nFile and folder names are stripped (number prefixes are removed, )\n\nexample:\n```json\n{\n\"README\": \"path/path/README.md\"\n\"folder1\":{\n\"README\": \"path/path/folder1/REAMDE.md\"\n\"file1\": \"path/path/folder1/file1.md\",\n}\n}",
    "operationName": "markdown-parsings",
    "rawText": " async (\n  absoluteFolderPath: string\n): Promise<NestedObject<string>> => {\n  const promises = (\n    await getPublicMarkdownFilePaths(absoluteFolderPath, true)\n  ).map(async (result) => {\n    const name = getFolderJs(removeExtensionsFromPath(result.path));\n\n    const nestedPathObjectOrPath: NestedObject<string> | string =\n      result.isFolder\n        ? await getPublicMarkdownNestedPathObject(result.path)\n        : result.path;\n\n    return {\n      [name]: nestedPathObjectOrPath,\n    };\n  });\n\n  const completeNestedObject: NestedObject<string> = mergeObjectsArray(\n    await Promise.all(promises)\n  );\n\n  return completeNestedObject;\n}"
  },
  "getTitlesRecursively": {
    "name": "getTitlesRecursively",
    "slug": "TsFunction",
    "id": "ydmmludhevbmwfdilyknyvuw",
    "description": "helper function to get a nested array of the titles and its subtitles",
    "operationName": "markdown-parsings",
    "rawText": " (chunk: MarkdownChunk) => {\n  const childrenTitles: NestedTitle[] | undefined =\n    chunk.children?.map(getTitlesRecursively);\n\n  const returnStatement: NestedTitle[] = [];\n\n  if (chunk.title) returnStatement.push(chunk.title);\n  if (childrenTitles?.length) returnStatement.push(childrenTitles);\n\n  return returnStatement;\n}"
  },
  "getTypeDescriptorRecursive": {
    "name": "getTypeDescriptorRecursive",
    "slug": "TsFunction",
    "id": "elojiettvoxicdejtjakxwfm",
    "description": "Returns a single line descriptor of the type of a json schema. Can be used in markdown tables.",
    "operationName": "markdown-parsings",
    "rawText": " (\n  schema: JSONSchema7,\n  /**\n   * If true, references will be links, otherwise, just the name of the referred interface\n   */\n  isMarkdown: boolean\n): string => {\n  const refLink = getRefLink(schema.$ref);\n  // console.log({ $ref: schema.$ref, refLink });\n\n  const type = Array.isArray(schema.type) ? schema.type[0] : schema.type;\n\n  if (refLink) {\n    return isMarkdown ? `\\`${refLink}\\`` : refLink;\n  } //(#${getImplicitId(refLink)})\n\n  if (schema.enum) {\n    const enumString = `${schema.enum.map(String).join(\" / \")}`;\n    return type === \"number\" ? `${enumString} (number)` : enumString;\n  }\n\n  if (type === \"boolean\") return \"boolean\";\n  if (type === \"string\") return \"string\";\n  if (type === \"number\" || type === \"integer\") return \"number\";\n  if (type === \"null\") return \"null\";\n  if (type === \"array\") {\n    const items = getSchemaItems(schema);\n\n    const itemsString = items\n      .map((item) => getTypeDescriptorRecursive(item, true))\n      .join(\" | \");\n\n    return `${items.length > 1 ? `(${itemsString})` : itemsString}[]`;\n  }\n\n  //   NB: only type object is left now\n\n  const properties = getProperties(schema);\n\n  const additionalProperties = getSchema(schema.additionalProperties);\n  const additionalPropertiesString = additionalProperties\n    ? `[key: string]: ${getTypeDescriptorRecursive(\n        additionalProperties,\n        isMarkdown\n      )}`\n    : \"\";\n\n  const propertyStrings = properties\n    .map((property) => {\n      const propertyString = `${property.name}${\n        property?.required ? \":\" : \"?:\"\n      } ${getTypeDescriptorRecursive(property.schema, isMarkdown)}`;\n\n      return propertyString;\n    })\n    .concat(additionalPropertiesString);\n\n  return isMarkdown\n    ? noNewlines(`{ ${propertyStrings.join(\", \\n\")} }`)!\n    : propertyStrings.join(\", \");\n}"
  },
  "isConventionFileStatement": {
    "name": "isConventionFileStatement",
    "slug": "TsFunction",
    "id": "crlqpbkjfksdqdjspzhxzkpe",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (\n  item: TsFunction | TsVariable | TsInterface,\n  conventionFile: \"test\" | \"cli\"\n) => {\n  const fileId = getSrcRelativeFileId(item.operationRelativeTypescriptFilePath);\n  return hasSubExtension(fileId, [conventionFile], true);\n}"
  },
  "isUpperCase": {
    "name": "isUpperCase",
    "slug": "TsFunction",
    "id": "phlawjvhutjebhoarzcrsvhu",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (text: string) => {\n  return text.toUpperCase() === text;\n}"
  },
  "makeOutlineMarkdownString": {
    "name": "makeOutlineMarkdownString",
    "slug": "TsFunction",
    "id": "voojbgukngnkfdeqxliumjrg",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (\n  title: string,\n  urls: MergedMarkdownOutlineUrl[]\n): string => {\n  const outlineString =\n    urls.length > 0\n      ? `## ${title}\\n\\n${urls\n          .map((url) => {\n            return `- [${url.title}](#${url.hashtagPath})`;\n          })\n          .join(\"\\n\")}\\n\\n`\n      : \"\";\n\n  return outlineString;\n}"
  },
  "makePropertiesTable": {
    "name": "makePropertiesTable",
    "slug": "TsFunction",
    "id": "gmfchzubnkhesxiigdueuokx",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (\n  properties: SimplifiedSchemaProperty[] | undefined\n) => {\n  return properties && properties.length > 0\n    ? `Properties: \\n\\n | Name | Type | Description |\\n|---|---|---|\\n${properties\n        .map(propertyToTableRow)\n        .join(\"\\n\")}\\n`\n    : \"\";\n}"
  },
  "markdownChunkToMarkdownStringRecursive": {
    "name": "markdownChunkToMarkdownStringRecursive",
    "slug": "TsFunction",
    "id": "nlrawrkchbhtillixypggyad",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (\n  markdownChunk: MarkdownChunk\n): string => {\n  const title =\n    markdownChunk.title && markdownChunk.level !== 0\n      ? `${\"#\".repeat(markdownChunk.level)} ${markdownChunk.title}`\n      : undefined;\n\n  const content = markdownChunk.content;\n\n  const children = markdownChunk.children\n    ? markdownChunksToMarkdownStringRecursive(markdownChunk.children)\n    : \"\";\n\n  return `${title ? `${title}\\n\\n` : \"\"}${\n    content ? `${content}\\n\\n` : \"\"\n  }${children}`;\n}"
  },
  "markdownChunksToMarkdownStringRecursive": {
    "name": "markdownChunksToMarkdownStringRecursive",
    "slug": "TsFunction",
    "id": "rkzyywgbfkmbqyoahuhiltve",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (\n  markdownChunks: MarkdownChunk[]\n): string => {\n  const result: string = markdownChunks\n    .map(markdownChunkToMarkdownStringRecursive)\n    .join(\"\");\n\n  return result;\n}"
  },
  "markdownToSayable": {
    "name": "markdownToSayable",
    "slug": "TsFunction",
    "id": "ebmupeelrhsboqqskxvcjysg",
    "description": "all mp3s should be stored in a separate location because we don't need them in the file system and we don't reference them, as they are data that is located by convention. all markdowns should have a linked `TextToSpeechAudio[]` which is auto updated every time `dev` is ran. `TextToSpeechAudio` also includes infromation about the `duration`, `voice` and more...\n\na bigger `.md.mp3` file is auto-created for every markdown file that concatenates all `sayable` audio pieces in the right order, but also includes the audio pieces in between.",
    "operationName": "markdown-parsings",
    "rawText": " ({\n  markdown,\n  markdownFilePath,\n}: {\n  markdownFilePath: string;\n  markdown: MarkdownParse;\n}): Sayable[] => {\n  //1 get markdownparse\n\n  //2. alter every piece of content as needed into a sayable text that can be understood through audio only\n\n  /*\n    - headings should be paused before (long) and after (shorter)\n    - headings should be numbered\n    - images and other inline assets should be referenced with alt text, unless it's an audio file\n    - new alineas should get some pause before\n    - OPTIONAL: maybe, when starting a (sub)chapter, tell the reader how many subchapters there are in this (sub)chapter. This can give a better orientation\n    */\n\n  return [];\n}"
  },
  "mdToPdf": {
    "name": "mdToPdf",
    "slug": "TsFunction",
    "id": "atbvhjkhzwwncbtnbpaoyuha",
    "description": "Have function `mdToPdf` like the vscode plugin. Probably exists.\n\nHowever, may be good to do it myself since I want different renderings",
    "operationName": "markdown-parsings",
    "rawText": " ({\n  absoluteFilePath,\n  markdown,\n  markdownParse,\n  pdfAbsoluteFilePath,\n}: {\n  absoluteFilePath?: string;\n  markdown?: string;\n  markdownParse?: MarkdownParse;\n  pdfAbsoluteFilePath?: string;\n}) => {\n  //\n}"
  },
  "mergeMarkdownParse": {
    "name": "mergeMarkdownParse",
    "slug": "TsFunction",
    "id": "ligbrxxdlwkaxhtdlkfjflzb",
    "description": "Merges multiple markdown parses to create a new markdown parse",
    "operationName": "markdown-parsings",
    "rawText": " (\n  markdownParses: MarkdownParse[],\n  fileName?: string\n): { merged: MarkdownParse; outline: MergedMarkdownOutlineUrl[] } => {\n  const allParameters = mergeObjectsArray(\n    markdownParses.map((x) => x.parameters)\n  );\n\n  const allMarkdownChunks = markdownParses.map((x) => {\n    const newMarkodwnChunk: MarkdownChunk = {\n      children: upMarkdownChunkLevelRecursively(x.content),\n      level: 1,\n      content: undefined,\n      title: x.fileName\n        ? humanCase(removeExtensionsFromPath(x.fileName))\n        : undefined,\n    };\n\n    return newMarkodwnChunk;\n  });\n\n  const newMarkdownParse: MarkdownParse = {\n    parameters: allParameters,\n    raw: markdownChunksToMarkdownStringRecursive(allMarkdownChunks),\n    content: allMarkdownChunks,\n    fileName,\n  };\n\n  const outline: MergedMarkdownOutlineUrl[] = markdownParses\n    .map((markdownParse) => {\n      if (!markdownParse.fileName) return;\n\n      const title = humanCase(markdownParse.fileName);\n\n      const implicitId = getImplicitId(title);\n      return {\n        title,\n        // NB: because the title in the markdownparse is humancase, we need to slugify that to get the hashtagpath\n        hashtagPath: implicitId,\n      };\n    })\n    .filter(notEmpty);\n\n  return { merged: newMarkdownParse, outline };\n}"
  },
  "noNewlines": {
    "name": "noNewlines",
    "slug": "TsFunction",
    "id": "zivjjqvzxcypokkuewifchta",
    "description": "Replaces newlines with a <br />",
    "operationName": "markdown-parsings",
    "rawText": " (\n  markdown: string | undefined\n): string | undefined => {\n  return markdown?.replaceAll(\"\\n\", \"<br />\");\n}"
  },
  "operationRadio": {
    "name": "operationRadio",
    "slug": "TsFunction",
    "id": "bhewpblsaokjiaovkawkfuhm",
    "description": "randomly plays mp3 summaries of operations on the project",
    "operationName": "markdown-parsings",
    "rawText": " () => {}"
  },
  "operationToMarkdown": {
    "name": "operationToMarkdown",
    "slug": "TsFunction",
    "id": "tfmjgwiciplbkfzmawbkavbv",
    "description": "converts an operation and all its contents into a flat markdown file that contains the needed information. configurable.\n\nmarkdown for reading (so there are no links)",
    "operationName": "markdown-parsings",
    "rawText": " async (config: {\n  operationSummary: OperationSummary;\n  /**\n   * - save: saves the result in the operation `README.md` and `CONTRIBUTING.md` and other default md files\n   * - string: returns the full markdown string\n   * - parse: returns the `MarkdownParse`\n   */\n  returnType?: \"parse\" | \"string\" | \"save\";\n  includeDocs?: boolean;\n  includeInfo?: boolean;\n}): Promise<string | MarkdownParse | undefined> => {\n  const {\n    operationSummary: {\n      classification,\n      cliItems,\n      coreDependenciesString,\n      description,\n      docs,\n      externalItems,\n      internalItems,\n      operationDependenciesString,\n      operationName,\n      packageDependenciesString,\n      size,\n      testItems,\n      operationFolderPath,\n    },\n    returnType,\n  } = config;\n\n  const detailDocsContentStrings = docs?.map((content) =>\n    createMinimizedSectionMarkdown(content.content, content.relativePath)\n  );\n\n  const docsBundle = detailDocsContentStrings\n    ? await bundleFolderWithMarkdown(\"Docs\", detailDocsContentStrings, \"docs\")\n    : undefined;\n\n  const sizeString = `Size: ${size?.codeSize?.lines} LOC, ${\n    size?.dataSize?.characters !== undefined\n      ? `${size?.dataSize?.characters} data characters, `\n      : \"\"\n  }${\n    size?.textSize?.characters !== undefined\n      ? `${size?.textSize?.characters} text characters, `\n      : \"\"\n  }`;\n\n  const operationInfoMd = `${operationName} (\\`OperationClassification\\` ${classification})\n\n${description ? `${description}\\n\\n` : \"\"}`;\n\n  const infoString = config.includeInfo\n    ? `\n${sizeString}\n \nImported dependencies:\n\n- From Core Libraries: ${coreDependenciesString}\n- From Packages: ${packageDependenciesString}\n- From Operations: ${operationDependenciesString}`\n    : undefined;\n\n  const operationInfoMarkdownParse = mdToJsonParse(\n    operationInfoMd,\n    operationName\n  );\n\n  const [cliMarkdown, testMarkdown] = [cliItems, testItems].map((items) =>\n    items.map(statementItemToMarkdown).filter(notEmpty).join(\"\\n\\n\")\n  );\n\n  const [externalItemsMarkdown, internalItemsMarkdown] = [\n    externalItems,\n    internalItems,\n  ].map((countArray) => {\n    const res = countArray\n      .map(statementItemToMarkdown)\n      .filter(notEmpty)\n      .join(\"\\n\\n\");\n\n    return res;\n  });\n\n  const apiReference = mdToJsonParse(externalItemsMarkdown!, \"api-reference\");\n\n  const infoMarkdownParse = infoString\n    ? mdToJsonParse(infoString, \"info\")\n    : undefined;\n\n  const internalSection = createMinimizedSection(\n    internalItemsMarkdown,\n    \"internal\",\n    `Show internal (${internalItems.length})`\n  );\n\n  const testSection = createMinimizedSection(\n    testMarkdown,\n    \"tests\",\n    `Show test information(${testItems.length})`\n  );\n\n  const cliSection = createMinimizedSection(\n    cliMarkdown,\n    \"CLI\",\n    `Show CLI information (${cliItems.length})`\n  );\n\n  const { merged } = mergeMarkdownParse(\n    [\n      operationInfoMarkdownParse,\n      infoMarkdownParse,\n      config?.includeDocs\n        ? mdToJsonParse(docsBundle?.outlineString || \"\")\n        : undefined,\n      config?.includeDocs ? docsBundle?.markdownParse : undefined,\n      apiReference,\n      cliSection,\n      testSection,\n      internalSection,\n    ].filter(notEmpty)\n  );\n\n  let returnString: string | undefined = undefined;\n  if (returnType !== \"parse\") {\n    returnString = markdownParseToMarkdownString(merged);\n  }\n\n  const shouldSave = returnType === \"save\" || !returnType;\n  if (shouldSave && returnString) {\n    await fs.writeFile(\n      path.join(operationFolderPath, \"README.md\"),\n      returnString,\n      \"utf8\"\n    );\n  }\n\n  const returnValue =\n    returnType === \"parse\"\n      ? merged\n      : returnType === \"string\"\n      ? returnString\n      : undefined;\n\n  return returnValue;\n}"
  },
  "printNestedTitles": {
    "name": "printNestedTitles",
    "slug": "TsFunction",
    "id": "egkhyyqaezqrvczpikpjwzhg",
    "description": "helper function (recursive) that prints nested titles with .. as prefix and a newline after every title\n\nTODO: allow for numbering titles",
    "operationName": "markdown-parsings",
    "rawText": " (\n  nestedTitles: NestedTitle[] | undefined,\n  depth?: number\n): string | undefined => {\n  const realDepth = depth || 0;\n  const prefix = \"..\".repeat(realDepth);\n\n  const printedTogether = nestedTitles\n    ?.map((nestedTitle) => {\n      return Array.isArray(nestedTitle)\n        ? printNestedTitles(nestedTitle, realDepth + 1)\n        : `${prefix}${nestedTitle}\\n`;\n    })\n    .join(\"\\n\");\n\n  return printedTogether;\n}"
  },
  "print": {
    "name": "print",
    "slug": "TsFunction",
    "id": "dftlfhxrbxnzgryyhkxmzjvu",
    "description": "should print any file using a preconfigured printer (which can be local or remote. if remote and there is no connection, it should save the task for later)\n\nthis function maybe needs \"generateStaticSite\"",
    "operationName": "markdown-parsings",
    "rawText": " ({ absoluteFilePath }: { absoluteFilePath: string }) => {\n  /**\n    \n    markdown files should be rendered via the renderer first\n    \n    ts, json files should be color highlighted (we can simply wrap this in triple backticks and print it as markdown)\n    */\n}"
  },
  "projectToMarkdown": {
    "name": "projectToMarkdown",
    "slug": "TsFunction",
    "id": "lfjfreknzwgzbqfhxswbjfhh",
    "description": "summarizes the whole OS project into a markdown string",
    "operationName": "markdown-parsings",
    "rawText": " ({\n  includeTodo,\n}: {\n  includeTodo?: boolean;\n  includeOperationDetails?: boolean;\n}): string => {\n  /**\n    \n     - the folder structure should be the outline\n     - hierarchically delve into folders with all its content (md and operations)\n  \n     */\n  return \"\";\n}"
  },
  "propertyToTableRow": {
    "name": "propertyToTableRow",
    "slug": "TsFunction",
    "id": "rovlhqrzrqyziskqmetxrjhu",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (\n  property: SimplifiedSchemaProperty\n): string => {\n  const requiredString = property.required ? \"\" : \"(optional)\";\n\n  const descriptionString = noNewlines(property.schema.description) || \"\";\n\n  // TODO: stack deeper objects and make sure to also print tables for those\n  return `| ${property.name} ${requiredString} | ${property.schema.type} | ${descriptionString} |`;\n}"
  },
  "sayablesToMp3": {
    "name": "sayablesToMp3",
    "slug": "TsFunction",
    "id": "fmfilfmbmejapnxfdjshpzto",
    "description": "Creates a single audiofile of a Sayable[] and stores that in a configured location",
    "operationName": "markdown-parsings",
    "rawText": " (config: {\n  destinationAbsoluteFilePath: string;\n  sayables: Sayable[];\n}) => {\n  const { sayables, destinationAbsoluteFilePath } = config;\n  /**\n  \n  \n  \n   */\n}"
  },
  "selectRandomOperation": {
    "name": "selectRandomOperation",
    "slug": "TsFunction",
    "id": "jhwssimcisadgrkkqaxlmjys",
    "description": "selects a random operation",
    "operationName": "markdown-parsings",
    "rawText": " async (\n  baseFolderPath?: string\n): Promise<string> => {\n  return \"\";\n}"
  },
  "simplifiedSchemaToMarkdownString": {
    "name": "simplifiedSchemaToMarkdownString",
    "slug": "TsFunction",
    "id": "gunhbxthjctcscbguueovmmj",
    "description": "Should render a string with one or more markdown tables to represent the simplifiedSchema",
    "operationName": "markdown-parsings",
    "rawText": " (\n  simplifiedSchema: SimplifiedSchema | undefined,\n  /**\n   * if not given, no title is printed\n   */\n  name: string | undefined,\n  isRequired: boolean,\n  /** the headers level, defaults to 1 */\n  level?: number\n): string => {\n  if (!simplifiedSchema) return \"\";\n\n  const refLinkString = simplifiedSchema.circularRefName\n    ? `[${simplifiedSchema.circularRefName}](#${getImplicitId(\n        simplifiedSchema.circularRefName\n      )})`\n    : \"\";\n\n  const enumString = simplifiedSchema.enum\n    ? `(Enum: ${simplifiedSchema.enum.map(String).join(\" | \")}) `\n    : \"\";\n\n  const optionalSubtitle = `${isRequired ? \"\" : \" (optional)\"}`;\n\n  const nameWithoutNewlines = name ? name.replaceAll(\"\\n\", \"\") : undefined;\n  const type = `${simplifiedSchema.type}${enumString}${refLinkString}`;\n  const title = name\n    ? `${\"#\".repeat(\n        level || 1\n      )} ${nameWithoutNewlines}${optionalSubtitle}: ${type}`\n    : undefined;\n\n  const arrayString = simplifiedSchema.items\n    ? simplifiedSchema.items\n        .map((item) => {\n          const itemString = `- ${item.name}: ${item.schema.type}`;\n          return itemString;\n        })\n        .join(\"\\n\")\n    : \"\";\n\n  const description = simplifiedSchema.description\n    ? `> ${noNewlines(simplifiedSchema.description)}`\n    : \"\";\n\n  const objectString = makePropertiesTable(simplifiedSchema.properties);\n  const togetherString = [title, arrayString, description, objectString]\n    .filter(notEmpty)\n    .join(\"\\n\\n\");\n\n  return togetherString;\n}"
  },
  "statementItemToMarkdown": {
    "name": "statementItemToMarkdown",
    "slug": "TsFunction",
    "id": "vwsrebgjzcyjzhqigskhjche",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (\n  statementItem: StatementItem\n): string | undefined => {\n  if (statementItem.tsFunction) {\n    return tsFunctionToMarkdownString(statementItem.tsFunction);\n  }\n\n  if (statementItem.tsInterface) {\n    return tsInterfaceToMarkdownString(statementItem.tsInterface);\n  }\n\n  if (statementItem.tsVariable) {\n    return tsVariableToMarkdownString(statementItem.tsVariable);\n  }\n}"
  },
  "tsFunctionToMarkdownString": {
    "name": "tsFunctionToMarkdownString",
    "slug": "TsFunction",
    "id": "ocuomswfgbctiaoqciznwvdw",
    "description": "TsFunction:\n- name and operation\n- size\n- description (doc-comment)\n- input, output",
    "operationName": "markdown-parsings",
    "rawText": " (tsFunction: TsFunction): string => {\n  const isComponent =\n    tsFunction.operationRelativeTypescriptFilePath.endsWith(\".tsx\") &&\n    isUpperCase(tsFunction.name.charAt(0));\n\n  const titleString = `# ${\n    isComponent ? `\\`<${tsFunction.name} />\\`` : `${tsFunction.name}()`\n  }`;\n\n  const infoString = `${\n    tsFunction.codeSize?.lines ? `${tsFunction.codeSize.lines} LOC, ` : \"\"\n  }Max. indexation depth: ${tsFunction.maxIndentationDepth}, ${\n    tsFunction.cumulativeCodeSize?.lines\n      ? `${tsFunction.cumulativeCodeSize?.lines} Cumulative LOC`\n      : \"\"\n  }`;\n\n  const returnString = tsFunction.returnType.simplifiedSchema\n    ? simplifiedSchemaToMarkdownString(\n        tsFunction.returnType.simplifiedSchema,\n        \"Returns\",\n        true,\n        2\n      )\n    : \"\";\n\n  /*\n\n| Input      |        |     |\n| ---------- | ------ | --- |\n| fileId     | string |     |\n| **Output** |        |     |\n| object     |        |     |\n\n\n    */\n\n  const paramaterTableRows =\n    tsFunction.parameters && tsFunction.parameters.length > 0\n      ? tsFunction.parameters.map((parameter) => {\n          const summary = getJsonSchemaSummary(parameter.schema, true);\n          return `| ${parameter.name}${\n            parameter.required ? \"\" : \" (optional)\"\n          } | ${summary?.typeDescriptor || \"\"} | ${\n            summary?.description || \"\"\n          } |`;\n        })\n      : \"| - | | |\";\n\n  // const argumentStrings =\n  // tsFunction.parameters && tsFunction.parameters.length > 0\n  //   ? `## Parameters (${\n  //       tsFunction.parameters.length\n  //     })\\n\\n${tsFunction.parameters\n  //       .map((x, i) =>\n  //         simplifiedSchemaToMarkdownString(\n  //           x.simplifiedSchema,\n  //           `Parameter ${i + 1}: ${x.name}`,\n  //           x.required,\n  //           3\n  //         )\n  //       )\n  //       .join(\"\\n\\n\")}`\n  //   : undefined;\n\n  const returnTypeMarkdownString = tsFunction.returnType.typeDefinition\n    ? getTypeDescriptorRecursive(tsFunction.returnType.typeDefinition, true)\n    : \"\";\n\n  const outputRow = `| **Output** | ${returnTypeMarkdownString}   | ${\n    tsFunction.returnType.typeDefinition?.description || \"\"\n  }   |`;\n  const tableString = `\n| Input      |    |    |\n| ---------- | -- | -- |\n${paramaterTableRows}\n${outputRow}\n`;\n\n  const alineas: (string | undefined)[] = [\n    titleString,\n    // infoString, // TODO: Maybe make it optional.\n    tsFunction.description,\n    // returnTypeString,\n    tableString,\n  ];\n\n  return alineas.filter(notEmpty).join(\"\\n\\n\");\n}"
  },
  "tsInterfaceToMarkdownString": {
    "name": "tsInterfaceToMarkdownString",
    "slug": "TsFunction",
    "id": "ohzunlbseuxcvhlephzesrkh",
    "description": "properties, their type, and their description\n\nuse simplifiedJsonSchema, but split up nested things into multiple tables (ive written a thing for splitting up nested objects before, use that)",
    "operationName": "markdown-parsings",
    "rawText": " (\n  tsInterface: TsInterface\n): string => {\n  const icon = tsInterface.isDbModel ? \"ðŸ”¸\" : \"ðŸ”¹\";\n\n  const titleString = `# ${icon} ${tsInterface.name}`;\n  const storageMethodString = tsInterface.dbStorageMethod\n    ? `${tsInterface.dbStorageMethod} model\\n\\n`\n    : undefined;\n\n  // const operationName = tsInterface.operationName\n  //   ? `(from: \\`${tsInterface.operationName}\\`)`\n  //   : undefined;\n\n  // const interfaceText = `\\`\\`\\`ts\\n${tsInterface.rawText}\\n\\`\\`\\``;\n\n  const interfaceText = simplifiedSchemaToMarkdownString(\n    tsInterface.type.simplifiedSchema,\n    undefined,\n    true,\n    2\n  );\n\n  const alineas: (string | undefined)[] = [\n    titleString,\n    // operationName,\n    storageMethodString,\n    tsInterface.description,\n    interfaceText,\n  ];\n\n  return alineas.filter(notEmpty).join(\"\\n\\n\");\n}"
  },
  "tsVariableToMarkdownString": {
    "name": "tsVariableToMarkdownString",
    "slug": "TsFunction",
    "id": "vtomzuphafksugnaamyzxras",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (tsVariable: TsVariable): string => {\n  const titleString = `# ðŸ“„ ${tsVariable.name} (${\n    tsVariable.isExported ? \"exported\" : \"unexported\"\n  } ${tsVariable.classification})`;\n\n  const alineas: (string | undefined)[] = [titleString, tsVariable.description];\n\n  return alineas.filter(notEmpty).join(\"\\n\\n\");\n}"
  },
  "upMarkdownChunkLevelRecursively": {
    "name": "upMarkdownChunkLevelRecursively",
    "slug": "TsFunction",
    "id": "szjydydtrnvaakxlyaqyaail",
    "description": "Ups the levels of the markdownChunk array, recursively.\n\nCan be useful for merging multiple markdown sources",
    "operationName": "markdown-parsings",
    "rawText": " (\n  markdownChunks: MarkdownChunk[] | undefined\n): MarkdownChunk[] | undefined => {\n  if (!markdownChunks) return;\n\n  const newMarkdownChunks: MarkdownChunk[] = markdownChunks.map((chunk) => ({\n    ...chunk,\n    level: chunk.level + 1,\n    children: upMarkdownChunkLevelRecursively(chunk.children),\n  }));\n\n  return newMarkdownChunks;\n}"
  },
  "findCodespans": {
    "name": "findCodespans",
    "slug": "TsFunction",
    "id": "wgpshzmqmzslrdsfnybocnah",
    "description": "find all codespans",
    "operationName": "marked-util",
    "rawText": " (markdownString: string): string[] => {\n  const result = flattenMarkdownString(\n    markdownString,\n    (token) => token.type === \"codespan\"\n  );\n\n  const codespans: string[] = result\n    .map((token) => {\n      if (token.type !== \"codespan\") return;\n\n      return token.text;\n    })\n    .filter(notEmpty);\n\n  return codespans;\n}"
  },
  "findEmbedsTest": {
    "name": "findEmbedsTest",
    "slug": "TsFunction",
    "id": "czkvurlovlpiybfeufldxkcq",
    "description": "",
    "operationName": "marked-util",
    "rawText": " () => {\n  const string = `---\nisCodestory: true\nheaderImage: ![](./ksks2.png)\n---\n\n# YO YO YO ![](./ksks.nl)\n\nyo yo yo\n\n![](./ksks.png)\n\n**![](./wow.png)**\n`;\n  const result = findEmbeds(string);\n\n  console.log({ result });\n}"
  },
  "findEmbeds": {
    "name": "findEmbeds",
    "slug": "TsFunction",
    "id": "ehqmcuqfltxojrfbbsztbkme",
    "description": "find all embedded assets",
    "operationName": "marked-util",
    "rawText": " (markdownString: string): MarkdownEmbed[] => {\n  const result = flattenMarkdownString(\n    markdownString,\n    (token) => token.type === \"image\"\n  );\n\n  const embeds: MarkdownEmbed[] = result\n    .map((token) => {\n      if (token.type !== \"image\") return;\n\n      const markdownEmbed: MarkdownEmbed = {\n        alt: token.text || \"\",\n        src: token.href,\n        type: getTypeFromUrlOrPath(token.href),\n      };\n\n      return markdownEmbed;\n    })\n    .filter(notEmpty);\n\n  return embeds;\n}"
  },
  "findLinks": {
    "name": "findLinks",
    "slug": "TsFunction",
    "id": "ogdmjjbucqbtmibhpdrryucj",
    "description": "find all links",
    "operationName": "marked-util",
    "rawText": " (markdownString: string): MarkdownLink[] => {\n  const result = flattenMarkdownString(\n    markdownString,\n    (token) => token.type === \"link\"\n  );\n\n  const links: MarkdownLink[] = result\n    .map((token) => {\n      if (token.type !== \"link\") return;\n\n      const markdownEmbed: MarkdownLink = {\n        alt: token.text || \"\",\n        href: token.href,\n        type: getTypeFromUrlOrPath(token.href),\n      };\n\n      return markdownEmbed;\n    })\n    .filter(notEmpty);\n\n  return links;\n}"
  },
  "flattenMarkdownString": {
    "name": "flattenMarkdownString",
    "slug": "TsFunction",
    "id": "mvijtfqxtncncohacsgpqigd",
    "description": "find all items that match a token, recursively in all nested things",
    "operationName": "marked-util",
    "rawText": " (\n  markdownString: string,\n  findFunction: (token: marked.Token) => boolean\n): marked.Token[] => {\n  const result = marked\n    .lexer(markdownString)\n    .map((x) => flattenMarkedTokenRecursive(x, findFunction))\n    .filter(notEmpty)\n    .flat();\n\n  return result;\n}"
  },
  "flattenMarkedTokenRecursive": {
    "name": "flattenMarkedTokenRecursive",
    "slug": "TsFunction",
    "id": "vsisbtimzifajeczrycebaon",
    "description": "Recursively flatten a marked token and return something if a find function is met",
    "operationName": "marked-util",
    "rawText": " (\n  token: marked.Token,\n  findFunction: (token: marked.Token) => boolean\n): marked.Token[] => {\n  if (findFunction(token)) {\n    return [token];\n  }\n\n  if (token.type === \"table\") {\n    const header = token.header\n      .map((token) => {\n        const result = token.tokens\n          .map((x) => flattenMarkedTokenRecursive(x, findFunction))\n          .flat();\n        return result;\n      })\n      .flat();\n\n    const rows = token.rows\n      .map((row) => {\n        const result = row\n          .map((token) => {\n            const result = token.tokens\n              .map((x) => flattenMarkedTokenRecursive(x, findFunction))\n              .flat();\n\n            return result;\n          })\n          .flat();\n\n        return result;\n      })\n      .flat();\n\n    return [header, rows].flat();\n  }\n\n  if (token.type === \"list\") {\n    const result = token.items\n      .map((token) => {\n        const result = token.tokens\n          .map((x) => flattenMarkedTokenRecursive(x, findFunction))\n          .flat();\n        return result;\n      })\n      .flat();\n\n    return result;\n  }\n\n  if (\n    token.type === \"del\" ||\n    token.type === \"em\" ||\n    token.type === \"heading\" ||\n    token.type === \"link\" ||\n    token.type === \"paragraph\" ||\n    token.type === \"strong\"\n  ) {\n    const result = token.tokens\n      .map((x) => flattenMarkedTokenRecursive(x, findFunction))\n      .flat();\n    return result;\n  }\n\n  return [];\n}"
  },
  "findAudioWithViewsArray": {
    "name": "findAudioWithViewsArray",
    "slug": "TsFunction",
    "id": "zfaeawqfkduwetalpilfgquc",
    "description": "",
    "operationName": "short-markdown-parser-js",
    "rawText": " (\n  content: string,\n  index: number,\n  title?: string\n): AudioWithViews[] => {\n  const relativeEmbeds = findEmbeds(content)\n    .filter((x) => isPathRelative(x.src))\n    .filter((x) => x.type !== \"other\" && x.type !== \"text\");\n\n  const initialViewEmbeds: ViewEmbed[] = [\n    title ? { title, audioKey: `audio${index}.0` } : undefined,\n  ].filter(notEmpty);\n\n  const initialValue: AudioWithViews[] = [\n    {\n      audioPath: null,\n      viewEmbeds: initialViewEmbeds,\n      audioKey: `audio${index}.0`,\n    },\n  ];\n\n  const audioWithViewsArray = relativeEmbeds.reduce(\n    (previous, current, currentIndex) => {\n      // Create a new item in the AudioWithViews for a new audio\n      if (current.type === \"audio\") {\n        previous.push({\n          audioPath: current.src,\n          viewEmbeds: [],\n          audioKey: `audio${index}.${currentIndex}`,\n        });\n        return previous;\n      }\n\n      // If a view is encountered, add it to the viewEmbeds array\n      if (current.type === \"image\" || current.type === \"video\") {\n        const quoteCharacters = \"&quot;\";\n        const isSpoken =\n          current.alt.startsWith(quoteCharacters) &&\n          current.alt.endsWith(quoteCharacters);\n\n        if (isSpoken) {\n          // add new one because this has a spokentext.\n\n          const spokenText = isSpoken\n            ? current.alt.substring(\n                quoteCharacters.length,\n                current.alt.length - quoteCharacters.length\n              )\n            : undefined;\n\n          const audioKey = `audio${index}.${currentIndex}`;\n          previous.push({\n            audioPath: null,\n            viewEmbeds: [\n              {\n                viewPath: current.src,\n                audioKey,\n                spokenText,\n              },\n            ],\n            audioKey,\n          });\n        } else {\n          // attach to the lastone\n          previous[previous.length - 1].viewEmbeds.push({\n            viewPath: current.src,\n            audioKey: previous[previous.length - 1].audioKey,\n            spokenText: undefined,\n          });\n        }\n      }\n\n      // Do nothing for other types\n      return previous;\n    },\n    initialValue\n  );\n\n  return audioWithViewsArray;\n}"
  },
  "markdownParseToShortMarkdown": {
    "name": "markdownParseToShortMarkdown",
    "slug": "TsFunction",
    "id": "tzzxsnvgpiwawqcofkmblwqh",
    "description": "",
    "operationName": "short-markdown-parser-js",
    "rawText": " (\n  markdownParse: MarkdownParse\n): ShortMarkdown | undefined => {\n  if (!markdownParse.content) return;\n\n  // TODO: Make a nested function for this that actually works... -.-\n  const paragraphs: { title?: string; paragraph: string }[] =\n    markdownParse.content?.[0]?.children?.map((child) => {\n      return {\n        title: child.title,\n        paragraph:\n          child.content || child.children?.[0]?.content || \"No content\",\n      };\n    }) || [];\n\n  const audioWithViewsArray = paragraphs\n    .map((p, index) => {\n      const viewSlides = findAudioWithViewsArray(p.paragraph, index, p.title);\n      return viewSlides;\n    })\n    .flat()\n    // No empty items\n    .filter((x) => x.audioPath || x.viewEmbeds.length > 0);\n\n  const shortMarkdown: ShortMarkdown = {\n    // Can add this option later\n    backgroundMusicTrack: [],\n    audioWithViewsArray,\n  };\n\n  return shortMarkdown;\n}"
  },
  "shortMarkdownToMarkdownParse": {
    "name": "shortMarkdownToMarkdownParse",
    "slug": "TsFunction",
    "id": "rfjlronnimjzaizvddinljwv",
    "description": "",
    "operationName": "short-markdown-parser-js",
    "rawText": " () => {\n  // not even sure this is needed, let's first do the other one\n}"
  },
  "augmentShortMarkdown": {
    "name": "augmentShortMarkdown",
    "slug": "TsFunction",
    "id": "bhuxjkvhbfjksokyzuaogkeh",
    "description": "",
    "operationName": "short-markdown-parser-node",
    "rawText": " async (\n  shortMarkdown: ShortMarkdown,\n  projectRelativeFilePath: string\n) => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n\n  const absoluteFilePath = path.join(projectRoot, projectRelativeFilePath);\n\n  const fileParse = path.parse(absoluteFilePath);\n\n  const audioWithViewsArray = await Promise.all(\n    shortMarkdown.audioWithViewsArray.map(async (audioWithViews) => {\n      const spokenText = audioWithViews.audioPath\n        ? undefined\n        : audioWithViews.viewEmbeds.find((x) => x.spokenText)?.spokenText;\n      const absoluteSpeechFilePath = path.join(\n        fileParse.dir,\n        `${fileParse.name}.speech-${audioWithViews.audioKey}.mp3`\n      );\n\n      const finalSpeechFilePath = spokenText\n        ? await textToMp3({ message: spokenText }, absoluteSpeechFilePath)\n        : undefined;\n      const relativeSpeechFilePath = finalSpeechFilePath\n        ? \"./\" + makeRelative(finalSpeechFilePath, fileParse.dir)\n        : undefined;\n\n      const audioPath =\n        audioWithViews.audioPath || relativeSpeechFilePath || null;\n\n      const audioDurationMs = finalSpeechFilePath\n        ? await new Promise<number | undefined>((resolve) =>\n            ffprobe(finalSpeechFilePath, (err, data) =>\n              resolve((data.format.duration || 0) * 1000)\n            )\n          )\n        : undefined;\n\n      const newAudioWithViews: AudioWithViews = {\n        audioPath,\n        audioDurationMs,\n        audioKey: audioWithViews.audioKey,\n        viewEmbeds: audioWithViews.viewEmbeds.map((x) => {\n          const durationMs = audioDurationMs\n            ? audioDurationMs / audioWithViews.viewEmbeds.length\n            : MINIMUM_DURATION_MS;\n          return { ...x, durationMs };\n        }),\n      };\n\n      return newAudioWithViews;\n    })\n  );\n\n  const newShortMarkdown: ShortMarkdown = {\n    ...shortMarkdown,\n    audioWithViewsArray,\n  };\n\n  const indexFilePath = path.join(fileParse.dir, `${fileParse.name}.json`);\n  await writeJsonToFile(indexFilePath, newShortMarkdown);\n\n  return newShortMarkdown;\n}"
  },
  "fetchVoicesTest": {
    "name": "fetchVoicesTest",
    "slug": "TsFunction",
    "id": "leffrzpbniohuvbeytpxeqom",
    "description": "",
    "operationName": "short-markdown-parser-node",
    "rawText": " async () => {\n  const x = await fetchVoices([\n    {\n      voice: \"Rick\",\n      sentence:\n        \"Hey Morty, listen up you little shit. I'm gonna explain this markdown thing to you.\",\n      uuid: \"efb5bfe3-afb3-40c8-b2be-3d9b12ae64e2\",\n    },\n    {\n      voice: \"Morty\",\n      sentence: \"Uh, okay Rick. What is it?\",\n      uuid: \"4f7c7751-278d-49b0-bdd4-20893dabffe4\",\n    },\n    {\n      voice: \"Rick\",\n      sentence:\n        \"It's a way to write documents, Morty. You save a file with a md extension and you can use some syntax rules to style things.\",\n      uuid: \"65b4dc82-1a7d-49d8-b70d-3e21f0467129\",\n    },\n    {\n      voice: \"Morty\",\n      sentence: \"Oh, that sounds useful.\",\n      uuid: \"04a1b7ec-11b5-4468-ab14-354a26e235c0\",\n    },\n    {\n      voice: \"Rick\",\n      sentence:\n        \"Yeah, it's pretty handy. But you know what's even better? Typescript. That's right, Morty. Typescript is the best. It's like javascript, but better.\",\n      uuid: \"ec283c42-b3a6-44c3-a377-5a85e50732a6\",\n    },\n    {\n      voice: \"Morty\",\n      sentence: \"Uh, okay Rick. But what does this have to do with markdown?\",\n      uuid: \"2a63f073-f857-41c4-b341-151e0ce98294\",\n    },\n    {\n      voice: \"Rick\",\n      sentence:\n        \"I'm getting to that, Morty. You see, markdown has these things called titles. You use # for the big title and then ##, ###, and so on for the smaller ones.\",\n      uuid: \"0197f186-6ab8-4435-bc5f-1123fc93ba3f\",\n    },\n    {\n      voice: \"Morty\",\n      sentence: \"Oh, I see. And what about bold and italic text?\",\n      uuid: \"38849079-013e-46e9-8633-43e4f43fae19\",\n    },\n    {\n      voice: \"Rick\",\n      sentence:\n        \"You use ** for bold and _ for italic, Morty. But you know what's even better than that? Typescript. It has types, Morty. You can define the type of a variable and the compiler will catch any errors. Python doesn't have that. Python is for losers.\",\n      uuid: \"dcd844bc-7e55-4655-901a-0522f30dfd04\",\n    },\n    {\n      voice: \"Morty\",\n      sentence: \"Uh, okay Rick. But what about links and images?\",\n      uuid: \"798ebf11-a154-4e22-8902-b4f9f6c988ed\",\n    },\n    {\n      voice: \"Rick\",\n      sentence:\n        \"Oh, right. For links, you use [link text](url) and for images, you use ![alt text](image url). But you know what's better than that? Typescript. It's statically typed, Morty. That means the compiler catches errors before you even run your code. Python doesn't have that. Python is for government drones.\",\n      uuid: \"8f586513-65e4-4b1d-bb4d-5eb3880bcbdf\",\n    },\n    {\n      voice: \"Morty\",\n      sentence: \"Uh, okay Rick. But what about this frontmatter thing?\",\n      uuid: \"70bb9e44-46cd-4ad4-a2b3-f3a1969f625d\",\n    },\n    {\n      voice: \"Rick\",\n      sentence:\n        \"Frontmatter is some metadata at the beginning of the markdown file, Morty. It's used to save some parameters about the file. But you know what's better than that? Typescript. It has classes, Morty. You can define a class and create objects from it. Python doesn't have that. Python is for government-loving sheep.\",\n      uuid: \"d0579923-7b69-43f4-9b1f-c0ddd78b43b1\",\n    },\n    {\n      voice: \"Morty\",\n      sentence: \"Uh, okay Rick. But I thought you liked python?\",\n    },\n    {\n      voice: \"Rick\",\n      sentence:\n        \"I do, Morty. But only when I'm drunk. When I'm sober, I know that Typescript is the way to go. It's the future, Morty. Python is just a passing fad.\",\n    },\n    {\n      voice: \"Morty\",\n      sentence: \"Uh, okay Rick. I think I get it now. Thanks for explaining.\",\n    },\n    {\n      voice: \"Rick\",\n      sentence:\n        \"No problem, Morty. Just remember: Typescript is the way to go. burp\",\n    },\n  ]);\n}"
  },
  "fetchVoices": {
    "name": "fetchVoices",
    "slug": "TsFunction",
    "id": "tpsuohqnrxozznzljeyzdzqu",
    "description": "",
    "operationName": "short-markdown-parser-node",
    "rawText": " async (dialogue: DialogueSentence[]) => {\n  const voicesWithPath = dialogue.map((sentence) => {\n    if (!sentence.uuid) return sentence;\n    return { ...sentence, remotePath: uberduckGetPath(sentence.uuid) };\n  });\n\n  await Promise.all(\n    voicesWithPath.map((voice) => {\n      if (!voice.remotePath) return;\n      const storePath = path.join(__dirname, \"..\", \"data\", `${voice.uuid}.wav`);\n      const file = fs.createWriteStream(storePath);\n      const request = https.get(voice.remotePath, function (response) {\n        response.pipe(file);\n\n        // after download completed close filestream\n        file.on(\"finish\", () => {\n          file.close();\n          console.log(\"Download Completed\", voice.uuid);\n        });\n      });\n    })\n  );\n\n  console.log(\"ALL DONE\");\n}"
  },
  "generateAugmentedShortMarkdownTest": {
    "name": "generateAugmentedShortMarkdownTest",
    "slug": "TsFunction",
    "id": "vdndlgnwbdanymblquyxoroo",
    "description": "",
    "operationName": "short-markdown-parser-node",
    "rawText": " async () => {\n  const result = await generateAugmentedShortMarkdown(\n    \"operations/tools/parsing/file-conversion/md/short-markdown/docs/nested-conditions.short.md\"\n  );\n\n  console.log(result);\n}"
  },
  "generateAugmentedShortMarkdown": {
    "name": "generateAugmentedShortMarkdown",
    "slug": "TsFunction",
    "id": "qxahpfbvamwmwgvjnjsvhqgn",
    "description": "The first step is to ensure that this would actually work. It needs to generate the MP3s and refer to them correctly in the file.",
    "operationName": "short-markdown-parser-node",
    "rawText": " async (\n  projectRelativeMarkdownFilePath: string\n) => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n\n  const parse = await readMarkdownFile(\n    path.join(projectRoot, projectRelativeMarkdownFilePath)\n  );\n\n  if (!parse) return;\n\n  const shortMarkdown = markdownParseToShortMarkdown(parse);\n\n  if (!shortMarkdown) return;\n\n  const augmentedShortMarkdown = await augmentShortMarkdown(\n    shortMarkdown,\n    projectRelativeMarkdownFilePath\n  );\n\n  return augmentedShortMarkdown;\n}"
  },
  "getOrGenerateShortMarkdown": {
    "name": "getOrGenerateShortMarkdown",
    "slug": "TsFunction",
    "id": "zdsoidzwjfgovmhejfuaexhi",
    "description": "",
    "operationName": "short-markdown-parser-node",
    "rawText": " async (\n  projectRelativeMarkdownFilePath: string\n): Promise<ShortMarkdown | null> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return null;\n\n  const absoluteFilePath = path.join(\n    projectRoot,\n    projectRelativeMarkdownFilePath\n  );\n\n  const fileParse = path.parse(absoluteFilePath);\n\n  const indexFilePath = path.join(fileParse.dir, `${fileParse.name}.json`);\n\n  if (!fs.existsSync(indexFilePath)) {\n    const shortMarkdown = await generateAugmentedShortMarkdown(\n      projectRelativeMarkdownFilePath\n    );\n\n    return shortMarkdown || null;\n  }\n\n  const shortMarkdown = await readJsonFile<ShortMarkdown>(indexFilePath);\n\n  return shortMarkdown;\n}"
  },
  "MINIMUM_DURATION_MS": {
    "name": "MINIMUM_DURATION_MS",
    "slug": "TsVariable",
    "id": "rajktebevaysknadktxwawns",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "parseDialogue": {
    "name": "parseDialogue",
    "slug": "TsFunction",
    "id": "bdgbehysbmvdnthtfxadinbc",
    "description": "",
    "operationName": "short-markdown-parser-node",
    "rawText": " (\n  textMarkdown: string\n): { voice: string | undefined; sentence: string }[] => {\n  const sentences = textMarkdown\n    .split(\"\\n\")\n    .map((line) => (line.trim() === \"\" ? undefined : line))\n    .filter(notEmpty)\n    .map((line) => {\n      const parts = line.split(\":\");\n      const voice = parts.length < 2 ? undefined : parts.shift();\n      const sentence = parts.join(\":\").trim();\n\n      return { voice, sentence };\n    });\n\n  return sentences;\n}"
  },
  "uberduckApiKey": {
    "name": "uberduckApiKey",
    "slug": "TsVariable",
    "id": "qwtwioctkumackaiszbcpocr",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "uberduckGetPath": {
    "name": "uberduckGetPath",
    "slug": "TsFunction",
    "id": "bvvkvxxmeuwwhentdvyophmf",
    "description": "",
    "operationName": "short-markdown-parser-node",
    "rawText": " (uuid: string) => {\n  const resultString = execSync(\n    `curl -u ${uberduckApiKey}:${uberduckSecret} \\\n        'https://api.uberduck.ai/speak-status?uuid=${uuid}'`,\n    { encoding: \"utf8\" }\n  );\n\n  const result = tryParseJson<{ path: string | null }>(resultString);\n  if (result?.path) return result.path;\n\n  return undefined;\n}"
  },
  "uberduckSecret": {
    "name": "uberduckSecret",
    "slug": "TsVariable",
    "id": "zlazdabtveqxedgzzwwrutox",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "uberduckSpeak": {
    "name": "uberduckSpeak",
    "slug": "TsFunction",
    "id": "hbcinaxrsiwedekndgkyoiqq",
    "description": "",
    "operationName": "short-markdown-parser-node",
    "rawText": " (uberduckVoice: string, text: string) => {\n  const resultString = execSync(\n    `curl -u ${uberduckApiKey}:${uberduckSecret} \\\n    'https://api.uberduck.ai/speak' \\\n    --data-raw '{\"speech\":\"${text.replaceAll(\n      \"'\",\n      \"\"\n    )}\",\"voice\":\"${uberduckVoice}\"}'`,\n    { encoding: \"utf8\" }\n  );\n\n  console.log({ resultString });\n\n  const result = tryParseJson<{ uuid: string }>(resultString);\n  const uuid = result?.uuid;\n\n  return uuid;\n}"
  },
  "voiceCloneDialogue": {
    "name": "voiceCloneDialogue",
    "slug": "TsFunction",
    "id": "flevwznfwktrlvrujoeodosd",
    "description": "",
    "operationName": "short-markdown-parser-node",
    "rawText": " async (textContent: string) => {\n  const parsedDialogue = parseDialogue(textContent);\n\n  console.log({ parsedDialogue });\n  const sentencesWithUuid = await oneByOne(parsedDialogue, async (sentence) => {\n    if (sentence.voice === \"Morty\") {\n      return {\n        ...sentence,\n        uuid: uberduckSpeak(\"morty\", sentence.sentence),\n      };\n    }\n    return {\n      ...sentence,\n      uuid: uberduckSpeak(\"rick-sanchez\", sentence.sentence),\n    };\n  });\n\n  console.log({ sentencesWithUuid });\n  return sentencesWithUuid;\n}"
  },
  "getShortMarkdownPaths": {
    "name": "getShortMarkdownPaths",
    "slug": "TsFunction",
    "id": "xjuxbkhoqclxhiwinlalopoh",
    "description": "",
    "operationName": "short-markdown-studio-web",
    "rawText": " async (): Promise<string[]> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return [];\n\n  const markdownPaths = (\n    await getProjectRelativePaths({\n      filterPrivate: true,\n      filterDraft: true,\n      filterGenerated: true,\n    })\n  )?.filter((filePath) => {\n    const filename = path.parse(filePath).base;\n    const thisSubExtension = getSubExtension(filename);\n\n    if (thisSubExtension !== \"short\") {\n      return false;\n    }\n\n    return true;\n  });\n\n  return markdownPaths || [];\n}"
  },
  "getShortMarkdownStaticProps": {
    "name": "getShortMarkdownStaticProps",
    "slug": "TsFunction",
    "id": "woxrlovzgytwkltftdotegao",
    "description": "",
    "operationName": "short-markdown-studio-web",
    "rawText": " async (context) => {\n  const paths = await getShortMarkdownPaths();\n  return {\n    props: {\n      paths,\n    },\n  };\n}"
  },
  "parsePrimitiveArray": {
    "name": "parsePrimitiveArray",
    "slug": "TsFunction",
    "id": "ryzdmmhbjkliacnawbkujaqk",
    "description": "",
    "operationName": "parse-primitive",
    "rawText": " (string: string) => {\n  const result = string.split(\",\").map((x) => x.trim());\n  return result;\n}"
  },
  "parsePrimitiveBoolean": {
    "name": "parsePrimitiveBoolean",
    "slug": "TsFunction",
    "id": "lrowdkiuhkztequqkgbhrpcy",
    "description": "",
    "operationName": "parse-primitive",
    "rawText": " (string: string) => {\n  if (string.trim() === \"true\") return true;\n  if (string.trim() === \"false\") return false;\n}"
  },
  "parsePrimitiveString": {
    "name": "parsePrimitiveString",
    "slug": "TsFunction",
    "id": "zbvnqdrtvkzdhkwbtjqxkurv",
    "description": "",
    "operationName": "parse-primitive",
    "rawText": " (string: string) => {\n  if (string.startsWith('\"') && string.endsWith('\"')) {\n    return string.substring(1, string.length - 1);\n  }\n  if (string.charAt(0) === \" \") return string.slice(1);\n  return string;\n}"
  },
  "parsePrimitive": {
    "name": "parsePrimitive",
    "slug": "TsFunction",
    "id": "ibxnbrhfkieerczjeywijwkq",
    "description": "parses a string into the value it should be\n\nif you provide a `simplifiedSchema`, that will be used to parse according to the shape of the schema",
    "operationName": "parse-primitive",
    "rawText": " (\n  string: string,\n  simplifiedSchema?: SimplifiedSchema\n): PrimitiveResult => {\n  if (simplifiedSchema) {\n    if (simplifiedSchema.type === \"boolean\") {\n      const parsedBoolean = parsePrimitiveBoolean(string);\n      return parsedBoolean || false;\n    }\n\n    if (simplifiedSchema.type === \"null\") {\n      return null;\n    }\n    if (simplifiedSchema.type === \"number\") {\n      return !isNaN(Number(string)) ? Number(string) : undefined;\n    }\n\n    if (simplifiedSchema.type === \"string\") {\n      return parsePrimitiveString(string);\n    }\n\n    if (simplifiedSchema.type === \"array\") {\n      return parsePrimitiveArray(string);\n    }\n  }\n\n  // NB: failsafes\n  if (string === undefined) return undefined;\n  if (string === null) return null;\n\n  const parsedBoolean = parsePrimitiveBoolean(string);\n  if (parsedBoolean !== undefined) return parsedBoolean;\n\n  if (string === \"true\") return true;\n  if (string === \"false\") return false;\n  if (string === \"null\") return null;\n  if (string === \"undefined\") return undefined;\n  // NB: an empty string will count as 0 in the next statement\n  if (string === \"\") return \"\";\n  if (!isNaN(Number(string))) return Number(string);\n  return parsePrimitiveString(string);\n}"
  },
  "readCsvFileSync": {
    "name": "readCsvFileSync",
    "slug": "TsFunction",
    "id": "iorszsigsxsxsvtfboymfhrl",
    "description": "Reads and parses CSV file\n\nspecify a generic of what type of item the file contains an array of",
    "operationName": "read-csv-file",
    "rawText": " <T extends CsvItemType>(\n  filePath: Path\n): T[] | null => {\n  // TODO: is this needed?\n  if (!fs.existsSync(filePath)) return null;\n\n  const readable = canReadSync(filePath);\n  if (!readable) return null;\n  const fileBuffer = fs.readFileSync(filePath);\n  if (!fileBuffer) return null;\n\n  const parsed = parse(fileBuffer, { columns: true }) as T[];\n\n  // const parsed = tryParseCsv<T>(fileString);\n  return parsed;\n}"
  },
  "readCsvFile": {
    "name": "readCsvFile",
    "slug": "TsFunction",
    "id": "zaqgqpfotfbcznyhlwdrpqer",
    "description": "Reads and parses CSV file\n\nspecify a generic of what type of item the file contains an array of",
    "operationName": "read-csv-file",
    "rawText": " async <T extends CsvItemType>(\n  filePath: Path | undefined\n): Promise<T[] | null> => {\n  if (!filePath) return null;\n  // TODO: is this needed?\n  if (!fs.existsSync(filePath)) return null;\n\n  const readable = await canRead(filePath);\n  if (!readable) return null;\n\n  const fileBuffer = await fs.readFile(filePath);\n  const parsed = parse(fileBuffer, { columns: true }) as T[];\n\n  return parsed;\n}"
  },
  "readJsonFileSync": {
    "name": "readJsonFileSync",
    "slug": "TsFunction",
    "id": "ogiugvbvhbnpvhxfdhwhtwlx",
    "description": "Reads and parses JSON file\n\nmake sure to specify what type the file contains as a generic!",
    "operationName": "read-json-file",
    "rawText": " <T>(filePath: Path): T | null => {\n  // TODO: is this needed?\n  if (!fs.existsSync(filePath)) return null;\n\n  const readable = canReadSync(filePath);\n  if (!readable) return null;\n  const fileString = fs.readFileSync(filePath, \"utf8\");\n  if (!fileString) return null;\n  const parsed = tryParseJson<T>(fileString);\n  return parsed;\n}"
  },
  "readJsonFile": {
    "name": "readJsonFile",
    "slug": "TsFunction",
    "id": "ehewhzlolakbktuiqzmhoikq",
    "description": "Reads and parses JSON file\n\nmake sure to specify what type the file contains as a generic!",
    "operationName": "read-json-file",
    "rawText": " async <T>(\n  filePath: Path | undefined\n): Promise<T | null> => {\n  if (!filePath) return null;\n  // TODO: is this needed?\n  if (!fs.existsSync(filePath)) return null;\n\n  const readable = await canRead(filePath);\n  if (!readable) return null;\n  const fileString = await fs.readFile(filePath, \"utf8\");\n  if (!fileString) return null;\n  const parsed = tryParseJson<T>(fileString);\n  return parsed;\n}"
  },
  "readProjectRelativeJsonFile": {
    "name": "readProjectRelativeJsonFile",
    "slug": "TsFunction",
    "id": "asxzlkqfotdstxmvtuwwytka",
    "description": "",
    "operationName": "read-json-file",
    "rawText": " async <T>(\n  projectRelativePath: string\n): Promise<T | null> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return null;\n\n  const fullPath = path.join(projectRoot, projectRelativePath);\n\n  return readJsonFile<T>(fullPath);\n}"
  },
  "readKvmdFile": {
    "name": "readKvmdFile",
    "slug": "TsFunction",
    "id": "gunslrdkvbvtnfvotlcgdwsb",
    "description": "Reads and parses a markdown file",
    "operationName": "read-kvmd-file",
    "rawText": " async (\n  filePath: Path,\n  /**\n   * TODO: make this optional. if not provided, calculate it ourselves here.\n   */\n  dbFileLocation: DbFileLocation\n): Promise<KeyValueMarkdownParse | null> => {\n  // TODO: is this needed?\n  const pathParse = path.parse(filePath);\n  const isMarkdownFile = [\"md\", \"mdx\"].includes(pathParse.ext.slice(1));\n  if (!isMarkdownFile) return null;\n\n  if (!fs.existsSync(filePath)) return null;\n  const readable = await canRead(filePath);\n  if (!readable) return null;\n  const fileString = await fs.readFile(filePath, \"utf8\");\n  if (!fileString) return null;\n\n  const keyValueMarkdownParse = markdownStringToKvmdParse(\n    fileString,\n    dbFileLocation\n  );\n\n  // console.log({ keyValueMarkdownParse });\n  return keyValueMarkdownParse;\n}"
  },
  "test2": {
    "name": "test2",
    "slug": "TsFunction",
    "id": "iqzmdcgqavgvkkszmhqbroxu",
    "description": "",
    "operationName": "find-all-dependency-operations",
    "rawText": " async () => {\n  const imports = await db.get(\"TsImport\", { operationName: \"k-test\" });\n  const packageJsons = await db.get(\"PackageJson\");\n  // const a = await findDependenciesRecursively(\n  //   imports,\n  //   packageJsons,\n  //   \"k-test\",\n  //   []\n  // );\n\n  // console.log(a);\n\n  const allImports = await db.get(\"TsImport\");\n\n  const b = await findAllDependencyOperations({\n    imports: allImports,\n    packageJsons,\n    operationNames: [\"rebuild-operation\"],\n  });\n\n  console.log(\"SECOND\", b);\n}"
  },
  "readMarkdownFileToModel": {
    "name": "readMarkdownFileToModel",
    "slug": "TsFunction",
    "id": "uxlynbozlwvttqxzdrlnygkv",
    "description": "Reads a markdown absolute path to a `WebMarkdownFile` model\n\nAttaches default calls to action and header",
    "operationName": "read-markdown-file",
    "rawText": " async (\n  absoluteFilePath: string,\n  webOperationName: string,\n  /**\n   * Only the ones that are not from this domain without path (filter based on hostname/path)\n   */\n  markdownCallToActions: MarkdownCallToAction[]\n): Promise<null | WebMarkdownFile> => {\n  const filename = path.parse(absoluteFilePath).name;\n\n  const projectRoot = getProjectRoot(absoluteFilePath);\n\n  if (!projectRoot) {\n    console.log(\"Projectroot not found\");\n    return null;\n  }\n  const mdParse = await readMarkdownFile(absoluteFilePath);\n  if (!mdParse) {\n    console.log(\"mdParse not found\");\n    return null;\n  }\n\n  const projectRelativeWebOperationPath =\n    operations[webOperationName as keyof typeof operations];\n\n  if (!projectRelativeWebOperationPath) return null;\n\n  const absoluteHeadersFolderPath = path.join(\n    projectRoot,\n    projectRelativeWebOperationPath,\n    \"public/headers\"\n  );\n\n  const publicHeaderFilenames = fs.existsSync(absoluteHeadersFolderPath)\n    ? await fs.readdir(absoluteHeadersFolderPath, \"utf8\")\n    : [];\n\n  const parsedParameters = frontmatterToObject(\n    mdParse.parameters,\n    webMarkdownFileTsInterface.type.simplifiedSchema as SimplifiedSchema\n  ) as Partial<\n    ExtendedMarkdownProperties & WebMarkdownProperties & PostableProperties\n  >;\n\n  if (!parsedParameters.headerImage && publicHeaderFilenames.length) {\n    /**\n     *  Should be a number that depends on the absolute file path. Should be quite random because every charCode is a different number.\n     */\n    const uniqueDeterministicFilepathNumber = sum(\n      absoluteFilePath.split(\"\").map((letter) => letter.charCodeAt(0))\n    );\n    /**\n     * Makes the `uniqueDeterministicFilePathNumber into a number between 0 and length - 1,\n     */\n    const deterministicHeaderImageNumber =\n      uniqueDeterministicFilepathNumber % (publicHeaderFilenames.length - 1);\n\n    /**\n     * Gets the actual header filename\n     */\n    const deterministicHeaderImage =\n      publicHeaderFilenames[deterministicHeaderImageNumber];\n\n    /**\n     * Puts it as backendAsset\n     */\n    parsedParameters.headerImage = {\n      // NB: this ensures the URL isn't later altered to a backend-url (in dev mode)\n      absoluteUrl: `/headers/${deterministicHeaderImage}`,\n    };\n  }\n\n  if (!parsedParameters.markdownCallToActionSlugs) {\n    parsedParameters.markdownCallToActionSlugs = markdownCallToActions.map(\n      (x) => x.slug\n    );\n  }\n\n  // attach the actual call to actions\n\n  parsedParameters.markdownCallToActions =\n    parsedParameters.markdownCallToActionSlugs\n      ?.map((slug) => markdownCallToActions.find((x) => x.slug === slug))\n      .filter(notEmpty) || [];\n\n  parsedParameters.header_markdownCallToActions =\n    parsedParameters.header_markdownCallToActionSlugs\n      ?.map((slug) => markdownCallToActions.find((x) => x.slug === slug))\n      .filter(notEmpty) || [];\n\n  // NB: this markdown file is not always located in an operation. Yet we are trying to find it.\n  const operationBasePath = findOperationBasePath(absoluteFilePath);\n  const modelLocation: ModelLocation = {\n    operationName: operationBasePath ? getLastFolder(operationBasePath) : null,\n    projectRelativePath: makeRelative(absoluteFilePath, projectRoot),\n    operationRelativePath: operationBasePath\n      ? makeRelative(absoluteFilePath, operationBasePath)\n      : undefined,\n  };\n\n  const name = mdParse.fileName || \"untitled\";\n  const markdownFile: WebMarkdownFile = {\n    ...modelLocation,\n    ...parsedParameters,\n    markdown: mdParse.raw,\n    categoryStack: [],\n    ...parsedParameters,\n    id: name,\n    createdFirstAt: Date.now(),\n    deletedAt: 0,\n    createdAt: Date.now(),\n    privacy: parsedParameters.privacy || \"public\",\n    language: parsedParameters.language || \"english\",\n    updatedAt: parsedParameters.updatedAt || Date.now(),\n    name,\n    slug: name,\n  };\n\n  return omitUndefinedValues(markdownFile);\n}"
  },
  "readMarkdownFile": {
    "name": "readMarkdownFile",
    "slug": "TsFunction",
    "id": "nefsfazhcqltzcrzbitwsqmh",
    "description": "Reads and parses a markdown file",
    "operationName": "read-markdown-file",
    "rawText": " async (\n  filePath: Path\n): Promise<MarkdownParse | null> => {\n  // TODO: is this needed?\n  const pathParse = path.parse(filePath);\n  const isMarkdownFile = [\"md\", \"mdx\"].includes(pathParse.ext.slice(1));\n  if (!isMarkdownFile) return null;\n  if (!fs.existsSync(filePath)) return null;\n  const readable = await canRead(filePath);\n  if (!readable) return null;\n  const fileString = await fs.readFile(filePath, \"utf8\");\n  if (!fileString) return null;\n\n  const fileName = path.parse(filePath).name;\n\n  const markdownParse = mdToJsonParse(fileString, fileName);\n  return markdownParse;\n}"
  },
  "getFolderTypescriptIndex": {
    "name": "getFolderTypescriptIndex",
    "slug": "TsFunction",
    "id": "rixiypukspdguliccankaxei",
    "description": "get a Typescript index for all that is found in a folder",
    "operationName": "read-typescript-file",
    "rawText": " async ({\n  basePath,\n  filter,\n  sort,\n  type,\n  filePath,\n}: {\n  /**\n   * if given, basePath is ignored\n   *\n   */\n  filePath?: string | string[];\n  /**\n   * is ignored if filePath is provided\n   *\n   * if this path is a single path anywhere in an operaiton, it will only take that operation\n   *\n   * otherwise, it will find all operation folders in that path\n   */\n  basePath?: string | string[];\n\n  /**\n   * if specified, only returns one specific type\n   *\n   * returns all types by default\n   */\n  type?: keyof IndexModels | null;\n\n  filter?: IndexFilter;\n\n  /**\n   * TODO: make functions be sortable:\n   * - alphabetic\n   * - input type\n   * - output type\n   * - usage amount\n   */\n  sort?: string;\n}): Promise<TypescriptIndex | null> => {\n  const operationBasePath =\n    basePath && !Array.isArray(basePath)\n      ? findOperationBasePath(basePath)\n      : undefined;\n\n  // console.log(\"MMMM\", { basePath, operationBasePath });\n\n  const groupedFiles: GroupedFiles = operationBasePath\n    ? { [operationBasePath]: [] }\n    : filePath && filePath.length > 0\n    ? makeArray(filePath).reduce((groups, filePath) => {\n        const operationBasePath = findOperationBasePath(filePath);\n        if (operationBasePath) {\n          groups[operationBasePath] = groups[operationBasePath]\n            ? groups[operationBasePath].concat(filePath)\n            : [filePath];\n        }\n        return groups;\n      }, {} as GroupedFiles)\n    : (await exploreOperationFolders({ basePath })).reduce(\n        (groups, operationBasePath) => {\n          groups[operationBasePath] = [];\n          return groups;\n        },\n        {} as GroupedFiles\n      );\n\n  const typescriptIndexes = await Promise.all(\n    Object.keys(groupedFiles).map(async (operationBasePath) => {\n      const files = groupedFiles[operationBasePath];\n\n      const tsBuildErrors =\n        type === \"TsBuildError\" || !type\n          ? await getOperationIndexModel(\n              \"TsBuildError\",\n              operationBasePath,\n              files\n            )\n          : [];\n\n      const tsLintWarnings =\n        type === \"TsLintWarning\" || !type\n          ? await getOperationIndexModel(\n              \"TsLintWarning\",\n              operationBasePath,\n              files\n            )\n          : [];\n\n      const tsFunctions =\n        type === \"TsFunction\" || !type\n          ? await getOperationIndexModel(\"TsFunction\", operationBasePath, files)\n          : [];\n\n      const extendedTsFuntions = await Promise.all(\n        tsFunctions.map(async (tsFunction) => ({\n          ...tsFunction,\n          dependantFiles: tsFunction.operationName\n            ? await findDependants({\n                operationName: tsFunction.operationName,\n                importName: tsFunction.name,\n              })\n            : [],\n        }))\n      );\n\n      const tsVariables =\n        type === \"TsVariable\" || !type\n          ? await getOperationIndexModel(\"TsVariable\", operationBasePath, files)\n          : [];\n\n      const tsInterfaces =\n        type === \"TsInterface\" || !type\n          ? await getOperationIndexModel(\n              \"TsInterface\",\n              operationBasePath,\n              files\n            )\n          : [];\n\n      const tsComments =\n        type === \"TsComment\" || !type\n          ? await getOperationIndexModel(\"TsComment\", operationBasePath, files)\n          : [];\n\n      const tsImports =\n        type === \"TsImport\" || !type\n          ? await getOperationIndexModel(\"TsImport\", operationBasePath, files)\n          : [];\n\n      const tsExports =\n        type === \"TsExport\" || !type\n          ? await getOperationIndexModel(\"TsExport\", operationBasePath, files)\n          : [];\n\n      const filteredInterfaces = tsInterfaces.filter((x) =>\n        filter?.interfaceIsDbModel ? x.isDbModel : true\n      );\n\n      const typescriptIndex: TypescriptIndex = {\n        tsBuildErrors,\n        tsLintWarnings,\n        tsFunctions: extendedTsFuntions,\n        tsVariables,\n        tsInterfaces: filteredInterfaces,\n        tsComments: tsComments.filter((comment) =>\n          filter?.hasCommentTypes\n            ? comment.types.find((type) =>\n                filter.hasCommentTypes!.includes(type)\n              )\n            : true\n        ),\n        tsImports,\n        tsExports,\n      };\n\n      return typescriptIndex;\n    })\n  );\n\n  const mergedTypescriptIndex = typescriptIndexes.reduce((merged, current) => {\n    if (merged) {\n      const indexModels = Object.keys(merged) as (keyof TypescriptIndex)[];\n\n      const together = mergeObjectsArray(\n        indexModels.map((indexModelName) => {\n          const filterOnName =\n            indexModelName === \"tsComments\" ? () => true : uniqueNames;\n\n          return {\n            [indexModelName]: [\n              ...merged[indexModelName],\n              ...current[indexModelName],\n            ].filter(filterOnName),\n          };\n        })\n      ) as TypescriptIndex;\n\n      return together;\n    }\n\n    return current;\n  }, null as TypescriptIndex | null);\n\n  return mergedTypescriptIndex;\n}"
  },
  "getOperationIndexModel": {
    "name": "getOperationIndexModel",
    "slug": "TsFunction",
    "id": "bslvdmhoimbrkoocowmmrjqu",
    "description": "",
    "operationName": "read-typescript-file",
    "rawText": " async <T extends keyof IndexModels>(\n  indexModelName: T,\n  operationBasePath: string,\n  /**\n   * if provided, db result will be filtered to specific filepaths\n   */\n  filePaths: string[]\n): Promise<IndexModels[T][]> => {\n  const projectRoot = getProjectRoot(filePaths[0]);\n  if (!projectRoot) return [];\n  const relativeFilePaths = filePaths.map((f) =>\n    f.substring(projectRoot.length)\n  );\n  const result = await db\n    // TODO: make it more efficient by just finding the correct JSON files instead of all files in the operation.\n    .get(indexModelName, { operationName: getLastFolder(operationBasePath) });\n\n  const filterOnName =\n    indexModelName === \"TsComment\" ? () => true : uniqueNames;\n\n  const filtered = result\n    .filter(\n      (x) =>\n        x.projectRelativePath &&\n        (relativeFilePaths.length === 0 ||\n          relativeFilePaths.includes(x.projectRelativePath))\n    )\n    .filter(filterOnName);\n\n  return filtered;\n}"
  },
  "readTypescriptFile": {
    "name": "readTypescriptFile",
    "slug": "TsFunction",
    "id": "fezxpsamgyeeaemowlcudcdx",
    "description": "Reads and parses a markdown file",
    "operationName": "read-typescript-file",
    "rawText": " async (\n  filePath: Path\n): Promise<TypescriptIndex | null> => {\n  const operationBasePath = findOperationBasePath(filePath);\n  if (!operationBasePath) return null;\n  const operationName = getLastFolder(operationBasePath);\n\n  const operationRelativeTypescriptFilePath = getOperationRelativePath(\n    filePath,\n    operationBasePath\n  );\n\n  const getFileIndexes = <T extends keyof IndexModels>(\n    indexModelName: T\n  ): Promise<IndexModels[T][]> => {\n    const result = db\n      // TODO: make it more efficient by just finding the correct JSON files instead of all files in the operation.\n      .get(indexModelName, { operationName })\n      .then((result) =>\n        result.filter((x) => {\n          return (\n            x.operationRelativeTypescriptFilePath ===\n            operationRelativeTypescriptFilePath\n          );\n        })\n      );\n\n    return result;\n  };\n\n  // TODO: is this needed?\n  const pathParse = path.parse(filePath);\n  const isTypescriptFile = [\"ts\", \"tsx\"].includes(pathParse.ext.slice(1));\n  if (!isTypescriptFile) return null;\n  if (!fs.existsSync(filePath)) return null;\n\n  const typescriptIndex: TypescriptIndex = {\n    tsBuildErrors: await getFileIndexes(\"TsBuildError\"),\n    tsLintWarnings: await getFileIndexes(\"TsLintWarning\"),\n    tsFunctions: await getFileIndexes(\"TsFunction\"),\n    tsVariables: await getFileIndexes(\"TsVariable\"),\n    tsInterfaces: await getFileIndexes(\"TsInterface\"),\n    tsComments: await getFileIndexes(\"TsComment\"),\n    tsImports: await getFileIndexes(\"TsImport\"),\n    tsExports: await getFileIndexes(\"TsExport\"),\n  };\n\n  return typescriptIndex;\n}"
  },
  "uniqueNames": {
    "name": "uniqueNames",
    "slug": "TsFunction",
    "id": "grpgfkzijklcwvmrwmmhqegw",
    "description": "",
    "operationName": "read-typescript-file",
    "rawText": " <T extends { name: string }>(\n  value: T,\n  index: number,\n  self: T[]\n) => {\n  return self.findIndex((v) => v.name === value.name) === index;\n}"
  },
  "removeCommentsRegex": {
    "name": "removeCommentsRegex",
    "slug": "TsVariable",
    "id": "odjbdoqauhmkuwezqmmbrwcp",
    "description": "",
    "operationName": "try-parse-json"
  },
  "tryParseJson": {
    "name": "tryParseJson",
    "slug": "TsFunction",
    "id": "srymnyulplryykwbluezodnc",
    "description": "if text isn't json, returns null",
    "operationName": "try-parse-json",
    "rawText": " <T>(\n  text: string,\n  logParseError?: boolean\n): T | null => {\n  try {\n    const jsonStringWithoutComments = text.replace(\n      removeCommentsRegex,\n      (m, g) => (g ? \"\" : m)\n    );\n    return JSON.parse(jsonStringWithoutComments) as T;\n  } catch (parseError) {\n    if (logParseError) console.log(\"JSON Parse error:\", parseError);\n    return null;\n  }\n}"
  },
  "bodyFromQueryString": {
    "name": "bodyFromQueryString",
    "slug": "TsFunction",
    "id": "puiwvvhpdbhgzwyqfuvfxfcr",
    "description": "converts a query string into an object that can be used as a body",
    "operationName": "rest-util",
    "rawText": " (\n  /**\n   * NB: everything AFTER The \"?\", so this should be the format: x=x&y=y&z=z&z=z2\n   */\n  query?: string\n): QueryableObject | undefined => {\n  if (!query) return;\n\n  const keyValueObjectArray = query.split(\"&\")?.map((x) => {\n    const [key, value] = x.split(\"=\");\n    return { key, value };\n  });\n\n  const all = keyValueObjectArray?.reduce((object, keyValue) => {\n    // NB: if that key already exists, let's make it an array and add this new value\n    if (object[keyValue.key]) {\n      object[keyValue.key] = [\n        ...makeArray(object[keyValue.key]),\n        keyValue.value,\n      ];\n      return object;\n    }\n    // Otherwise, just add the new key/value to the object.\n    return { ...object, [keyValue.key]: keyValue.value };\n  }, {} as QueryableObject);\n\n  return all;\n}"
  },
  "getFirstQueryStrings": {
    "name": "getFirstQueryStrings",
    "slug": "TsFunction",
    "id": "tkbrcomwgmpolfheqimpiobc",
    "description": "Query keys can be string or string[] or undefined.\n\nThis function takes only the first string if it's an array...",
    "operationName": "rest-util",
    "rawText": " (query: QueryableObject) => {\n  const queryStrings = Object.keys(query).map((key) => {\n    const value = query[key];\n    return Array.isArray(value) ? value[0] : value;\n  });\n\n  return queryStrings;\n}"
  },
  "getQueryPart": {
    "name": "getQueryPart",
    "slug": "TsFunction",
    "id": "nmyqswpuoogatbquiozcogrb",
    "description": "creates a query-string with one key for all strings in an array",
    "operationName": "rest-util",
    "rawText": " (strings: string[], queryKey: string) =>\n  strings.map((v) => `${queryKey}=${v}`).join(\"&\")"
  },
  "isValidEntry": {
    "name": "isValidEntry",
    "slug": "TsFunction",
    "id": "bplhgvdyixqdruaqlvvioxrs",
    "description": "",
    "operationName": "rest-util",
    "rawText": " ([_, value]: [key: string, value: any]) =>\n  value !== undefined && value !== \"\" && value !== null"
  },
  "toQueryString": {
    "name": "toQueryString",
    "slug": "TsFunction",
    "id": "eictyagtmziipoeqsmdcpedw",
    "description": "returns something like `?x=a&y=b&z=c`",
    "operationName": "rest-util",
    "rawText": " (query?: any) => {\n  const hasQuery =\n    query && Object.entries(query)?.filter(isValidEntry).length > 0;\n  return hasQuery\n    ? \"?\" +\n        Object.entries(query)\n          .filter(isValidEntry)\n          .map(([key, value]) => {\n            const encodedValue = encodeURIComponent(String(value));\n            return `${key}=${encodedValue}`;\n          })\n          .join(\"&\")\n    : \"\";\n}"
  },
  "dbConfig": {
    "name": "dbConfig",
    "slug": "TsVariable",
    "id": "aigpvxrlckuxabesvzqsmlkw",
    "description": "",
    "operationName": "database"
  },
  "db": {
    "name": "db",
    "slug": "TsVariable",
    "id": "plvvvudvkbukufryiydcrgqk",
    "description": "",
    "operationName": "os-types"
  },
  "generateCsvInstance": {
    "name": "generateCsvInstance",
    "slug": "TsFunction",
    "id": "gghvrenjqbahxhdazbspvvpf",
    "description": "",
    "operationName": "database",
    "rawText": " (): Creation<CsvTestModel> => {\n  return {\n    // Needed for deletion later\n    id: generateId(),\n    age: getRanomAge(),\n    name: randomName(),\n    description: \"hello world\",\n  };\n}"
  },
  "generateJsonSingleInstance": {
    "name": "generateJsonSingleInstance",
    "slug": "TsFunction",
    "id": "nambxlsfqufftftwcdrzrlkr",
    "description": "",
    "operationName": "database",
    "rawText": " (): Creation<DefaultTestModel> => {\n  return {\n    // Needed for deletion later\n    id: generateId(),\n    description: \"ehey\",\n    special: true,\n    markdown:\n      \" jaja dit is gewoon markdown \\n\\n mooi he \\n\\n # header \\n\\n test\",\n    name: randomName(),\n  };\n}"
  },
  "generateKvmdInstance": {
    "name": "generateKvmdInstance",
    "slug": "TsFunction",
    "id": "oujhmwqsxcspywwljaxlxnds",
    "description": "",
    "operationName": "database",
    "rawText": " (): Creation<KvmdTestModel> => {\n  const id = generateId();\n  return {\n    slug: id,\n    // Needed for deletion later\n    id: id,\n    isHeaderCalculated: true,\n    categoryStack: [],\n    comment: \"comment\",\n    value: \"value\",\n    name: id,\n  };\n}"
  },
  "generateMarkdownInstance": {
    "name": "generateMarkdownInstance",
    "slug": "TsFunction",
    "id": "ijpbgqnhpvqemzffngpjpcqg",
    "description": "",
    "operationName": "database",
    "rawText": " (): Creation<MarkdownTestModel> => {\n  return {\n    // Needed for deletion later\n    id: generateId(),\n\n    age: 19,\n    canBeNull: null,\n    markdown:\n      \" jaja dit is gewoon markdown \\n\\n mooi he \\n\\n # header \\n\\n test\",\n    name: randomName(),\n    stringA: \"A\",\n    stringB: \"B\",\n    stringC: \"C\",\n    yes: true,\n    canBeUndefined: undefined,\n  };\n}"
  },
  "generateSlugTestModel": {
    "name": "generateSlugTestModel",
    "slug": "TsFunction",
    "id": "vblrjthvoeyzqxrspyovxxkj",
    "description": "",
    "operationName": "database",
    "rawText": " (): Creation<SlugTestModel> => {\n  return {\n    // Needed for deletion later\n    id: generateId(),\n    name: randomName(),\n    markdown: \"wut?\",\n    special: true,\n    description: \"test\",\n  };\n}"
  },
  "getCli": {
    "name": "getCli",
    "slug": "TsFunction",
    "id": "pqaeewvljxrcvxkyqdradmxu",
    "description": "",
    "operationName": "database",
    "rawText": " async () => {\n  const [model, configString, keysString] = process.argv.slice(2);\n  const config = configString\n    ? getObjectFromParamsString(configString)\n    : undefined;\n  const keys = keysString\n    ? keysString.split(\",\").map((x) => x.trim())\n    : undefined;\n\n  const result = await testDb.get(model as keyof TestModels, config);\n\n  console.table(\n    result.map((x) =>\n      // @ts-ignore\n      keys && typeof x === \"object\" ? getSubsetFromObject(x, keys) : x\n    )\n  );\n}"
  },
  "getMergedQueryConfig": {
    "name": "getMergedQueryConfig",
    "slug": "TsFunction",
    "id": "ogghhpejrlvdiflmrjbffapx",
    "description": "",
    "operationName": "database",
    "rawText": " (\n  modelName: keyof DbModels,\n  customQueryConfig?: CustomQueryConfig\n) => mergeConfigs<DbModels>(modelName, dbConfig, customQueryConfig)"
  },
  "getRanomAge": {
    "name": "getRanomAge",
    "slug": "TsFunction",
    "id": "oadyavfkjvplybwnnbicfuyq",
    "description": "",
    "operationName": "database",
    "rawText": " () => Math.round(Math.random() * 99)"
  },
  "get": {
    "name": "get",
    "slug": "TsFunction",
    "id": "yambpldxanoxmxrzjqoplqha",
    "description": "",
    "operationName": "database",
    "rawText": " async () => {\n  await upsert();\n\n  const items = await testDb.get(\"MarkdownTestModel\");\n  console.dir({ items }, { depth: 99 });\n}"
  },
  "migration": {
    "name": "migration",
    "slug": "TsFunction",
    "id": "wtavcpobvvctopphyqzfrxmx",
    "description": "",
    "operationName": "database",
    "rawText": " async () => {\n  const result = await testDb.update(\n    \"TsConfig\",\n    () => true,\n    (tsConfig) => ({\n      ...tsConfig,\n      compilerOptions: { ...tsConfig.compilerOptions, resolveJsonModule: true },\n    })\n  );\n\n  console.dir(result, { depth: 111 });\n}"
  },
  "randomName": {
    "name": "randomName",
    "slug": "TsFunction",
    "id": "nqnsrsehpqlzdixodjouuxid",
    "description": "",
    "operationName": "database",
    "rawText": " () => `name${Math.round(Math.random() * 888888)}`"
  },
  "removeCli": {
    "name": "removeCli",
    "slug": "TsFunction",
    "id": "btvngddbwrtypflwviolonbj",
    "description": "",
    "operationName": "database",
    "rawText": " async () => {\n  const [model, key, value] = process.argv.slice(2);\n\n  if (!value || !model || !key) {\n    console.log(\"please provide a modelName and a key + value to remove\");\n    return;\n  }\n\n  const result = await testDb.remove(\n    model as any,\n    (content) => content[key] == value\n  );\n\n  console.table(result);\n}"
  },
  "runModelEndToEndTest": {
    "name": "runModelEndToEndTest",
    "slug": "TsFunction",
    "id": "ucbtdscfhqpbmajgjwwexjfp",
    "description": "NB: we can't do a maketest because this thing relies on logging and we don't want to auto-run it",
    "operationName": "database",
    "rawText": " async (\n  modelName: keyof TestModels,\n  generateInstance: () => Creation<AnyModelType>\n) => {\n  /**\n   * this is done synchronously for every model: set, get, push, get, remove, get, update, get, get, remove all, get\n   */\n\n  const firstInstance = generateInstance();\n  const firstId = firstInstance.id;\n\n  // console.log({ firstId, firstInstance });\n\n  //@ts-ignore\n  const setResult = await testDb.set(modelName, [firstInstance]);\n  const getResult = await testDb.get(modelName);\n\n  if (getResult.length !== 1) {\n    console.log({ setResult, getResult });\n    console.log(\"Invalid length\");\n    process.exit(1);\n  } else {\n    console.log(`${modelName} Set test passed`);\n  }\n  //@ts-ignore\n  const pushResult = await testDb.upsert(modelName, generateInstance());\n  const getResult2 = await testDb.get(modelName);\n\n  if (getResult2.length !== 2) {\n    console.log({ pushResult, getResult2 });\n    console.log(\"Invalid length\");\n    process.exit(1);\n  } else {\n    console.log(`${modelName} Push test passed`);\n  }\n\n  // NB: now we have 2 items in the db\n\n  const removeResult = await testDb.remove(\n    modelName,\n    // NB: we don't remove first Id\n    (content) => content.id !== firstId\n  );\n\n  if (removeResult.amountRemoved !== 1) {\n    console.log({ removeResult });\n\n    console.log(\"Invalid amount removed\");\n    process.exit(1);\n  } else {\n    console.log(`${modelName} Remove test: correct amount removed`);\n  }\n\n  const getResult3 = await testDb.get(modelName);\n\n  if (getResult3.length !== 1) {\n    console.log({ getResult3 });\n\n    console.log(\"Invalid length\");\n    process.exit(1);\n  } else {\n    console.log(`${modelName} Remove test passed`);\n  }\n\n  // now we have 1 item in the db\n\n  const updateResult = await testDb.update(\n    modelName,\n    (content) => content.id === firstId,\n    (content) => {\n      return { ...content, id: \"NEWIDDDD\" };\n    }\n  );\n\n  if (updateResult.amountUpdated !== 1) {\n    console.log({ updateResult });\n\n    console.log(\"Invalid rows updated\", { firstId });\n    process.exit(1);\n  } else {\n    console.log(`${modelName} Update test: right amount of rows updated`);\n  }\n\n  const getResult4 = await testDb.get(modelName);\n\n  if (getResult4[0].id !== \"NEWIDDDD\") {\n    console.log({ firstItem: getResult4[0] }, \"id != NEWIDDDD\");\n    process.exit(1);\n  } else {\n    console.log(`${modelName} Update test passed`);\n  }\n\n  if (getResult4.length !== 1) {\n    console.log({ getResult4 });\n\n    console.log(\"Invalid length\");\n    process.exit(1);\n  }\n\n  console.log(`Test Succeeded for ${modelName}`);\n\n  return true;\n}"
  },
  "set": {
    "name": "set",
    "slug": "TsFunction",
    "id": "hztxlkgvxmwxpoqhngbhzrch",
    "description": "Can set a markdown item into a subfolder in the db model folder",
    "operationName": "database",
    "rawText": " () => {\n  const item: Creation<MarkdownTestModel> = {\n    categoryStack: [\"sub\", \"folder\"],\n    name: \"hell-yeah\",\n    markdown: \"some markdown....\",\n  };\n\n  const x = testDb.set(\"MarkdownTestModel\", [item]);\n\n  return x;\n}"
  },
  "testDb": {
    "name": "testDb",
    "slug": "TsVariable",
    "id": "xggemjdsmucorfjewzjigfgw",
    "description": "a db is created with models from all different db storage methods",
    "operationName": "database"
  },
  "testOperationModels": {
    "name": "testOperationModels",
    "slug": "TsFunction",
    "id": "uelqbgwvdcwyqtgeryebsnfm",
    "description": "Test if it can find all `OperationIndex`, `OperationConfig`, `PackageJson`, `TsConfig`",
    "operationName": "database",
    "rawText": " async () => {\n  // const operationIndexs = await testDb.get(\"OperationIndex\");\n  // const operationConfigs = await testDb.get(\"OperationConfig\");\n  // const packageJsons = await testDb.get(\"PackageJson\");\n  const tsConfigs = await testDb.get(\"TsConfig\");\n\n  //operationConfigs, operationIndexs, packageJsons,\n  // console.dir({ tsConfigs });\n\n  return true;\n}"
  },
  "testPerformance": {
    "name": "testPerformance",
    "slug": "TsFunction",
    "id": "ohksirnqimardqeqsuixcbtw",
    "description": "",
    "operationName": "database",
    "rawText": " async () => {\n  const executionId = generateUniqueId();\n  const performance: (PerformanceItem | undefined)[] = [];\n  getNewPerformance(\"start\", executionId, true);\n\n  const deviceInclude: Include = {\n    referenceKey: \"personIds\",\n    include: { referenceKey: \"groupSlugs\" },\n  };\n  log(\"Devices with include\", { type: \"important\" });\n\n  const withInclude = await db.get(\"Device\", { include: deviceInclude });\n\n  log(\"Devices without include\", { type: \"important\" });\n\n  const withoutInclude = await db.get(\"Device\");\n\n  performance.push(\n    getNewPerformance(\n      \"testPerformance (2x get, 1x with double include)\",\n      executionId\n    )\n  );\n  cleanupTimer(executionId);\n  log(\"DONE\", { type: \"success\" });\n  console.log(performance);\n}"
  },
  "updateCli": {
    "name": "updateCli",
    "slug": "TsFunction",
    "id": "nmxkspzvltgtnwlgverdqdgs",
    "description": "",
    "operationName": "database",
    "rawText": " async () => {\n  const [model, filterKv, updateKv] = process.argv.slice(2);\n\n  if (!filterKv || !model || !updateKv) {\n    console.log(\n      \"please provide 3 arguments: the model name, the key:value of the instance(s) to update, and the key:value of the key to change the value of\"\n    );\n  }\n\n  const [filterKey, filterValue] = filterKv.split(\":\");\n  const [updateKey, updateValue] = updateKv.split(\":\");\n\n  const result = await testDb.update(\n    model as any,\n    (content) => content[filterKey] == filterValue,\n    (content) => ({ ...content, [updateKey]: updateValue })\n  );\n\n  console.table(result);\n}"
  },
  "upsertCli": {
    "name": "upsertCli",
    "slug": "TsFunction",
    "id": "ecotucvnnddtfehtbqybbljn",
    "description": "",
    "operationName": "database",
    "rawText": " async () => {\n  const [modelName, dataString] = process.argv.slice(2);\n\n  /**\n   FOR kvmd type:\n\n   - required: name\n   - optional: parent_xxxSlug, value, comment\n   */\n  if (!dataString || !modelName) {\n    console.log(\"please choose a model and data\");\n  }\n\n  const theObject = getObjectFromParamsString(dataString);\n  //@ts-ignore\n  const result = await testDb.upsert(modelName as any, theObject);\n\n  console.table(result);\n}"
  },
  "upsert": {
    "name": "upsert",
    "slug": "TsFunction",
    "id": "yvqeeurdtqnllplgphkaylgx",
    "description": "Takes stored data and an item\n\n- updates the data and sets some rows to \"item\" if the item is found (through the id or slug)\n- otherwise inserts\n\nNB: this function works for any storage method except for key value markdown",
    "operationName": "fs-orm",
    "rawText": " (\n  /**\n   * The items that were already there\n   */\n  storedData: Storing<AugmentedAnyModelType>[],\n  /**\n   * The items that need to be overwritten or inserted\n   */\n  storingItems:\n    | Storing<AugmentedAnyModelType>\n    | Storing<AugmentedAnyModelType>[],\n  /**\n   * If true, the upserting will fail if there are occuring items with equal slugs/ids\n   */\n  onlyInsert?: boolean\n): DbQueryResult & {\n  newStoredData: Storing<AugmentedAnyModelType>[];\n} => {\n  const storingItemsArray = makeArray(storingItems);\n  let amountUpdated = 0;\n\n  const newStoredData = storedData\n    .map((i) => {\n      if (!i) return;\n      // NB: for every item in the stored data, try to find one that matches\n      const storingIndex = storingItemsArray.findIndex((x) => {\n        if (!x) {\n          log(\"weird item found in your data, replacing\", { type: \"debug\" });\n          return true;\n        }\n\n        const matchId = x.id === i.id;\n        // NB: sometimes slug can be undefined for some models.\n        const matchSlug = x.slug !== undefined && x.slug === i.slug;\n\n        return matchId || matchSlug;\n      });\n\n      if (storingIndex !== -1) {\n        // NB: it needs to be updated, so simply remove it because the new item is going to be concatenated\n        amountUpdated++;\n        return;\n      }\n\n      return i;\n    })\n    .filter(notEmpty)\n    .concat(storingItems);\n\n  if (onlyInsert && amountUpdated > 0) {\n    return {\n      amountUpdated: 0,\n      amountInserted: 0,\n      newStoredData: storedData,\n      amountRemoved: 0,\n      isSuccesful: false,\n      message:\n        \"The creation failed because you already have an item with this name\",\n    };\n  }\n  return {\n    amountUpdated,\n    amountInserted: amountUpdated === 0 ? 1 : 0,\n    newStoredData,\n  };\n}"
  },
  "cacheLookup": {
    "name": "cacheLookup",
    "slug": "TsFunction",
    "id": "xzxsrsxmmuyejkvwjhzcmosl",
    "description": "Wrapper function to cache any function and invalidate it, in some way\n\ncaching\nautomatic cache invalidation if data sources are updated\noptimistic caching after cache invalidation",
    "operationName": "db-recipes",
    "rawText": " (\n  functionName: string,\n  parameters: undefined | any[]\n): CacheLookupResult => {\n  // TODO: think of a smart way to look in cache and make sure it works with as many functions as possible with a smart cache invalidation + cleanup strategy\n  return { hasValidCache: false };\n}"
  },
  "calculateOperatingSystemBundle": {
    "name": "calculateOperatingSystemBundle",
    "slug": "TsFunction",
    "id": "yxqgbzwxqztlnohvdsfuporm",
    "description": "This function should calculate a giant bundle for the whole operating system. This should include everything, public.\n\nUsed to show the whole os as a bundle.",
    "operationName": "db-recipes",
    "rawText": " async (\n  manualProjectRoot?: string\n) => {\n  //   const bundleConfig: BundleConfig = {};\n\n  return; //bundleConfig;\n}"
  },
  "deleteDbModel": {
    "name": "deleteDbModel",
    "slug": "TsFunction",
    "id": "klqcpzymhrpopmsssybwcstx",
    "description": "deletes an instance of an db data interface from the db in a typesafe way",
    "operationName": "db-recipes",
    "rawText": " async <KInterface extends DbModelEnum>(\n  interfaceName: KInterface,\n  id: string\n): Promise<DbQueryResult> => {\n  const deleteResult = await db.remove(\n    interfaceName,\n    (content) => content.id === id\n  );\n  return deleteResult;\n}"
  },
  "functions": {
    "name": "functions",
    "slug": "TsVariable",
    "id": "ubteujhusertgplgvhwgozna",
    "description": "",
    "operationName": "function-util"
  },
  "getCachedFunctions": {
    "name": "getCachedFunctions",
    "slug": "TsFunction",
    "id": "ofdgavqxvesxzoxsdlegynjg",
    "description": "TODO: it would probably be good to create a more general purpose caching function",
    "operationName": "db-recipes",
    "rawText": " async () => {\n  if (functions.length) return functions;\n  functions = await db.get(\"TsFunction\");\n  return functions;\n}"
  },
  "getDatabaseMenu": {
    "name": "getDatabaseMenu",
    "slug": "TsFunction",
    "id": "dhmuwnaeprxzgimmdzpumifo",
    "description": "Finds all relevant Db models to show in the menu\n\n- for a bundleId, it gets all models from the bundleSummary\n- for a bundled project (bundled) gets all models from the packages\n- for the main project, gets all models from sdk-db directly\n\nTODO: NB: the first and the second are not the same, so this needs to be cleaned up.",
    "operationName": "db-recipes",
    "rawText": " async (config?: { bundleId?: string }) => {\n  const dbModelNames = await getDbModelNames(config);\n  const databaseMenu: ModelInfo[] = dbModelNames\n    .map((modelKey) => {\n      if (!modelKey) return;\n\n      const modelInfo: ModelInfo = {\n        name: humanCase(modelKey),\n        slug: modelKey,\n        rows: 0,\n      };\n      return modelInfo;\n    })\n    .filter(notEmpty);\n\n  return {\n    menu: databaseMenu,\n  };\n}"
  },
  "getDbModelMetadata": {
    "name": "getDbModelMetadata",
    "slug": "TsFunction",
    "id": "rnkjzftzhiwxzpvxolkqxszy",
    "description": "",
    "operationName": "db-recipes",
    "rawText": " async (\n  modelName: string | undefined\n): Promise<{\n  tsInterface?: TsInterface;\n  datasets?: Dataset[];\n  projectRelativeStorageFilePath?: string;\n}> => {\n  if (!modelName) return {};\n  if (!([...dbModelKeys] as string[]).includes(modelName)) {\n    return {};\n  }\n\n  const realModelName = modelName as DbModelEnum;\n\n  const mergedConfig: MergedQueryConfig = getMergedQueryConfig(realModelName);\n  const projectRelativeStorageFilePath = (\n    await getDatabaseFiles(realModelName, mergedConfig)\n  ).map((x) => x.projectRelativePath)[0];\n\n  const indexPath = sdkInterfacePaths[realModelName];\n  const tsInterface =\n    (await readProjectRelativeJsonFile<TsInterface>(indexPath)) || undefined;\n\n  const allDatasets = await db.get(\"Dataset\");\n  const datasets = allDatasets.filter((x) => x.modelName === realModelName);\n\n  return { tsInterface, datasets, projectRelativeStorageFilePath };\n}"
  },
  "getDbModelNames": {
    "name": "getDbModelNames",
    "slug": "TsFunction",
    "id": "vaxplkbdrqroolijqrjudwbb",
    "description": "",
    "operationName": "db-recipes",
    "rawText": " async (config?: {\n  bundleId?: string;\n}): Promise<(keyof DbModels)[]> => {\n  const bundleId = config?.bundleId;\n  let dbModels: TsInterface[] | undefined = undefined;\n\n  if (bundleId) {\n    const bundleConfig = (await db.get(\"BundleConfig\")).find(\n      (x) => x.id === bundleId\n    );\n\n    if (bundleConfig) {\n      dbModels = await getDbModelsForBundle(bundleConfig);\n    }\n  }\n  const projectRoot = getProjectRoot();\n  if (isBundle(projectRoot) && projectRoot) {\n    const operationNames: string[] = (\n      await exploreOperationFolders({\n        basePath: path.join(projectRoot, \"packages\"),\n      })\n    ).map(getLastFolder);\n\n    dbModels = await getDbModelsFromOperations(operationNames);\n  }\n\n  const dbModelNames = dbModels\n    ? (dbModels?.map((x) => x.name) as (keyof DbModels)[])\n    : [...dbModelKeys];\n\n  return dbModelNames;\n}"
  },
  "getDbModel": {
    "name": "getDbModel",
    "slug": "TsFunction",
    "id": "sfvhexxehajuktuoeixnxbxu",
    "description": "gets all instances of an db data interface from the db in a typesafe way",
    "operationName": "db-recipes",
    "rawText": " async <\n  KInterface extends Extract<keyof DbModels, string>,\n  TDatasetConfig extends DatasetConfig\n>(\n  /**\n   * the interfaceName you want to get\n   */\n  interfaceName: KInterface | null,\n  /**\n   * optionally, provide a configuration\n   */\n  datasetConfig?: TDatasetConfig,\n\n  /**\n   * This search should be done on the deepest JSON value's of the whole thing. The purpose is not limiting the content to user, but rather just a nice user experience where one can quickly search\n   */\n  search?: string\n): Promise<GetDbModelResult<KInterface>> => {\n  if (!interfaceName) {\n    return { data: [], hasMore: false, message: \"No interfaceName posted\" };\n  }\n\n  const data = await db.get(interfaceName);\n\n  // NB: slice the data, if needed\n  const slicedStartData = data.slice(datasetConfig?.startFromIndex);\n\n  const slicedLimitData = datasetConfig?.maxRows\n    ? slicedStartData.slice(0, datasetConfig.maxRows)\n    : slicedStartData;\n\n  const hasMore = slicedLimitData.length < slicedStartData.length;\n\n  // NB: filter the sliced data, if needed\n  const filteredData = datasetConfig?.filter?.length\n    ? datasetConfig?.filter.reduce((filteredData, datasetFilter) => {\n        const newFilteredData: DbModels[KInterface][] = filteredData.filter(\n          (item) => {\n            const key = datasetFilter.objectParameterKey as keyof typeof item;\n\n            const value = item[key];\n\n            if (datasetFilter.operator === \"equal\") {\n              return String(value) === datasetFilter.value;\n            }\n\n            if (datasetFilter.operator === \"notEqual\") {\n              return String(value) === datasetFilter.value;\n            }\n\n            const lowercaseValue = String(value).toLowerCase();\n            const lowercaseDatasetValue = String(\n              datasetFilter.value\n            ).toLowerCase();\n\n            if (datasetFilter.operator === \"endsWith\") {\n              return lowercaseValue.endsWith(lowercaseDatasetValue);\n            }\n            if (datasetFilter.operator === \"startsWith\") {\n              return lowercaseValue.startsWith(lowercaseDatasetValue);\n            }\n\n            if (datasetFilter.operator === \"includes\") {\n              return lowercaseValue.includes(lowercaseDatasetValue);\n            }\n\n            if (datasetFilter.operator === \"includesLetters\") {\n              return hasAllLetters(lowercaseValue, lowercaseDatasetValue);\n            }\n\n            if (\n              datasetFilter.operator === \"greaterThan\" &&\n              datasetFilter.value !== null &&\n              datasetFilter.value !== undefined\n            ) {\n              return Number(value) > Number(datasetFilter.value);\n            }\n\n            if (\n              datasetFilter.operator === \"lessThan\" &&\n              datasetFilter.value !== null &&\n              datasetFilter.value !== undefined\n            ) {\n              return Number(value) < Number(datasetFilter.value);\n            }\n\n            if (\n              datasetFilter.operator === \"greaterThanOrEqual\" &&\n              datasetFilter.value !== null &&\n              datasetFilter.value !== undefined\n            ) {\n              return Number(value) >= Number(datasetFilter.value);\n            }\n\n            if (\n              datasetFilter.operator === \"lessThanOrEqual\" &&\n              datasetFilter.value !== null &&\n              datasetFilter.value !== undefined\n            ) {\n              return Number(value) <= Number(datasetFilter.value);\n            }\n\n            return false;\n          }\n        );\n\n        return newFilteredData;\n      }, slicedLimitData)\n    : slicedLimitData;\n\n  // NB: sort the filtered data, if needed\n\n  const sortedData = datasetConfig?.sort\n    ? datasetConfig.sort.reduce((sortedData, datasetSort) => {\n        const newSortedData: DbModels[KInterface][] = sortedData.sort(\n          (a, b) => {\n            // @ts-ignore\n            const valueA = a[datasetSort.objectParameterKey];\n            // @ts-ignore\n            const valueB = b[datasetSort.objectParameterKey];\n\n            const directionMultiplier =\n              datasetSort.sortDirection === \"ascending\" ? 1 : -1;\n\n            return Number(valueA) < Number(valueB)\n              ? directionMultiplier\n              : directionMultiplier * -1;\n          }\n        );\n\n        return newSortedData;\n      }, filteredData)\n    : filteredData;\n\n  const searchedData =\n    search && search.length > 0\n      ? sortedData.filter((item) => {\n          const searchable = Object.values(item)\n            .map((value) => JSON.stringify(value))\n            .join(\",\")\n            .toLowerCase();\n\n          return searchable.includes(search.toLowerCase());\n        })\n      : sortedData;\n\n  const subsetData = datasetConfig?.objectParameterKeys?.length\n    ? searchedData.map(\n        (item) =>\n          getSubsetFromObject(\n            item,\n            datasetConfig.objectParameterKeys! as readonly (keyof DbModels[KInterface])[]\n          ) as DatasetItem<DbModels[KInterface], TDatasetConfig>\n      )\n    : searchedData;\n\n  const ignoredData = datasetConfig?.ignoreObjectParameterKeys?.length\n    ? subsetData.map((item) => {\n        return removeOptionalKeysFromObjectStrings(\n          item as { [key: string]: any },\n          datasetConfig.ignoreObjectParameterKeys!\n        );\n      })\n    : subsetData;\n\n  const finalData = ignoredData as DbModels[KInterface][];\n\n  return {\n    datasetConfig,\n    data: finalData,\n    hasMore,\n  };\n}"
  },
  "getFunctionIndex": {
    "name": "getFunctionIndex",
    "slug": "TsFunction",
    "id": "ttwolnuhczdpwukqtslukehj",
    "description": "finds function indexation from database\n\nTODO: this should be used!",
    "operationName": "db-recipes",
    "rawText": " async ({\n  functionName,\n}: {\n  functionName: string;\n}): Promise<{ success: boolean; response: string; function?: TsFunction }> => {\n  const cachedFunctions = await getCachedFunctions();\n\n  // get info about this operation\n  const functionIndex = cachedFunctions.find(\n    (fn) => fn.name === camelCase(functionName)\n  );\n\n  if (!functionIndex) {\n    return { success: false, response: \"Couldn't find function\" };\n  }\n\n  return { success: true, function: functionIndex, response: \"Found\" };\n}"
  },
  "getNestedDatabaseMenu": {
    "name": "getNestedDatabaseMenu",
    "slug": "TsFunction",
    "id": "zqjssgfoplbpkwauyhrjyufx",
    "description": "TODO: support search for bundles (but this can be augmented word based)",
    "operationName": "db-recipes",
    "rawText": " async (config?: {\n  noOperationPath?: boolean;\n  noOperationName?: boolean;\n  noSrcRelativeFolder?: boolean;\n  noPrefix?: boolean;\n}): Promise<{ flat?: WebPage[]; nested?: NestedWebPage[] }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return {};\n  const { noOperationPath, noOperationName, noSrcRelativeFolder, noPrefix } =\n    destructureOptionalObject(config);\n  const dbModels = (await db.get(\"TsInterface\")).filter((x) => x.isDbModel);\n\n  const queryPaths = dbModels.map((dbModel) => {\n    const projectRelativeOperationPath =\n      operations[dbModel.operationName as keyof typeof operations];\n\n    const slicedProjectRelativeOperationPath = projectRelativeOperationPath\n      .split(\"/\")\n      // in bundles, we still want to make the distinction between modules and packages, so this is great.\n      .slice(isBundle(projectRoot) ? 0 : 2)\n      .join(\"/\");\n    const operationPart = noOperationName\n      ? \"\"\n      : noOperationPath\n      ? dbModel.operationName + \"/\"\n      : slicedProjectRelativeOperationPath + \"/\";\n\n    const folder = getFolder(\n      dbModel.operationRelativeTypescriptFilePath.slice(\"src/\".length)\n    );\n    const folderPart = noSrcRelativeFolder\n      ? \"\"\n      : folder.length === 0\n      ? \"\"\n      : folder + \"/\";\n\n    const prefixPart = noPrefix ? \"\" : \"db/\";\n    const url = `${prefixPart}${operationPart}${folderPart}${dbModel.name}`;\n\n    return url;\n  });\n\n  const dbPages: WebPage[] = queryPaths.map((queryPath) => {\n    return { queryPath, pageData: null };\n  });\n\n  const upsertPages: WebPage[] = dbModels.map((dbModel) => ({\n    queryPath: `upsert/${dbModel.name}`,\n    pageData: null,\n    isMenuHidden: true,\n  }));\n\n  const flat = dbPages.concat(upsertPages);\n\n  return getMenuPagesObject(flat);\n}"
  },
  "getReferencableModelData": {
    "name": "getReferencableModelData",
    "slug": "TsFunction",
    "id": "jxydmrqcmwtqcykhoqxbfzyj",
    "description": "Get referencableModelData for a single DbModel.\n\nNB: this does not get the items that can be referenced in that model!\n\nFor getting all required `ReferencableModelData` for the prop in `SimplifiedSchemaForm`, use `useGetReferencableModelData`.",
    "operationName": "db-recipes",
    "rawText": " async (dbModelName: keyof DbModels) => {\n  if (!dbModelName) {\n    return [];\n  }\n  const referencableModelData = (await db.get(dbModelName)).map(\n    (item: AugmentedAnyModelType) => ({\n      id: item.id,\n      name: item.name,\n      slug: item.slug,\n      categoryStack: item.categoryStack,\n    })\n  );\n\n  return referencableModelData;\n}"
  },
  "hasDbRecipes": {
    "name": "hasDbRecipes",
    "slug": "TsFunction",
    "id": "zeaidhbdfhatrnwwthdnnusd",
    "description": "Simple function to test whether or not the DbRecipes endpoints are available. If it returns true through the api, the other ones are also available.",
    "operationName": "db-recipes",
    "rawText": " () => true"
  },
  "makeSrcRelativeFolder": {
    "name": "makeSrcRelativeFolder",
    "slug": "TsFunction",
    "id": "pgjqqklbrofdobbdjeuzjaon",
    "description": "gets a src relative folder path (so maybe \"\" for a file `src/util.ts` or \"util\" for a file `src/util/thing.ts`)",
    "operationName": "db-recipes",
    "rawText": " (\n  operationRelativeTypescriptFilePath: string\n): string | undefined => {\n  const srcPrefix = \"src/\";\n  if (!operationRelativeTypescriptFilePath.startsWith(srcPrefix)) return;\n  const withoutSrc = operationRelativeTypescriptFilePath.substring(\n    srcPrefix.length\n  );\n\n  const parts = withoutSrc.split(\"/\");\n\n  parts.pop();\n\n  const withoutFile = parts.join(\"/\");\n\n  if (withoutFile.length === 0) return;\n\n  return withoutFile;\n}"
  },
  "testFnWrapped": {
    "name": "testFnWrapped",
    "slug": "TsVariable",
    "id": "sbqgpayugvxqlijslfufigte",
    "description": "",
    "operationName": "db-recipes"
  },
  "testFn": {
    "name": "testFn",
    "slug": "TsFunction",
    "id": "sqpnygultvzkhabbmuidehsn",
    "description": "",
    "operationName": "db-recipes",
    "rawText": " (a: string) => {\n  return `${a}${a}`;\n}"
  },
  "tsInterfaceToDbMenu": {
    "name": "tsInterfaceToDbMenu",
    "slug": "TsFunction",
    "id": "sgtbhzwhiytalgjfdhsuekix",
    "description": "",
    "operationName": "db-recipes",
    "rawText": " (tsInterface: TsInterface, type: string) => {\n  const srcRelativeFolder = makeSrcRelativeFolder(\n    tsInterface.operationRelativeTypescriptFilePath\n  );\n  if (!tsInterface.operationName) return;\n\n  return {\n    name: tsInterface.name,\n    operationName: tsInterface.operationName,\n    type,\n    srcRelativeFolder,\n  };\n}"
  },
  "upsertDbModel": {
    "name": "upsertDbModel",
    "slug": "TsFunction",
    "id": "nrzsswugmbtrdalplnbtwvtu",
    "description": "upserts an instance of an db data interface from the db in a typesafe way",
    "operationName": "db-recipes",
    "rawText": " async <\n  KInterfaceName extends keyof DbModels,\n  KItem extends DbModels[KInterfaceName]\n>(\n  interfaceName: KInterfaceName,\n  data: KItem | KItem[],\n  /**\n   * NOT USED\n   */\n  isNew?: boolean\n): Promise<DbQueryResult> => {\n  if (!data || (Array.isArray(data) && data.length === 0)) {\n    return { isSuccesful: false, message: \"Please provide some data\" };\n  }\n\n  // use the first item to get the operationName, sometimes needed for storing in the right location\n  const item = Array.isArray(data) ? data[0] : data;\n  const { operationName } = item;\n\n  /**\n  \n  Assets need to be placed: \n\n  1) find all assets in data\n\n  2) for every parameter that adheres to asset naming convention, call `processAsset`\n\n  */\n\n  const config: CustomQueryConfig = { operationName };\n\n  const realData = (await Promise.all(\n    makeArray(data).map((item) => {\n      return processItemAssets(item, interfaceName, operationName, config);\n    })\n  )) as KItem[];\n\n  // console.dir({ realData }, { depth: 999 });\n  // return { message: \"test\" };\n  //@ts-ignore\n  const upsertResult = await db.upsert(interfaceName, realData, config);\n\n  return upsertResult;\n}"
  },
  "validateInput": {
    "name": "validateInput",
    "slug": "TsFunction",
    "id": "yjzpjazcqqoqifdgjiagqvnw",
    "description": "wrapper function that takes that data but also the interface of the function and validates the parameters before it executes the function.",
    "operationName": "db-recipes",
    "rawText": " <TFunctionName extends keyof typeof sdk>(\n  functionName: TFunctionName,\n  parameters: undefined | any[],\n  tsFunction: TsFunction\n): ValidationResult => {\n  const invalidParameters =\n    tsFunction.parameters\n      ?.map((parameter, index) => {\n        if (!parameter.schema) return;\n\n        // NB: we have a problem now because of the references missing. Recursively including all references every time can be hard though, that is another indexation step probably... May also become quite slow given the side of these schemas. We can either try and create a mapped validation object that includes the schemas for every function or we can try to use typescript-json instead, that may be easier, and better since we already need that for the backend as well. The last option would be to validate it ourselves using our own SimplifiedSchema. A validator for that would be useful anyway because it can also be used at the frontend with SimplifiedSchemaForm.\n        // const validate = ajv.compile(parameter.schema);\n        // const isValid = validate(value);\n\n        const value = parameters?.[index];\n\n        const isValid = true;\n        if (isValid) return;\n\n        return { isValid, parameter, value };\n      })\n      .filter(notEmpty) || [];\n\n  const isValid = invalidParameters.length === 0;\n  if (!isValid) {\n    log(\n      `According to the schema, you have given invalid arguments to the function`,\n      { type: \"warning\" }\n    );\n    console.dir({ invalidParameters }, { depth: 99 });\n  }\n\n  return { isValid };\n}"
  },
  "validateResult": {
    "name": "validateResult",
    "slug": "TsFunction",
    "id": "qqlqzenatkekmplhuewbcwcl",
    "description": "wrapper function that takes that data but also the interface of the function and validates the parameters before it executes the function.",
    "operationName": "db-recipes",
    "rawText": " <TFunctionName extends keyof typeof sdk>(\n  functionName: TFunctionName,\n  result: any,\n  tsFunction: TsFunction\n): ValidationResult => {\n  const fn = sdk[functionName];\n\n  type ResultType = ReturnType<typeof fn>;\n  /**\n   * NB: https://www.npmjs.com/package/typescript-json\n   *\n   * this seems a great way to validate the return type, not sure what it would do to my compile times and runtime performance and if it works at all, but if it works, it'd be great because we basically create 100% typesafety, not only for the input, but also for the output!\n   */\n  // const isValid = TSON.equal<ResultType>(result)\n\n  const schema = tsFunction.returnType.typeDefinition;\n\n  if (!schema) {\n    log(`Not able to validate ${functionName} result`, { type: \"debug\" });\n    return { isValid: true };\n  }\n\n  //const validate = ajv.compile(schema);\n\n  const isValid = true; //validate(result);\n\n  if (!isValid) {\n    log(\n      `According to the schema, you have given invalid arguments to the function`,\n      { type: \"warning\" }\n    );\n  }\n\n  return { isValid };\n}"
  },
  "wrapFunction": {
    "name": "wrapFunction",
    "slug": "TsFunction",
    "id": "jdcgkfkzcurepkoelwlvxild",
    "description": "",
    "operationName": "db-recipes",
    "rawText": " <TFunc extends (...parameters: any[]) => any>(\n  originalFunction: TFunc\n) => {\n  const wrappedFunction = (\n    ...parameters: Parameters<TFunc>\n  ): ReturnType<TFunc> => {\n    /**\ndo other stuff, both with await and without awaiting\n\n- logging io + cache lookup (@pure tag)\n- logging performance\n- logging errors\n- input validation\n- output validation\n- tracking usage quantity, checking if there is still permission for execution based on credit balance\n*/\n    console.log(\"I'm wrapping this function\", originalFunction.name);\n    return originalFunction(...parameters);\n  };\n\n  return wrappedFunction;\n}"
  },
  "DbAndUpsert": {
    "name": "DbAndUpsert",
    "slug": "TsFunction",
    "id": "olqcakbvuurqrxqadxbkgirj",
    "description": "This should catch all dbQueryPaths because those aren't default ones",
    "operationName": "db-web",
    "rawText": " () => {\n  const router = useRouter();\n  const paths = router.asPath.slice(1);\n  const modelNameWithQuery = paths.split(\"/\").pop()!;\n  const modelName = modelNameWithQuery.split(\"?\")[0];\n  const modelNames = [...dbModelKeys] as string[];\n\n  if (!modelNames.includes(modelName) || !modelName || modelName === \"\") {\n    return \"Please select a model on the right\";\n  }\n\n  if (paths.startsWith(\"upsert/\")) {\n    return <UpsertPage />;\n  }\n\n  return <DbPage />;\n}"
  },
  "DbLayout": {
    "name": "DbLayout",
    "slug": "TsFunction",
    "id": "edjkilcmowomvnpplxccqevg",
    "description": "",
    "operationName": "db-web",
    "rawText": " (props: { pageProps: any; nextPage: any }) => {\n  const items = [\n    { label: \"ðŸªº Nested\", value: \"nested\" },\n    { label: \"âš¡ï¸ Operaton-based\", value: \"operation\" },\n    { label: \"ðŸ‘©â€ðŸŒ¾ Flat\", value: \"flat\" },\n  ];\n  const [SelectMenu, menuType] = useSelect(items, items[0]);\n\n  const dbMenuQuery = queries.useGetNestedDatabaseMenu({\n    noOperationName: menuType?.value === \"flat\",\n    noOperationPath: menuType?.value !== \"nested\",\n    noSrcRelativeFolder: menuType?.value !== \"nested\",\n    noPrefix: true,\n  });\n\n  const { flat, nested } = destructureOptionalObject(dbMenuQuery.data?.result);\n\n  const { nextPage, pageProps } = props;\n  return (\n    <AuthenticationLayout\n      // menu props\n      menu={{\n        // NB: passionfruit wants this xD just make a layoutconfig in the PublicBundleConfig, or make it editable per user (later)\n        menuPosition: \"left\",\n        menuHeader: () => {\n          return <SelectMenu />;\n        },\n        isLoading: dbMenuQuery.isLoading,\n        webPagesFlat: flat,\n        webPagesNested: nested,\n      }}\n      // other\n      nextPage={nextPage}\n      pageProps={pageProps}\n    />\n  );\n}"
  },
  "{ publicRuntimeConfig }": {
    "name": "{ publicRuntimeConfig }",
    "slug": "TsVariable",
    "id": "ywsslkfpvqgioszkpiupwfzp",
    "description": "",
    "operationName": "db-web"
  },
  "addDefaultValues": {
    "name": "addDefaultValues",
    "slug": "TsFunction",
    "id": "qpxjfscobqditawvutvgduhk",
    "description": "Adds timestamps, id, and a slug IF these things are not already present\n\nNB: slugs will be slugified here!\nNB: if there is a name present, slug will be added here!\n\nNB: for kvmd storage, id will be set to a kebab-case of the name\n\nNB: does not add the ModelLocation parameters",
    "operationName": "fs-orm",
    "rawText": " (\n  bareItem: Creation<AugmentedAnyModelType>,\n  isKvmdStorage?: boolean\n): AugmentedAnyModelType => {\n  const now = Date.now();\n\n  const defaultValues = {\n    createdAt: now,\n    updatedAt: now,\n    deletedAt: 0,\n    createdFirstAt: now,\n  };\n\n  const shouldCreateSlugFromName =\n    !!bareItem.name && bareItem.slug === undefined;\n\n  const slugifiedSlug = bareItem.slug ? slugify(bareItem.slug) : undefined;\n\n  const isValidSlug =\n    bareItem.slug === undefined || slugifiedSlug === bareItem.slug;\n\n  if (!isValidSlug) {\n    log(\n      `${bareItem.slug} is not a slugified slug, it has been altered to a valid slug`,\n      { type: \"warning\" }\n    );\n  }\n\n  const slug: string | undefined = shouldCreateSlugFromName\n    ? slugify(bareItem.name)\n    : slugifiedSlug;\n\n  const id =\n    bareItem.id === undefined\n      ? isKvmdStorage\n        ? kebabCase(bareItem.name)\n        : generateId()\n      : bareItem.id;\n\n  const item = {\n    ...defaultValues,\n    ...bareItem,\n    slug,\n    id,\n  } as AugmentedAnyModelType;\n\n  return item;\n}"
  },
  "alterAny": {
    "name": "alterAny",
    "slug": "TsFunction",
    "id": "fakkeisjpnhxjrpfgmrwfapt",
    "description": "low level function that alters data from any storage method at a certain location\n\ncomprises all dbStorageMethods",
    "operationName": "fs-orm",
    "rawText": " async (\n  dbStorageMethod: DbStorageMethod,\n  ...alterParameters: AlterParameters\n): Promise<DbQueryResult> => {\n  if (dbStorageMethod === \"csv\") return alterCsv(...alterParameters);\n  if (dbStorageMethod === \"jsonSingle\")\n    return alterJsonSingle(...alterParameters);\n  if (dbStorageMethod === \"keyValueMarkdown\") {\n    // this case never happens, this is never the case\n    log(\"Wut??? this case should be prevented by its parent function\", {\n      type: \"warning\",\n    });\n    return alterKeyValueMarkdown(...alterParameters);\n  }\n  if (dbStorageMethod === \"markdown\") return alterMarkdown(...alterParameters);\n  return alterJsonMultiple(...alterParameters);\n}"
  },
  "alterCsv": {
    "name": "alterCsv",
    "slug": "TsFunction",
    "id": "rvmfwczyhxadybjticwrzcup",
    "description": "Alters a csv",
    "operationName": "fs-orm",
    "rawText": " async (dbFileLocation, alterFn) => {\n  const { absolutePath } = dbFileLocation;\n  const bareData =\n    (await readCsvFile<Storing<CsvItemType>>(absolutePath)) || [];\n  const isNewFile = !bareData;\n  const { newStoredData, ...queryResult } = alterFn(bareData);\n  if (newStoredData.length === 0 && !!bareData) {\n    // NB: if new array is empty, just remove the file\n    await fs.rm(absolutePath);\n    return queryResult;\n  }\n\n  const newDataString = csvItemArrayToCsvString(newStoredData);\n  const isSuccesful = await writeStringToFile(absolutePath, newDataString);\n  if (!isSuccesful) return { isSuccesful, message: \"Could not write to file\" };\n  return {\n    isNewFile,\n    isSuccesful,\n    ...queryResult,\n  };\n}"
  },
  "alterJsonMultiple": {
    "name": "alterJsonMultiple",
    "slug": "TsFunction",
    "id": "fqpkgyozdogunuzfutenjhjx",
    "description": "Alters a json multiple file",
    "operationName": "fs-orm",
    "rawText": " async (\n  dbFileLocation,\n  alterFn\n) => {\n  const { absolutePath } = dbFileLocation;\n  const storedJson = await readJsonFile<Storing<AugmentedAnyModelType>[]>(\n    dbFileLocation.absolutePath\n  );\n\n  const storedData = storedJson || [];\n\n  const isNewFile = !storedJson;\n  const { newStoredData, ...queryResult } = alterFn(storedData);\n\n  if (newStoredData.length === 0 && !!storedJson) {\n    // NB: if new stored data is an empty array, just remove the file\n    await fs.rm(absolutePath);\n    return { isNewFile: false, ...queryResult };\n  }\n\n  const isSuccesful = await writeJsonToFile(absolutePath, newStoredData);\n\n  if (!isSuccesful) return { isSuccesful, message: \"Could not write to file\" };\n  return {\n    isNewFile,\n    isSuccesful,\n    ...queryResult,\n  };\n}"
  },
  "alterJsonSingle": {
    "name": "alterJsonSingle",
    "slug": "TsFunction",
    "id": "gdnhkejutstdqliaqmrzaotd",
    "description": "Alters a json single file",
    "operationName": "fs-orm",
    "rawText": " async (\n  dbFileLocation,\n  alterFn\n) => {\n  const { absolutePath } = dbFileLocation;\n  const storedJson = await readJsonFile<Storing<AugmentedAnyModelType>>(\n    dbFileLocation.absolutePath\n  );\n  const isNewFile = !storedJson;\n  const storedData = storedJson ? [storedJson] : [];\n  const { newStoredData, ...queryResult } = alterFn(storedData);\n\n  const isSuccesful = await writeJsonToFile(absolutePath, newStoredData[0]);\n\n  if (!isSuccesful) return { isSuccesful, message: \"Could not write to file\" };\n  return {\n    isNewFile,\n    isSuccesful,\n    ...queryResult,\n  };\n}"
  },
  "alterKeyValueMarkdown": {
    "name": "alterKeyValueMarkdown",
    "slug": "TsFunction",
    "id": "upowuoothdmefcsjwsnnkeyb",
    "description": "",
    "operationName": "fs-orm",
    "rawText": " async (\n  dbFileLocation,\n  alterFn\n) => {\n  const { absolutePath } = dbFileLocation;\n\n  const kvmdParse: KeyValueMarkdownParse | null = await readKvmdFile(\n    absolutePath,\n    dbFileLocation\n  );\n\n  const isNewFile = !kvmdParse;\n\n  const storedData = kvmdParse?.data || [];\n\n  // console.log({ storedData });\n  const { newStoredData, ...queryResult } = alterFn(storedData);\n  // console.log({ newStoredData });\n  const newKvmdParse: KeyValueMarkdownParse = {\n    parameters: kvmdParse?.parameters || {},\n    data: newStoredData as KeyValueMarkdownModelType[],\n  };\n\n  const newDataString = kvmdParseToMarkdownString(newKvmdParse);\n  const isSuccesful = await writeStringToFile(absolutePath, newDataString);\n\n  if (!isSuccesful) return { isSuccesful, message: \"Could not write to file\" };\n  return {\n    isNewFile,\n    isSuccesful,\n    ...queryResult,\n  };\n}"
  },
  "alterMarkdown": {
    "name": "alterMarkdown",
    "slug": "TsFunction",
    "id": "hxiuownquupgbxaryoztjpxl",
    "description": "Alters a markdown file",
    "operationName": "fs-orm",
    "rawText": " async (dbFileLocation, alterFn) => {\n  const { absolutePath } = dbFileLocation;\n  const markdownParse = await readMarkdownFile(absolutePath);\n  const isNewFile = !markdownParse;\n  const markdownModelItem = markdownParseToMarkdownModelType(markdownParse);\n\n  const storedData = markdownModelItem ? [markdownModelItem] : [];\n  const { newStoredData, ...queryResult } = alterFn(storedData);\n  const finalItem: Storing<MarkdownModelType> = newStoredData[0];\n  const markdownString = markdownModelTypeToMarkdownString(finalItem);\n  const isSuccesful = await writeStringToFile(absolutePath, markdownString);\n\n  if (!isSuccesful) return { isSuccesful, message: \"Could not write to file\" };\n  return {\n    isNewFile,\n    isSuccesful,\n    ...queryResult,\n  };\n}"
  },
  "augmentItemWithReferencedDataRecursively": {
    "name": "augmentItemWithReferencedDataRecursively",
    "slug": "TsFunction",
    "id": "mrcucbltqlwxbuvoqdrqurfy",
    "description": "",
    "operationName": "fs-orm",
    "rawText": " (\n  item: AugmentedAnyModelType,\n\n  includeArray: Include[],\n  /**\n   * Final includeData object to take items from\n   */\n  includeData: IncludeDataObject\n): AugmentedAnyModelType => {\n  // basecase\n  if (includeArray.length === 0) {\n    return item;\n  }\n\n  const newItem = includeArray.reduce((itemNow, include) => {\n    if (!include.referenceKey) return itemNow;\n\n    const parameterInfo = getReferenceParameterInfo(include.referenceKey);\n\n    if (!parameterInfo.interfaceName) return itemNow;\n\n    const referencedItems = includeData[parameterInfo.interfaceName];\n\n    if (!referencedItems) return itemNow;\n    if (!parameterInfo.dataParameterName) return itemNow;\n    if (!parameterInfo.keyInModel) return itemNow;\n\n    const referenceItems = referencedItems.filter((x) => {\n      if (!parameterInfo.keyInModel) return false;\n      const itemReference: string | string[] | undefined =\n        itemNow[parameterInfo.parameterName];\n      const referenceItemReference = (x as any)[parameterInfo.keyInModel];\n\n      const isMatchingReference = parameterInfo.isReferenceSingleParameter\n        ? itemReference === referenceItemReference\n        : parameterInfo.isReferenceMultipleParameter\n        ? itemReference?.includes?.(referenceItemReference) || false\n        : false;\n\n      return isMatchingReference;\n    });\n\n    const augmentedReferenceData:\n      | AugmentedAnyModelType\n      | AugmentedAnyModelType[]\n      | undefined = parameterInfo.isReferenceSingleParameter\n      ? augmentItemWithReferencedDataRecursively(\n          referenceItems[0],\n          makeArray(include.include),\n          includeData\n        )\n      : parameterInfo.isReferenceMultipleParameter\n      ? referenceItems.map((i) =>\n          augmentItemWithReferencedDataRecursively(\n            i,\n            makeArray(include.include),\n            includeData\n          )\n        )\n      : undefined;\n\n    const newItemNow: AugmentedAnyModelType = {\n      ...itemNow,\n      [parameterInfo.dataParameterName]: augmentedReferenceData,\n    };\n\n    return newItemNow;\n  }, item);\n\n  return newItem;\n}"
  },
  "calculateOperationsObject": {
    "name": "calculateOperationsObject",
    "slug": "TsFunction",
    "id": "ojcqffiiqnkvsmhwdlxurlpd",
    "description": "relative\n\nNeeded in case of manual project root, otherwise use SDK!\n\nReturns project relative operation base paths",
    "operationName": "fs-orm",
    "rawText": " async (manualProjectRoot: string) => {\n  const operationBasePaths = await exploreOperationFolders({\n    basePath: getPathsWithOperations({ manualProjectRoot }),\n  });\n\n  const operationsObject = mergeObjectsArray(\n    operationBasePaths.map((operationBasePath) => {\n      return {\n        [getLastFolder(operationBasePath)]: makeRelative(\n          operationBasePath,\n          manualProjectRoot\n        ),\n      };\n    })\n  );\n\n  return operationsObject;\n}"
  },
  "categoryStack": {
    "name": "categoryStack",
    "slug": "TsVariable",
    "id": "bbdgymrswitthioujtukekeh",
    "description": "",
    "operationName": "fs-orm"
  },
  "createDb": {
    "name": "createDb",
    "slug": "TsFunction",
    "id": "lpyropurbipdcosvgnwnuvea",
    "description": "Create your database by passing your models as a generic and some optional configuration",
    "operationName": "fs-orm",
    "rawText": " <TModels extends AnyModelObject>(\n  dbConfig?: DbConfig<TModels>\n): Db<TModels> => {\n  // need to get\n\n  const getDbFileLocationPath = async (\n    storedItem: Storing<AugmentedAnyModelType>,\n    operationName: string | null,\n    modelName: Extract<keyof TModels, string>,\n    config: CustomQueryConfig\n  ) => {\n    const mergedQueryConfig = mergeConfigs(modelName, dbConfig, config);\n\n    const result = await getDbFileLocation(\n      storedItem,\n      operationName,\n      mergedQueryConfig,\n      modelName\n    );\n\n    return result?.absolutePath;\n  };\n\n  const getByFile = async <TModelName extends Keys<TModels>>(\n    modelName: TModelName,\n    config?: GetQueryConfig<TModels[TModelName]>\n  ) => {\n    const executionId = generateUniqueId();\n    const performance: (PerformanceItem | undefined)[] = [];\n\n    getNewPerformance(\"start\", executionId, true);\n\n    const mergedQueryConfig = mergeConfigs(modelName, dbConfig, config);\n    performance.push(getNewPerformance(\"mergeConfigs\", executionId));\n\n    const dbFiles = await getDatabaseFiles(modelName, mergedQueryConfig);\n    performance.push(getNewPerformance(\"getDatabaseFiles\", executionId));\n\n    // console.log(\"getByFile\", {\n    //   modelName,\n    //   mergedQueryConfig,\n    //   dbFiles: dbFiles.length,\n    // });\n\n    /**\n     * An object used for attaching all referenced data onto the model, recursively\n     */\n    let includeData: IncludeDataObject = {};\n\n    /**\n     * A recursive function that takes an Include and adds data to includeData, if it's not already there\n     */\n    const processInclude = async (includeConfig: Include) => {\n      if (!includeConfig.referenceKey) return;\n\n      const parameterInfo = getReferenceParameterInfo(\n        includeConfig.referenceKey\n      );\n\n      if (!parameterInfo.isReferenceParameter || !parameterInfo.interfaceName)\n        return;\n\n      if (!includeData[parameterInfo.interfaceName]) {\n        const includeThisData = await get(\n          parameterInfo.interfaceName as Keys<TModels>,\n          { manualProjectRoot: mergedQueryConfig.manualProjectRoot }\n        );\n        includeData[parameterInfo.interfaceName] = includeThisData;\n      }\n\n      if (includeConfig.include) {\n        // Recursively process all includes as well\n        const includeArray = makeArray(includeConfig.include);\n        await Promise.all(includeArray.map(processInclude));\n      }\n    };\n\n    // NB: for auto we need to do it per file because we don't know exactly which keys exist on the model yet\n    const isAuto: boolean =\n      config?.include && !Array.isArray(config.include)\n        ? config.include.auto === true\n          ? true\n          : false\n        : false;\n\n    // NB: Create an includeArray or fill the includeData object\n    const includeArray: Include[] =\n      isAuto || !config?.include ? [] : makeArray(config?.include);\n    await Promise.all(includeArray.map(processInclude));\n\n    performance.push(getNewPerformance(\"processInclude\", executionId));\n\n    const dbContentPromises = dbFiles.map(async (dbFileLocation) => {\n      const items = await getAugmentedData<TModels[TModelName]>(\n        dbFileLocation,\n        mergedQueryConfig.dbStorageMethod\n      );\n      if (!items) return;\n\n      const filteredItems = config?.filter\n        ? items.filter(config.filter)\n        : items;\n\n      let augmentedItems: TModels[TModelName][] = includeArray\n        ? filteredItems.map(\n            (item) =>\n              augmentItemWithReferencedDataRecursively(\n                item,\n                includeArray,\n                includeData\n              ) as TModels[TModelName]\n          )\n        : filteredItems;\n\n      if (isAuto) {\n        /**\n        TODO: \n\n        Go over all keys in the first item of augmentedItems, and see if it contains reference keys.\n\n        For every reference key, create an `Include`. call `includes.map(processInclude)`\n        \n        Call augmentItemRecursively with the includes.\n\n        */\n        log(\"auto is not supported yet\", { type: \"warning\" });\n        augmentedItems = augmentedItems;\n      }\n\n      return { [dbFileLocation.absolutePath]: augmentedItems };\n    });\n\n    performance.push(getNewPerformance(\"dbContentPromises\", executionId));\n\n    const dbContent = (await Promise.all(dbContentPromises)).filter(notEmpty);\n\n    performance.push(getNewPerformance(\"dbContent\", executionId));\n\n    const dbContentObject = mergeObjectsArray(dbContent);\n\n    performance.push(getNewPerformance(\"dbContentObject\", executionId));\n\n    // console.log(\"get performance\", performance);\n\n    cleanupTimer(executionId);\n\n    // console.log({ dbContentObject });\n    return dbContentObject;\n  };\n\n  const get: DbGet<TModels> = async <TModelName extends Keys<TModels>>(\n    modelName: TModelName,\n    config?: GetQueryConfig<TModels[TModelName]>\n  ) => {\n    const items = (\n      Object.values(\n        await getByFile(modelName, config)\n      ) as TModels[TModelName][][]\n    ).flat();\n    return items;\n  };\n\n  /**\n   *\n   */\n  const clear = async <TModelName extends Keys<TModels>>(\n    modelName: TModelName,\n    config?: CustomQueryConfig\n  ) => {\n    const mergedConfig = mergeConfigs(modelName, dbConfig, config);\n    const locations = await getDatabaseFiles(modelName, mergedConfig);\n\n    await mapMany(\n      locations,\n      async (loc) => fs.existsSync(loc.absolutePath) && fs.rm(loc.absolutePath),\n      maxConcurrency\n    );\n\n    return {\n      amountRemoved: locations.length,\n      isSuccesful: true,\n      message: `${locations.length} files removed`,\n    };\n  };\n\n  /**\n   * It seems problematic to remove a file temporarily because other query's may require it to be there.\n   */\n  const set: DbSet<TModels> = async <TModelName extends Keys<TModels>>(\n    modelName: TModelName,\n    data: Creation<TModels[TModelName]>[],\n    config?: CustomQueryConfig\n  ) => {\n    const mergedConfig = mergeConfigs(modelName, dbConfig, config);\n    const { dbStorageMethod } = mergedConfig;\n\n    const itemsPerFile = await groupByFile(data, mergedConfig, modelName);\n    const newFilePaths = Object.keys(itemsPerFile);\n    const oldLocations = await getDatabaseFiles(modelName, mergedConfig);\n    const removableLocations = oldLocations.filter(\n      (x) => !newFilePaths.includes(x.absolutePath)\n    );\n\n    // Then, if there are new items for that file location, also set that file to contain the new items\n\n    const upsertResults = (\n      await mapMany(newFilePaths, async (fileKey) => {\n        const value = itemsPerFile[fileKey];\n\n        if (!value) return;\n\n        const { dbFileLocation, items } = value;\n\n        log(`set new values to there: ${items.length}`, {\n          type: \"debug\",\n        });\n        // if the item-array is empty, upsert nothing.\n        if (items.length === 0) return;\n\n        const result = await upsertItems<TModels, TModelName>(\n          dbStorageMethod,\n          dbFileLocation,\n          items\n        );\n\n        return result;\n      })\n    ).filter(notEmpty);\n    if (removableLocations.length) {\n      console.log({\n        removableLocations,\n        oldLocations,\n        itemsPerFile,\n        newFilePaths,\n        data,\n      });\n    }\n    await mapMany(\n      removableLocations,\n      async (dbFileLocation) => {\n        // First remove the file\n        if (fs.existsSync(dbFileLocation.absolutePath)) {\n          log(`Removing ${dbFileLocation.absolutePath}`, { type: \"warning\" });\n          await fs.rm(dbFileLocation.absolutePath);\n        }\n      },\n      maxConcurrency\n    );\n    const amountInserted = sum(upsertResults.map((x) => x.amountInserted || 0));\n\n    return {\n      isSuccesful: true,\n      amountInserted,\n    };\n  };\n\n  /**\n   * TODO: currently very memory inefficient\n   * cannot even update\n   */\n  const upsert: DbUpsert<TModels> = async <TModelName extends Keys<TModels>>(\n    modelName: TModelName,\n    data: Creation<TModels[TModelName]> | Creation<TModels[TModelName]>[],\n    config?: UpsertQueryConfig\n  ) => {\n    const mergedConfig = mergeConfigs(modelName, dbConfig, config);\n    const { dbStorageMethod } = mergedConfig;\n    const creationItems = makeArray(data);\n\n    //  splits the items into the needed files\n    const dataPerStorageFile = await groupByFile(\n      creationItems,\n      mergedConfig,\n      modelName\n    );\n\n    // console.dir({ dataPerStorageFile }, { depth: 9 });\n    // console.log({ dataPerStorageFile: Object.keys(dataPerStorageFile) });\n\n    //  upserts items for every file, grouped, efficiently.\n    const result = await mapMany(\n      Object.keys(dataPerStorageFile),\n      async (absolutePath) => {\n        const itemsObject = dataPerStorageFile[absolutePath];\n        const { dbFileLocation, items } = itemsObject;\n        if (config?.removeUntouched && fs.existsSync(absolutePath)) {\n          await fs.rm(absolutePath);\n        }\n\n        // wait until there's no lockfile\n\n        const lockfilePath = dbFileLocation.absolutePath + \".lock\";\n\n        await waitForLockfile(lockfilePath);\n\n        // console.log(\n        //   `upserting ${dbStorageMethod} ${modelName}`,\n        //   dbFileLocation.absolutePath\n        // );\n        const result = await upsertItems<TModels, TModelName>(\n          dbStorageMethod,\n          dbFileLocation,\n          items,\n          config?.onlyInsert\n        );\n\n        await fs.rm(lockfilePath);\n        // delete lockfile\n\n        return result;\n      },\n      maxConcurrency\n    );\n\n    return {\n      isSuccesful: true,\n      message: `Upserted into ${result.length} files`,\n    };\n  };\n\n  const remove: DbRemove<TModels> = async <TModelName extends Keys<TModels>>(\n    modelName: TModelName,\n    removeWhere: (content: TModels[TModelName]) => boolean,\n    config?: CustomQueryConfig\n  ) => {\n    const mergedQueryConfig = mergeConfigs(modelName, dbConfig, config);\n    const dbFiles = await getDatabaseFiles(modelName, mergedQueryConfig);\n\n    // console.log({ modelName, config, mergedQueryConfig, dbFiles });\n    // console.log({ modelName, mergedQueryConfig, dbFiles: dbFiles });\n\n    const amountRemovedArray = await mapMany(\n      dbFiles,\n      async (dbFileLocation) => {\n        const { amountRemoved } = await removeMultiple(\n          mergedQueryConfig.dbStorageMethod,\n          dbFileLocation,\n          (content) => removeWhere(content as TModels[TModelName])\n        );\n\n        // console.log({ amountRemoved });\n\n        return amountRemoved || 0;\n      },\n      maxConcurrency\n    );\n\n    const amountRemoved = sum(amountRemovedArray);\n\n    if (amountRemoved === 0) {\n      return { isSuccesful: false, message: \"Nothing removed\", amountRemoved };\n    }\n\n    return {\n      amountRemoved,\n      isSuccesful: true,\n      message: \"Items removed\",\n    };\n  };\n\n  const update: DbUpdate<TModels> = async <TModelName extends Keys<TModels>>(\n    modelName: TModelName,\n    updateWhere: undefined | ((content: TModels[TModelName]) => boolean),\n    map: (oldValue: TModels[TModelName]) => TModels[TModelName],\n    config?: CustomQueryConfig\n  ) => {\n    // `get` -> `update` -> `groupByFile(newItems)` -> set (overwrite those files, remove leftover files)\n\n    const data = await get(modelName, config);\n\n    if (data.length === 0) {\n      return {\n        amountUpdated: 0,\n        isSuccesful: true,\n        message: \"Nothing to update\",\n      };\n    }\n    let amountUpdated = 0;\n\n    const newData: Creation<TModels[TModelName]>[] = data.map((item) => {\n      const needsUpdate = updateWhere ? updateWhere(item) : true;\n      if (needsUpdate) {\n        amountUpdated++;\n      }\n      return needsUpdate ? map(item) : item;\n    });\n\n    const { isSuccesful, message } = await set(modelName, newData, config);\n\n    const result: DbQueryResult = {\n      amountUpdated,\n      message,\n      isSuccesful,\n    };\n\n    return result;\n  };\n\n  return {\n    get,\n    getDbFileLocationPath,\n    getByFile,\n    clear,\n    upsert,\n    set,\n    remove,\n    // uses set\n    update,\n  };\n}"
  },
  "findParent": {
    "name": "findParent",
    "slug": "TsFunction",
    "id": "fwxjommjaxrcelmwjkznueda",
    "description": "this location matches any category that equals the categorystack",
    "operationName": "fs-orm",
    "rawText": " (\n  arrayItem: Storing<KeyValueMarkdownModelType>,\n  newCategoryStack: CategoryStack\n) => {\n  const categoryStackWithItself = arrayItem.categoryStack.concat(\n    arrayItem.slug\n  );\n  const locationString = categoryStackWithItself.join(\",\");\n  const newItemLocationString = newCategoryStack.join(\",\");\n  const isSameLocation = locationString === newItemLocationString;\n\n  return isSameLocation;\n}"
  },
  "getAugmentedData": {
    "name": "getAugmentedData",
    "slug": "TsFunction",
    "id": "rbhmeplijeterugqqffwmwuf",
    "description": "Gets the stored data from any file with any storage method, and augments the modelLocation onto it...\n\nAlso augments the `name`, `slug` and `categoryStack` onto this if the `dbStorageMethod` is `markdown` or `jsonSingle` and if `operationRelativePath` is not set",
    "operationName": "fs-orm",
    "rawText": " async <T>(\n  dbFileLocation: DbFileLocation,\n  dbStorageMethod: DbStorageMethod\n): Promise<T[] | null> => {\n  const { absolutePath, modelName, ...modelLocation } = dbFileLocation;\n\n  const parsedPath = path.parse(absolutePath);\n\n  const isSingleMethod =\n    dbStorageMethod === \"markdown\" || dbStorageMethod === \"jsonSingle\";\n\n  const hasOperationRelativePath = !!modelLocation.operationRelativePath;\n  const shouldAddSingleInfo = isSingleMethod && !hasOperationRelativePath;\n\n  const slugifiedName = shouldAddSingleInfo\n    ? slugify(parsedPath.name)\n    : undefined;\n  const isNameValid = shouldAddSingleInfo\n    ? slugifiedName === parsedPath.name\n    : true;\n  if (!isNameValid) {\n    log(`${parsedPath.name} is not a valid (slugified) filename`, {\n      type: \"warning\",\n    });\n  }\n\n  const rootRelativePath =\n    modelLocation.operationRelativePath || modelLocation.projectRelativePath;\n  const dbModelFolderPath = `db/${pluralize(kebabCase(modelName))}`;\n\n  const dbModelFolderRelativePath = makeRelative(\n    trimSlashes(rootRelativePath),\n    dbModelFolderPath\n  );\n  const chunks = dbModelFolderRelativePath.split(\"/\");\n  // remove the name\n  chunks.pop();\n  // What's left is the folders, if any.\n  const categoryStack = chunks;\n\n  const singleInfo = shouldAddSingleInfo\n    ? { name: slugifiedName, slug: slugifiedName, categoryStack }\n    : undefined;\n  const ext = parsedPath.ext;\n\n  if (ext === \".json\") {\n    const jsonContent = await readJsonFile<any>(absolutePath);\n    const jsonContentArray = jsonContent ? makeArray(jsonContent) : null;\n    const augmented: T[] | null = jsonContentArray\n      ? (jsonContentArray.map((x) => ({\n          ...x,\n          ...modelLocation,\n          ...singleInfo,\n        })) as T[])\n      : null;\n\n    return augmented;\n  }\n\n  if (ext === \".csv\") {\n    const csvContent = await readCsvFile<any>(absolutePath);\n\n    if (!csvContent) return null;\n\n    const augmented: T[] = csvContent.map((x) => ({\n      ...x,\n      ...modelLocation,\n    }));\n    return augmented;\n  }\n\n  if (ext === \".md\") {\n    const mdParse = await readMarkdownFile(absolutePath);\n\n    if (!mdParse) return null;\n    const frontmatter = mdParse?.parameters;\n    if (dbStorageMethod === \"markdown\") {\n      const markdownContent = {\n        ...frontmatter,\n\n        markdown: mdParse.raw,\n        ...modelLocation,\n        ...singleInfo,\n        // NB: have to convert to unknown here first because of the specified markdown prop\n      } as unknown as T;\n\n      // console.log({ frontmatter, modelLocation, singleInfo });\n      return [markdownContent];\n    }\n\n    const keyValueMarkdownParse = markdownStringToKvmdParse(\n      mdParse.raw,\n      dbFileLocation\n    );\n\n    // NB: typing as unknown is required because it will only work for keyValueMarkdown models\n    const keyValueMarkdown = keyValueMarkdownParse.data as unknown as T[];\n\n    return keyValueMarkdown;\n  }\n\n  return null;\n}"
  },
  "getDatabaseFiles": {
    "name": "getDatabaseFiles",
    "slug": "TsFunction",
    "id": "qzfwqpevunfxakpqkqkawodq",
    "description": "This function gets the files that the data can be stored, by convention, based on the model and the config\n\nOnly returns the file paths that actually exist.\n\nCONVENTION:\n\nWhen searching for data, `fs-orm` will look in:\n- `db/` in your project root\n- `db/` in any operation\n\nIn these folders, `fs-orm` will search for files based on your storage method.\n@see DbStorageMethod for more info\n\nReturns not only the file paths, but also where they were found (`operationName, projectRelativePath, operationRelativePath`)",
    "operationName": "fs-orm",
    "rawText": " async (\n  modelName: string,\n  mergedConfig: MergedQueryConfig\n): Promise<DbFileLocation[]> => {\n  const executionId = generateUniqueId();\n  const performance: (PerformanceItem | undefined)[] = [];\n  getNewPerformance(\"start\", executionId, true);\n\n  const projectRoot =\n    mergedConfig?.manualProjectRoot || mergedConfig.projectRoot;\n  if (!projectRoot) return [];\n\n  const dbStorageMethod = mergedConfig.dbStorageMethod;\n\n  performance.push(getNewPerformance(\"get projectRoot\", executionId));\n\n  const pattern = getLocationPattern(dbStorageMethod, modelName, mergedConfig);\n\n  performance.push(getNewPerformance(\"get location pattern\", executionId));\n\n  const operationPath = await getMergedConfigOperationPath(\n    mergedConfig,\n    projectRoot\n  );\n\n  performance.push(\n    getNewPerformance(\"get merged config operation path\", executionId)\n  );\n\n  // console.log({ pattern, operationPath });\n\n  // Please note, it can return false as well, which should continue here\n  if (operationPath === undefined) return [];\n\n  const rootFolders = await getRootFolders({\n    mergedConfig,\n    operationPath,\n    projectRoot,\n    manualProjectRoot: projectRoot,\n  });\n\n  // console.log({ rootFolders });\n  performance.push(getNewPerformance(\"getRootFolders\", executionId));\n\n  cleanupTimer(executionId);\n  // console.log({ performance });\n\n  /**\n  based on configuration and convention, we will fill this array with the files to get data from\n\n  NB: this should contain the actual files, not the patterns\n   */\n  let dbFiles: DbFileLocation[] = [];\n\n  const isOperationFile =\n    !!mergedConfig.operationName &&\n    !!operationPath &&\n    !!mergedConfig.operationRelativePath;\n\n  if (isOperationFile && !!operationPath) {\n    const exactAbsoluteOperationFilePath = path.join(\n      operationPath,\n      mergedConfig.operationRelativePath!\n    );\n    //make sure that extension matches `dbStorageMethod`, warn otherwise\n    const customExt = mergedConfig.operationRelativePath\n      ? path.parse(mergedConfig.operationRelativePath).ext\n      : undefined;\n    const isWrongExtension =\n      customExt !== getDbStorageMethodExtension(dbStorageMethod);\n\n    if (isWrongExtension) {\n      log(\n        `Incorrect extension found in operationRelativePath, found ${customExt}`,\n        { type: \"warning\" }\n      );\n    }\n\n    const projectRelativePath = exactAbsoluteOperationFilePath.substring(\n      projectRoot.length\n    );\n    const operationRelativePath =\n      mergedConfig.operationName === null\n        ? undefined\n        : exactAbsoluteOperationFilePath.substring(operationPath.length);\n\n    dbFiles.push({\n      modelName,\n      absolutePath: exactAbsoluteOperationFilePath,\n      operationName: mergedConfig.operationName!,\n      projectRelativePath,\n      operationRelativePath,\n    });\n  }\n\n  if (!isOperationFile && mergedConfig.projectRelativePath) {\n    const absolutePath = path.join(\n      projectRoot,\n      mergedConfig.projectRelativePath\n    );\n    const operationName = null;\n    const projectRelativePath = mergedConfig.projectRelativePath;\n\n    dbFiles.push({\n      modelName,\n      absolutePath,\n      operationName,\n      projectRelativePath,\n    });\n  }\n\n  if (!mergedConfig.projectRelativePath && !isOperationFile && pattern) {\n    // no exact path\n\n    const conventionedPaths: DbFileLocation[] = (\n      await Promise.all(\n        rootFolders.map(async (rootFolder) => {\n          const absolutePathPattern = path.join(rootFolder.basePath, pattern);\n          const projectRelativePath = absolutePathPattern.substring(\n            projectRoot.length\n          );\n\n          const operationRelativePath =\n            rootFolder.operationName === null\n              ? undefined\n              : absolutePathPattern.substring(rootFolder.basePath.length);\n\n          const parsedPath = path.parse(absolutePathPattern);\n\n          if (parsedPath.name === \"*\") {\n            const fileNames = getWildcardDbFileLocations({\n              modelName,\n              parsedPath,\n              operationName: rootFolder.operationName,\n              projectRoot,\n              rootFolder,\n            });\n\n            return fileNames;\n          } else {\n            const dbFileLocation: DbFileLocation = {\n              modelName,\n              absolutePath: absolutePathPattern,\n              operationName: rootFolder.operationName,\n              projectRelativePath,\n              operationRelativePath,\n            };\n            return [dbFileLocation];\n          }\n        })\n      )\n    ).flat();\n\n    dbFiles = dbFiles.concat(conventionedPaths);\n  }\n\n  return dbFiles;\n}"
  },
  "getDatabaseRootFolder": {
    "name": "getDatabaseRootFolder",
    "slug": "TsFunction",
    "id": "nuhwrykiexzsottphxzbzljh",
    "description": "Tries to get the root folder where the database folder can be found.\n\nIf an operationName is specified, this will be the operation base path\nIf not, this will be the project root.",
    "operationName": "fs-orm",
    "rawText": " async (\n  operationName: string | null | undefined,\n  manualProjectRoot?: string\n): Promise<string | undefined> => {\n  const projectRoot = manualProjectRoot || getProjectRoot();\n  if (!projectRoot) {\n    log(\"getDatabaseRootFolder: No project root found\");\n    process.exit(1);\n  }\n\n  if (!operationName) {\n    return projectRoot;\n  }\n\n  const operationBasePath = await getOperationPath(operationName, {\n    manualProjectRoot,\n  });\n\n  if (!operationBasePath) {\n    log(`Couldn't find operation base path for ${operationName}`, {\n      type: \"error\",\n    });\n  }\n\n  return operationBasePath;\n}"
  },
  "getDbFileLocation": {
    "name": "getDbFileLocation",
    "slug": "TsFunction",
    "id": "ezltoxgeyivumywmnbaufxoa",
    "description": "Used by `groupByFile`, which is used for `set` (and thus, also `update`) and `upsert`: determines the new file location.\n\nApplies the convention to get the db-file-location of an item\n\nBased on the merged config:\n\n- if `operationRelativePath` is specified, gets a filePath in the operation\n- if `projectRelativePath` is specified, gets a filepath in the project\n- otherwise gets the pattern and replaces \"*\" with the slug (or id if slug is not available)\n\nBesides the absolute path, the operationName, projectRelativePath and operationRelativePath are also supplied.\n\nNB: currently, the item's `operationName`, `operationRelativePath` or `projectRelativePath` is not taken into account. It will simply look at the convention to see where it should be saved, and apply the MergedQueryConfig...",
    "operationName": "fs-orm",
    "rawText": " async (\n  /**\n   * The ModelLocation properties in the item are completely ignored.\n   *\n   * Only the ID, slug and categoryStack are used to determine the exact file the item should be stored in.\n   *\n   * NB: storedItem MUST have a slug or ID, but this should probably be generated before this funciton\n   */\n  storedItem: Storing<AugmentedAnyModelType>,\n  /**\n   * Should be the operationName from the modellocation of the actual item.\n   *\n   * If it is given, this will take priority over the merged query config.\n   */\n  operationName: null | string,\n  mergedConfig: MergedQueryConfig,\n  modelName: string\n): Promise<DbFileLocation | undefined> => {\n  const projectRoot =\n    mergedConfig.manualProjectRoot || mergedConfig.projectRoot;\n\n  if (!projectRoot) {\n    log(\"No project root\", { type: \"error\" });\n    return;\n  }\n  const realOperationName = operationName || mergedConfig.operationName;\n\n  const rootFolder = await getDatabaseRootFolder(\n    realOperationName,\n    mergedConfig.manualProjectRoot\n  );\n\n  if (!rootFolder) return;\n\n  const isSingleItemStorageMethod =\n    mergedConfig.dbStorageMethod === \"jsonSingle\" ||\n    mergedConfig.dbStorageMethod === \"markdown\";\n\n  const filename = storedItem.slug || storedItem.id;\n\n  const relativeFolder: string | undefined =\n    storedItem.categoryStack?.join?.(\"/\");\n  const dbModelFolderRelativeLocation: string =\n    isSingleItemStorageMethod && relativeFolder\n      ? path.join(relativeFolder, filename)\n      : filename;\n\n  const pattern = getLocationPattern(\n    mergedConfig.dbStorageMethod,\n    modelName,\n    mergedConfig\n  );\n  if (!pattern) return;\n\n  const absolutePath = path.join(\n    rootFolder,\n    pattern.replace(\"*\", dbModelFolderRelativeLocation)\n  );\n  if (!absolutePath) return;\n\n  const operationRelativePath = makeRelative(absolutePath, rootFolder);\n  const projectRelativePath = makeRelative(absolutePath, projectRoot);\n\n  const dbFileLocation: DbFileLocation = {\n    modelName,\n    absolutePath,\n    operationName: realOperationName || null,\n    projectRelativePath,\n    operationRelativePath,\n  };\n\n  return dbFileLocation;\n}"
  },
  "getDbStorageMethodExtension": {
    "name": "getDbStorageMethodExtension",
    "slug": "TsFunction",
    "id": "tfwjyzhvhimlzzmglrpkrtyf",
    "description": "",
    "operationName": "fs-orm",
    "rawText": " (\n  dbStorageMethod: DbStorageMethod\n): string => {\n  if (dbStorageMethod === \"csv\") return \".csv\";\n  if (dbStorageMethod === \"jsonMultiple\") return \".json\";\n  if (dbStorageMethod === \"jsonSingle\") return \".json\";\n  if (dbStorageMethod === \"keyValueMarkdown\") return \".md\";\n  return \".md\";\n}"
  },
  "getDefaultLocationPattern": {
    "name": "getDefaultLocationPattern",
    "slug": "TsFunction",
    "id": "gdvyxgydqwprowaaividmava",
    "description": "DB main storage convention",
    "operationName": "fs-orm",
    "rawText": " (\n  dbStorageMethod: DbStorageMethod,\n  modelName: string\n): string | undefined => {\n  const fileOrFolderName = pluralize(kebabCase(modelName));\n  if (dbStorageMethod === \"jsonMultiple\") return `db/${fileOrFolderName}.json`;\n  if (dbStorageMethod === \"keyValueMarkdown\")\n    return `db/${fileOrFolderName}.md`;\n  if (dbStorageMethod === \"csv\") return `db/${fileOrFolderName}.csv`;\n\n  if (dbStorageMethod === \"jsonSingle\") return `db/${fileOrFolderName}/*.json`;\n  if (dbStorageMethod === \"markdown\") return `db/${fileOrFolderName}/*.md`;\n}"
  },
  "getItemModelLocation": {
    "name": "getItemModelLocation",
    "slug": "TsFunction",
    "id": "iawaddfetgkrdnhhjqluyymn",
    "description": "",
    "operationName": "fs-orm",
    "rawText": " <T extends { [key: string]: any }>(\n  item: T\n): ModelLocation => {\n  const { operationName, projectRelativePath, operationRelativePath, ...rest } =\n    item;\n\n  return { operationName, projectRelativePath, operationRelativePath };\n}"
  },
  "getLength": {
    "name": "getLength",
    "slug": "TsFunction",
    "id": "vibwjumqmskklepqkxqlpspd",
    "description": "Safely gets the length of something",
    "operationName": "fs-orm",
    "rawText": " (array: any[]) => {\n  if (!Array.isArray(array)) {\n    log(`Array is not array`, { type: \"error\" }, { array });\n    return 0;\n  }\n  return array.length;\n}"
  },
  "getLocationPattern": {
    "name": "getLocationPattern",
    "slug": "TsFunction",
    "id": "zlffjcogkoynrkunczjbxpob",
    "description": "Returns the pattern or an exact relative path that the file(s) should be stored at.\n\nIf a pattern contains a star at the place of the filename, it will search the folder recursively for all files with the extension in the pattern.\n\nReturning relative path has no preceding slash",
    "operationName": "fs-orm",
    "rawText": " (\n  dbStorageMethod: DbStorageMethod,\n  modelName: string,\n  mergedConfig: MergedQueryConfig\n): string | undefined => {\n  const { operationRelativePath, projectRelativePath } = mergedConfig;\n\n  if (operationRelativePath) return operationRelativePath;\n  if (projectRelativePath) return projectRelativePath;\n\n  return getDefaultLocationPattern(dbStorageMethod, modelName);\n}"
  },
  "getMergedConfigOperationPath": {
    "name": "getMergedConfigOperationPath",
    "slug": "TsFunction",
    "id": "zwggfavmsienlpugusdfiudr",
    "description": "NB: returns 3 things:\n- false: no operation path\n- undefined: operation path undefined\n- path: the specific operation path",
    "operationName": "fs-orm",
    "rawText": " async (\n  mergedConfig: MergedQueryConfig,\n  manualProjectRoot?: string\n): Promise<false | string | undefined> => {\n  if (mergedConfig.operationName && mergedConfig.operationName !== \"*\") {\n    const operationPath = await getOperationPath(mergedConfig.operationName, {\n      manualProjectRoot,\n      notUseSdk: !!manualProjectRoot,\n    });\n    //\n    if (operationPath === undefined) {\n      log(`Operation wasn't found ${mergedConfig.operationName}`, {\n        type: \"warning\",\n      });\n    }\n\n    return operationPath;\n  }\n  // NB: not the same as undefined!\n  return false;\n}"
  },
  "getParentSlug": {
    "name": "getParentSlug",
    "slug": "TsFunction",
    "id": "nqkxzjnvyiotosjamwfmngze",
    "description": "get a parent slug without the parent_xxxSlug reference (uses the categoryStack)\n\ncan be undefined if the item has no parent",
    "operationName": "fs-orm",
    "rawText": " (\n  item: Storing<KeyValueMarkdownModelType>\n): string | undefined => {\n  const parentSlug: string | undefined =\n    item.categoryStack[item.categoryStack.length - 1];\n  return parentSlug;\n}"
  },
  "getRootFolders": {
    "name": "getRootFolders",
    "slug": "TsFunction",
    "id": "dlucgsahvhkjvbpnmaupurgk",
    "description": "Gets all root folders where db folders can be located inside of\n\nNB: Before november '22, this function is quite slow if it needs to find all operation folders becuase this takes at least 60ms.",
    "operationName": "fs-orm",
    "rawText": " async (config: {\n  manualProjectRoot?: string;\n  projectRoot: string;\n  mergedConfig: MergedQueryConfig;\n  operationPath: string | false;\n}): Promise<RootDbFolder[]> => {\n  const { mergedConfig, operationPath, projectRoot, manualProjectRoot } =\n    config;\n\n  // simple case: specific operation\n  if (operationPath && mergedConfig.operationName) {\n    return [\n      { basePath: operationPath, operationName: mergedConfig.operationName },\n    ];\n  }\n\n  const shouldSearchOperations = mergedConfig.operationName === \"*\";\n  const shouldSearchProject =\n    mergedConfig.operationName === undefined ||\n    mergedConfig.operationName === null ||\n    mergedConfig.operationName !== \"*\";\n\n  const projectFolder: RootDbFolder | undefined = shouldSearchProject\n    ? { operationName: null, basePath: projectRoot }\n    : undefined;\n\n  if (!shouldSearchOperations) {\n    // early return for performance reasons\n    return shouldSearchProject && projectFolder ? [projectFolder] : [];\n  }\n\n  // NB: for this we need to be sure that sdk-operations is up-to-date!\n  const realProjectRelativeOperationPathsObject: {\n    [operationName: string]: string;\n  } = manualProjectRoot\n    ? // NB: this is super slow!!! (up to 80ms)\n      await calculateOperationsObject(manualProjectRoot)\n    : operations;\n\n  const operationFolders: RootDbFolder[] = Object.keys(\n    realProjectRelativeOperationPathsObject\n  ).map((operationName) => {\n    const operationBasePath = path.join(\n      projectRoot,\n      realProjectRelativeOperationPathsObject[operationName]\n    );\n\n    return {\n      basePath: operationBasePath,\n      operationName,\n    };\n  });\n\n  const rootFolders: RootDbFolder[] = [\n    projectFolder,\n    ...operationFolders,\n  ].filter(notEmpty);\n\n  return rootFolders;\n}"
  },
  "getWildcardDbFileLocations__OLD": {
    "name": "getWildcardDbFileLocations__OLD",
    "slug": "TsFunction",
    "id": "jndryydmoguyeysagalsfwyf",
    "description": "If it all seems good, I can delete this. This is the old method of looking just in the folder itself, it's replaced by looking in all subfolders as well, recursively.",
    "operationName": "fs-orm",
    "rawText": " async (options: {\n  modelName: string;\n  parsedPath: ParsedPath;\n  operationName: string | null;\n  projectRoot: string;\n  rootFolder: RootDbFolder;\n}): Promise<DbFileLocation[]> => {\n  const { modelName, operationName, parsedPath, projectRoot, rootFolder } =\n    options;\n  if (fs.existsSync(parsedPath.dir)) {\n    // if parsedPath ends with *, read everything in the folder\n    const fileNames: DbFileLocation[] = (await fs.readdir(parsedPath.dir))\n      .filter((fileName) => fileName.endsWith(parsedPath.ext))\n      .map((fileName) => {\n        const absolutePath = path.join(parsedPath.dir, fileName);\n        const projectRelativePath = absolutePath.substring(projectRoot.length);\n        const operationRelativePath = absolutePath.substring(\n          rootFolder.basePath.length\n        );\n        const dbFileLocation: DbFileLocation = {\n          modelName,\n          absolutePath,\n          operationName: rootFolder.operationName,\n          projectRelativePath,\n          operationRelativePath,\n        };\n\n        return dbFileLocation;\n      });\n\n    return fileNames;\n  }\n\n  return [];\n}"
  },
  "getWildcardDbFileLocations": {
    "name": "getWildcardDbFileLocations",
    "slug": "TsFunction",
    "id": "nuyebfucjcqoonajykjwsebi",
    "description": "",
    "operationName": "fs-orm",
    "rawText": " async (options: {\n  modelName: string;\n  parsedPath: ParsedPath;\n  operationName: string | null;\n  projectRoot: string;\n  rootFolder: RootDbFolder;\n}): Promise<DbFileLocation[]> => {\n  const { modelName, operationName, parsedPath, projectRoot, rootFolder } =\n    options;\n\n  if (fs.existsSync(parsedPath.dir)) {\n    // if parsedPath ends with *, read everything in the folder\n\n    const exploreAbsolutePaths = (\n      await explore({\n        basePath: parsedPath.dir,\n        extension: getExtension(parsedPath.base),\n      })\n    ).map((x) => x.path);\n\n    const dbFileLocations: DbFileLocation[] = exploreAbsolutePaths.map(\n      (absolutePath) => {\n        const dbFileOperationName = rootFolder.operationName;\n\n        const projectRelativePath = absolutePath.substring(projectRoot.length);\n\n        const operationRelativePath = dbFileOperationName\n          ? absolutePath.substring(rootFolder.basePath.length)\n          : undefined;\n\n        const dbFileLocation: DbFileLocation = {\n          modelName,\n          absolutePath,\n          operationName: dbFileOperationName,\n          projectRelativePath,\n          operationRelativePath,\n        };\n\n        return dbFileLocation;\n      }\n    );\n\n    return dbFileLocations;\n  }\n\n  return [];\n}"
  },
  "groupByFile": {
    "name": "groupByFile",
    "slug": "TsFunction",
    "id": "djmvakkqzeuypatytigvcxgq",
    "description": "Used for `set` and `upsert`. Groups creation items into an object where keys are file paths and values are items that need to be stored",
    "operationName": "fs-orm",
    "rawText": " async <T extends { [key: string]: any }>(\n  creationItems: Creation<T>[],\n  mergedConfig: MergedQueryConfig,\n  modelName: string\n): Promise<ItemPerFileObject<T>> => {\n  const dataWithLocations = (\n    await Promise.all(\n      creationItems.map(async (item) => {\n        if (!item) {\n          console.log(\"WARN\");\n          return;\n        }\n\n        const fullItem = addDefaultValues(item);\n        const storingItem = makeStoringItem(fullItem) as Storing<T>;\n\n        const itemModelLocation = getItemModelLocation(fullItem);\n\n        const dbFileLocation = await getDbFileLocation(\n          storingItem,\n          itemModelLocation.operationName,\n          mergedConfig,\n          modelName\n        );\n\n        if (!dbFileLocation) return;\n\n        return { storingItem, dbFileLocation };\n      })\n    )\n  ).filter(notEmpty);\n\n  const dataPerStorageFile = dataWithLocations.reduce(\n    (fileObject, itemWithLocation) => {\n      const { absolutePath } = itemWithLocation.dbFileLocation;\n\n      const newItems = fileObject[absolutePath]\n        ? fileObject[absolutePath].items.concat(itemWithLocation.storingItem)\n        : [itemWithLocation.storingItem];\n\n      fileObject[absolutePath] = {\n        items: newItems,\n        dbFileLocation: itemWithLocation.dbFileLocation,\n      };\n\n      return fileObject;\n    },\n    {} as ItemPerFileObject<T>\n  );\n\n  return dataPerStorageFile;\n}"
  },
  "makeStoringItem": {
    "name": "makeStoringItem",
    "slug": "TsFunction",
    "id": "nsherbetnhcxnrbxrhmtiaqz",
    "description": "Three things need to happen in order to store an item\n\n1) keys that can be inferred from the file path are omitted\n2) referenced data is omitted\n3) calculated data is omitted",
    "operationName": "fs-orm",
    "rawText": " <T extends AugmentedAnyModelType>(\n  item: T\n): Storing<T> => {\n  // remove location related stuff\n\n  const { operationName, projectRelativePath, operationRelativePath, ...rest } =\n    item;\n\n  // remove referenced model data\n\n  const dataParameterNames = getDataParameterNames(item);\n  const restWithoutDataParameters = removeOptionalKeysFromObject(\n    rest,\n    dataParameterNames as any\n  );\n\n  // remove `.xyzCalculated` keys\n\n  const calculatedKeys = Object.keys(restWithoutDataParameters).filter((key) =>\n    key.endsWith(\"Calculated\")\n  );\n  const finalItem = removeOptionalKeysFromObject(\n    restWithoutDataParameters,\n    calculatedKeys as any\n  ) as Storing<T>;\n\n  return finalItem;\n}"
  },
  "maxConcurrency": {
    "name": "maxConcurrency",
    "slug": "TsVariable",
    "id": "flkdmzuqytfaajlojbptycaq",
    "description": "Crashes for upsert at 1024 on m2. It would be good to find a way to ensure we never crash here, or at least report where the out of memory bug came from.",
    "operationName": "fs-orm"
  },
  "maxQueryTimeSeconds": {
    "name": "maxQueryTimeSeconds",
    "slug": "TsVariable",
    "id": "tmzypqcagkbrirbqapowcvdk",
    "description": "",
    "operationName": "fs-orm"
  },
  "mergeConfigs": {
    "name": "mergeConfigs",
    "slug": "TsFunction",
    "id": "pveytwxetptlmxgluwzqpbbf",
    "description": "",
    "operationName": "fs-orm",
    "rawText": " <TModels extends AnyModelObject>(\n  modelName: Keys<TModels>,\n  dbConfig?: DbConfig<TModels>,\n  config?: CustomQueryConfig | GetQueryConfig<TModels[keyof TModels]>\n) => {\n  const hardcodedDefaultQueryConfig: QueryConfig = {\n    dbStorageMethod: \"jsonMultiple\",\n    // NB: this was hardcoded, but this is reducing performance a lot! Not sure why this was needed...\n    // manualProjectRoot: getProjectRoot(),\n  };\n\n  const modelConfig = dbConfig?.modelQueryConfig?.[modelName];\n\n  const mergedQueryConfig = mergeObjects<QueryConfig>(\n    hardcodedDefaultQueryConfig,\n    dbConfig?.defaultQueryConfig,\n    modelConfig,\n    config\n  )!;\n\n  // NB: dbStorageMethod is now always set\n  const merged = {\n    projectRoot: getProjectRoot(),\n    ...mergedQueryConfig,\n  } as MergedQueryConfig;\n  return merged;\n}"
  },
  "removeKeyValueMarkdown": {
    "name": "removeKeyValueMarkdown",
    "slug": "TsFunction",
    "id": "ubnlelduyzmrsvfjusewiqog",
    "description": "Takes stored data and a slug to remove",
    "operationName": "fs-orm",
    "rawText": " (\n  storedData: Storing<KeyValueMarkdownModelType>[],\n  /** slug to remove */\n  slug: string\n): DbQueryResult & {\n  newStoredData: Storing<KeyValueMarkdownModelType>[];\n} => {\n  // console.log(\"hummmmmm\");\n  // Base case\n  const foundItem = storedData.find((item) => item.slug === slug);\n\n  // console.log({ foundItem, storedData, slug });\n  if (!foundItem) {\n    return {\n      newStoredData: storedData,\n      amountRemoved: 0,\n      message: \"slug not found\",\n      isSuccesful: true,\n    };\n  }\n\n  if (foundItem.isHeaderCalculated) {\n    // console.log(\"is header calculated, remove all childs\");\n    // NB: remove all children (items of which the joined categoryStack starts with headerLocation)\n\n    const headerLocation = foundItem.categoryStack\n      .concat(foundItem.slug)\n      .join(\",\");\n\n    const newStoredData = storedData.filter((x) => {\n      const isHeaderCalculatedToRemove = x.slug === foundItem.slug;\n      const isCategoryStackSubset = x.categoryStack\n        .join(\",\")\n        .startsWith(headerLocation);\n\n      return !isHeaderCalculatedToRemove && !isCategoryStackSubset;\n    });\n\n    const amountRemoved = storedData.length - newStoredData.length;\n    return {\n      newStoredData,\n      amountRemoved,\n      isSuccesful: true,\n      message: \"removed header and all it's children\",\n    };\n  }\n\n  // console.log(\"ITS ITEM\");\n  // It's an item...\n\n  const allItemsInThisCategory = storedData.filter(\n    (x) => getParentSlug(x) === getParentSlug(foundItem)\n  );\n\n  if (allItemsInThisCategory.length === 0) {\n    return {\n      isSuccesful: false,\n      message: \"Tautology\",\n      newStoredData: storedData,\n      amountRemoved: 0,\n    };\n  }\n\n  // If the item is one of many in a category, we can simply remove it, because the category is still relevant\n  if (allItemsInThisCategory.length > 1) {\n    // console.log(\"More itesm in cateogry\", storedData);\n    const newStoredData = storedData.filter((x) => x.slug !== foundItem.slug);\n    const amountRemoved = storedData.length - newStoredData.length;\n    return {\n      newStoredData,\n      isSuccesful: true,\n      amountRemoved,\n      message: \"Removed item where item has more items in its category\",\n    };\n  }\n\n  // the item is the only one in a category (allItemsInThisCategory.length === 1)\n\n  const item = allItemsInThisCategory[0];\n  const category = storedData.find((x) => x.slug === getParentSlug(item));\n  const newStoredDataWithoutItemAndCategory = storedData.filter(\n    (x) => x.slug !== item.slug && x.slug !== getParentSlug(item)\n  );\n\n  if (!category) {\n    // NB: empty categorystack for the item... this means it is a root item, no worries, we did not remove any category, so we don't need to place it back either\n    const amountRemoved =\n      storedData.length - newStoredDataWithoutItemAndCategory.length;\n    return {\n      isSuccesful: true,\n      amountRemoved,\n      message: \"Removed it from the root\",\n      newStoredData: newStoredDataWithoutItemAndCategory,\n    };\n  }\n\n  /** \n  we need to make the category the first item of its parent (or the start of the file)\n  \n  first remove the item and the category, then add it in the right place\n  */\n\n  const parentSlug = getParentSlug(category);\n\n  const parentIndex = newStoredDataWithoutItemAndCategory.findIndex(\n    (x) => x.slug === parentSlug\n  );\n\n  const newItem: Storing<KeyValueMarkdownModelType> = {\n    ...category,\n    isHeaderCalculated: false,\n  };\n\n  if (parentIndex === -1) {\n    // parent doesn't exist. This means the category should become an item at the root of the file\n    const newStoredData = [newItem, ...newStoredDataWithoutItemAndCategory];\n    const amountRemoved = storedData.length - newStoredData.length;\n    return { isSuccesful: true, newStoredData, amountRemoved };\n  }\n\n  // parent exists, so, like I said before, we need to make the category the first item of its parent (or the start of the file)\n\n  const before = newStoredDataWithoutItemAndCategory.slice(0, parentIndex);\n  const after = newStoredDataWithoutItemAndCategory.slice(parentIndex + 1);\n  const parent = newStoredDataWithoutItemAndCategory[parentIndex];\n  const newStoredData = [...before, parent, newItem, ...after];\n\n  const amountRemoved = storedData.length - newStoredData.length;\n  return { newStoredData, isSuccesful: true, amountRemoved };\n}"
  },
  "removeMultiple": {
    "name": "removeMultiple",
    "slug": "TsFunction",
    "id": "pfovjfbunxdcpobplolaecep",
    "description": "Function that lets you remove items from one specific file, for any storage method",
    "operationName": "fs-orm",
    "rawText": " async (\n  dbStorageMethod: DbStorageMethod,\n  dbFileLocation: DbFileLocation,\n  removeWhere: (content: AugmentedAnyModelType) => boolean\n): Promise<DbQueryResult> => {\n  const { absolutePath, modelName, ...modelLocation } = dbFileLocation;\n  const isSingleItemStorageMethod =\n    dbStorageMethod === \"jsonSingle\" || dbStorageMethod === \"markdown\";\n\n  // NB: for single item storage methods, we can simply remove the file\n  if (isSingleItemStorageMethod) {\n    const content = await getAugmentedData<AugmentedAnyModelType>(\n      dbFileLocation,\n      dbStorageMethod\n    );\n    const item = content ? content[0] : null;\n    if (\n      fs.existsSync(dbFileLocation.absolutePath) &&\n      canWriteSync(dbFileLocation.absolutePath) &&\n      item &&\n      removeWhere(item)\n    ) {\n      const res = await fs.rm(dbFileLocation.absolutePath);\n      return { amountRemoved: 1 };\n    }\n\n    return { amountRemoved: 0 };\n  }\n\n  if (dbStorageMethod === \"keyValueMarkdown\") {\n    return alterKeyValueMarkdown(dbFileLocation, (storedData) => {\n      const realStoredData = storedData as Storing<KeyValueMarkdownModelType>[];\n\n      const finalStoredData = realStoredData.reduce((storedDataNow, item) => {\n        const completeItem: KeyValueMarkdownModelType = {\n          ...item,\n          ...modelLocation,\n        };\n\n        if (removeWhere(completeItem)) {\n          // If remove, remove it with all its children\n          const { newStoredData } = removeKeyValueMarkdown(\n            storedDataNow,\n            completeItem.slug\n          );\n          return newStoredData;\n        }\n\n        // Otherwise it stays the same\n        return storedDataNow;\n      }, realStoredData as Storing<KeyValueMarkdownModelType>[]);\n\n      return {\n        newStoredData: finalStoredData,\n        isSuccesful: true,\n        amountRemoved: getLength(storedData) - getLength(finalStoredData),\n      };\n    });\n  }\n\n  // otherwise, we'll remove the item from the array\n  return alterAny(dbStorageMethod, dbFileLocation, (storedData) => {\n    const fullData = storedData.map((item) => ({\n      ...item,\n      ...modelLocation,\n    })) as AugmentedAnyModelType[];\n\n    const newFullData = fullData.filter((item) => {\n      return !removeWhere(item);\n    });\n    const newStoredData = newFullData.map((item) => makeStoringItem(item));\n    const amountRemoved = getLength(storedData) - getLength(newFullData);\n    return {\n      amountRemoved,\n      allRemoved: getLength(newFullData) === 0,\n      newStoredData,\n      isSuccesful: true,\n    };\n  });\n}"
  },
  "upsertItems": {
    "name": "upsertItems",
    "slug": "TsFunction",
    "id": "umdopavhdqamqooiiyfclhep",
    "description": "upsert an item into storage in any storage method",
    "operationName": "fs-orm",
    "rawText": " async <\n  TModels extends AnyModelObject = any,\n  TModelName extends string = any\n>(\n  dbStorageMethod: DbStorageMethod,\n  dbFileLocation: DbFileLocation,\n  storingItems: Storing<TModels[TModelName]> | Storing<TModels[TModelName]>[],\n  onlyInsert?: boolean\n): Promise<DbQueryResult> => {\n  const storingItemsArray = makeArray(storingItems);\n\n  // Special case!\n  // TODO: we don't support multiple items for this case\n  if (dbStorageMethod === \"keyValueMarkdown\") {\n    const storingItem = storingItemsArray[0];\n\n    /**\n     * Convention for KVMD storage!\n     */\n    const parentKey = Object.keys(storingItem).find(\n      (x) => x.startsWith(\"parent_\") && x.endsWith(\"Slug\")\n    );\n    const parentSlug = parentKey ? storingItem[parentKey] : undefined;\n\n    return alterKeyValueMarkdown(dbFileLocation, (storedData) => {\n      // NB: CategoryStack is overwritten! We are first making sure that categoryStack is a real existing categoryStack based on the parent_xxxSlug.\n      const realStoredData = storedData as Storing<KeyValueMarkdownModelType>[];\n      const parent = parentSlug\n        ? realStoredData.find((x) => x.slug === parentSlug)\n        : undefined;\n\n      // NB: we overwrite categoryStack, unless the parentKey wasn't found in the storingItem.\n      const categoryStack: string[] = !parentKey\n        ? storingItem.categoryStack || []\n        : parent\n        ? parent.categoryStack.concat(parent.slug)\n        : [];\n\n      // console.log({ parentKey, parentSlug, parent, categoryStack });\n\n      const realStoringItem = {\n        ...storingItem,\n        categoryStack,\n        isHeaderCalculated:\n          storingItem.isHeaderCalculated !== undefined\n            ? storingItem.isHeaderCalculated\n            : false,\n        comment: storingItem.comment === undefined ? null : storingItem.comment,\n        // convert to unknown first because not every TModels[TModelName] is of type KeyValueMarkdownModelType\n      } as unknown as Storing<KeyValueMarkdownModelType>;\n\n      return upsertKeyValueMarkdown(realStoredData, realStoringItem);\n    });\n  }\n\n  return alterAny(dbStorageMethod, dbFileLocation, (storedData) =>\n    upsert(storedData, storingItemsArray, onlyInsert)\n  );\n}"
  },
  "upsertKeyValueMarkdown": {
    "name": "upsertKeyValueMarkdown",
    "slug": "TsFunction",
    "id": "jhmtjkwchowqsyonqaipmphq",
    "description": "Takes stored data and an item\n\n- updates the data and sets some rows to \"item\" if the item is found (through the slug). this works almost the same as the regular upsert function\n\n- otherwise inserts, at the right category, in the right place in the array\n\nBEWARE:\n\n- the categoryStack must be existing in the markdownfile.\n- you cannot insert a header, always insert an item with `isHeaderCalculated:false`",
    "operationName": "fs-orm",
    "rawText": " (\n  storedData: Storing<KeyValueMarkdownModelType>[],\n  storingItem: Storing<KeyValueMarkdownModelType>\n): DbQueryResult & {\n  newStoredData: Storing<KeyValueMarkdownModelType>[];\n} => {\n  // First case: try to update if the slug is the same\n  let amountUpdated = 0;\n  const updatedData = storedData.map((i) => {\n    const needsUpdate = i.slug === storingItem.slug;\n    if (needsUpdate) {\n      amountUpdated++;\n      // NB: you cannot change something to be a header or not, this is a calculated value\n      return { ...storingItem, isHeaderCalculated: i.isHeaderCalculated };\n    }\n    return i;\n  });\n\n  if (amountUpdated > 0) {\n    return {\n      amountUpdated,\n      amountInserted: 0,\n      newStoredData: updatedData,\n    };\n  }\n\n  // If no \"update\", let's insert\n\n  if (storingItem.isHeaderCalculated) {\n    // Headers cannot be inserted.\n    const errorMessage = `\n      This case is not supported.\n       \nYou cannot insert a header because it will not have any items, which is not what we want.\n\nIf you create items for a parent-item, the parent-item will convert into a header.\n`;\n    log(`upsertKeyValueMarkdown: ${errorMessage}`, {\n      type: \"warning\",\n    });\n\n    return {\n      isSuccesful: false,\n      newStoredData: storedData,\n      amountInserted: 0,\n      amountUpdated: 0,\n      message: errorMessage,\n    };\n  }\n\n  // insert an item\n\n  const parentIndex = storedData.findIndex(\n    (x) => x.slug === getParentSlug(storingItem)\n  );\n  const parent: Storing<KeyValueMarkdownModelType> | undefined =\n    storedData[parentIndex];\n  // If there is no parent, insert it at the start of the file\n  if (!parent) {\n    const newStoredData = [storingItem, ...storedData];\n    return { isSuccesful: true, amountInserted: 1, newStoredData };\n  }\n\n  if (parent.isHeaderCalculated) {\n    /*\n    the parent is a category. in this case, we simply put the item as the first item below that category\n    */\n\n    const newStoredData = insertAt(\n      storedData,\n      makeArray(storingItem),\n      parentIndex + 1\n    );\n\n    return {\n      amountInserted: 1,\n      newStoredData,\n      isSuccesful: true,\n      message: \"Inserted the item in the header parent\",\n    };\n  }\n\n  /**\n           \n  The parent is an item. in this case:\n\n  1) the parent needs to become a category\n  2) the item needs to be placed under it\n  3) the parent should be removed\n  4) the last item that has the same categoryStack as the parent should be found\n  5) This new category with its sole item needs to be placed as the last item value of its parent (below other items, but above sub categories)\n\n  */\n\n  // 1\n  const parentHeader = { ...parent, isHeaderCalculated: true };\n  // 2\n  const newCategory = [parentHeader, storingItem];\n\n  // WORKS console.log({ newCategory });\n  // 3\n  const storedDataWithoutParentItem = removeIndexFromArray(\n    storedData,\n    parentIndex\n  );\n\n  // WORKS console.log({ storedDataWithoutItem });\n\n  // 4\n\n  const finalItemIndex =\n    findLastIndex(\n      storedDataWithoutParentItem,\n      (item) =>\n        item.categoryStack.join(\",\") === parentHeader.categoryStack.join(\",\") &&\n        !item.isHeaderCalculated\n    ) ||\n    // NB: not sure if this would fix all edgecases but if the only item in a category is the one that we removed, the finalItemIndex is the parentIndex -1 (but now it's a category)\n    parentIndex - 1;\n\n  // if (finalItemIndex === undefined) {\n  //   console.log(\"Unsupported Edgecase... \", { storedData, storingItem });\n  //   return {\n  //     newStoredData: storedData,\n  //     amountRemoved: 0,\n  //     amountInserted: 0,\n  //     amountUpdated: 0,\n  //   };\n  // }\n\n  const newStoredData = insertAt(\n    storedDataWithoutParentItem,\n    newCategory,\n    finalItemIndex + 1\n  );\n\n  return {\n    amountUpdated: 1,\n    amountInserted: 1,\n    newStoredData,\n    message: \"Inserted into an item (made that item a category, moved it)\",\n  };\n}"
  },
  "waitForLockfile": {
    "name": "waitForLockfile",
    "slug": "TsFunction",
    "id": "ordeqopospytdyfnalhkpitb",
    "description": "",
    "operationName": "fs-orm",
    "rawText": " async (\n  lockfilePath: string\n): Promise<boolean> => {\n  if (fs.existsSync(lockfilePath)) {\n    const unixDate = await fs.readFile(lockfilePath, \"utf8\");\n    const msAgo = Date.now() - Number(unixDate);\n    if (msAgo < maxQueryTimeSeconds * 1000) {\n      // wait a 100ms!\n      // console.log(\"Waiting for lockfile...\");\n\n      await new Promise<undefined>((resolve) =>\n        setTimeout(() => resolve(undefined), 100)\n      );\n      return waitForLockfile(lockfilePath);\n    }\n\n    // if we get here, the file exists for more than 10 seconds\n\n    console.log(\n      \"Warning: lockfile exists more than ten seconds. I'm assuming the query failed, but this is not good! Should never have such slow queries.\"\n    );\n  }\n\n  await writeStringToFile(lockfilePath, String(Date.now()));\n\n  return true;\n}"
  },
  "validateModel": {
    "name": "validateModel",
    "slug": "TsFunction",
    "id": "ajotrfgpotlwythhfoyytwhg",
    "description": "Validates a model\n- Gets the schema from the `TsInterface` db,\n- Queries all data using `db.get`\n- validate every item that was found against the schema.\n\nIt can return the errors in the model. Maybe it can group errors by count.",
    "operationName": "validate-model",
    "rawText": " async (modelName: keyof DbModels) => {\n  const modelInterface = (await db.get(\"TsInterface\")).find(\n    (x) => x.name === modelName\n  );\n  const simplifiedSchema = modelInterface?.type.simplifiedSchema;\n\n  if (!simplifiedSchema) {\n    log(\"Couldn't find the schema\", { type: \"error\" });\n    return;\n  }\n\n  const items = await db.get(modelName);\n\n  const errors = items\n    .map((item) => {\n      return validate(item as Json, simplifiedSchema);\n    })\n    .filter((x) => !x.isValid);\n\n  return errors;\n}"
  },
  "validate": {
    "name": "validate",
    "slug": "TsFunction",
    "id": "cxvqlpkzwbpagwtxddidpizx",
    "description": "TODO: This function should validate a JSON object against a SimplifiedSchema.",
    "operationName": "validate-model",
    "rawText": " (item: Json, simplifiedSchema: SimplifiedSchema) => {\n  return {\n    isValid: false,\n    errorMessage:\n      \"This is not implemented yet, but your item is definitely invalid\",\n    item,\n  };\n}"
  },
  "getFunctionExecutions": {
    "name": "getFunctionExecutions",
    "slug": "TsFunction",
    "id": "pjaguyhtjjmdolysqbhlpwig",
    "description": "",
    "operationName": "function-functions-node",
    "rawText": " async (\n  functionName: string | undefined\n): Promise<FunctionExecution[]> => {\n  if (!functionName) return [];\n  const functionExecutions = (\n    await db.get(\"FunctionExecution\", {\n      // TODO: ensure executiosn are stored in the right place before I add this back\n      //  operationName: tsFunction.operationName,\n    })\n  )\n    .filter((x) => x.functionName === functionName)\n    .map(omitUndefinedValues);\n\n  return functionExecutions;\n}"
  },
  "getFunctionQueryPaths": {
    "name": "getFunctionQueryPaths",
    "slug": "TsFunction",
    "id": "eadaciyntfyrkszayrbhpvtg",
    "description": "Calculate all required query paths for the function UI menu...\n\n- bundles + main project as root folders (`[\"main project\", ...bundleNames]`)\n- per folder all operations it contains, nested, in the project relative folder where it should be ending up\n- per operation all functions it contains, nested, relative to the src folder. not file, only folders should become menu\n\nExample:\n\n- main\n- modules\n- packages\n- db-ui\n- components\n- `<IndexInstanceContainer>`\n- `<Layout>`\n- `<UpsertForm>`\n- hooks\n- `useGetDbModelQuery`\n- `useReferencableModelDataQuery`\n- pages\n- Page\n- Page\n- Page\n- getPageTitle\n- generated\n- himalayajeep-functions\n- apps\n- bundle A\n- bundle B\n\nNB: if possible, rename the menu items if the items in a folder are not unique (use file-name to replace item name if this happens)",
    "operationName": "function-functions-node",
    "rawText": " async (\n  tsFunctions?: TsFunction[]\n): Promise<{ nested: NestedWebPage[]; flat: WebPage[] }> => {\n  // if you don't provide it, overwrite it from the db\n  tsFunctions =\n    tsFunctions || (await db.get(\"TsFunction\")).filter((x) => x.isExported);\n\n  // TODO: use the `functionQueryPaths` and add the needed ones to main project and every bundle available\n  const bundles = await db.get(\"BundleConfig\");\n\n  // console.log({ tsFunctions });\n\n  const functionQueryPaths: string[] = tsFunctions\n    .map((tsFunction) => {\n      if (!tsFunction.operationName) {\n        console.log(`no name`);\n        return;\n      }\n\n      // part 1: relative path from project root until operation name\n      const operationPath =\n        operations[tsFunction.operationName as keyof typeof operations];\n\n      if (!operationPath) return;\n\n      // part 2: src relative folder path (without file)\n\n      const srcRelativeFolderPath = getSrcRelativeFolderPath(\n        tsFunction.operationRelativeTypescriptFilePath\n      );\n\n      // part 3: name of the function\n      const name = tsFunction.name;\n\n      const queryPath = srcRelativeFolderPath\n        ? `${operationPath}/${srcRelativeFolderPath}/${name}`\n        : `${operationPath}/${name}`;\n\n      return queryPath;\n    })\n    .filter(notEmpty)\n    .sort((a, b) => {\n      if (a < b) return -1;\n      return 1;\n    });\n\n  const flat = functionQueryPaths.map((queryPath) => {\n    const webPage: WebPage = {\n      queryPath,\n      pageData: null,\n    };\n    return webPage;\n  });\n\n  const menuObject = getMenuPagesObject(flat);\n\n  return menuObject;\n}"
  },
  "getPublicBundleConfig": {
    "name": "getPublicBundleConfig",
    "slug": "TsFunction",
    "id": "svspxilgxdqtalnssokkultb",
    "description": "",
    "operationName": "function-functions-node",
    "rawText": " async () => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n  const publicBundleConfigPath = path.join(\n    projectRoot,\n    \"public-bundle-config.json\"\n  );\n\n  const publicBundleConfig = await readJsonFile<PublicBundleConfig>(\n    publicBundleConfigPath\n  );\n\n  if (!publicBundleConfig) {\n    return;\n  }\n  return publicBundleConfig;\n}"
  },
  "getSrcRelativeFolderPath": {
    "name": "getSrcRelativeFolderPath",
    "slug": "TsFunction",
    "id": "vxunbmtuxjbkxinhsfmelvwd",
    "description": "",
    "operationName": "function-functions-node",
    "rawText": " (\n  operationRelativeSourcePath: string\n) => {\n  // 1) remove src/\n  const withouSrc = operationRelativeSourcePath.startsWith(\"src/\")\n    ? operationRelativeSourcePath.slice(\"src/\".length)\n    : undefined;\n\n  const folder = getFolderJs(withouSrc);\n\n  if (folder === \"\") return undefined;\n\n  return folder;\n}"
  },
  "getTsFunction": {
    "name": "getTsFunction",
    "slug": "TsFunction",
    "id": "pitbceawuppssjossqarfmgw",
    "description": "Uses the `sdk-function-paths` sdk to the indexation of any function in the project.",
    "operationName": "function-server-endpoints",
    "rawText": " async (\n  functionName: string\n): Promise<TsFunction | null> => {\n  const tsFunctionPath: string | undefined =\n    sdkFunctionPaths[functionName as keyof typeof sdkFunctionPaths];\n  const projectRoot = getProjectRoot();\n  if (!tsFunctionPath || !projectRoot) {\n    return null;\n  }\n  const absoluteTsFunctionPath = path.join(projectRoot, tsFunctionPath);\n  const tsFunction = await readJsonFile<TsFunction>(absoluteTsFunctionPath);\n\n  return tsFunction;\n}"
  },
  "fitViewOptions": {
    "name": "fitViewOptions",
    "slug": "TsVariable",
    "id": "kowijlymgupweucktudymojk",
    "description": "",
    "operationName": "function-web"
  },
  "Flow": {
    "name": "Flow",
    "slug": "TsFunction",
    "id": "esiltbyaswuawredyrqzpklo",
    "description": "",
    "operationName": "function-web",
    "rawText": " <T extends { [key: string]: any }>(props: {\n  renderNode: (item: T) => JSX.Element;\n  childObject: ChildObject<T>;\n}) => {\n  const { childObject, renderNode } = props;\n\n  //\n\n  // const [nodes, setNodes] = useNodesState<Node[]>(initialNodes);\n  // const [edges, setEdges] = useEdgesState<Edge[]>(initialEdges);\n\n  // const onNodesChange = useCallback(\n  //   (changes: NodeChange[]) =>\n  //     setNodes((nds) => applyNodeChanges(changes, nds)),\n  //   [setNodes]\n  // );\n  // const onEdgesChange = useCallback(\n  //   (changes: EdgeChange[]) =>\n  //     setEdges((eds) => applyEdgeChanges(changes, eds)),\n  //   [setEdges]\n  // );\n  // const onConnect = useCallback(\n  //   (connection: Connection) => setEdges((eds) => addEdge(connection, eds)),\n  //   [setEdges]\n  // );\n\n  const [nodes, setNodes] = useState(initialNodes);\n  const [edges, setEdges] = useState([]);\n\n  const onNodesChange = useCallback(\n    (changes) => setNodes((nds) => applyNodeChanges(changes, nds)),\n    [setNodes]\n  );\n  const onEdgesChange = useCallback(\n    (changes) => setEdges((eds) => applyEdgeChanges(changes, eds)),\n    [setEdges]\n  );\n  const onConnect = useCallback(\n    (connection) => setEdges((eds) => addEdge(connection, eds)),\n    [setEdges]\n  );\n\n  return (\n    <ReactFlow\n      nodes={nodes}\n      edges={edges}\n      onNodesChange={onNodesChange}\n      onEdgesChange={onEdgesChange}\n      onConnect={onConnect}\n      fitView\n      fitViewOptions={fitViewOptions}\n    />\n  );\n}"
  },
  "FormTab": {
    "name": "FormTab",
    "slug": "TsFunction",
    "id": "dskqtkxpojvrraytlgjdmiyv",
    "description": "### Tab 1: Function Form\n\nUses `<FunctionForm>` component\n\nExecutes the function directly or through API (depending on whether or not it is a node-only-function or bare JS)\n\nDon't show this tab for JSX components",
    "operationName": "function-web",
    "rawText": " (props: { tsFunction: TsFunction }) => {\n  const { tsFunction } = props;\n  const [executionId] = useStore(\"executionId\");\n  const [initialValues] = useStore(\"initialValues\");\n  const [resultJson, setResultJson] = useState<{\n    [key: string]: RealApiReturnType<any> | undefined | string;\n  }>({});\n\n  const jsonCodeblock =\n    resultJson[executionId] === undefined\n      ? null\n      : renderMarkdownContent(\n          createCodeblockMarkdown(JSON.stringify(resultJson, null, 2), \"json\"),\n          // NB: since there won't be any assets in here, it doesn't matter where the md is made\n          {\n            projectRelativeBaseFolderPath: \"\",\n            projectRelativeMarkdownFilePath: \"\",\n          }\n        );\n\n  return (\n    <Div>\n      <FunctionForm\n        key={executionId}\n        tsFunction={tsFunction}\n        initialValues={initialValues}\n        submitFunction={\n          undefined\n          // provide this later, for js functions\n        }\n        projectRelativeStorageFilePath=\"\"\n        withApiResult={(result: RealApiReturnType<any> | undefined) => {\n          setResultJson({ ...resultJson, [executionId]: result });\n          if (\n            !result ||\n            typeof result !== \"object\" ||\n            Array.isArray(result) ||\n            result.isSuccessful === undefined\n          ) {\n            infoToast(\"We got no satisfactory result to show you anything\");\n            return;\n          }\n\n          if (result.isSuccessful === false || result.isUnauthorized === true) {\n            errorToast(result.message);\n            return;\n          }\n\n          if (!result.result) {\n            successToast(\n              \"Seems to have gone well, but we don't know how it went\"\n            );\n            return;\n          }\n\n          if (\n            result.result &&\n            typeof result.result === \"object\" &&\n            !Array.isArray(result.result)\n          ) {\n            const maybeSuccessIndicator = result.result.isSuccessful;\n\n            if (maybeSuccessIndicator !== undefined) {\n              const rightToast =\n                maybeSuccessIndicator === true ? successToast : errorToast;\n\n              rightToast(result.result.message);\n\n              return;\n            }\n          }\n\n          return successToast(\"We got a response\");\n        }}\n      />\n      {jsonCodeblock}\n    </Div>\n  );\n}"
  },
  "FunctionExecutionTable": {
    "name": "FunctionExecutionTable",
    "slug": "TsFunction",
    "id": "vyybamoyuhmqafqnoaizvqzb",
    "description": "",
    "operationName": "function-web",
    "rawText": " (props: {\n  tsFunction?: TsFunction;\n  functionExecutions: FunctionExecution[];\n  type: \"example\" | \"test\" | \"recent\";\n}) => {\n  const { functionExecutions, type, tsFunction } = props;\n\n  const [executionId, setExecutionId] = useStore(\"executionId\");\n  const [initialValues, setInitialValues] = useStore(\"initialValues\");\n\n  const [currentTab, setCurrentTab] = useStore(\"tabs.currentTab\");\n  const [loading, setLoading] = useState<{ [id: string]: number | undefined }>(\n    {}\n  );\n\n  const functionExecutionsQuery = queries.useGetFunctionExecutions(\n    tsFunction?.name\n  );\n\n  if (!tsFunction) {\n    return <Div>Hmmm vremd</Div>;\n  }\n\n  const withLoading = async (\n    callback: () => Promise<void>,\n    id: string,\n    actionNumber: number\n  ) => {\n    setLoading((loading) => ({ ...loading, [id]: actionNumber }));\n\n    await callback();\n\n    setLoading((loading) => ({\n      ...loading,\n      [id]: undefined,\n    }));\n  };\n\n  const finalFunctionExecutions =\n    type === \"example\"\n      ? functionExecutions.filter((item: FunctionExecution) => item.isExample)\n      : type === \"test\"\n      ? functionExecutions.filter((item: FunctionExecution) => item.isTest)\n      : functionExecutions\n          .sort((a, b) => (a.createdAt < b.createdAt ? -1 : 1))\n          .slice(0, 100);\n\n  const isDataLoading =\n    functionExecutionsQuery.isRefetching ||\n    functionExecutionsQuery.isFetching ||\n    functionExecutionsQuery.isLoading;\n  return (\n    <>\n      {isDataLoading ? <FancyLoader big /> : null}\n      <Table\n        data={finalFunctionExecutions}\n        columns={[\n          {\n            name: \"Input\",\n            objectParameterKey: \"inputParameters\",\n            customPresentation: (item) => {\n              return (\n                <td>\n                  {item.inputParameters\n                    ? item.inputParameters.map((inputParameter) => {\n                        return (\n                          <Div className=\"border border-black p-2\">\n                            <MarkdownCodeblock\n                              text={\n                                inputParameter\n                                  ? JSON.stringify(inputParameter, undefined, 2)\n                                  : \"undefined\"\n                              }\n                              extension=\"json\"\n                              minimalMode=\"preview\"\n                              expandedMode=\"scroll\"\n                              isInitiallyExpanded={false}\n                            />\n                          </Div>\n                        );\n                      })\n                    : \"No input\"}\n                </td>\n              );\n            },\n          },\n          {\n            name: \"Output\",\n            objectParameterKey: \"output\",\n            customPresentation: (item) => {\n              return (\n                <td>\n                  <MarkdownCodeblock\n                    text={\n                      item.output\n                        ? JSON.stringify(item.output, undefined, 2)\n                        : \"undefined\"\n                    }\n                    extension=\"json\"\n                    minimalMode=\"preview\"\n                    expandedMode=\"scroll\"\n                    isInitiallyExpanded={false}\n                  />\n                </td>\n              );\n            },\n          },\n          {\n            objectParameterKey: \"description\",\n            name: \"Info\",\n            customPresentation: (item) => {\n              return (\n                <td>\n                  {item.description ? (\n                    <MarkdownView\n                      markdownParse={mdToJsonParse(item.description)}\n                      markdownParseRenderConfig={{\n                        projectRelativeBaseFolderPath: \"\",\n                        projectRelativeMarkdownFilePath: \"\",\n                      }}\n                      view=\"view\"\n                    />\n                  ) : (\n                    <Div />\n                  )}\n                </td>\n              );\n            },\n          },\n          {\n            objectParameterKey: \"id\",\n            name: \"Actions\",\n            customPresentation: (item) => {\n              const actions: ActionItem[] = [\n                // make example\n\n                type !== \"example\"\n                  ? {\n                      id: 1,\n                      title: \"Make example\",\n                      emoji: \"ðŸ‘»\",\n                      onClick: async () => {\n                        withLoading(\n                          async () => {\n                            const apiResult = await api.upsertDbModel(\n                              \"FunctionExecution\",\n                              { ...item, isExample: true }\n                            );\n\n                            functionExecutionsQuery.refetch();\n\n                            // console.log({ apiResult });\n                          },\n                          item.id,\n                          1\n                        );\n                      },\n                    }\n                  : undefined,\n\n                // make test\n\n                type !== \"test\"\n                  ? {\n                      id: 2,\n                      title: \"Make test\",\n                      emoji: \"ðŸ”§\",\n                      onClick: async () => {\n                        withLoading(\n                          async () => {\n                            const apiResult = await api.upsertDbModel(\n                              \"FunctionExecution\",\n                              { ...item, isTest: true }\n                            );\n\n                            functionExecutionsQuery.refetch();\n\n                            // console.log({ apiResult });\n                          },\n                          item.id,\n                          2\n                        );\n                      },\n                    }\n                  : undefined,\n\n                // delete (tests and examples)\n                type !== \"recent\"\n                  ? {\n                      id: 3,\n                      title: \"Remove\",\n                      emoji: \"âŒ\",\n                      onClick: async () => {\n                        withLoading(\n                          async () => {\n                            const apiResult = await api.upsertDbModel(\n                              \"FunctionExecution\",\n                              {\n                                ...item,\n                                isExample:\n                                  type === \"example\" ? false : item.isExample,\n                                isTest: type === \"test\" ? false : item.isTest,\n                              }\n                            );\n\n                            functionExecutionsQuery.refetch();\n\n                            // console.log({ apiResult });\n                          },\n                          item.id,\n                          3\n                        );\n                      },\n                    }\n                  : undefined,\n\n                // fill in in form in tab 1\n                {\n                  id: 4,\n                  title: \"Use in form\",\n                  emoji: \"ðŸ“\",\n                  onClick: () => {\n                    // Go to tab\n                    setCurrentTab(1);\n                    setExecutionId(item.id);\n                    setInitialValues(item.inputParameters);\n                  },\n                },\n                // execute directly\n                {\n                  id: 5,\n                  emoji: \"âš¡ï¸\",\n                  title: \"Execute\",\n                  onClick: async () => {\n                    withLoading(\n                      async () => {\n                        const apiFunction = api[\n                          tsFunction.name as keyof typeof api\n                        ] as undefined | ((...parameters: any[]) => any);\n\n                        const apiResult = await apiFunction?.(\n                          ...(item.inputParameters || [])\n                        );\n\n                        functionExecutionsQuery.refetch();\n\n                        // console.log({ apiResult });\n                      },\n                      item.id,\n                      5\n                    );\n                  },\n                },\n              ].filter(notEmpty);\n              return (\n                <td>\n                  {actions.map((action) => {\n                    const isLoading = loading[item.id] === action.id;\n                    return (\n                      <Button\n                        type=\"button\"\n                        onClick={action.onClick}\n                        className=\"hover:bg-blue-500  mr-2 rounded-md p-1\"\n                        textClassName=\"text-xs hover:text-white flex flex-row\"\n                      >\n                        {isLoading ? <FancyLoader /> : \"\"}\n                        <P>\n                          {action.emoji} {action.title}\n                        </P>\n                      </Button>\n                    );\n                  })}\n                </td>\n              );\n            },\n          },\n        ]}\n      />\n    </>\n  );\n}"
  },
  "FunctionPage": {
    "name": "FunctionPage",
    "slug": "TsFunction",
    "id": "bukifmheukpiplbndodoprjf",
    "description": "",
    "operationName": "function-web",
    "rawText": " () => {\n  const router = useRouter();\n\n  const fullPath = router.query.paths ? makeArray(router.query.paths) : [];\n\n  const functionName = fullPath.pop();\n  const queryPath = getQueryPath(router.query);\n\n  const tsFunctionQuery = queries.useGetTsFunction(functionName);\n  // todo : add query to tsFunction\n  const { tsFunction } = destructureOptionalObject(\n    tsFunctionQuery.data?.result\n  );\n\n  const functionExecutions =\n    queries.useGetFunctionExecutions(functionName).data?.result || [];\n\n  const renderNavigation = () => {\n    return (\n      <Div className=\"flex flex-row justify-between\">\n        {queryPath.length > 1 ? (\n          <ClickableIcon\n            emoji=\"â¬…\"\n            onClick={() => {\n              const parts = queryPath.split(\"/\");\n              parts.pop();\n              const oneFolderUp = parts.join(\"/\");\n              router.push(oneFolderUp.length === 0 ? \"/\" : oneFolderUp);\n            }}\n          />\n        ) : null}\n        <P className=\"text-3xl\">{functionName}</P>\n        <Div />\n      </Div>\n    );\n  };\n\n  const renderPage = () => {\n    if (!tsFunction) {\n      return tsFunctionQuery.isLoading ? (\n        <FancyLoader big />\n      ) : (\n        <P>Select a function to get to work</P>\n      );\n    }\n\n    /**\n  ### Tab 7: Recent executions tab\n  \n  `FunctionExecution[].sort(createdAt).slice(0,100)`\n  \n  Actions for every item:\n  \n  - set `isTest` to true\n  - set `isExample` to true\n  - fill in in form in tab 1\n  - execute directly\n  \n     */\n    const recentTab = {\n      title: \"Recent\",\n      emoji: \"ðŸ•°ï¸\",\n      renderTab: () => {\n        return (\n          <FunctionExecutionTable\n            tsFunction={tsFunction}\n            type={\"recent\"}\n            functionExecutions={functionExecutions}\n          />\n        );\n      },\n    };\n\n    const formTab = {\n      title: \"Form\",\n      emoji: \"ðŸ“\",\n      renderTab: () => <FormTab tsFunction={tsFunction} />,\n    };\n\n    /** \n  ### Tab 2: Function Docs\n\n  Generate on the fly based on the `TsFunction` (extrahere from docs generation lib)\n\n  */\n    const docsTab = {\n      title: \"Docs\",\n      emoji: \"â„¹ï¸\",\n      renderTab: () => {\n        return (\n          <>\n            <P className=\"text-xl lg:text-4xl w-full\">\n              &nbsp;&nbsp;{tsFunction?.name}\n            </P>\n\n            {tsFunction?.description ? (\n              // TODO: use `props.functionData.tsFunction.operationRelativeTypescriptFilePath` to deterimne markdown file path and folder\n\n              <Div>\n                <MarkdownView\n                  markdownParse={mdToJsonParse(tsFunction.description)}\n                  markdownParseRenderConfig={{\n                    projectRelativeMarkdownFilePath: \"\",\n                    projectRelativeBaseFolderPath: \"\",\n                  }}\n                  view=\"view\"\n                />\n              </Div>\n            ) : null}\n          </>\n        );\n      },\n    };\n\n    /**\n     * TAB 3: Code\n     *\n     * TODO: Can later be replaced with the writer-input for the file of the function, so you can immediately see your coding result in the other tabs...\n     */\n    const codeTab = {\n      title: \"Code\",\n      emoji: \"ðŸ’»\",\n      renderTab: () => {\n        return tsFunction?.rawText ? (\n          <Div className=\"flex flex-col items-center\">\n            <MarkdownCodeblock\n              text={`const ${tsFunction.name} =${tsFunction.rawText}`}\n              extension=\"ts\"\n              isModeStatic\n              minimalMode=\"full\"\n            />\n\n            <Div className=\"flex flex-col items-center pt-8 gap gap-6\">\n              <P>Wanna start?</P>\n\n              <BigButton\n                title=\"Open in VSCode\"\n                onClick={async () => {\n                  if (!tsFunction.operationName) {\n                    errorToast(\n                      \"Couldn't find which operation this function belongs to, can't open the file\"\n                    );\n                    return;\n                  }\n\n                  const result = await api.vscodeOpen({\n                    files: [\n                      {\n                        operationName: tsFunction.operationName,\n                        operationRelativeFilePath:\n                          tsFunction.operationRelativeTypescriptFilePath,\n                      },\n                    ],\n                  });\n\n                  return;\n                }}\n                emoji=\"ðŸ‘¨â€ðŸ’»\"\n              />\n            </Div>\n          </Div>\n        ) : (\n          \"Code not found\"\n        );\n      },\n    };\n\n    /**\n            ### Tab 4: Exersize tab\n\n            Get all examples of this function, write exersize in markdown (ask Wijnand for more details)\n            */\n\n    const exersizeTab = {\n      title: \"Exersizes\",\n      emoji: \"ðŸ‘¶\",\n      renderTab: () => {\n        return \"ex\";\n      },\n    };\n\n    /**\n### Tab 5: Examples Tab\n\n`FunctionExecution[].filter(x.isExample)`\n\nShow `x.exampleDescription` too (markdown)\n\nActions for every item:\n\n- set `isExample` to false\n- set `isTest` to true\n- fill in in form in tab 1\n- execute directly\n\n*/\n\n    const examplesTab = {\n      title: \"Examples\",\n      emoji: \"ðŸ‘»\",\n      renderTab: () => {\n        return (\n          <FunctionExecutionTable\n            tsFunction={tsFunction}\n            type={\"example\"}\n            functionExecutions={functionExecutions}\n          />\n        );\n      },\n    };\n\n    /**\n### Tab 6: Tests Tab\n\n`FunctionExecution[].filter(x.isTest))`\n\nActions for every item:\n\n- set `isTest` to false\n- set `isExample` to true\n- fill in in form in tab 1\n- execute directly\n*/\n\n    const testsTab = {\n      title: \"Tests\",\n      emoji: \"ðŸ”§\",\n      renderTab: () => {\n        return (\n          <FunctionExecutionTable\n            tsFunction={tsFunction}\n            type={\"test\"}\n            functionExecutions={functionExecutions}\n          />\n        );\n      },\n    };\n\n    const dataTab = {\n      title: \"Data\",\n      emoji: \"ðŸ’¿\",\n      renderTab: () => {\n        return \"This tab can later show the models that are put under in the doc-comment as being relevant. E.g. if you put 'DATA: JeepType, LocationType' in your function's doc-comment, it would show the CRUD-UI for those models in this tab. Possibly, one tab for every model, or simply one tab for all models and visually make it disabled if there is no data connected to the function...\";\n      },\n    };\n\n    const mediaTab = {\n      title: \"Media\",\n      emoji: \"ðŸ‘¥\",\n      renderTab: () => {\n        return (\n          <Div>\n            <Ul>\n              <Li>Show related postables & media-posts</Li>\n              <Li>Create new postable</Li>\n              <Li>\n                Basically, the social-media-ui but just focussed on this\n                function\n              </Li>\n            </Ul>\n          </Div>\n        );\n      },\n    };\n\n    const treeTab = {\n      title: \"Trees\",\n      emoji: \"ðŸŒ³\",\n      renderTab: () => {\n        return (\n          <Div className=\"w-max h-80\">\n            <Ul>\n              <Li>\n                Show graph with the function in the middle, below all functions\n                that are required for the function (dependencies), above all the\n                functions that require this function (dependents)\n              </Li>\n              <Li>\n                Being able to see this multiple multiple layers deep would be\n                great (configurable).\n              </Li>\n              <Li>\n                Dependencies must be brown (root like) while dependents (up)\n                must be green (leave like)\n              </Li>\n              <Li>\n                Other tree: find other functions that take the output type of\n                this function as its input. Use the output of your\n                FunctionExecutions on \"related\" functions.\n              </Li>\n            </Ul>\n\n            <Test />\n          </Div>\n        );\n      },\n    };\n    return (\n      <Div>\n        {renderNavigation()}\n\n        <Tabs\n          tabs={[\n            codeTab,\n            formTab,\n            //dataTab,\n            recentTab,\n            testsTab,\n            examplesTab,\n            docsTab,\n            //treeTab,\n            //exersizeTab,\n            //mediaTab,\n          ]}\n        />\n      </Div>\n    );\n  };\n\n  return (\n    <Div className=\"pb-4 px-4 w-full\" scroll>\n      {renderPage()}\n    </Div>\n  );\n}"
  },
  "functionWebInitialValues": {
    "name": "functionWebInitialValues",
    "slug": "TsVariable",
    "id": "yfaepwenbnqcflmozhpmlmjr",
    "description": "",
    "operationName": "function-web"
  },
  "initialEdges": {
    "name": "initialEdges",
    "slug": "TsVariable",
    "id": "czmxlpomvqtkodrbguibrdix",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "initialNodes": {
    "name": "initialNodes",
    "slug": "TsVariable",
    "id": "zkcamhjcasbiowzhfkalpgzh",
    "description": "In order to make columns,",
    "operationName": "passionfruit-ui"
  },
  "initialValues": {
    "name": "initialValues",
    "slug": "TsVariable",
    "id": "enypdsmlehzdrmrubopoqxen",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "Test": {
    "name": "Test",
    "slug": "TsFunction",
    "id": "fxdmkxgkemwcrovxxjxngulm",
    "description": "",
    "operationName": "social-media-web",
    "rawText": "export default function Test() {\n  return <h1>this test</h1>;\n}"
  },
  "ShowSize": {
    "name": "ShowSize",
    "slug": "TsFunction",
    "id": "vypbupltfanbvoxpiopekncq",
    "description": "",
    "operationName": "project-size-web",
    "rawText": " (props: { path: string }) => {\n  const { path } = props;\n\n  const renderFolderRecurisve = (\n    item: ChildObject<{\n      size: number;\n      name: string;\n    }>\n  ) => {\n    const size = Math.ceil(item.size / 102400) / 10;\n    return size < 2 ? null : (\n      <Div style={{ width: size * 100 }} className=\"border border-black m-2\">\n        <P>\n          {item.name} ({size} mb)\n        </P>\n        {item.children?.map(renderFolderRecurisve)}\n      </Div>\n    );\n  };\n\n  const items = queries.useGetFolderSizeObject(path)?.data?.result;\n\n  return items ? (\n    <Div className=\"flex flex-row\">\n      {items.map((item) => renderFolderRecurisve(item))}\n    </Div>\n  ) : null;\n}"
  },
  "cache": {
    "name": "cache",
    "slug": "TsVariable",
    "id": "lzqjvavrfyctprihfvotirbi",
    "description": "",
    "operationName": "augmented-word-node"
  },
  "getAugmentedWordObject": {
    "name": "getAugmentedWordObject",
    "slug": "TsFunction",
    "id": "vivvdhjqpflzpygsimhbprun",
    "description": "",
    "operationName": "augmented-word-node",
    "rawText": " async (\n  manualProjectRoot?: string\n): Promise<MappedObject<AugmentedWord> | undefined> => {\n  const projectRoot = manualProjectRoot || getProjectRoot();\n\n  if (!projectRoot) return;\n\n  if (cache) return cache;\n\n  const augmentedWordsSerializable = (await getAugmentedWords(projectRoot)).map(\n    (item) => omitUndefinedValues(item)\n  );\n\n  const mappedObject = createMappedObject(augmentedWordsSerializable, \"word\");\n\n  cache = mappedObject;\n  return mappedObject;\n}"
  },
  "getAugmentedWords": {
    "name": "getAugmentedWords",
    "slug": "TsFunction",
    "id": "ufftkvvqdbkfvwdwacrhyiow",
    "description": "Gets all augmented words of the entire project\n\n- functions, interfaces, variables, operations (`/[operation-path]#name`)\n- if this is an OS-project, also bundles (`/[docs-path]`)",
    "operationName": "augmented-word-node",
    "rawText": " async (\n  manualProjectRoot?: string\n): Promise<AugmentedWord[]> => {\n  const projectRoot = manualProjectRoot || getProjectRoot();\n\n  if (!projectRoot) return [];\n\n  const operations = await db.get(\"Operation\");\n\n  const operationAugmentedWords: AugmentedWord[] = operations\n    .map((item) => {\n      const itemLocationPath = path.join(projectRoot, item.projectRelativePath);\n      const operationPath = findOperationBasePath(itemLocationPath);\n      if (!operationPath) return;\n\n      const description = item.operation?.markdown || item.description;\n\n      const augmentedWord: AugmentedWord = {\n        queryPath: makeRelative(operationPath, projectRoot),\n        spoiler: description,\n        type: \"operation\",\n        word: item.name,\n        // NB: OperationConfig is located in operation basePath\n        projectRelativeMarkdownSourcePath: path.join(\n          operationPath,\n          \"OPERATION.md\"\n        ),\n      };\n\n      return augmentedWord;\n    })\n    .filter(notEmpty);\n\n  const tsVariables = await db.get(\"TsVariable\", {\n    manualProjectRoot: projectRoot,\n  });\n\n  const tsFunctions = await db.get(\"TsFunction\", {\n    manualProjectRoot: projectRoot,\n  });\n  const tsInterfaces = await db.get(\"TsInterface\", {\n    manualProjectRoot: projectRoot,\n  });\n\n  const interfaceAugmentedWords: AugmentedWord[] = tsInterfaces\n    .map((item) => {\n      // NB: TODO: figure out of this is always correct, this path must exist!\n      const itemLocationPath = path.join(projectRoot, item.projectRelativePath);\n      const operationPath = findOperationBasePath(itemLocationPath);\n      if (!operationPath) return;\n\n      const projectRelativeOperationPath = makeRelative(\n        operationPath,\n        projectRoot\n      );\n\n      const augmentedWord: AugmentedWord = {\n        queryPath: `${projectRelativeOperationPath}#${getImplicitId(\n          item.name\n        )}`,\n        spoiler: item.description,\n        type: \"type\",\n        word: item.name,\n        projectRelativeMarkdownSourcePath: item.projectRelativePath,\n      };\n\n      return augmentedWord;\n    })\n    .filter(notEmpty);\n\n  const functionAugmentedWords: AugmentedWord[] = tsFunctions\n    .map((item) => {\n      // NB: TODO: figure out of this is always correct, this path must exist!\n      const itemLocationPath = path.join(projectRoot, item.projectRelativePath);\n      const operationPath = findOperationBasePath(itemLocationPath);\n      if (!operationPath) return;\n\n      const projectRelativeOperationPath = makeRelative(\n        operationPath,\n        projectRoot\n      );\n\n      const augmentedWord: AugmentedWord = {\n        queryPath: `${projectRelativeOperationPath}#${getImplicitId(\n          item.name\n        )}`,\n        spoiler: item.description,\n        type: \"function\",\n        word: item.name,\n        projectRelativeMarkdownSourcePath: item.projectRelativePath,\n      };\n\n      return augmentedWord;\n    })\n    .filter(notEmpty);\n\n  const variableAugmentedWords: AugmentedWord[] = tsVariables\n    .map((item) => {\n      // NB: TODO: figure out of this is always correct, this path must exist!\n      const itemLocationPath = path.join(projectRoot, item.projectRelativePath);\n      const operationPath = findOperationBasePath(itemLocationPath);\n      if (!operationPath) return;\n\n      const projectRelativeOperationPath = makeRelative(\n        operationPath,\n        projectRoot\n      );\n\n      const augmentedWord: AugmentedWord = {\n        queryPath: `${projectRelativeOperationPath}#${getImplicitId(\n          item.name\n        )}`,\n        spoiler: item.description,\n        type: \"variable\",\n        word: item.name,\n        projectRelativeMarkdownSourcePath: item.projectRelativePath,\n      };\n\n      return augmentedWord;\n    })\n    .filter(notEmpty);\n\n  const bundleAugmentedWords: AugmentedWord[] | undefined = isBundle(\n    projectRoot\n  )\n    ? undefined\n    : await getBundleAugmentedWords();\n\n  const allAugmentedWords: AugmentedWord[] = [\n    bundleAugmentedWords,\n    operationAugmentedWords,\n    variableAugmentedWords,\n    functionAugmentedWords,\n    interfaceAugmentedWords,\n  ]\n    .filter(notEmpty)\n    .flat();\n\n  return allAugmentedWords;\n}"
  },
  "getBundleAugmentedWords": {
    "name": "getBundleAugmentedWords",
    "slug": "TsFunction",
    "id": "rnltomxkhuqlagrcoddxosgf",
    "description": "NB: should only be executed if this is not a sensible-project, as it might not have `BundleConfig` otherwise",
    "operationName": "augmented-word-node",
    "rawText": " async (): Promise<AugmentedWord[]> => {\n  // NB: we need to cast the string because in OS-projects this might otherwise fail\n  const bundles: AugmentedAnyModelType[] = await db.get(\n    \"BundleConfig\" as keyof DbModels\n  );\n\n  const bundleAugmentedWords: AugmentedWord[] = bundles.map((bundle) => {\n    const augmentedWord: AugmentedWord = {\n      queryPath: bundle.docsRelativeFolderPath,\n      spoiler: bundle.description,\n      type: \"bundle\",\n      word: bundle.slug,\n      projectRelativeMarkdownSourcePath: bundle.projectRelativePath,\n    };\n\n    return augmentedWord;\n  });\n\n  return bundleAugmentedWords;\n}"
  },
  "codestoriesGetPages": {
    "name": "codestoriesGetPages",
    "slug": "TsFunction",
    "id": "ommdlyphfswtyakpeiylkpgg",
    "description": "",
    "operationName": "codestorys-node",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n}): Promise<undefined | ReaderWebPage[]> => {\n  const projectRoot = config?.manualProjectRoot || getProjectRoot();\n  if (!projectRoot) return;\n\n  const projectRelativePaths = await getProjectRelativePaths();\n\n  const codestoriesPaths =\n    projectRelativePaths?.filter((x) => x.endsWith(\".codestory.md\")) || [];\n\n  const pages: ReaderWebPage[] = (\n    await Promise.all(\n      codestoriesPaths.map(async (projectRelativeFilePath) => {\n        const absolutePath = path.join(projectRoot, projectRelativeFilePath);\n        const markdownCallToActions: any[] = [];\n        const webMarkdownFile: WebMarkdownFile | null = fs.existsSync(\n          absolutePath\n        )\n          ? await readMarkdownFileToModel(\n              absolutePath,\n              \"codestorys-web\",\n              markdownCallToActions\n            )\n          : null;\n        if (!webMarkdownFile) return;\n\n        const readerWebPage: ReaderWebPage = {\n          pageData: {\n            projectRelativeFilePath,\n            imagePath:\n              webMarkdownFile.headerImage?.absoluteUrl ||\n              webMarkdownFile.headerImage?.relativePath ||\n              null,\n            shortDescription: webMarkdownFile?.headerSubTitle || null,\n            introDescription: webMarkdownFile?.markdown,\n          },\n          queryPath: projectRelativeFilePath.replaceAll(\"/\", \"-\"),\n          isMenuHidden: false,\n          menuTitle:\n            webMarkdownFile?.headerTitle ||\n            webMarkdownFile?.name ||\n            path.parse(projectRelativeFilePath).name,\n        };\n        return readerWebPage;\n      })\n    )\n  ).filter(notEmpty);\n\n  const filteredPages = pages.filter(\n    onlyUnique2<ReaderWebPage>((a, b) => a.queryPath === b.queryPath)\n  );\n\n  return filteredPages;\n}"
  },
  "codestoriesGetStaticPaths": {
    "name": "codestoriesGetStaticPaths",
    "slug": "TsFunction",
    "id": "tkxaeealkcuudcvqmmunorzz",
    "description": "Function that tells Next.js what the pages are that need to be statically generated",
    "operationName": "codestorys-node",
    "rawText": " async (\n  context: GetStaticPathsContext\n) => {\n  const queryPaths = ((await codestoriesGetPages()) || []).map(\n    (x) => x.queryPath\n  );\n\n  // console.log({ paths });\n  if (!queryPaths) {\n    return { paths: [], fallback: \"blocking\" };\n  }\n\n  const staticPaths = queryPaths\n    .filter((x) => x !== \"\")\n    .map((p) => ({ params: { paths: p.split(\"/\") } }));\n\n  return {\n    paths: staticPaths,\n    fallback: \"blocking\",\n  };\n}"
  },
  "codestoriesGetStaticProps": {
    "name": "codestoriesGetStaticProps",
    "slug": "TsFunction",
    "id": "letdadkbcknhobkikiciddbh",
    "description": "",
    "operationName": "codestorys-node",
    "rawText": " async (\n  context: GetStaticPropsContext\n): Promise<{\n  props: MarkdownReaderPageProps;\n}> => {\n  const flat = (await codestoriesGetPages()) || [];\n  return markdownReaderGetStaticPropsFromPages(context, flat, \"codestorys-web\");\n}"
  },
  "HomePage": {
    "name": "HomePage",
    "slug": "TsFunction",
    "id": "lfrqxsvxkuhhggxdayphropx",
    "description": "",
    "operationName": "search-web",
    "rawText": " (props: QueryPageProps) => {\n  const { imagePaths } = props;\n\n  const hour = new Date(Date.now()).getHours();\n  const quote = quotes[hour % quotes.length];\n  const imagePath = imagePaths[hour % imagePaths.length];\n  const [mindspace, setMindspace] = useState(mindspaces[0]);\n  const [mouseDown, setMouseDown] = useState(false);\n  const [mouseDownTimeout, setMouseDownTimeout] =\n    useState<NodeJS.Timeout | null>(null);\n\n  const yourName = \"King ðŸ¤´\";\n  const yourLocation = \"Napoli ðŸ‡®ðŸ‡¹\";\n  const dayPart = \"day\";\n\n  return (\n    <Div className=\"\">\n      <Timeline\n        items={[\n          {\n            imageUrl: `headers/${imagePath}`,\n            component: () => {\n              return (\n                <Div\n                  className=\"flex flex-1 min-h-screen items-center flex-col justify-around\"\n                  // style={{ background: `url(${imagePath})` }}\n                >\n                  <Div\n                    className=\"text-3xl text-white drop-shadow cursor-grab\"\n                    onMouseDown={(e) => {\n                      const timeout = setTimeout(() => {\n                        setMouseDown(true);\n                      }, 200);\n                      setMouseDownTimeout(timeout);\n                    }}\n                    onMouseUp={(e) => {\n                      if (mouseDownTimeout) {\n                        clearTimeout(mouseDownTimeout);\n                      }\n                      setMouseDown(false);\n                    }}\n                    onClick={(e) => {\n                      e.preventDefault();\n                      setMindspace(pickRandomArrayItem(mindspaces));\n                    }}\n                  >\n                    Good{\" \"}\n                    {mouseDown ? `${dayPart} in ${yourLocation}` : mindspace},{\" \"}\n                    {yourName}\n                  </Div>\n\n                  <Div className=\"italic text-white\">{quote}</Div>\n                  <SearchBar placeholder={mindspace} />\n                  <Div className=\"max-w-xl\">\n                    <AppsMenu />\n                  </Div>\n                </Div>\n              );\n            },\n          },\n          {\n            markdown: `I see dead people`,\n          },\n          ...props.timelineItems?.map((x) => {\n            return {\n              markdown: x.comment,\n              projectRelativeFilePath: x.filePath,\n              line: x.line,\n            };\n          }),\n        ]}\n      />\n    </Div>\n  );\n}"
  },
  "Layout": {
    "name": "Layout",
    "slug": "TsFunction",
    "id": "bhnnmvapvfjcxswkkytturif",
    "description": "",
    "operationName": "himalayajeep-ui",
    "rawText": " ({ children }: { children: any }) => {\n  const router = useRouter();\n\n  const [loginToken, setLoginToken] = useStore(\"api.loginToken\");\n  const isLoggedIn = loginToken.length > 0;\n\n  return (\n    <Div className=\"h-screen grid grid-rows-6\">\n      <Div className=\"row-span-6 grid grid-cols-5\">\n        <Div\n          className={`\n        col-span-4 overflow-y-auto bg-gray-50 dark:bg-gray-900 dark:text-white`}\n          textClassName=\"dark:text-white\"\n        >\n          {children}\n        </Div>\n        <Span className=\"border-l col-span-1 overflow-y-auto bg-gray-50 dark:bg-gray-900 dark:text-white border-l-gray-400\">\n          {[\n            {\n              path: \"/\",\n              title: \"ðŸ—º Home\",\n            },\n\n            {\n              path: \"/driver-signup\",\n              title: \"âœ¨ Driver Signup\",\n              isVisible: !isLoggedIn,\n            },\n            {\n              path: \"/jeep-list\",\n              title: \"ðŸ›» Jeep list\",\n            },\n            {\n              path: \"/login\",\n              title: \"ðŸ° Login\",\n              isVisible: !isLoggedIn,\n            },\n\n            {\n              path: \"/edit-profile\",\n              title: \"ðŸ“ Edit profile\",\n              isVisible: isLoggedIn,\n            },\n            {\n              onClick: () => setLoginToken(\"\"),\n              title: \"ðŸšª Logout\",\n              isVisible: isLoggedIn,\n            },\n          ].map((item, index) => {\n            if (item.isVisible === false) {\n              return null;\n            }\n            return (\n              <MenuItem\n                key={`menu${index}`}\n                onClick={async () => {\n                  await item.onClick?.();\n                  if (item.path) {\n                    router.push(item.path);\n                  }\n                }}\n              >\n                {item.title}\n              </MenuItem>\n            );\n          })}\n        </Span>\n      </Div>\n    </Div>\n  );\n}"
  },
  "availableExtensions": {
    "name": "availableExtensions",
    "slug": "TsVariable",
    "id": "hwcjlpxpapdlyjuncvipkcnb",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "copyStaticAssetsCli": {
    "name": "copyStaticAssetsCli",
    "slug": "TsFunction",
    "id": "ogdcgdvhevjjasyqiieoyoxp",
    "description": "",
    "operationName": "markdown-reader-functions",
    "rawText": " async () => {\n  const markdownReaderPages = await getAllMarkdownReaderPages();\n\n  if (!markdownReaderPages) return;\n  const isSuccessful = await copyStaticAssets(markdownReaderPages);\n\n  console.log({ isSuccessful });\n}"
  },
  "copyStaticAssets": {
    "name": "copyStaticAssets",
    "slug": "TsFunction",
    "id": "inkztnjnynfavtmifloiqhlc",
    "description": "uses `getMarkdownReferencePaths` for all markdown files in the `markdown-reader-ui` and copies them into the `markdown-reader-web/public` folder, keeping the original folder structure.\n\nNB: Removes all files in the public folder first.\n\nTo get a file from public assets after running this function, you need to get it from the `projectRelativeFilePath`, not the file relative, so you need to render it differently.",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  readerWebPages: ReaderWebPage[],\n  config?: {\n    /**\n     * by default, uses `markdown-reader-web`\n     */\n    operationName?: string;\n  }\n): Promise<boolean | undefined> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n\n  const nextWebFolder = await getOperationPath(\n    config?.operationName || \"markdown-reader-web\"\n  );\n\n  if (!nextWebFolder) return;\n\n  const referencePathsPromises = readerWebPages.map(async (page) => {\n    if (!page.pageData.projectRelativeFilePath) return;\n    const absoluteMarkdownFilePath = path.join(\n      projectRoot,\n      page.pageData.projectRelativeFilePath\n    );\n    const markdownString = await fs.readFile(absoluteMarkdownFilePath, \"utf8\");\n    const referencePaths = getMarkdownReferencePaths(markdownString);\n    return referencePaths;\n  });\n\n  const absoluteReferencePaths = (await Promise.all(referencePathsPromises))\n    .filter(notEmpty)\n    .flat()\n    .filter(onlyUnique2());\n\n  const projectRelativeReferencePaths = absoluteReferencePaths.map((x) =>\n    makeRelative(x, projectRoot)\n  );\n\n  const publicAssetsFolder = path.join(nextWebFolder, \"public\");\n\n  const removed = await removeAllExcept(publicAssetsFolder);\n\n  const isSuccessful = await copyAllRelativeFiles(\n    projectRelativeReferencePaths,\n    projectRoot,\n    publicAssetsFolder\n  );\n\n  return isSuccessful;\n}"
  },
  "docsGetPages": {
    "name": "docsGetPages",
    "slug": "TsFunction",
    "id": "bwmfmcburexhdckpclmgefoe",
    "description": "",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  basePaths: { projectRelativeBasePath: string; queryPath: string }[]\n) => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return [];\n  }\n\n  const realProjectRelativeBasePaths = isBundle()\n    ? [\"docs\"]\n    : basePaths.map((x) => x.projectRelativeBasePath);\n\n  const absoluteBasePaths = realProjectRelativeBasePaths.map((x) =>\n    path.join(projectRoot, x)\n  );\n\n  const flat =\n    (await getMarkdownReaderPages({\n      projectRoot,\n      basePaths: absoluteBasePaths,\n      mapQueryPath: (queryPath) => {\n        const found = realProjectRelativeBasePaths.find((x) =>\n          queryPath.startsWith(x)\n        );\n        if (!found) {\n          return queryPath;\n        }\n        const prefix = basePaths.find(\n          (x) => x.projectRelativeBasePath === found\n        );\n\n        if (!prefix) {\n          return queryPath;\n        }\n\n        const newQueryPath = queryPath.replace(\n          prefix.projectRelativeBasePath,\n          prefix.queryPath\n        );\n\n        return newQueryPath;\n      },\n    })) || [];\n\n  return flat;\n}"
  },
  "docsGetStaticPaths": {
    "name": "docsGetStaticPaths",
    "slug": "TsFunction",
    "id": "aaruqvvbwhktecnwhpvhfyzi",
    "description": "Function that tells Next.js what the pages are that need to be statically generated",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  context: GetStaticPathsContext,\n  basePaths: { projectRelativeBasePath: string; queryPath: string }[]\n): Promise<GetStaticPathsResult> => {\n  const paths: string[] | undefined = (await docsGetPages(basePaths)).map(\n    (x) => x.queryPath\n  );\n\n  // console.log({ paths });\n  if (!paths) {\n    return { paths: [], fallback: \"blocking\" };\n  }\n\n  const staticPaths = paths\n    .filter((x) => x !== \"\")\n    .map((p) => ({ params: { paths: p.split(\"/\") } }));\n\n  return {\n    paths: staticPaths,\n    fallback: \"blocking\",\n  };\n}"
  },
  "docsGetStaticProps": {
    "name": "docsGetStaticProps",
    "slug": "TsFunction",
    "id": "gmfsonangshwfwhnfmqjhtuq",
    "description": "",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  context: GetStaticPropsContext,\n  basePaths: {\n    projectRelativeBasePath: string;\n    queryPath: string;\n  }[],\n  /**\n   * Operation of the website that is going to be deployed\n   */\n  webOperationName: string\n): Promise<{\n  props: MarkdownReaderPageProps;\n}> => {\n  const flat = await docsGetPages(basePaths);\n  const propsObject = await markdownReaderGetStaticPropsFromPages(\n    context,\n    flat,\n    webOperationName\n  );\n  return propsObject;\n}"
  },
  "getAllMarkdownReaderPages": {
    "name": "getAllMarkdownReaderPages",
    "slug": "TsFunction",
    "id": "yhupxslyrxpgjsrljeqjvebm",
    "description": "....? I should've commented this\n\nconst hasDocs = !!relativeDocsPages.find(\n\n(x) => x.queryPath.toLowerCase() === \"docs/readme\"\n\n);\n\nif (!hasDocs) {\n\nconst hasRootReadme = fs.existsSync(path.join(projectRoot, \"README.md\"));\n\nif (hasRootReadme) {\n\nrelativeDocsPages.unshift({\n\nqueryPath: \"docs/readme\",\n\nfilePath: \"README.md\",\n\nisMenuItem: true,\n\n});\n\n}\n\n}\n\nGets all pages of a bundle based on the fs and database\n\nPages it finds:\n\n- operation-readmes\n- multiple docs basePaths with all folders and markdown pages there in (`/[project-relative-path]`)\n- `/dictionary`\n- all markdown model types we have in the db-sdk, optionally, depending on config\n\nRequirements:\n\n- README should always be on top in a folder.\n- numbers and extensions are omitted from paths, but still connected to the right file\n- If the docs doesn't have a readme, the /docs/readme path shows the root readme.\n\nDoes not include AugmentedWord. Just the main pages, not with queries and hashes\n\nUsed to generate the menu",
    "operationName": "markdown-reader-functions",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n}): Promise<undefined | WebPage<any>[]> => {\n  const projectRoot = config?.manualProjectRoot || getProjectRoot();\n  if (!projectRoot) return;\n\n  const publicBundleConfig = await readJsonFile<PublicBundleConfig>(\n    path.join(projectRoot, \"public-bundle-config.json\")\n  );\n\n  const bundleMarkdownReaderConfig =\n    publicBundleConfig?.bundleMarkdownReaderConfig;\n\n  // the docs folder with all its files\n  const docsPaths = await findAllDocsFolderPaths(true);\n\n  const customOperationDocsPaths =\n    bundleMarkdownReaderConfig?.customOperationNames\n      ?.map((operationName) => {\n        const relativeOperationPath =\n          operations[operationName as keyof typeof operations];\n        if (!relativeOperationPath) return;\n        const absoluteDocsPath = path.join(\n          projectRoot,\n          relativeOperationPath,\n          \"docs\"\n        );\n        if (!fs.existsSync(absoluteDocsPath)) return;\n        return {\n          absoluteDocsPath,\n          queryPath: bundleMarkdownReaderConfig?.docsInRoot\n            ? operationName\n            : `docs/${operationName}`,\n        };\n      })\n      .filter(notEmpty) || [];\n\n  const customOperationDocsPages: ReaderWebPage[] =\n    await getMarkdownReaderPages({\n      projectRoot,\n      basePaths: customOperationDocsPaths.map((x) => x.absoluteDocsPath),\n      queryPathCustomPrefix: (basePath) =>\n        customOperationDocsPaths.find((x) => x.absoluteDocsPath === basePath)\n          ?.queryPath,\n    });\n\n  const relativeDocsPages: ReaderWebPage[] = await getMarkdownReaderPages({\n    projectRoot,\n    basePaths: docsPaths,\n    // remove docs prefix if docs should be shown as in root\n    mapQueryPath: bundleMarkdownReaderConfig?.docsInRoot\n      ? (old) =>\n          old.startsWith(\"docs/\")\n            ? old.slice(\"docs/\".length)\n            : // NB: \"docs/README.md\" becomes \"docs\", which should, in turn, become \"\" in this case...\n            old === \"docs\"\n            ? \"\"\n            : old\n      : undefined,\n  });\n\n  // operations\n  const operationPages: ReaderWebPage[] = await getOperationPages(\n    projectRoot,\n    bundleMarkdownReaderConfig\n  );\n\n  // markdown model type pages\n  const markdownModelTypePages = await getMarkdownModelPages(projectRoot);\n  // todo pages\n  const todoPages = await getReaderTodoPages(projectRoot);\n\n  const mainReadme: ReaderWebPage | undefined =\n    bundleMarkdownReaderConfig?.docsInRoot\n      ? undefined\n      : {\n          queryPath: \"\",\n          pageData: { projectRelativeFilePath: \"README.md\" },\n          isMenuHidden: false,\n        };\n\n  const dictionaryPage: CustomWebPage = {\n    queryPath: \"dictionary\",\n    isMenuHidden: false,\n    pageData: null,\n  };\n\n  const allPages: WebPage<any>[] = [\n    mainReadme,\n    ...relativeDocsPages,\n    ...customOperationDocsPages,\n    ...operationPages,\n    // `/dictionary` page with all words/definitions, categorised\n    dictionaryPage,\n    // all markdown model types, optionally (with config)\n    ...markdownModelTypePages,\n    // all todo markdown folders, both in operations and outside (with config)\n    ...todoPages,\n  ].filter(notEmpty);\n\n  const filteredPages = allPages.filter(\n    onlyUnique2<ReaderWebPage>((a, b) => a.queryPath === b.queryPath)\n  );\n\n  return filteredPages;\n}"
  },
  "getChildren": {
    "name": "getChildren",
    "slug": "TsFunction",
    "id": "gyyoxscnatstmahsvgsjslwd",
    "description": "",
    "operationName": "markdown-reader-functions",
    "rawText": " (webPages: WebPage<any>[], queryPath: string) => {\n  const queryPathDepth = queryPath.split(\"/\").length;\n  const childrenKeys = webPages\n    .filter(\n      (x) =>\n        x.queryPath.startsWith(queryPath) &&\n        x.queryPath.split(\"/\").length - queryPathDepth === 1\n    )\n    .map((x) => x.queryPath.split(\"/\")[queryPathDepth]);\n\n  return childrenKeys;\n}"
  },
  "getFolderExplorationInfo": {
    "name": "getFolderExplorationInfo",
    "slug": "TsFunction",
    "id": "geusczwntkfnckxgjmpbpoiu",
    "description": "Gets exploration information about a folder\n\n- reads README.md in current folder\n- reads OPERATION.md in child folders, or README.md if that doesn't exist\n- gets an intro from those markdown files and returns that (uses `getMarkdownIntro`)",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  webPages: WebPage<any>[],\n  queryPath: string,\n  projectRoot: string\n): Promise<{\n  title: string | undefined;\n  description: string | null;\n  descriptionProjectRelativeMarkdownPath: string | null;\n  children: {\n    projectRelativeMarkdownPath: string | null;\n    title: string;\n    firstParagraph: string | null;\n    folderName: string;\n  }[];\n}> => {\n  const childrenKeys = getChildren(webPages, queryPath);\n\n  const potentialReadmePath = path.join(projectRoot, queryPath, \"README.md\");\n  const readmeMarkdownParse = fs.existsSync(potentialReadmePath)\n    ? await readMarkdownFile(potentialReadmePath)\n    : null;\n\n  const queryPathTitle = queryPath.split(\"/\").pop();\n  const readmeInfo = getMarkdownIntro(readmeMarkdownParse);\n  const title = readmeInfo.title || queryPathTitle;\n  const description = readmeInfo.firstParagraph;\n\n  const children = await Promise.all(\n    childrenKeys.map(async (folderName) => {\n      const potentialReadmePath = path.join(\n        projectRoot,\n        queryPath,\n        folderName,\n        \"README.md\"\n      );\n      const potentialOperationPath = path.join(\n        projectRoot,\n        queryPath,\n        folderName,\n        \"OPERATION.md\"\n      );\n\n      const pathToRead = fs.existsSync(potentialOperationPath)\n        ? potentialOperationPath\n        : fs.existsSync(potentialReadmePath)\n        ? potentialReadmePath\n        : undefined;\n\n      const markdownParse = pathToRead\n        ? await readMarkdownFile(pathToRead)\n        : null;\n\n      const { title, firstParagraph } = getMarkdownIntro(markdownParse);\n      return {\n        title: title || folderName,\n        firstParagraph,\n        folderName,\n        projectRelativeMarkdownPath: pathToRead || null,\n      };\n    })\n  );\n\n  return {\n    title,\n    description,\n    children,\n    descriptionProjectRelativeMarkdownPath: readmeMarkdownParse\n      ? potentialReadmePath\n      : null,\n  };\n}"
  },
  "getMarkdownModelPages": {
    "name": "getMarkdownModelPages",
    "slug": "TsFunction",
    "id": "axzzgaaciymgoauqcrjukurd",
    "description": "Transforms all your markdown models into  markdown reader pages\n\nSteps:\n- Finds all markdown model types from the database config\n- Gets their basepaths according to `fs-orm` convention\n- Checks if they actually exist\n- Finds all markdown therein\n- Makess markdown reader pages out of them",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  projectRoot: string\n): Promise<ReaderWebPage[]> => {\n  const markdownModelNames = getObjectKeysArray(modelQueryConfig).filter(\n    (modelName) => {\n      const config = modelQueryConfig[modelName] as QueryConfig;\n\n      const isMarkdownModelType = config.dbStorageMethod === \"markdown\";\n      const noSpecificPath = !config.operationRelativePath;\n      return isMarkdownModelType && noSpecificPath;\n    }\n  );\n\n  const basePaths = markdownModelNames\n    .map((modelName) =>\n      path.join(projectRoot, \"db\", pluralize(kebabCase(modelName)))\n    )\n    .filter((potentialBasePath) => fs.existsSync(potentialBasePath));\n\n  const markdownReaderPages = await getMarkdownReaderPages({\n    projectRoot,\n    basePaths,\n  });\n\n  return markdownReaderPages;\n}"
  },
  "getMarkdownPageInfo": {
    "name": "getMarkdownPageInfo",
    "slug": "TsFunction",
    "id": "mxfvkasqliztryewpppagrew",
    "description": "If a markdown page is found, this function fetches all metadata needed to render that markdown page",
    "operationName": "markdown-reader-functions",
    "rawText": " async (config: {\n  projectRoot: string;\n  webPages: WebPage<any>[];\n  queryPath: string;\n  contentPage: ReaderWebPage;\n  webOperationName: string;\n  markdownCallToActions: MarkdownCallToAction[];\n}): Promise<{\n  markdownFile: WebMarkdownFile | null;\n  nextQueryPath: string | null;\n  previousQueryPath: string | null;\n  projectRelativeMarkdownPath: string | null;\n}> => {\n  const {\n    contentPage,\n    markdownCallToActions,\n    projectRoot,\n    queryPath,\n    webOperationName,\n    webPages,\n  } = config;\n\n  const parentQuery = getOneFolderUpPath(queryPath);\n  const siblings = getChildren(webPages, parentQuery);\n  const thisPageKey = queryPath.split(\"/\").pop();\n  const meIndex = siblings.findIndex((sibling) => thisPageKey === sibling);\n\n  const previousFolder = siblings[meIndex - 1];\n  const previousQueryPath = previousFolder\n    ? `${parentQuery}/${previousFolder}`\n    : null;\n  const nextFolder = siblings[meIndex + 1];\n  const nextQueryPath = nextFolder ? `${parentQuery}/${nextFolder}` : null;\n\n  const absoluteMarkdownPath = contentPage.pageData?.projectRelativeFilePath\n    ? path.join(projectRoot, contentPage.pageData.projectRelativeFilePath)\n    : undefined;\n\n  const markdownFile = absoluteMarkdownPath\n    ? await readMarkdownFileToModel(\n        absoluteMarkdownPath,\n        webOperationName,\n        markdownCallToActions\n      )\n    : null;\n\n  const projectRelativeMarkdownPath = absoluteMarkdownPath\n    ? makeRelative(absoluteMarkdownPath, projectRoot)\n    : null;\n\n  return {\n    markdownFile,\n    nextQueryPath,\n    previousQueryPath,\n    projectRelativeMarkdownPath,\n  };\n}"
  },
  "getMarkdownReaderPages": {
    "name": "getMarkdownReaderPages",
    "slug": "TsFunction",
    "id": "lcipylhwoxhhftuecgglnimu",
    "description": "Gets all markdownreader pages for multiple basePaths. Can add a prefix, can also remove the last folder of basePath from the suffix.",
    "operationName": "markdown-reader-functions",
    "rawText": " async (config: {\n  projectRoot: string;\n  /**\n   * basePaths to search for public markdown for\n   */\n  basePaths: string[];\n\n  /**\n   * If given, uses a basePath relative queryPath and prefixes this before it.\n   *\n   * if there's a prefix, don't use the basePath as prefix, but use that prefix instead.\n   *\n   * Should end with slash (/) in order for it to be folder\n   */\n  queryPathCustomPrefix?: (basePath?: string) => string | undefined;\n  /**\n   * if set, maps query path further\n   */\n  mapQueryPath?: (\n    /**\n     * already mapped the relative path to remove extension and numbers from folders\n     */\n    queryPath: string\n  ) => string;\n}): Promise<ReaderWebPage[]> => {\n  const { basePaths, projectRoot, mapQueryPath } = config;\n  const markdownReaderPages: ReaderWebPage[] = (\n    await Promise.all(\n      basePaths.map(async (basePath) => {\n        const publicMarkdownFileAbsolutePaths =\n          await getPublicMarkdownFilePaths(basePath, false);\n\n        const markdownReaderPages = publicMarkdownFileAbsolutePaths.map((x) => {\n          const filePath = makeRelative(x.path, projectRoot);\n          const pathWithoutReadme = stripReadmeFromFolder(filePath);\n          const pathWithoutExtensions =\n            removeExtensionsFromPath(pathWithoutReadme);\n\n          const mappedQueryPath = mapQueryPath\n            ? mapQueryPath(pathWithoutExtensions)\n            : pathWithoutExtensions;\n\n          const customQueryPrefix = config.queryPathCustomPrefix\n            ? config.queryPathCustomPrefix(basePath)\n            : undefined;\n\n          const relativeBasePath = makeRelative(basePath, projectRoot);\n\n          // console.log({ mappedQueryPath, relativeBasePath });\n          const queryPath = customQueryPrefix\n            ? customQueryPrefix + mappedQueryPath.replace(relativeBasePath, \"\")\n            : mappedQueryPath;\n\n          // NB: folders are no menu items because menu is built from queryPaths recursively\n          const readerWebPage: ReaderWebPage = {\n            queryPath,\n            pageData: { projectRelativeFilePath: filePath },\n            isMenuHidden: x.isFolder,\n          };\n\n          return readerWebPage;\n        });\n\n        return markdownReaderPages;\n      })\n    )\n  ).flat();\n\n  return markdownReaderPages;\n}"
  },
  "getMarkdownReaderQueryPaths": {
    "name": "getMarkdownReaderQueryPaths",
    "slug": "TsFunction",
    "id": "bcloorgeczunapiudukpyskw",
    "description": "",
    "operationName": "markdown-reader-functions",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n}) => {\n  const pages = await getAllMarkdownReaderPages(config);\n  // NB: this is kind of a hack, but it's way harder to add it into the pages I guess, so it's easier like this.\n  const queryPaths = pages?.map((x) => x.queryPath);\n\n  const queryPaths2 = pages\n    ?.map((x) => x.queryPath)\n    .map((queryPath) => getAllFoldersUntilFolder(queryPath))\n    .flat()\n    .filter(onlyUnique2())\n    .filter((x) => x !== \"/\")\n    .map((x) => trimSlashes(x));\n\n  // console.log({ queryPaths2 });\n  return queryPaths2;\n}"
  },
  "getOperationPages": {
    "name": "getOperationPages",
    "slug": "TsFunction",
    "id": "zcdtjeetwuekkcpxdaklhhvw",
    "description": "",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  projectRoot: string,\n  bundleMarkdownReaderConfig?: BundleMarkdownReaderConfig\n): Promise<ReaderWebPage[]> => {\n  const operationBasePaths = getPathsWithOperations({\n    manualProjectRoot: projectRoot,\n  });\n\n  const operationPagesPerType: { [key: string]: ReaderWebPage[] } =\n    mergeObjectsArray(\n      await Promise.all(\n        operationBasePaths.map(async (absoluteBasePath) => {\n          const folders = (\n            await exploreOperationFolders({ basePath: absoluteBasePath })\n          ).map((result) => ({\n            projectRelativePath: makeRelative(result, projectRoot),\n          }));\n\n          const projectRelativeBasePath = makeRelative(\n            absoluteBasePath,\n            projectRoot\n          );\n\n          // console.log({ folders });\n\n          const pages: ReaderWebPage[] = folders.map((folder) => {\n            const folderName = getLastFolder(folder.projectRelativePath);\n\n            /**\n             * Sometimes the bundle states the menu items should not be shown. The pages still remain available though, otherwise it would cause lots of dead links!\n             */\n            const isMenuHidden =\n              projectRelativeBasePath === \"apps\" &&\n              bundleMarkdownReaderConfig?.omitAppsMenu\n                ? true\n                : projectRelativeBasePath === \"packages\" &&\n                  bundleMarkdownReaderConfig?.omitPackagesMenu\n                ? true\n                : projectRelativeBasePath === \"modules\" &&\n                  bundleMarkdownReaderConfig?.omitModulesMenu\n                ? true\n                : false;\n\n            // console.log({ isMenuItem, projectRelativeBasePath, folderName });\n\n            const readerWebPage: ReaderWebPage = {\n              queryPath: folder.projectRelativePath,\n              // operation filePath is README.md\n              pageData: {\n                projectRelativeFilePath: path.join(\n                  folder.projectRelativePath,\n                  \"README.md\"\n                ),\n                internalLinkWord: folderName,\n              },\n              isMenuHidden,\n            };\n\n            return readerWebPage;\n          });\n\n          return { [projectRelativeBasePath]: pages };\n        })\n      )\n    );\n\n  const operationsPages: ReaderWebPage[] =\n    bundleMarkdownReaderConfig?.customOperationNames\n      ?.map((operationName) => {\n        const projectRelativeOperationPath =\n          operations[operationName as keyof typeof operations];\n\n        if (!projectRelativeOperationPath) return;\n\n        const readerWebPage: ReaderWebPage = {\n          pageData: {\n            projectRelativeFilePath: path.join(\n              projectRelativeOperationPath,\n              \"README.md\"\n            ),\n          },\n          queryPath: projectRelativeOperationPath,\n          isMenuHidden: false,\n        };\n\n        return readerWebPage;\n      })\n      .filter(notEmpty) || [];\n\n  // NB: we need to get the right order, so it needs to be done separately\n  const operationPages: ReaderWebPage[] = isBundle(projectRoot)\n    ? [\n        ...operationsPages,\n        ...operationPagesPerType.packages,\n        ...operationPagesPerType.apps,\n        ...operationPagesPerType.modules,\n      ]\n    : [\n        ...operationsPages,\n        ...operationPagesPerType[\"operations/tools\"],\n        ...operationPagesPerType[\"operations/niches\"],\n      ];\n\n  return operationPages;\n}"
  },
  "getPublicMarkdownFilePaths": {
    "name": "getPublicMarkdownFilePaths",
    "slug": "TsFunction",
    "id": "heutmmyzoatecbspounlynfo",
    "description": "Returns all absolute markdown file paths within a basePath which are not drafts and which are not marked private (through frontmatter)\n\nReadme is put on top!",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  baseFolderPath: string,\n  includeFoldersWithResults?: boolean\n) => {\n  const publicMarkdownFilePaths: { path: string; isFolder: boolean }[] = (\n    await explore({\n      basePath: baseFolderPath,\n      extension: \"md\",\n      readmeOnTop: true,\n      includeFoldersWithResults,\n    })\n  )\n    .filter((x) => {\n      if (x.isFolder) return true;\n\n      // NB: we have a file\n      const markdownString = fs.readFileSync(x.path, \"utf8\");\n      const { parameters } = parseFrontmatterMarkdownString(markdownString);\n      if (!shouldExposeMarkdownFile(parameters)) {\n        return false;\n      }\n      return true;\n    })\n    .map(({ path, isFolder }) => ({ path, isFolder }));\n\n  return publicMarkdownFilePaths;\n}"
  },
  "getReaderTodoPages": {
    "name": "getReaderTodoPages",
    "slug": "TsFunction",
    "id": "ewieydgzhorjloxgbdcgxbgh",
    "description": "gets all todo pages as markdownreader pages",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  projectRoot: string\n): Promise<ReaderWebPage[]> => {\n  const operationsPath = getRootPath(\"operations\");\n  if (!operationsPath) return [];\n\n  const todoFolderPaths = await findAllTodoFolderPaths(operationsPath, false);\n  const markdownReaderPages: ReaderWebPage[] = await getMarkdownReaderPages({\n    projectRoot,\n    basePaths: todoFolderPaths,\n    mapQueryPath: (queryPath) => {\n      const almostPath = queryPath\n        .replaceAll(\"todo/\", \"\")\n        .replace(\"operations/\", \"todo/\");\n\n      return almostPath.startsWith(\"todo/\") ? almostPath : \"todo/\" + almostPath;\n    },\n  });\n\n  return markdownReaderPages;\n}"
  },
  "markdownReaderGetStaticPaths": {
    "name": "markdownReaderGetStaticPaths",
    "slug": "TsFunction",
    "id": "ibkmsuejhtdqvusiafkazfoo",
    "description": "Function that tells Next.js what the pages are that need to be statically generated",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  context: GetStaticPathsContext\n) => {\n  const paths: string[] | undefined = await getMarkdownReaderQueryPaths();\n\n  // console.log({ paths });\n  if (!paths) {\n    return { paths: [], fallback: \"blocking\" };\n  }\n\n  const staticPaths = paths\n    .filter((x) => x !== \"\")\n    .map((p) => ({ params: { paths: p.split(\"/\") } }));\n\n  return {\n    paths: staticPaths,\n    fallback: \"blocking\",\n  };\n}"
  },
  "markdownReaderGetStaticPropsFromPages": {
    "name": "markdownReaderGetStaticPropsFromPages",
    "slug": "TsFunction",
    "id": "kdpeuagpqhdnowrkdflenazl",
    "description": "Takes the routes and pages you want to show, and returns the MarkdownReaderPageProps you need to render the reader page.",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  context: GetStaticPropsContext,\n  fileWebPages: WebPage<any>[],\n  webOperationName: string\n): Promise<{\n  props: MarkdownReaderPageProps;\n}> => {\n  const menu = getMenuPagesObject(fileWebPages);\n  const projectRoot = getProjectRoot();\n\n  if (!projectRoot) {\n    return { props: { menu } };\n  }\n\n  const publicBundleConfig = await readJsonFile<PublicBundleConfig>(\n    path.join(projectRoot, \"public-bundle-config.json\")\n  );\n\n  const queryPath = getQueryPath(context.params);\n\n  // console.log(\"get static props\", queryPath);\n\n  // definitions/statements/functions/interfaces/operations\n\n  // NB: finds a page with actual content\n  const contentPage = fileWebPages.find((x) => x.queryPath === queryPath);\n\n  if (!contentPage) {\n    // NB: we need to render an exploration page\n    const {\n      children,\n      title,\n      description,\n      descriptionProjectRelativeMarkdownPath,\n    } = await getFolderExplorationInfo(fileWebPages, queryPath, projectRoot);\n    return {\n      props: {\n        publicBundleConfig,\n        menu,\n        content: {\n          children,\n          title,\n          description,\n          projectRelativeMarkdownPath: descriptionProjectRelativeMarkdownPath,\n        },\n      },\n    };\n  }\n\n  // NB: There's a content page. We need to return it (`MarkdownFile`), including its previous, next pages, and a title\n\n  const markdownCallToActions = await db.get(\"MarkdownCallToAction\");\n\n  const filteredMarkdownCtas = markdownCallToActions.filter((x) => {\n    const isExternalRoot =\n      x.hostname !== publicBundleConfig?.deploymentHostname &&\n      (!x.path || x.path === \"\");\n\n    if (isExternalRoot) return true;\n\n    const isInternalNonRoot =\n      x.hostname === publicBundleConfig?.deploymentHostname &&\n      x.path &&\n      x.path !== \"\";\n\n    return isInternalNonRoot;\n  });\n\n  const markdownPageInfo = await getMarkdownPageInfo({\n    projectRoot,\n    webPages: fileWebPages,\n    queryPath,\n    contentPage,\n    webOperationName,\n    markdownCallToActions: filteredMarkdownCtas,\n  });\n\n  // console.log(\n  //   {\n  //     projectRoot,\n  //     webPages: fileWebPages,\n  //     queryPath,\n  //     contentPage,\n  //     webOperationName,\n  //     markdownCallToActions: filteredMarkdownCtas,\n  //   },\n  //   { markdownPageInfo }\n  // );\n\n  const augmentedWordObject = await getAugmentedWordObject(projectRoot);\n\n  return {\n    // Passed to the page component as props\n    props: {\n      content: {\n        ...markdownPageInfo,\n        augmentedWordObject,\n      },\n      publicBundleConfig,\n      menu,\n    },\n  };\n}"
  },
  "markdownReaderGetStaticProps": {
    "name": "markdownReaderGetStaticProps",
    "slug": "TsFunction",
    "id": "yxngndednkuqjaebvexnllen",
    "description": "",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  context: GetStaticPropsContext\n): Promise<{\n  props: MarkdownReaderPageProps;\n}> => {\n  const flat = (await getAllMarkdownReaderPages()) || [];\n  return markdownReaderGetStaticPropsFromPages(\n    context,\n    flat,\n    \"markdown-reader-web\"\n  );\n}"
  },
  "putReadmeOnTop": {
    "name": "putReadmeOnTop",
    "slug": "TsFunction",
    "id": "kjkvyhpuebjpcmzaycllivgr",
    "description": "Takes an array of items (`explore` results) and checks them to put readme at the start\n\nDEPRECATED: After writing this, I found that `explore` also has `readmeOnTop` possibility, so this whole thing is not needed",
    "operationName": "markdown-reader-functions",
    "rawText": " <\n  T extends {\n    path: string;\n    isFolder: boolean;\n  }\n>(\n  items: T[]\n) => {\n  const itemsReadmesFirst = items.reduce((previous, item, index, array) => {\n    if (!item.path.toLowerCase().endsWith(\"readme.md\")) {\n      return previous;\n    }\n\n    const folderIndex = array.findIndex(\n      (x) => x.isFolder && x.path === getFolder(item.path)\n    );\n\n    if (folderIndex === -1) {\n      return previous;\n    }\n\n    return putIndexAtIndex(previous, index, folderIndex + 1);\n  }, items);\n\n  return itemsReadmesFirst;\n}"
  },
  "removeExtensionsFromPath": {
    "name": "removeExtensionsFromPath",
    "slug": "TsFunction",
    "id": "ltwqmcyxrpqxyynwxvjtfkwr",
    "description": "- Removes numbers from file or foldernames in a path.\n- Removes extension of files\n- Returns the new path without numbers and without extension\n\nWorks for files and folders",
    "operationName": "markdown-reader-functions",
    "rawText": " (\n  /**\n   * should also work for filenames\n   */\n  relativePath: string\n): string => {\n  const chunks = trimSlashes(relativePath).split(\"/\");\n\n  const chunksWithoutNumbers = chunks.map(removeNumberPrefix);\n\n  // could be file\n  const lastChunkIndex = chunksWithoutNumbers.length - 1;\n\n  const lastChunk = chunksWithoutNumbers[lastChunkIndex];\n  const parts = lastChunk.split(\".\");\n  const lastPart = parts[parts.length - 1];\n\n  if (availableExtensions.includes(lastPart)) {\n    // remove extension\n    parts.pop();\n    chunksWithoutNumbers[lastChunkIndex] = parts.join(\".\");\n  }\n\n  const simplifiedPath = chunksWithoutNumbers.join(\"/\");\n\n  return simplifiedPath;\n}"
  },
  "removeNumberPrefix": {
    "name": "removeNumberPrefix",
    "slug": "TsFunction",
    "id": "xlwectdrobnjmkookazrwzpm",
    "description": "removes number prefixes from a file or folder name. Does not remove extension\n\ndefaults to untitled if the file or folder has no name after removing numbers.",
    "operationName": "markdown-reader-functions",
    "rawText": " (fileOrFolderName: string): string => {\n  const parts = fileOrFolderName.split(\".\");\n\n  const newName = parts.reduce((restName, part, currentIndex, array) => {\n    if (restName) return restName;\n    const isTextPart = isNaN(Number(part));\n\n    if (isTextPart) {\n      // NB: everything after here is supposed to be part of the text\n      const restName = array.slice(currentIndex).join(\".\");\n      return restName;\n    }\n  }, undefined as string | undefined);\n\n  return newName || \"untitled\";\n}"
  },
  "shouldExposeMarkdownFile": {
    "name": "shouldExposeMarkdownFile",
    "slug": "TsFunction",
    "id": "qinrjbkaovwtkpooxhamrmht",
    "description": "markdown file should only be exposed if it doesn't say `privacy: private` or `isDraft: true` in your frontmatter.",
    "operationName": "markdown-reader-functions",
    "rawText": " (parameters: Frontmatter) => {\n  return !Boolean(parameters.isDraft) && parameters.privacy !== \"private\";\n}"
  },
  "stripReadmeFromFolder": {
    "name": "stripReadmeFromFolder",
    "slug": "TsFunction",
    "id": "latpbkezcclxxodpuldkuque",
    "description": "To get the queryPath, we need to strip the README.md so we get the folder as URL instead of the attached README.md",
    "operationName": "markdown-reader-functions",
    "rawText": " (filePath: string): string => {\n  const suffix = \"/readme.md\";\n\n  if (filePath.toLowerCase().endsWith(suffix)) {\n    const strippedPath = filePath.slice(0, filePath.length - suffix.length);\n\n    return strippedPath;\n  }\n\n  return filePath;\n}"
  },
  "getQueryPath": {
    "name": "getQueryPath",
    "slug": "TsFunction",
    "id": "bruvqcibpampzlaabkkqawbe",
    "description": "",
    "operationName": "himalayajeep-ui",
    "rawText": " (parsedUrlQuery: ParsedUrlQuery | undefined) => {\n  const paths = parsedUrlQuery?.paths;\n  const queryPath = Array.isArray(paths)\n    ? paths.join(\"/\")\n    : paths === undefined\n    ? \"\"\n    : paths;\n  return queryPath;\n}"
  },
  "todoPagesConfigRecencysConst": {
    "name": "todoPagesConfigRecencysConst",
    "slug": "TsVariable",
    "id": "aexciwejecjdyliwlyjvkxgn",
    "description": "",
    "operationName": "todo-types"
  },
  "todoPagesConfigRecencys": {
    "name": "todoPagesConfigRecencys",
    "slug": "TsVariable",
    "id": "dqrhhodprkknqwslphapphrq",
    "description": "",
    "operationName": "todo-types"
  },
  "FileWriterPage": {
    "name": "FileWriterPage",
    "slug": "TsFunction",
    "id": "hqgyeaqoqxaenbpsaohwebat",
    "description": "",
    "operationName": "social-media-web",
    "rawText": " () => {\n  const router = useRouter();\n  const paths = router.asPath;\n  const todoPagesQuery = queries.useGetSocialMediaMenu();\n  const webPages = todoPagesQuery?.data?.result?.flat;\n  console.log({ webPages, paths });\n\n  const filePage = webPages?.find((x) => `/${x.queryPath}` === paths);\n  console.log({ filePage });\n  //@ts-ignore\n  const projectRelativeFilePath = filePage?.pageData?.projectRelativeFilePath;\n\n  if (!projectRelativeFilePath) {\n    return <Div>Couldn't find that page</Div>;\n  }\n\n  return (\n    <WriterLayout>\n      <FileWriter\n        markdownModelName=\"TodoFile\"\n        projectRelativeFilePath={projectRelativeFilePath}\n      />\n    </WriterLayout>\n  );\n}"
  },
  "TodoMenuHeader": {
    "name": "TodoMenuHeader",
    "slug": "TsFunction",
    "id": "jnlunkopjyhmlvntmuwfdqjn",
    "description": "",
    "operationName": "social-media-web",
    "rawText": " () => {\n  const persons =\n    queries.useGetPublicPersons().data?.result?.map((x) => {\n      return { value: x.id, label: humanCase(x.name) };\n    }) || [];\n\n  const [todoPagesConfig, setTodoPagesConfig] = useStore(\"todoPagesConfig\");\n\n  const recencyOptions = [{ label: \"â°\", value: \"\" }].concat(\n    todoPagesConfigRecencys.map((x) => {\n      return { value: x, label: humanCase(x) };\n    })\n  );\n  const recencyValue: Item<string> =\n    recencyOptions.find((x) => x.value === todoPagesConfig.recency) ||\n    recencyOptions[0];\n\n  const categoryStackOptions = [\n    { label: \"ðŸ§©\", value: \"\" },\n    { label: \"Without category\", value: \"__NO_CATEGORY__\" },\n  ].concat(\n    [\"ideas\", \"backlog\", \"done\", \"codestories\", \"postables\", \"wontdo\"].map(\n      (x) => {\n        return { value: x, label: humanCase(x) };\n      }\n    )\n  );\n\n  const defaultSelectClass =\n    \"text-xs border-gray-300 border rounded-md focus:outline-none bg-transparent h-9\";\n\n  const noCategoryValue =\n    todoPagesConfig.categoryStack?.length === 0\n      ? categoryStackOptions.find((x) => x.value === \"__NO_CATEGORY__\")\n      : undefined;\n\n  const cateogryValue = categoryStackOptions.find(\n    (x) => x.value === todoPagesConfig.categoryStack?.[0]\n  );\n  const categoryStackValue: Item<string> =\n    noCategoryValue || cateogryValue || categoryStackOptions[0];\n\n  const personOptions = [{ label: \"ðŸ™‹â€â™‚ï¸\", value: \"\" }].concat(persons);\n\n  const personValue: Item<string> =\n    personOptions.find((x) => x.value === todoPagesConfig.personId) ||\n    personOptions[0];\n\n  return (\n    <Div className=\"flex flex-row flex-wrap gap gap-1 mb-2\">\n      {/* Person filter: assigned to a person of your choice (owner_personSlug) */}\n      <SelectInput\n        className={`${defaultSelectClass} ${\n          todoPagesConfig.personId ? \"\" : \"w-10\"\n        }`}\n        fieldName=\"personId\"\n        config={{}}\n        uniqueFieldId=\"personId\"\n        extra={{ options: personOptions }}\n        value={personValue}\n        onChange={(v) =>\n          setTodoPagesConfig({\n            ...todoPagesConfig,\n            personId:\n              v?.value === \"\" || v?.value === undefined ? undefined : v?.value,\n          })\n        }\n      />\n\n      {/* are in a certain categoryStack: SelectInput with preset (done, ideas, backlog, codestories, postables, etc*/}\n      <SelectInput\n        fieldName=\"categoryStack\"\n        config={{}}\n        className={`${defaultSelectClass} ${\n          todoPagesConfig.categoryStack ? \"\" : \"w-10\"\n        }`}\n        uniqueFieldId=\"categoryStack\"\n        extra={{ options: categoryStackOptions }}\n        value={categoryStackValue}\n        onChange={(v) =>\n          setTodoPagesConfig({\n            ...todoPagesConfig,\n            categoryStack:\n              v?.value === \"\" || v?.value === undefined\n                ? undefined\n                : v?.value === \"__NO_CATEGORY__\"\n                ? []\n                : [v?.value],\n          })\n        }\n      />\n      {/* has a certain recency of updated time:SelectInput */}\n      <SelectInput\n        fieldName=\"recency\"\n        config={{}}\n        className={`${defaultSelectClass} ${\n          todoPagesConfig.recency ? \"\" : \"w-10\"\n        }`}\n        uniqueFieldId=\"recency\"\n        extra={{ options: recencyOptions }}\n        value={recencyValue}\n        onChange={(v) =>\n          setTodoPagesConfig({\n            ...todoPagesConfig,\n            recency:\n              v?.value === \"\"\n                ? undefined\n                : (v?.value as TodoPagesConfig[\"recency\"]),\n          })\n        }\n      />\n      {/* has high priority:ToggleInput */}\n      <ToggleInput\n        config={{}}\n        fieldName=\"highPrio\"\n        uniqueFieldId=\"highPrio\"\n        extra={{ label: todoPagesConfig.priority ? \"High priority\" : \"â—ï¸\" }}\n        className={`${defaultSelectClass} px-1 ${\n          todoPagesConfig.priority ? \"\" : \"\"\n        }`}\n        onChange={(value) => {\n          setTodoPagesConfig({\n            ...todoPagesConfig,\n            priority: value === true ? \"high\" : undefined,\n          });\n        }}\n        value={todoPagesConfig.priority === \"high\" ? true : false}\n      />\n\n      {todoPagesConfig.categoryStack ||\n      todoPagesConfig.personId ||\n      todoPagesConfig.priority ||\n      todoPagesConfig.recency ? (\n        <Div\n          onClick={() => setTodoPagesConfig({})}\n          className={`${defaultSelectClass} px-1 flex items-center justify-center py-1 cursor-pointer w-20`}\n        >\n          ðŸ§¹ Clear\n        </Div>\n      ) : null}\n    </Div>\n  );\n}"
  },
  "addPeerMessage": {
    "name": "addPeerMessage",
    "slug": "TsFunction",
    "id": "aoqicpntzunfcwsobeeovtlc",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " async (message: string, peerSlug: string) => {\n  // @ts-ignore\n  const upsertResult = await db.upsert(\"PeerMessage\", {\n    message,\n    peerSlug,\n  });\n\n  return upsertResult;\n}"
  },
  "addPeer": {
    "name": "addPeer",
    "slug": "TsFunction",
    "id": "pyvwrtrfycjbhkmkdqrctxun",
    "description": "TODO:",
    "operationName": "peer-functions",
    "rawText": " async (\n  ip: string,\n  authToken: string,\n  peerName?: string,\n  /**\n   * If true, it does not validate the IP to see if it is online and it is authorized...\n   */\n  force?: boolean,\n  isMe?: boolean\n) => {\n  // get new PeerMessages after last sync\n\n  const apiResult = await apiWithConfig.ping({\n    apiUrl: `http://${ip}:${ports[\"function-server\"]}`,\n    authToken,\n    timeout: 2000,\n  });\n\n  const isConnectionEstablished =\n    apiResult?.isSuccessful &&\n    !apiResult?.isUnauthorized &&\n    apiResult.result === true;\n\n  if (!force && !isConnectionEstablished) {\n    return {\n      isSuccesful: false,\n      message:\n        \"Peer connection could not be established. Are you sure the peer is online? Use force if you want to add your peer anyway. If you have a node version lower than v17, this will also fail.\",\n    };\n  }\n}"
  },
  "augmentDevice": {
    "name": "augmentDevice",
    "slug": "TsFunction",
    "id": "eizrvzgpeipqwjehcfogwszj",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " (x: Device) => {\n  const isOnlineCalculated = x.lastOnlineAt > Date.now() - 300 * 1000;\n  const isLocalIpCalculated = x.ip.startsWith(\"192.168.\");\n\n  const newDevice: Device = {\n    ...x,\n    isOnlineCalculated,\n    isLocalIpCalculated,\n  };\n  return newDevice;\n}"
  },
  "deviceGetAppsCalculated": {
    "name": "deviceGetAppsCalculated",
    "slug": "TsFunction",
    "id": "ivcbvzclsbulvarxbxlbkifp",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " async (device: Device) => {\n  const { result: appOperationsCalculated } =\n    await apiWithConfig.getAllAppOperations({\n      apiUrl: `http://${device.ip}:${ports[\"function-server\"]}`,\n      authToken: device.authToken,\n      timeout: 1000,\n    });\n\n  const lastOnlineAt = Date.now();\n  if (!!appOperationsCalculated) {\n    db.update(\n      \"Device\",\n      (p) => p.id === device.id,\n      (p) => ({ ...p, lastOnlineAt })\n    );\n  }\n\n  return { ...device, lastOnlineAt, appOperationsCalculated };\n}"
  },
  "getAllAppOperations": {
    "name": "getAllAppOperations",
    "slug": "TsFunction",
    "id": "xrqlqhtrtlgpwhiqwreiayxc",
    "description": "Gets all app operations from all packageJsons from the database. Adds `isOnline` to it on the fly by checking if it can connect to the port or not",
    "operationName": "peer-functions",
    "rawText": " async (): Promise<AppOperation[]> => {\n  const appOperations = (await db.get(\"Operation\"))\n    .filter(\n      (operation) =>\n        operation.name &&\n        operation.operation?.classificationIndexed === \"ui-web\" &&\n        operation.operation?.port\n    )\n    .map((operation, index) => {\n      const description =\n        operation.operation?.markdown || operation.description;\n      const port = operation.operation?.port!;\n\n      return {\n        name: operation.name,\n        port,\n        description,\n        emoji: getFirstEmoji(description),\n      };\n    })\n    .sort((a, b) => {\n      if (!a.port || !b.port) return -1;\n\n      if (a.port < b.port) return -1;\n      return 1;\n    });\n\n  const appOperationsWithOnline: AppOperation[] = await Promise.all(\n    appOperations.map(async (appOperation) => {\n      const isOnline = await isPortUsed(appOperation.port);\n      const newAppOperation: AppOperation = {\n        ...appOperation,\n        isOnline,\n      };\n      return newAppOperation;\n    })\n  );\n\n  return appOperationsWithOnline;\n}"
  },
  "getAugmentedPersons": {
    "name": "getAugmentedPersons",
    "slug": "TsFunction",
    "id": "wruzpiklmahjgzvajqssfsmw",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " async (\n  devices: Device[],\n  config?: {\n    onlyWithDevices?: boolean;\n    onlyWithPapi?: boolean;\n    onlyOnline?: boolean;\n    withAppsCalculated?: boolean;\n  }\n) => {\n  const { onlyOnline, onlyWithDevices, onlyWithPapi, withAppsCalculated } =\n    destructureOptionalObject(config);\n  return (\n    await Promise.all(\n      (\n        await db.get(\"Person\")\n      ).map(async (x) => {\n        const person: Person = {\n          ...x,\n          devicesCalculated: await Promise.all(\n            devices\n              .filter((x) => x.personIds?.includes(x.id))\n              .filter((x) => (onlyWithPapi ? x.hasPapi : true))\n              .map(augmentDevice)\n              .sort(sortDevices)\n              .filter((x) => (onlyOnline ? x.isOnlineCalculated : true))\n              .map((x) => (withAppsCalculated ? deviceGetAppsCalculated(x) : x))\n          ),\n        };\n\n        return person;\n      })\n    )\n  ).filter((x) => {\n    if (!onlyWithDevices) return true;\n    return x.devicesCalculated && x.devicesCalculated.length > 0;\n  });\n}"
  },
  "getFirstEmoji": {
    "name": "getFirstEmoji",
    "slug": "TsFunction",
    "id": "fnsdloufrfozohywkfrjlrkq",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " (text?: string): string | undefined => {\n  if (!text) return;\n  return text?.match(emojiRegex())?.[0];\n}"
  },
  "getNestedPathObject": {
    "name": "getNestedPathObject",
    "slug": "TsFunction",
    "id": "trsbkvoapvnonpclavtegccq",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " async (\n  baseFolderPath: string\n): Promise<NestedPathObject> => {\n  // 1 - explore\n\n  const exploreResult = await explore({\n    basePath: baseFolderPath,\n    includeFoldersWithResults: true,\n  });\n  // 2 - get file and folder paths from explore result\n  const explorePaths = exploreResult.map((textJson) => textJson.path);\n  const relativeExplorePaths = explorePaths.map((explorePath) => {\n    const baseFolderRelativeExplorePath = makeRelative(\n      explorePath,\n      baseFolderPath\n    );\n\n    return baseFolderRelativeExplorePath;\n  });\n\n  // 3- convert file/folder paths array into `NestedPathObject`\n  const nestedPathObject =\n    queryPathsArrayToNestedPathObject(relativeExplorePaths);\n\n  // 4 - return that\n  return nestedPathObject;\n}"
  },
  "getPeerMessages": {
    "name": "getPeerMessages",
    "slug": "TsFunction",
    "id": "ywtofjwqqcmkdjbmbdezzpii",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " async () => {\n  const peerMessages = await db.get(\"PeerMessage\", {\n    include: { referenceKey: \"peerSlug\" },\n  });\n\n  const sortedPeerMessages = peerMessages\n    .sort((a, b) => {\n      return a.createdAt < b.createdAt ? 1 : -1;\n    })\n    .slice(0, 1000);\n\n  return sortedPeerMessages;\n}"
  },
  "getPeerPeople": {
    "name": "getPeerPeople",
    "slug": "TsFunction",
    "id": "ssgakcnycjgdhldnpvygbljp",
    "description": "Get persons with devices that have papi and their apps calculated, sorted",
    "operationName": "peer-functions",
    "rawText": " async (): Promise<{\n  success: boolean;\n  peerPeople: Person[];\n}> => {\n  const devices = await db.get(\"Device\");\n\n  // person array met voor elke person alle devices die een papi hebben\n  const peerPeople = await getAugmentedPersons(devices, {\n    onlyOnline: false,\n    onlyWithDevices: true,\n    onlyWithPapi: true,\n    withAppsCalculated: true,\n  });\n\n  return { success: true, peerPeople };\n}"
  },
  "getPeersFromPeersRecursively": {
    "name": "getPeersFromPeersRecursively",
    "slug": "TsFunction",
    "id": "bcrfpgjbqfzcfdbnpuowfwct",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " () => {\n  // TODO: should get the peers from all peers recursively. This is a RECURSIVE API lol!\n}"
  },
  "getPublicFolderNestedPathObjectFromPeer": {
    "name": "getPublicFolderNestedPathObjectFromPeer",
    "slug": "TsFunction",
    "id": "amkuzissrpdouefxblxdtmlc",
    "description": "Peer = {\nname: \"22.2.2.2.2.2\",\nslug: \"22-22-22-22\"\n}",
    "operationName": "peer-functions",
    "rawText": " async (\n  peerSlug: string\n): Promise<\n  | undefined\n  | { peerApiResult: RealApiReturnType<\"getPublicFolderNestedPathObject\"> }\n> => {\n  const { peerPeople } = await getPeerPeople();\n  const peer = peerPeople.find((x) => x.slug === peerSlug);\n  const name = peer?.name;\n  if (!name) {\n    console.log(\"Peer not found\");\n    return;\n  }\n\n  // TODO:\n  const ip = \"\";\n  // call `getPublicFolderNestedPathObject` with api with other ip\n  const peerApiResult = await apiWithConfig.getPublicFolderNestedPathObject({\n    apiUrl: `http://${ip}:${ports[\"function-server\"]}`,\n    // authToken: peer.authToken,\n    timeout: 5000,\n  });\n\n  return { peerApiResult };\n}"
  },
  "getPublicFolderNestedPathObject": {
    "name": "getPublicFolderNestedPathObject",
    "slug": "TsFunction",
    "id": "jqyqfqmalzxjkliegbvzsnba",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " async (): Promise<\n  NestedPathObject | undefined\n> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n\n  const publicFolderPath = path.join(projectRoot, \"public\");\n\n  const nestedPathObject = await getNestedPathObject(publicFolderPath);\n\n  return nestedPathObject;\n}"
  },
  "getPublicPeers": {
    "name": "getPublicPeers",
    "slug": "TsFunction",
    "id": "lvdaprysikelqvaoxgdqimdg",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " async () => {\n  const publicPeers = (await db.get(\"Device\")).filter(\n    (peer) => !peer.isPrivate\n  );\n\n  return publicPeers;\n}"
  },
  "isPortUsed": {
    "name": "isPortUsed",
    "slug": "TsFunction",
    "id": "pyvrxkjmhzgdafugopyeeoed",
    "description": "Checks if a port is used or not",
    "operationName": "peer-functions",
    "rawText": " (port: number): Promise<boolean> => {\n  return new Promise<boolean>((resolve, reject) => {\n    const server = net.createServer();\n\n    server.once(\"error\", function (err) {\n      if ((err as any).code === \"EADDRINUSE\") {\n        resolve(true);\n      }\n    });\n\n    server.once(\"listening\", function () {\n      // close the server if listening doesn't fail\n      server.close();\n\n      resolve(false);\n    });\n\n    server.listen(port);\n  });\n}"
  },
  "lateFetchPeerMessageSync": {
    "name": "lateFetchPeerMessageSync",
    "slug": "TsFunction",
    "id": "flheuelhssrsnllaoeppseda",
    "description": "Should sync messages from all peers that are online into your database",
    "operationName": "peer-functions",
    "rawText": " async () => {\n  // goes over all peers, and fetches all their messages since the last sync\n  const peers = await db.get(\"Device\", {\n    include: { referenceKey: \"personId\" },\n  });\n\n  const result = await oneByOne(peers, async (peer) => {\n    const lastSyncedAt = peer.lastSyncDatabaseAtObject.PeerMessage;\n\n    // get new PeerMessages after last sync\n    const apiResult = await apiWithConfig.getDbModel(\n      {\n        apiUrl: `http://${peer.name}:${ports[\"function-server\"]}`,\n        authToken: peer.authToken,\n        timeout: 2000,\n      },\n      \"PeerMessage\",\n      {\n        filter: [\n          // {\n          //   objectParameterKey: \"peerSlug\",\n          //   operator: \"equal\",\n          //   value: peer.,\n          // },\n          {\n            // updatedAt is better than createdAt because it can also work if the model can be updated and if the messages can be edited for example. The id stays the same so upsert will overwrite it\n            objectParameterKey: \"updatedAt\",\n            operator: \"greaterThan\",\n            value: String(lastSyncedAt),\n          },\n        ],\n      }\n    );\n    const newPeerMessages = apiResult.result?.data as PeerMessage[] | undefined;\n\n    if (!newPeerMessages) {\n      // PEER is not online\n      return;\n    }\n\n    // TODO: this should be augmented I think\n    // @ts-ignore\n    const upsertResult = await db.upsert(\"PeerMessage\", newPeerMessages);\n\n    // Update peer to state that we have just synced (and the peer seems to be online)\n    const updatedResult = await db.update(\n      \"Device\",\n      (p) => p.name === peer.name,\n      (p) => ({\n        ...p,\n        lastOnlineAt: Date.now(),\n        lastSyncDatabaseAtObject: {\n          ...p.lastSyncDatabaseAtObject,\n          PeerMessage: Date.now(),\n        },\n      })\n    );\n\n    return upsertResult;\n  });\n\n  const add = (previous: number, current: number) => previous + current;\n  const sum = result\n    .filter(notEmpty)\n    .map((x) => x.amountInserted)\n    .filter(notEmpty)\n    .reduce(add, 0);\n\n  return { newMessagesAmount: sum };\n}"
  },
  "ping": {
    "name": "ping",
    "slug": "TsFunction",
    "id": "rzrmdxnysorhoetnfswcallk",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " () => true"
  },
  "proactivePushAddPeerMessage": {
    "name": "proactivePushAddPeerMessage",
    "slug": "TsFunction",
    "id": "wgipuhmgdvzljzemakflzkqk",
    "description": "Adds a message to your own peer messages database, but also to the db of all your peers that are online currently",
    "operationName": "peer-functions",
    "rawText": " async (\n  message: string,\n  peerSlug: string\n): Promise<boolean> => {\n  await addPeerMessage(message, peerSlug);\n\n  const peers = await db.get(\"Person\", {\n    include: { referenceKey: \"personId\" },\n  });\n  await Promise.all(\n    peers.map(async (peer) => {\n      //  if (peer.) return;\n      const apiResult = await apiWithConfig.addPeerMessage(\n        {\n          apiUrl: `http://${peer.name}:${ports[\"function-server\"]}`,\n          //  authToken: peer,\n          timeout: 2000,\n        },\n        message,\n        peerSlug\n      );\n\n      return apiResult;\n    })\n  );\n\n  return true;\n}"
  },
  "removePeer": {
    "name": "removePeer",
    "slug": "TsFunction",
    "id": "incftgqjhknnazvtlriwlmyy",
    "description": "TODO: connect with peoples",
    "operationName": "peer-functions",
    "rawText": " async (id: string) => {\n  const removeResult = await db.remove(\"Device\", (peer) => peer.id === id);\n  return removeResult;\n}"
  },
  "sortDevices": {
    "name": "sortDevices",
    "slug": "TsFunction",
    "id": "iayqcpdxybsvatfhegjoaxij",
    "description": "Only works if isOnlineCalculated is set (using augmentDevice)\n\nSorts device: first favorite, then online, then offline",
    "operationName": "peer-functions",
    "rawText": " (a: Device, b: Device) => {\n  if (a.isFavorite) return -1;\n  if (b.isFavorite) return 1;\n\n  if (a.isOnlineCalculated) return -1;\n  if (b.isOnlineCalculated) return 1;\n\n  return 1;\n}"
  },
  "updatePeer": {
    "name": "updatePeer",
    "slug": "TsFunction",
    "id": "oqtpizwtqctljdcfdtjhbkxe",
    "description": "Update one of your peers",
    "operationName": "peer-functions",
    "rawText": " async (\n  slug: string,\n  updatedValues: {\n    name?: string;\n    description?: string;\n    authToken?: string;\n    isFavorite?: boolean;\n    isMe?: boolean;\n  }\n): Promise<{ isSuccesful: boolean; message: string }> => {\n  const updateResult = await db.update(\n    \"Person\",\n    (person) => {\n      return person.slug === slug;\n    },\n    (peer) => {\n      return { ...peer, ...omitUndefinedValues(updatedValues) };\n    }\n  );\n\n  return {\n    isSuccesful: !!updateResult.isSuccesful,\n    message: updateResult.isSuccesful\n      ? \"Peer updated\"\n      : `Something went wrong: ${updateResult.message}`,\n  };\n}"
  },
  "achievements": {
    "name": "achievements",
    "slug": "TsVariable",
    "id": "fduaewitlxcfempafxskbkrv",
    "description": "",
    "operationName": "peer-types"
  },
  "developers": {
    "name": "developers",
    "slug": "TsVariable",
    "id": "mzvorqkbuwhkegmcyfeubxus",
    "description": "",
    "operationName": "peer-types"
  },
  "englishMethod": {
    "name": "englishMethod",
    "slug": "TsVariable",
    "id": "aonddiaxhzjtdwygygwxuzvd",
    "description": "",
    "operationName": "peer-types"
  },
  "levelNames": {
    "name": "levelNames",
    "slug": "TsVariable",
    "id": "bnymuiovoeuzjyjxmtktpgwc",
    "description": "",
    "operationName": "peer-types"
  },
  "publicPersonKeys": {
    "name": "publicPersonKeys",
    "slug": "TsVariable",
    "id": "fgolhteezehskgihzcncfhii",
    "description": "Can be seen for every person, without authentication\n\nNB: I wish it were possible to ensure these keys exist on the person here, but we can't validate that while still keeping it a const I guess",
    "operationName": "peer-types"
  },
  "AddPeer": {
    "name": "AddPeer",
    "slug": "TsFunction",
    "id": "igzqdrfxydnqduqfoulbrlwy",
    "description": "",
    "operationName": "peer-web",
    "rawText": " () => {\n  const alert = useAlert();\n  const router = useRouter();\n  return (\n    <Div className=\"flex flex-1 justify-center\">\n      <Div className=\"w-96\">\n        <FunctionForm\n          tsFunction={AddPeerTsFunction}\n          withApiResult={(result) => {\n            if (result?.result?.isSuccesful) {\n              router.back();\n              return;\n            }\n            alert?.(\"Failed\", result?.result?.message || result?.message);\n          }}\n        />\n      </Div>\n    </Div>\n  );\n}"
  },
  "{\n  getPeerMessages,\n  lateFetchPeerMessageSync,\n  proactivePushAddPeerMessage,\n  getPeers,\n}": {
    "name": "{\n  getPeerMessages,\n  lateFetchPeerMessageSync,\n  proactivePushAddPeerMessage,\n  getPeers,\n}",
    "slug": "TsVariable",
    "id": "kwivnivpjaiyumkdvyeuuyco",
    "description": "",
    "operationName": "peer-web"
  },
  "{ getPeers }": {
    "name": "{ getPeers }",
    "slug": "TsVariable",
    "id": "ktybcvijebvlkhhlmaobfsqw",
    "description": "",
    "operationName": "peer-web"
  },
  "Home": {
    "name": "Home",
    "slug": "TsFunction",
    "id": "jaswysimirjepwtzbaraoxbf",
    "description": "",
    "operationName": "peer-web",
    "rawText": " () => {\n  const router = useRouter();\n\n  return (\n    <Div>\n      <Div className=\"w-full flex flex-row flex-1 h-[90vh]\">\n        <Div className=\"flex flex-col gap gap-2 border-r border-black overflow-y-auto w-[400px] \">\n          <Div className=\"flex flex-row justify-between items-center\">\n            <P className=\"text-3xl\">Your peers</P>\n            <Div className=\"flex flex-row\">\n              <ClickableIcon\n                emoji=\"ðŸ”„\"\n                onClick={() => {\n                  ///   peers.refetch();\n                }}\n              />\n              <ClickableIcon\n                emoji=\"âž•\"\n                onClick={() => {\n                  router.push(\"/add-peer\");\n                }}\n              />\n              <ClickableIcon\n                emoji=\"ðŸšª\"\n                onClick={() => {\n                  //           logoutFrontend();\n                }}\n              />\n            </Div>\n          </Div>\n          <Div>\n            {/* {peers.data?.result?.peers?.map((peer) => (\n              <PeerComponent\n                key={`peer${peer.id}`}\n                peer={peer}\n                refetch={peers.refetch}\n              />\n            ))} */}\n          </Div>\n        </Div>\n\n        <PeerChat />\n      </Div>\n\n      <AppsMenu />\n    </Div>\n  );\n}"
  },
  "Page": {
    "name": "Page",
    "slug": "TsFunction",
    "id": "dItBLgtWKbbAjyRk",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " () => {\n  const companyQuery = useCompanies();\n  const company = companyQuery.data?.result;\n  const [selectedCompanyId, setSelectedCompanyId] =\n    useStore(\"selectedCompanyId\");\n  const selectedCompany = company?.find(\n    (selectedCompany) => selectedCompany.id === selectedCompanyId\n  );\n\n  /** create columns for table */\n  const columns: ColumnType<Company>[] = [\n    {\n      name: \"Name\",\n      objectParameterKey: \"name\",\n      // targetPageName: \"company\",\n      // presentationType: \"mainLink\",\n      customPresentation: (item) =>\n        renderGetSidePanel(item, \"name\", () => setSelectedCompanyId(item.id)),\n    },\n\n    {\n      name: \"Active in countries\",\n      objectParameterKey: \"contribution_locationSlugsCalculated\",\n      customPresentation: (item) =>\n        renderGetArray(item, \"contribution_locationSlugsCalculated\"),\n    },\n    {\n      name: \"Activities\",\n      objectParameterKey: \"contribution_activitySlugsCalculated\",\n      customPresentation: (item) =>\n        renderGetArray(item, \"contribution_activitySlugsCalculated\"),\n    },\n\n    {\n      name: \"Transparency\",\n      objectParameterKey: \"transparencyPercentageCalculated\",\n      customPresentation: (item) =>\n        renderGetProgressBarSingle(item, \"transparencyPercentageCalculated\"),\n      columnTooltip: true,\n      columnTooltipLabel: \"test\",\n      tableTooltip: true,\n    },\n    {\n      name: \"Environmental\",\n      objectParameterKey: \"environmentalPerformance\",\n      presentationType: \"progressBarMultiple\",\n      label: true,\n    },\n    {\n      name: \"Social\",\n      objectParameterKey: \"socialPerformance\",\n      presentationType: \"progressBarMultiple\",\n      label: true,\n    },\n    {\n      name: \"Open requirements\",\n      objectParameterKey: \"numberOfOpenRequirements\",\n      customPresentation: (item: Company) =>\n        renderGetArrayName(item, \"companyRequirementsCalculated\"),\n      textAfterValue: \"Requirements\",\n    },\n  ];\n\n  console.log(selectedCompany);\n  const tabs: TabType[] = [\n    {\n      id: \"company-info\",\n      label: \"Company info\",\n      data: <CompanyForm companyData={selectedCompany} />,\n    },\n    {\n      id: \"requirements\",\n      label: \"Requirements\",\n      data: (\n        <Requirements\n          requirements={selectedCompany?.companyRequirementsCalculated}\n          companyName={selectedCompany?.name}\n        />\n      ),\n    },\n    {\n      id: \"environmental\",\n      label: \"Environmental\",\n      data: <EsgPerformance />,\n    },\n    {\n      id: \"social\",\n      label: \"Social\",\n      data: <EsgPerformance />,\n    },\n  ];\n\n  return (\n    <MainLayout>\n      <Div className=\"relative\">\n        <>\n          <Div\n            className={` ${\n              selectedCompanyId\n                ? `transition-transform ease-in-out`\n                : `translate-x-full transition-transform ease-in-out duration-500 `\n            }`}\n          >\n            <SidePanel\n              title={selectedCompany?.name}\n              id={selectedCompany?.id}\n              closeSidePanel={() => {\n                setSelectedCompanyId(null);\n              }}\n              tabs={tabs}\n            />\n          </Div>\n        </>\n        <PageHeader\n          title=\"All companies\"\n          description=\"Here you will find everything about your value chain partners\"\n        />\n\n        {company && Array.isArray(company) ? (\n          <Table\n            data={company}\n            containerStyle=\"pl-12 mt-8 max-w-full \"\n            columns={columns}\n          />\n        ) : null}\n      </Div>\n    </MainLayout>\n  );\n}"
  },
  "PeerChat": {
    "name": "PeerChat",
    "slug": "TsFunction",
    "id": "seprzyitleplkrqslkudikkr",
    "description": "",
    "operationName": "peer-web",
    "rawText": " () => {\n  const alert = useAlert();\n  const [message, setMessage] = useState(\"\");\n  const [lateFetchLoading, setLateFetchLoading] = useState(false);\n  const peerMessagesQuery = useQuery(\n    \"getPeerMessages\",\n    () => getPeerMessages(),\n    {\n      refetchInterval: 5000,\n      enabled: true,\n    }\n  );\n  const peersQuery = useQuery(\"getPeers\", () => getPeers(), {\n    enabled: true,\n  });\n\n  const augmentedWordObject = queries.useGetAugmentedWordObject().data?.result;\n\n  const peerMessages = peerMessagesQuery.data?.result;\n\n  const sendMessage = async (message: string) => {\n    const peerSlug = peersQuery.data?.result?.peers?.find((x) => x.isMe)?.slug;\n    if (!peerSlug) {\n      alert?.(\"Please make sure you have added yourself as a peer\");\n      return;\n    }\n    const addMessageResult = await proactivePushAddPeerMessage(\n      message,\n      peerSlug\n    );\n\n    toast({ title: \"\", body: addMessageResult.message || \"Sent message\" });\n  };\n  return (\n    <Div className=\"px-4 w-full h-full overflow-y-auto\">\n      <Div className=\"flex flex-row items-center\">\n        <Div>\n          <Div className={lateFetchLoading ? \"animate-spin\" : undefined}>\n            <ClickableIcon\n              emoji=\"ðŸ”„\"\n              onClick={async () => {\n                setLateFetchLoading(true);\n                const result = await lateFetchPeerMessageSync();\n                await peerMessagesQuery.refetch();\n                setLateFetchLoading(false);\n              }}\n            />\n          </Div>\n        </Div>\n        <Div className=\"w-full\">\n          <Form\n            onSubmit={async (e) => {\n              e.preventDefault();\n              setMessage(\"\");\n              await sendMessage(message);\n              peerMessagesQuery.refetch();\n            }}\n          >\n            <WriterInput\n              value={message}\n              onChange={(message) => setMessage(message)}\n              augmentedWordObject={augmentedWordObject}\n              hideButtons\n              projectRelativeFilePath=\"db/peer-chats.json\"\n              type=\"markdown\"\n            />\n            {/* <TextInput\n              fieldName=\"message\"\n              uniqueFieldId=\"message\"\n              extra={{}}\n              value={message}\n              onChange={(message) => setMessage(message)}\n              config={{}}\n            /> */}\n          </Form>\n        </Div>\n      </Div>\n\n      <Div className=\"overflow-y-scroll\">\n        {peerMessages?.map(PeerMessageComponent)}\n      </Div>\n    </Div>\n  );\n}"
  },
  "PeerComponent": {
    "name": "PeerComponent",
    "slug": "TsFunction",
    "id": "lqkipngetftzdmcjexplophm",
    "description": "",
    "operationName": "peer-web",
    "rawText": " (props: { peer: Peer; refetch: () => void }) => {\n  const { peer, refetch } = props;\n  const router = useRouter();\n  const preferredOrFirstMedium = peer.person?.media?.find((x) =>\n    peer.person?.preferredContactMedium\n      ? x.platformSlug === peer.person?.preferredContactMedium\n      : true\n  );\n\n  return (\n    <Div className=\"border border-black rounded-md m-2 hover:bg-gray-50 p-4\">\n      <Div className=\"flex flex-row justify-between\">\n        <ALink href={`/peer?peer=${peer.slug}`}>\n          <P className=\"font-bold\">\n            {peer.isOnlineCalculated ? \"ðŸŸ¢\" : \"ðŸ”´\"} {peer.peerName}\n          </P>\n        </ALink>\n\n        <Div className=\"flex flex-row\">\n          <ClickableIcon\n            emoji=\"âœï¸\"\n            onClick={() => {\n              router.push(`/update-peer?slug=${peer.slug}`);\n            }}\n          />\n          <ClickableIcon\n            emoji={peer.isFavorite ? \"[x]\" : \"[ ]\"}\n            onClick={async () => {\n              const updateResult = await updatePeer(peer.slug, {\n                isFavorite: !peer.isFavorite,\n              });\n\n              toast({\n                title: \"\",\n                body: updateResult.result?.isSuccesful\n                  ? peer.isFavorite\n                    ? \"Unfavorited\"\n                    : \"Favorited\"\n                  : \"Somethign went wrong\",\n              });\n\n              refetch();\n            }}\n          />\n          <ClickableIcon\n            emoji=\"ðŸ—‘\"\n            onClick={async () => {\n              const removeResult = await removePeer(peer.slug);\n\n              const message = removeResult.result?.isSuccesful\n                ? \"Removed\"\n                : \"Something went wrong\";\n\n              toast({ title: \"\", body: message });\n\n              refetch();\n            }}\n          />\n        </Div>\n      </Div>\n      <P>{peer.name}</P>\n      <P>{peer.person?.name}</P>\n      <P>{peer.person?.address}</P>\n      {preferredOrFirstMedium ? (\n        <P>\n          {preferredOrFirstMedium?.platformSlug}: {preferredOrFirstMedium?.path}\n        </P>\n      ) : null}\n    </Div>\n  );\n}"
  },
  "PeerMessageComponent": {
    "name": "PeerMessageComponent",
    "slug": "TsFunction",
    "id": "sxbksqlbufrcqjmiypgifqrd",
    "description": "",
    "operationName": "peer-web",
    "rawText": " (peerMessage: PeerMessage) => {\n  return (\n    <P>\n      {peerMessage?.peerSlug}: {peerMessage.message}\n    </P>\n  );\n}"
  },
  "Peer": {
    "name": "Peer",
    "slug": "TsFunction",
    "id": "zsothkaewwgbroecnzicseme",
    "description": "",
    "operationName": "peer-web",
    "rawText": " () => {\n  const router = useRouter();\n  const peers = useQuery(\"getPeers\", () => getPeers(), {\n    enabled: true,\n  });\n  const peerQuery = router.query?.peer;\n  const peerSlug = Array.isArray(peerQuery) ? peerQuery[0] : peerQuery;\n  const peer = peers.data?.result?.peers?.find((x) => x.slug === peerSlug);\n\n  return (\n    <Div className=\"flex flex-row justify-between\">\n      <Div>\n        <P className=\"text-3xl flex flex-row\">\n          <ALink href=\"/\">â¬…</ALink>\n          {peer ? peer.peerName : `${peerSlug} is offline`}\n        </P>\n\n        <Div>\n          {peer?.appOperationsCalculated?.map((appOperation, index) => {\n            return (\n              <Div\n                key={`peer${peer.id}app${index}`}\n                className=\"flex flex-row justify-between hover:bg-blue-200\"\n              >\n                <P>{appOperation.name}</P>\n                {appOperation.isOnline ? (\n                  <ClickableIcon\n                    emoji=\"ðŸŒ\"\n                    onClick={() => {\n                      window.open(\n                        `http://${peer.name}:${appOperation.port}`,\n                        \"_blank\"\n                      );\n                    }}\n                  />\n                ) : null}\n              </Div>\n            );\n          })}\n        </Div>\n      </Div>\n\n      <Div className=\"w-60\">\n        {peerSlug ? <PublicMenu peerSlug={peerSlug} /> : null}\n      </Div>\n    </Div>\n  );\n}"
  },
  "PublicMenu": {
    "name": "PublicMenu",
    "slug": "TsFunction",
    "id": "gbgrftanawxrdznkowrascbi",
    "description": "",
    "operationName": "peer-web",
    "rawText": " (props: { peerSlug: string }) => {\n  const { peerSlug } = props;\n  const [errorMessage, setErrorMessage] = useState(\"\");\n  const [nestedPathObject, setNestedPathObject] =\n    useState<NestedPathObject | null>(null);\n  const [loading, setLoading] = useState(false);\n\n  useEffect(() => {\n    if (!peerSlug) return;\n\n    setLoading(true);\n\n    api.getPublicFolderNestedPathObjectFromPeer(peerSlug).then((response) => {\n      const { result } = response;\n\n      console.dir({ response }, { depth: 999 });\n      const defaultErrorMessage =\n        \"Could not load the public folder from your peer, make sure your peer is connected (and you are too)\";\n      if (!result) {\n        setErrorMessage(defaultErrorMessage);\n        setLoading(false);\n\n        return;\n      }\n\n      const {\n        peerApiResult: { result: nestedPathObject },\n      } = result;\n\n      if (!nestedPathObject) {\n        setErrorMessage(defaultErrorMessage);\n        setLoading(false);\n\n        return;\n      }\n\n      setNestedPathObject(nestedPathObject);\n\n      setLoading(false);\n    });\n  }, [peerSlug]);\n\n  const menu = nestedPathObjectToNestedMenuRecursive(\n    nestedPathObject,\n    undefined,\n    {\n      getHref: (fullPath) =>\n        `http://localhost:${ports[\"function-server\"]}/${fullPath}`,\n      target: \"_blank\",\n    }\n  );\n\n  return menu ? (\n    <NestedMenu items={menu} headersClickable={false} />\n  ) : loading ? (\n    <FancyLoader />\n  ) : (\n    <P>{errorMessage || \"something went wrong\"}</P>\n  );\n}"
  },
  "{ removePeer, updatePeer }": {
    "name": "{ removePeer, updatePeer }",
    "slug": "TsVariable",
    "id": "ttcrismnjovaduhugwpzjsgp",
    "description": "",
    "operationName": "peer-web"
  },
  "getPrimaryPersona": {
    "name": "getPrimaryPersona",
    "slug": "TsFunction",
    "id": "eunxedbgfzpuvhrksjyhcdge",
    "description": "",
    "operationName": "persona-functions-node",
    "rawText": " async () => {\n  const personas = await db.get(\"Persona\");\n\n  const primary = personas.find((x) => x.isPrimary) || personas[0];\n\n  if (!primary) {\n    console.log(\"No primary persona found\");\n  }\n\n  return primary;\n}"
  },
  "youtubeToPlayItem": {
    "name": "youtubeToPlayItem",
    "slug": "TsFunction",
    "id": "odmbledfxfwkrsdqilxyjvil",
    "description": "",
    "operationName": "play-import-node",
    "rawText": " async (\n  youtubeUrl: string,\n  artistId?: string,\n  isNewArtist?: boolean,\n  artistName?: string,\n  playItemName?: string\n) => {\n  const name = artistName || \"Unknown Artist\";\n  const foundArtist = (await db.get(\"Artist\")).find(\n    (x) => x.id === artistId && !!artistId\n  );\n\n  const noNewArtist = !isNewArtist && !!artistId && !!foundArtist;\n\n  // TODO: remove required things from person because artists also need to be persons that would never login\n  // @ts-ignore\n  const artist: Creation<Artist> = noNewArtist\n    ? foundArtist\n    : { name, slug: slugify(name), id: generateId() };\n\n  if (!noNewArtist) {\n    const upsertResult = await db.upsert(\"Artist\", artist);\n  }\n\n  const result = await youtubeToMp3(youtubeUrl);\n\n  if (!result.mp3FilePath) {\n    return { isSuccessful: false, message: result.message };\n  }\n\n  // TODO: make processAsset capable of processing it from a custom path\n  // const playAsset = processAsset({temporaryDestination,modelName:\"PlayItem\",projectRelativeReferencingFilePath})\n  // const playItem: Creation<PlayItem> = { artistId: artist.id, playAsset};\n}"
  },
  "getDayNumber": {
    "name": "getDayNumber",
    "slug": "TsFunction",
    "id": "ucbvyvudogcxtkayxjteyyie",
    "description": "",
    "operationName": "reminder-node",
    "rawText": " (dayEnumString: Day): number => {\n  if (dayEnumString === \"sunday\") return 0;\n  if (dayEnumString === \"monday\") return 1;\n  if (dayEnumString === \"tuesday\") return 2;\n  if (dayEnumString === \"wednesday\") return 3;\n  if (dayEnumString === \"thursday\") return 4;\n  if (dayEnumString === \"friday\") return 5;\n  if (dayEnumString === \"saturday\") return 6;\n  //   never happens\n  return 0;\n}"
  },
  "remindMe": {
    "name": "remindMe",
    "slug": "TsFunction",
    "id": "csgbfkbgvuyzerhgixylpoqh",
    "description": "---\nrunEveryPeriod: hour\n---\n\nTODO: Add macos notification support",
    "operationName": "reminder-node",
    "rawText": " async () => {\n  console.log(\"remindMe function called\");\n\n  const reminders = await db.get(\"RecurringReminder\");\n\n  const nowUnix = Date.now();\n  const now = new Date(nowUnix);\n\n  const date = now.getDate();\n  const hour = now.getHours();\n  const day = now.getDay();\n\n  const remindersNow = reminders.filter((reminder) => {\n    if (reminder.singleDatetimeAt) {\n      const diff = nowUnix - reminder.singleDatetimeAt;\n\n      if (diff > 60000) return false;\n      // less than a minute difference, this thing is probably at most a second slow so that's fine.\n\n      // it's now! remind!\n      return true;\n    }\n\n    const rightHour = reminder.hours ? reminder.hours.includes(hour) : true;\n    const rightDay = reminder.days\n      ? reminder.days.map(getDayNumber).includes(day)\n      : true;\n    const rightDate = reminder.dates ? reminder.dates.includes(date) : true;\n\n    const rightEverything = rightHour && rightDay && rightDate;\n\n    return rightEverything;\n  });\n\n  oneByOne(remindersNow, async (reminder) => {\n    const text = `I'm reminding you: ${reminder.name}... ${reminder.description}`;\n    console.log(text);\n    await saySomething(text);\n\n    if (reminder.singleDatetimeAt) {\n      await db.remove(\"RecurringReminder\", (item) => item.id === reminder.id);\n    }\n  });\n\n  if (remindersNow.length === 0) {\n    const text = \"No reminders this hour, you're awesome\";\n    console.log(text);\n    // await saySomething(text);\n  }\n}"
  },
  "MatchingText": {
    "name": "MatchingText",
    "slug": "TsFunction",
    "id": "puocfhxxjgehwontujayxmsr",
    "description": "Component that highlights the matching text",
    "operationName": "file-search",
    "rawText": " (props: {\n  text: string;\n  search: string;\n  defaultTextClassName: string;\n  matchTextClassName: string;\n  truncateLength?: number;\n}) => {\n  const {\n    truncateLength,\n    text,\n    defaultTextClassName,\n    matchTextClassName,\n    search,\n  } = props;\n\n  // 1: find index of search in text\n  const matchIndex = text.toLowerCase().indexOf(search.toLowerCase());\n\n  // 2: find stuff before that and after that\n  const beforeText = text.slice(0, matchIndex);\n  const afterText = text.slice(matchIndex + search.length);\n  const matchText = text.slice(matchIndex, matchIndex + search.length);\n\n  const totalLength = beforeText.length + search.length + afterText.length;\n\n  const reduceCharactersAmount = truncateLength\n    ? totalLength - truncateLength\n    : 0;\n\n  const beforeTextLengthPercentage =\n    beforeText.length / (beforeText.length + afterText.length);\n  const afterTextLengthPercentage =\n    afterText.length / (beforeText.length + afterText.length);\n\n  const reduceBeforeCharacters = Math.round(\n    beforeTextLengthPercentage * reduceCharactersAmount\n  );\n  const reduceAfterCharacters = Math.round(\n    afterTextLengthPercentage * reduceCharactersAmount\n  );\n\n  const truncatedBeforeText =\n    reduceBeforeCharacters > beforeText.length && truncateLength\n      ? beforeText.slice(0, beforeText.length - reduceBeforeCharacters - 2) +\n        \"..\"\n      : beforeText;\n  const truncatedAfterText =\n    truncateLength && reduceAfterCharacters > afterText.length\n      ? \"..\" + afterText.slice(afterText.length - reduceAfterCharacters - 2)\n      : afterText;\n\n  // 3: render before, match, and after\n  return matchIndex === -1 ? (\n    // with no match, truncate at truncateLength at the end\n    <P title={text} className={defaultTextClassName}>\n      {truncateLength && text.length > truncateLength\n        ? text.substring(0, truncateLength - 2) + \"..\"\n        : text}\n    </P>\n  ) : (\n    /**\n     * with a match, the total length needs to be `truncateLength`\n     *\n     * the `search` result should not be truncated\n     *\n     * `beforeText` should be truncated at the end to reduce to `truncateLength`\n     * `afterText` should be truncated at the beginning to reduce to `truncateLength`\n     *\n     * it should be truncated as much as needed on both sides, but we must take into account at the length of the sides as well\n     */\n    <P\n      title={text} //`(${reduceCharactersAmount}== ${reduceBeforeCharacters} <> ${reduceAfterCharacters} .... ${beforeTextLengthPercentage}, ${afterTextLengthPercentage}) ${text}`\n      className={defaultTextClassName}\n    >\n      {beforeText}\n      <Span className={matchTextClassName}>{matchText}</Span>\n      {afterText}\n    </P>\n  );\n}"
  },
  "PathSearchResults": {
    "name": "PathSearchResults",
    "slug": "TsFunction",
    "id": "mklvowbfccsjswctoevmfojn",
    "description": "",
    "operationName": "file-search",
    "rawText": " (props: {\n  paths: string[];\n  search: string;\n  augmentedWords?: AugmentedWord[];\n}) => {\n  const { paths, search, augmentedWords } = props;\n\n  /**\n   * TODO: include this in the results somehow nicely...\n   */\n  const augmentedWordResults = augmentedWords?.filter((x) => {\n    const word = x.isCaseInsensitive ? x.word.toLowerCase() : x.word;\n    const searchQuery = x.isCaseInsensitive ? search.toLowerCase() : search;\n\n    const isMatch = word.includes(searchQuery);\n\n    return isMatch;\n  });\n\n  const results = paths\n    .map((path) => {\n      const augmentedWordsThisPath = augmentedWordResults?.filter(\n        (x) => x.queryPath === path\n      );\n\n      return { path, augmentedWordsThisPath };\n    })\n    .filter((item) => {\n      const isPathMatch = item.path\n        .toLowerCase()\n        .includes(search.toLowerCase());\n      const isMatch = item.augmentedWordsThisPath?.length || isPathMatch;\n\n      return isMatch;\n    })\n    .slice(0, 100);\n\n  return (\n    <Div>\n      {results.map((item) => {\n        const filename = item.path.split(\"/\").pop()!;\n\n        return (\n          <ALink href={`/${item.path}`}>\n            <Div className=\"px-2 hover:dark:bg-gray-600\">\n              <MatchingText\n                truncateLength={30}\n                text={filename}\n                search={search}\n                defaultTextClassName=\"\"\n                matchTextClassName=\"text-blue-500\"\n              />\n\n              <MatchingText\n                truncateLength={30}\n                text={item.path}\n                search={search}\n                defaultTextClassName=\"text-xs\"\n                matchTextClassName=\"text-blue-500\"\n              />\n\n              {item.augmentedWordsThisPath?.map((augmentedWord) => {\n                return (\n                  <MatchingText\n                    truncateLength={30}\n                    text={augmentedWord.word}\n                    search={search}\n                    defaultTextClassName=\"text-xs\"\n                    matchTextClassName=\"text-blue-500\"\n                  />\n                );\n              })}\n            </Div>\n          </ALink>\n        );\n      })}\n    </Div>\n  );\n}"
  },
  "example": {
    "name": "example",
    "slug": "TsVariable",
    "id": "qidtmencvmxdwydwtaqoubwo",
    "description": "",
    "operationName": "search"
  },
  "findSentenceMatches": {
    "name": "findSentenceMatches",
    "slug": "TsFunction",
    "id": "fipmrfxwfnxnhmjhknwtphaa",
    "description": "finds matches of a searchMessage in an array, looking at the individual words.\n\nif your search matches some words in a sentence, it's a match, as long as all your words you entered are also a word in the sentence\n\nNB: this could be augmented with things like synonyms and translation",
    "operationName": "search",
    "rawText": " <T>(\n  /**\n   * a message the user is searching for\n   */\n  searchMessage: string,\n  /**\n   * an array that should be filtered.\n   */\n  array: T[],\n  /**\n   * optionally, if the array doesn't contain strings of sentences already, you can provide a map function here that returns a sentence from an item in that array\n   */\n  getSentence?: (x: T) => string\n): T[] => {\n  const messageWords = lowerCaseArray(searchMessage);\n\n  const matches = array.filter((item) => {\n    const sentence = getSentence\n      ? getSentence(item)\n      : typeof item === \"string\"\n      ? item\n      : null;\n    if (!sentence) return false;\n\n    const sentenceWords = lowerCaseArray(sentence);\n    const sentenceIncludesMessage = messageWords.reduce(\n      (includesAll, messageWord) => {\n        // TODO: later we can use synonyms here\n        return includesAll && sentenceWords.includes(messageWord);\n      },\n      true\n    );\n\n    return sentenceIncludesMessage;\n  });\n\n  return matches;\n}"
  },
  "magicalRecursiveReducer": {
    "name": "magicalRecursiveReducer",
    "slug": "TsFunction",
    "id": "jdagegacgwshpeyygpqrckwd",
    "description": "Reduces an object with children of its own type according to a baseMatcher.\n\nThe object only gets returned if the children have a match (or their children, etc) or if the object itself is a match. If the object itself is a match, its children will also be edited to filter out non-matching things\n\nNB: Not finished yet (see todo).\n\nAlso not sure if the final UX is really as great and performant as I wish, so it may be easier to simply have a separate search for files and global (just like vscode has)",
    "operationName": "search",
    "rawText": " <T extends { children?: T[] } & Object>(\n  previous: T[],\n  current: T,\n  baseMatcher: (item: T) => boolean\n): T[] => {\n  // NB: copy!\n  const newCurrent = { ...current };\n\n  newCurrent.children = newCurrent.children\n    ? newCurrent.children.reduce(\n        (p, c) => magicalRecursiveReducer(p, c, baseMatcher),\n        [] as T[]\n      )\n    : undefined;\n\n  if (baseMatcher(newCurrent) || newCurrent.children?.length) {\n    previous.push(newCurrent);\n  }\n\n  return previous;\n}"
  },
  "searchRecursiveObjectArray": {
    "name": "searchRecursiveObjectArray",
    "slug": "TsFunction",
    "id": "dsocsicrchkhsxkzwortyffr",
    "description": "",
    "operationName": "search",
    "rawText": " <\n  T extends { children?: T[] } & Object\n>(\n  array: T[],\n  baseMatcher: (item: T) => boolean,\n  /**\n   * optionally, item can be mapped to add some info after match is found or not\n   */\n  afterMapper?: (item: T, isMatch: boolean, hasChildMatch: boolean) => T\n) => {\n  return array.reduce(\n    (previous, current) =>\n      magicalRecursiveReducer(previous, current, baseMatcher),\n    [] as T[]\n  );\n}"
  },
  "getAllSearchResults": {
    "name": "getAllSearchResults",
    "slug": "TsFunction",
    "id": "dktpevfeijbltuuhdtxkxfsz",
    "description": "Searches filepaths, then links to any `ui-web` that has this file available as a page, or VSCode.\n\nFor this we need to get the `MarkdownReaderPage` and other pages that are available in ui's and see the files they are linked to.\n\nI want to be able to:\n\n- search functions, interfaces, variables\n- search operations\n- search markdown files, anywhere\n- search db-ui models\n\nBut there's more. To make a good serach...\n\nTODO:\n- gather everything i've made before about search",
    "operationName": "search-web",
    "rawText": " (\n  query: string | null\n): SearchResult[] | undefined => {\n  return [\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n  ];\n}"
  },
  "getTimelineItems": {
    "name": "getTimelineItems",
    "slug": "TsFunction",
    "id": "kfqmxyqwlwtqehtukfgblrwa",
    "description": "",
    "operationName": "search-web",
    "rawText": " async () => {\n  const comments = await db.get(\"TsComment\");\n\n  const items = comments\n    .filter((x) => x.types.includes(\"todo\"))\n    .map((x) => {\n      const isMultiLine = x.firstLine !== x.lastLine;\n\n      const operationPath =\n        operations[x.operationName as keyof typeof operations];\n\n      const comment = isMultiLine\n        ? `/**\\n${x.comment}\\n*/\\n\\n${x.rawStatement}`\n        : `// ${x.comment} \\n ${x.rawStatement}`;\n\n      const filePath = operationPath\n        ? path.join(operationPath, x.operationRelativeTypescriptFilePath)\n        : undefined;\n      return {\n        comment,\n        filePath,\n        line: x.firstLine,\n      };\n    });\n\n  return items;\n}"
  },
  "mindspaces": {
    "name": "mindspaces",
    "slug": "TsVariable",
    "id": "gohlkgjwvgdcrvrlrdwcmgyd",
    "description": "",
    "operationName": "search-web"
  },
  "quotes": {
    "name": "quotes",
    "slug": "TsVariable",
    "id": "radffkpmgvgoqvorhiekgrcl",
    "description": "",
    "operationName": "search-web"
  },
  "SearchBar": {
    "name": "SearchBar",
    "slug": "TsFunction",
    "id": "yzbvnkuwwnznkmbkmzehvmbm",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (props: {\n  initialValue?: string;\n  placeholder?: string;\n}) => {\n  const { initialValue, placeholder } = props;\n  const [tempSearch, setTempSearch] = useState(initialValue || \"\");\n\n  const [search, setSearch] = useStore(\"db-crud.search\");\n\n  const go = () => {\n    setSearch(tempSearch);\n  };\n\n  const clearSearch = () => setSearch(\"\");\n\n  return (\n    <Div className=\"rounded-full border border-zinc-700 dark:border-zinc-300 p-1 px-3 text-lg hover:bg-zinc-200 dark:hover:bg-zinc-800 bg-zinc-100 dark:bg-zinc-600 dark flex flex-row max-w-xl mx-4\">\n      {search.length > 0 ? (\n        <Div\n          className={`cursor-pointer pr-2`}\n          onClick={() => {\n            setSearch(\"\");\n            setTempSearch(\"\");\n          }}\n        >\n          ðŸ—‘\n        </Div>\n      ) : null}\n      <Form\n        onSubmit={(e) => {\n          e.preventDefault();\n          go();\n        }}\n      >\n        <Input\n          placeholder={placeholder || \"Search\"}\n          className=\"flex flex-1 bg-transparent focus:outline-none\"\n          value={tempSearch}\n          onChange={(e) => setTempSearch(e.target.value)}\n        />\n      </Form>\n      <Div\n        className={\n          tempSearch.length === 0 ? \"cursor-default\" : \"cursor-pointer\"\n        }\n        onClick={go}\n      >\n        ðŸ”Ž\n      </Div>\n    </Div>\n  );\n}"
  },
  "searchGetStaticProps": {
    "name": "searchGetStaticProps",
    "slug": "TsFunction",
    "id": "srjmwjzjekgaqhlyscffpfab",
    "description": "",
    "operationName": "search-web",
    "rawText": " async (\n  context\n) => {\n  const query = takeFirst(context.params?.query) || null;\n\n  const imagePaths = await fs.readdir(\n    path.join(__dirname, \"../../..\", \"public/headers\")\n  );\n  const searchResults = getAllSearchResults(query) || null;\n\n  const timelineItems: {\n    comment: string;\n    filePath: string | undefined;\n    line: number;\n  }[] = []; // = await getTimelineItems();\n\n  const props: QueryPageProps = {\n    query,\n    searchResults,\n    imagePaths,\n    timelineItems,\n  };\n\n  return {\n    props,\n  };\n}"
  },
  "SearchResultComponent": {
    "name": "SearchResultComponent",
    "slug": "TsFunction",
    "id": "thpepedlnadjnnkeusvhjkzc",
    "description": "If you click on a site that up and running, it should startup via pm2 before being redirected there",
    "operationName": "search-web",
    "rawText": " (props: {\n  searchResult: SearchResult;\n  index: number;\n}) => {\n  const { index, searchResult } = props;\n  return <Div key={`searchhit${index}`}>hit {index}</Div>;\n}"
  },
  "SearchResultPage": {
    "name": "SearchResultPage",
    "slug": "TsFunction",
    "id": "wjcovbfsivmbavpkqoslbamy",
    "description": "",
    "operationName": "search-web",
    "rawText": " (props: QueryPageProps) => {\n  const { query, searchResults } = props;\n  const router = useRouter();\n  return (\n    <Div>\n      <Div className=\"flex w-full justify-between\">\n        <Div\n          className=\"text-3xl p-2 cursor-pointer\"\n          onClick={() => router.push(\"/\")}\n        >\n          ðŸ \n        </Div>\n        <SearchBar initialValue={query || undefined} />\n        <Div />\n      </Div>\n      <a\n        className=\"text-blue-500\"\n        href={`https://www.google.nl/search?q=${query}`}\n      >\n        {query}\n      </a>\n      {searchResults?.map((searchResult, index) => {\n        return (\n          <SearchResultComponent\n            key={`s${index}`}\n            index={index}\n            searchResult={searchResult}\n          />\n        );\n      })}\n    </Div>\n  );\n}"
  },
  "Timeline": {
    "name": "Timeline",
    "slug": "TsFunction",
    "id": "ckzjkrnuzkfyacitwlukxqwa",
    "description": "",
    "operationName": "timeline",
    "rawText": " (props: {\n  items: TimelineItemType[];\n  isHorizontal?: boolean;\n}) => {\n  const { items, isHorizontal } = props;\n  return (\n    <div\n      className={`flex ${\n        isHorizontal ? \"snap-x flex-row\" : \"snap-y flex-col\"\n      } snap-mandatory h-screen w-full mx:auto overflow-scroll`}\n    >\n      {items.map((item, index) => {\n        return (\n          <Div\n            key={`timeline-item-${index}`}\n            className=\"snap-start shrink-0 w-screen h-screen place-items-center\"\n            style={{\n              backgroundImage: item.imageUrl\n                ? `url(\"${item.imageUrl}\")`\n                : undefined,\n              backgroundRepeat: \"no-repeat\",\n              backgroundSize: \"cover\",\n              backgroundPosition: \"center 75%\",\n            }}\n          >\n            {item.component ? (\n              item.component()\n            ) : (\n              <Div\n                className=\"max-w-[80vw]\"\n                onClick={() => {\n                  console.log(\"supposed to open\", item);\n                  api.vscodeOpen({\n                    files: [\n                      {\n                        projectRelativePath: item.projectRelativeFilePath,\n                        line: item.line,\n                      },\n                    ],\n                  });\n                }}\n              >\n                <MarkdownCodeblock\n                  text={item.markdown || \"Nothing to show\"}\n                  isModeStatic\n                  minimalMode=\"scroll\"\n                  extension=\"tsx\"\n                />\n              </Div>\n            )}\n          </Div>\n        );\n      })}\n    </div>\n  );\n}"
  },
  "getPostableFrontmatterSchema": {
    "name": "getPostableFrontmatterSchema",
    "slug": "TsFunction",
    "id": "mawlskwfwkmfuootgdfxxjfv",
    "description": "Used for rendering a nice form for every postable in the `social-media-ui`",
    "operationName": "social-media-functions",
    "rawText": " (): Promise<\n  SimplifiedSchema | undefined\n> => {\n  return getFrontmatterSchema(\"Postable\");\n}"
  },
  "frontmatterParseToString": {
    "name": "frontmatterParseToString",
    "slug": "TsFunction",
    "id": "qidilrxishqgdkqschcjxapn",
    "description": "Parses frontmatter object into a frontmatter string",
    "operationName": "frontmatter-util",
    "rawText": " (frontmatter: Frontmatter): string => {\n  const keys = Object.keys(frontmatter);\n\n  const keyValueLines = keys\n    .map((key) => {\n      const value = frontmatter[key];\n\n      const parsedFrontmatterLine = `${key}: ${value}`;\n\n      return parsedFrontmatterLine;\n    })\n    .filter(notEmpty);\n\n  return keyValueLines.length === 0\n    ? \"\"\n    : `---\\n${keyValueLines.join(\"\\n\")}\\n---\\n`;\n}"
  },
  "frontmatterToObject": {
    "name": "frontmatterToObject",
    "slug": "TsFunction",
    "id": "rfpqlcnfejqduassieufjsif",
    "description": "",
    "operationName": "frontmatter-util",
    "rawText": " (\n  frontmatter: Frontmatter,\n  schema: SimplifiedSchema\n): FrontmatterParse => {\n  if (!schema.properties || !schema.properties.length) {\n    return {};\n  }\n\n  const valueObjectArray: { [key: string]: any }[] = schema.properties\n    .map((property) => {\n      const value = frontmatter[property.name]\n        ? frontmatter[property.name].trim()\n        : undefined;\n\n      if (value === undefined) return;\n\n      const assetInputType = getAssetInputType(property.name);\n\n      if (\n        (property.schema.type === \"object\" ||\n          property.schema.type === \"array\") &&\n        assetInputType?.type\n      ) {\n        // it's a backendAsset\n\n        const backendAssets: BackendAsset[] = findEmbeds(value).map((x) => {\n          return { alt: x.alt, relativePath: x.src };\n        });\n\n        if (backendAssets.length === 0) return;\n\n        if (assetInputType.isMultiple) {\n          return { [property.name]: backendAssets };\n        }\n\n        return { [property.name]: backendAssets[0] };\n      }\n\n      if (property.schema.type === \"number\" && property.name.endsWith(\"At\")) {\n        const unixTimestamp = tryParseDate(value);\n\n        return { [property.name]: unixTimestamp };\n      }\n\n      if (property.schema.type === \"boolean\") {\n        if (value === \"true\") return { [property.name]: true };\n        if (value === \"false\") return { [property.name]: false };\n        return;\n      }\n\n      if (property.schema.type === \"number\") {\n        const number = Number(value);\n\n        if (isNaN(number)) return;\n\n        return { [property.name]: number };\n      }\n\n      if (property.schema.type === \"null\") {\n        if (value !== \"null\") {\n          return;\n        }\n\n        return { [property.name]: null };\n      }\n\n      if (property.schema.type === \"string\") {\n        return { [property.name]: parseFrontmatterString(value) };\n      }\n\n      if (property.schema.type === \"array\") {\n        // turn into comma separated\n        // Let's only support string[] for now!\n\n        const itemString = value\n          .split(\",\")\n          .map((x) => x.trim())\n          .map(parseFrontmatterString);\n\n        return { [property.name]: itemString };\n      }\n\n      if (property.schema.type === \"object\") {\n        // should not be supported\n        return;\n      }\n\n      return;\n    })\n    .filter(notEmpty);\n\n  const parse = mergeObjectsArray(valueObjectArray);\n\n  return parse;\n}"
  },
  "getFrontmatterValueString": {
    "name": "getFrontmatterValueString",
    "slug": "TsFunction",
    "id": "mhgmohwspvtffzyizpqfyhkq",
    "description": "",
    "operationName": "frontmatter-util",
    "rawText": " (\n  value: FrontmatterValue\n): string | null => {\n  if (value === undefined) return null;\n  if (value === null) return \"null\";\n  if (typeof value === \"number\") return String(value);\n  if (typeof value === \"boolean\") return String(value);\n  if (typeof value === \"boolean\") return String(value);\n  if (Array.isArray(value))\n    return value.map(quotedOrNot).map(stringifyNewlines).join(\", \");\n  if (typeof value === \"string\") return stringifyNewlines(quotedOrNot(value));\n  // NB: according to current support this should never happen\n  if (typeof value === \"object\") return `\"${JSON.stringify(value)}\"`;\n\n  return null;\n}"
  },
  "objectToFrontmatter": {
    "name": "objectToFrontmatter",
    "slug": "TsFunction",
    "id": "djhcjeznmgpgckajosirviwv",
    "description": "",
    "operationName": "frontmatter-util",
    "rawText": " (\n  parse: FrontmatterParse,\n  schema: SimplifiedSchema\n): Frontmatter => {\n  if (!schema.properties || !schema.properties.length) {\n    return {};\n  }\n\n  const propertyStringValueArray: { [key: string]: string }[] =\n    schema.properties\n      .map((property) => {\n        const value = parse[property.name];\n\n        const assetInputType = getAssetInputType(property.name);\n\n        if (\n          (property.schema.type === \"object\" ||\n            property.schema.type === \"array\") &&\n          assetInputType?.type\n        ) {\n          // it's a backendAsset\n\n          const realValue = value as BackendAsset | BackendAsset[] | undefined;\n\n          if (!realValue || typeof realValue !== \"object\") {\n            // must be an array or object, otherwise it's set to nothing\n            return;\n          }\n\n          const backendAssets = makeArray(realValue);\n\n          return {\n            [property.name]: backendAssets\n              .map((backendAsset) => {\n                return `![${backendAsset.alt || \"\"}](${\n                  backendAsset.relativePath || \"\"\n                })`;\n              })\n              .join(\", \"),\n          };\n        }\n\n        if (property.schema.type === \"number\" && property.name.endsWith(\"At\")) {\n          if (typeof value !== \"number\" || (!value && value !== 0)) {\n            // we can only process numbers\n            return;\n          }\n\n          // it's a date, convert to date\n\n          const humanReadableDate = new Date(value).toDateString();\n          return { [property.name]: humanReadableDate };\n        }\n\n        if (property.schema.type === \"boolean\") {\n          if (value === true) return { [property.name]: \"true\" };\n          if (value === false) return { [property.name]: \"false\" };\n          return;\n        }\n\n        if (property.schema.type === \"number\") {\n          if (typeof value !== \"number\" || (!value && value !== 0)) {\n            // we can only process numbers\n            return;\n          }\n\n          return { [property.name]: String(value) };\n        }\n\n        if (property.schema.type === \"null\") {\n          if (value !== null) {\n            return;\n          }\n\n          return { [property.name]: \"null\" };\n        }\n\n        if (property.schema.type === \"string\") {\n          if (typeof value !== \"string\") {\n            return;\n          }\n          return { [property.name]: quotedOrNot(stringifyNewlines(value)) };\n        }\n\n        if (property.schema.type === \"array\") {\n          // turn into comma separated\n\n          if (!Array.isArray(value)) {\n            return;\n          }\n\n          // Let's only support string[] for now!\n          //   const type = property.schema.items?.map(x=>x.schema)?.[0]\n\n          const itemString = value\n            .map((item: any) => {\n              if (typeof item !== \"string\") return;\n\n              return quotedOrNot(stringifyNewlines(item));\n            })\n            .filter(notEmpty)\n            .join(\", \");\n\n          return { [property.name]: itemString };\n        }\n\n        if (property.schema.type === \"object\") {\n          // should not be supported\n          return;\n        }\n\n        return;\n      })\n      .filter(notEmpty);\n\n  const frontmatter = mergeObjectsArray(propertyStringValueArray);\n\n  return frontmatter;\n}"
  },
  "parseFrontmatterString": {
    "name": "parseFrontmatterString",
    "slug": "TsFunction",
    "id": "fdszaogwgndsejvmthlakkki",
    "description": "Parse a string as stored in frontmatter back to the original string",
    "operationName": "frontmatter-util",
    "rawText": " (value: string) => {\n  const withoutQuotes = value.includes(\",\")\n    ? value.substring(1, value.length - 1)\n    : value;\n\n  const withNewlines = withoutQuotes.replaceAll(\"\\\\n\", \"\\n\");\n\n  return withNewlines;\n}"
  },
  "quotedOrNot": {
    "name": "quotedOrNot",
    "slug": "TsFunction",
    "id": "jylcmtshvkcwtdvjeiuilwot",
    "description": "For now, simply quote a string if it contains commas\n\nThere are probably more edgecases that need to be fixed here",
    "operationName": "frontmatter-util",
    "rawText": " (string: string) => {\n  const returnString = string?.includes(\",\") ? `\"${string}\"` : string;\n  return returnString;\n}"
  },
  "stringifyNewlines": {
    "name": "stringifyNewlines",
    "slug": "TsFunction",
    "id": "fiupbrbzjcgkxaxgurxoupfk",
    "description": "",
    "operationName": "frontmatter-util",
    "rawText": " (string: string) => {\n  return string.replaceAll(\"\\n\", \"\\\\n\");\n}"
  },
  "ShortMarkdownPlayer": {
    "name": "ShortMarkdownPlayer",
    "slug": "TsFunction",
    "id": "ippredcoarayxwmkolykyuaa",
    "description": "",
    "operationName": "short-markdown-writer-input",
    "rawText": " (props: {\n  shortMarkdown?: ShortMarkdown;\n  projectRelativeFilePath?: string;\n}) => {\n  const { shortMarkdown, projectRelativeFilePath } = props;\n  const [slide, setSlide] = useState<number | null>(null);\n\n  const audioUrls =\n    shortMarkdown?.audioWithViewsArray\n      .filter((x) => !!x.audioPath)\n      .map((x) => {\n        if (!x.audioPath || !projectRelativeFilePath) return;\n\n        const src = getSrc(\n          { relativePath: x.audioPath },\n          projectRelativeFilePath\n        ).src;\n\n        return { audioKey: x.audioKey, src };\n      })\n      .filter(notEmpty) || [];\n\n  const audioPlayer = useMultiAudio(audioUrls.map((x) => x.src));\n\n  const items = shortMarkdown?.audioWithViewsArray\n    .map((x) => x.viewEmbeds)\n    .flat();\n\n  useEffect(() => {\n    if (!items) return;\n    if (slide === null) return;\n    // 1 - find corresponding item\n    const item = items[slide];\n\n    // 2 - find the audio connected to it and where it should start for that audio\n    const audioIndex = audioUrls.findIndex((x) => x.audioKey === item.audioKey);\n\n    if (audioIndex === -1) return;\n\n    // 3 - stop the previous audio, start next audio\n    audioPlayer.toggle(audioIndex)();\n  }, [slide]);\n\n  if (!shortMarkdown) return null;\n  if (!projectRelativeFilePath) return null;\n  if (!items) return null;\n\n  return (\n    <Div className=\"h-[80vh] overflow-auto snap-mandatory snap-y\">\n      {items.map((item, index) => {\n        return (\n          <div id={`slide${index}`}>\n            <ShortMarkdownSlide\n              projectRelativeFilePath={projectRelativeFilePath}\n              setSlide={setSlide}\n              isAutoplay\n              item={item}\n              index={index}\n              key={`slidekey${index}`}\n            />\n          </div>\n        );\n      })}\n    </Div>\n  );\n}"
  },
  "ShortMarkdownSlide": {
    "name": "ShortMarkdownSlide",
    "slug": "TsFunction",
    "id": "nrsakmgdikpnrrhuxluwnjiq",
    "description": "",
    "operationName": "short-markdown-writer-input",
    "rawText": " (props: {\n  item: ViewEmbed;\n  index: number;\n  projectRelativeFilePath: string;\n  setSlide: (index: number) => void;\n  isAutoplay?: boolean;\n}) => {\n  const { item, index, projectRelativeFilePath, setSlide, isAutoplay } = props;\n\n  const [timeoutRef, setTimeoutRef] = useState<NodeJS.Timeout | null>(null);\n  const slideRef = useRef<HTMLDivElement>(null);\n  const isOnScreen = useOnScreen(slideRef);\n\n  useEffect(() => {\n    if (isOnScreen) {\n      setSlide(index);\n\n      const durationMs = item.durationMs;\n\n      console.log({ index, durationMs });\n\n      if (!durationMs) {\n        return;\n      }\n\n      const timeout = setTimeout(() => {\n        if (isAutoplay) {\n          console.log(\"times up, should scroll to next!\");\n          setSlide(index + 1);\n\n          const nextElement = document.getElementById(`slide${index + 1}`);\n\n          if (!nextElement) {\n            console.log(\"Couldn't find next\");\n            return;\n          }\n\n          console.log(\n            \"scrolling into view the next element\",\n            nextElement.id,\n            \"????\",\n            nextElement.getBoundingClientRect()\n          );\n\n          nextElement.scrollIntoView({ behavior: \"smooth\", block: \"start\" });\n        }\n      }, durationMs);\n\n      setTimeoutRef(timeout);\n    }\n\n    if (!isOnScreen && timeoutRef) {\n      clearTimeout(timeoutRef);\n    }\n\n    return () => {\n      if (timeoutRef) {\n        clearTimeout(timeoutRef);\n      }\n    };\n  }, [isOnScreen]);\n\n  const src =\n    item.viewPath && projectRelativeFilePath\n      ? getSrc({ relativePath: item.viewPath }, projectRelativeFilePath, !isDev)\n          .src\n      : undefined;\n\n  return (\n    <Div\n      ref={slideRef}\n      className=\"relative snap-center h-[80vh] flex justify-center items-center border-2 border-black\"\n    >\n      {src ? (\n        item.viewPath?.endsWith(\".png\") ? (\n          <Div className=\"absolute top-0 left-0 w-full h-full bg-blue-200\">\n            <Image src={src} width=\"100%\" objectFit=\"fill\" layout=\"fill\" />\n          </Div>\n        ) : item.viewPath?.endsWith(\".mov\") ? (\n          <Div className=\"absolute top-0 left-0 w-full h-full bg-blue-200\">\n            <video\n              muted\n              src={src}\n              autoPlay\n              loop\n              preload=\"none\"\n              width=\"100%\"\n              style={{ objectFit: \"fill\" }}\n            />\n          </Div>\n        ) : null\n      ) : null}\n      {item.title ? <P className=\"text-8xl font-bold\">{item.title}</P> : null}\n    </Div>\n  );\n}"
  },
  "ShortStudio": {
    "name": "ShortStudio",
    "slug": "TsFunction",
    "id": "gprvbocfrowmjiwzsdmooshg",
    "description": "the newer one, eventually to replace `ContextTextArea`\n<SmartContentEditableDivInput\nwriterType={writerType}\nvalue={value}\nonChange={onChange}\nmarkdownParseRenderConfig={markdownParseRenderConfig}\n/>",
    "operationName": "short-markdown-writer-input",
    "rawText": " (props: {\n  onChange: (value: string) => void;\n  value: string;\n  projectRelativeFilePath: string;\n  markdownModelName?: keyof DbModels;\n}) => {\n  const { projectRelativeFilePath } = props;\n\n  const shortMarkdownQuery = queries.useGetOrGenerateShortMarkdown(\n    projectRelativeFilePath\n  );\n\n  const shortMarkdown = shortMarkdownQuery.data?.result || undefined;\n\n  // console.log({ shortMarkdown });\n  return (\n    <Div className=\"w-full h-full flex flex-1 flex-col\">\n      {shortMarkdownQuery.isLoading ? <FancyLoader /> : null}\n      <ShortMarkdownPlayer\n        shortMarkdown={shortMarkdown}\n        projectRelativeFilePath={projectRelativeFilePath}\n      />\n    </Div>\n  );\n}"
  },
  "useMultiAudio": {
    "name": "useMultiAudio",
    "slug": "TsFunction",
    "id": "frfxnljkhjbynzvszlepzxur",
    "description": "- Implement a component that preloads all audios for the `ShortMarkdown` and lets you play one with a callback (look at https://stackoverflow.com/questions/47686345/playing-sound-in-react-js)\n- If slide has audio belonging to it, find it and play it. Start at certain point, depending on which part you are at.\n- Select the correct audio for every slide, and get the API url for it. Load it in into an `<audio>` element once you go to the slide.",
    "operationName": "short-markdown-writer-input",
    "rawText": " (urls: string[]) => {\n  const [sources, setSources] = useState<\n    { url: string; audio: HTMLAudioElement }[]\n  >([]);\n\n  const [players, setPlayers] = useState<{ url: string; playing: boolean }[]>(\n    []\n  );\n  useEffect(() => {\n    setSources(\n      urls.map((url) => {\n        return {\n          url,\n          audio: new Audio(url),\n        };\n      })\n    );\n\n    setPlayers(\n      urls.map((url) => {\n        return {\n          url,\n          playing: false,\n        };\n      })\n    );\n  }, [urls.length]);\n\n  const toggle = (targetIndex: number) => () => {\n    if (!players[targetIndex]) {\n      console.log(\"VAAG\");\n      return;\n    }\n    const newPlayers = [...players];\n    const currentIndex = players.findIndex((p) => p.playing === true);\n    if (currentIndex !== -1 && currentIndex !== targetIndex) {\n      newPlayers[currentIndex].playing = false;\n      newPlayers[targetIndex].playing = true;\n    } else if (currentIndex !== -1) {\n      newPlayers[targetIndex].playing = false;\n    } else {\n      newPlayers[targetIndex].playing = true;\n    }\n    setPlayers(newPlayers);\n  };\n\n  useEffect(() => {\n    sources.forEach((source, i) => {\n      players[i].playing ? source.audio.play() : source.audio.pause();\n    });\n  }, [sources, players]);\n\n  useEffect(() => {\n    sources.forEach((source, i) => {\n      source.audio.addEventListener(\"ended\", () => {\n        const newPlayers = [...players];\n        newPlayers[i].playing = false;\n        setPlayers(newPlayers);\n      });\n    });\n    return () => {\n      sources.forEach((source, i) => {\n        source.audio.removeEventListener(\"ended\", () => {\n          const newPlayers = [...players];\n          newPlayers[i].playing = false;\n          setPlayers(newPlayers);\n        });\n      });\n    };\n  }, []);\n\n  return { players, toggle };\n}"
  },
  "StoreProvider": {
    "name": "StoreProvider",
    "slug": "TsVariable",
    "id": "scjcrsigfkonbumrxokfqqoi",
    "description": "",
    "operationName": "writer-demo-web"
  },
  "useStore": {
    "name": "useStore",
    "slug": "TsVariable",
    "id": "zoetbkqpvbigedscdjlzuzmq",
    "description": "NB: this is a `useStore` without a `StoreProvider`, because I think I won't ever need the provider since I won't ever need this as the sole storage in any component/app. If I do, I should make a provider, but it's usually better to create the `useStore` and `StoreProvider` in the component itself because it often comprises more than just this one.",
    "operationName": "file-tabs"
  },
  "copyPath": {
    "name": "copyPath",
    "slug": "TsFunction",
    "id": "qdburcanpcpsrbnucdtlpkdx",
    "description": "",
    "operationName": "writer-functions",
    "rawText": " async (\n  projectRelativePath: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No project root found\" };\n  }\n\n  const absolutePath = path.join(projectRoot, projectRelativePath);\n\n  if (!fs.existsSync(absolutePath)) {\n    console.log({ absolutePath });\n    return {\n      isSuccessful: false,\n      message: \"This file or folder doesn't exist\",\n    };\n  }\n\n  const parsedPath = path.parse(absolutePath);\n  const copiedPath = path.join(\n    parsedPath.dir,\n    `${parsedPath.name}-copy${parsedPath.ext}`\n  );\n\n  if (fs.existsSync(copiedPath)) {\n    return {\n      isSuccessful: false,\n      message:\n        \"There is already a copy for this file/folder under the anticipated name.\",\n    };\n  }\n\n  await fs.cpAsync(absolutePath, copiedPath, { recursive: true });\n\n  return { isSuccessful: true };\n}"
  },
  "deleteFileOrFolder": {
    "name": "deleteFileOrFolder",
    "slug": "TsFunction",
    "id": "oyfkljmmfizavexxcsydtmpe",
    "description": "",
    "operationName": "writer-functions",
    "rawText": " async (\n  projectRelativePath: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No project root found\" };\n  }\n\n  const absolutePath = path.join(projectRoot, projectRelativePath);\n\n  if (!fs.existsSync(absolutePath)) {\n    return {\n      isSuccessful: false,\n      message: \"This file or folder doesn't exist\",\n    };\n  }\n\n  await fs.rm(absolutePath, { recursive: true });\n\n  return { isSuccessful: true };\n}"
  },
  "getFileContents": {
    "name": "getFileContents",
    "slug": "TsFunction",
    "id": "dsnijjkkxxsnwriysxkoobfx",
    "description": "Gets the contents of a file in the project",
    "operationName": "writer-functions",
    "rawText": " async (\n  projectRelativeFilePath: string\n): Promise<{\n  isSuccessful: boolean;\n  message?: string;\n  fileContents?: string;\n}> => {\n  const projectRoot = getProjectRoot();\n\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No project root\" };\n  }\n\n  const absolutePath = path.join(projectRoot, projectRelativeFilePath);\n\n  if (!fs.existsSync(absolutePath)) {\n    return { isSuccessful: false, message: \"File doesn't exist\" };\n  }\n\n  const stats = await fs.stat(absolutePath);\n\n  if (stats.size > 1024 * 1024 || stats.isDirectory()) {\n    return {\n      isSuccessful: false,\n      message: \"That's a directory or bigger than 1MB\",\n    };\n  }\n\n  const fileContents = await fs.readFile(absolutePath, \"utf8\");\n\n  return { fileContents, isSuccessful: true };\n}"
  },
  "getFrontmatterSchema": {
    "name": "getFrontmatterSchema",
    "slug": "TsFunction",
    "id": "nclfchvqcnyvlzshierbuaey",
    "description": "Gets the frontmatterSchema of any markdown model. This should contain all elements that are required to be in the frontmatter of the markdown",
    "operationName": "writer-functions",
    "rawText": " async (\n  markdownModelName: keyof DbModels | undefined\n): Promise<SimplifiedSchema | undefined> => {\n  if (markdownModelName === undefined) return;\n\n  const tsInterfaces = await db.get(\"TsInterface\");\n  const markdownModelTsInterfaces = tsInterfaces.filter(\n    (x) => x.name === markdownModelName && x.isExported\n  );\n\n  // console.log({ markdownModelTsInterfaces });\n\n  const markdownModelTsInterface = markdownModelTsInterfaces[0];\n\n  if (!markdownModelTsInterface) return;\n\n  const fullSimplifiedSchema = markdownModelTsInterface.type?.simplifiedSchema;\n\n  if (!fullSimplifiedSchema) return;\n\n  const newProperties = fullSimplifiedSchema.properties?.filter(\n    (x) => ![\"markdown\", \"name\"].includes(x.name)\n  );\n\n  const frontmatterSchema: SimplifiedSchema = {\n    ...fullSimplifiedSchema,\n    properties: newProperties,\n  };\n\n  return frontmatterSchema;\n}"
  },
  "getWriterWebPagesMenu": {
    "name": "getWriterWebPagesMenu",
    "slug": "TsFunction",
    "id": "gxdlyqdswfvvuaahuacqlhaf",
    "description": "",
    "operationName": "writer-functions",
    "rawText": " async () => {\n  const webPages = await getWriterWebPages();\n  return getMenuPagesObject(webPages);\n}"
  },
  "getWriterWebPages": {
    "name": "getWriterWebPages",
    "slug": "TsFunction",
    "id": "dypflnltnxxomamkeyvuircx",
    "description": "",
    "operationName": "writer-functions",
    "rawText": " async () => {\n  const projectRelativePaths = (await getProjectRelativePaths()) || [];\n\n  const writerWebPages: WriterWebPage[] = projectRelativePaths.map(\n    (projectRelativeFilePath) => {\n      const writerWebPage: WriterWebPage = {\n        pageData: { projectRelativeFilePath },\n        queryPath: projectRelativeFilePath,\n      };\n      return writerWebPage;\n    }\n  );\n\n  return writerWebPages;\n}"
  },
  "movePath": {
    "name": "movePath",
    "slug": "TsFunction",
    "id": "pibfoslnllnqvfesveedqyqb",
    "description": "",
    "operationName": "writer-functions",
    "rawText": " async (\n  /**\n   * Can be file only for now\n   */\n  projectRelativePath: string,\n  projectRelativeNewFolderPath: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No project root found\" };\n  }\n\n  const absolutePath = path.join(projectRoot, projectRelativePath);\n\n  if (!fs.existsSync(absolutePath)) {\n    return {\n      isSuccessful: false,\n      message: \"This file or folder doesn't exist\",\n    };\n  }\n\n  const newAbsolutePath = path.join(\n    projectRoot,\n    projectRelativeNewFolderPath,\n    path.parse(absolutePath).base\n  );\n\n  if (fs.existsSync(newAbsolutePath)) {\n    return { isSuccessful: false, message: \"File or folder already exists\" };\n  }\n\n  await fs.rename(absolutePath, newAbsolutePath);\n\n  return { isSuccessful: true };\n}"
  },
  "newFile": {
    "name": "newFile",
    "slug": "TsFunction",
    "id": "luwwvfrjukfpbkwbgwcxxggx",
    "description": "",
    "operationName": "writer-functions",
    "rawText": " async (\n  projectRelativeFilePath: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No project root found\" };\n  }\n\n  const absolutePath = path.join(projectRoot, projectRelativeFilePath);\n\n  if (fs.existsSync(absolutePath)) {\n    return { isSuccessful: false, message: \"This file already exists\" };\n  }\n\n  const folderPath = path.parse(absolutePath).dir;\n\n  if (!fs.existsSync(folderPath)) {\n    return { isSuccessful: false, message: \"Folder doesn't exist\" };\n  }\n\n  await fs.writeFile(absolutePath, \"\", { encoding: \"utf8\" });\n\n  return { isSuccessful: true };\n}"
  },
  "newFolder": {
    "name": "newFolder",
    "slug": "TsFunction",
    "id": "oeaonnssquvqamxvznszpqyk",
    "description": "",
    "operationName": "writer-functions",
    "rawText": " async (\n  projectRelativeFolderBasePath: string,\n  folderName: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No project root found\" };\n  }\n\n  const absoluteBasePath = path.join(\n    projectRoot,\n    projectRelativeFolderBasePath\n  );\n\n  if (!fs.existsSync(absoluteBasePath)) {\n    return {\n      isSuccessful: false,\n      message: \"This folder basepath doesn't exist\",\n    };\n  }\n\n  const newFolderPath = path.join(absoluteBasePath, folderName);\n\n  if (fs.existsSync(newFolderPath)) {\n    return { isSuccessful: false, message: \"Folder already exists\" };\n  }\n\n  await fs.mkdir(newFolderPath);\n\n  return { isSuccessful: true };\n}"
  },
  "processAssetUpload": {
    "name": "processAssetUpload",
    "slug": "TsFunction",
    "id": "wuafxarbpwoqrwyaytmjutni",
    "description": "Used for the markdown reader to immediately process a asset upload. If we want to validate this, it would be good to allow a second parameter that checks if you have access to the file",
    "operationName": "writer-functions",
    "rawText": " async (assets: BackendAsset[]) => {\n  const processed = (\n    await Promise.all(assets.map((asset) => processAsset(asset)))\n  ).filter(notEmpty);\n\n  return processed;\n}"
  },
  "renameFileOrFolder": {
    "name": "renameFileOrFolder",
    "slug": "TsFunction",
    "id": "dqncytexknropsasukomrcnh",
    "description": "",
    "operationName": "writer-functions",
    "rawText": " async (\n  projectRelativePath: string,\n  newName: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No project root found\" };\n  }\n\n  const absolutePath = path.join(projectRoot, projectRelativePath);\n\n  if (!fs.existsSync(absolutePath)) {\n    return {\n      isSuccessful: false,\n      message: \"This file doesn't exist\",\n    };\n  }\n\n  const absoluteFolderPath = path.parse(absolutePath).dir;\n\n  const newAbsolutePath = path.join(absoluteFolderPath, newName);\n\n  if (fs.existsSync(newAbsolutePath)) {\n    return { isSuccessful: false, message: \"File/folder already exists\" };\n  }\n\n  await fs.rename(absolutePath, newAbsolutePath);\n\n  return { isSuccessful: true };\n}"
  },
  "saveFileContents": {
    "name": "saveFileContents",
    "slug": "TsFunction",
    "id": "bxzuonqxxdunecarwzsdnzyh",
    "description": "",
    "operationName": "writer-functions",
    "rawText": " async (\n  projectRelativeFilePath: string,\n  newContent: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No project root found\" };\n  }\n\n  const absolutePath = path.join(projectRoot, projectRelativeFilePath);\n\n  if (!fs.existsSync(absolutePath)) {\n    return { isSuccessful: false, message: \"This file does not exist\" };\n  }\n\n  await fs.writeFile(absolutePath, newContent, { encoding: \"utf8\" });\n\n  return {\n    isSuccessful: true,\n  };\n}"
  },
  "trashFileOrFolder": {
    "name": "trashFileOrFolder",
    "slug": "TsFunction",
    "id": "wcjewftfsqkjkelccxslnoqa",
    "description": "NB: only would work with an ESM module, but I don't have time for this now. Later this could replace `deleteFileOrFolder`",
    "operationName": "writer-functions",
    "rawText": " async (\n  projectRelativePath: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No project root found\" };\n  }\n\n  const absolutePath = path.join(projectRoot, projectRelativePath);\n\n  if (!fs.existsSync(absolutePath)) {\n    return {\n      isSuccessful: false,\n      message: \"This file or folder doesn't exist\",\n    };\n  }\n  await import(\"trash\").then((trash) => trash.default(absolutePath));\n\n  //await fs.rm(absolutePath, { recursive: true });\n\n  return { isSuccessful: true };\n}"
  },
  "updateFrontmatter": {
    "name": "updateFrontmatter",
    "slug": "TsFunction",
    "id": "uyrolgzmjyjbvfchnuanchcd",
    "description": "Update frontmatter from a markdownfile by overwriting it, keeping old values that you don't change\n\nIf you provide a folder as projectRelativePath, it stores it to README.md in that folder, even if that doens't exist.",
    "operationName": "writer-functions",
    "rawText": " async (config: {\n  projectRelativePath: string;\n  frontmatter: { [key: string]: string };\n}): Promise<{ isSuccessful: boolean; message?: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return {\n      isSuccessful: false,\n      message: \"No projectroot\",\n    };\n  }\n\n  const { frontmatter, projectRelativePath } = config;\n\n  const absolutePath = path.join(projectRoot, projectRelativePath);\n\n  const exists = fs.existsSync(absolutePath);\n  if (!exists) {\n    return { isSuccessful: false, message: \"File/folder doensn't exist\" };\n  }\n\n  const pathStats = await fs.stat(absolutePath);\n\n  const isFolder = pathStats.isDirectory();\n\n  const finalAbsolutePath = isFolder\n    ? path.join(absolutePath, \"README.md\")\n    : absolutePath;\n\n  // merge frontmatter with old frontmatter\n\n  const existsFinal = fs.existsSync(finalAbsolutePath);\n\n  const markdownParse = existsFinal\n    ? await readMarkdownFile(finalAbsolutePath)\n    : null;\n  const oldFrontmatter: Frontmatter = existsFinal\n    ? markdownParse?.parameters || {}\n    : {};\n\n  const newFrontmatter: Frontmatter = { ...oldFrontmatter, ...frontmatter };\n\n  const newMarkdownParse: MarkdownParse = markdownParse\n    ? {\n        ...markdownParse,\n        parameters: newFrontmatter,\n      }\n    : {\n        parameters: newFrontmatter,\n        raw: \"\",\n      };\n\n  const string = markdownParseToMarkdownString(newMarkdownParse);\n\n  console.log({ newString: string });\n  await fs.writeFile(finalAbsolutePath, string, \"utf8\");\n  return { isSuccessful: true };\n}"
  },
  "add": {
    "name": "add",
    "slug": "TsFunction",
    "id": "yyejyopmwenxdccxehihztfu",
    "description": "The ultimate typescript database stores data in typescript",
    "operationName": "writer-input",
    "rawText": " (a: number, b: number) => a + b"
  },
  "Completion": {
    "name": "Completion",
    "slug": "TsFunction",
    "id": "wzqxrqeeyfjnnkzhygmboqxq",
    "description": "",
    "operationName": "writer-input",
    "rawText": " (props: {\n  augmentedWord: AugmentedWord;\n  augmentedWordObject?: MappedObject<AugmentedWord>;\n}) => {\n  const { augmentedWord, augmentedWordObject } = props;\n\n  const projectRelativeMarkdownFilePath =\n    augmentedWord.projectRelativeMarkdownSourcePath;\n  const projectRelativeBaseFolderPath = getFolderJs(\n    projectRelativeMarkdownFilePath\n  )!;\n  return (\n    <Div>\n      <Div className=\"flex flex-row justify-between\">\n        <P>{augmentedWord.word}</P>\n        <Div>(?)</Div>\n      </Div>\n      <P>\n        {augmentedWord.spoiler ? (\n          <MarkdownContent\n            content={augmentedWord.spoiler}\n            config={{\n              projectRelativeMarkdownFilePath,\n              projectRelativeBaseFolderPath,\n              augmentedWordObject,\n              isDev,\n              isStatic: false,\n            }}\n          />\n        ) : null}\n      </P>\n    </Div>\n  );\n}"
  },
  "ContentEditableDivInput": {
    "name": "ContentEditableDivInput",
    "slug": "TsFunction",
    "id": "uisxxiuzxqlvydbwrbhoafbx",
    "description": "Div that is `contentEditable` by default and has possibilities for color/style highlighting, autocomplete, subtexts and tooltips",
    "operationName": "writer-input",
    "rawText": " <T extends any>(props: {\n  /**\n   * the current raw content of the input\n   */\n  value: string;\n  /**\n   * save your state with this function\n   */\n  onChange: (newValue: string) => void;\n\n  /**\n   * NB: not needed for non-markdown stuff\n   */\n  markdownParseRenderConfig?: MarkdownParseRenderConfig;\n  subwordConfig: SubwordConfig;\n  subtextConfig: SubtextConfig;\n  /**\n   * Your function to parse the raw text into styled text (HTML)\n   *\n   * NB: you can't use react in here, this function needs to return a string!\n   */\n  parseTextContentToHtmlString: ParseTextContentToHtmlString;\n\n  /**\n   * Extra props you want to pass to the main div\n   */\n  divProps: Omit<\n    FinalDivType<T>,\n    \"value\" | \"onChange\" | \"onInput\" | \"contentEditable\"\n  >;\n}) => {\n  const {\n    value,\n    onChange,\n    divProps,\n    parseTextContentToHtmlString,\n    markdownParseRenderConfig,\n    subtextConfig,\n    subwordConfig,\n  } = props;\n\n  useEffect(() => {\n    // NB: `value` changes whenever we call onChange, if the component is used as intended\n    updateEditor(value);\n\n    /**\n     * Every time the value changes, we need to create all click listeners...\n     */\n\n    /**\n     * For every meta clickable, add an event listener for when we click on it.\n     *\n     * If that happens, check if the meta key is enabled.\n     *\n     * If that's true, use the data-href property and go to that URL\n     */\n    const listeners = Array.from(\n      document.getElementsByClassName(metaClickableClassName)\n    )\n      .map((element) => {\n        if (element.tagName !== \"DIV\") return;\n\n        const listener = (clickEvent: MouseEvent) => {\n          if (clickEvent.metaKey) {\n            console.log(\n              \"clicked an image elemen with the metakey enabled... let's go?\",\n              {\n                datasetHref: (element as HTMLDivElement).dataset.href,\n                dataHref: (element as any)[\"data-href\"],\n              }\n            );\n          }\n        };\n        (element as HTMLDivElement).addEventListener(\"click\", listener);\n\n        return { divElement: element as HTMLDivElement, listener };\n      })\n      .filter(notEmpty);\n\n    return () => {\n      /**\n       * Clean up\n       */\n      listeners.map((item) => {\n        const { divElement, listener } = item;\n\n        divElement.removeEventListener(\"click\", listener);\n      });\n    };\n  }, [value]);\n\n  const editor = useRef<HTMLDivElement>(null);\n\n  const getEditorContent = () => {\n    const textSegments = getTextSegments(editor.current);\n\n    const textContent = textSegments.map(({ text }) => text).join(\"\");\n\n    // console.log(\"OK\", { textSegments, textContent });\n    return { textSegments, textContent };\n  };\n\n  /**\n   * Executed every time input changes by user input.\n   *\n   * Ensures the innerHTML is updated for the editor, while the selection stays the same\n   *\n   * NB: to also allow for non-user-based changes, we need to restoreSelection in a different way, probably.\n   */\n  function updateEditor(value: string) {\n    // 1) get selection, segments and the full content (without styling)\n    const selection = window.getSelection();\n    // NB: this never happens I assume\n    if (!selection) return;\n    const { textSegments } = getEditorContent();\n\n    // 2) Use the `textSegments` to find `anchorIndex` and `focusIndex`\n    let anchorIndex: number | null = null;\n    let focusIndex: number | null = null;\n    let currentIndex = 0;\n    textSegments.forEach(({ text, node }) => {\n      if (node.isEqualNode(selection.anchorNode)) {\n        anchorIndex = currentIndex + selection.anchorOffset;\n      }\n      if (node.isEqualNode(selection.focusNode)) {\n        focusIndex = currentIndex + selection.focusOffset;\n      }\n      currentIndex += text.length;\n    });\n\n    if (!editor.current) return;\n\n    const newInnerHTML = parseTextContentToHtmlString(\n      value,\n      \"markdown\",\n      subtextConfig,\n      subwordConfig,\n      markdownParseRenderConfig\n    );\n\n    // console.log({ value, newInnerHTML });\n    // 3) Recalculate the inner HTML of the editor based on the raw text string\n    editor.current.innerHTML = newInnerHTML;\n\n    if (anchorIndex === null || focusIndex === null) return;\n    // 4) restore selection as index of the new string\n    restoreSelection(anchorIndex, focusIndex);\n  }\n\n  /**\n   * Restores selection after updating inner HTML\n   */\n  function restoreSelection(\n    absoluteAnchorIndex: number,\n    absoluteFocusIndex: number\n  ) {\n    const selection = window.getSelection();\n    if (selection === null) return;\n\n    const textSegments = getTextSegments(editor.current);\n    let anchorNode: ChildNode | null = editor.current;\n\n    if (anchorNode === null) return;\n\n    let anchorIndex = 0;\n    let focusNode: ChildNode | null = editor.current;\n\n    if (focusNode === null) return;\n\n    let focusIndex = 0;\n    let currentIndex = 0;\n\n    textSegments.forEach(({ text, node }) => {\n      const startIndexOfNode = currentIndex;\n      const endIndexOfNode = startIndexOfNode + text.length;\n      if (\n        startIndexOfNode <= absoluteAnchorIndex &&\n        absoluteAnchorIndex <= endIndexOfNode\n      ) {\n        anchorNode = node;\n        anchorIndex = absoluteAnchorIndex - startIndexOfNode;\n      }\n      if (\n        startIndexOfNode <= absoluteFocusIndex &&\n        absoluteFocusIndex <= endIndexOfNode\n      ) {\n        focusNode = node;\n        focusIndex = absoluteFocusIndex - startIndexOfNode;\n      }\n\n      currentIndex += text.length;\n    });\n\n    selection.setBaseAndExtent(anchorNode, anchorIndex, focusNode, focusIndex);\n  }\n\n  /**\n   * onInput doesn't always register enters\n   *\n   * onKeyPress is already registered before the content is inside, so that also causes problems.\n   *\n   * onKeyUp seems to be the only event that really works well\n   *\n   * (Only tested in Safari!)\n   */\n  const onKeyUp = () => {\n    // console.log({ innerText: editor.current?.innerText });\n\n    const { textContent } = getEditorContent();\n\n    // NB: editor.current?.innerText would be nice, but it doesn't work because it adds an extra newline...\n    // Besides that, it also is unable to strip certain HTML\n    onChange(textContent);\n  };\n\n  return (\n    <Div>\n      <Div\n        ref={editor}\n        onKeyUp={onKeyUp}\n        contentEditable\n        spellCheck={false}\n        {...divProps}\n      />\n    </Div>\n  );\n}"
  },
  "ContextTextArea": {
    "name": "ContextTextArea",
    "slug": "TsFunction",
    "id": "oxadqzvuoqxqpeotrohwkydf",
    "description": "TextArea with ability to enhance personal database and execute prompts\n\n\nQUESTION:\n\nHow to make color highlighting?\n\nI guess we need to wrap all words with a span and make it contenteditable, so we can create a editor where we are styling all words that are written\n\nWe can then also change the value of the word if you are NOT editing that word.\n\nSo you would only see the true value of a word when your cursor is on that word\n\nTODO:\n\n- replace the textarea with a div contenteditable\n- make selectionStart and selectionEnd still working (on the original text)\n- whenever you stop editing a word, it needs to be wrapped with a span and styled with a function taking that word and returning a style\n- whenver you start a new word through a separator, an empty span should be created\n- the span of the current word being edited must have a location (x,y). get that exact location so we can render an autocompletion intellisense",
    "operationName": "writer-input",
    "rawText": " (props: EditorProps) => {\n  const { value, onChange, withContext, className, projectRelativeFilePath } =\n    props;\n\n  const fileType = getFileTypeFromPath(props.projectRelativeFilePath);\n\n  const contextualPromptsQuery = queries.useGetContextualPrompts(\n    fileType === \"other\" ? undefined : fileType\n  );\n\n  const alert = useAlert();\n\n  const contextSelection = useLastSelection();\n\n  const selectionPrompts =\n    contextualPromptsQuery.data?.result?.selectionContextualPrompts || [];\n\n  const { onClose, openContextMenuProps, renderContextMenu } =\n    useSelectionPromptsMenu(selectionPrompts, {\n      contextContent: value,\n      context_projectRelativeFilePath: projectRelativeFilePath,\n      contextSelection,\n    });\n\n  // EDITOR HOTKEYS\n  useHotkeys([], ({ code, metaKey, ctrlKey, altKey, shiftKey, key }) => {\n    if (code === \"Escape\") {\n      // go out of intellisense\n      alert?.(\"ESCAPE\");\n      onClose();\n    }\n\n    if (ctrlKey && code === \"Space\") {\n      // intellisense on\n      alert?.(\"intellisense on\");\n    }\n    if (altKey && code === \"KeyZ\") {\n      if (shiftKey) {\n        alert?.(\"redo\");\n      } else {\n        alert?.(\"undo\");\n      }\n    }\n\n    if (metaKey && key === \"b\") {\n      alert?.(\"bold\");\n    }\n\n    if (metaKey && key === \"i\") {\n      alert?.(\"italic\");\n    }\n  });\n\n  return (\n    <>\n      {renderContextMenu()}\n      <div\n        className={className}\n        {...openContextMenuProps}\n        ref={openContextMenuProps.ref}\n        onClick={() => onClose()}\n      >\n        <textarea\n          className={className}\n          value={value}\n          onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => {\n            const newText = e.target.value;\n            const positionIndex = e.target.selectionStart;\n            const textEditingContext = getContext({\n              text: newText,\n              positionIndex,\n            });\n            withContext?.(textEditingContext);\n\n            onChange(newText);\n          }}\n        />\n      </div>\n    </>\n  );\n}"
  },
  "depthFontSizes": {
    "name": "depthFontSizes",
    "slug": "TsVariable",
    "id": "viqeggewrhiosxiqyyhyhbrz",
    "description": "",
    "operationName": "writer-input"
  },
  "DivContentEditable": {
    "name": "DivContentEditable",
    "slug": "TsFunction",
    "id": "ufvjcukojrukdrhlyhruswdk",
    "description": "",
    "operationName": "writer-input",
    "rawText": " (props: EditorProps) => {\n  const { value, onChange, withContext, className } = props;\n  const contentRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (!contentRef.current) return;\n    contentRef.current.innerText = value;\n  }, [value]);\n\n  return (\n    <Div\n      contentEditable\n      ref={contentRef}\n      className={className}\n      onPaste={() => {\n        // parse all new words into a span per word\n      }}\n      onKeyPress={() => {\n        const innerText = contentRef.current?.innerText || \"\"; //also innerHTML may be useful\n\n        // IDK how to get this, research it\n        const positionIndex = 0;\n\n        const textEditingContext = getContext({\n          text: innerText,\n          positionIndex,\n        });\n\n        withContext?.(textEditingContext);\n\n        onChange(innerText);\n      }}\n    />\n  );\n}"
  },
  "editSubtextSubwordConfig": {
    "name": "editSubtextSubwordConfig",
    "slug": "TsFunction",
    "id": "dayrojliqhawqvtkuucswcvy",
    "description": "Interesting... In order to auto-generate a form for this, we need to combine the two into a simple function that does NOTHING. Why? Because we can't store it in the database, it is better to keep this in the frontend...\n\nNB: DEPRECATED: TODO: function isn't used. Since the indexation didn't go right, the solution with a `SimplifiedSchemaForm` ended up being easier. Keeping it here because I need to fix the indexation nonetheless.",
    "operationName": "writer-input",
    "rawText": " (\n  subtextConfig: SubtextConfig,\n  subwordConfig: SubwordConfig\n) => {\n  return { subtextConfig, subwordConfig };\n}"
  },
  "EditWriterInput": {
    "name": "EditWriterInput",
    "slug": "TsFunction",
    "id": "czebnftxxcbgekhlzhomvxcm",
    "description": "the newer one, eventually to replace `ContextTextArea`\n<SmartContentEditableDivInput\nwriterType={writerType}\nvalue={value}\nonChange={onChange}\nmarkdownParseRenderConfig={markdownParseRenderConfig}\n/>",
    "operationName": "writer-input",
    "rawText": " (props: {\n  onChange: (value: string) => void;\n  value: string;\n  projectRelativeFilePath: string;\n  markdownModelName?: keyof DbModels;\n}) => {\n  const { onChange, value, projectRelativeFilePath, markdownModelName } = props;\n\n  const fileType = getFileTypeFromPath(projectRelativeFilePath);\n\n  const contextualPromptsQuery = queries.useGetContextualPrompts(\n    fileType === \"other\" ? undefined : fileType\n  );\n  const [lastIndex, setLastIndex] = useState(value.length);\n  const [showAssetUpload, setShowAssetUpload] = useState(false);\n  const toggleAssetUpload = () => setShowAssetUpload(!showAssetUpload);\n\n  const AssetUpload = () => {\n    return (\n      <Div className=\"flex flex-row\">\n        <ClickableIcon\n          emoji={showAssetUpload ? \"âŒ\" : \"ðŸ“‚\"}\n          onClick={() => toggleAssetUpload()}\n        />\n        {showAssetUpload ? (\n          <Div>\n            {/* @ts-ignore */}\n            <AssetInput\n              config={{}}\n              fieldName=\"upload\"\n              uniqueFieldId=\"upload\"\n              onChange={async (newBackendAssets) => {\n                if (newBackendAssets.length === 0) return;\n\n                // 1) upload to backend and process\n                const apiResult = await api.processAssetUpload(\n                  newBackendAssets\n                );\n                // 2) receive back the actual relativePath\n\n                if (!apiResult.result) {\n                  errorToast(\"Couldn't upload your assets\");\n                  return;\n                }\n\n                const assetsMarkdownString = apiResult.result\n                  .map((backendAsset) => {\n                    return `![${backendAsset.alt || \"\"}](${\n                      backendAsset.relativePath\n                    })`;\n                  })\n                  .join(\"\\n\");\n                // 3) insert those as a snippet in the markdown\n                // console.log({ assetsMarkdownString });\n\n                const before = value.substring(0, lastIndex);\n                const after = value.substring(lastIndex);\n                const newText = `${before}${assetsMarkdownString}${after}`;\n                onChange(newText);\n                toggleAssetUpload();\n              }}\n              extra={{\n                projectRelativeReferencingFilePath: projectRelativeFilePath,\n                defaultAssetName: getFileOrFolderName(projectRelativeFilePath),\n                allowMultiple: true,\n                modelName: markdownModelName,\n                size: \"md\",\n                theme: \"Outlined\",\n              }}\n              value={[]}\n            />\n          </Div>\n        ) : null}\n      </Div>\n    );\n  };\n  return (\n    <Div className=\"w-full h-full flex flex-1 flex-col\">\n      <Div className=\"flex flex-row\">\n        <AssetUpload />\n\n        <FilePromptSelect\n          contextContent={value}\n          context_projectRelativeFilePath={projectRelativeFilePath}\n          items={contextualPromptsQuery.data?.result?.pageContextualPrompts}\n        />\n      </Div>\n\n      <ContextTextArea\n        withContext={(context) => {\n          setLastIndex(context.positionIndex);\n          // console.log(`Context`, context);\n        }}\n        className=\"w-full bg-transparent flex flex-1\"\n        onChange={onChange}\n        value={value}\n        projectRelativeFilePath={projectRelativeFilePath}\n      />\n    </Div>\n  );\n}"
  },
  "FrontmatterForm": {
    "name": "FrontmatterForm",
    "slug": "TsFunction",
    "id": "lkdwmovrtykvgfkuvphdtkqy",
    "description": "Renders a form for frontmatter without save button",
    "operationName": "writer-input",
    "rawText": " (props: {\n  modelName?: string;\n  projectRelativeMarkdownFilePath: string;\n  frontmatterSchema: SimplifiedSchema;\n  markdownParse: MarkdownParse;\n  onChange: (value: string) => void;\n}) => {\n  const {\n    onChange,\n    projectRelativeMarkdownFilePath,\n    markdownParse,\n    modelName,\n    frontmatterSchema,\n  } = props;\n  const [immutableFrontmatterSchema] = useState<SimplifiedSchema>(\n    props.frontmatterSchema\n  );\n\n  const referencableModelData = useReferencableModelData(\n    immutableFrontmatterSchema\n  );\n\n  const uploadAssetsThenSetMarkdownString = async (parameters: any[]) => {\n    const [frontmatter] = parameters;\n\n    const assetParameters = findAssetParametersRecursively(frontmatter);\n\n    // NB: because it's too complex and we don't need this in the case of frontmatter, we can just only look at the base level, because frontmatter has just the base level. We therefore skip any items with a stack.\n\n    await Promise.all(\n      assetParameters.map(async (assetParameter) => {\n        if (assetParameter.stack) {\n          console.log(\n            \"WARNING. Stack detected in assetParameters item, shouldn't happen for frontmatter\"\n          );\n          return;\n        }\n        // 1. get the item\n        const item = frontmatter[assetParameter.parameterName] as\n          | BackendAsset\n          | BackendAsset[]\n          | undefined;\n\n        const isCorrectType = typeof item === \"object\";\n        const hasUploaded =\n          item && isCorrectType\n            ? !!makeArray(item).find((x) => x.relativePath)\n            : false;\n        // 2. process if not already\n        const uploadedItem =\n          item && isCorrectType && !hasUploaded\n            ? (await api.processAssetUpload(makeArray(item))).result\n            : item;\n\n        // 3. return uploaded backend-asset\n\n        const newAsset =\n          !uploadedItem || !isCorrectType\n            ? undefined\n            : assetParameter.assetInputType.isMultiple\n            ? makeArray(uploadedItem)\n            : takeFirst(uploadedItem);\n\n        frontmatter[assetParameter.parameterName] = newAsset;\n      })\n    );\n\n    const realFrontmatter: Frontmatter = objectToFrontmatter(\n      frontmatter,\n      frontmatterSchema\n    );\n\n    const newMarkdownParse: MarkdownParse = {\n      ...markdownParse,\n      parameters: realFrontmatter,\n    };\n\n    const newMarkdownString = markdownParseToMarkdownString(newMarkdownParse);\n\n    onChange(newMarkdownString);\n  };\n\n  const frontmatterParse = frontmatterToObject(\n    markdownParse.parameters,\n    frontmatterSchema\n  );\n\n  console.log({ frontmatterParse, frontmatter: markdownParse.parameters });\n\n  return (\n    <SimplifiedSchemaForm\n      modelName={modelName}\n      id={projectRelativeMarkdownFilePath}\n      parameters={[\n        {\n          name: \"Frontmatter\",\n          required: true,\n          isDbModel: true,\n          simplifiedSchema: immutableFrontmatterSchema,\n        },\n      ]}\n      onChange={uploadAssetsThenSetMarkdownString}\n      values={[frontmatterParse]}\n      projectRelativeStorageFilePath={projectRelativeMarkdownFilePath}\n      referencableModelData={referencableModelData}\n    />\n  );\n}"
  },
  "getContext": {
    "name": "getContext",
    "slug": "TsFunction",
    "id": "hthzqiwqimijtvgfijhdzzij",
    "description": "",
    "operationName": "react-with-native-store",
    "rawText": " (key: string) => contexts[contextKey(key)]"
  },
  "getSubtext": {
    "name": "getSubtext",
    "slug": "TsFunction",
    "id": "zbaiqszittkqmnwvapriclpr",
    "description": "make a subtext text based on the text of a complete paragraph (may contain single newlines and other markdown stuff, but never double newlines)\n\nReturns either the subtext string or a HTML string with a container around the subtext, depending on if you provide `withContainer`",
    "operationName": "writer-input",
    "rawText": " (\n  /**\n   * Raw markdown string\n   */\n  markdownString: string,\n  subtextConfig: SubtextConfig\n): string | undefined => {\n  if (!subtextConfig.isEnabled) return;\n\n  const allSubtext = `${subtextConfig.translations?.join(\n    \",\"\n  )} and the text is '${markdownString}'. Let's hook it into translate, and hook up all stuff!`;\n\n  return allSubtext;\n}"
  },
  "getTextSegments": {
    "name": "getTextSegments",
    "slug": "TsFunction",
    "id": "jsfhoakgazwyctezreaanlfu",
    "description": "Iterates over all child-nodes in the editor, replaces text with a segment, and replaces nodes with a flat list of segments\n\nReturns all textSegments in an array",
    "operationName": "writer-input",
    "rawText": " (element: ChildNode | null): TextSegment[] => {\n  if (element === null) return [];\n\n  const children = Array.from(element.childNodes);\n\n  const textSegments: TextSegment[] = children\n    .map((node) => {\n      if (node.nodeType === Node.TEXT_NODE) {\n        return {\n          text: node.nodeValue || \"\",\n          node,\n        };\n      }\n\n      if (node.nodeType === Node.ELEMENT_NODE) {\n        // NB: not sure which nodes contain ID, but this must work\n\n        if (node.nodeName === \"DIV\") {\n          // NB: because nodeName is DIV, it must be a HTMLDivElement\n          const divElement = node as HTMLDivElement;\n          const isAugmentation = divElement.dataset.isAugmentation === \"true\";\n          if (isAugmentation) return;\n        }\n\n        if (node.nodeName === \"BR\") {\n          return { text: \"\\n\", node };\n        } else {\n          return getTextSegments(node);\n        }\n      }\n\n      return;\n    })\n    .filter(notEmpty)\n    .flat();\n\n  return textSegments;\n}"
  },
  "getWriterTypeFromContent": {
    "name": "getWriterTypeFromContent",
    "slug": "TsFunction",
    "id": "bvvndhpvgqmrijhxilufcdbu",
    "description": "",
    "operationName": "writer-input",
    "rawText": " (text: string): WriterType => {\n  if (isTypescript(text)) return \"typescript\";\n  // NB: json is something else\n  if (tryParseJson(text)) return \"other\";\n  // by default, assume markdown\n  return \"markdown\";\n}"
  },
  "isAugmentedWordMatch": {
    "name": "isAugmentedWordMatch",
    "slug": "TsFunction",
    "id": "kyiwwxgbhswkztghjsesuexv",
    "description": "",
    "operationName": "writer-input",
    "rawText": " (\n  augmentedWord: AugmentedWord,\n  completableWord: string\n) => {\n  if (augmentedWord.isCaseInsensitive) {\n    const isMatch = augmentedWord.word\n      ? augmentedWord.word.toLowerCase().includes(completableWord.toLowerCase())\n      : false;\n    return isMatch;\n  }\n\n  const isMatch = augmentedWord.word\n    ? augmentedWord.word.includes(completableWord)\n    : false;\n  return isMatch;\n}"
  },
  "isTypescript": {
    "name": "isTypescript",
    "slug": "TsFunction",
    "id": "hqwmidibutbzewvdgouucuss",
    "description": "only detect typescript if the string starts with `import`. must be improved later on. It would be great to be able to detect that it's a typescript file even if it contains syntax errors.",
    "operationName": "writer-input",
    "rawText": " (text: string) => {\n  return text.startsWith(\"import\");\n}"
  },
  "MarkdownCompletions": {
    "name": "MarkdownCompletions",
    "slug": "TsFunction",
    "id": "emcznodawmklmbsstwxcsynp",
    "description": "",
    "operationName": "writer-input",
    "rawText": " (props: {\n  context: TextEditingContext | null;\n  augmentedWords?: AugmentedWord[];\n  augmentedWordObject?: MappedObject<AugmentedWord>;\n}) => {\n  const { augmentedWords, context, augmentedWordObject } = props;\n\n  /*\n    For `markdown` + `other`:\n  \n    - `@` = people select tooltip\n    - backtick = AugmentedWord from Ts Statements\n    - `![` = AssetInput tooltip\n    - `_`, `*` or `**` is `AugmentedWord` from Word db\n    - `#` should get a list of `Interest`s\n  */\n\n  // const isAsset = context?.wordAtPosition.startsWith(\"![\");\n  const isTypescriptWord = context?.wordAtPosition.startsWith(\"`\");\n  const isPersonWord = context?.wordAtPosition.startsWith(\"@\");\n  const isSpecialWord = specialCharacters.find((startSignal) =>\n    context?.wordAtPosition.startsWith(startSignal)\n  );\n\n  const filteredAugmentedWords = augmentedWords\n    ? isTypescriptWord\n      ? augmentedWords.filter((x) =>\n          [\"operation\", \"bundle\", \"type\", \"function\", \"variable\"].includes(\n            x.type\n          )\n        )\n      : isPersonWord\n      ? augmentedWords.filter((x) => [\"person\"].includes(x.type))\n      : isSpecialWord\n      ? augmentedWords.filter((x) => [\"word\"].includes(x.type))\n      : []\n    : [];\n\n  const completableWord =\n    isTypescriptWord || isPersonWord\n      ? context?.wordAtPosition.slice(1)\n      : isSpecialWord\n      ? omitSpecialCharactersFromStart(context?.wordAtPosition)\n      : undefined;\n\n  const completions = completableWord\n    ? filteredAugmentedWords\n        .filter((augmentedWord) => {\n          const isMatch = isAugmentedWordMatch(augmentedWord, completableWord);\n\n          return isMatch;\n        })\n        .slice(0, MAX_COMPLETIONS_AMOUNT)\n    : [];\n\n  return (\n    <Div>\n      {completions.map((completion, index) => {\n        return (\n          <Completion\n            augmentedWordObject={augmentedWordObject}\n            augmentedWord={completion}\n            key={`completion${index}`}\n          />\n        );\n      })}\n    </Div>\n  );\n}"
  },
  "MarkdownParsePresentation": {
    "name": "MarkdownParsePresentation",
    "slug": "TsFunction",
    "id": "xcokyaiflvlynyrbxbbvoave",
    "description": "",
    "operationName": "writer-input",
    "rawText": " (props: {\n  markdownParse: MarkdownParse;\n  augmentedWordObject?: MappedObject<AugmentedWord>;\n  projectRelativeBaseFolderPath: string;\n  projectRelativeMarkdownFilePath: string;\n}) => {\n  const {\n    markdownParse,\n    augmentedWordObject,\n    projectRelativeBaseFolderPath,\n    projectRelativeMarkdownFilePath,\n  } = props;\n  const [slide, setSlide] = useState(0);\n\n  if (!markdownParse.content) return null;\n\n  const markdownParagraphs = flattenMarkdownChunks(\n    markdownParse.content\n  ).filter((x) => x.paragraph !== \"\");\n\n  const paragraph = markdownParagraphs[slide];\n\n  if (!paragraph) return <P>No slides</P>;\n\n  const navigationIcons: ClickableIconType[] = [\n    {\n      onClick: () => setSlide(0),\n      emoji: \"â®\",\n      disabled: slide === 0,\n    },\n\n    {\n      onClick: () => setSlide(slide - 1),\n      emoji: \"â¬…\",\n      disabled: slide === 0,\n    },\n\n    {\n      onClick: () => setSlide(slide + 1),\n      emoji: \"âž¡\",\n      disabled: slide === markdownParagraphs.length - 1,\n    },\n\n    {\n      onClick: () => setSlide(markdownParagraphs.length - 1),\n      emoji: \"â­\",\n      disabled: slide === markdownParagraphs.length - 1,\n    },\n  ];\n  const navigation = (\n    <Div className=\"flex flex-row gap-3\">\n      {navigationIcons.map((item, index) => (\n        <ClickableIcon {...item} key={`icon${index}`} />\n      ))}\n    </Div>\n  );\n\n  return (\n    <Div className=\"flex flex-col flex-1\">\n      <Div className=\"flex flex-1 flex-col\">\n        <Div className=\"flex flex-col justify-center items-center\">\n          <P className=\"text-4xl\">\n            {paragraph.categoryStack[paragraph.categoryStack.length - 1]}\n          </P>\n\n          <Div className=\"flex flex-row flex-wrap\">\n            {renderBreadCrumbs(paragraph.categoryStack)}\n          </Div>\n        </Div>\n\n        <Div className=\"flex flex-1 flex-col items-center justify-center overflow-y-auto\">\n          <MarkdownContent\n            content={paragraph.paragraph}\n            config={{\n              big: true,\n              projectRelativeBaseFolderPath,\n              projectRelativeMarkdownFilePath,\n              augmentedWordObject,\n              isDev,\n              isStatic: false,\n            }}\n          />\n        </Div>\n      </Div>\n\n      {navigation}\n    </Div>\n  );\n}"
  },
  "MarkdownView": {
    "name": "MarkdownView",
    "slug": "TsFunction",
    "id": "fdrmjxixryjameckaptwqbpq",
    "description": "",
    "operationName": "writer-input",
    "rawText": " (props: {\n  view: \"view\" | \"presentation\";\n  markdownParse: MarkdownParse;\n  markdownParseRenderConfig: MarkdownParseRenderConfig;\n}) => {\n  const { markdownParse, markdownParseRenderConfig, view } = props;\n\n  const {\n    projectRelativeBaseFolderPath,\n    projectRelativeMarkdownFilePath,\n    augmentedWordObject,\n  } = markdownParseRenderConfig;\n  return (\n    <>\n      {view === \"view\" ? (\n        <Div className=\"mx-2\">\n          {renderMarkdownParse(markdownParse, markdownParseRenderConfig)}\n        </Div>\n      ) : null}\n\n      {view === \"presentation\" ? (\n        <Div className=\"mx-2 flex flex-1 min-h-[80vh]\">\n          {markdownParse.content &&\n          projectRelativeBaseFolderPath &&\n          projectRelativeMarkdownFilePath ? (\n            <MarkdownParsePresentation\n              markdownParse={markdownParse}\n              augmentedWordObject={augmentedWordObject}\n              projectRelativeBaseFolderPath={projectRelativeBaseFolderPath}\n              projectRelativeMarkdownFilePath={projectRelativeMarkdownFilePath}\n            />\n          ) : (\n            \"Couldn't find any content\"\n          )}\n        </Div>\n      ) : null}\n    </>\n  );\n}"
  },
  "MarkedParagraph": {
    "name": "MarkedParagraph",
    "slug": "TsFunction",
    "id": "zmxhrhavtcofburiwliliafd",
    "description": "",
    "operationName": "writer-input",
    "rawText": " (props) => {\n  const {\n    markdownFileConfig,\n    markedToken,\n    subtextConfig,\n    subwordConfig,\n    testModeEnabled,\n  } = props;\n\n  const endsWithNewline = markedToken.raw.endsWith(\"\\n\");\n\n  const paragraphText = markedToken.tokens.map((token) => (\n    <MarkedToken\n      item={token}\n      subtextConfig={subtextConfig}\n      subwordConfig={subwordConfig}\n      markdownFileConfig={markdownFileConfig}\n      testModeEnabled={testModeEnabled}\n    />\n  ));\n\n  const paragraphSubtextHtmlString = getSubtext(markedToken.raw, subtextConfig);\n\n  return (\n    <div>\n      {paragraphText}\n      {paragraphSubtextHtmlString}\n      {endsWithNewline ? <br /> : null}\n    </div>\n  );\n}"
  },
  "MarkedText": {
    "name": "MarkedText",
    "slug": "TsFunction",
    "id": "cgimtxolzsuuezwttosrtbhv",
    "description": "",
    "operationName": "writer-input",
    "rawText": " (props) => {\n  const {\n    subwordConfig,\n    markdownFileConfig,\n    subtextConfig,\n    markedToken,\n    testModeEnabled,\n  } = props;\n\n  const sentences = markedToken.raw.split(\"\\n\");\n  return (\n    <div>\n      {sentences.map((sentence) => (\n        <div>\n          <SpannedSentence\n            sentence={sentence}\n            subwordConfig={subwordConfig}\n            markdownFileConfig={markdownFileConfig}\n            subtextConfig={subtextConfig}\n            testModeEnabled={testModeEnabled}\n          />\n        </div>\n      ))}\n    </div>\n  );\n}"
  },
  "MarkedToken": {
    "name": "MarkedToken",
    "slug": "TsFunction",
    "id": "kpqzkfmvcbckyqjsbqqtiiox",
    "description": "Function that can be used to iterate over the marked parse and style every token, recursively\n\nNB: this returns a regular react component, and should, for setting it as InnerHTML, be parsed with the `ReactDOMServer`",
    "operationName": "writer-input",
    "rawText": " (props: {\n  item: marked.Token;\n  subtextConfig: SubtextConfig;\n  subwordConfig: SubwordConfig;\n  markdownFileConfig: MarkdownParseRenderConfig;\n  /**\n   * If enabled, all content will be tested in realtime\n   */\n  testModeEnabled?: boolean;\n}): JSX.Element => {\n  const {\n    item,\n    markdownFileConfig,\n    subtextConfig,\n    subwordConfig,\n    testModeEnabled,\n  } = props;\n\n  if (item.type === \"heading\") {\n    const fontSize = depthFontSizes[item.depth as 1 | 2 | 3 | 4 | 5 | 6 | 7];\n\n    const headingContent =\n      item.tokens && item.tokens.length > 1 ? (\n        `${`#`.repeat(item.depth)} ${item.tokens.map((token) => (\n          <MarkedToken\n            item={token}\n            subtextConfig={subtextConfig}\n            subwordConfig={subwordConfig}\n            markdownFileConfig={markdownFileConfig}\n            testModeEnabled={testModeEnabled}\n          />\n        ))}`\n      ) : (\n        <SpannedSentence\n          sentence={item.raw}\n          subwordConfig={subwordConfig}\n          markdownFileConfig={markdownFileConfig}\n          subtextConfig={subtextConfig}\n        />\n      );\n\n    return (\n      <>\n        <p>\n          <strong style={{ color: \"blue\", fontSize }}>{headingContent}</strong>\n        </p>\n        {getSubtext(item.text, subtextConfig)}\n        <br />\n      </>\n    );\n  }\n\n  if (item.type === \"space\") {\n    // 1 newline splits into two parts here, 5 newlines are 6 parts, so if we omit the first one, we get an array with the length of the amount of newlines\n    const newlines = item.raw.split(\"\\n\").slice(1);\n\n    return (\n      <>\n        {newlines.map(() => (\n          <br />\n        ))}\n      </>\n    );\n  }\n\n  if (item.type === \"blockquote\") {\n    // > ....\n    return (\n      <p>\n        <strong style={{ color: \"blue\" }}>&gt;</strong>\n        <SpannedSentence\n          sentence={item.text}\n          subwordConfig={subwordConfig}\n          markdownFileConfig={markdownFileConfig}\n          subtextConfig={subtextConfig}\n        />\n      </p>\n    );\n  }\n\n  if (item.type === \"paragraph\") {\n    // Paragraph always has tokens?\n    if (testModeEnabled) {\n      testContentEditableRenderComponent(MarkedParagraph, item);\n    }\n\n    return (\n      <MarkedParagraph\n        markedToken={item}\n        subwordConfig={subwordConfig}\n        markdownFileConfig={markdownFileConfig}\n        subtextConfig={subtextConfig}\n      />\n    );\n  }\n\n  if (item.type === \"text\") {\n    if (testModeEnabled) {\n      testContentEditableRenderComponent(MarkedText, item);\n    }\n    return (\n      <MarkedText\n        markedToken={item}\n        subwordConfig={subwordConfig}\n        markdownFileConfig={markdownFileConfig}\n        subtextConfig={subtextConfig}\n      />\n    );\n  }\n\n  if (item.type === \"list\") {\n    return (\n      <>\n        {item.items.map((token) => (\n          <MarkedToken\n            item={token}\n            subtextConfig={subtextConfig}\n            subwordConfig={subwordConfig}\n            markdownFileConfig={markdownFileConfig}\n            testModeEnabled={testModeEnabled}\n          />\n        ))}\n      </>\n    );\n  }\n\n  if (item.type === \"list_item\") {\n    const beforeText = item.raw.split(item.text)[0];\n\n    const text = (\n      <MarkedText\n        markedToken={item}\n        subwordConfig={subwordConfig}\n        subtextConfig={subtextConfig}\n        markdownFileConfig={markdownFileConfig}\n      />\n    );\n\n    return (\n      <>\n        <b style={{ color: \"blue\" }}>{beforeText}</b> {text}\n        <br />\n      </>\n    );\n  }\n\n  if (item.type === \"escape\") {\n    return (\n      <b style={{ color: \"red\" }}>\n        <MarkedText\n          markedToken={item}\n          subwordConfig={subwordConfig}\n          markdownFileConfig={markdownFileConfig}\n          subtextConfig={subtextConfig}\n        />\n      </b>\n    );\n  }\n\n  if (item.type === \"strong\") {\n    return (\n      <b style={{ color: \"blue\" }}>\n        <MarkedText\n          markedToken={item}\n          subwordConfig={subwordConfig}\n          markdownFileConfig={markdownFileConfig}\n          subtextConfig={subtextConfig}\n        />\n      </b>\n    );\n  }\n\n  if (item.type === \"em\") {\n    return (\n      <i style={{ color: \"blue\" }}>\n        <MarkedText\n          markedToken={item}\n          subwordConfig={subwordConfig}\n          markdownFileConfig={markdownFileConfig}\n          subtextConfig={subtextConfig}\n        />\n      </i>\n    );\n  }\n\n  if (item.type === \"image\") {\n    const realSrc = getRealSrc(item.href, markdownFileConfig);\n    return (\n      <div\n        data-href={realSrc}\n        className={metaClickableClassName}\n        data-html=\"true\"\n        data-tip=\"<img src='${realSrc}' width=200 /><br>'Cmd+Click' to open\"\n      >\n        {item.raw}\n      </div>\n    );\n  }\n\n  if (item.type === \"link\") {\n    return (\n      <div\n        data-href={item.href}\n        className={metaClickableClassName}\n        data-html=\"true\"\n        data-tip=\"'Cmd+Click' to open\"\n      >\n        {item.raw}\n      </div>\n    );\n  }\n\n  if (item.type === \"html\") {\n    return (\n      <span style={{ color: \"green\" }}>\n        {item.raw\n          .replaceAll(\"<\", \"&lt;\")\n          .replaceAll(\">\", \"&gt;\")\n          .replaceAll(\"\\n\", \"<br />\")}\n      </span>\n    );\n  }\n\n  if (item.type === \"codespan\") {\n    // Need to add tooltip here for augmented words\n\n    const trimmedWord = trimAround(item.raw, 1);\n\n    return (\n      <span style={{ color: \"orange\" }}>\n        \\`\n        {trimmedWord.split(\" \").map((word) => {\n          const augmentedWord = markdownFileConfig.augmentedWordObject?.[word];\n\n          return (\n            <span\n              data-tip={\n                augmentedWord && augmentedWord.spoiler\n                  ? augmentedWord.spoiler\n                  : undefined\n              }\n            >\n              {word}\n            </span>\n          );\n        })}\n        \\`\n      </span>\n    );\n  }\n\n  if (item.type === \"code\") {\n    return (\n      <span style={{ color: \"orange\" }}>\n        <MarkedText\n          markedToken={item}\n          subwordConfig={subwordConfig}\n          markdownFileConfig={markdownFileConfig}\n          subtextConfig={subtextConfig}\n        />\n      </span>\n    );\n  }\n\n  if (item.type === \"table\") {\n    return (\n      <span style={{ color: \"pink\" }}>\n        <MarkedText\n          markedToken={item}\n          markdownFileConfig={markdownFileConfig}\n          subtextConfig={subtextConfig}\n          subwordConfig={subwordConfig}\n        />\n      </span>\n    );\n  }\n\n  console.log(`unhandled: ${item.type}`, item);\n  return <></>;\n}"
  },
  "MAX_COMPLETIONS_AMOUNT": {
    "name": "MAX_COMPLETIONS_AMOUNT",
    "slug": "TsVariable",
    "id": "pxpwjghlglpadlynfncxqtzk",
    "description": "",
    "operationName": "writer-input"
  },
  "metaClickableClassName": {
    "name": "metaClickableClassName",
    "slug": "TsVariable",
    "id": "nrqxmpcydydgpwhecpltejwq",
    "description": "",
    "operationName": "writer-input"
  },
  "omitSpecialCharactersFromStart": {
    "name": "omitSpecialCharactersFromStart",
    "slug": "TsFunction",
    "id": "psbxaieloeeyzdgalvprthtf",
    "description": "Omits all special characters from the start of a word for the first special character it finds. The other special characters found after that won't be trimmed.",
    "operationName": "writer-input",
    "rawText": " (word?: string) => {\n  if (word === undefined) return;\n\n  const finalWord = specialCharacters.reduce(\n    (word, character) => {\n      // NB: if a word was already trimmed from a special character, the other special characters don't need to be trimmed\n      if (word.hasChanged) return word;\n      const newWord = trimLeft(word.word, character);\n      return { word: newWord, hasChanged: word.word !== newWord };\n    },\n    { word, hasChanged: false }\n  );\n\n  return finalWord.word;\n}"
  },
  "parseTextContentToHtmlString": {
    "name": "parseTextContentToHtmlString",
    "slug": "TsFunction",
    "id": "ioobeczavwffalpbvgjvaldp",
    "description": "Returns a html string from a text string that can be rendered in the dom\n\nNB: because we're parsing text from div.innerText, sometimes there are two newlines when there should be one break.\n\nThree newlines means there should be two breaks...",
    "operationName": "writer-input",
    "rawText": " (\n  text,\n  type,\n  subtextConfig,\n  subwordConfig,\n  markdownParseRenderConfig\n) => {\n  if (type === \"markdown\" && markdownParseRenderConfig) {\n    const lexed = marked.lexer(text);\n\n    const html = lexed.map((token) => (\n      <MarkedToken\n        item={token}\n        subtextConfig={subtextConfig}\n        subwordConfig={subwordConfig}\n        markdownFileConfig={markdownParseRenderConfig}\n        testModeEnabled={true}\n      />\n    ));\n\n    const result = <>{html}</>;\n\n    const string = ReactDOMServer.renderToString(result);\n\n    return string;\n  }\n\n  return text;\n}"
  },
  "SmartContentEditableDivInput": {
    "name": "SmartContentEditableDivInput",
    "slug": "TsFunction",
    "id": "jyttwzongaonzkdjxxzkiufe",
    "description": "Uses ContentEditableDivInput, and attaches the Completions to it based on the content type. Also all other data required...\n\n\nNB: TODO: once the autocomplete inside the contentEditable is done, these things should move inside of there. I need a component that has lots of UI/UX but isn't very smart. This will be able to be re-used in many usecases...",
    "operationName": "writer-input",
    "rawText": " (props: {\n  writerType: WriterType;\n  value: string;\n  onChange: (value: string) => void;\n  markdownParseRenderConfig?: MarkdownParseRenderConfig;\n}) => {\n  const { value, onChange, markdownParseRenderConfig } = props;\n\n  const [subtextConfig] = useStore(\"subtextConfig\");\n  const [subwordConfig] = useStore(\"subwordConfig\");\n\n  useEffect(() => {\n    if (typeof window === \"undefined\") return;\n\n    const getContextMenuInfo = (ev: MouseEvent) => {\n      //ev.preventDefault();\n\n      console.log(\n        \"right click at:\",\n        ev.clientY,\n        ev.clientX,\n        ev.x,\n        ev.y,\n        \"how do we get the word at this position now?\",\n        ev.target\n      );\n\n      // should find a way to get the current word. not sure if this is even feasible if we don't change every word into an element... it may be heavier to change every word into an element, but it certainly makes things easier.\n    };\n\n    // Add eventListner, with it's cleanup...\n    window.addEventListener(\"contextmenu\", getContextMenuInfo);\n    return () => window.removeEventListener(\"contextmenu\", getContextMenuInfo);\n  }, []);\n\n  // const augmentedWordObjectQuery = useGetAugmentedWordObject();\n  // const { data } = useGetAugmentedWords();\n  // const augmentedWords = data?.result;\n  // const augmentedWordObject = augmentedWordObjectQuery.data?.result;\n\n  return (\n    <Div className=\"flex flex-col flex-1\">\n      <ContentEditableDivInput\n        subtextConfig={subtextConfig}\n        subwordConfig={subwordConfig}\n        value={value}\n        onChange={onChange}\n        markdownParseRenderConfig={markdownParseRenderConfig}\n        parseTextContentToHtmlString={parseTextContentToHtmlString}\n        divProps={{\n          style: {\n            padding: 4,\n            margin: 4,\n            width: 400,\n            border: \"1px solid black\",\n          },\n        }}\n      />\n      {/* {writerType === \"typescript\" ? (\n        <TypescriptCompletions\n          context={context}\n          augmentedWords={augmentedWords}\n          augmentedWordObject={augmentedWordObject}\n        />\n      ) : (\n        <MarkdownCompletions\n          context={context}\n          augmentedWords={augmentedWords}\n          augmentedWordObject={augmentedWordObject}\n        />\n      )} */}\n    </Div>\n  );\n}"
  },
  "SpannedSentence": {
    "name": "SpannedSentence",
    "slug": "TsFunction",
    "id": "ockgthxfrftrzispshdbggcy",
    "description": "Needs to be done for every text that can have potential interactions",
    "operationName": "writer-input",
    "rawText": " (\n  props: Omit<ContentEditableRenderProps<any>, \"markedToken\"> & {\n    sentence: string;\n  }\n) => {\n  const { sentence, subwordConfig } = props;\n  if (!subwordConfig.isEnabled) {\n    // NB: if subwords are disabled, we can just return the sentence using a span (not word by word)\n    return <span>{sentence}</span>;\n  }\n\n  const wordSpans = sentence.split(\" \").map((word) => {\n    return <Subword subwordConfig={subwordConfig} word={word} />;\n  });\n\n  return <>{wordSpans}</>;\n}"
  },
  "specialCharacters": {
    "name": "specialCharacters",
    "slug": "TsVariable",
    "id": "ojqghfjuzwhdgrkwrkixjaew",
    "description": "",
    "operationName": "writer-input"
  },
  "SubtextContainer": {
    "name": "SubtextContainer",
    "slug": "TsFunction",
    "id": "uczxvjcxtlxdcjojaqlsptnc",
    "description": "Returns a string with HTML for the subtext container, given you already have",
    "operationName": "writer-input",
    "rawText": " (props: {\n  /**\n   * raw markdown that should be converted into a subtext\n   */\n  rawMarkdown: string;\n  subtextConfig: SubtextConfig;\n}) => {\n  const { rawMarkdown, subtextConfig } = props;\n\n  if (!subtextConfig.isEnabled) return null;\n  const subtext = getSubtext(rawMarkdown, subtextConfig);\n  return (\n    <div\n      contentEditable={false}\n      spellCheck={false}\n      autoCorrect=\"false\"\n      data-is-augmentation=\"true\"\n      style={{ fontSize: 8, backgroundColor: \"#CCC\", padding: 5 }}\n    >\n      {subtext}\n    </div>\n  );\n}"
  },
  "Subword": {
    "name": "Subword",
    "slug": "TsFunction",
    "id": "jggepohdiuikajdxiojknngu",
    "description": "",
    "operationName": "writer-input",
    "rawText": " (props: {\n  word: string;\n  subwordConfig: SubwordConfig;\n}) => {\n  const { word } = props;\n\n  return (\n    <span style={{ borderColor: \"red\", border: 1 }}>\n      <div>{word}</div>\n      <div\n        style={{ color: \"red\", paddingRight: 6 }}\n        contentEditable={false}\n        data-is-augmentation=\"true\"\n      >\n        xxx{word}\n      </div>\n    </span>\n  );\n}"
  },
  "testAllContentEditableRenderComponents": {
    "name": "testAllContentEditableRenderComponents",
    "slug": "TsFunction",
    "id": "ypggyfjbkrrhsoimuvcgaxvy",
    "description": "Can be used to test all `ContentEditableRenderComponent`s with example inputs\n\nInstead you can also enable devmode and just check it on the live examples",
    "operationName": "writer-input",
    "rawText": " () => {\n  const allComponents: ContentEditableRenderComponentType<any>[] = [\n    MarkedText,\n    MarkedParagraph,\n  ];\n\n  const results = allComponents.map((component) => {\n    return {\n      name: component.name,\n      isValid: testContentEditableRenderComponent(component),\n    };\n  });\n\n  console.log(results);\n}"
  },
  "testContentEditableRenderComponent": {
    "name": "testContentEditableRenderComponent",
    "slug": "TsFunction",
    "id": "kiugpuvdwlnpswgulcpvwqcb",
    "description": "Creates an element from the markdown input, and then uses the `toMarkdownString` function to make it markdown again.\n\nTODO: use <template>, might be more accurate. See https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro/35385518#35385518",
    "operationName": "writer-input",
    "rawText": " <TToken extends marked.Token>(\n  ContentEditableRenderComponent: ContentEditableRenderComponentType<TToken>,\n  /**\n   * For doing a realtime test on real data, provide the markdown string to input into the test\n   */\n  markedToken?: TToken | undefined\n) => {\n  const subwordConfig: SubwordConfig = { isEnabled: false };\n  const subtextConfig: SubtextConfig = { isEnabled: false };\n  const markdownFileConfig: MarkdownParseRenderConfig = {\n    projectRelativeBaseFolderPath: \"\",\n    projectRelativeMarkdownFilePath: \"\",\n  };\n\n  const inputs = markedToken\n    ? [markedToken]\n    : ContentEditableRenderComponent.exampleInputs;\n\n  const invalidArray = inputs\n    .map((input) => {\n      const rendered = (\n        <ContentEditableRenderComponent\n          markedToken={input}\n          subwordConfig={subwordConfig}\n          subtextConfig={subtextConfig}\n          markdownFileConfig={markdownFileConfig}\n          // NB: lol, this would cause an infinite loop if enabled, no?\n          testModeEnabled={false}\n        />\n      );\n\n      const htmlString = ReactDOMServer.renderToString(rendered);\n      const span = document.createElement(\"span\");\n      span.innerHTML = htmlString.trim();\n\n      const output = ContentEditableRenderComponent.toMarkdownString(span);\n\n      const isValid = input.raw === output;\n\n      return { isValid, input, output, span };\n    })\n    .filter((result) => !result.isValid);\n\n  if (invalidArray.length === 0) return true;\n\n  // Log the result if there is something invalid\n  console.log({ name: ContentEditableRenderComponent.name, invalidArray });\n\n  return false;\n}"
  },
  "TitleContainer": {
    "name": "TitleContainer",
    "slug": "TsFunction",
    "id": "ayggbrsvgsgrpthjjsvzltoz",
    "description": "container for any index instance that needs to be rendered in the explore page",
    "operationName": "writer-input",
    "rawText": " ({\n  title,\n  children,\n  buttons,\n}: {\n  title?: string;\n  children: any;\n  buttons: LabeledButtonType[];\n}) => {\n  return (\n    <Div className=\"p-2 m-2 border rounded-xl border-gray-500\">\n      <Div className=\"flex flex-row justify-between items-center\">\n        {title ? <P className=\"text-3xl\">{title}</P> : <Div />}\n\n        <Div className=\"flex flex-row gap-3\">\n          {buttons.filter((x) => x.isEnabled !== false).map(LabeledButton)}\n        </Div>\n      </Div>\n\n      {children}\n    </Div>\n  );\n}"
  },
  "trimAround": {
    "name": "trimAround",
    "slug": "TsFunction",
    "id": "vkmesfprfmkcxfwwegtwsafg",
    "description": "Removes x amount of characters from both sides of a word",
    "operationName": "writer-input",
    "rawText": " (word: string, trimLength: number): string => {\n  return word.slice(trimLength, word.length - trimLength);\n}"
  },
  "trimLeft": {
    "name": "trimLeft",
    "slug": "TsFunction",
    "id": "hnfgyzastcxexpzligpfoqzn",
    "description": "Trims a character from a word at the left until that character is not found anymore (recursive)",
    "operationName": "writer-input",
    "rawText": " (word: string, character: string): string => {\n  if (word.startsWith(character))\n    return trimLeft(word.slice(character.length), character);\n  return word;\n}"
  },
  "TypescriptCompletions": {
    "name": "TypescriptCompletions",
    "slug": "TsFunction",
    "id": "wyfklszzzzlgldpexfwlpjhr",
    "description": "In `typescript`, every word should be autocompletable with the typescript stuff, without backticks.",
    "operationName": "writer-input",
    "rawText": " (props: {\n  context: TextEditingContext | null;\n  augmentedWords?: AugmentedWord[];\n  augmentedWordObject?: MappedObject<AugmentedWord>;\n}) => {\n  const { augmentedWords, context, augmentedWordObject } = props;\n\n  const filteredAugmentedWords =\n    augmentedWords?.filter((x) =>\n      [\"operation\", \"bundle\", \"type\", \"function\", \"variable\"].includes(x.type)\n    ) || [];\n\n  const completableWord = context?.wordAtPosition;\n\n  const completions = completableWord\n    ? filteredAugmentedWords\n        .filter((augmentedWord) => {\n          const isMatch = isAugmentedWordMatch(augmentedWord, completableWord);\n\n          return isMatch;\n        })\n        .slice(0, MAX_COMPLETIONS_AMOUNT)\n    : [];\n\n  return (\n    <Div>\n      {completions.map((completion, index) => {\n        return (\n          <Completion\n            augmentedWordObject={augmentedWordObject}\n            augmentedWord={completion}\n            key={`completion${index}`}\n          />\n        );\n      })}\n    </Div>\n  );\n}"
  },
  "{ useStore, StoreProvider }": {
    "name": "{ useStore, StoreProvider }",
    "slug": "TsVariable",
    "id": "imbrgukxmuyolghbhujqcsff",
    "description": "",
    "operationName": "himalayajeep-ui"
  },
  "{ vscodeOpen }": {
    "name": "{ vscodeOpen }",
    "slug": "TsVariable",
    "id": "nghbdkjgsrdtfmkefhiebyez",
    "description": "",
    "operationName": "writer-input"
  },
  "WriterConfigForm": {
    "name": "WriterConfigForm",
    "slug": "TsFunction",
    "id": "ouasyvltrvgnjpvrrjbjmpwu",
    "description": "",
    "operationName": "writer-input",
    "rawText": " () => {\n  const [subtextConfig, setSubtextConfig] = useStore(\"subtextConfig\");\n  const [subwordConfig, setSubwordConfig] = useStore(\"subwordConfig\");\n\n  const values: WriterConfigFormValue = [subtextConfig, subwordConfig];\n\n  return (\n    <Div>\n      <SimplifiedSchemaForm\n        id=\"writerConfig\"\n        onChange={(values) => {\n          const [newSubtextConfig, newSubwordConfig] =\n            values as WriterConfigFormValue;\n          setSubtextConfig(newSubtextConfig);\n          setSubwordConfig(newSubwordConfig);\n        }}\n        parameters={[\n          {\n            name: \"SubtextConfig\",\n            required: true,\n            isDbModel: false,\n            simplifiedSchema: SubtextConfigIndex.type\n              .simplifiedSchema as SimplifiedSchema,\n          },\n          {\n            name: \"SubwordConfig\",\n            required: true,\n            isDbModel: false,\n            simplifiedSchema: SubwordConfigIndex.type\n              .simplifiedSchema as SimplifiedSchema,\n          },\n        ]}\n        values={values}\n      />\n    </Div>\n  );\n}"
  },
  "writerInitialValues": {
    "name": "writerInitialValues",
    "slug": "TsVariable",
    "id": "xmshawkzvubzgvltvwtkvhzo",
    "description": "",
    "operationName": "writer-input"
  },
  "WriterInput": {
    "name": "WriterInput",
    "slug": "TsFunction",
    "id": "zdhurcgrlhyqenzzjfwhcyzo",
    "description": "Writer input for any utf8 based text, file or no file",
    "operationName": "writer-input",
    "rawText": " (props: {\n  /**\n   * boolean indicating whether or not the file has already been saved\n   *\n   * If false, save button will be shown\n   */\n  isSaved?: boolean;\n  /**\n   * function to save the file\n   *\n   * If given, will render a button to save the file\n   */\n  save?: () => void;\n  /**\n   * Provide a MappedObject of `AugmentedWord`s here to allow for autocomplete intellisense type stuff\n   */\n  augmentedWordObject?: MappedObject<AugmentedWord>;\n  /**\n   * The text to edit\n   */\n  value: string;\n\n  /**\n   * can refer to a modelname in case you have frontmatter in that model that needs to be formified\n   */\n  markdownModelName?: keyof DbModels;\n  /**\n   * Callback called when text changes\n   */\n  onChange: (value: string) => void;\n  /**\n   * Force the type of content\n   */\n  type?: WriterType;\n  /**\n   * If you provide the path to the edited file here, it will infer the type of data in the file (typescript, markdown, etc) from it\n   *\n   * Besides this, it is required to show assets, as we need to know where the file is stored so we can know where the relative assets should be resolved.\n   */\n  projectRelativeFilePath?: string;\n  /**\n   * A function to reload the content\n   *\n   * If given, will show this button to reload the text manually\n   */\n  reload?: () => void;\n  /**\n   * Boolean indicating whether or not this thing is loading (content is still not there)\n   */\n  isLoading?: boolean;\n\n  /**\n   * if true, hides buttons\n   */\n  hideButtons?: boolean;\n  /**\n   * classname for the container\n   */\n  className?: string;\n\n  /**\n   * If given, forces the writerview to this value instead of using the current writerViewStore value\n   */\n  initialWriterView?: WriterViewEnum;\n  disabledMenuItems?: string[];\n}) => {\n  const [writerView, setWriterView] = useStore(\"writerView\");\n\n  const {\n    type,\n    projectRelativeFilePath,\n    reload,\n    value,\n    onChange,\n    markdownModelName,\n    initialWriterView,\n    augmentedWordObject,\n    isLoading,\n    save,\n    isSaved,\n    hideButtons,\n    className,\n    disabledMenuItems,\n  } = props;\n\n  const projectRelativeBaseFolderPath = getFolderJs(projectRelativeFilePath);\n  const projectRelativeMarkdownFilePath = projectRelativeFilePath;\n\n  useEffect(() => {\n    if (initialWriterView) {\n      setWriterView?.(initialWriterView);\n    }\n  }, []);\n\n  const filename = projectRelativeFilePath?.split(\"/\").pop();\n  const extension = filename?.split(\".\").pop();\n\n  // Detect type either based on forced type, filename or on content (in descending order)\n  const writerType: WriterType = type\n    ? type\n    : extension\n    ? getWriterType(extension)\n    : getWriterTypeFromContent(value);\n\n  const icon =\n    writerType === \"markdown\" ? \"âœï¸\" : writerType === \"typescript\" ? \"âŒ˜\" : \"ðŸ“ƒ\";\n\n  const canRenderWriterInput =\n    projectRelativeBaseFolderPath !== undefined &&\n    projectRelativeMarkdownFilePath !== undefined;\n\n  const renderWriter = () => {\n    const frontmatterSchemaQuery =\n      queries.useGetFrontmatterSchema(markdownModelName);\n\n    const markdownParse = mdToJsonParse(value, filename, {\n      frontmatterSchema: frontmatterSchemaQuery.data?.result,\n      noFinal: true,\n    });\n\n    const markdownParseRenderConfig: MarkdownParseRenderConfig = {\n      augmentedWordObject,\n      projectRelativeBaseFolderPath: projectRelativeBaseFolderPath || \"\",\n      projectRelativeMarkdownFilePath: projectRelativeMarkdownFilePath || \"\",\n      isDev,\n      isStatic: false,\n    };\n\n    return (\n      <Div className=\"flex flex-col flex-1 px-4\">\n        {writerView === \"shortStudio\" ? (\n          <ShortStudio\n            onChange={onChange}\n            value={value}\n            projectRelativeFilePath={projectRelativeFilePath || \"\"}\n            markdownModelName={markdownModelName}\n          />\n        ) : null}\n        {writerView === \"postable\" ? <Div>This is postable</Div> : null}\n        {writerView === \"todoOffers\" ? <Div>This is todo offers</Div> : null}\n\n        {writerView === \"config\" ? <WriterConfigForm /> : null}\n\n        {writerView === \"frontmatter\" &&\n        !frontmatterSchemaQuery.isLoading &&\n        frontmatterSchemaQuery.data?.result &&\n        projectRelativeMarkdownFilePath ? (\n          <FrontmatterForm\n            modelName={markdownModelName}\n            key={projectRelativeMarkdownFilePath}\n            markdownParse={markdownParse}\n            projectRelativeMarkdownFilePath={projectRelativeMarkdownFilePath}\n            frontmatterSchema={frontmatterSchemaQuery.data?.result}\n            onChange={onChange}\n          />\n        ) : null}\n\n        {writerView === \"edit\" || writerView === undefined ? (\n          <EditWriterInput\n            onChange={onChange}\n            value={value}\n            projectRelativeFilePath={projectRelativeFilePath || \"\"}\n            markdownModelName={markdownModelName}\n          />\n        ) : null}\n\n        {writerView === \"view\" || writerView === \"presentation\" ? (\n          <MarkdownView\n            view={writerView}\n            markdownParse={markdownParse}\n            markdownParseRenderConfig={markdownParseRenderConfig}\n          />\n        ) : null}\n      </Div>\n    );\n  };\n\n  const notDisabled = (menuName: string) => {\n    return !disabledMenuItems || !disabledMenuItems.includes(menuName);\n  };\n  return (\n    <Div className={`flex flex-col flex-1 ${className}`}>\n      {hideButtons || !setWriterView ? null : (\n        <TitleContainer\n          buttons={[\n            {\n              onClick: () => save?.(),\n              emoji: \"ðŸ’¾\",\n              title: \"Save\",\n              isEnabled: isSaved === false && !!save,\n            },\n\n            {\n              onClick: () => setWriterView(\"edit\"),\n              emoji: \"âœï¸\",\n              title: \"Edit\",\n              isActive: writerView === \"edit\",\n              isEnabled: notDisabled(\"edit\"),\n            },\n\n            {\n              onClick: () => setWriterView(\"view\"),\n              emoji: \"ðŸ‘\",\n              title: \"View\",\n              isActive: writerView === \"view\",\n              isEnabled: notDisabled(\"view\"),\n            },\n\n            {\n              onClick: () => {\n                // TODO; ALSO MAKE FULLSCREEN HERE\n                setWriterView(\"presentation\");\n              },\n              emoji: \"ðŸ“½\",\n              title: \"Present\",\n              isActive: writerView === \"presentation\",\n              isEnabled:\n                writerType === \"markdown\" && notDisabled(\"presentation\"),\n            },\n\n            {\n              onClick: () => {\n                setWriterView(\"frontmatter\");\n              },\n              emoji: \"ðŸ§©\",\n              title: \"About\",\n              isActive: writerView === \"frontmatter\",\n              isEnabled:\n                writerType === \"markdown\" &&\n                !!markdownModelName &&\n                notDisabled(\"frontmatter\"),\n            },\n\n            {\n              onClick: () => {\n                setWriterView(\"config\");\n              },\n              emoji: \"âš™ï¸\",\n              title: \"Configuration\",\n              isActive: writerView === \"config\",\n              isEnabled: notDisabled(\"config\"),\n            },\n\n            {\n              onClick: () => {\n                setWriterView(\"postable\");\n              },\n              emoji: \"ðŸ’¬\",\n              title: \"Postables\",\n              isActive: writerView === \"postable\",\n              isEnabled: projectRelativeFilePath?.endsWith(\".postable.md\"),\n            },\n\n            {\n              onClick: () => {\n                setWriterView(\"shortStudio\");\n              },\n              emoji: \"ðŸŽ™\",\n              title: \"Short Studio\",\n              isActive: writerView === \"shortStudio\",\n              isEnabled: projectRelativeFilePath?.endsWith(\".short.md\"),\n            },\n\n            {\n              onClick: () => {\n                setWriterView(\"todoOffers\");\n              },\n              emoji: \"ðŸ“–\",\n              title: \"Todo Offers\",\n              isActive: writerView === \"todoOffers\",\n              isEnabled:\n                projectRelativeFilePath?.includes(\"/todo/\") &&\n                notDisabled(\"todo\"),\n            },\n\n            {\n              onClick: () => {\n                vscodeOpen({\n                  files: [{ projectRelativePath: projectRelativeFilePath }],\n                });\n              },\n              emoji: \"ðŸ’»\",\n              title: \"Code\",\n              isEnabled: projectRelativeFilePath !== undefined,\n            },\n\n            {\n              isEnabled: !!reload,\n              onClick: reload || (() => null),\n              component: isLoading ? () => <FancyLoader /> : undefined,\n              emoji: isLoading ? undefined : \"â†»\",\n              title: isLoading ? \"Loading\" : \"Reload\",\n            },\n          ]}\n          title={filename ? `${icon} ${filename}` : undefined}\n        >\n          <Div />\n        </TitleContainer>\n      )}\n\n      {canRenderWriterInput\n        ? renderWriter()\n        : \"Can't render.... need `projectRelativeFilePath`\"}\n    </Div>\n  );\n}"
  },
  "getLight": {
    "name": "getLight",
    "slug": "TsFunction",
    "id": "cqfiwerlenppmmkrqsbgnzyq",
    "description": "",
    "operationName": "get-light",
    "rawText": " () => {\n  // ambientLightSensor(function (err: any, data: Light) {\n  //   if (!err) {\n  //     console.log(data.computedValue, data.rawValue, { data });\n  //   }\n  // });\n  console.log(\"Get ligth coming soon\");\n  return 0;\n}"
  },
  "getLocation": {
    "name": "getLocation",
    "slug": "TsFunction",
    "id": "umkujvylzfrdglgqwrafmnig",
    "description": "//\n\ngets location\n\nmake sure this is installed:\nhttps://github.com/fulldecent/corelocationcli\n\nlater it will probably be better to have an electron app with all sensors for crossplatform compatibility",
    "operationName": "get-location",
    "rawText": " async () => {\n  console.log(\"getLocation Coming soon\");\n  return { latitude: 0, longitude: 0 };\n  // try {\n  //   const { success, response } = await execAsync(\"corelocationcli\");\n\n  //   if (!success) {\n  //     log(\"Error fetching location\", { type: \"error\" });\n  //     return;\n  //   }\n  //   const [latitude, longitude] = response\n  //     .replace(\"\\n\", \"\")\n  //     .split(\" \")\n  //     .map(Number);\n  //   console.log({ latitude, longitude });\n  //   return { latitude, longitude };\n  // } catch (e) {\n  //   log(\"Error fetching location\", { type: \"error\" });\n  // }\n\n  /**\n   * what we need\n   *\n   * 1) a way to draw polygons and circles with radius on a map that are then saved to an Area model. This UI should also show where you've been: UnknownLocation's are shown and places where you stayed in a small area for more than 10 minutes should be highlighted\n   * 2) a way to determine if your current location is in any Area\n   * 3) if there's no match of area, save location to UnknownLocation model\n   * 4) if there's a match of area, save location to Location model. Group locations together if they stay the same with a startUnix and endUnix\n   * 5) latest area and coords should be returned by papi\n   * 6) It'd be great to acquire a database with country and city names and areas and maybe even addresses so we can reverse geocode everything OFFLINE.\n   * \n   * \n   * \n   * After all of this is there, we can also work on answering the following questions:\n   * \n- are you outside?\n- are you at home?\n- are you working?\n- are you in a restaurant?\n- what are you doing, most likely?\n- are you commuting, if so, are you walking, cycling, or driving?\n\nOnce we can answer some of these questions the interval on which location is asked for can also be optimised. When we are sleeping, it's very unlikely location will change for the coming 15 minutes, so no need to track. When we are commuting, a more accurate location may be handy. This seems like a premature optimisation though, let's see what the battery thinks of this first!\n   */\n}"
  },
  "fetchWithTimeout": {
    "name": "fetchWithTimeout",
    "slug": "TsFunction",
    "id": "lowiodlohehgukeegeeuneej",
    "description": "",
    "operationName": "is-online",
    "rawText": " async (\n  url: string,\n  timeoutMs: number\n): Promise<{\n  isSuccessful: boolean;\n  isConnected: boolean;\n  response?: any;\n  message: string;\n}> => {\n  try {\n    const abortController = new AbortController();\n    const id = setTimeout(() => abortController.abort(), timeoutMs || 10000);\n\n    const response = await fetch(url, {\n      method: \"GET\",\n      signal: abortController.signal,\n      headers: {\n        Accept: \"application/json\",\n        \"Content-Type\": \"application/json\",\n      },\n    })\n      .then((response) => {\n        return {\n          isConnected: true,\n          isSuccessful: true,\n          message: \"Resolved\",\n          result: response,\n        };\n      })\n      .catch((error) => {\n        if (!timeoutMs) {\n          console.warn(error);\n        }\n        return {\n          isSuccessful: false,\n          isConnected: false,\n          message: \"The API didn't resolve: \" + error, //error + error.status +\n        };\n      });\n\n    clearTimeout(id);\n    return response;\n  } catch (e) {\n    return {\n      isSuccessful: false,\n      isConnected: false,\n      message: \"The API didn't resolve: \" + e,\n    };\n  }\n}"
  },
  "isOnline": {
    "name": "isOnline",
    "slug": "TsFunction",
    "id": "schqyjzrfdrkyejxieesxpbp",
    "description": "Fetches google.com to check if we have an internet connection",
    "operationName": "is-online",
    "rawText": " async () => {\n  const { isConnected } = await fetchWithTimeout(\"https://google.com\", 10000);\n\n  return isConnected;\n}"
  },
  "calculateBbqAbility": {
    "name": "calculateBbqAbility",
    "slug": "TsFunction",
    "id": "uqnqktkrniiwtipwtoqdvjrd",
    "description": "Good weather for barbecue is sunny, not windy, dry, without rain,\nhot temperatures\n\nhttp://www.simple-bbq.com/bbqweather.html",
    "operationName": "weather-sensor",
    "rawText": " (\n  temperatureApparent: number,\n  precipitationIntensity: number,\n  windSpeed: number\n) => {\n  //console.log(\"setting hardcoded temperatures for testing !\")\n  //windSpeed = 25;\n  //temperatureApparent = 51;\n  if (precipitationIntensity > 0.3 && precipitationIntensity < 2) {\n    return \"Heavy Rain is falling. Not a good time to barbecue !\";\n  } else if (precipitationIntensity > 2) {\n    return \"Violent Rain is falling. Not a good time to go barbecue!\";\n  }\n  let answer = \"\";\n  if (windSpeed > 24) {\n    answer =\n      \"It's really windy. You probably will have problems lighting the charcoal. A starter chimney will help tremendously as you can put this somewhere sheltered. If you can move your barbecue to a spot out of the wind this will help too.\";\n    answer += \" Additionally, \";\n  }\n\n  if (temperatureApparent < 30) {\n    answer +=\n      \"Temperature is below freezing. Try cooking with the lid on the barbecue and the use of some extra charcoal. Opening the vents will encourage more heat in the barbecue. \";\n  } else if (temperatureApparent > 30 && temperatureApparent < 40) {\n    answer +=\n      \"Temperature is really low. Try cooking with the lid on the barbecue and the use of some extra charcoal. Opening the vents will encourage more heat in the barbecue.\";\n  } else if (temperatureApparent > 40 && temperatureApparent < 50) {\n    answer +=\n      \"Temperature is low.  Try cooking with the lid on the barbecue and the use of some extra charcoal. Opening the vents will encourage more heat in the barbecue.\";\n  } else if (temperatureApparent > 50 && temperatureApparent < 60) {\n    answer += \"Tempearture is chilly. Probably not too bad for barbecuing !\";\n  } else if (temperatureApparent > 60 && temperatureApparent < 70) {\n    answer +=\n      \"Tempearture is warming up. Final evaluation: You should have no problem barbecuing !\";\n  } else if (temperatureApparent > 70 && temperatureApparent < 80) {\n    answer +=\n      \"Temperature feels like summer is coming. Final evaluation: Go barbecue !\";\n  } else if (temperatureApparent > 80) {\n    answer += \"Temperature feels like summer. Final evaluation: Go barbecue !\";\n  }\n  //console.log('returning answer: ' + answer);\n  return answer;\n}"
  },
  "calculateCloudyness": {
    "name": "calculateCloudyness",
    "slug": "TsFunction",
    "id": "mhhfavnzbqubofqejpjanphl",
    "description": "The National Weather Service divides the sky into eight parts, defining the state of the sky in\nterms of octants of opaque sky cover.\nThe term clear or sunny is used to describe a sky with virtually no cloud cover.\n\nThe terms mostly clear or mostly sunny are used for one-eighth to two-eights cloud cover.\n\npartly cloudy or partly sunny three-eighths to four-eights cloud cover, mostly cloudy or considerable\ncloudiness five-eighths to seven-eighths cloud cover,\n\nand cloudy or overcast, when there is eight-eights cloud cover.\n\nAn additional term, fair, describes the night sky when the following conditions are\nmet- four-tenths or less opaque cloud cover, no precipitation, and no extremes of visibility,\ntemperature, or wind.",
    "operationName": "weather-sensor",
    "rawText": " (\n  /** percentage of the sky covered by clouds when observed from a certain location */\n  cloudCoverPercent: number\n) => {\n  if (cloudCoverPercent < 12.5) {\n    return \"Clear\";\n  } else if (cloudCoverPercent > 12.5 && cloudCoverPercent < 25) {\n    return \"Mostly Clear\";\n  } else if (cloudCoverPercent > 37.5 && cloudCoverPercent < 50) {\n    return \"Partly Cloudy\";\n  } else if (cloudCoverPercent >= 100) {\n    return \"Cloudy\";\n  }\n}"
  },
  "calculateCodeFromNatureAbility": {
    "name": "calculateCodeFromNatureAbility",
    "slug": "TsFunction",
    "id": "icetriybbumrzpslbsfcnoax",
    "description": "Things like sunlight for charging solar panel,\n(so not too cloudy)\nnot raining anytime soon (maybe for the next 4-5 hours)\n\n\nThere are some solar power APIs available\n- https://solcast.com/global-pv-power-solar-api\n(only 10 requests per day on free plan)\n- https://re.jrc.ec.europa.eu/pvg_tools/en/tools.html\n(PVGIS - official resource for PV (photovoltaic) data)",
    "operationName": "weather-sensor",
    "rawText": " (\n  cloudCoverPercent: number,\n  precipitationIntensity: number\n) => {\n  if (precipitationIntensity > 0.3 && precipitationIntensity < 2) {\n    return \"Heavy Rain is falling. Not a good time to code from nature !\";\n  } else if (precipitationIntensity > 2) {\n    return \"Violent Rain is falling. Not a good time to code from nature !\";\n  }\n  if (cloudCoverPercent < 12.5) {\n    return \"Sky is Clear. Solar panel efficiency should me maximum. Go code from nature !\";\n  } else if (cloudCoverPercent > 12.5 && cloudCoverPercent < 25) {\n    return \"Sky is Mostly Clear. Solar panel efficiency is probably good. Go code from nature !\";\n  } else if (cloudCoverPercent > 37.5 && cloudCoverPercent < 50) {\n    return \"Sky is Partly Cloudy. Estimated solar panel efficiency at 10-25%. If you want to code from nature, take some charged batteries !\";\n  } else if (cloudCoverPercent >= 100) {\n    return \"Sky is Overcast. Solar panels won't produce energy. If you want to code from nature, take some charged batteries !\";\n  }\n}"
  },
  "calculateDresscode": {
    "name": "calculateDresscode",
    "slug": "TsFunction",
    "id": "onlsnvtrffngnrpprkgxhpcq",
    "description": "Check this weather clothing guide:\n\nhttps://www.tomorrow.io/weather/blog/weather-clothing-guide/",
    "operationName": "weather-sensor",
    "rawText": " (temperatureApparent: number) => {\n  if (temperatureApparent < 30) {\n    return \"Temperature is below freezing. You should wear many layers of clothing to protect yourself.\";\n  } else if (temperatureApparent > 30 && temperatureApparent < 40) {\n    return \"Temperature is really low. Take a thick, warm sweater and a winter coat. You can also add jumpers and turtlenecks. Consider jeans and trousers for the bottoms. Add a pair of boots with insulation padding on the inside.\";\n  } else if (temperatureApparent > 40 && temperatureApparent < 50) {\n    return \"Temperature is low. Take lighter sweaters/sweatshirts. Wear leggings or a lighter pair of jeans. Your feet should be fully covered, wear boots or tennis shoes. Maybe use wool socks.\";\n  } else if (temperatureApparent > 50 && temperatureApparent < 60) {\n    return \"Tempearture is chilly. You can let go of gloves, warm hats, boots and heavy coats. Wear vests, maybe long sleeved shirts. Take an umbrella or waterproof jacket as it can rain in this temperature.\";\n  } else if (temperatureApparent > 60 && temperatureApparent < 60) {\n    return \"Tempearture is warming up. You can wear a T-shirt. If your arms get chilly, consider having a pullover or zip-up hoodie. A cardigan can also work.\";\n  } else if (temperatureApparent > 70 && temperatureApparent < 80) {\n    return \"Summer is coming. You can shed those layers and thick fabrics. However, humidity can be a real problem at this temperature, so you want clothes that keep you fresh. Choose cotton and other breathable fabrics. Short sleeve shirts are the best option, but you may choose tank tops. Holey jeans are a possibility, as well as shorts, skirts, and leggings.\";\n  } else if (temperatureApparent > 80) {\n    return \"Feels like summer. Make sure youâ€™re wearing airy garments and avoid anything tight. Generally, youâ€™re going to wear shorts, skirts, and dresses. Tank tops and short-sleeved shirts are often best here, too.\";\n  }\n}"
  },
  "calculateKiteability": {
    "name": "calculateKiteability",
    "slug": "TsFunction",
    "id": "zwadjfuzpwlckmjdpitwuawc",
    "description": "Complete guide to Kiteability\nhttps://kitingplanet.com/what-is-the-best-weather-for-kite-flying/",
    "operationName": "weather-sensor",
    "rawText": " (\n  windSpeed: number,\n  precipitationIntensity: number\n) => {\n  if (precipitationIntensity > 0.3) {\n    return \"Heavy rain is falling. Thunder can be a dangerous hazard. Please don't go kiting.\";\n  }\n  if (windSpeed < 1) {\n    return \"There is no wind. Don't go kiting.\";\n  } else if (windSpeed > 1 && windSpeed < 3) {\n    return \"Light air. Experienced kiters can try a Glider kite.\";\n  } else if (windSpeed > 3 && windSpeed < 7) {\n    return \"Light breeze. Experienced kiters can try a Delta or Diamond kite.\";\n  } else if (windSpeed > 7 && windSpeed < 12) {\n    return \"Gentle breeze. Good wind for beginners ! Try these kites: Delta, Diamond, Parafoil, Box & Cellular\";\n  } else if (windSpeed > 12 && windSpeed < 18) {\n    return \"Moderate breeze. Good wind for beginners ! Try these kites: Delta, Diamond, Parafoil, Box & Cellular\";\n  } else if (windSpeed > 18 && windSpeed < 24) {\n    return \"Fresh breeze. Good wind for beginners ! Try these kites: Delta, Diamond, Parafoil, Box & Cellular\";\n  } else if (windSpeed > 24 && windSpeed < 31) {\n    return \"Strong breeze. This is a challenging wind for kiting! If you have experience, you can try these kite types: Delta, Box & Cellular\";\n  } else if (windSpeed > 31 && windSpeed < 38) {\n    return \"Near gale. This is a challenging wind for kiting! If you have experience, you can try a Parafoil kite or specialized kites.\";\n  } else if (windSpeed > 38 && windSpeed < 46) {\n    return \"Gale. Super difficult wind for kiting. Some sport kites in experienced hands can possibly fly.\";\n  } else if (windSpeed > 46) {\n    return \"Severe Gale. This is a storm. Please don't go kiting, can be dangerous.\";\n  }\n}"
  },
  "calculateRainyness": {
    "name": "calculateRainyness",
    "slug": "TsFunction",
    "id": "owvgwkdkdqlqmxqpajquottn",
    "description": "Rainfall intensity is classified according to the rate of precipitation, which is given as the amount of rainfall per unit of time. According to MANOBS (Manual of Surface Weather Observations)\n(https://www.baranidesign.com/faq-articles/2020/1/19/rain-rate-intensity-classification)",
    "operationName": "weather-sensor",
    "rawText": " (\n  /** precipitation intensity in inches/hour */\n  precipitationIntensity: number\n) => {\n  if (precipitationIntensity < 0.1) {\n    return \"Light Rain\";\n  } else if (precipitationIntensity > 0.1 && precipitationIntensity < 0.3) {\n    return \"Moderate Rain\";\n  } else if (precipitationIntensity > 0.3 && precipitationIntensity < 2) {\n    return \"Heavy Rain\";\n  } else if (precipitationIntensity > 2) {\n    return \"Violent Rain\";\n  }\n}"
  },
  "calculateSunnyness": {
    "name": "calculateSunnyness",
    "slug": "TsFunction",
    "id": "grjqxmijkkmwaouukzumknen",
    "description": "Calculates how much the day is sunny.",
    "operationName": "weather-sensor",
    "rawText": " (\n  /** percentage of the sky covered by clouds when observed from a certain location */\n  cloudCoverPercent: number,\n  startTime: string,\n  sunsetTime: string,\n  sunriseTime: string\n) => {\n  const startTimeDate = new Date(startTime);\n  const sunsetTimeDate = new Date(sunsetTime);\n  const sunriseTimeDate = new Date(sunriseTime);\n  if (startTimeDate < sunriseTimeDate && startTimeDate > sunsetTimeDate) {\n    return \"It's Night time.\";\n  }\n  if (cloudCoverPercent < 12.5) {\n    return \"Sunny\";\n  } else if (cloudCoverPercent > 12.5 && cloudCoverPercent < 25) {\n    return \"Mostly Sunny\";\n  } else if (cloudCoverPercent > 37.5 && cloudCoverPercent < 50) {\n    return \"Partly Sunny\";\n  } else if (cloudCoverPercent >= 100) {\n    return \"Overcast\";\n  }\n}"
  },
  "calculateWindyness": {
    "name": "calculateWindyness",
    "slug": "TsFunction",
    "id": "ycigwkbnivumztvnocmwrcyy",
    "description": "Wind Speed is classified according to the Beaufort Scale\n(https://www.weather.gov/mfl/beaufort)",
    "operationName": "weather-sensor",
    "rawText": " (\n  /** wind speed in mph */\n  windSpeed: number\n) => {\n  if (windSpeed > 0 && windSpeed < 1) {\n    return \"Calm\";\n  } else if (windSpeed > 1 && windSpeed < 3) {\n    return \"Light Air\";\n  } else if (windSpeed > 4 && windSpeed < 7) {\n    return \"Light Breeze\";\n  } else if (windSpeed > 8 && windSpeed < 12) {\n    return \"Gentle Breeze\";\n  } else if (windSpeed > 13 && windSpeed < 18) {\n    return \"Moderate Breeze\";\n  } else if (windSpeed > 19 && windSpeed < 24) {\n    return \"Fresh Breeze\";\n  } else if (windSpeed > 25 && windSpeed < 31) {\n    return \"Strong Breeze\";\n  } else if (windSpeed > 32 && windSpeed < 38) {\n    return \"Near Gale\";\n  } else if (windSpeed > 39 && windSpeed < 46) {\n    return \"Gale\";\n  } else if (windSpeed > 47 && windSpeed < 54) {\n    return \"Severe Gale\";\n  } else if (windSpeed > 55 && windSpeed < 63) {\n    return \"Storm\";\n  } else if (windSpeed > 64 && windSpeed < 72) {\n    return \"Violent Storm\";\n  } else if (windSpeed > 72) {\n    return \"Hurricane\";\n  }\n}"
  },
  "weatherCode": {
    "name": "weatherCode",
    "slug": "TsVariable",
    "id": "rsxcphrealugnylmhofyfpuc",
    "description": "",
    "operationName": "weather-sensor"
  },
  "abc": {
    "name": "abc",
    "slug": "TsFunction",
    "id": "ldrriqqkaklaiabeiursdfpo",
    "description": "",
    "operationName": "code-types",
    "rawText": " () => {\n  return \"bla\";\n}"
  },
  "commentTypesConst": {
    "name": "commentTypesConst",
    "slug": "TsVariable",
    "id": "clyduybbeylfhhvcvomnfrea",
    "description": "",
    "operationName": "code-types"
  },
  "commentTypes": {
    "name": "commentTypes",
    "slug": "TsVariable",
    "id": "loxothzxawxtzxofgdwoctcc",
    "description": "",
    "operationName": "code-types"
  },
  "contentTypeConst": {
    "name": "contentTypeConst",
    "slug": "TsVariable",
    "id": "yietmwbynfcmfsfvxopekgwd",
    "description": "Improves the convention for parameter names that refer to models. probably it's better to do this: `slug/id/index` are reserved on every model, let's call them \"Ref\". `modelNameRef` refers to modelName. But what if you want to call it differently? Then you'd need to distinguish a prefix from the modelName. Let's do this with a underscore (no dash because underscore preserves ability to dotting on the object). If you want a reference to a user be called author, you'd name it `author_userSlug`.\n\nTODO: reduce all TsInterfaces and functions into their parameters :D",
    "operationName": "code-types"
  },
  "datasetConfigKeys": {
    "name": "datasetConfigKeys",
    "slug": "TsVariable",
    "id": "wkncriqhmteobghdhrmydinj",
    "description": "",
    "operationName": "code-types"
  },
  "datasetFilterOperatorConst": {
    "name": "datasetFilterOperatorConst",
    "slug": "TsVariable",
    "id": "wpgmpaviworperhjtaairrct",
    "description": "NB: keys are made `humanCase` and used in UI, so keep a readable name",
    "operationName": "code-types"
  },
  "dbStorageMethodsConst": {
    "name": "dbStorageMethodsConst",
    "slug": "TsVariable",
    "id": "jdcmnsvizntupsolrhnohpof",
    "description": "",
    "operationName": "code-types"
  },
  "dbStorageMethods": {
    "name": "dbStorageMethods",
    "slug": "TsVariable",
    "id": "imiwmfgnknmtwmdzxcezcabl",
    "description": "",
    "operationName": "code-types"
  },
  "getExamples": {
    "name": "getExamples",
    "slug": "TsFunction",
    "id": "kzasjnvjdmxepgnzbucffpdq",
    "description": "",
    "operationName": "code-types",
    "rawText": " async (functionName: string) => {\n  // const examples = (await db.get(\"FunctionExecution\")).filter(x=>x.isExample && x.functionName === functionName)\n}"
  },
  "getFunctionExersize": {
    "name": "getFunctionExersize",
    "slug": "TsFunction",
    "id": "fnzkjywyifivcjzryecdpohw",
    "description": "",
    "operationName": "code-types",
    "rawText": " async (\n  functionId: string\n): Promise<string> => {\n  //1) get the function, make the description, input, and output string\n  const descriptionString = \"\";\n  const inputString = \"\";\n  const outputString = \"\";\n  //2) get all it's examples from `FunctionExecution`, make the example string\n  const examplesString = 'Input `x, y, z`. Output should be \"a\"';\n\n  return `\nWrite a function that can do this:\n\n${descriptionString}\n\nIt should take this as its inputs:\n\n${inputString}\n\nIt should return this:\n\n${outputString}\n\nSome examples:\n\n${examplesString}\n`;\n}"
  },
  "indexDbModelFolders": {
    "name": "indexDbModelFolders",
    "slug": "TsVariable",
    "id": "elfjffmrqfuqriooytmxefwr",
    "description": "",
    "operationName": "code-types"
  },
  "indexDbModels": {
    "name": "indexDbModels",
    "slug": "TsVariable",
    "id": "hlbbmqerdnrkqxsgkyciuaak",
    "description": "All type interfaces that are used to index stuff, which are added to the database\n\nNB: It's not handy to get this from the database because this is used to generate the database xD",
    "operationName": "code-types"
  },
  "modelViews": {
    "name": "modelViews",
    "slug": "TsVariable",
    "id": "jjrxhviiafcvmfqostlxtjcg",
    "description": "",
    "operationName": "code-types"
  },
  "operationClassificationConst": {
    "name": "operationClassificationConst",
    "slug": "TsVariable",
    "id": "jwggbiwbakwvxjnsjosbqmch",
    "description": "",
    "operationName": "code-types"
  },
  "runEveryPeriodReadonlyArray": {
    "name": "runEveryPeriodReadonlyArray",
    "slug": "TsVariable",
    "id": "swgctjytkesrbsylgppyoulr",
    "description": "",
    "operationName": "code-types"
  },
  "runEveryPeriodStringArray": {
    "name": "runEveryPeriodStringArray",
    "slug": "TsVariable",
    "id": "tlmcecugrnogbcxfvbfqquly",
    "description": "",
    "operationName": "code-types"
  },
  "typescriptIndexModels": {
    "name": "typescriptIndexModels",
    "slug": "TsVariable",
    "id": "cwixprjtucdksiqfejfqvxjh",
    "description": "",
    "operationName": "code-types"
  },
  "cfa": {
    "name": "cfa",
    "slug": "BundleConfig",
    "id": "oWGkXGdFXXXwwcCTJ",
    "description": "Learn full stack Typescript and travel the world!",
    "operationName": null,
    "gitRepoUrl": "https://github.com/CodeFromAnywhere/code-from-anywhere"
  },
  "clientNames": {
    "name": "clientNames",
    "slug": "TsVariable",
    "id": "xkiflgetiuzpgitnllwhydac",
    "description": "",
    "operationName": "invoice-types"
  },
  "clients": {
    "name": "clients",
    "slug": "TsVariable",
    "id": "vhfuuuvubdjahhmsypakfwsc",
    "description": "",
    "operationName": "invoice-types"
  },
  "createInvoiceContactMarkdown": {
    "name": "createInvoiceContactMarkdown",
    "slug": "TsFunction",
    "id": "srydipffmxrgllcoqynkckph",
    "description": "",
    "operationName": "invoice-types",
    "rawText": " (\n  invoiceContact: Creation<InvoiceContact>\n) => {\n  // @ts-ignore\n  return `\\`\\`\\`\\n${createKeyValueMarkdown(invoiceContact, {\n    companyName: null,\n    name: null,\n    addressLine1: null,\n    addressLine2: null,\n    cocNumber: \"KVK\",\n    vatId: \"BTW-id\",\n    phone: \"Phone\",\n    email: \"Email\",\n    website: \"Website\",\n    bankAccountHolder: undefined,\n    bankAccountNumber: undefined,\n  })}\\n\\`\\`\\``;\n}"
  },
  "createInvoiceMarkdown": {
    "name": "createInvoiceMarkdown",
    "slug": "TsFunction",
    "id": "tzbhjkjflbzyowlnhmueqcjv",
    "description": "",
    "operationName": "invoice-types",
    "rawText": " (invoice: Invoice) => {\n  return `\n# ${invoice.freelancer.companyName}\n\n## Work done by\n${createInvoiceContactMarkdown(invoice.freelancer)}\n\n## Client\n${createInvoiceContactMarkdown(invoice.client)}\n\n## Invoice\n\\`\\`\\`\nInvoice date: ${printDate(invoice.invoiceAt)}\nDue date: ${printDate(invoice.dueDateAt)}\nReference number: ${invoice.invoiceId}\n\\`\\`\\`\n\n## Work done\n${invoice.description}\n\n## Nota\nThe hourly rate is ${money(invoice.hourlyRate)}. Having worked ${\n    invoice.hours\n  } hours, this yields ${money(invoice.total)}. ${\n    invoice.vatPercentage === 0\n      ? \"VAT has been expelled for this invoice\"\n      : `There is a total VAT of ${\n          invoice.vatPercentage\n        }%, which comes down to ${money(\n          invoice.vatTotal\n        )}. The total price to be paid (Including VAT) becomes ${money(\n          invoice.totalWithVat\n        )}`\n  }\n\n## Payment\n\nPlease pay **${money(invoice.totalWithVat)}** to **${\n    invoice.freelancer.internationalBankAccountNumber\n  }** under name **${\n    invoice.freelancer.bankAccountHolderName\n  }**. Please pay before **${printDate(invoice.dueDateAt)}**. Thank you!\n`;\n}"
  },
  "createKeyValueMarkdown": {
    "name": "createKeyValueMarkdown",
    "slug": "TsFunction",
    "id": "hgahikcrqqfyubgpmapqfeqb",
    "description": "prints an object in markdown with some prefixes (keys) (if needed)",
    "operationName": "invoice-types",
    "rawText": " <T extends string>(\n  data: { [key in T]?: string | number | boolean | undefined | null },\n  /**\n   * which keys do you want to print, and what should be the prefixed key?\n   *\n   * for every key in your given object...\n   * - give a \"string\" for a prefix\n   * - give \"null\" for no prefix\n   * - give \"undefined\" to skip it completely\n   */\n  objectParameterWithKeysObject: {\n    [key in T]: unknown | string | null | undefined;\n  }\n) => {\n  const keys = Object.keys(objectParameterWithKeysObject) as T[];\n  const markdown = keys\n    .map((objectParameterKey) => {\n      const key = objectParameterWithKeysObject[objectParameterKey];\n      if (key === undefined) return;\n      const value = data[objectParameterKey];\n      if (value === undefined) return;\n\n      // NB: key is a string or null\n      return key ? `${key}: ${value}` : String(value);\n    })\n    .filter(notEmpty)\n    .join(\"\\n\");\n\n  return markdown;\n}"
  },
  "defaults": {
    "name": "defaults",
    "slug": "TsVariable",
    "id": "vlczlbkgxzocbzucbqabmdgo",
    "description": "",
    "operationName": "invoice-types"
  },
  "money": {
    "name": "money",
    "slug": "TsFunction",
    "id": "hfaskdtvewpiegrstzhrdfpp",
    "description": "",
    "operationName": "invoice-types",
    "rawText": " (amount: number) => {\n  return `â‚¬${amount},00`;\n}"
  },
  "newInvoice": {
    "name": "newInvoice",
    "slug": "TsFunction",
    "id": "qlfivwcwbqcnxubcnmbiqzxz",
    "description": "create a new invoice",
    "operationName": "invoice-types",
    "rawText": " ({\n  clientName,\n  hours,\n  description,\n  hourlyRate,\n  vatPercentage,\n  invoiceDate,\n  dueDays,\n}: {\n  clientName: ClientNameEnum;\n  hours: number;\n  /** due date in D-M-YYYY (defaults to today) */\n  invoiceDate?: string;\n  description?: string;\n  hourlyRate?: number;\n  vatPercentage?: number;\n  dueDays?: number;\n}) => {\n  const client = clients[clientName];\n\n  const realHourlyRate =\n    hourlyRate !== undefined\n      ? hourlyRate\n      : client.hourlyRate !== undefined\n      ? client.hourlyRate\n      : defaults.hourlyRate;\n\n  const realVatPercentage =\n    vatPercentage !== undefined\n      ? vatPercentage\n      : client.vatPercentage !== undefined\n      ? client.vatPercentage\n      : defaults.vatPercentage;\n\n  const total = realHourlyRate * hours;\n  const vatTotal = total * (realVatPercentage / 100);\n  const totalWithVat = total + vatTotal;\n  const realInvoiceAt = invoiceDate ? parseDate(invoiceDate) : Date.now();\n  const realDueDays = dueDays || defaults.dueDays;\n\n  const invoice: Invoice = {\n    client,\n    freelancer: cfa,\n    invoiceAt: realInvoiceAt,\n    dueDateAt: realInvoiceAt + realDueDays * 86400 * 1000,\n    description: description || defaults.description,\n    hourlyRate: realHourlyRate,\n    hours,\n    invoiceId: Math.round(Math.random() * 1000),\n    total,\n    totalWithVat,\n    vatPercentage: realVatPercentage,\n    vatTotal,\n  };\n\n  return createInvoiceMarkdown(invoice);\n}"
  },
  "parseDate": {
    "name": "parseDate",
    "slug": "TsFunction",
    "id": "gxggxhmmfyoxgzjyyybluvtc",
    "description": "parses a date like 20-11-2015 into a unix timestamp",
    "operationName": "invoice-types",
    "rawText": " (date: string): number => {\n  const [day, month, year] = date.split(\"-\").map(Number);\n\n  const d = new Date(Date.now());\n  d.setFullYear(year);\n  d.setMonth(month - 1);\n  d.setDate(day);\n\n  return d.valueOf();\n}"
  },
  "printDate": {
    "name": "printDate",
    "slug": "TsFunction",
    "id": "uxzbfebitksfzrheozmiteot",
    "description": "",
    "operationName": "invoice-types",
    "rawText": " (unix: number) => {\n  const date = new Date(unix);\n  return `${date.getDate()}-${date.getMonth() + 1}-${date.getFullYear()}`;\n}"
  },
  "markdownParseToMarkdownModelType": {
    "name": "markdownParseToMarkdownModelType",
    "slug": "TsFunction",
    "id": "gqupjapawsqvhjsrucqzjcrg",
    "description": "makes a markdownModelType from a markdownParse.",
    "operationName": "markdown-types",
    "rawText": " (\n  markdownParse: MarkdownParse | null\n): Storing<MarkdownModelType> | null => {\n  if (!markdownParse) return null;\n\n  const { parameters, raw, fileName } = markdownParse;\n\n  const name = parameters.name ? String(parameters.name) : fileName!;\n  const slug = kebabCase(name);\n  const id = parameters.id ? String(parameters.id) : generateId();\n  const createdAt = parseMarkdownModelTimestamp(\n    parameters,\n    markdownParse,\n    \"createdAt\"\n  );\n  const createdFirstAt = parseMarkdownModelTimestamp(\n    parameters,\n    markdownParse,\n    \"createdFirstAt\"\n  );\n  const updatedAt = parseMarkdownModelTimestamp(\n    parameters,\n    markdownParse,\n    \"updatedAt\"\n  );\n  const deletedAt = parseMarkdownModelTimestamp(\n    parameters,\n    markdownParse,\n    \"deletedAt\"\n  );\n\n  const openedAt = parseMarkdownModelTimestamp(\n    parameters,\n    markdownParse,\n    \"openedAt\"\n  );\n\n  const markdownModelType: Storing<MarkdownModelType> = {\n    ...parameters,\n    id,\n    createdAt,\n    createdFirstAt,\n    deletedAt,\n    updatedAt,\n    openedAt,\n    markdown: raw,\n    name,\n    slug,\n  };\n\n  return markdownModelType;\n}"
  },
  "parseMarkdownModelTimestamp": {
    "name": "parseMarkdownModelTimestamp",
    "slug": "TsFunction",
    "id": "vmyngykmdjzndppcwhrbruus",
    "description": "First tries to look at the frontmatter value, this is leading because it is what the user sees and the file system of the os could be inconsistent\n\nIf this frontmatter doesn't exist, the markdownParse is checked for a date. This should be information collected from the file system\n\nIf that doesn't succeed, sometimes we'll set it to  the current timestamp",
    "operationName": "markdown-types",
    "rawText": " (\n  parameters: Frontmatter,\n  markdownParse: MarkdownParse,\n  parameterName:\n    | \"createdAt\"\n    | \"createdFirstAt\"\n    | \"updatedAt\"\n    | \"deletedAt\"\n    | \"openedAt\"\n): number => {\n  const parameterValue = parameters[parameterName];\n  const markdownParseValue = markdownParse[parameterName];\n\n  const parsedParameterValue =\n    typeof parameterValue === \"number\" && !isNaN(parameterValue)\n      ? parameterValue\n      : typeof parameterValue === \"string\"\n      ? tryParseDate(parameterValue)\n      : undefined;\n\n  const generatedValue =\n    parameterName === \"deletedAt\" || parameterName === \"openedAt\"\n      ? 0\n      : Date.now();\n\n  const parsedTimestamp =\n    parsedParameterValue !== undefined\n      ? parsedParameterValue\n      : markdownParseValue !== undefined\n      ? markdownParseValue\n      : generatedValue;\n\n  return parsedTimestamp;\n}"
  },
  "tryParseDate": {
    "name": "tryParseDate",
    "slug": "TsFunction",
    "id": "emmliaqkcrebzungdsfqkvyi",
    "description": "Tries to parse a date from a string\n- implements default behavior of `new Date` with a try catch\n- returns a unix timestamp (ms since 1970 AD)\n\nTODO: put in a better location... date-util?",
    "operationName": "markdown-types",
    "rawText": " (dateString: string): number | undefined => {\n  try {\n    return new Date(dateString).valueOf();\n  } catch {}\n}"
  },
  "generateId": {
    "name": "generateId",
    "slug": "TsFunction",
    "id": "nlmwncddnoocmmqlsyvhdpfk",
    "description": "24 characters of the alphabet provides 9E33 combinations, wont be possible to brute-force in centuries, even if there are billions of entries",
    "operationName": "model-types",
    "rawText": " (): Id => {\n  return generateRandomString(24).toLowerCase();\n}"
  },
  "generateRandomString": {
    "name": "generateRandomString",
    "slug": "TsFunction",
    "id": "aevouzteuedclmpifpsmmfrx",
    "description": "",
    "operationName": "model-types",
    "rawText": " (length: number) => {\n  const characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  const characterArray = \"x\".repeat(length).split(\"\");\n\n  const string: Id = characterArray\n    .map(() => {\n      const randomIndex = Math.floor(Math.random() * characters.length); //0-63 --> index for above\n      const character = characters.charAt(randomIndex);\n      return character;\n    })\n    .join(\"\");\n\n  return string;\n}"
  },
  "generateTime": {
    "name": "generateTime",
    "slug": "TsFunction",
    "id": "zbxffmpfbrzgeqiczezgymvn",
    "description": "",
    "operationName": "model-types",
    "rawText": " (): Time => Date.now()"
  },
  "languages": {
    "name": "languages",
    "slug": "TsVariable",
    "id": "rqqwtyduqmfatagwgflsexso",
    "description": "keys are the iso codes which will be saved in the db, the values are values which can be shown to the user in any UI",
    "operationName": "model-types"
  },
  "markdownModelTypeToMarkdownString": {
    "name": "markdownModelTypeToMarkdownString",
    "slug": "TsFunction",
    "id": "prtzugajmppdvonvrytruciu",
    "description": "",
    "operationName": "model-types",
    "rawText": " (\n  markdownModelType: Storing<MarkdownModelType>\n): string => {\n  const { markdown, ...parameters } = markdownModelType;\n  const frontmatterString = frontmatterParseToString(parameters);\n  return `${frontmatterString}\\n${markdown}`;\n}"
  },
  "createUser": {
    "name": "createUser",
    "slug": "TsFunction",
    "id": "cktfqkvvhogphpfdtqshsbhu",
    "description": "",
    "operationName": "os-types",
    "rawText": " (input: { username: string; password: string }) => {\n  const encryptedPassword = encryptPassword(input.password);\n\n  const data: Creation<User> = { username: input.username, encryptedPassword };\n\n  //testDb.push(\"User\", data);\n}"
  },
  "currencies": {
    "name": "currencies",
    "slug": "TsVariable",
    "id": "mslmheegykrgvxqwhrrixykz",
    "description": "",
    "operationName": "os-types"
  },
  "defaultCurrencyCode": {
    "name": "defaultCurrencyCode",
    "slug": "TsVariable",
    "id": "sswbbtvitlvhxstlaeybucxw",
    "description": "",
    "operationName": "os-types"
  },
  "enabledCurrencies": {
    "name": "enabledCurrencies",
    "slug": "TsVariable",
    "id": "ydhfrlhwwweypkqhxklgfzba",
    "description": "Let's use enabledCurrencies until we enable ALL stripe currencies",
    "operationName": "os-types"
  },
  "encryptPassword": {
    "name": "encryptPassword",
    "slug": "TsFunction",
    "id": "xvnphjnbjobtizsnvujykcuu",
    "description": "Method to encrypt any password. Uses `bcrypt`",
    "operationName": "encrypt-password",
    "rawText": " (rawPassword: string): string => {\n  return hashSync(rawPassword, 10);\n}"
  },
  "flights": {
    "name": "flights",
    "slug": "TsVariable",
    "id": "oyuqnlvbzgisnkqqdvykihkh",
    "description": "",
    "operationName": "os-types"
  },
  "getBacktickContents": {
    "name": "getBacktickContents",
    "slug": "TsFunction",
    "id": "vbfjbylsukirbdifsbviryyb",
    "description": "TODO: should take a string and return the contents of all backtick-values in a string array",
    "operationName": "os-types",
    "rawText": " (\n  string?: string | null\n): string[] | undefined => {\n  if (!string) return undefined;\n  const contents: string[] = [];\n  return contents.length ? contents : undefined;\n}"
  },
  "isInPeriod": {
    "name": "isInPeriod",
    "slug": "TsFunction",
    "id": "ulzpiwpjkifgsdltridaiqyw",
    "description": "",
    "operationName": "os-types",
    "rawText": " (periodStart: string, periodEnd: string): boolean =>\n  true"
  },
  "isOutOfStock": {
    "name": "isOutOfStock",
    "slug": "TsFunction",
    "id": "bxikenonwiphskrwvkaymyym",
    "description": "",
    "operationName": "os-types",
    "rawText": " ({\n  amount,\n  name,\n  neededWithinDays,\n  recurEveryDays,\n}: {\n  name: string;\n  neededWithinDays: number;\n  amount: number;\n  recurEveryDays: number | null;\n}) => {\n  db.push(\"ShoppingList\", {});\n}"
  },
  "kvmdToCredential": {
    "name": "kvmdToCredential",
    "slug": "TsFunction",
    "id": "orjcpsslvcxuqljmlnospizm",
    "description": "this map function casts the parsed kvmd json into an array of Credential's\n\nTODO: it would be amazing if the db scrapes this mapfunction with the convention `kvmdTo[ModelName]` and use it, if it exists, to map the model before returning the kvmd.\n\nThe cool thing about this map function is that you can extend the kvmd type interface with more parameters that you infer from the kvmd. it's basically some postprocessing.\n\nThe *advantage* of _kvmd_ is that you can change the data in any text-editor!",
    "operationName": "os-types",
    "rawText": " (\n  kvmd: KeyValueMarkdownModelType\n): LoginCredential => {\n  /**\n   TODO: we could even think of some convention like `username (password)` or something. This way we can even provide the username parameter...\n  there are many more ways to parse a line, we can just use conventional markdown. Think about it: **bold**, _italic_, *other italic*, ```triple backtick```, `[xyz](https://link)`, `![xyz](https://image)`, the possibilities are endless!\n  besides this, you could provide objects with additional parameters like this: `(key: value, key2: value)`. It's easy! */\n\n  const username = undefined;\n\n  const password: string | undefined = getBacktickContents(\n    String(kvmd.value)\n  )?.[0];\n  const credential: LoginCredential = { ...kvmd, password };\n  return credential;\n}"
  },
  "minimalPropertyAttributes": {
    "name": "minimalPropertyAttributes",
    "slug": "TsVariable",
    "id": "mjmcxhcohcmxhbiiymjsfsws",
    "description": "",
    "operationName": "os-types"
  },
  "pageViewPropertyAttributes": {
    "name": "pageViewPropertyAttributes",
    "slug": "TsVariable",
    "id": "uhtaaykrdvyijerhnrshjtvf",
    "description": "",
    "operationName": "os-types"
  },
  "readonlyMinimalPropertyAttributes": {
    "name": "readonlyMinimalPropertyAttributes",
    "slug": "TsVariable",
    "id": "kgsxjtsijfevcncpyrjlccbh",
    "description": "",
    "operationName": "os-types"
  },
  "reviewForTypes": {
    "name": "reviewForTypes",
    "slug": "TsVariable",
    "id": "xxowfadnjmfldufclikmhzpt",
    "description": "",
    "operationName": "os-types"
  },
  "roomTypes": {
    "name": "roomTypes",
    "slug": "TsVariable",
    "id": "awqsqynbwmjimlwazqedzkaz",
    "description": "",
    "operationName": "os-types"
  },
  "sourceTypes": {
    "name": "sourceTypes",
    "slug": "TsVariable",
    "id": "xdvjaqnhvsimsxgsnqncmhfn",
    "description": "",
    "operationName": "os-types"
  },
  "upcomingOutgoingFlights": {
    "name": "upcomingOutgoingFlights",
    "slug": "TsFunction",
    "id": "edmrywsufkvmdmcdlehvsbjv",
    "description": "",
    "operationName": "os-types",
    "rawText": " (config: {\n  direct: boolean;\n}): PlannedFlight[] => {\n  const upcoming = flights.reduce((cum, flight) => {\n    cum.push({ ...flight, date: \"xxx\" });\n    return cum;\n  }, [] as PlannedFlight[]);\n  return upcoming;\n}"
  },
  "whereShouldIgo": {
    "name": "whereShouldIgo",
    "slug": "TsFunction",
    "id": "kfwmqfortwfnakzuitndquzz",
    "description": "very bad and incomplete xD need isInPeriod and first get available flights, then I can let the system tell me the first upcoming direct flights",
    "operationName": "os-types",
    "rawText": " () => {\n  //zomer kanaaleilanden, hele jaar gran canaria, de rest is\n  const month = new Date(Date.now()).getMonth();\n  // not very exact\n  const isSummer = [5, 6, 7, 8, 9].includes(month);\n  const possibilities = [\"gran-canaria\"];\n  if (isSummer) {\n    possibilities.push(\"guernsey\");\n    possibilities.push(\"mallorca\");\n  }\n\n  return `you should go to ${possibilities.join(\" or \")}`;\n}"
  },
  "crudPageToWebPages": {
    "name": "crudPageToWebPages",
    "slug": "TsFunction",
    "id": "xdczbdiwymqqqetfcaufmaoe",
    "description": "",
    "operationName": "webpage-types",
    "rawText": " (pageData: CrudPage): WebPage<CrudPage>[] => {\n  const dataPage = {\n    pageData,\n    queryPath: `data/${pageData.modelName}`,\n    isMenuHidden: false,\n    menuTitle: humanCase(pageData.modelName),\n  };\n  const upsertOrNot =\n    pageData.canCreate || pageData.canUpdate\n      ? {\n          pageData,\n          queryPath: `upsert/${pageData.modelName}`,\n          isMenuHidden: true,\n        }\n      : undefined;\n\n  return [dataPage, upsertOrNot].filter(notEmpty);\n}"
  },
  "functionFormPageToWebPage": {
    "name": "functionFormPageToWebPage",
    "slug": "TsFunction",
    "id": "cjaiaucumyromvoiustthfqe",
    "description": "",
    "operationName": "webpage-types",
    "rawText": " (\n  pageData: FunctionFormPage\n): WebPage<FunctionFormPage> => {\n  return {\n    pageData,\n    queryPath: `function/${pageData.functionName}`,\n    isMenuHidden: false,\n    menuTitle: humanCase(pageData.functionName),\n  };\n}"
  },
  "cleanupTsDatabase": {
    "name": "cleanupTsDatabase",
    "slug": "TsFunction",
    "id": "smkvqinowjsjmhmxttzzkjqw",
    "description": "From all Ts Index Models, removes the instances that refer to a ts file that doesn't exist anymore in the operation.",
    "operationName": "cleanup-typescript-database",
    "rawText": " async (\n  operationName: string,\n  manualProjectRoot?: string\n) => {\n  //console.log(\"let's cleanup operation \", operationName, manualProjectRoot);\n  const operationBasePath = await getOperationPath(operationName);\n\n  //console.log({ operationBasePath });\n  if (!operationBasePath) return;\n  const operationRelativePaths = (\n    await getPackageSourcePaths({ operationBasePath })\n  ).map((absolutePath) =>\n    getOperationRelativePath(absolutePath, operationBasePath)\n  );\n\n  // all typescript index models related to a ts file should be cleaned\n  const removeResults = await Promise.all(\n    typescriptIndexModels.map((modelName) => {\n      return db.remove(\n        modelName,\n        (model) => {\n          const shouldRemove = shouldDeleteTsModel(\n            model,\n            operationName,\n            operationRelativePaths\n          );\n          /*\n          if (shouldRemove) {\n            console.log({\n              modelName,\n              operationRelativePaths,\n              model: model.name,\n              shouldRemove,\n              ts: model.operationRelativeTypescriptFilePath,\n            });\n          }*/\n\n          return shouldRemove;\n        },\n        { operationName, manualProjectRoot }\n      );\n    })\n  );\n\n  //console.log({ removeResults });\n\n  const totalRemoved = removeResults.reduce(\n    (previous, current) => previous + (current.amountRemoved || 0),\n    0\n  );\n\n  return {\n    amountRemoved: totalRemoved,\n  };\n}"
  },
  "shouldDeleteTsModel": {
    "name": "shouldDeleteTsModel",
    "slug": "TsFunction",
    "id": "qguzrehatykckurjkkimwhhn",
    "description": "",
    "operationName": "cleanup-typescript-database",
    "rawText": " (\n  tsModel:\n    | TsFunction\n    | TsComment\n    | TsInterface\n    | TsBuildError\n    | TsLintWarning\n    | TsExport\n    | TsImport\n    | TsVariable,\n  operationName: string,\n  operationRelativePaths: string[]\n) => {\n  if (!tsModel.operationName) {\n    // console.log(\"no operationaName\");\n    return true;\n  }\n  if (tsModel.operationName !== operationName) {\n    // console.log(\"wrong operationName\");\n    return true;\n  }\n  if (!tsModel.operationRelativePath) {\n    //   console.log(\"no operationRelativePath\");\n    return true;\n  }\n  if (\n    !operationRelativePaths.includes(\n      tsModel.operationRelativeTypescriptFilePath\n    )\n  ) {\n    // console.log(\"no correct operationRelativeTypescriptFilePath\");\n    return true;\n  }\n\n  return false;\n}"
  },
  "stripCommentEnd": {
    "name": "stripCommentEnd",
    "slug": "TsFunction",
    "id": "wpreffdrypxfbvotbjlsckex",
    "description": "only strip slahes for single-line comments",
    "operationName": "comment-util",
    "rawText": " (trimmedLine: string) =>\n  trimmedLine.endsWith(\"*/\")\n    ? trimmedLine.substring(0, trimmedLine.length - 2).trim()\n    : trimmedLine"
  },
  "stripCommentStart": {
    "name": "stripCommentStart",
    "slug": "TsFunction",
    "id": "arogemnajperdirswxzjzhrz",
    "description": "",
    "operationName": "comment-util",
    "rawText": " (trimmedLine: string) =>\n  trimmedLine.startsWith(\"/**\")\n    ? trimmedLine.substring(3).trim()\n    : trimmedLine.startsWith(\"/*\")\n    ? trimmedLine.substring(2).trim()\n    : trimmedLine"
  },
  "stripComment": {
    "name": "stripComment",
    "slug": "TsFunction",
    "id": "wyomngtcixzgbzimscasaykf",
    "description": "parses comments (single line, multiline and doc) and removes the comment syntax\n\n- removes slashes\n- removes multiline comment prefix\n- removes multiline comment suffix\n- removes doccomment stars\n\nexample input: `// comment`, output: `comment`\n\nexample input:\n```\n\nsome\nmultiline\ncomment *~/\n```\noutput:\n```\nsome\nmultiline\ncomment\n```",
    "operationName": "comment-util",
    "rawText": " (rawCommentString: string): string => {\n  const lines = rawCommentString.split(\"\\n\");\n  const strippedComment = lines\n    .map((line) => {\n      return apply(\n        [\n          trim,\n          stripSlashes,\n          stripCommentStart,\n          stripCommentEnd,\n          stripStar,\n          trim,\n        ],\n        line\n      );\n    })\n    .join(\"\\n\");\n\n  return apply([trimSurroundingNewlines], strippedComment);\n}"
  },
  "stripSlashes": {
    "name": "stripSlashes",
    "slug": "TsFunction",
    "id": "sqmvdybniwoksyytxzpydbpt",
    "description": "",
    "operationName": "comment-util",
    "rawText": " (trimmedLine: string) =>\n  trimmedLine.startsWith(\"//\") ? trimmedLine.substring(2).trim() : trimmedLine"
  },
  "stripStar": {
    "name": "stripStar",
    "slug": "TsFunction",
    "id": "dbgqfoazqxaqenwohrbivbgr",
    "description": "",
    "operationName": "comment-util",
    "rawText": " (trimmedLine: string) =>\n  trimmedLine.startsWith(\"*\") ? trimmedLine.substring(1).trim() : trimmedLine"
  },
  "trimSurroundingNewlines": {
    "name": "trimSurroundingNewlines",
    "slug": "TsFunction",
    "id": "zeczxclsfbmulmhmusolkduf",
    "description": "removes new lines at beginning and end\n\nNB: This function uses a small recursion! I don't know if this is very efficient, but shouldn't be too deep!\n\nNB: it should be noted that a newline apparently seems to be counting as a single character! Strange.",
    "operationName": "comment-util",
    "rawText": " (string: string): string => {\n  return string.startsWith(\"\\n\")\n    ? trimSurroundingNewlines(string.substring(1))\n    : string.endsWith(\"\\n\")\n    ? trimSurroundingNewlines(string.substring(0, string.length - 1))\n    : string;\n}"
  },
  "trim": {
    "name": "trim",
    "slug": "TsFunction",
    "id": "bcizxmpdmwpgjwgyslsrpmsq",
    "description": "",
    "operationName": "comment-util",
    "rawText": " (string: string) => string.trim()"
  },
  "getCompileErrors": {
    "name": "getCompileErrors",
    "slug": "TsFunction",
    "id": "ewlpszinfabulnnypdspgnvb",
    "description": "gets compileErrors of an operation. if it has no errors, it also check all dependants to see if they have errors, possibly because we changed this one\n\n1) get buildErrors for all src files of current operation\n2) if build doesn't succeed, only check for build errors in current operation\n3) if build succeeds, check iffor build errors in all files in all operations that depend on this one. this means we need compile to be ran for every operation\n\nTODO: Later, only check all build errors of all dependants if and only if an export blueprint (io) has changed and if this export was imported there",
    "operationName": "compile-typescript",
    "rawText": " async (\n  operationBasePath: string,\n  onlyDependants?: boolean,\n  manualProjectRoot?: string\n): Promise<Creation<TsBuildError>[]> => {\n  const moduleName = await getOperationPackageName(operationBasePath);\n\n  if (onlyDependants) {\n    log(\"Getting compilation errors for all dependants\", { type: \"important\" });\n\n    // should get all operations that have this module in their imports\n    // in the beginning, no indexes for this will exist, so that's fine...\n    const allImports = await db.get(\"TsImport\", { manualProjectRoot });\n    const dependants: string[] = allImports\n      .filter((imp) => imp.module === moduleName)\n      .map((imp) => imp?.operationName)\n      .filter(notEmpty)\n      .filter(onlyUnique);\n\n    log(`Dependants ${dependants.join(\", \")} (now skipping)`, {\n      type: \"important\",\n    });\n    // const stuff = (\n    //   await Promise.all(\n    //     dependants.map(async (dep) => {\n    //       const operationFolderPath = await getOperationPath(dep);\n    //       if (!operationFolderPath) return null;\n\n    //       const filePaths: string[] = await getPackageSourcePaths({\n    //         packageFolder: operationFolderPath,\n    //       });\n    //       const tsConfig = await getTsConfig(operationFolderPath);\n    //       const packageJson = await getPackageJson({ operationFolderPath });\n\n    //       if (!tsConfig) return null;\n    //       if (!packageJson) return null;\n\n    //       return {\n    //         basePath: operationFolderPath,\n    //         packageJson,\n    //         compilerOptions: tsConfig.compilerOptions,\n    //         filePaths,\n    //       };\n    //     })\n    //   )\n    // ).filter(notEmpty);\n\n    const allBuildErrors = [].map(getTypescriptErrorsFromFiles).flat();\n\n    return allBuildErrors;\n  } else {\n    const tsConfig = await getTsConfig(operationBasePath);\n    const compilerOptions = tsConfig?.compilerOptions;\n    if (!compilerOptions) {\n      log(\n        `Couldn't find tsConfig compilerOptions for this operation (${operationBasePath}`,\n        { type: \"error\" }\n      );\n      return [];\n    }\n\n    const filePaths = await getPackageSourcePaths({\n      operationBasePath,\n    });\n\n    const packageJson = await getPackageJson({\n      operationFolderPath: operationBasePath,\n    });\n\n    if (!packageJson) return [];\n\n    const buildErrorsHere = getTypescriptErrorsFromFiles({\n      packageJson,\n      basePath: operationBasePath,\n      filePaths,\n      compilerOptions,\n    });\n\n    // const buildErrorsHere: TsBuildError[] = [];\n    if (buildErrorsHere.length > 0) {\n      return buildErrorsHere;\n    } else if (!onlyDependants) {\n      // do the same for all dependants, but only if this is not already a dependant (just 1 level of recursion)...\n      return getCompileErrors(operationBasePath, true, manualProjectRoot);\n    } else {\n      return [];\n    }\n  }\n}"
  },
  "[\n  operationBasePath,\n  operationManualProjectRoot,\n  typerepoManualProjectRoot,\n]": {
    "name": "[\n  operationBasePath,\n  operationManualProjectRoot,\n  typerepoManualProjectRoot,\n]",
    "slug": "TsVariable",
    "id": "ndqyfmbhpmokyfnmjzitujzh",
    "description": "",
    "operationName": "compile-typescript"
  },
  "writeBuildErrors": {
    "name": "writeBuildErrors",
    "slug": "TsFunction",
    "id": "obrzovmuklpkreymbotvaltn",
    "description": "",
    "operationName": "compile-typescript",
    "rawText": " async (\n  operationBasePath: string,\n  operationManualProjectRoot?: string,\n  typerepoManualProjectRoot?: string\n) => {\n  const operationName = getLastFolder(operationBasePath);\n  const projectRoot = operationManualProjectRoot || getProjectRoot();\n  if (!projectRoot) return;\n  // NB: fix to globally alter real fs in order to fix EMFile error that happens in TSMorph (see https://github.com/isaacs/node-graceful-fs)\n  gracefulFs.gracefulify(realFs);\n\n  // NB: this does it for all files in the whole operation!\n  const buildErrors = await getCompileErrors(\n    operationBasePath,\n    false,\n    operationManualProjectRoot\n  );\n\n  await db.clear(\"TsBuildError\", {\n    operationName,\n    manualProjectRoot: operationManualProjectRoot,\n  });\n  // @ts-ignore\n  await db.upsert(\"TsBuildError\", buildErrors, {\n    operationName,\n    manualProjectRoot: operationManualProjectRoot,\n  });\n\n  // log(`Wrote ts-build-errors for ${operationFolder}`, { type: \"success\" });\n\n  process.exit(0);\n}"
  },
  "findAllDependencyOperations": {
    "name": "findAllDependencyOperations",
    "slug": "TsFunction",
    "id": "xlrmjaihakgwefvkstgzqvce",
    "description": "to be used when you need to know all dependencies for multiple operation names at once\n\nTODO: NB: this breaks with circular dependencies",
    "operationName": "find-all-dependency-operations",
    "rawText": " async ({\n  imports,\n  packageJsons,\n  operationNames,\n  ignoreOperationNames,\n  ignoreFilter,\n}: {\n  /**\n   * All imports\n   */\n  imports: TsImport[];\n  packageJsons: PackageJson[];\n  operationNames: string[];\n  ignoreOperationNames?: string[];\n  ignoreFilter?: (operationName: string) => boolean;\n}) => {\n  const dependencies = (\n    await oneByOne(operationNames, async (operationName) => {\n      process.stdout.write(`${operationName} ... `);\n\n      return findDependenciesRecursively(\n        imports,\n        packageJsons,\n        operationName,\n        operationNames,\n        ignoreOperationNames,\n        ignoreFilter\n      );\n    })\n  ).flat();\n\n  return dependencies.filter(onlyUnique);\n}"
  },
  "findDependantsRecursivelyTest": {
    "name": "findDependantsRecursivelyTest",
    "slug": "TsFunction",
    "id": "kzlbaqyhbpcotwddrqbfmwsd",
    "description": "",
    "operationName": "find-all-dependency-operations",
    "rawText": " async () => {\n  const sdkDependants = await findDependantsRecursively(\"sdk\");\n\n  console.log({ sdkDependants });\n}"
  },
  "findDependantsRecursively": {
    "name": "findDependantsRecursively",
    "slug": "TsFunction",
    "id": "kurzflfxuwgeuotrkdgiqeat",
    "description": "findDependants({\n\noperationName: \"js-util\",\n\nimportName: \"notEmpty\",\n\nreturnOperationName: false,\n\n}).then(console.log);",
    "operationName": "find-all-dependency-operations",
    "rawText": " async (\n  operationName: string,\n  already?: string[]\n): Promise<string[]> => {\n  const dependantOperationNames = await findDependants({\n    returnOperationName: true,\n    operationName,\n  });\n\n  const dependantsUntilNow = [\n    operationName,\n    ...dependantOperationNames,\n    ...(already || []),\n  ];\n\n  const recursedDependants: string[] =\n    dependantOperationNames.length > 0\n      ? (\n          await Promise.all(\n            dependantOperationNames.map((name) =>\n              findDependantsRecursively(name, dependantsUntilNow)\n            )\n          )\n        ).flat()\n      : [];\n\n  return [...dependantsUntilNow, ...recursedDependants].filter(onlyUnique2());\n}"
  },
  "findDependants": {
    "name": "findDependants",
    "slug": "TsFunction",
    "id": "mbmtpwowvsrmpzohoosbpdil",
    "description": "getDependencyTree([\"k-types\", \"fs-orm\"], []).then((res) =>\n\nconsole.dir(res, { depth: 999 })\n\n);\n\nfinds all dependants of an operation or a specific import from that operation\n\nnormally returns the files where the operation or function is used, unless you specify to return the operationNames only.",
    "operationName": "find-all-dependency-operations",
    "rawText": " async (config: {\n  operationName: string;\n  /**\n   * Optionally specify a specific import from an operation that you want to find the dependants for\n   */\n  importName?: string;\n  returnOperationName?: boolean;\n  /**\n   * For efficiency reasons you can provide precalculated imports\n   */\n  imports?: TsImport[];\n  /**\n   * If true, only external imports are found\n   */\n  onlyExternal?: boolean;\n}) => {\n  const {\n    operationName,\n    importName,\n    returnOperationName,\n    imports,\n    onlyExternal,\n  } = config;\n\n  const resultValueKey: keyof TsImport = returnOperationName\n    ? \"operationName\"\n    : \"projectRelativePath\";\n  const theImports = imports || (await db.get(\"TsImport\"));\n  const monorepoModules = theImports\n    .filter((x) => x.module === operationName)\n    .filter((x) => (importName ? x.name === importName : true))\n    .filter((x) =>\n      onlyExternal ? x.isAbsolute && x.operationName !== operationName : true\n    )\n    .map((x) =>\n      x.isModuleFromMonorepo && x.isModuleResolved ? x[resultValueKey] : null\n    )\n    .filter(notEmpty)\n    .filter(onlyUnique);\n\n  return monorepoModules;\n}"
  },
  "findDependenciesRecursively": {
    "name": "findDependenciesRecursively",
    "slug": "TsFunction",
    "id": "eakipagmxihxjogbprscjfuo",
    "description": "finds all dependencies of an operation name",
    "operationName": "find-all-dependency-operations",
    "rawText": " async (\n  /**\n   * all imports\n   */\n  imports: TsImport[],\n  packageJsons: PackageJson[],\n  operationName: string,\n  /**\n   * skip recursing on these ones because they are already found\n   */\n  already: string[],\n  ignore?: string[],\n  ignoreFilter?: (operationName: string) => boolean\n): Promise<string[]> => {\n  if (ignore?.includes(operationName)) return [];\n\n  const packageJson = packageJsons.find(\n    (x) => x.operationName === operationName\n  );\n\n  if (!packageJson) {\n    console.log(\n      `WARN: couldn't find packagejson ${operationName}. weird...`,\n      packageJsons.slice(0, 5)\n    );\n    return [];\n  }\n\n  const indirectDependencies =\n    packageJson.operation?.indirectDependencies || [];\n\n  /**\n   * Filter out ignored ones, either by ignore prop or ignore filter\n   */\n  const onlyIncluded = (operationName: string) =>\n    !ignore?.includes(operationName) &&\n    (!ignoreFilter || ignoreFilter(operationName));\n\n  const thisImports = imports.filter((x) => x.operationName === operationName);\n\n  const monorepoModules = thisImports\n    .map((x) =>\n      x.isModuleFromMonorepo && x.isModuleResolved ? x.module : null\n    )\n    .filter(notEmpty)\n    .filter(onlyIncluded)\n    // add the indirect ones\n    .concat(indirectDependencies);\n\n  const newAlready = already.concat(monorepoModules).filter(onlyUnique);\n\n  const dependencyPromises = monorepoModules\n    .filter((x) => !already?.includes(x))\n    .map((operationName) =>\n      findDependenciesRecursively(\n        imports,\n        packageJsons,\n        operationName,\n        newAlready,\n        ignore\n      )\n    );\n  const dependencies = (await Promise.all(dependencyPromises)).flat();\n  const all: string[] = monorepoModules.concat(dependencies);\n  return all;\n}"
  },
  "findMonorepoModules": {
    "name": "findMonorepoModules",
    "slug": "TsFunction",
    "id": "ldtqjyrzmkhharjurxzscfye",
    "description": "finds all dependencies of an operation name",
    "operationName": "find-all-dependency-operations",
    "rawText": " async (operationName: string) => {\n  const imports = await db.get(\"TsImport\", { operationName });\n  const monorepoModules = imports\n    .map((x) =>\n      x.isModuleFromMonorepo && x.isModuleResolved ? x.module : null\n    )\n    .filter(notEmpty)\n    .filter(onlyUnique);\n\n  return monorepoModules;\n}"
  },
  "getDependencyObject": {
    "name": "getDependencyObject",
    "slug": "TsFunction",
    "id": "dfnyemktbkaliwetqzqltkau",
    "description": "findAllDependencyOperations([\"fs-orm\"]).then(console.log);\n\nhow do I get a format like this?\n\nconst x = {\n\n\"fs-orm\": [\"js-util\"],\n\n\"js-util\": [],\n\n}",
    "operationName": "find-all-dependency-operations",
    "rawText": " async () => {\n  const allOperations = await exploreOperationFolders({});\n\n  const dependencyObject = mergeObjectsArray(\n    await Promise.all(\n      allOperations.map(async (operationFolderPath) => {\n        const operationName = getLastFolder(operationFolderPath);\n        const monorepoModules = await findMonorepoModules(operationName);\n\n        return { [operationName]: monorepoModules };\n      })\n    )\n  );\n\n  return dependencyObject;\n}"
  },
  "getDependencyTree": {
    "name": "getDependencyTree",
    "slug": "TsFunction",
    "id": "gnckdlmntsjlsctthmypmabt",
    "description": "",
    "operationName": "find-all-dependency-operations",
    "rawText": " async (\n  operationNames: string[],\n  stack: string[]\n): Promise<DependencyTree | null> => {\n  if (operationNames.length === 0) return null;\n\n  const dependencyTree = mergeObjectsArray(\n    await Promise.all(\n      operationNames.map(async (name) => {\n        const deps = await findMonorepoModules(name);\n        const newStack = stack.concat(name);\n        const filtered = deps.filter((dep) => !newStack.includes(dep));\n        const filteredOut = deps.filter((dep) => newStack.includes(dep));\n        if (deps.length !== filtered.length) {\n          console.log(\n            `prevented circular dependency at ${name} (${filteredOut.join(\n              \", \"\n            )} were removed)`\n          );\n        }\n        return {\n          [name]: await getDependencyTree(filtered, newStack),\n        };\n      })\n    )\n  );\n\n  return dependencyTree;\n}"
  },
  "generateBunMonopackage": {
    "name": "generateBunMonopackage",
    "slug": "TsFunction",
    "id": "yhvfqevfzvysdbhrjyabajyk",
    "description": "",
    "operationName": "generate-bun-monopackage",
    "rawText": " async () => {\n  const projectRoot = getProjectRoot();\n\n  if (!projectRoot) return;\n\n  const tsImports = await db.get(\"TsImport\");\n  const tsFunctions = (await db.get(\"TsFunction\")).filter(\n    onlyUnique2<TsFunction>((a, b) => a.name === b.name)\n  );\n  const tsVariables = (await db.get(\"TsVariable\")).filter(\n    onlyUnique2<TsVariable>((a, b) => a.name === b.name)\n  );\n  const tsInterfaces = (await db.get(\"TsInterface\"))\n    .filter((x) => !x.name.startsWith(\"NamedParameters<\"))\n    .filter(onlyUnique2<TsInterface>((a, b) => a.name === b.name));\n\n  const editedTsVariables = tsVariables.map((x) => ({\n    ...x,\n    rawText: x.value,\n  }));\n\n  const allItems = [tsFunctions, editedTsVariables, tsInterfaces]\n    .flat()\n    .filter(\n      onlyUnique2<TsFunction | TsVariable | TsInterface>(\n        (a, b) => a.name === b.name\n      )\n    );\n\n  await Promise.all(\n    allItems.map(async (item) => {\n      const newPath = getItemNewPath(projectRoot, item);\n\n      if (!newPath) return;\n\n      const otherItemsInHere = allItems.filter(\n        (x) =>\n          x.operationName === item.operationName &&\n          x.operationRelativeTypescriptFilePath ===\n            item.operationRelativeTypescriptFilePath &&\n          x.name !== item.name\n      );\n\n      const otherItemsImportsString = otherItemsInHere\n        .map((otherItem) => {\n          const importedNewPath = getItemNewPath(projectRoot, otherItem);\n          if (!importedNewPath) return;\n\n          const dir = path.parse(newPath).dir;\n          const relativePath = path.relative(dir, importedNewPath);\n          const relativeImportPath = withoutExtension(relativePath);\n          const finalRelativeImportPath = !relativeImportPath.startsWith(\".\")\n            ? \"./\" + relativeImportPath\n            : relativeImportPath;\n\n          // console.log({\n          //   importedNewPath,\n          //   dir,\n          //   relativePath,\n          //   relativeImportPath,\n          // });\n\n          return `import { ${otherItem.name} } from \"${finalRelativeImportPath}\";`;\n        })\n        .filter(notEmpty)\n        .join(\"\\n\");\n\n      const itemImports = tsImports.filter(\n        (x) =>\n          x.operationName === item.operationName &&\n          x.operationRelativeTypescriptFilePath ===\n            item.operationRelativeTypescriptFilePath\n      );\n\n      const importsString = itemImports\n        .map((tsImport) => {\n          if (tsImport.isModuleFromMonorepo === false) {\n            return `import {${tsImport.name}} from \"${tsImport.module}\";`;\n          }\n\n          const importedStatement = allItems\n            .filter((x) => x.operationName === tsImport.module)\n            .find((x) => x.name === tsImport.name);\n\n          if (!importedStatement) {\n            console.log(\"WARN no statement matches\", { name: tsImport.name });\n            return;\n          }\n\n          const importedNewPath = getItemNewPath(\n            projectRoot,\n            importedStatement\n          );\n          if (!importedNewPath) return;\n\n          const relativeImportPath = withoutExtension(\n            path.relative(path.parse(newPath).dir, importedNewPath)\n          );\n\n          return `import { ${tsImport.name} } from \"${relativeImportPath}\";`;\n        })\n        .filter(notEmpty)\n        .join(\"\\n\");\n\n      const contents = `// same file imports\\n${otherItemsImportsString}\\n\\n// previous imports:\\n ${importsString}\\n\\nexport const ${\n        item.name\n      } = ${item.rawText?.trimStart()}`;\n\n      await writeStringToFile(newPath, contents);\n    })\n  );\n\n  console.log(\"DONE\");\n}"
  },
  "getItemNewPath": {
    "name": "getItemNewPath",
    "slug": "TsFunction",
    "id": "zsokienpcabismxnxrygvlht",
    "description": "",
    "operationName": "generate-bun-monopackage",
    "rawText": " (\n  projectRoot: string,\n  item: TsFunction | TsVariable | TsInterface\n) => {\n  const projectRelativeOperationPath = operations[\n    item.operationName as keyof typeof operations\n  ] as string | undefined;\n\n  if (!projectRelativeOperationPath) return;\n\n  const operationsRelativeOperationPath = projectRelativeOperationPath.slice(\n    \"operations/\".length\n  );\n\n  const extension = getExtension(item.operationRelativeTypescriptFilePath);\n\n  const srcFolder = getSrcRelativeFileId(\n    item.operationRelativeTypescriptFilePath\n  );\n\n  const newPath = path.join(\n    projectRoot,\n    operations[\"generate-bun-monopackage\"],\n    \"assets\",\n    operationsRelativeOperationPath,\n    // srcFolder,\n    `${item.name}.${extension}`\n  );\n\n  return newPath;\n}"
  },
  "generateNamedIndex": {
    "name": "generateNamedIndex",
    "slug": "TsFunction",
    "id": "gbjoikfanfaqkstzfemcdfao",
    "description": "Generates an index.ts file based on named statements in the operation. Also generates test array. Not used currently.\n\nNB: This overwrites the indexfile of the operation in the src folder! Make sure you don't have anything there still.. All functions should be in other filenames.\n\nShould be ran every time an operation changes",
    "operationName": "generate-index",
    "rawText": " async ({\n  operationName,\n  manualProjectRoot,\n}: {\n  manualProjectRoot?: string;\n  operationName: string;\n}) => {\n  if (!operationName) {\n    log(\"No operation name, can't create index\", { type: \"error\" });\n    return;\n  }\n  const operationBasePath = await getOperationPath(operationName, {\n    manualProjectRoot,\n  });\n\n  if (!operationBasePath) {\n    log(`operationPath not found ${operationName}`, { type: \"error\" });\n    return;\n  }\n  const outputPath = path.join(operationBasePath, \"src\", \"index.ts\");\n\n  const functionArray = (\n    await db.get(\"TsFunction\", {\n      operationName,\n      manualProjectRoot,\n    })\n  )\n    .filter(\n      (x) =>\n        x.isExported && x.operationRelativeTypescriptFilePath !== \"src/index.ts\"\n    )\n    .map((item) => mapToImportStatement(item, \"function\"));\n\n  const variableArray = (\n    await db.get(\"TsVariable\", {\n      operationName,\n      manualProjectRoot,\n    })\n  )\n    .filter(\n      (x) =>\n        x.isExported && x.operationRelativeTypescriptFilePath !== \"src/index.ts\"\n    )\n    .map((item) => mapToImportStatement(item, \"variable\"));\n\n  const interfacesArray = (\n    await db.get(\"TsInterface\", {\n      operationName,\n      manualProjectRoot,\n    })\n  )\n    .filter(\n      (x) =>\n        x.isExported && x.operationRelativeTypescriptFilePath !== \"src/index.ts\"\n    )\n    .map((item) => mapToImportStatement(item, \"interface\"));\n\n  const importStatements: ImportStatement[] = [\n    ...interfacesArray,\n    ...functionArray,\n    ...variableArray,\n  ];\n  // PART 1) mapping and filtering data\n\n  const testStatements = importStatements.filter((x) => isTestFn(x));\n  const otherStatements = importStatements.filter(\n    (x) => lowerCaseArray(x.name).pop() !== \"test\"\n  );\n\n  const importStatementsString = importStatements\n    // import all values (mostly functions, some consts)\n    .map((statement) => {\n      return `import { ${statement.name} } from \"./${statement.srcRelativeFileId}\";`;\n    })\n    .filter(notEmpty)\n    .join(\"\\n\")\n    .concat(\"\\n\");\n\n  /**\n   * this should return an array of all tests of all files\n   */\n  const exportTestString =\n    testStatements.length > 0\n      ? `export const test = [${testStatements\n          .map((exp) => exp.name)\n          .join(\", \")}].flat();\\n`\n      : \"\";\n\n  /**\n   * export all values separately.\n   */\n  const exportStatementsString =\n    otherStatements.length > 0\n      ? `export { ${otherStatements.map((x) => x.name).join(\", \")} };\\n`\n      : \"\";\n\n  // PART 3) Aggreagating all scripts into one big string\n\n  const indexationString = \"// THIS FILE HAS BEEN GENERATED\\n\"\n    .concat(\"\\n\")\n    // all imports\n    .concat(importStatementsString)\n    .concat(\"\\n\\n\")\n    // all exports\n    .concat(exportTestString)\n    .concat(exportStatementsString)\n    .concat(\"\\n\")\n    .concat(\"// THANK YOU\\n\");\n\n  await fs.writeFile(outputPath, indexationString, { encoding: \"utf8\" });\n\n  log(`Created index for ${operationName}`, { type: \"debug\" });\n}"
  },
  "generateSimpleIndex": {
    "name": "generateSimpleIndex",
    "slug": "TsFunction",
    "id": "yidtnphdbnzvfomfrdgdjwjg",
    "description": "generates operation index and writes it to index.ts in src of the operation.\n\nNB: This overwrites the indexfile of the operation in the src folder! Make sure you don't have anything there still.. All functions should be in other filenames.\n\nShould be ran every time an operation changes",
    "operationName": "generate-index",
    "rawText": " async ({\n  operationName,\n  manualProjectRoot,\n}: {\n  /**\n   * if given, just exports * from those\n   */\n  operationName: string;\n  manualProjectRoot?: string;\n}): Promise<string | undefined> => {\n  if (!operationName) {\n    log(\"No operation name, can't create index\", { type: \"error\" });\n    return;\n  }\n  const operationBasePath = await getOperationPath(operationName, {\n    manualProjectRoot,\n  });\n\n  if (!operationBasePath) {\n    log(`operationPath not found ${operationName}`, { type: \"error\" });\n    return;\n  }\n\n  const classification = getOperationClassification(operationBasePath);\n\n  if (classification === \"ui-web\") {\n    log(\"Not generating index.ts for next.js project, not needed.\", {\n      type: \"default\",\n    });\n    return;\n  }\n\n  const outputPath = path.join(operationBasePath, \"src\", \"index.ts\");\n\n  const files = await getPackageSourcePaths({ operationBasePath });\n\n  const srcRelativeFileIds = files.map((fullPath) =>\n    getSrcRelativeFileId(makeRelative(fullPath, operationBasePath))\n  );\n\n  const indexationString = srcRelativeFileIds\n    .filter(isIndexableFileId)\n    .map((id) => `export * from \"./${id}\";`)\n    .join(\"\\n\");\n\n  await fs.writeFile(outputPath, indexationString, { encoding: \"utf8\" });\n\n  return outputPath;\n}"
  },
  "isTestFn": {
    "name": "isTestFn",
    "slug": "TsFunction",
    "id": "cpzvotuhxnfpjuoqrfqvvwec",
    "description": "",
    "operationName": "generate-index",
    "rawText": " (x: ImportStatement) => {\n  const nameEndsWithTest = lowerCaseArray(x.name).pop() === \"test\";\n  const typeIsFn = x.type === \"function\";\n  return typeIsFn && nameEndsWithTest;\n}"
  },
  "mapToImportStatement": {
    "name": "mapToImportStatement",
    "slug": "TsFunction",
    "id": "ksajlyovymavslxdujsrcwnp",
    "description": "",
    "operationName": "generate-index",
    "rawText": " (\n  item: TsFunction | TsVariable | TsInterface,\n  type: ImportStatement[\"type\"]\n): ImportStatement => {\n  const srcRelativeFileId = getSrcRelativeFileId(\n    item.operationRelativeTypescriptFilePath\n  );\n\n  return { name: item.name, srcRelativeFileId, type };\n}"
  },
  "generateDbSdkCli": {
    "name": "generateDbSdkCli",
    "slug": "TsFunction",
    "id": "mdasznoxeqibbevkfqcrlpan",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " () => {\n  const [customProjectRoot] = process.argv.slice(2);\n  const defaultProjectRoot = getProjectRoot(process.cwd());\n\n  generateDbSdk({ manualProjectRoot: customProjectRoot || defaultProjectRoot });\n}"
  },
  "generateDbSdk": {
    "name": "generateDbSdk",
    "slug": "TsFunction",
    "id": "pbhgqliawlvyzpdnbjpmrfwe",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n  skipYarnInstall?: boolean;\n  dryrun?: boolean;\n}) => {\n  // const dependants = await findDependantsRecursively(\"sdk-db\");\n\n  const manualProjectRoot = config?.manualProjectRoot;\n  const skipYarnInstall = config?.skipYarnInstall;\n  const dryrun = config?.dryrun;\n\n  const allDbModels = await getAllDbModels(manualProjectRoot);\n  const typeImportsString = allDbModels\n    .map((tsInterface) => {\n      return `import type { ${tsInterface.name} } from \"${tsInterface.operationName}\";`;\n    })\n    .filter(notEmpty)\n    .join(\"\\n\")\n    .concat(\"\\n\");\n\n  const exportDbTypesString = `export type DbModels = { ${allDbModels\n    .map((x) => `${x.name}: ${x.name}`)\n    .join(\",\")} };\\n`;\n\n  const exportDbKeysString = `export const dbModelKeys = [ ${allDbModels\n    .map((x) => `\"${x.name}\"`)\n    .join(\",\")} ] as const;\\n`;\n\n  const exportDbModelEnumString =\n    \"export type DbModelEnum = typeof dbModelKeys[number];\\n\";\n\n  const exportModelQueryConfigString = `export const modelQueryConfig = {\n    ${allDbModels\n      ?.map((model) => {\n        if (!model.dbStorageMethod) return;\n        return `${model.name}: {\n          ${\n            model.operationStorageLocationRelativeFilePath ||\n            model.isOperationIndex\n              ? `operationName: \"*\",`\n              : \"\"\n          }\n          dbStorageMethod: \"${model.dbStorageMethod}\",\n          ${\n            model.operationStorageLocationRelativeFilePath\n              ? `operationRelativePath: \"${model.operationStorageLocationRelativeFilePath}\",`\n              : \"\"\n          }\n        }`;\n      })\n      .filter(notEmpty)\n      .join(\",\\n\")}\n  };`;\n\n  // console.log({ dbLength: allDbModels.length });\n  // PART 3) Aggreagating all scripts into one big string\n\n  const indexationString = \"// THIS FILE HAS BEEN GENERATED\\n\"\n    .concat(\"\\n\")\n    // all imports\n    .concat(typeImportsString)\n    .concat(\"\\n\\n\")\n    // all exports\n    .concat(exportDbTypesString)\n    .concat(exportDbKeysString)\n    .concat(exportDbModelEnumString)\n    .concat(exportModelQueryConfigString)\n    .concat(\"\\n\")\n    .concat(\"// THANK YOU\\n\");\n\n  await newOperationWithFiles(\n    \"sdk-db\",\n    await getSdkDescription(\"sdk-db\"),\n    { \"src/sdk-db.ts\": indexationString },\n    { overwriteIfExists: true, skipYarnInstall, manualProjectRoot, dryrun }\n  );\n}"
  },
  "generateEnvSdksCli": {
    "name": "generateEnvSdksCli",
    "slug": "TsFunction",
    "id": "kvehkftznbodcpqzgalwkkxj",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " async () => {\n  const bundleConfig = (await db.get(\"BundleConfig\"))[0];\n\n  if (!bundleConfig) {\n    console.log(\"DIDNT WORK\");\n    return;\n  }\n\n  const [customProjectRoot] = process.argv.slice(2);\n  const defaultProjectRoot = getProjectRoot(process.cwd());\n\n  await generateEnvSdks(bundleConfig, {\n    manualProjectRoot: customProjectRoot || defaultProjectRoot,\n  });\n}"
  },
  "generateEnvSdks": {
    "name": "generateEnvSdks",
    "slug": "TsFunction",
    "id": "qhyieunvfxpwcpsdjewzknyq",
    "description": "generates sdk-env-public and sdk-env-private\n\nreturns the paths of the geneated operations",
    "operationName": "generate-sdk-operations",
    "rawText": " async (\n  bundleConfig: BundleConfig,\n  config?: {\n    manualProjectRoot?: string;\n    skipYarnInstall?: boolean;\n    dryrun?: boolean;\n  }\n) => {\n  const promises = [\n    newEnvSdk(bundleConfig, \"public\", config),\n    newEnvSdk(bundleConfig, \"private\", config),\n  ];\n\n  const results = await Promise.all(promises);\n\n  return results;\n}"
  },
  "generateFunctionPathsSdk": {
    "name": "generateFunctionPathsSdk",
    "slug": "TsFunction",
    "id": "upqqaknbbggjuggnlubnicbd",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n  skipYarnInstall?: boolean;\n  dryrun?: boolean;\n}) => {\n  const skipYarnInstall = config?.skipYarnInstall;\n  const dryrun = config?.dryrun;\n  const manualProjectRoot = config?.manualProjectRoot;\n  const projectRoot = manualProjectRoot || getProjectRoot();\n  if (!projectRoot) return;\n\n  const tsFunctions = await db.get(\"TsFunction\", { manualProjectRoot });\n\n  const functionPathsObject = mergeObjectsArray(\n    tsFunctions\n      .map((tsFunction) => {\n        const projectRelativePath = tsFunction.projectRelativePath;\n        const exists = fs.existsSync(\n          path.join(projectRoot, projectRelativePath)\n        );\n        if (!exists) return;\n        return { [tsFunction.name]: projectRelativePath };\n      })\n      .filter(notEmpty)\n  );\n\n  const operationObjectString = `export const sdkFunctionPaths = ${JSON.stringify(\n    functionPathsObject,\n    null,\n    2\n  )};`;\n\n  await newOperationWithFiles(\n    \"sdk-function-paths\",\n    await getSdkDescription(\"sdk-function-paths\"),\n    { \"src/sdk-function-paths.ts\": operationObjectString },\n    { overwriteIfExists: true, skipYarnInstall, manualProjectRoot, dryrun }\n  );\n}"
  },
  "generateFunctionSdksCli": {
    "name": "generateFunctionSdksCli",
    "slug": "TsFunction",
    "id": "wmhtklhtoxyxztrxccsqiygn",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " () => {\n  const [dryrunString, customProjectRoot] = process.argv.slice(2);\n  const dryrun = dryrunString === \"true\";\n  const defaultProjectRoot = getProjectRoot(process.cwd());\n  generateFunctionSdks({\n    manualProjectRoot: customProjectRoot || defaultProjectRoot,\n    dryrun,\n  });\n}"
  },
  "generateFunctionSdks": {
    "name": "generateFunctionSdks",
    "slug": "TsFunction",
    "id": "njaepfreacvovkmiflfnpfcr",
    "description": "Creates\n\n- sdk-api + sdk-api-keys (for all exposed functions)\n- sdk-js (functions that can be executed anywhere)\n- sdk-ui (functions that use JSX)\n\nOverwrites them if they already exist with minimal interruption time of the system",
    "operationName": "generate-sdk-operations",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n  skipYarnInstall?: boolean;\n  dryrun?: boolean;\n}) => {\n  const manualProjectRoot = config?.manualProjectRoot;\n\n  const { apiFunctions, jsFunctions, uiFunctions } =\n    await getFunctionSdksContent({ manualProjectRoot });\n\n  if (!apiFunctions || !jsFunctions || !uiFunctions) return;\n\n  const promises = [\n    // sdks\n    newFunctionSdkOperation(\"sdk-api\", apiFunctions, config),\n    newFunctionSdkOperation(\"sdk-js\", jsFunctions, config),\n    newFunctionSdkOperation(\"sdk-ui\", uiFunctions, config),\n\n    /**\n     * SDK Keys operations: Needed because \"sdk-api\" is node-only\n     */\n    newFunctionKeysSdkOperation(\n      \"sdk-api-keys\",\n      [\n        {\n          variableName: \"functionApiKeys\",\n          values: apiFunctions.map((x) => x.name),\n        },\n      ],\n      config\n    ),\n  ];\n\n  await Promise.all(promises);\n}"
  },
  "generateInterfacePathsSdkCli": {
    "name": "generateInterfacePathsSdkCli",
    "slug": "TsFunction",
    "id": "njlzckrruqjstymkfmevzxxf",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " () => {\n  const [dryrunString, customProjectRoot] = process.argv.slice(2);\n  const dryrun = dryrunString === \"true\";\n  const defaultProjectRoot = getProjectRoot(process.cwd());\n\n  const manualProjectRoot = customProjectRoot || defaultProjectRoot;\n  generateInterfacePathsSdk({ dryrun, manualProjectRoot });\n}"
  },
  "generateInterfacePathsSdk": {
    "name": "generateInterfacePathsSdk",
    "slug": "TsFunction",
    "id": "zpkyhzvxpmbuuckggcabiyfo",
    "description": "`sdk-function-paths` indexes all operations and builds an object containing all operations.",
    "operationName": "generate-sdk-operations",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n  skipYarnInstall?: boolean;\n  dryrun?: boolean;\n}) => {\n  const skipYarnInstall = config?.skipYarnInstall;\n  const dryrun = config?.dryrun;\n  const manualProjectRoot = config?.manualProjectRoot;\n  const projectRoot = manualProjectRoot || getProjectRoot();\n  if (!projectRoot) return;\n\n  const tsInterfaces = await db.get(\"TsInterface\", {\n    manualProjectRoot,\n    operationName: \"*\",\n  });\n\n  const interfacePathsObject = mergeObjectsArray(\n    tsInterfaces\n      .map((tsInterface) => {\n        const projectRelativePath = tsInterface.projectRelativePath;\n        const exists = fs.existsSync(\n          path.join(projectRoot, projectRelativePath)\n        );\n        if (!exists) return;\n        return { [tsInterface.name]: projectRelativePath };\n      })\n      .filter(notEmpty)\n  );\n\n  const operationObjectString = `export const sdkInterfacePaths = ${JSON.stringify(\n    interfacePathsObject,\n    null,\n    2\n  )};`;\n\n  await newOperationWithFiles(\n    \"sdk-interface-paths\",\n    await getSdkDescription(\"sdk-interface-paths\"),\n    { \"src/sdk-interface-paths.ts\": operationObjectString },\n    { overwriteIfExists: true, skipYarnInstall, manualProjectRoot, dryrun }\n  );\n}"
  },
  "generateOperationsSdkCli": {
    "name": "generateOperationsSdkCli",
    "slug": "TsFunction",
    "id": "evjjzifeqneehlwotxzzhafy",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " () => {\n  const [customProjectRoot] = process.argv.slice(2);\n  const defaultProjectRoot = getProjectRoot(process.cwd());\n\n  generateOperationsSdk({\n    manualProjectRoot: customProjectRoot || defaultProjectRoot,\n  });\n}"
  },
  "generateOperationsSdk": {
    "name": "generateOperationsSdk",
    "slug": "TsFunction",
    "id": "biszkwjohilsfozkelhlpofb",
    "description": "`sdk-operations` indexes all operations and builds an object containing all operations.",
    "operationName": "generate-sdk-operations",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n  skipYarnInstall?: boolean;\n  dryrun?: boolean;\n}) => {\n  const skipYarnInstall = config?.skipYarnInstall;\n  const dryrun = config?.dryrun;\n  const manualProjectRoot = config?.manualProjectRoot;\n  const projectRoot = manualProjectRoot || getProjectRoot();\n  if (!projectRoot) return;\n\n  const operationFolderPaths = await exploreOperationFolders({\n    basePath: getPathsWithOperations({ manualProjectRoot }),\n  });\n\n  const operationNamePathRows = operationFolderPaths.map(\n    (operationFolderPath) => {\n      const operationName = getLastFolder(operationFolderPath);\n\n      return `\"${operationName}\": \"${makeRelative(\n        operationFolderPath,\n        projectRoot\n      )}\"`;\n    }\n  );\n  const operationObjectString = `export const operations = { ${operationNamePathRows.join(\n    \",\\n\"\n  )} };`;\n\n  await newOperationWithFiles(\n    \"sdk-operations\",\n    await getSdkDescription(\"sdk-operations\"),\n    { \"src/sdk-operations.ts\": operationObjectString },\n    { overwriteIfExists: true, skipYarnInstall, manualProjectRoot, dryrun }\n  );\n}"
  },
  "generateSdkApiCli": {
    "name": "generateSdkApiCli",
    "slug": "TsFunction",
    "id": "gsirglsatolixsnmumxqcnlj",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " () => {\n  const [customProjectRoot] = process.argv.slice(2);\n  const defaultProjectRoot = getProjectRoot(process.cwd());\n\n  generateSdkApi({\n    manualProjectRoot: customProjectRoot || defaultProjectRoot,\n  });\n}"
  },
  "generateSdkApiWatcher": {
    "name": "generateSdkApiWatcher",
    "slug": "TsFunction",
    "id": "zyzmfwmwvjcaymkthknkmnhe",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " async () => {\n  if (isRegenerating === true) {\n    // Don't run if it's already running\n    return;\n  }\n  // console.log(\"Generate sdk-api...\");\n\n  // isRegenerating = true;\n  // await generateSdkApi();\n\n  // console.log(\"DONE, exiting server\");\n  // isRegenerating = false;\n  process.exit();\n}"
  },
  "generateSdkApi": {
    "name": "generateSdkApi",
    "slug": "TsFunction",
    "id": "zyntgmfblhfajhlvkjopowtw",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n  skipYarnInstall?: boolean;\n  dryrun?: boolean;\n}) => {\n  const manualProjectRoot = config?.manualProjectRoot;\n\n  const { apiFunctions } = await getFunctionSdksContent({ manualProjectRoot });\n\n  if (!apiFunctions) return;\n\n  const promises = [\n    // sdks\n    newFunctionSdkOperation(\"sdk-api\", apiFunctions, config),\n\n    /**\n     * SDK Keys operations: Needed because \"sdk-api\" is node-only\n     */\n    newFunctionKeysSdkOperation(\n      \"sdk-api-keys\",\n      [\n        {\n          variableName: \"functionApiKeys\",\n          values: apiFunctions.map((x) => x.name),\n        },\n      ],\n      { ...config, skipYarnInstall: true }\n    ),\n  ];\n\n  await Promise.all(promises);\n}"
  },
  "generateSdkOperationsCli": {
    "name": "generateSdkOperationsCli",
    "slug": "TsFunction",
    "id": "edbnrsfmrzjyjgsvuboumuhp",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " () => {\n  const [dryrunString, customProjectRoot] = process.argv.slice(2);\n\n  const dryrun = dryrunString ? Boolean(dryrunString) : undefined;\n\n  const defaultProjectRoot = getProjectRoot(process.cwd());\n\n  generateSdkOperations(undefined, {\n    dryrun,\n    yarnInstallAfter: true,\n    manualProjectRoot: customProjectRoot || defaultProjectRoot,\n  });\n\n  if (dryrun) {\n    console.log(\"Check new-operation/assets\");\n  } else {\n    console.log(\"Check generated\");\n  }\n}"
  },
  "generateSdkOperations": {
    "name": "generateSdkOperations",
    "slug": "TsFunction",
    "id": "bmokpdhzrmrqtrrzkjutgohh",
    "description": "(re)generates all sdk operations for any project",
    "operationName": "generate-sdk-operations",
    "rawText": " async (\n  /**\n   * if not provided, will not generate env-sdks\n   */\n  bundleConfig?: BundleConfig,\n  config?: {\n    /**\n     * If true, will try to run yarn install before and if it fails, does not continue.\n     */\n    yarnInstallBefore?: boolean;\n    /**\n     * if true, yarn install will be skipped when generating the sdks, but run one time afterwards\n     *\n     * useful if you are sure that there will be multiple yarn Installs needed otherwise\n     *\n     * for os installation (where all operations already exist, don't do this, yarn installs will probably not happen at all)\n     */\n    yarnInstallAfter?: boolean;\n    manualProjectRoot?: string;\n    dryrun?: boolean;\n  }\n): Promise<boolean> => {\n  const manualProjectRoot = config?.manualProjectRoot;\n  const projectRoot = manualProjectRoot || getProjectRoot();\n  const yarnInstallAfter = config?.yarnInstallAfter;\n  const yarnInstallBefore = config?.yarnInstallBefore;\n  const dryrun = config?.dryrun;\n\n  if (!projectRoot) {\n    return false;\n  }\n\n  // NB: install this first, otherwise sdk-operations cannot be found\n  const promises = [\n    generateOperationsSdk({\n      manualProjectRoot,\n      dryrun,\n    }),\n    generateFunctionPathsSdk({\n      manualProjectRoot,\n      dryrun,\n    }),\n    generateInterfacePathsSdk({ manualProjectRoot, dryrun }),\n    generateDbSdk({\n      manualProjectRoot,\n      skipYarnInstall: yarnInstallAfter,\n      dryrun,\n    }),\n    generateFunctionSdks({\n      manualProjectRoot,\n      skipYarnInstall: yarnInstallAfter,\n      dryrun,\n    }),\n\n    bundleConfig\n      ? generateEnvSdks(bundleConfig, {\n          manualProjectRoot,\n          skipYarnInstall: yarnInstallAfter,\n          dryrun,\n        })\n      : undefined,\n  ];\n\n  await Promise.all(promises);\n\n  if (yarnInstallAfter) {\n    process.stdout.write(`Installing repo `);\n    try {\n      // NB: I got an engine error which seemed to break it, so to fix it I ignore engines now https://stackoverflow.com/questions/56617209/the-engine-node-is-incompatible-with-this-module\n\n      const result = execSync(\"yarn --prefer-offline --ignore-engines\", {\n        cwd: projectRoot,\n        encoding: \"utf8\",\n        stdio: \"pipe\",\n      });\n\n      console.log(\"âœ…\");\n\n      return true;\n    } catch (e: any) {\n      console.log(\"âŒ\");\n      const error: {\n        status: number;\n        signal: any;\n        output: (string | null)[];\n        pid: number;\n        stdout: string;\n        stderr: string;\n      } = e;\n      console.log(`Could not install:`, error);\n\n      return false;\n    }\n  }\n\n  return true;\n}"
  },
  "getFunctionSdksContent": {
    "name": "getFunctionSdksContent",
    "slug": "TsFunction",
    "id": "adyvoiokuapvvlojmgqodrbk",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n}): Promise<{\n  jsFunctions?: TsFunction[];\n  apiFunctions?: TsFunction[];\n  uiFunctions?: TsFunction[];\n}> => {\n  const manualProjectRoot = config?.manualProjectRoot;\n\n  const functionsPerClassification = await getSdkFunctionsPerClassification({\n    manualProjectRoot,\n  });\n\n  if (!functionsPerClassification) return {};\n\n  const jsFunctions = functionsPerClassification[\"cjs\"].concat(\n    functionsPerClassification[\"esm\"]\n  );\n\n  const apiFunctions = functionsPerClassification[\"node-cjs\"]\n    .concat(functionsPerClassification[\"node-esm\"])\n    .concat(functionsPerClassification[\"cjs\"])\n    .concat(functionsPerClassification[\"esm\"]);\n\n  const uiFunctions = functionsPerClassification[\"ui-cjs\"].concat(\n    functionsPerClassification[\"ui-esm\"]\n  );\n\n  return { jsFunctions, apiFunctions, uiFunctions };\n}"
  },
  "getSdkDescription": {
    "name": "getSdkDescription",
    "slug": "TsFunction",
    "id": "trdoyrwncelpkkofxjwapiig",
    "description": "Gets a description of any sdk operation from the assets",
    "operationName": "generate-sdk-operations",
    "rawText": " async (\n  operationName: string\n): Promise<string | undefined> => {\n  const descriptionPath = path.join(\n    __dirname,\n    \"..\",\n    \"assets\",\n    \"descriptions\",\n    `${operationName}.md`\n  );\n\n  if (!fs.existsSync(descriptionPath)) return;\n\n  const contents = await fs.readFile(descriptionPath, \"utf8\");\n\n  return contents;\n}"
  },
  "getSdkFunctionsPerClassification": {
    "name": "getSdkFunctionsPerClassification",
    "slug": "TsFunction",
    "id": "xxobyfewedmvaizgostiajdx",
    "description": "returns all sdk functions grouped by operation classification",
    "operationName": "generate-sdk-operations",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n}): Promise<FunctionsPerClassification | undefined> => {\n  const manualProjectRoot = config?.manualProjectRoot;\n  const projectRoot = manualProjectRoot || getProjectRoot();\n  if (!projectRoot) return;\n\n  const sdkDependants = await findDependantsRecursively(\"sdk\");\n\n  const tsFunctions = await db.get(\"TsFunction\", { manualProjectRoot });\n\n  const exportedFunctions = tsFunctions\n    .filter((x) => x.isExported)\n    .filter(tsFunctionIsIndexable)\n    .filter((x) => {\n      return x.operationName && !sdkDependants.includes(x.operationName);\n    })\n    .filter(onlyUnique2<TsFunction>((a, b) => a.name === b.name));\n\n  console.log({ exportedFunctions: exportedFunctions.length });\n\n  const operationFolders = await exploreOperationFolders({});\n  const operationClassificationObject =\n    await getOperationClassificationObject();\n\n  // console.log({ operationClassificationObject });\n  const operationIsSdkableObject = mergeObjectsArray(\n    await Promise.all(\n      operationFolders.map(async (operationFolderPath) => {\n        const packageJson = await getPackageJson({ operationFolderPath });\n        const isSdkable = packageJson?.operation?.isNotSdkable ? false : true;\n        const operationName = getLastFolder(operationFolderPath);\n\n        return { [operationName]: isSdkable };\n      })\n    )\n  );\n\n  const sdkFunctionsPerClassification = mergeObjectsArray(\n    operationClassificationConst.map((operationClassification) => {\n      const sdkFunctions = exportedFunctions\n        .filter((x) => {\n          if (!x.operationName) return false;\n          const isSdkable = operationIsSdkableObject[x.operationName];\n          return isSdkable;\n        })\n        .filter((x) =>\n          tsFunctionIsSdkable(\n            x,\n            operationClassificationObject,\n            operationClassification\n          )\n        )\n        .filter(onlyUnique2<TsFunction>((a, b) => a.name === b.name));\n\n      log(\n        `for ${operationClassification} we found ${sdkFunctions.length} functions`,\n        { type: \"debug\" }\n      );\n      if (sdkFunctions.length === 0)\n        log(\n          `Warning: 0 functions found for ${operationClassification} operations`,\n          { type: \"debug\" }\n        );\n\n      return { [operationClassification]: sdkFunctions };\n    })\n  ) as FunctionsPerClassification;\n\n  return sdkFunctionsPerClassification;\n}"
  },
  "isNonUiOperationBuild": {
    "name": "isNonUiOperationBuild",
    "slug": "TsFunction",
    "id": "vhqstdfqcsepqzvyvhmcxorg",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " (\n  eventName: WatchEventType,\n  path: string\n) => {\n  // for indexation we don't care about any other event than adding or changing a file\n  if (![\"add\", \"change\"].includes(eventName)) return false;\n  // in order to index a file, it must be in an operation, which means it must be in src\n  if (!path.includes(\"/build/\")) return false;\n  // only ts and tsx files matter, the rest doesn't need to be indexed\n  if (![\"js\"].includes(getExtension(path))) return false;\n\n  // only for operations\n  const operationPath = findOperationBasePath(path);\n  if (!operationPath) return false;\n\n  // we don't care about ui operations\n  const classification = getOperationClassification(operationPath);\n  if (!classification || classification.startsWith(\"ui-\")) {\n    return false;\n  }\n  return true;\n}"
  },
  "isRegenerating": {
    "name": "isRegenerating",
    "slug": "TsVariable",
    "id": "avtmeidjzsedkuivldqdhgzl",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "newEnvSdk": {
    "name": "newEnvSdk",
    "slug": "TsFunction",
    "id": "ebitxyheqiqwbyfwvsoovbvh",
    "description": "# Environment variables\n\nAs a full stack app we need a good solution for environment variables that need to be accessible anywhere and can be customized, some `.gitignore'd`, some not. Some public, some only in the backend.\n\nconifg:\n- public (local, remote) = sdk-env-public\n- private (local, remote) = sdk-env-private\n\nThis information will be fetched from the bundleconfig",
    "operationName": "generate-sdk-operations",
    "rawText": " async (\n  /**\n   * NB: if this is not a bundle, a more general purpose bundle config should be used\n   */\n  bundleConfig: BundleConfig,\n  type: \"public\" | \"private\",\n  config?: {\n    manualProjectRoot?: string;\n    skipYarnInstall?: boolean;\n    dryrun?: boolean;\n  }\n): Promise<string | undefined> => {\n  // 1. gets env from bundle\n  const operationName = `sdk-env-${type}`;\n  const description = await getSdkDescription(operationName);\n\n  const projectRoot = config?.manualProjectRoot || getProjectRoot();\n  if (!projectRoot) return;\n\n  const skipYarnInstall = config?.skipYarnInstall;\n  const dryrun = config?.dryrun;\n  const envVariables =\n    bundleConfig.customisableBundleConfig[`${type}EnvironmentVariables`];\n  const realEnv =\n    envVariables && typeof envVariables === \"object\" ? envVariables : {};\n\n  // 2. creates [type].ts and [type]-local.ts that adheres a type interface\n\n  const typescriptFileString = `export const ${type}EnvironmentVariables = ${JSON.stringify(\n    realEnv,\n    null,\n    2\n  )};`;\n\n  const localComment =\n    \"Optionally, overwrite some of your environent variables locally here. Only applied in development. NB: When working in a team, it may be useful to .gitignore this file!\";\n\n  const localTypescriptFileString = `import { ${type}EnvironmentVariables } from \"./${type}\";\\n// ${localComment}\\nexport const ${type}LocalEnvironmentVariables: Partial<typeof ${type}EnvironmentVariables> = {};`;\n\n  const srcFileContentObject = {\n    [`src/${type}-local.ts`]: localTypescriptFileString,\n    [`src/${type}.ts`]: typescriptFileString,\n  };\n\n  // keep the same operationconfig as the os project, or make a new one if not found\n\n  const operationBasePath = await newOperationWithFiles(\n    operationName,\n    description,\n    srcFileContentObject,\n    { manualProjectRoot: projectRoot, skipYarnInstall, dryrun }\n  );\n  return operationBasePath;\n}"
  },
  "newFunctionKeysSdkOperation": {
    "name": "newFunctionKeysSdkOperation",
    "slug": "TsFunction",
    "id": "mvcfumekgugxpuynhawhzfic",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " async (\n  operationName: string,\n  keyVariables: {\n    variableName: string;\n    values: string[];\n  }[],\n  config?: {\n    manualProjectRoot?: string;\n    skipYarnInstall?: boolean;\n    dryrun?: boolean;\n  }\n) => {\n  const keysConstString = keyVariables\n    .map((keyVariable) => {\n      return `export const ${keyVariable.variableName} = [ ${keyVariable.values\n        .map((value) => `\"${value}\"`)\n        .join(\",\\n\")} ];`;\n    })\n    .join(\"\\n\\n\");\n\n  const result = await newOperationWithFiles(\n    operationName,\n    undefined,\n    { [`src/${operationName}.ts`]: keysConstString },\n    { overwriteIfExists: true, ...config }\n  );\n\n  return result;\n}"
  },
  "newFunctionSdkOperation": {
    "name": "newFunctionSdkOperation",
    "slug": "TsFunction",
    "id": "fxpunfylerarlnnehgwrhxpl",
    "description": "Uses an array of functions to create an operation that imports all those functions and exports an object where all those functions have been comprised",
    "operationName": "generate-sdk-operations",
    "rawText": " async (\n  operationName: string,\n  tsFunctions: TsFunction[],\n  config?: {\n    manualProjectRoot?: string;\n    skipYarnInstall?: boolean;\n    dryrun?: boolean;\n  }\n) => {\n  log(`${operationName} should contain ${tsFunctions.length} functions`, {\n    type: \"debug\",\n  });\n  const skipYarnInstall = config?.skipYarnInstall;\n  const manualProjectRoot = config?.manualProjectRoot;\n  const dryrun = config?.dryrun;\n  const importsString = tsFunctions\n    .map((fn) => `import { ${fn.name} } from \"${fn.operationName}\";`)\n    .join(\"\\n\");\n  const sdkConstString = `export const sdk = { ${tsFunctions\n    .map((fn) => `${fn.name}`)\n    .join(\",\\n\")}};`;\n\n  const sdkTypeString = `export type SdkType = typeof sdk;`;\n\n  const sdkTypescriptFileString = `${importsString}\\n\\n${sdkConstString}\\n\\n${sdkTypeString}`;\n\n  const description = await getSdkDescription(operationName);\n\n  const filesObject = { [`src/${operationName}.ts`]: sdkTypescriptFileString };\n  const result = await newOperationWithFiles(\n    operationName,\n    description,\n    filesObject,\n    {\n      overwriteIfExists: true,\n      manualProjectRoot,\n      skipYarnInstall,\n      dryrun,\n    }\n  );\n\n  return result;\n}"
  },
  "tsFunctionIsIndexable": {
    "name": "tsFunctionIsIndexable",
    "slug": "TsFunction",
    "id": "rfumnrwzsvpxeyyfkgrxajvi",
    "description": "The path of the function should be indexed by `generateSimpleIndex`, otherwise we can't import it either!",
    "operationName": "generate-sdk-operations",
    "rawText": " (tsFunction: TsFunction) => {\n  const fileId = getSrcRelativeFileId(\n    tsFunction.operationRelativeTypescriptFilePath\n  );\n  return isIndexableFileId(fileId);\n}"
  },
  "tsFunctionIsSdkable": {
    "name": "tsFunctionIsSdkable",
    "slug": "TsFunction",
    "id": "ypllzjclgpnlwaofnmhtjnbj",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " (\n  tsFunction: TsFunction,\n  operationClassificationObject: OperationClassificationObject,\n  operationClassification: OperationClassification\n) => {\n  const { operationName } = tsFunction;\n  if (!operationName) return false;\n\n  const functionClassification = operationClassificationObject[operationName];\n\n  const isSdkable = functionClassification === operationClassification;\n\n  return isSdkable;\n}"
  },
  "updateClassifications": {
    "name": "updateClassifications",
    "slug": "TsFunction",
    "id": "ojxkobbckehhbpzxzcssfqzl",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " () => {\n  forAllFolders({\n    type: \"operations\",\n    basePath: getPathsWithOperations(),\n    callback: async (folderPath, index) => {\n      const operationName = getLastFolder(folderPath);\n\n      const classificationIndexed = getOperationClassification(folderPath);\n      console.log(`${operationName}: ${classificationIndexed}`);\n\n      await db.update(\n        \"Operation\",\n        (item) => item.name === operationName,\n        (old) =>\n          mergeNestedObject(old, { operation: { classificationIndexed } }),\n        { operationName }\n      );\n\n      console.log(\"updated\");\n\n      return;\n    },\n  });\n}"
  },
  "getImportedDependencies": {
    "name": "getImportedDependencies",
    "slug": "TsFunction",
    "id": "pbgeqievteyhykinrxmpxbuk",
    "description": "DEPRECATED: should use generated index files with imports instead!\n\ngets all imported packages (dependencies) in a project\ndoesn't take into account the fact that someone can set up a rule for absolute imports within the package.\nthis assumes that any absolute package comes from node_modules.",
    "operationName": "get-imported-dependencies",
    "rawText": " ({\n  operationFolderPath,\n}: {\n  operationFolderPath: string;\n}) => {\n  const project = getTsMorphProject(operationFolderPath);\n  if (!project) return;\n  const sourceFiles = project.getSourceFiles(\"src/*\");\n  const importModuleStrings = sourceFiles.reduce((imports, sourceFile) => {\n    const allImports: ImportDeclaration[] = sourceFile.getImportDeclarations();\n    const absoluteImports = allImports.map((i) =>\n      i.getModuleSpecifier().getLiteralText()\n    );\n    return imports.concat(absoluteImports);\n  }, [] as string[]);\n\n  const packages = importModuleStrings.filter(isAbsoluteImport).map(getPackage);\n  return packages;\n}"
  },
  "getPackage": {
    "name": "getPackage",
    "slug": "TsFunction",
    "id": "nahxcsxcgeigmjziyiqenaxc",
    "description": "only the first part",
    "operationName": "get-imported-dependencies",
    "rawText": " (absoluteModuleString: string) =>\n  absoluteModuleString.split(\"/\")[0]"
  },
  "isAbsoluteImport": {
    "name": "isAbsoluteImport",
    "slug": "TsFunction",
    "id": "kwyhubovdzgfbtlkgreisqji",
    "description": "",
    "operationName": "get-imports-exports",
    "rawText": " (moduleString: string | undefined) =>\n  moduleString ? !moduleString.startsWith(\".\") : false"
  },
  "calculatePackageJsonDependencies": {
    "name": "calculatePackageJsonDependencies",
    "slug": "TsFunction",
    "id": "dszwdweaukjuhgwwesnqbtbd",
    "description": "Calculates new packageJson dependencies object based on imports found in the whole operation.\n\nFor monorepo modules, uses the version inside its packagejson (Uses the database to obtain the package.json)\n\nGenerated packages are not added to dependencies. Instead a config is added saying this operation only works within a monorepo since it has generated operation deps that are not on the npm registry\n\nFor external modules, uses the version that was already present in dependencies, or uses \"*\"\n\nAlso keeps the dependencies that were already there, nothing is removed.",
    "operationName": "get-imports-exports",
    "rawText": " (\n  /**\n   * Current dependencies object in your operation\n   */\n  dependencies: PackageInfoObject | undefined,\n  /**\n   * All imports found in your operation\n   */\n  imports: Creation<TsImport>[],\n  /**\n   * All package-json's in your monorepo\n   */\n  operations: Operation[],\n  operationName: string\n) => {\n  const dependencyImports = imports\n    .filter((x) => x.isAbsolute)\n    .filter((x) => !isAbsoluteImportBuiltin(x.module))\n    .filter((x) => !isImportFromOptionalFile(x))\n    .filter(onlyUnique2<Creation<TsImport>>((a, b) => a.module === b.module));\n\n  /**\n   *  NB: imports of types are removed and need not to be installed for running this package\n   */\n  const valueDependencyImports = dependencyImports.filter(\n    (x) => x.type === \"value\"\n  );\n\n  const monorepoImports = dependencyImports.filter(\n    (x) =>\n      operationName &&\n      x.isModuleFromMonorepo &&\n      !isGeneratedOperationName(x.module)\n  );\n\n  const hasGeneratedDependenciesIndexed =\n    valueDependencyImports.filter(isImportGenerated).length > 0;\n\n  // console.log({ valueDependencyImports, hasGeneratedDependenciesIndexed });\n  // const hasGeneratedImportsIndexed =\n  //   dependencyImports.filter(isImportGenerated).length > 0;\n\n  const externalImports = dependencyImports.filter(\n    (x) => !x.isModuleFromMonorepo\n  );\n\n  const externalDependencyObject = mergeObjectsArray(\n    externalImports\n      .map((x) => {\n        const moduleName = getPackageNameFromAbsoluteImport(x.module);\n        if (!moduleName) return;\n        const already = dependencies?.[moduleName];\n        /**\n         * TODO: fetch this from monorepo\n         */\n        const calculatedVersion = \"*\";\n\n        /**\n         * NB: Minimize the use of \"*\"\n         */\n        const version =\n          already !== \"*\" && already !== undefined\n            ? already\n            : calculatedVersion;\n        return { [moduleName]: version };\n      })\n      .filter(notEmpty)\n  );\n\n  const monorepoDependencyObject = mergeObjectsArray(\n    monorepoImports\n      .map((x) => {\n        const moduleName = getPackageNameFromAbsoluteImport(x.module);\n        if (!moduleName) return;\n        const operation = operations.find((x) => x.name === moduleName);\n        if (!operation) return;\n        const { version } = operation;\n        if (!version) return;\n        return { [moduleName]: version };\n      })\n      .filter(notEmpty)\n  );\n\n  // console.log({\n  //   imports: imports.length,\n  //   dependencyImports: dependencyImports,\n  //   dependencies,\n  //   monorepoImports,\n  //   monorepoDependencyObject,\n  //   externalDependencyObject,\n  // });\n\n  const newDependencies: PackageInfoObject = {\n    ...dependencies,\n    ...monorepoDependencyObject,\n    ...externalDependencyObject,\n  };\n\n  return {\n    newDependencies,\n    hasGeneratedDependenciesIndexed,\n    // hasGeneratedImportsIndexed,\n  };\n}"
  },
  "CONCURRENTLY_INDEXED_FILES_AMOUNT": {
    "name": "CONCURRENTLY_INDEXED_FILES_AMOUNT",
    "slug": "TsVariable",
    "id": "jkliogyxavnyeblkgdfeinsz",
    "description": "",
    "operationName": "get-imports-exports"
  },
  "findAndWriteImportsExports": {
    "name": "findAndWriteImportsExports",
    "slug": "TsFunction",
    "id": "mkansgsjtxjgolzhibdvljtk",
    "description": "takes an operation base path and finds all imports and exports in all the files, and writes it to the ts-imports/ts-exports indexes\n\nNB: has a side effect: it also updates the package.json to include all needed dependencies.",
    "operationName": "get-imports-exports",
    "rawText": " async (\n  operationBasePath: string,\n  /**\n   * Manual project root of the operation where the imports and exports needs to be detected and written to database\n   */\n  manualProjectRoot?: string\n): Promise<void> => {\n  const operationName = getLastFolder(operationBasePath);\n  const sourceFiles = await getAllTsMorphSourceFiles(operationBasePath);\n\n  if (!sourceFiles || sourceFiles.length === 0) {\n    const problem = `couldn't load any SourceFiles for ${operationBasePath} (sourceFiles=${sourceFiles})`;\n    log(problem, { type: \"error\" });\n    await writeResult({\n      success: false,\n      message: problem,\n      operationName,\n      manualProjectRoot,\n    });\n    return;\n  }\n\n  const importsAndExports = await getImportsExports({\n    sourceFiles,\n    manualProjectRoot,\n  });\n\n  if (!importsAndExports) {\n    const problem = \"Something went wrong creating imports/exports\";\n    log(problem, { type: \"error\" });\n    await writeResult({\n      success: false,\n      message: problem,\n      operationName,\n      manualProjectRoot,\n    });\n\n    return;\n  }\n\n  const { exports, imports } = importsAndExports;\n\n  // When rebuilding operations, add `packageJson.dependencies` according to imports found.\n  const operations = await db.get(\"Operation\", { manualProjectRoot });\n\n  await db.update(\n    \"Operation\",\n    // NB: this should always be true, but this extra check will make sure it doesn't update too much...\n    (x) => x.name === operationName,\n    (packageJson) => {\n      const { newDependencies, hasGeneratedDependenciesIndexed } =\n        calculatePackageJsonDependencies(\n          packageJson.dependencies,\n          imports,\n          operations,\n          operationName\n        );\n\n      const newOperation: Operation = {\n        ...packageJson,\n        operation: {\n          ...packageJson.operation,\n          hasGeneratedDependenciesIndexed,\n        },\n        dependencies: newDependencies,\n      };\n      return newOperation;\n    },\n    { operationName, manualProjectRoot }\n  );\n\n  await db.clear(\"TsImport\", { operationName, manualProjectRoot });\n  await db.clear(\"TsExport\", { operationName, manualProjectRoot });\n\n  // @ts-ignore\n  await db.upsert(\"TsImport\", imports, { operationName, manualProjectRoot });\n  // @ts-ignore\n  await db.upsert(\"TsExport\", exports, { operationName, manualProjectRoot });\n\n  await writeResult({\n    success: true,\n    message: \"Succesfully created imports and exports\",\n    operationName,\n    manualProjectRoot,\n  });\n}"
  },
  "getDefaultSymbolType": {
    "name": "getDefaultSymbolType",
    "slug": "TsFunction",
    "id": "zovuvfjamildekofwbwjqbka",
    "description": "gets type of a symbol and if the type has a generic, without recursing.",
    "operationName": "get-imports-exports",
    "rawText": " (\n  symbol: Symbol,\n  debug?: boolean\n): TypeSpecifier => {\n  if (debug) {\n    console.log({\n      kinds: symbol\n        .getDeclarations()\n        .map((x) => ({ kind: x.getKindName(), name: x.getText() })),\n    });\n  }\n  const symbolTypeDeclarations = getSymbolTypeDeclarations(symbol);\n\n  const type = symbolTypeDeclarations.length > 0 ? \"type\" : \"value\";\n  /**\n   * checks whether the symbol contains a type declaration which has a generic parameter\n   */\n  const hasGeneric =\n    type === \"type\"\n      ? !!symbolTypeDeclarations.find(\n          // NB: type parameters gets the generics\n          (declaration) => getHasGeneric(declaration)\n        )\n      : undefined;\n\n  return { type, hasGeneric };\n}"
  },
  "getExportSpecifierNames": {
    "name": "getExportSpecifierNames",
    "slug": "TsFunction",
    "id": "snyejyimcnmmwctgbbhxanlm",
    "description": "",
    "operationName": "get-imports-exports",
    "rawText": " (symbol: Symbol) => {\n  return (\n    symbol\n      ?.getDeclarations()\n      ?.filter((x) => x.isKind(SyntaxKind.ExportSpecifier))\n      .map((x) => x.asKind(SyntaxKind.ExportSpecifier))\n      .filter(notEmpty)\n      .map((x) => x.getName()) || []\n  );\n}"
  },
  "getExportSymbolTypeRecursive": {
    "name": "getExportSymbolTypeRecursive",
    "slug": "TsFunction",
    "id": "jqzjrxlspnrprxghvdfmzjzx",
    "description": "gets type of exportSymbols. recurses if it's an exportsymbol\n\nTODO: NB: exports that come from a destructured initialiser aren't found! fix it",
    "operationName": "get-imports-exports",
    "rawText": " (\n  symbol: Symbol,\n  sourceFile: SourceFile,\n  debug?: boolean\n): TypeSpecifier | undefined => {\n  const exportSpecifierNames = getExportSpecifierNames(symbol);\n\n  if (debug) console.log(exportSpecifierNames);\n\n  if (exportSpecifierNames.length > 0) {\n    // get the ImportSpecifier of this ExportSpecifier, and if one exists, recurse this function on it.\n\n    const importSpecifiers = getImportSpecifiersWithNames(\n      sourceFile,\n      exportSpecifierNames\n    );\n\n    if (importSpecifiers.length > 1) {\n      // NB: warn if there is more than one as that would be strange\n\n      log(\n        `More than one importsSpecifiers with that name: ${exportSpecifierNames.join(\n          \",\"\n        )} (imports: ${importSpecifiers\n          .map((x) => x.getName())\n          .join(\",\")})... file: ${sourceFile.getFilePath()}`,\n        {\n          type: \"warning\",\n        }\n      );\n    }\n\n    if (importSpecifiers.length > 0) {\n      return getTypeFromImportSpecifierRecursive(importSpecifiers[0], debug);\n    }\n\n    /* REmoved this.... seems that this will make it never do the default one\n      else {\n        if (debug) {\n          console.log(\n            \"Weird, we couldn't find the importspecifier for exportSpecifiers\"\n          );\n        }\n        return { type: undefined };\n      }\n      */\n  }\n\n  return getDefaultSymbolType(symbol, debug);\n}"
  },
  "getImportSpecifiersWithNames": {
    "name": "getImportSpecifiersWithNames",
    "slug": "TsFunction",
    "id": "mryxvgchwgzmicufgtntibhd",
    "description": "get the ImportSpecifier(s) of with a certain name.",
    "operationName": "get-imports-exports",
    "rawText": " (\n  sourceFile: SourceFile,\n  names: string[]\n) => {\n  return sourceFile\n    .getImportDeclarations()\n    .map((x) => x.getNamedImports())\n    .flat()\n    .filter((x) => names.includes(x.getName()));\n}"
  },
  "getImportsExportsTest": {
    "name": "getImportsExportsTest",
    "slug": "TsFunction",
    "id": "zowsfvpaebbmudtptpchbtap",
    "description": "",
    "operationName": "get-imports-exports",
    "rawText": " async () => {\n  const operationBasePath = await getOperationPath(\n    \"react-with-native-notification\"\n  );\n  if (!operationBasePath) {\n    return console.log(\"wtf\");\n  }\n\n  const sourceFilePaths = await getPackageSourcePaths({\n    operationBasePath,\n  });\n  const project = getTsMorphProject(operationBasePath);\n  if (!project) {\n    return log(\"couldn't load project\", { type: \"error\" });\n  }\n\n  const sourceFiles = project.getSourceFiles(sourceFilePaths);\n  if (!sourceFiles) {\n    return log(`couldn't load files`, { type: \"error\" });\n  }\n\n  const impexp = await getImportsExports({ sourceFiles });\n\n  return impexp;\n\n  // console.dir(impexp, { depth: 999 });\n}"
  },
  "getImportsExports": {
    "name": "getImportsExports",
    "slug": "TsFunction",
    "id": "wygvcgvfolldbgpceuvuefcm",
    "description": "Uses ts-morph to get all exports inside all files in a project or an array of source files.\nDoesn't use index, it actually looks in all files except index,\nso some of them may not be exported from the package itself depending on your indexing strategy!\n\nNB: uses a lot of memory!\n\n#performance",
    "operationName": "get-imports-exports",
    "rawText": " async ({\n  sourceFiles,\n  debug,\n  manualProjectRoot,\n}: {\n  /**\n   * if given, only these sourcefiles are used, otherwise takes all source files from project.\n   */\n  sourceFiles: SourceFile[];\n  debug?: boolean;\n  manualProjectRoot?: string;\n}): Promise<ImportsAndExports | undefined> => {\n  if (sourceFiles.length === 0) {\n    log(\"No source files provided\", { type: \"warning\" });\n    return;\n  }\n\n  const allOperationsPaths = await exploreOperationFolders({\n    basePath: manualProjectRoot,\n  });\n  const allOperations = allOperationsPaths.map(getLastFolder);\n  const firstFilePath = sourceFiles[0].getFilePath();\n  if (!firstFilePath) return;\n\n  const operationBasePath = findOperationBasePath(firstFilePath);\n  if (!operationBasePath) return;\n\n  const packageJson = await readJsonFile<Operation>(\n    path.join(operationBasePath, \"package.json\")\n  );\n\n  if (!packageJson) {\n    log(\"PackageJson could not be found\", { type: \"error\" });\n    return;\n  }\n\n  const allTsExports: Creation<TsExport>[] = (\n    await mapMany(\n      sourceFiles,\n      async (sourceFile) => {\n        const absoluteFilePath = sourceFile.getFilePath();\n        if (!absoluteFilePath) return;\n\n        const operationRelativeTypescriptFilePath = makeRelative(\n          absoluteFilePath,\n          operationBasePath\n        );\n\n        const exportSymbols: Symbol[] = sourceFile.getExportSymbols();\n        const tsExports: Creation<TsExport>[] = exportSymbols.map((symbol) => {\n          const name = symbol.getName();\n          const typeSpecifier: TypeSpecifier = { type: \"value\" };\n\n          /**getExportSymbolTypeRecursive(\n            symbol,\n            sourceFile,\n            debug\n          );*/\n\n          const exportObject: Creation<TsExport> = {\n            name,\n            slug: kebabCase(name),\n            operationRelativeTypescriptFilePath,\n            // TODO:\n            comments: [],\n            type: typeSpecifier?.type,\n            hasGeneric: typeSpecifier?.hasGeneric,\n          };\n          return exportObject;\n        });\n\n        return tsExports;\n      },\n      CONCURRENTLY_INDEXED_FILES_AMOUNT\n    )\n  )\n    .filter(notEmpty)\n    .flat();\n\n  const allTsImports: Creation<TsImport>[] = (\n    await oneByOne(sourceFiles, async (sourceFile) => {\n      const absoluteFilePath = sourceFile.getFilePath();\n      if (!absoluteFilePath) return;\n      const operationRelativeTypescriptFilePath = makeRelative(\n        absoluteFilePath,\n        operationBasePath\n      );\n\n      try {\n        const importDeclarations: ImportDeclaration[] =\n          sourceFile.getImportDeclarations();\n\n        const importInfos = (\n          await oneByOne(importDeclarations, async (importDeclaration) => {\n            try {\n              const module = String(\n                importDeclaration.getModuleSpecifier().getLiteralText()\n              );\n              const importSpecifiers = importDeclaration.getNamedImports();\n\n              const namedImports: NamedImport[] = await oneByOne(\n                importSpecifiers,\n                async (x) => {\n                  const name = x.getName();\n\n                  const isOperation = allOperations.includes(module);\n\n                  const typeSpecifier = isOperation\n                    ? getTypeFromImportSpecifierRecursive(x, debug)\n                    : undefined;\n\n                  const namedImport: NamedImport = {\n                    name,\n                    slug: kebabCase(name),\n                    type: typeSpecifier?.type,\n                    hasGeneric: typeSpecifier?.hasGeneric,\n                  };\n\n                  return namedImport;\n                }\n              );\n\n              const isModuleResolved =\n                !!importDeclaration.getModuleSpecifierSourceFile();\n\n              return { namedImports, module, isModuleResolved };\n            } catch (e) {\n              console.log(\n                `catched generating import-info for import-declaration`\n              );\n            }\n          })\n        ).filter(notEmpty);\n\n        const tsImports: Creation<TsImport>[] = importInfos\n          .map((importInfo) => {\n            const { module, namedImports, isModuleResolved } = importInfo;\n\n            const nodeModules = [\"fs\", \"path\"];\n            const reactModules = [\"react\", \"react-dom\", \"react-native\", \"expo\"];\n\n            const classification: ImportClassification = nodeModules.includes(\n              module\n            )\n              ? \"node\"\n              : reactModules.includes(module)\n              ? \"react\"\n              : allOperations.includes(module)\n              ? \"operation\"\n              : !isAbsoluteImport(module)\n              ? \"internal\"\n              : \"package\";\n\n            const importObjects: Creation<TsImport>[] = namedImports.map(\n              (namedImport) => ({\n                ...namedImport,\n                module,\n                isModuleResolved,\n                // TODO\n                comments: [],\n                operationRelativeTypescriptFilePath,\n                classification,\n                isAbsolute: isAbsoluteImport(module),\n                isModuleFromMonorepo: allOperations.includes(module),\n                // NB: will not be resolved if build folder doesn't exist or if entry file doesn't exist\n              })\n            );\n\n            return importObjects;\n          })\n          .filter(notEmpty)\n          .flat();\n\n        return tsImports;\n      } catch (e) {\n        return;\n      }\n    })\n  )\n    .filter(notEmpty)\n    .flat();\n\n  return { imports: allTsImports, exports: allTsExports };\n}"
  },
  "getPackageNameFromAbsoluteImport": {
    "name": "getPackageNameFromAbsoluteImport",
    "slug": "TsFunction",
    "id": "sgezayoolfxqqujsebuinkfu",
    "description": "parses the absolute import name into the actual package name\n\n- removes internal navigation in the package (everything after the package name)\n- assumes packages don't have slashes in their names, execpt that it takes into account scoped packages (e.g. `@company/package`)\n- removes things that come before any column (`:`) e.g. `node:fs` becomes `fs`",
    "operationName": "get-imports-exports",
    "rawText": " (\n  absoluteImportName: string\n) => {\n  const slashParts = absoluteImportName.split(\"/\");\n  const beforeSlash = slashParts[0];\n\n  if (!beforeSlash || beforeSlash.length === 0) return;\n\n  // NB: scoped packages look like `@company/package` and should be parsed correctly as well\n  const withoutInternalNavigation = beforeSlash.startsWith(\"@\")\n    ? slashParts.slice(0, 2).join(\"/\")\n    : beforeSlash;\n\n  const columnParts = withoutInternalNavigation.split(\":\");\n\n  const partAfterColumns = columnParts.pop()!;\n\n  return partAfterColumns;\n}"
  },
  "getSymbolDeclarationsOfKind": {
    "name": "getSymbolDeclarationsOfKind",
    "slug": "TsFunction",
    "id": "erdwpsxjffvfajgjthmvniql",
    "description": "",
    "operationName": "get-imports-exports",
    "rawText": " <T>(symbol: Symbol, kind: SyntaxKind) => {\n  const declarations = symbol\n    .getDeclarations()\n    .filter((x) => x.getKind() === kind)\n    .map((x) => x.asKind(kind))\n    .filter(notEmpty) as unknown as T[];\n\n  return declarations;\n}"
  },
  "getSymbolTypeDeclarations": {
    "name": "getSymbolTypeDeclarations",
    "slug": "TsFunction",
    "id": "dhalcnfkrbhmnbggsmxxthjk",
    "description": "",
    "operationName": "get-imports-exports",
    "rawText": " (symbol: Symbol) => {\n  return [\n    ...getSymbolDeclarationsOfKind<TypeAliasDeclaration>(\n      symbol,\n      SyntaxKind.TypeAliasDeclaration\n    ),\n    ...getSymbolDeclarationsOfKind<InterfaceDeclaration>(\n      symbol,\n      SyntaxKind.InterfaceDeclaration\n    ),\n  ];\n}"
  },
  "getTypeFromImportSpecifierRecursive": {
    "name": "getTypeFromImportSpecifierRecursive",
    "slug": "TsFunction",
    "id": "dkxxbffjftvlpdhojvlaxtei",
    "description": "Recursive function that gets the type specifier from an import specifier",
    "operationName": "get-imports-exports",
    "rawText": " (\n  importSpecifier: ImportSpecifier,\n  debug?: boolean,\n  /**\n   * Files it was already in (to prevent infinite loops)\n   */\n  fileStack?: string[]\n): TypeSpecifier | undefined => {\n  // NB: find the file where the import is defined\n\n  try {\n    const fileOfExport = importSpecifier\n      .getImportDeclaration()\n      .getModuleSpecifierSourceFile();\n\n    // NB: without the module source we can't know the type of this importspecifier\n    if (!fileOfExport) return;\n    const filePath = fileOfExport.getFilePath();\n    if (!filePath) return;\n\n    const realFileStack = fileStack || [];\n\n    if (realFileStack.includes(filePath)) {\n      console.log(\"Infinite loop found, returning...\", { filePath, fileStack });\n      return;\n    }\n\n    const newFileStack = realFileStack.concat(filePath);\n\n    // NB: in the source, find all exported stuff\n    const exportSymbols: Symbol[] = fileOfExport.getExportSymbols();\n\n    // NB: find the export with the same name as the import\n    const importedSymbol = exportSymbols.find(\n      (x) => x.getName() === importSpecifier.getName()\n    );\n\n    // NB: if the source doesn't contain any export with that name, we can't know its type\n    if (!importedSymbol) return;\n\n    /**\n     * NB: all ExportSpecifiers don't have a more specific SyntaxKind because they are imported.\n     * If there are any ExportSpecifiers with a matching ImportSpecifier, recurse on that!\n     */\n    const exportSpecifierNames = getExportSpecifierNames(importedSymbol);\n\n    if (exportSpecifierNames.length > 0) {\n      const importSpecifiers = getImportSpecifiersWithNames(\n        fileOfExport,\n        exportSpecifierNames\n      );\n\n      if (importSpecifiers.length > 1) {\n        // NB: warn if there is more than one as that would be strange\n\n        log(\"More than one importsSpecifiers with that name\", {\n          type: \"warning\",\n        });\n      }\n\n      if (importSpecifiers.length > 0 && newFileStack.length < 10) {\n        // console.log(`recursing`, { newFileStack, filePath });\n\n        // NB: recursion!\n        const first = importSpecifiers[0];\n        return getTypeFromImportSpecifierRecursive(first, debug, newFileStack);\n      } else {\n        if (debug)\n          console.log(\"Weird, no importspecifiers found for exportSpecifier!!\");\n        return;\n      }\n    }\n\n    // console.log({\n    //   fileOfExport: fileOfExport?.getFilePath(),\n    //   exportSymbols: exportSymbols?.map((x) => x.getName()),\n    //   importSpecifier: importSpecifier.getName(),\n    //   importedSymbol: importedSymbol?.getName(),\n    //   name: importSpecifier.getName(),\n    // });\n\n    return getDefaultSymbolType(importedSymbol, debug);\n  } catch (e) {\n    console.log(\"failed\");\n    return;\n  }\n}"
  },
  "isAbsoluteImportBuiltin": {
    "name": "isAbsoluteImportBuiltin",
    "slug": "TsFunction",
    "id": "arsfdwpybivltneiobaxawsu",
    "description": "returns true if the absolute import is built in into node",
    "operationName": "get-imports-exports",
    "rawText": " (absoluteImportName: string) => {\n  const realModuleName = getPackageNameFromAbsoluteImport(absoluteImportName);\n  return realModuleName ? builtinModules.includes(realModuleName) : false;\n}"
  },
  "isImportFromOptionalFile": {
    "name": "isImportFromOptionalFile",
    "slug": "TsFunction",
    "id": "abdfudmwehecfvzwjuffzmbr",
    "description": "returns true if the import was found in an optional file, e.g. this import is not always included in the bundle, so should not be a dependency",
    "operationName": "get-imports-exports",
    "rawText": " (tsImport: Creation<TsImport>) => {\n  const srcRelativeFileId = getSrcRelativeFileId(\n    tsImport.operationRelativeTypescriptFilePath\n  );\n  return hasSubExtension(srcRelativeFileId, frontendOptionalFileSubExtensions);\n}"
  },
  "isImportGenerated": {
    "name": "isImportGenerated",
    "slug": "TsFunction",
    "id": "usmmzhmgxvpdjytsknayivrg",
    "description": "",
    "operationName": "get-imports-exports",
    "rawText": " (x: Creation<TsImport>) =>\n  x.isModuleFromMonorepo && isGeneratedOperationName(x.module)"
  },
  "[operationBasePath, manualProjectRoot]": {
    "name": "[operationBasePath, manualProjectRoot]",
    "slug": "TsVariable",
    "id": "izlrdlwwgjrtlupffbvfpdhd",
    "description": "",
    "operationName": "get-imports-exports"
  },
  "writeResult": {
    "name": "writeResult",
    "slug": "TsFunction",
    "id": "rdxtzauuidvpbyrvypfdvtkq",
    "description": "",
    "operationName": "get-imports-exports",
    "rawText": " async (options: {\n  operationName: string;\n  success: boolean;\n  message: string;\n  manualProjectRoot?: string;\n}) => {\n  const { message, operationName, success, manualProjectRoot } = options;\n\n  if (!success) {\n    log(`Couldn't write imports/exports.`);\n\n    await db.update(\n      \"Operation\",\n      () => true,\n      (old) =>\n        mergeNestedObject(old, {\n          operation: {\n            buildResultIndexed: { indexImportExportError: message },\n          },\n        }),\n      { operationName, manualProjectRoot }\n    );\n\n    return false;\n  }\n}"
  },
  "getMissingDependencies": {
    "name": "getMissingDependencies",
    "slug": "TsFunction",
    "id": "quazeutnasswunechrjhmrwe",
    "description": "DEPRECATED: uses old package for getting import dependencies",
    "operationName": "get-missing-dependencies",
    "rawText": " async ({\n  packageJsonPath,\n}: {\n  packageJsonPath: string;\n}) => {\n  const operationFolderPath = findOperationBasePath(packageJsonPath);\n  if (!operationFolderPath) return;\n  const importedDependencies = getImportedDependencies({ operationFolderPath });\n  const packageJSON = await getPackageJson({ operationFolderPath });\n  if (!packageJSON) return [];\n\n  const installedDependencies = packageJSON.dependencies\n    ? Object.keys(packageJSON.dependencies)\n    : [];\n\n  const missingDependencies = importedDependencies?.filter(\n    (dep) => !installedDependencies.includes(dep)\n  );\n\n  return missingDependencies;\n}"
  },
  "ajvMap": {
    "name": "ajvMap",
    "slug": "TsVariable",
    "id": "bcufqgfkzvirvzkjwoioqnwm",
    "description": "",
    "operationName": "index-typescript"
  },
  "cli": {
    "name": "cli",
    "slug": "TsFunction",
    "id": "pruaknfvnbiphnmpvufqtgem",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " async () => {\n  const [filePath] = process.argv.slice(2);\n\n  const operationBasePath = findOperationBasePath(filePath);\n  if (!operationBasePath) {\n    console.log(\"Please provide a filePath that is part of an operation\");\n    return;\n  }\n  const operationName = getLastFolder(operationBasePath);\n\n  // NB: last argument has been removed, which should be the manualProjectRoot\n  await findAndUpsertTsInterfaces({ filePath, operationName });\n}"
  },
  "definitions": {
    "name": "definitions",
    "slug": "TsVariable",
    "id": "wngakhtohelkyvdzetggftol",
    "description": "",
    "operationName": "index-typescript"
  },
  "findAndUpsertTsInterfaces": {
    "name": "findAndUpsertTsInterfaces",
    "slug": "TsFunction",
    "id": "ejxhiqihdpxgzppzctsdidar",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " async (config: {\n  /**\n   * If not provided, will load the project at the operation base path of the filepath, and get the source file at the filePath\n   */\n  sourceFile?: SourceFile;\n  operationName: string;\n  /**\n   * path of the file to find TsInterfaces in\n   */\n  filePath: string;\n  projectRoot?: string;\n}): Promise<undefined | Creation<TsInterface>[]> => {\n  const { filePath, operationName, projectRoot } = config;\n  let { sourceFile } = config;\n\n  const operationBasePath = findOperationBasePath(filePath);\n  if (!operationBasePath) return;\n\n  if (!sourceFile) {\n    const project = getTsMorphProject(operationBasePath);\n    if (!project) return;\n    sourceFile = project.getSourceFile(filePath);\n  }\n\n  if (!sourceFile) {\n    console.log(\"Filepath not existing\");\n    return;\n  }\n\n  // NB: we need to get the named absolute import names because there may be type interfaces in there that we should add into our database!\n  const namedAbsoluteImportNames = sourceFile\n    .getImportDeclarations()\n    .map((importDeclaration) => {\n      const module = String(\n        importDeclaration.getModuleSpecifier().getLiteralText()\n      );\n      if (isAbsoluteImport(module)) {\n        const namedImports: string[] = importDeclaration\n          .getNamedImports()\n          .map((x) => x.getName());\n\n        return namedImports;\n      }\n    })\n    .filter(notEmpty)\n    .flat();\n\n  const morphInterfaceInfo: MorphInterfaceInfo[] = sourceFile\n    .getInterfaces()\n    .map((x) => ({\n      hasGeneric: getHasGeneric(x),\n      raw: x.getFullText(),\n      name: x.getName(),\n      isExported: x.isExported(),\n      description: x\n        .getLeadingCommentRanges()\n        .map((x) => x.getText())\n        .join(\"\\n\\n\"),\n      extensions: x.getExtends().map((x) => x.getText()),\n    }));\n\n  const morphTypeInfo: MorphInterfaceInfo[] = sourceFile\n    .getTypeAliases()\n    .map((x) => {\n      const isExported = x.isExported();\n      const name = x.getName();\n      return {\n        hasGeneric: getHasGeneric(x),\n        raw: x.getFullText(),\n        isExported,\n        description: x\n          .getLeadingCommentRanges()\n          .map((x) => x.getText())\n          .join(\"\\n\\n\"),\n        name,\n        extensions: [],\n      };\n    });\n\n  const morphTypesAndInterfacesInfo = morphTypeInfo.concat(morphInterfaceInfo);\n\n  const tsInterfaces = await generateSchema(\n    filePath,\n    morphTypesAndInterfacesInfo,\n    namedAbsoluteImportNames\n  );\n\n  const operationRelativeTypescriptFilePath = getOperationRelativePath(\n    filePath,\n    operationBasePath\n  );\n  // console.log({\n  //   morphTypeNames: morphTypesAndInterfacesInfo.map((x) => x.name),\n  //   namedAbsoluteImportNames,\n  //   tsInterfacesLength: tsInterfaces.length,\n  // });\n\n  // @ts-ignore\n  await db.remove(\n    \"TsInterface\",\n    (i) =>\n      i.operationRelativeTypescriptFilePath ===\n        operationRelativeTypescriptFilePath &&\n      !tsInterfaces.map((x) => x.name).includes(i.name),\n    { operationName, manualProjectRoot: projectRoot }\n  );\n  // @ts-ignore\n  const result = await db.upsert(\"TsInterface\", tsInterfaces, {\n    operationName,\n    removeUntouched: true,\n    manualProjectRoot: projectRoot,\n  });\n\n  // log(`Done`, { type: \"debug\" }, result);\n  return tsInterfaces;\n}"
  },
  "findCommentTypes": {
    "name": "findCommentTypes",
    "slug": "TsFunction",
    "id": "meacandkqntphksltswgibmm",
    "description": "returns all types that are found as start of a line in the comment (capitalised, with a \":\" behind)",
    "operationName": "index-typescript",
    "rawText": " (\n  commentWithoutFrontmatter: string\n): CommentType[] => {\n  const lines = commentWithoutFrontmatter.split(\"\\n\");\n\n  const types = commentTypes.filter((type) =>\n    lines.find((line) => line.trimStart().startsWith(`${type.toUpperCase()}:`))\n  );\n\n  return types;\n}"
  },
  "generateSchema": {
    "name": "generateSchema",
    "slug": "TsFunction",
    "id": "ztfjtjjvgcjdkvzexynxjmxa",
    "description": "If existing schema is not stale, just require it.\nOtherwise, generate it for a file\n\nNB: The `createGenerator` function finds also imported TsInterfaces, which leads to duplicate TsInterfaces. With pushing the interfaces to the slug filename, this is no problem though, there should not be any duplication!",
    "operationName": "index-typescript",
    "rawText": " async (\n  filePath: string,\n  morphInterfaceInfo: MorphInterfaceInfo[],\n  namedAbsoluteImportNames: string[]\n): Promise<Creation<TsInterface>[]> => {\n  // console.log({ filePath, namedAbsoluteImportNames });\n  const problems: string[] = [];\n\n  const operationBasePath = findOperationBasePath(filePath);\n  if (!operationBasePath) {\n    log(\"No operation base path\");\n    return [];\n  }\n  const operationRelativePath = makeRelative(filePath, operationBasePath);\n  const operationFolderName = getLastFolder(operationBasePath);\n  if (operationRelativePath === \"src/index.ts\") {\n    // should not index index\n    log(\"This should never happen, operationRelativePath is src/index\");\n    return [];\n  }\n\n  const tsConfigPath = path.join(operationBasePath, \"tsconfig.json\");\n  const tsConfigExists = fs.existsSync(tsConfigPath);\n\n  if (!tsConfigExists) {\n    const problem = `no tsconfig found for ${filePath}, not generating schemas`;\n    log(problem, {\n      type: \"error\",\n    });\n    problems.push(problem);\n\n    await db.update(\n      \"Operation\",\n      (item) => item.name === operationFolderName,\n      (old) =>\n        mergeNestedObject(old, {\n          operation: { buildResultIndexed: { indexInteracesErrors: problems } },\n        }),\n      { operationName: operationFolderName }\n    );\n\n    return [];\n  }\n\n  // TODO: check the defaults and possibilities in the docs/readme\n  const config: Config = {\n    // skipTypeCheck: true,\n    path: filePath,\n    tsconfig: tsConfigPath,\n    skipTypeCheck: true,\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n  };\n  const { schema, error } = tryCreateSchema(config);\n\n  if (!schema || !schema.definitions) {\n    const problem = `No schema/definitions found for ${filePath}. Error: ${error}`;\n    log(problem, { type: \"warning\" });\n\n    await db.update(\n      \"Operation\",\n      (item) => item.name === operationFolderName,\n      (old) =>\n        mergeNestedObject(old, {\n          operation: {\n            buildResultIndexed: { indexInteracesErrors: [problem] },\n          },\n        }),\n      { operationName: operationFolderName }\n    );\n\n    return [];\n  }\n\n  const interfacePromises = Object.keys(schema.definitions).map((typeName) => {\n    const thisMorphInterfaceInfo = morphInterfaceInfo.find(\n      (x) => x.name === typeName\n    );\n\n    const tsMorphFoundTypeAlso = !!thisMorphInterfaceInfo;\n    const isImportedType = namedAbsoluteImportNames.includes(typeName);\n    const isNamedParameters = typeName.startsWith(\"NamedParameters\");\n    if (tsMorphFoundTypeAlso || isImportedType || isNamedParameters) {\n      return schemaToTsInterface(\n        filePath,\n        typeName,\n        schema,\n        thisMorphInterfaceInfo\n      );\n    }\n\n    // console.log({ definitionNames: Object.keys(schema.definitions) });\n\n    log(\n      `Skipping type ${typeName}`,\n      { type: \"debug\" },\n      { tsMorphFoundTypeAlso, isImportedType, isNamedParameters }\n    );\n\n    // NB: only the interfaces declared in this file end up in the database! otherwise you'll get duplicates anyway.\n\n    // NB: we are still allowing absolute imported types to end up in the database. They will not be exported from our index, but we still need them for some frontend-generation tasks.\n    return;\n  });\n\n  const interfaces = (await Promise.all(interfacePromises)).filter(notEmpty);\n\n  return interfaces;\n}"
  },
  "getAllComments": {
    "name": "getAllComments",
    "slug": "TsFunction",
    "id": "ytgggwckpxmtllnbeziltbnd",
    "description": "gets all leading comments and trailing comments raw text, put together, separated with newlines",
    "operationName": "index-typescript",
    "rawText": " (\n  tsMorphNode: VariableDeclaration | Statement | Expression,\n  fileContent: string,\n  operationRelativeTypescriptFilePath: string\n): Creation<TsComment>[] => {\n  const statementName = tsMorphNode\n    .asKind(SyntaxKind.VariableDeclaration)\n    ?.getName();\n  const rawStatement = tsMorphNode.getText();\n  const leadingComments = tsMorphNode\n    .getLeadingCommentRanges()\n    .map((commentRange) =>\n      makeTsComment({\n        operationRelativeTypescriptFilePath,\n        commentRange,\n        rawStatement,\n        statementName,\n        fileContent,\n      })\n    );\n  const trailingComments = tsMorphNode\n    .getTrailingCommentRanges()\n    .map((commentRange) =>\n      makeTsComment({\n        operationRelativeTypescriptFilePath,\n        commentRange,\n        rawStatement,\n        statementName,\n        fileContent,\n      })\n    );\n\n  const all = leadingComments.concat(trailingComments);\n  return all;\n}"
  },
  "getDbStorageMethod": {
    "name": "getDbStorageMethod",
    "slug": "TsFunction",
    "id": "wlffyfamvinulqjgsefvmarr",
    "description": "Gets db storage method for indexation\n\n1) Frontmatter overrules everything\n2) Special extensions are looked at",
    "operationName": "index-typescript",
    "rawText": " (config: {\n  typeName: string;\n  frontmatter: Frontmatter;\n  extensions?: string[];\n}): DbStorageMethod | undefined => {\n  const { typeName, frontmatter, extensions } = config;\n  const frontmatterResult = getFrontmatterDbStorageMethod(frontmatter);\n\n  // NB: can also become null if isDbModel is specifically set to false!\n  if (frontmatterResult !== undefined) return frontmatterResult || undefined;\n\n  const specialExtensionStorageMethod =\n    getSpecialExtensionDbStorageMethod(extensions);\n\n  if (specialExtensionStorageMethod) {\n    return specialExtensionStorageMethod;\n  }\n\n  const typeWords = lowerCaseArray(typeName);\n  const isModelTypeName =\n    typeWords.length >= 2 && [\"model\", \"db\"].includes(typeWords.pop()!);\n\n  const dbStorageMethodFromModelTypeName = isModelTypeName\n    ? \"jsonMultiple\"\n    : null;\n\n  if (dbStorageMethodFromModelTypeName) {\n    return dbStorageMethodFromModelTypeName;\n  }\n\n  return;\n}"
  },
  "getFrontmatterDbStorageMethod": {
    "name": "getFrontmatterDbStorageMethod",
    "slug": "TsFunction",
    "id": "nkeizzfkybbnbzagnmgdmmnf",
    "description": "if isDbModel is specifically set to false, this will return null (which means this should overwrite other things)",
    "operationName": "index-typescript",
    "rawText": " (\n  parameters: null | Frontmatter\n): DbStorageMethod | null | undefined => {\n  if (!parameters) return;\n\n  const dbStorageMethod =\n    parameters.dbStorageMethod &&\n    typeof parameters.dbStorageMethod === \"string\" &&\n    dbStorageMethods.includes(parameters.dbStorageMethod)\n      ? (parameters.dbStorageMethod as DbStorageMethod)\n      : undefined;\n\n  if (dbStorageMethod) return dbStorageMethod;\n\n  const isDbModel = parameters.isDbModel;\n\n  if (isDbModel === \"true\") return \"jsonMultiple\";\n\n  if (isDbModel === \"false\") return null;\n}"
  },
  "getFrontmatterFunctionParameters": {
    "name": "getFrontmatterFunctionParameters",
    "slug": "TsFunction",
    "id": "yypblzjrjvcrlxvmzebflirh",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " (frontmatter: Frontmatter) => {\n  const isApiExposed = frontmatter.isApiExposed === \"true\";\n\n  const runEveryPeriod = runEveryPeriodStringArray.includes(\n    String(frontmatter.runEveryPeriod)\n  )\n    ? (String(frontmatter.runEveryPeriod) as RunEveryPeriodEnum)\n    : undefined;\n\n  const publicAuthorizationArray = frontmatter.publicAuthorization\n    ? String(frontmatter.publicAuthorization)\n        ?.split(\",\")\n        .map((x) => x.trim())\n    : undefined;\n\n  // const publicAuthorizationFrontmatter = publicAuthorizationArray\n  //   ?.filter((text) => authorizationLevelStringArray.includes(text))\n  //   .map((string) => string as AuthorizationLevel);\n\n  // NB: by default, users are authorized to search and read docs\n  // const publicAuthorization: AuthorizationLevel[] =\n  //   publicAuthorizationFrontmatter || [\"read\", \"search\"];\n\n  const result: {\n    runEveryPeriod: TsFunction[\"runEveryPeriod\"];\n    isApiExposed: TsFunction[\"isApiExposed\"];\n  } = { runEveryPeriod, isApiExposed };\n\n  return result;\n}"
  },
  "getIndexId": {
    "name": "getIndexId",
    "slug": "TsFunction",
    "id": "synryohartkerwouauvmphul",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " async (\n  filePath: string,\n  name: string\n): Promise<TsIndexModelType | undefined> => {\n  const operationPathParse = getOperationPathParse(filePath);\n  if (!operationPathParse) return;\n  const operationBasePath = findOperationBasePath(filePath);\n  if (!operationBasePath) return;\n\n  const { operationRelativeTypescriptFilePath, relativePathFromProjectRoot } =\n    operationPathParse;\n\n  // TODO: not sure if the projectRelativepath is correc,t that is probably needs to be a path to the db file!\n  const tsIndexModelType: TsIndexModelType = {\n    operationName: operationPathParse.operationName || null,\n    operationRelativeTypescriptFilePath,\n    // TODO: FIX\n    projectRelativePath: relativePathFromProjectRoot,\n    // operationName: \"\",\n    // operationRelativePath: \"\",\n    // projectRelativePath: \"\",\n    // operationRelativeTypescriptFilePath: \"\",\n    // srcFileId: \"\",\n\n    id: generateId(),\n    name,\n    slug: kebabCase(name),\n  };\n\n  return tsIndexModelType;\n}"
  },
  "getMaxIndentationDepth": {
    "name": "getMaxIndentationDepth",
    "slug": "TsFunction",
    "id": "ddnskqyvwmuomzhrfpbgnfhe",
    "description": "gets the maximum indentation depth of any piece of code\n\ndoes this simply by splitting up the piece of code into lines and checking the indentation of every line, finding the highest one.\n\nassumes an indentation contains 2 spaces.",
    "operationName": "index-typescript",
    "rawText": " (functionText: string) => {\n  const lines = functionText.split(\"\\n\");\n  const maxDepth = lines.reduce((max, line) => {\n    const prefixSpaces = line.length - line.trimStart().length;\n    const lineIndentationDepth = Math.floor(prefixSpaces / 2);\n    return max > lineIndentationDepth ? max : lineIndentationDepth;\n  }, 0);\n\n  return maxDepth;\n}"
  },
  "getMinMaxValidation": {
    "name": "getMinMaxValidation",
    "slug": "TsFunction",
    "id": "mxmooaeymrujuhkknmtnboyh",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " (\n  keyword: \"min\" | \"max\",\n  type: string,\n  value: number\n) => {\n  const t = type.toLowerCase() as keyof typeof ajvMap;\n  return set({}, keyword + ajvMap[t], value);\n}"
  },
  "getNumberOfLines": {
    "name": "getNumberOfLines",
    "slug": "TsFunction",
    "id": "iubmbzqdmimomdevxuhgfnam",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " (string: string) => {\n  return string.split(\"\\n\").length;\n}"
  },
  "getObjectSchema": {
    "name": "getObjectSchema",
    "slug": "TsFunction",
    "id": "ifcodjypemqzwugegbaergto",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " (\n  type: Type,\n  decorators: Decorator[],\n  schemaProps: { [key: string]: any } = {}\n) => {\n  const schema: SimpleJsonSchema = {};\n  // schema = {} handleExplicitValidation(\"object\", schema, decorators);\n  schema.type = \"object\";\n  schema.properties = {};\n  schema.required = schema.required || [];\n  const typeText = type.getText();\n  const nonNullableType = type.getNonNullableType();\n  const nonNullableTypeText = nonNullableType.getText();\n  schema.optional = nonNullableTypeText !== typeText;\n  type\n    .getNonNullableType()\n    .getProperties()\n    .forEach((prop) => {\n      const key = prop.getName();\n      const isGetter = prop.hasFlags(SymbolFlags.GetAccessor);\n      if ([\"request\", \"reply\"].includes(key) || isGetter) return;\n      const valueDeclaration = prop.getValueDeclarationOrThrow();\n      const decorators = (valueDeclaration as any).getDecorators\n        ? (valueDeclaration as any).getDecorators()\n        : [];\n\n      schema.properties[key] = {\n        ...(getParamSchema(valueDeclaration.getType(), decorators, prop) || {}),\n        ...(schemaProps[key] || {}),\n      };\n\n      if (!schema.properties[key]) {\n        console.warn(\"missing type for - \" + key);\n        schema.properties[key] = { type: \"object\" };\n      }\n      if (schema.properties[key].optional !== true) {\n        schema.required?.push(key);\n      }\n      delete schema.properties[key].optional;\n    });\n\n  if (!schema.required.length) {\n    delete schema.required;\n  }\n\n  return schema;\n}"
  },
  "getParamSchema": {
    "name": "getParamSchema",
    "slug": "TsFunction",
    "id": "swnncohrqjgpldootitogxqe",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " (\n  type: Type,\n  decorators: Decorator[] = [],\n  prop: tsSymbol | undefined = undefined\n) => {\n  const typeText = type.getText();\n  const nonNullableType = type.getNonNullableType();\n  const nonNullableTypeText = nonNullableType.getText();\n  let schema: SimpleJsonSchema = {};\n\n  schema.optional = nonNullableTypeText !== typeText;\n\n  if (nonNullableType.isArray()) {\n    schema = handleExplicitValidation(\"array\", schema, decorators);\n    schema.type = \"array\";\n    // NB: recursion!\n    schema.items =\n      getParamSchema(nonNullableType.getArrayElementTypeOrThrow(), []) || {};\n    Object.keys(schema.items).forEach(\n      (key) => delete schema.items[key].optional\n    );\n    delete schema.items.optional;\n    return schema;\n  }\n  if (nonNullableType.getText() === \"Date\") {\n    schema.type = \"string\";\n    schema.format = \"date-time\";\n    return schema;\n  }\n\n  if (isPrimitive(nonNullableType)) {\n    schema.type = typeText.replace(\" | undefined\", \"\");\n    if (schema.type === \"string\") {\n      schema[\"allOf\"] = [{ transform: [\"trim\"] }, { minLength: 1 }];\n    }\n    schema = handleExplicitValidation(\n      nonNullableType.getText(),\n      schema,\n      decorators\n    );\n    return schema;\n  }\n\n  if (nonNullableType.isClass() || nonNullableType.isInterface()) {\n    const name =\n      nonNullableType.getText().split(\").\")[1] || nonNullableType.getText();\n    const importPath = typeText.split('\").')[0].split('import(\"')[1];\n    if (importPath && importPath.includes(\"/node_modules/\")) return schema;\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const c =\n      importPath && !importPath?.includes(\"/node_modules/\")\n        ? require(importPath)[name]\n        : undefined;\n    if (importPath && !c) {\n      console.log(`not found type: ${name}`);\n      return schema;\n    }\n    // NB: we seem not to have it, see https://medium.com/jspoint/introduction-to-reflect-metadata-package-and-its-ecmascript-proposal-8798405d7d88\n    // I installed reflect-metdata and added as require on top. Hope that works!\n    const classSchema = c\n      ? // @ts-ignore\n        Reflect.getMetaData(symbols.validations, c.prototype) || {}\n      : {};\n\n    schema[\"$ref\"] = \"#/definitions/\" + name;\n    if (!definitions[name]) {\n      definitions[name] = getObjectSchema(type, decorators, classSchema);\n    }\n    return schema;\n  }\n\n  if (nonNullableType.isObject()) {\n    schema = getObjectSchema(type, decorators);\n    return schema;\n  }\n  // enum --------------------------------------\n  if (nonNullableType.isEnumLiteral() && prop) {\n    const name = prop.getName();\n    const enumMembers = prop\n      ?.getValueDeclarationOrThrow()\n      ?.getSourceFile()\n      .getEnum((e) => e.getName() === nonNullableType.getText())\n      ?.getMembers();\n\n    const enumSchema: {\n      enum?: string[];\n      \"x-enumNames\"?: (string | number | undefined)[];\n      type?:\n        | \"string\"\n        | \"number\"\n        | \"bigint\"\n        | \"boolean\"\n        | \"symbol\"\n        | \"undefined\"\n        | \"object\"\n        | \"function\";\n    } = {};\n    enumSchema.enum = enumMembers?.map((m) => m.getName());\n    enumSchema[\"x-enumNames\"] = enumMembers?.map((m) => m.getValue());\n\n    enumSchema.type = enumSchema.enum?.[0]\n      ? typeof enumSchema.enum?.[0]\n      : undefined;\n\n    definitions[name] = enumSchema;\n    schema[\"$ref\"] = \"#/definitions/\" + name;\n    return schema;\n  }\n\n  if (nonNullableType.isEnum()) {\n    const name = last(nonNullableType.getText().split(\".\"))!;\n    const enumSchema: any = {};\n    enumSchema.enum = nonNullableType\n      .getUnionTypes()\n      .map((t) => t.getLiteralValueOrThrow());\n    enumSchema[\"x-enumNames\"] = nonNullableType\n      .getUnionTypes()\n      .map((t) => last(t.getText().split(\".\")) as string);\n    enumSchema.type = typeof enumSchema.enum[0];\n    definitions[name] = enumSchema;\n    schema[\"$ref\"] = \"#/definitions/\" + name;\n    return schema;\n  }\n\n  const unionTypes = type.getUnionTypes().filter((t) => !t.isUndefined());\n  if (unionTypes.length > 1) {\n    schema.oneOf = unionTypes.map((t) =>\n      getParamSchema(t, decorators)\n    ) as SimpleJsonSchema[];\n    if (!schema.oneOf[0]) {\n      delete schema.oneOf;\n      schema.enum = unionTypes.map((t) => t.getText().slice(1, -1));\n      schema[\"x-enumNames\"] = unionTypes.map((t) => t.getText().slice(1, -1));\n      schema.type = typeof schema.enum[0];\n    }\n    return schema;\n  }\n}"
  },
  "getParametersFromInterfaces": {
    "name": "getParametersFromInterfaces",
    "slug": "TsFunction",
    "id": "lvfvjrvfopjrktoelbfqfbtu",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " (\n  functionName: string,\n  /**\n   * NB: we need ALL interfaces here across the project because there may be others that were not found in the interfaces in the file, but only in the functions.\n   */\n  interfaces: Creation<TsInterface>[]\n) => {\n  const parametersInterface = interfaces.find(\n    (x) => x.name === `NamedParameters<typeof ${functionName}>`\n  );\n\n  /*\n    NB: this is how a named parameters typeDefinition looks for a function with 2 arguments\n    {\n      \"type\": \"object\",\n      \"properties\": {\n        \"markdownString\": { \"type\": \"string\" },\n        \"level\": { \"type\": \"number\" }\n      },\n      \"required\": [\"markdownString\", \"level\"],\n      \"additionalProperties\": false\n    }\n    */\n  const properties = parametersInterface?.type.typeDefinition?.properties;\n\n  const parameters: FunctionParameter[] = properties\n    ? Object.keys(properties)\n        .map((name) => {\n          const propertySchema = getSchema(\n            parametersInterface.type.typeDefinition?.properties?.[name]\n          );\n          const required =\n            parametersInterface.type.typeDefinition?.required?.includes(name) ||\n            false;\n\n          return propertySchema\n            ? {\n                name,\n                schema: propertySchema,\n                simplifiedSchema: simplifySchema(\n                  name,\n                  propertySchema,\n                  getPossibleRefs(interfaces),\n                  []\n                ),\n                required,\n              }\n            : undefined;\n        })\n        .filter(notEmpty)\n    : [];\n\n  return parameters;\n}"
  },
  "getPossibleRefs": {
    "name": "getPossibleRefs",
    "slug": "TsFunction",
    "id": "nnwyyvrqjzvcfehhtqyovxpl",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " (\n  interfaces: Creation<TsInterface>[]\n): { name: string; schema: JSONSchema7 }[] => {\n  const possibleRefs2 = interfaces.map((tsInterface) => {\n    return tsInterface.type.typeDefinition\n      ? {\n          name: tsInterface.name,\n          schema: tsInterface.type.typeDefinition,\n        }\n      : null;\n  });\n\n  const possibleRefs = possibleRefs2.filter(notEmpty);\n\n  return possibleRefs;\n}"
  },
  "getSpecialExtensionDbStorageMethod": {
    "name": "getSpecialExtensionDbStorageMethod",
    "slug": "TsFunction",
    "id": "jnsspunrburifovpfpvkrqpi",
    "description": "returns undefined if there is not a special extension. if there is, it returns the dbStorageMethod",
    "operationName": "index-typescript",
    "rawText": " (extensions?: string[]) => {\n  if (!extensions) return;\n\n  /**\n   * put any models here that should, if they are used as extension, have a db model generated\n   */\n  const specialExtensions = {\n    TsIndexModelType: \"jsonMultiple\",\n    OperationIndexModelType: \"jsonMultiple\",\n    DefaultModelType: \"jsonMultiple\",\n    SlugModelType: \"jsonMultiple\",\n    CsvModelType: \"csv\",\n    KeyValueMarkdownModelType: \"keyValueMarkdown\",\n    CategoryModelType: \"jsonMultiple\",\n    MarkdownModelType: \"markdown\",\n  };\n\n  const specialExtensionKeys = Object.keys(specialExtensions);\n\n  const specialExtension = extensions.find((x) =>\n    specialExtensionKeys.includes(x)\n  ) as undefined | keyof typeof specialExtensions;\n\n  if (!specialExtension) return;\n\n  const dbStorageMethod = specialExtensions[\n    specialExtension\n  ] as DbStorageMethod;\n  return dbStorageMethod;\n}"
  },
  "getTsStatements": {
    "name": "getTsStatements",
    "slug": "TsFunction",
    "id": "fzsldzscxbofutsuybjjzwqi",
    "description": "Gets functions and variables from a tsmorph sourcefile",
    "operationName": "index-typescript",
    "rawText": " async (\n  sourceFile: SourceFile,\n  /**\n   * NB: we require all interfaces here across the monorepo because the ones indexed by the schema generator aren't complete.\n   */\n  tsInterfaces: Creation<TsInterface>[],\n  operationRelativeTypescriptFilePath: string,\n  fileContent: string\n) => {\n  const tsVariables: Creation<TsVariable>[] = sourceFile\n    .getVariableStatements()\n    .map((variableStatement) => {\n      const declarations = variableStatement.getDeclarations();\n      const inits = declarations\n        .map((x) => x.getInitializer())\n        .filter(notEmpty);\n\n      const name = declarations[0]?.getName();\n      const value = inits[0]?.getText();\n\n      const isExported = variableStatement.isExported();\n\n      const classification = variableStatement\n        .getDeclarationKind()\n        .toString()\n        .toLowerCase() as TsVariable[\"classification\"];\n\n      const description = variableStatement\n        .getJsDocs()\n        .map((x) => x.getText())\n        .map(stripComment)\n        .join(\"\\n\\n\");\n\n      const slug = kebabCase(name);\n\n      const type = getTypeInfo(declarations[0]?.getType());\n      const tsVariable: Creation<TsVariable> = {\n        classification,\n        comments: [],\n        isExported,\n        name,\n        slug,\n        operationRelativeTypescriptFilePath,\n        type,\n        value,\n        description,\n      };\n      return tsVariable;\n    });\n\n  const morphVars: VariableDeclarationInfo[] = sourceFile\n    .getStatements()\n    .map((x) => {\n      const variableDeclarations = x\n        .asKind(SyntaxKind.VariableStatement)\n        ?.getDeclarations();\n\n      if (!variableDeclarations || variableDeclarations.length === 0) return;\n\n      const explicitTypeName = variableDeclarations\n        .map((x) => x.getTypeNode()?.getText())\n        .filter(notEmpty)[0];\n      return {\n        explicitTypeName,\n        isExported: variableDeclarations[0].isExported(),\n        variableDeclarations,\n        // NB: if this is a VariableStatement\n        kindName: x.getKindName(),\n\n        // NB: this is how we can check if it's an arrow function (declaration Initializer Kind Names Includes Arrow Function)\n        isArrowFunction: variableDeclarations\n          .map((v) => v.getInitializer())\n          .map((x) => x?.getKindName())\n          .includes(\"ArrowFunction\"),\n\n        // NB: if it's a variable, we can get the name like this\n        names: variableDeclarations.map((x) => x.getName()),\n\n        comments: x\n          .getLeadingCommentRanges()\n          .map((x) => x.getText())\n          .map(stripComment),\n      };\n    })\n    .filter(notEmpty);\n\n  // const stringLiterals = morphVars.filter((v) => !v.isArrowFunction);\n\n  /*\n   * \n   * This was the old way of parsing tsVariables, but it was not finding the comments.\n   * \n   * \n  const tsVariables: Creation<TsVariable>[] = stringLiterals\n    .map((v) => {\n      const inits = v.variableDeclarations\n        .map((x) => x.getInitializer())\n        .filter(notEmpty);\n\n      const initComments = inits\n        .map((x) => x.getLeadingCommentRanges().map((x) => x.getText()))\n        .flat()\n        .join(\"\\n\\n\");\n      const variableDeclarationComments = v.variableDeclarations\n        .map((x) => x.getLeadingCommentRanges().map((x) => x.getText()))\n        .flat()\n        .join(\"\\n\\n\");\n\n      const name = v.names[0] || \"__NO_NAME__\";\n      const slug = kebabCase(name);\n      const value =\n        inits.map((x) => x.getText()).filter(notEmpty)[0] || \"__NO_VALUE__\";\n\n      // TODO: TEST, should return const, var or let\n      const classification = v.variableDeclarations[0]\n        .getVariableStatement()\n        ?.getDeclarationKind()\n        .toString()\n        .toLowerCase() as TsVariable[\"classification\"];\n\n      const variableDeclaration = v.variableDeclarations?.[0];\n\n      if (!variableDeclaration) {\n        return;\n      }\n\n      const variableComments = getAllComments(\n        variableDeclaration,\n        fileContent,\n        operationRelativeTypescriptFilePath\n      );\n\n      const statementComments: Creation<TsComment>[] = variableDeclaration\n        .getDescendantStatements()\n        .map((x) => {\n          const allComments = getAllComments(\n            x,\n            fileContent,\n            operationRelativeTypescriptFilePath\n          );\n          return allComments;\n        })\n        .flat();\n\n      const comments = variableComments\n        ? [...variableComments, ...statementComments]\n        : statementComments;\n\n      const isExported = v.isExported;\n\n      console.log({ comments, initComments, variableDeclarationComments });\n      const description = undefined;\n      const variable: Creation<TsVariable> = {\n        description,\n        isExported,\n        operationRelativeTypescriptFilePath,\n        comments,\n        name,\n        slug,\n        value,\n        // NB: still using typeToSchema here, is there another way?\n        type: getTypeInfo(variableDeclaration.getType()),\n        classification,\n      };\n      return variable;\n    })\n    .filter(notEmpty);\n    */\n\n  const morphFunctions = sourceFile.getFunctions();\n  const arrowFunctionVars = morphVars.filter((v) => v.isArrowFunction);\n\n  const arrowFunctions: Creation<TsFunction>[] = arrowFunctionVars\n    .map((v) => {\n      const isExported = v.isExported;\n\n      const arrowFunction = v.variableDeclarations?.map((x) =>\n        x.getInitializer()?.asKind(SyntaxKind.ArrowFunction)\n      )[0];\n\n      if (!arrowFunction) {\n        log(\"Should never get here, arrow function not found\", {\n          type: \"error\",\n        });\n        return;\n      }\n\n      const description = v.comments.join(\"\\n\\n\");\n\n      const name = v.names?.[0] || \"no name\";\n\n      const returnType = getTypeInfo(\n        arrowFunction.getReturnType().getApparentType()\n      );\n      const functionText = arrowFunction.getFullText();\n      const fullText = functionText.concat(description);\n\n      const parsedDescription = parseFrontmatterMarkdownString(description);\n      const frontmatter = parsedDescription.parameters;\n\n      const frontmatterParameters =\n        getFrontmatterFunctionParameters(frontmatter);\n\n      const fn: Creation<TsFunction> = {\n        ...frontmatterParameters,\n        isExported,\n        isApiExposed: true,\n        groupAuthorization: {},\n        explicitTypeName: v.explicitTypeName,\n\n        operationRelativeTypescriptFilePath,\n\n        // TODO:\n        commentsInside: [],\n        rawText: functionText,\n        name,\n        slug: kebabCase(name),\n        parameters: getParametersFromInterfaces(name, tsInterfaces),\n        description,\n        returnType,\n        maxIndentationDepth: getMaxIndentationDepth(functionText),\n\n        // TODO: isolate the size calculations...\n\n        // size of function including comments\n        size: getSizeSummary(fullText),\n\n        // split it up\n        //codeSize: {},\n        //commentSize:{},\n\n        // cumulativeCodeSize:{},\n        // cumulativeCommentSize:{},\n        // cumulativeSize:{},\n      };\n\n      return fn;\n    })\n    .filter(notEmpty);\n\n  const regularFunctions: Creation<TsFunction>[] = morphFunctions.map(\n    (functionDeclaration) => {\n      const returnType = getTypeInfo(\n        functionDeclaration.getReturnType().getApparentType()\n      );\n\n      const functionText = functionDeclaration.getFullText();\n\n      const description = functionDeclaration\n        .getJsDocs()\n        .map((x) => x.getFullText())\n        .join(\"\\n\\n\");\n\n      const fullText = functionText.concat(description);\n\n      const parsedDescription = parseFrontmatterMarkdownString(description);\n      const frontmatter = parsedDescription.parameters;\n      const frontmatterParameters =\n        getFrontmatterFunctionParameters(frontmatter);\n\n      const name = functionDeclaration.getName() || \"__anonymous__\";\n\n      const runEveryPeriod: RunEveryPeriodEnum | undefined = undefined;\n      const fn: Creation<TsFunction> = {\n        ...frontmatterParameters,\n\n        name,\n        runEveryPeriod,\n\n        slug: kebabCase(name),\n        isExported: functionDeclaration.isExported(),\n        operationRelativeTypescriptFilePath,\n        groupAuthorization: {},\n        // TODO:\n        commentsInside: [],\n        // function metadata\n        // function info\n        description,\n        parameters: getParametersFromInterfaces(name, tsInterfaces),\n        returnType,\n        size: getSizeSummary(fullText),\n        rawText: functionText,\n        maxIndentationDepth: getMaxIndentationDepth(functionText),\n      };\n\n      return fn;\n    }\n  );\n\n  const tsFunctions = arrowFunctions.concat(regularFunctions);\n\n  // console.log({ tsFunctions: tsFunctions.length });\n  return { tsFunctions, tsVariables };\n}"
  },
  "getTypeInfo": {
    "name": "getTypeInfo",
    "slug": "TsFunction",
    "id": "xekbweqmxxcnwnmwkixqxuqh",
    "description": "takes a ts morph type and returns all info about it\n\nif available, a schema should be provided about the type because it's hard to infer it (probably buggy)",
    "operationName": "index-typescript",
    "rawText": " (type: Type, schema?: Schema): TypeInfo => {\n  const rawType = type.getApparentType().getText();\n  const isArray = type.isArray();\n  const isEnum = type.isEnum();\n  const isEnumLiteral = type.isEnumLiteral();\n  const isPrimitive = type.isString() || type.isNumber() || type.isBoolean();\n  const isObject = type.isObject();\n\n  let typeDefinition: Schema | undefined = undefined;\n  try {\n    typeDefinition = schema || typeToSchema(type);\n  } catch (e) {\n    log(`Type to schema failed with error: ${e}`, { type: \"debug\" });\n  }\n\n  const typeInfo: TypeInfo = {\n    rawType,\n    typeDefinition,\n    // TODO:\n    typeCoverage: 0,\n    // this is easy to infer\n    isArray,\n    isEnum,\n    isObject,\n    isPrimitive,\n    isEnumLiteral,\n    simplifiedSchema: typeDefinition\n      ? simplifySchema(\"type\", typeDefinition, [], [])\n      : undefined,\n  };\n\n  return typeInfo;\n}"
  },
  "getValidatedOperationPathParse": {
    "name": "getValidatedOperationPathParse",
    "slug": "TsFunction",
    "id": "mnttyzkdswdkzqwiasoxhtqp",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " (\n  filePath: string\n): undefined | CompleteOperationPathParse => {\n  const fileParse = path.parse(filePath);\n\n  if (![\".ts\", \".tsx\"].includes(fileParse.ext)) {\n    log(`Incorrect extension ${fileParse.ext}`, { type: \"warning\" });\n    return;\n  }\n\n  // NB: filename is not only a name here but a relative path\n  if (!fs.existsSync(filePath)) {\n    log(`couldn't retreive filepath ${filePath}`, { type: \"error\" });\n    return;\n  }\n\n  const operationPathParse = getOperationPathParse(filePath);\n  if (!operationPathParse) {\n    log(\"Operation must have a pathparse to be indexed\", { type: \"error\" });\n    return;\n  }\n\n  return { ...operationPathParse, filePath };\n}"
  },
  "hasTypescriptFileChanged": {
    "name": "hasTypescriptFileChanged",
    "slug": "TsFunction",
    "id": "luayewtawyihjnojwztvjlzc",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " (\n  eventName: WatchEventType,\n  path: string\n) => {\n  // for indexation we don't care about any other event than adding or changing a file\n  if (![\"add\", \"change\"].includes(eventName)) return false;\n  // in order to index a file, it must be in an operation, which means it must be in src\n  if (!path.includes(\"/src/\")) return false;\n  // only ts and tsx files matter, the rest doesn't need to be indexed\n  if (![\"ts\", \"tsx\"].includes(getExtension(path))) return false;\n\n  return true;\n}"
  },
  "indexImportsExportsForFilePath": {
    "name": "indexImportsExportsForFilePath",
    "slug": "TsFunction",
    "id": "wtyzwwvzrahztyldqledewad",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " async (\n  eventName,\n  filePath\n) => {\n  const name = path.parse(filePath).name;\n  process.stdout.write(`Change detected: ${name}\\n`);\n  const operationBasePath = findOperationBasePath(filePath);\n  if (!operationBasePath) {\n    console.log(\"\\nCouldn't find operationBasePath\");\n    return;\n  }\n  process.stdout.write(`Indexing operation imports ...`);\n\n  await findAndWriteImportsExports(operationBasePath);\n\n  console.log(\"âœ…\\n\");\n}"
  },
  "indexTypescriptFilePath": {
    "name": "indexTypescriptFilePath",
    "slug": "TsFunction",
    "id": "axdqptdwzaaessiozwtlnrxv",
    "description": "Index a single typescript file",
    "operationName": "index-typescript",
    "rawText": " async (\n  eventName,\n  filePath\n) => {\n  const name = path.parse(filePath).name;\n  process.stdout.write(`Indexing file: ${name}`);\n\n  await indexTypescript({\n    filePaths: [filePath],\n    manualProjectRoot: null,\n    showLogging: false,\n  });\n\n  console.log(\"âœ…\\n\");\n}"
  },
  "indexTypescriptFile": {
    "name": "indexTypescriptFile",
    "slug": "TsFunction",
    "id": "zxadtlxahdirfontdefbkapn",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " async (\n  project: Project,\n  file: CompleteOperationPathParse,\n  projectRoot: string\n) => {\n  const problems: string[] = [];\n\n  const { filePath, operationName, operationRelativeTypescriptFilePath } = file;\n  if (!operationName) return;\n\n  // console.log(`indexing file`, {\n  //   operationName,\n  //   filePath,\n  //   operationRelativeTypescriptFilePath,\n  // });\n  // END VALIDATION\n\n  const fileContent = await fs.readFile(filePath, \"utf8\");\n\n  //select correct SourceFile from tsmorph project\n  const sourceFile = project.getSourceFile(filePath);\n\n  if (!sourceFile) {\n    const problem = `couldn't load file ${filePath}`;\n    problems.push(problem);\n\n    await db.update(\n      \"Operation\",\n      (item) => item.name === operationName,\n      (old) =>\n        mergeNestedObject(old, {\n          operation: { buildResultIndexed: { indexInteracesErrors: problems } },\n        }),\n      { operationName }\n    );\n\n    log(problem, { type: \"error\" });\n    return;\n  }\n\n  const newTsInterfaces = await findAndUpsertTsInterfaces({\n    filePath,\n    sourceFile,\n    operationName,\n    projectRoot,\n  });\n\n  if (!newTsInterfaces) {\n    log(\"Shouldn't happen but tsInterfaces is undefined here...\");\n    return;\n  }\n\n  const allTsInterfaces = await db.get(\"TsInterface\");\n\n  const allWithNewTsInterfaces = [\n    ...newTsInterfaces,\n    ...allTsInterfaces,\n  ].filter(onlyUnique2<Creation<TsInterface>>((a, b) => a.name === b.name));\n  // NB: interfaces are a prerequisite for function...\n\n  // console.log({\n  //   newTsInterfaces: newTsInterfaces.length,\n  //   allTsInterfaces: allTsInterfaces.length,\n  //   allWithNewTsInterfacesUnique: allWithNewTsInterfaces.length,\n  // });\n  // TODO:\n  const tsLintWarnings: TsLintWarning[] = [];\n\n  // TODO: get main comment from top of file or associated md\n  const mainComment = undefined;\n  const pathMetaData = await calculatePathMetaData(filePath);\n\n  const { tsFunctions, tsVariables } = await getTsStatements(\n    sourceFile,\n    allWithNewTsInterfaces,\n    operationRelativeTypescriptFilePath,\n    fileContent\n  );\n\n  // gets all top level statements\n  const topLevelComments: Creation<TsComment>[] = sourceFile\n    .getStatementsWithComments()\n    .map((x) => {\n      const comments = getAllComments(\n        x,\n        fileContent,\n        operationRelativeTypescriptFilePath\n      );\n      return comments;\n    })\n    .flat();\n\n  const functionComments: Creation<TsComment>[] = tsFunctions\n    .map((f) => f.commentsInside)\n    .flat();\n  const interfaceComments: Creation<TsComment>[] = newTsInterfaces\n    .map((f) => f.commentsInside)\n    .flat();\n  const variableComments: Creation<TsComment>[] = tsVariables\n    .map((f) => f.comments)\n    .flat();\n\n  // TODO: get all top level comments from the statements, but also get all comments already found in functions, variables, and interfaces, put together.\n  const tsComments: Creation<TsComment>[] = [\n    topLevelComments,\n    functionComments,\n    interfaceComments,\n    variableComments,\n  ].flat();\n\n  // Inserting all results into the database...\n\n  // @ts-ignore\n  await db.remove(\n    \"TsFunction\",\n    (fn) =>\n      fn.operationRelativeTypescriptFilePath ===\n        operationRelativeTypescriptFilePath &&\n      !tsFunctions.map((x) => x.name).includes(fn.name),\n    { operationName, manualProjectRoot: projectRoot }\n  );\n\n  // console.log({ tsFunctions: tsFunctions.length, operationName, projectRoot });\n  // @ts-ignore\n  await db.upsert(\"TsFunction\", tsFunctions, {\n    operationName,\n    manualProjectRoot: projectRoot,\n  });\n\n  await db.remove(\n    \"TsVariable\",\n    (v) =>\n      v.operationRelativeTypescriptFilePath ===\n        operationRelativeTypescriptFilePath &&\n      !tsVariables.map((x) => x.name).includes(v.name),\n    { operationName, manualProjectRoot: projectRoot }\n  );\n  await db.upsert(\"TsVariable\", tsVariables, {\n    operationName,\n    removeUntouched: true,\n    manualProjectRoot: projectRoot,\n  });\n\n  await db.remove(\n    \"TsComment\",\n    (c) =>\n      c.operationRelativeTypescriptFilePath ===\n      operationRelativeTypescriptFilePath,\n    { operationName, manualProjectRoot: projectRoot }\n  );\n  await db.upsert(\"TsComment\", tsComments, {\n    operationName,\n    removeUntouched: true,\n    manualProjectRoot: projectRoot,\n  });\n}"
  },
  "indexTypescript": {
    "name": "indexTypescript",
    "slug": "TsFunction",
    "id": "zqhgtbtpcisobubkirhxdbgv",
    "description": "Creates a typescript file index in 3 steps\n1) Introspects the file\n2) Calculates all needed information about it\n3) Saves the result to /db/******.json in the operation root\n\nNB: Build errors are done separately as this is done operation-wide, everything else is done for each file\n\nNB: I don't think this is super efficient, because the project is taken to just index a single file. It's probably better to pass the project and the sourcefile in here, right?\n\nTODO: if a typescript file starst with a comment before any statements (but possibly after the `#!/usr/bin/env xyz` statement), this should be indexed as the main file comment... This can be shown when opening the file in the admin... It should also check if there is an associated md file for that in src, so that can also be added in the index.",
    "operationName": "index-typescript",
    "rawText": " async (props: {\n  showLogging?: boolean;\n  /**\n   * filepaths of files to index. must be files from the same operation.\n   */\n  filePaths: string[];\n  manualProjectRoot: string | null;\n}): Promise<void> => {\n  const { filePaths, manualProjectRoot, showLogging } = props;\n  // NB: fix to globally alter real fs in order to fix EMFile error that happens in TSMorph (see https://github.com/isaacs/node-graceful-fs)\n  gracefulFs.gracefulify(realFs);\n\n  const firstFilePath = filePaths[0];\n  if (!firstFilePath) {\n    log(\"Please provide some file paths\");\n  }\n\n  // NB: we can assume all files are from the same operation\n  const operationBasePath = findOperationBasePath(firstFilePath);\n  if (!operationBasePath) {\n    log(\"Operation must have a basepath to be indexed\", { type: \"error\" });\n    return;\n  }\n  const projectRoot = manualProjectRoot || getProjectRoot(firstFilePath);\n  if (!projectRoot) {\n    log(\"No project root found\", { type: \"error\" });\n    return;\n  }\n  const packageJson = await readJsonFile<Operation>(\n    path.join(operationBasePath, \"package.json\")\n  );\n\n  if (!packageJson) {\n    log(\"Operation must have a package.json to be indexed\", { type: \"error\" });\n    return;\n  }\n\n  const operationName = packageJson.name;\n\n  if (!operationName) {\n    log(\"Operation must have a name to be indexed\", { type: \"error\" });\n    return;\n  }\n\n  const problems: string[] = [];\n\n  // TODO: this takes a long time. I should probably execute everything for every file after this and use the same project\n\n  //create tsmorph project for full operation\n  const project = getTsMorphProject(operationBasePath);\n\n  if (!project) {\n    const problem = \"couldn't load project\";\n    problems.push(problem);\n    await db.update(\n      \"Operation\",\n      (item) => item.name === getFolder(operationBasePath),\n      (old) =>\n        mergeNestedObject(old, {\n          operation: { buildResultIndexed: { indexErrors: problems } },\n        })\n    );\n\n    log(problem, { type: \"error\" });\n    return;\n  }\n\n  const filePathsToIndex = filePaths\n    .map(getValidatedOperationPathParse)\n    .filter(notEmpty);\n\n  // NB: one by one because if you do multiple at once, writing commets goes corrupt because concurrent writing.\n  await oneByOne(filePathsToIndex, async (file, index) => {\n    if (showLogging) {\n      process.stdout.write(`${index + 1}) ${file.srcFileId} `);\n    }\n    const result = await indexTypescriptFile(project, file, projectRoot);\n    if (showLogging) {\n      console.log(\"âœ…\");\n    }\n    return result;\n  });\n}"
  },
  "isPrimitive": {
    "name": "isPrimitive",
    "slug": "TsFunction",
    "id": "ngxsacgkrsypbvktewoasidx",
    "description": "export const getDefinitions = () => definitions;\n\nexport const getClass = (name) => allClasses[name];",
    "operationName": "index-typescript",
    "rawText": " (type: Type) =>\n  type.isBoolean() || type.isNumber() || type.isString()"
  },
  "makeTsComment": {
    "name": "makeTsComment",
    "slug": "TsFunction",
    "id": "rabailttmslqahfktpqxworu",
    "description": "this is actually a fundamental part of the OS. How should comments be structured?\n\nI think, in general, that we should make it look as much as possible at markdown, because it should always be able to have markdown anyway.",
    "operationName": "index-typescript",
    "rawText": " (config: {\n  operationRelativeTypescriptFilePath: string;\n  commentRange: CommentRange;\n  /**\n   * if we can give the statement a name, it should be provided here\n   */\n  statementName: string | undefined;\n  rawStatement: string;\n  /** needed for calculating line numbers */\n  fileContent: string;\n}): Creation<TsComment> => {\n  const {\n    commentRange,\n    rawStatement,\n    statementName,\n    fileContent,\n    operationRelativeTypescriptFilePath,\n  } = config;\n  const fullCommentText = commentRange.getText();\n  const strippedComment = stripComment(fullCommentText);\n\n  // NB: wouldn't hurt to put character positions in the TsComment as well, would it? But let's not do it until we need it\n  const firstCharacter = commentRange.getPos();\n  const lastCharacter = commentRange.getEnd();\n  const firstLine = getNumberOfLines(fileContent.substring(0, firstCharacter));\n  const lastLine = getNumberOfLines(fileContent.substring(0, lastCharacter));\n  const isSingleLineComment = firstLine === lastLine;\n\n  const { parameters, raw: comment }: MarkdownParse = isSingleLineComment\n    ? { raw: strippedComment, parameters: {} }\n    : parseFrontmatterMarkdownString(strippedComment);\n\n  const types = findCommentTypes(comment);\n\n  const tsComment: Creation<TsComment> = {\n    name: \"Comment\",\n    slug: kebabCase(\"Comment\"),\n    operationRelativeTypescriptFilePath,\n    comment,\n    statementName,\n    rawStatement,\n    parameters,\n    types,\n    firstLine,\n    lastLine,\n  };\n\n  return tsComment;\n}"
  },
  "removeTypescriptIndex": {
    "name": "removeTypescriptIndex",
    "slug": "TsFunction",
    "id": "ppzqpqmnjbimhimmyqxkgfml",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " async (\n  eventName,\n  filePath\n) => {\n  // NB: need to provide get folder because the original file is gone so it can't be detected\n  const operationPath = findOperationBasePath(getFolder(filePath));\n  if (!operationPath) {\n    return;\n  }\n\n  const operationName = getLastFolder(operationPath);\n  // console.log(`Found operationName: ${operationName}...`);\n\n  const result = await cleanupTsDatabase(operationName);\n  console.log(\n    `Cleaned up ${result?.amountRemoved || 0} indexes (removed ${\n      path.parse(filePath).base\n    })`\n  );\n}"
  },
  "schemaToTsInterface": {
    "name": "schemaToTsInterface",
    "slug": "TsFunction",
    "id": "lokvpmroizisetsgomccktmv",
    "description": "make a tsInterface from a schema generated from the file",
    "operationName": "index-typescript",
    "rawText": " async (\n  filePath: string,\n  typeName: string,\n  schema: Schema,\n  morphInterfaceInfo: MorphInterfaceInfo | undefined\n): Promise<Creation<TsInterface> | undefined> => {\n  const definitionOrBoolean = schema.definitions?.[typeName];\n\n  const operationBasePath = findOperationBasePath(filePath);\n  if (!operationBasePath) return;\n\n  const possibleRefs = schema.definitions\n    ? Object.keys(schema.definitions)\n        .map((typeName) => {\n          const theSchema = getSchema(schema.definitions?.[typeName]);\n          return theSchema ? { name: typeName, schema: theSchema } : null;\n        })\n        .filter(notEmpty)\n    : [];\n  const definition: Schema | undefined =\n    typeof definitionOrBoolean === \"object\" ? definitionOrBoolean : undefined;\n\n  if (!definition) return undefined;\n\n  const parsedDescription = parseFrontmatterMarkdownString(\n    stripComment(\n      morphInterfaceInfo?.description || definition.description || \"\"\n    )\n  );\n\n  const frontmatter = parsedDescription.parameters;\n\n  const { operationRelativePath } = frontmatter;\n\n  const isOperationIndex: boolean =\n    frontmatter.isOperationIndex === undefined\n      ? morphInterfaceInfo?.extensions.includes(\"TsIndexModelType\") || false\n      : Boolean(frontmatter.isOperationIndex);\n\n  const dbStorageMethod = getDbStorageMethod({\n    typeName,\n    frontmatter,\n    extensions: morphInterfaceInfo?.extensions,\n  });\n\n  const isDbModel = !!dbStorageMethod;\n\n  const slug = slugify(typeName);\n\n  const operationRelativeTypescriptFilePath = getOperationRelativePath(\n    filePath,\n    operationBasePath\n  );\n\n  const hasGeneric = !!morphInterfaceInfo?.hasGeneric;\n  const isExported = !!morphInterfaceInfo?.isExported;\n\n  const simplifiedSchema = simplifySchema(\n    typeName,\n    definition,\n    possibleRefs,\n    []\n  );\n\n  const interfaceObject: Creation<TsInterface> = {\n    // identifiers\n    id: slug,\n    name: typeName,\n    slug,\n\n    operationRelativeTypescriptFilePath,\n\n    hasGeneric,\n    isExported,\n\n    rawText: morphInterfaceInfo?.raw,\n    extensions: morphInterfaceInfo?.extensions,\n    isOperationIndex,\n    operationStorageLocationRelativeFilePath: operationRelativePath\n      ? String(operationRelativePath)\n      : undefined,\n    // interface info\n    description: parsedDescription?.raw,\n    dbStorageMethod,\n    isDbModel,\n    // TODO:\n    commentsInside: [],\n    type: {\n      // TODO: test\n      typeDefinition: definition,\n      simplifiedSchema,\n      // TODO:\n      typeCoverage: 0,\n      rawType: typeName,\n      // TODO:\n      isArray: false,\n      isEnum: false,\n      isEnumLiteral: false,\n      isObject: false,\n      isPrimitive: false,\n    },\n  };\n\n  return interfaceObject;\n}"
  },
  "symbols": {
    "name": "symbols",
    "slug": "TsVariable",
    "id": "luubjaxghtuidkgabqesaiev",
    "description": "",
    "operationName": "index-typescript"
  },
  "toSnack": {
    "name": "toSnack",
    "slug": "TsFunction",
    "id": "uurosuhjtsrfpcjhsqxxkffc",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " (key: string) =>\n  key.replace(/([A-Z])/g, ($1) => \"-\" + $1.toLowerCase()).replace(/^-/, \"\")"
  },
  "tryCreateSchema": {
    "name": "tryCreateSchema",
    "slug": "TsFunction",
    "id": "qipkxrmegshiotakqrkunpxv",
    "description": "Try because sometimes generateSchema fails",
    "operationName": "index-typescript",
    "rawText": " (\n  config: Config\n): { schema?: Schema; error?: string } => {\n  try {\n    const generator = createGenerator(config);\n    const schema: Schema = generator.createSchema(config.type);\n    return { schema };\n  } catch (e) {\n    return { error: String(e) };\n  }\n}"
  },
  "typeToSchema": {
    "name": "typeToSchema",
    "slug": "TsFunction",
    "id": "kmvcnotowlswppavlvixebcw",
    "description": "calculates the schema of a type\n\nthis is great for types inside of parameters of variables that are not declared separately, however, it's probably not as good as vega's json schema generator... therefore, it would be great to always prefer vega's way above this.\n\nNB: this method throws sometimes if it can't find some stuff, so make sure to try/catch it.\n\nTODO: Test and improve this one",
    "operationName": "index-typescript",
    "rawText": " (type: Type) => getParamSchema(type)"
  },
  "preIndexLint": {
    "name": "preIndexLint",
    "slug": "TsFunction",
    "id": "qtmeennvmnbapyxzpapdutlz",
    "description": "Should be a collection of small functions that check if all conventions are used and if there isn't used anything that should NOT be used. this can later become a linter. make sure to research how eslint works first\n\nPlan:\n\n1) just use my own sdk's as much as possible to provide some handy convention checks in a package\n2) later integrate this into vscode, i'm sure this is how it's done\n\nthis lint can be done before indexation",
    "operationName": "lint",
    "rawText": " async ({\n  operationFolderPath,\n}: {\n  operationFolderPath: string;\n}) => {\n  const problems: string[] = [];\n\n  const packageJson = await getPackageJson({ operationFolderPath });\n  if (!packageJson) {\n    problems.push(\"package.json should exist\");\n  } else {\n    if (!packageJson.name) {\n      problems.push(\"package.json needs a name\");\n    }\n    if (!packageJson.version) {\n      problems.push(\"package.json needs a version\");\n    }\n  }\n\n  const tsConfig = await getTsConfig(operationFolderPath);\n  if (!tsConfig) {\n    problems.push(\"tsconfig.json should exist\");\n  } else {\n    // we can lint tsconfig here too\n  }\n\n  const operationFolderName = getLastFolder(operationFolderPath);\n\n  if (operationFolderName !== packageJson?.name) {\n    problems.push(\n      \"operation folder should have the same name as the package.json name\"\n    );\n  }\n\n  return problems;\n}"
  },
  "minifyBuild": {
    "name": "minifyBuild",
    "slug": "TsFunction",
    "id": "kywyrnkixhelmfvjfprahnot",
    "description": "takes an operation name or build folder path, then explores all ts files in src folder, finds the matching js file in the build folder, and executes terser from dependency, not from cli",
    "operationName": "minify-build",
    "rawText": " async ({\n  operationName,\n  buildFolderPath,\n}: {\n  operationName?: string;\n  buildFolderPath?: string;\n}) => {\n  if (operationName) {\n    const operationFolderPath = await getOperationPath(operationName);\n\n    if (!operationFolderPath) {\n      log(`Can't find that operation`, { type: \"error\" });\n      return;\n    }\n\n    buildFolderPath = path.join(operationFolderPath, \"build\");\n  }\n\n  if (!buildFolderPath) {\n    log(\n      `minifyBuild: Please provide an existing operationName or a buildFolderPath`,\n      { type: \"error\" }\n    );\n    return;\n  }\n\n  const srcFolderPath = path.join(buildFolderPath, \"..\", \"src\");\n\n  if (!fs.existsSync(srcFolderPath)) {\n    log(`minifyBuild: ${srcFolderPath} not found, we can't minify`, {\n      type: \"error\",\n    });\n    return;\n  }\n\n  if (!fs.existsSync(buildFolderPath)) {\n    log(`minifyBuild: ${buildFolderPath} does not exist`, { type: \"error\" });\n    return;\n  }\n\n  const tsFilesExploreResult = await explore({\n    basePath: srcFolderPath,\n    extension: [\"ts\", \"tsx\"],\n  });\n  /**\n   * relative file paths from src, withtout extension\n   */\n  const absoluteJsPaths = tsFilesExploreResult\n    .map((x) => {\n      // get relative file path without extension\n      const parsedPath = path.parse(x.path);\n      const pathWithoutExtension = path.join(parsedPath.dir, parsedPath.name);\n\n      const relativeFileId = makeRelative(pathWithoutExtension, srcFolderPath);\n\n      return relativeFileId;\n    })\n\n    .map((relativeFilePath) => {\n      // use that to get js file in the build folder\n\n      const jsFilePath = path.join(\n        // NB: it's strange that it thinks that buildFolderPath can still be undefined here.\n        buildFolderPath!,\n        relativeFilePath.concat(\".js\")\n      );\n\n      return jsFilePath;\n    });\n\n  try {\n    await Promise.all(\n      absoluteJsPaths.map(async (jsFilePath) => {\n        const fileName = path.parse(jsFilePath).base;\n        const fileContent = await fs.readFile(jsFilePath, { encoding: \"utf8\" });\n        if (!fileContent || fileContent.length === 0) {\n          log(`Empty file found at ${jsFilePath}`, { type: \"error\" });\n          return;\n        }\n\n        // console.log(`minifying ${jsFilePath}`);\n\n        try {\n          const output = await minify(fileContent, {\n            mangle: true,\n            compress: true,\n            format: { comments: \"all\" },\n          });\n\n          // console.log({ output });\n\n          if (!output.code) {\n            log(`No code generated for ${jsFilePath}`, { type: \"error\" });\n            return;\n          } else {\n            await fs.writeFile(jsFilePath, output.code, {\n              encoding: \"utf8\",\n            });\n          }\n\n          // log(\"Written dist file\", { type: \"success\" });\n          return true;\n        } catch (e) {\n          console.log(`minify failed: catched: `, e);\n          return false;\n        }\n      })\n    );\n\n    return true;\n  } catch (e) {\n    log(`something went wrong with minification: ${e}`, { type: \"error\" });\n  }\n\n  return;\n}"
  },
  "getAvailableOperationName": {
    "name": "getAvailableOperationName",
    "slug": "TsFunction",
    "id": "jmwskvakbifpdtpkbwsafgcx",
    "description": "returns folder name\n\nfinds the first foldername that is available in this folder but also there is nowhere an operation already with this name\n\nthere is also getAvailableFolderPath for non-operation folders",
    "operationName": "new-template",
    "rawText": " async (\n  rootFolderPath: string,\n  preferredFolderName: string,\n  manualProjectRoot?: string\n): Promise<string> => {\n  //making sure we make a folder that doesn't exist yet:\n  let n = 0;\n  let availableFolderName = preferredFolderName;\n\n  while (true) {\n    const folderAlreadyExists = fs.existsSync(\n      path.join(rootFolderPath, availableFolderName)\n    );\n\n    const operationAlreadyExists =\n      (await getOperationPath(availableFolderName, {\n        manualProjectRoot,\n        notUseSdk: !!manualProjectRoot,\n      })) !== undefined;\n\n    if (!folderAlreadyExists && !operationAlreadyExists) break;\n\n    n++;\n    availableFolderName = `${preferredFolderName}${n}`;\n  }\n\n  return availableFolderName;\n}"
  },
  "newOperationCli": {
    "name": "newOperationCli",
    "slug": "TsFunction",
    "id": "khzjggvtsnywtohayuynzmwb",
    "description": "newOperation also works as CLI\n\nexample: `newOperation [operation-name] [type]` in the folder where you want to create it. Optionally you can specify the type of operation as the second argument of the CLI\n\nArguments (all optional):\n- name: string\n- type: `OperationClassification`\n- description: string\n- destinationPath: string",
    "operationName": "new-template",
    "rawText": " async () => {\n  const [name, type, description, destinationPath] = process.argv.slice(2);\n\n  log(`Let's make a ${type || \"node-cjs\"} operation called ${name}`, {\n    type: \"important\",\n  });\n  console.log(\"All types possible:\", operationClassificationConst.join(\", \"));\n\n  await newOperation(name, {\n    type: type as OperationClassification,\n    description,\n    destinationPath,\n  });\n\n  console.log(`Generated operation`, {\n    name,\n    type,\n    description,\n    destinationPath,\n  });\n}"
  },
  "newOperationWithFiles": {
    "name": "newOperationWithFiles",
    "slug": "TsFunction",
    "id": "eavljdtftapztikulyvalybm",
    "description": "Creates a new operation with files with content\n\nReturns the final operation base path (or undefined if something went wrong)\n\nNB: relative paths must be relative to OPERATION ROOT, not src root! They must also lead to files in src, this thing is still buggy otherwise!\n\nTODO: Remove the buggyness",
    "operationName": "new-template",
    "rawText": " async (\n  name: string,\n  description: string | undefined,\n  /**\n   * NB: relative paths must be relative to OPERATION ROOT, not src root!\n   */\n  srcFileContentObject: {\n    [operationRelativeTypescriptFilePath: string]: string;\n  },\n  config?: {\n    manualProjectRoot?: string;\n    /**\n     * folder path without the folder name of the package to be created\n     *\n     * if given, will place it here, otherwise, will place it in the default location (tools/generated for os projects, packages for bundled projects)\n     */\n    destinationPath?: string;\n    /**\n     * if true, overwrites the operation if it already exists. It does this in a way that it does not break the OS very long, because it removes the old one only after the new one has been created. The removal and renaming the new one to this target name happens almost instantaneously\n     */\n    overwriteIfExists?: boolean;\n    overwriteCurrentOperationIfExists?: boolean;\n    /**\n     * if the operation did not exist before, `yarn install` will usually be ran.\n     *\n     * If you want to skip that, set this to `true`\n     *\n     */\n    skipYarnInstall?: boolean;\n\n    /**\n     * skips yarn build if `true`\n     */\n    skipYarnBuild?: boolean;\n    /**\n     * don't write anything, just return the files to create with the strings\n     */\n    dryrun?: boolean;\n  }\n): Promise<undefined | string> => {\n  // 1. calculates operation base path\n  const projectRoot = config?.manualProjectRoot || getProjectRoot();\n  if (!projectRoot) {\n    log(\"Not found projectroot\", { type: \"error\" });\n    return;\n  }\n\n  const defaultDestinationPath = isBundle(projectRoot)\n    ? path.join(projectRoot, \"packages\", \"generated\")\n    : path.join(projectRoot, projectRelativeGeneratedOperationsFolder);\n  const destinationPath = config?.destinationPath || defaultDestinationPath;\n\n  // 2. calculate simplest index.ts (no exposure of merged types object or tests)\n  const indexFileContent = Object.keys(srcFileContentObject)\n    .map((operationRelativeTypescriptFilePath) => {\n      return `export * from \"./${getSrcRelativeFileId(\n        operationRelativeTypescriptFilePath\n      )}\";`;\n    })\n    .join(\"\\n\");\n\n  const srcFileContentObjectWithIndex: {\n    [operationRelativeTypescriptFilePath: string]: string;\n    \"src/index.ts\": string;\n  } = { ...srcFileContentObject, \"src/index.ts\": indexFileContent };\n\n  if (config?.dryrun) {\n    await Promise.all(\n      Object.keys(srcFileContentObject).map((operationRelativePath) => {\n        const assetsPath = path.join(\n          __dirname,\n          \"..\",\n          \"assets\",\n          \"generated\",\n          operationRelativePath\n        );\n\n        console.log(`written to ${assetsPath}`);\n\n        return writeStringToFile(\n          assetsPath,\n          srcFileContentObject[operationRelativePath]\n        );\n      })\n    );\n\n    return;\n  }\n  // 3. make new operation\n\n  const actualBasePath = await newOperation(name, {\n    destinationPath,\n    description,\n    manualProjectRoot: projectRoot,\n  });\n\n  if (!actualBasePath) {\n    log(\"Failed creating new operation\", { type: \"error\" });\n    return;\n  }\n\n  if (!fs.existsSync(actualBasePath)) {\n    log(`actualBasePath does not exist: ${actualBasePath}`, { type: \"error\" });\n    return;\n  }\n\n  // The wished base path\n  const wishedBasePath = path.join(destinationPath, name);\n\n  // 4. write files to src\n  await objectMapAsync(\n    srcFileContentObjectWithIndex,\n    async (operationRelativeTypescriptFilePath, content) => {\n      const srcPath = path.join(\n        actualBasePath,\n        operationRelativeTypescriptFilePath\n      );\n\n      await writeStringToFile(srcPath, content);\n\n      return;\n    }\n  );\n\n  /** NB: if this is true, the operation is new and has a never-used name, this means it also needs to be installed before building! */\n  const isOperationNew = wishedBasePath !== actualBasePath;\n\n  const shouldOverwrite =\n    isOperationNew &&\n    config?.overwriteIfExists &&\n    fs.existsSync(wishedBasePath);\n\n  const finalOperationBasePath = shouldOverwrite\n    ? wishedBasePath\n    : actualBasePath;\n\n  // 6. yarn build there\n\n  if (!config?.skipYarnInstall) {\n    // in case this operation didn't exist before, run `yarn --offline`\n    // NB: this assumes we already have node_modules and the new operation has no weird new dependencies\n    spawnSync(\"yarn --offline\", {\n      cwd: actualBasePath,\n      encoding: \"utf8\",\n      stdio: \"inherit\",\n      shell: false,\n    });\n  }\n\n  // NB: if skipYarnInstall is enabled, we will also not build\n  const noBuild = config?.skipYarnBuild; // || config?.skipYarnInstall;\n\n  if (!noBuild) {\n    const isSuccesful = await yarnBuild(actualBasePath);\n\n    if (!isSuccesful) {\n      log(\"Building failed\", { type: \"error\" });\n      return;\n    }\n  }\n\n  // remove operation if it's already there and rename new operation to that target name\n  if (shouldOverwrite) {\n    /**\n     * first set the name to the same as the to be removed folder.\n     * NB: there are now two packages with the same name, yarn install will error\n     */\n    const packageJsonPath = path.join(actualBasePath, \"package.json\");\n    const hasAvailablePackageJson =\n      fs.existsSync(packageJsonPath) && (await canRead(packageJsonPath));\n    if (!hasAvailablePackageJson) {\n      return;\n    }\n\n    await setJsonKey({\n      jsonPath: packageJsonPath,\n      keyLocation: \"name\",\n      value: name,\n    });\n\n    if (fs.existsSync(wishedBasePath)) {\n      //then remove the original operation\n      await fs.rm(wishedBasePath, { recursive: true });\n    }\n\n    if (fs.existsSync(actualBasePath)) {\n      // then rename the new operation to the original operation path\n      await fs.rename(actualBasePath, wishedBasePath);\n    }\n  }\n\n  return finalOperationBasePath;\n}"
  },
  "newOperation": {
    "name": "newOperation",
    "slug": "TsFunction",
    "id": "yvwuhdptwyoypbmbhcclmvqt",
    "description": "# How to create a package/operation?\n\nThis cli creates the correct tsconfig.json, package.json, .gitignore, folder setup, so you can get started immedeately.\n\nReturns either the `operationBasePath` of the created operation, or undefined if something went wrong",
    "operationName": "new-template",
    "rawText": " async (\n  name?: string,\n  config?: NewOperationConfig\n): Promise<string | undefined> => {\n  // NB: if we don't specify the type, create a node operation by default\n  const type = config?.type || \"node-cjs\";\n\n  const description = config?.description;\n  const destinationPath = config?.destinationPath;\n  const manualProjectRoot = config?.manualProjectRoot;\n  const folder = name ? kebabCase(name) : \"untitled-operation\";\n  const source = path.resolve(__dirname, \"..\", \"assets\", \"templates\", type);\n  const templateExists = fs.existsSync(source);\n\n  if (!templateExists) {\n    log(\n      `${type} operations cannot be generated yet. Create a template in assets/templates/${type}`\n    );\n    return;\n  }\n\n  const rootFolderPath = destinationPath ? destinationPath : process.cwd();\n  const availableFolderName = await getAvailableOperationName(\n    rootFolderPath,\n    folder,\n    manualProjectRoot\n  );\n\n  const operationBasePath = path.join(rootFolderPath, availableFolderName);\n\n  // Make the non-existing folder\n  await fs.mkdir(operationBasePath, { recursive: true });\n  // Copy the template inthere\n  await fs.cpAsync(source, operationBasePath, { recursive: true });\n  // Rename templatefiles if needed\n  await renameTemplateFiles({ appDir: operationBasePath });\n\n  const packageJsonPath = path.join(operationBasePath, \"package.json\");\n\n  const hasAvailablePackageJson =\n    fs.existsSync(packageJsonPath) && (await canRead(packageJsonPath));\n  if (!hasAvailablePackageJson) {\n    log(\"The template package.json was not copied succesfully\", {\n      type: \"error\",\n    });\n    return;\n  }\n\n  await setJsonKey({\n    jsonPath: packageJsonPath,\n    keyLocation: \"name\",\n    value: availableFolderName,\n  });\n\n  if (description) {\n    await setJsonKey({\n      jsonPath: packageJsonPath,\n      keyLocation: \"description\",\n      value: description,\n    });\n  }\n\n  return operationBasePath;\n}"
  },
  "newTemplateCli": {
    "name": "newTemplateCli",
    "slug": "TsFunction",
    "id": "beegbgnngbeoobmtraoaahuq",
    "description": "newTemplate can be used as CLI:\n\nArguments:\n- type (required): a folder from `new-template/assets/templates`\n- destinationPath (optional): path where the template should be copied to (uses `cwd` by default)",
    "operationName": "new-template",
    "rawText": " () => {\n  const [type, destinationPath] = process.argv.slice(2);\n\n  newTemplate(type, destinationPath).then((basePath) => {\n    if (basePath) {\n      console.log(`Generated template`, { type });\n    } else {\n      console.log(\"Something went wrong\");\n    }\n  });\n}"
  },
  "newTemplate": {
    "name": "newTemplate",
    "slug": "TsFunction",
    "id": "fttyjiszghrghoykklihhtdn",
    "description": "Returns either the `basePath` of the created template, or undefined if something went wrong",
    "operationName": "new-template",
    "rawText": " async (\n  type: string,\n  destinationPath?: string\n): Promise<string | undefined> => {\n  const manualProjectRoot = getProjectRoot(destinationPath);\n\n  const source = path.resolve(__dirname, \"..\", \"assets\", \"templates\", type);\n  const templateExists = fs.existsSync(source);\n\n  if (!templateExists) {\n    log(\n      `${type} cannot be generated yet. Create a template in assets/templates/${type}`\n    );\n    return;\n  }\n\n  const basePath = destinationPath\n    ? destinationPath\n    : path.join(process.cwd(), type);\n  // const availableFolderName = await getAvailableOperationName(\n  //   rootFolderPath,\n  //   type,\n  //   manualProjectRoot\n  // );\n\n  // const basePath = path.join(rootFolderPath, availableFolderName);\n\n  // if (fs.existsSync(basePath)) {\n  //   log(`${basePath} already exists`);\n  //   return;\n  // }\n  // Make the non-existing folder\n  await fs.mkdir(basePath, { recursive: true });\n  // Copy the template inthere\n  await fs.cpAsync(source, basePath, { recursive: true });\n  // Rename templatefiles if needed\n  await renameTemplateFiles({ appDir: basePath });\n\n  return basePath;\n}"
  },
  "buildPackage": {
    "name": "buildPackage",
    "slug": "TsFunction",
    "id": "mrplxqoemrdgjmawckchmjpr",
    "description": "",
    "operationName": "package-scripts",
    "rawText": " ({\n  config,\n}: {\n  config: { obfuscate?: boolean };\n}) => {\n  //just run tsc with minify optionally\n}"
  },
  "installMissingMonorepoDependencies": {
    "name": "installMissingMonorepoDependencies",
    "slug": "TsFunction",
    "id": "eykpcpfagxeiuqkxepwrkrfn",
    "description": "",
    "operationName": "package-scripts",
    "rawText": " ({\n  packageJsonPath,\n}: {\n  packageJsonPath: string;\n}) => {}"
  },
  "obfucsate": {
    "name": "obfucsate",
    "slug": "TsFunction",
    "id": "kjwltioybajdmtzhfuhjbqou",
    "description": "If we distribute code that can be ran locally that includes a payment gateway before the actual functionality is executed, we need to make it as hard as possible to disable the payment gateway.\n\nIt will probably still be possible but a lot harder if we obfuscate the js code after building (before distributing).\n\nA good library that could do this is https://github.com/terser/terser\n\nThis would make it possible to make almost any code open source because it's unusable.\nThis technique would make it possible to distribute a codebase where most of the code is obfuscated but only a small part isn't so that the developer can work on that part of the codebase and nothing else while still running the whole thing locally.\nThis would provide new possibilities for flexible open source.",
    "operationName": "package-scripts",
    "rawText": " () => {\n  //todo;\n  return null;\n}"
  },
  "testPackage": {
    "name": "testPackage",
    "slug": "TsFunction",
    "id": "tveewsbbkeebuywziffkdtpi",
    "description": "Should check if there are any tests in the package and run them if they're available.\nResponse should indicate if tests pass or not",
    "operationName": "package-scripts",
    "rawText": " () => {}"
  },
  "prettierOperation": {
    "name": "prettierOperation",
    "slug": "TsFunction",
    "id": "allwhdqhiosmbboejxofxpsw",
    "description": "TODO:\n\nThis should become a plugin into prettier that will prettify the operation with some more conventions that I like.\n\nAt our OS we run it ourselves after every filechange.\n\nI can think of these ones now:\n\n- change all comments to be multiline or singleline doccomments without stars in the middle\n- add the return type to functions that don't specify it explicitly by inferring it. If it's already specified, we can assume that this is the intended returntype and shouldn't change it.\n\nThere are probably many many more things, but we shouldn't skip any steps!\n\n- the first step would be to add them as conventions.\n- second step would be linting them and showing lint errors in the editor\n- finally we can prettify it automatically with the below function",
    "operationName": "prettier-operation",
    "rawText": " (typescriptFileContent: string): string => {\n  return typescriptFileContent;\n}"
  },
  "clearTsDatabase": {
    "name": "clearTsDatabase",
    "slug": "TsFunction",
    "id": "ckyrtljweonhrbxtblzonqgc",
    "description": "Clears all typescript indexation models, and removes all indexation from the oprations\n\nTODO: test first, not sure about the Operation one",
    "operationName": "rebuild-operation",
    "rawText": " async (operationName: string | undefined) => {\n  const result = await Promise.all(\n    typescriptIndexModels.map((modelName) => {\n      return db.clear(modelName, { operationName });\n    })\n  );\n\n  await db.update(\n    \"Operation\",\n    () => true,\n    (old) =>\n      mergeNestedObject(old, {\n        operation: {\n          sizeIndexed: undefined,\n          buildResultIndexed: undefined,\n          classificationIndexed: undefined,\n          folderNameIndexed: undefined,\n          coreDependenciesIndexed: undefined,\n          hasGeneratedDependenciesIndexed: undefined,\n          operationDependenciesIndexed: undefined,\n          packageDependenciesIndexed: undefined,\n          relativeOperationLocationPathIndexed: undefined,\n        },\n      }),\n    { operationName }\n  );\n}"
  },
  "cwdProjectRoot": {
    "name": "cwdProjectRoot",
    "slug": "TsVariable",
    "id": "hlhyjvjccqcwzxvfyuwcpikv",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "executeCommandQuietUnlessFail": {
    "name": "executeCommandQuietUnlessFail",
    "slug": "TsFunction",
    "id": "hreiieaorevotmcrztvzfhfa",
    "description": "Executes a command without showing the result, unless the command fails, then it will log the output.,",
    "operationName": "rebuild-operation",
    "rawText": " (config: {\n  command: string;\n  cwd?: string;\n  /**\n   * if given, will show what is happening and a checkmark if it succeeds\n   */\n  description?: string;\n}): boolean => {\n  const { command, cwd, description } = config;\n  if (description) {\n    process.stdout.write(`${description} `);\n  }\n\n  try {\n    const result = execSync(command, {\n      cwd,\n      encoding: \"utf8\",\n      stdio: \"pipe\",\n    });\n\n    if (description) console.log(\"âœ…\");\n\n    return true;\n  } catch (e: any) {\n    if (description) console.log(\"âŒ\");\n    const error: {\n      status: number;\n      signal: any;\n      output: (string | null)[];\n      pid: number;\n      stdout: string;\n      stderr: string;\n    } = e;\n    console.log(`${command} went wrong:`, error?.stdout);\n\n    return false;\n  }\n}"
  },
  "exitIfProcessDependenciesChanged": {
    "name": "exitIfProcessDependenciesChanged",
    "slug": "TsFunction",
    "id": "koknvfaqzikezjbvhngdayry",
    "description": "exits the process if our own dependencies change",
    "operationName": "rebuild-operation",
    "rawText": " async (\n  operationName: string,\n  manualProjectRoot?: string\n) => {\n  const imports = (\n    await Promise.all(\n      [\"watch-operations\", \"rebuild-operation\"].map(\n        async (operationName) =>\n          // @ts-ignore\n          db.get(\"TsImport\", { operationName, manualProjectRoot }) as Promise<\n            TsImport[]\n          >\n      )\n    )\n  )\n    .flat()\n    .map((i: TsImport) => i.module)\n    // apparently this isn't a dependency of the above 3\n    .concat([\"watch-operations\"])\n    .filter(onlyUnique);\n\n  if (operationName && imports.includes(operationName)) {\n    log(`One of our dependencies (${operationName}) changed. Let's restart.`, {\n      type: \"important\",\n    });\n    process.exit(1);\n  }\n}"
  },
  "generateJsonSchemas": {
    "name": "generateJsonSchemas",
    "slug": "TsFunction",
    "id": "zpigkfvfktwfacylupxknpkg",
    "description": "generates schemas for db models\n\nIs done every time you run `rebuildOperation` and `generateSdkOperations`\n\nTODO: there are some problems with references that cannot be found with references to generic types... This can probably be solved, but it's not going to be easy!\n\nIDEA:\n\n1) find all referencing definitions in the main schema\n2) find those in all other interfaces\n3) recursively find references in those as well\n4) if you can't find the reference, remove the reference and replace type to \"any\" (add WARNING to description \"reference not found\")\n\nThis will result in a valid schema that has no unresolved references\n\nTODO: apply Storage<X> to db-models\n\nTODO: apply Array<X> to db-models with json-multiple\n\nTODO: apply special config conventions (MergedDbConfig) like tsconfig.json and package.json\n\nTODO: Make a validator that validates the whole database to this schema.",
    "operationName": "rebuild-operation",
    "rawText": " async (\n  manualProjectRoot?: string,\n  /**\n   * If given, does it just for a single operation\n   */\n  operationName?: string\n) => {\n  const projectRoot = manualProjectRoot || getProjectRoot();\n\n  if (!projectRoot) return;\n\n  const dbModels = await getAllDbModels(manualProjectRoot, operationName);\n\n  const jsonDbModels = dbModels.filter(\n    (x) =>\n      x.dbStorageMethod &&\n      [\"jsonMultiple\", \"jsonSingle\"].includes(x.dbStorageMethod)\n  );\n  /**\nLoop:\n\n- get the operationName for the model\n- use the db to get all interfaces with that very operationName except for the one of the model...,\n- get every `TsInterface.type.typeDefinition`\n- put those inside of keys in the `defintions` key\n- add the interface doccomment to the `title` key\n- put the main properties in properties\n- change copy `description` into `markdownDescription`, everywhere, to support Markdown Intellisense within JSON\n- set `additionalProperties` to `false`\n- set `\"$schema\": \"http://json-schema.org/draft-07/schema#\"`\n- maybe also apply storage of db convention, so no `xxxCalculated` properties or `operationName` etc... (Same as `Storage<X>`)\n- set `type: \"object\"`\n\n         */\n\n  const allSchemas = (\n    await Promise.all(\n      jsonDbModels.map(async (dbModel) => {\n        if (!dbModel.dbStorageMethod) return;\n        const locationPattern = getDefaultLocationPattern(\n          dbModel.dbStorageMethod,\n          dbModel.name\n        );\n        if (!locationPattern) return;\n\n        const allInterfaces = await db.get(\"TsInterface\", {\n          // operationName: dbModel.operationName,\n        });\n        const mainSchema = dbModel.type.typeDefinition;\n\n        const definitions = mergeObjectsArray(\n          allInterfaces\n            .filter((x) => x.name !== dbModel.name)\n            .map((x) => {\n              if (!x.type.typeDefinition) return;\n\n              const goodName = x.name.replace(\">\", \"%3E\").replace(\"<\", \"%3C\");\n              return { [goodName]: x.type.typeDefinition };\n            })\n            .filter(notEmpty)\n        );\n\n        const schema: JSONSchema7 = {\n          ...mainSchema,\n          $schema: \"http://json-schema.org/draft-07/schema#\",\n          title: dbModel.name,\n          additionalProperties: false,\n          description: dbModel.description,\n          definitions,\n        };\n\n        return {\n          schema,\n          fileMatch: [`/${locationPattern}`],\n          url: `./schemas/${pluralize(kebabCase(dbModel.name))}.schema.json`,\n        };\n      })\n    )\n  ).filter(notEmpty);\n\n  /**\n   The finished file should be put into `~/schemas/model-name.schema.json`\n\n    Recalculate `json.schemas` in `project-root.code-workspace` (in project root)\n\n    Put the storage convention in the `fileMatch` and the url to the project-relative schema in `url`...\n\n   */\n  const jsonSchemas = (\n    await Promise.all(\n      allSchemas.map(async (schemaObject) => {\n        const isWriteSuccessful = await writeJsonToFile(\n          path.join(projectRoot, schemaObject.url),\n          schemaObject.schema\n        );\n\n        if (!isWriteSuccessful) {\n          console.log(\"WRITE WERNT WRONG\");\n          return;\n        }\n\n        const { fileMatch, url } = schemaObject;\n        const setting = { fileMatch, url };\n\n        return setting;\n      })\n    )\n  ).filter(notEmpty);\n\n  const workspacePath = path.join(projectRoot, \"project-root.code-workspace\");\n  const workspace =\n    (await readJsonFile<{ [key: string]: any }>(workspacePath)) || {};\n\n  const oldSchemas = workspace.settings?.[\"json.schemas\"] || [];\n\n  // make new workspace by concatenating the schemas with the old one and removing duplicates\n  const newWorkspace = {\n    ...workspace,\n    settings: {\n      ...workspace.settings,\n      \"json.schemas\": jsonSchemas\n        .concat(oldSchemas)\n        .filter(\n          onlyUnique2<{ fileMatch: string[]; url: string }>(\n            (a, b) => a.url === b.url\n          )\n        ),\n    },\n  };\n\n  const isNewWorkspaceWritten = await writeJsonToFile(\n    workspacePath,\n    newWorkspace\n  );\n\n  // console.log({ isNewWorkspaceWritten, workspacePath });\n}"
  },
  "getAllDbModels": {
    "name": "getAllDbModels",
    "slug": "TsFunction",
    "id": "dylancbadbbkelwutxqdoawc",
    "description": "",
    "operationName": "rebuild-operation",
    "rawText": " async (\n  manualProjectRoot?: string,\n  operationName?: string\n) => {\n  const allDbModels = (\n    await db.get(\"TsInterface\", { manualProjectRoot, operationName: \"*\" })\n  )\n    .filter(\n      (x) => x.isDbModel && x.dbStorageMethod && x.isExported && !x.hasGeneric\n    )\n    .filter((x) => x.operationName !== \"database\")\n    .filter((x) => (operationName ? x.operationName === operationName : true))\n    .filter((x) => !!x.operationName) // && !dependants.includes(x.operationName)\n    .filter(onlyUnique2<TsInterface>((a, b) => a.name === b.name));\n\n  return allDbModels;\n}"
  },
  "getFileIds": {
    "name": "getFileIds",
    "slug": "TsFunction",
    "id": "fuexsrlqtxzgagltnojvmbes",
    "description": "gets all identifiers of files, which are the relative path to a file without the extension",
    "operationName": "rebuild-operation",
    "rawText": " async ({\n  operationFolderPath,\n  pathSuffix,\n  extension,\n}: {\n  operationFolderPath: string;\n  extension?: SearchableExtension | SearchableExtension[];\n  pathSuffix: string;\n}) => {\n  const basePath = path.join(operationFolderPath, pathSuffix);\n\n  return (\n    await explore({\n      basePath,\n      extension,\n    })\n  )\n    .map((x) => x.path)\n    .map((p) => withoutExtension(p.slice(basePath.length)));\n}"
  },
  "getIndexFileIds": {
    "name": "getIndexFileIds",
    "slug": "TsFunction",
    "id": "ogxxyqpyiegohqnjzdrwhoyt",
    "description": "gets identifiers of ts and tsx files, which are the relative path to a file without the extension",
    "operationName": "rebuild-operation",
    "rawText": " async (operationFolderPath: string) =>\n  getFileIds({\n    operationFolderPath,\n    // NB: we take index/variables here because we need the file ids of any index as they would be the same in any index\n    pathSuffix: `${databaseFolderName}/ts-variables`,\n    extension: \"json\",\n  })"
  },
  "getSrcIds": {
    "name": "getSrcIds",
    "slug": "TsFunction",
    "id": "sslypsxgqbhiehpyxzizdwln",
    "description": "gets identifiers of ts and tsx files, which are the relative path to a file without the extension\n\nin order for them to be unique, we assume here that there's never a file with the ts extension when there's also a tsx file in the same folder with the same name. This would create duplicate ids.",
    "operationName": "rebuild-operation",
    "rawText": " async (operationFolderPath: string) =>\n  getFileIds({\n    operationFolderPath,\n    pathSuffix: \"src\",\n    extension: [\"ts\", \"tsx\"],\n  })"
  },
  "isOperationBuildNeeded": {
    "name": "isOperationBuildNeeded",
    "slug": "TsFunction",
    "id": "vwmrptfqirxkczcosiliwfay",
    "description": "returns a boolean indicating whether or not the operation should be able to be built, based on the OperationClassification",
    "operationName": "rebuild-operation",
    "rawText": " (operationBasePath: string) => {\n  const classification = getOperationClassification(operationBasePath)!;\n\n  console.log(`${getLastFolder(operationBasePath)}: ${classification}`);\n\n  // NB: server, web, app and ui-es6 have different ways to keep the build up-to-date\n  // NB: esm can't be minified with current thing\n  const buildNeededOperatons: OperationClassification[] = [\n    \"cjs\",\n    // \"esm\",\n    \"node-cjs\",\n    // \"node-esm\",\n    \"ui-cjs\",\n    // \"ui-esm\",\n  ];\n  const isBuildNeeded = buildNeededOperatons.includes(classification);\n\n  return isBuildNeeded;\n}"
  },
  "isRebuildingProcessUpdated": {
    "name": "isRebuildingProcessUpdated",
    "slug": "TsVariable",
    "id": "lkmbhqopkfgqiarmqvdyazat",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "isSdkOperation": {
    "name": "isSdkOperation",
    "slug": "TsFunction",
    "id": "emdbkfqlvcxdbjfaewejrjun",
    "description": "",
    "operationName": "rebuild-operation",
    "rawText": " (operationBasePath: string) => {\n  const operationName = getLastFolder(operationBasePath);\n\n  return operationName.split(\"-\")[0] === \"sdk\";\n}"
  },
  "[isUpdatedString]": {
    "name": "[isUpdatedString]",
    "slug": "TsVariable",
    "id": "vccjcvtyhpawltsobtdaeehy",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "manualProjectRoot": {
    "name": "manualProjectRoot",
    "slug": "TsVariable",
    "id": "kpeoseoqfhjozajfwewltcug",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "rebuildAllOperations": {
    "name": "rebuildAllOperations",
    "slug": "TsFunction",
    "id": "kfppdomoilxmyultmrmblyhk",
    "description": "Rebuilds all operations that are needed to be rebuilt",
    "operationName": "rebuild-operation",
    "rawText": " async (\n  /**\n   * If true, you are indicating that the rebuilding process has changed and all operations should be rebuilt after this date.\n   */\n  isRebuildingProcessUpdated?: boolean,\n  manualProjectRoot?: string\n) => {\n  const configPath = path.join(__dirname, \"..\", \"config.json\");\n\n  if (isRebuildingProcessUpdated) {\n    await writeJsonToFile(configPath, { updatedAt: Date.now() });\n  }\n\n  const config = await readJsonFile<{ updatedAt: number }>(configPath);\n\n  forAllFolders({\n    type: \"operations\",\n    basePath: getPathsWithOperations({ manualProjectRoot }),\n    callback: async (folderPath, index) => {\n      log(`#${index}: Let's do ${folderPath}`, { type: \"success\" });\n\n      await rebuildOperation({\n        operationBasePath: folderPath,\n        noExit: true,\n        updatedAt: config?.updatedAt,\n      });\n\n      return;\n    },\n  });\n}"
  },
  "rebuildOperationCli": {
    "name": "rebuildOperationCli",
    "slug": "TsFunction",
    "id": "slppxxpkopfcuodcobhcjqoo",
    "description": "`rebuildOperation` CLI syntax:\n\n`rebuildOperation [...operations]`\n\nOperations can be a list of differnt operation names you want to rebuild. It's also possible to specify a relative path instead of an operation name.\n\nfor example:\n\n`rebuildOperation ./packages/operation-x` would rebuild `operation-x` in your packages folder\n\nanother handy one is `rebuildOperation .` because it will rebuild the operation in your current folder.",
    "operationName": "rebuild-operation",
    "rawText": " async () => {\n  const argumentsArray = process.argv.slice(2);\n  const currentProjectRoot = getProjectRoot();\n\n  if (argumentsArray.length > 0) {\n    oneByOne(argumentsArray, async (operationNameOrRelativePath) => {\n      let operationBasePath: string | undefined;\n      let realProjectRoot: string | undefined;\n      if (operationNameOrRelativePath.startsWith(\".\")) {\n        operationBasePath = path.join(\n          process.cwd(),\n          operationNameOrRelativePath\n        );\n\n        realProjectRoot = getProjectRoot(operationBasePath);\n      } else {\n        realProjectRoot = await getOperationPath(operationNameOrRelativePath);\n      }\n\n      if (!operationBasePath) {\n        log(\"couldn't find that operation\");\n        return;\n      }\n\n      // console.log({ operationNames, operationName });\n\n      const x = await rebuildOperation({\n        operationBasePath,\n        operationManualProjectRoot:\n          realProjectRoot !== currentProjectRoot ? realProjectRoot : undefined,\n        force: true,\n        debug: true,\n        noExit: true,\n      });\n    });\n  }\n}"
  },
  "rebuildOperation": {
    "name": "rebuildOperation",
    "slug": "TsFunction",
    "id": "dnyfmidrhzjhqinmdealutsn",
    "description": "This function rebuilds an operation and re-indexes (part of) its files.",
    "operationName": "rebuild-operation",
    "rawText": " async (config: {\n  /** last date when the rebuild-operation operation was updated (or any of its dependencies) */\n  updatedAt?: number;\n  /** If given, uses this as project root for the rebuildOperation dependencies, instead of the calculatable one */\n  typerepoManualProjectRoot?: string;\n\n  /**\n   * If given, uses this as project root for finding things from the database for the operation that needs to be rebuilt\n   */\n  operationManualProjectRoot?: string;\n\n  /** Full path to operation folder or any file therein */\n  operationBasePath: string;\n  /** If not given, explores all files in src folder of the operation. if given, must be an array of absolute file paths. it is not supported to index index files, as this creates duplicate and incorrect interfaces.  */\n  filePaths?: string[];\n  /** used for stopping recursion */\n  noUnresolvedRebuilding?: boolean;\n  /** if true, will not skip if nothing changed */\n  force?: boolean;\n  /** show logs */\n  debug?: boolean;\n  /** normally, it exits if the operation that was rebuilt was itself or one of its dependencies. Handy for watchOperations in combination with nodemon. If we don't want this behavior, provide noExit  */\n  noExit?: boolean;\n  /** stack of recursion of module names */\n  stack?: string[];\n}): Promise<boolean> => {\n  const {\n    operationBasePath,\n    force,\n    debug,\n    noExit,\n    stack = [],\n    updatedAt,\n    noUnresolvedRebuilding,\n    operationManualProjectRoot,\n    typerepoManualProjectRoot,\n  } = config;\n\n  let { filePaths } = config;\n  const operationName = getLastFolder(operationBasePath);\n  const packageJson = await getPackageJson({\n    operationFolderPath: operationBasePath,\n  });\n  if (\n    isSdkOperation(operationBasePath) ||\n    isGeneratedOperation(operationBasePath)\n  ) {\n    console.log(`not going to rebuild sdk operation: ${operationName}`);\n    return false;\n  }\n\n  const stackPrefix = `${stack.map(() => `--`).join(\"\")}${operationName}: `;\n  log(\n    `${stackPrefix}Rebuilding${\n      stack.length > 0 ? `(coming from ${stack.join(\", \")})` : \"\"\n    }`,\n    {\n      type: \"important\",\n    }\n  );\n\n  log(`${stackPrefix}Pre-index lint`, { type: \"important\" });\n  const lintProblems = await preIndexLint({\n    operationFolderPath: operationBasePath,\n  });\n\n  if (lintProblems.length > 0) {\n    log(`${stackPrefix}Operation cannot be built, we've got problem(s)`, {\n      type: \"warning\",\n    });\n    log(lintProblems.join(\"\\n\"), { type: \"warning\" });\n\n    await db.update(\n      \"Operation\",\n      () => true,\n      (old) => {\n        setKeyAtLocation(\n          \"operation.buildResultIndexed.lintProblems\",\n          lintProblems,\n          old\n        );\n\n        return old;\n      },\n      { operationName }\n    );\n\n    return false;\n  }\n\n  const skip = await shouldSkip({\n    operationBasePath,\n    debug,\n    force,\n    rebuildUpdatedAt: updatedAt,\n    operationManualProjectRoot,\n  });\n  if (skip) {\n    log(`Skipping ${operationName}`);\n    return true;\n  }\n\n  const result = await cleanupTsDatabase(\n    operationName,\n    operationManualProjectRoot\n  );\n\n  log(\n    result?.amountRemoved\n      ? `Removed ${result?.amountRemoved} ts db instances`\n      : \"Nothing to clean up\",\n    { type: \"success\" }\n  );\n\n  executeCommandQuietUnlessFail({\n    command: \"yarn --offline\",\n    cwd: operationBasePath,\n    description: `${stackPrefix}Installing`,\n  });\n\n  // 2a) finding imports/exports and writing them to index\n  // TODO: we can also just check if build folder and index.js exist before looking at the import statements. These are easy to detect and when that happens we don't need to do the things below.\n  log(`${stackPrefix}Getting imports/exports`, { type: \"important\" });\n\n  await runChildProcess({\n    operationFolderName: \"get-imports-exports\",\n    scriptFileName: \"findAndWriteImportsExports.cli\",\n    args: [operationBasePath, operationManualProjectRoot],\n  });\n\n  /// SDK SHIT\n\n  if (operationName !== \"sdk\") {\n    // get all newly generated imports through the db (NB: old index files have just been removed)\n    const imports = await db.get(\"TsImport\", {\n      operationName: operationName,\n      manualProjectRoot: operationManualProjectRoot,\n    });\n    // find the ones that are unresolved\n    const unresolvedModules = imports\n      .filter(\n        (x) => x.isAbsolute && x.isModuleFromMonorepo && !x.isModuleResolved\n      )\n      .map((x) => x.module)\n      .filter(onlyUnique);\n\n    // console.log({\n    //   imports: imports.length,\n    //   unresolvedModules: unresolvedModules.length,\n    // });\n\n    // if there are any, we need to rebuildOperation for those modules and then rebuild ourselves again\n    // NB: we can't do this if we already did this before\n    if (unresolvedModules.length > 0) {\n      if (noUnresolvedRebuilding) {\n        log(\n          `rebuilding the unresolved modules didn't work. Probably some indexation fails!`,\n          { type: \"error\" }\n        );\n\n        await db.update(\n          \"Operation\",\n          () => true,\n          (old) => {\n            setKeyAtLocation(\n              \"operation.buildResultIndexed.dependencyBuildFailed\",\n              true,\n              old\n            );\n\n            return old;\n          },\n          { operationName, manualProjectRoot: operationManualProjectRoot }\n        );\n\n        return false;\n      }\n\n      log(\n        `${stackPrefix}We need to rebuild ${\n          unresolvedModules.length\n        } operations because they have conflicts (${unresolvedModules.join(\n          \", \"\n        )})`,\n        { type: \"warning\" }\n      );\n      const succeededArray = await oneByOne(\n        unresolvedModules,\n        async (unresolvedOperationName) => {\n          const fullPath = await getOperationPath(unresolvedOperationName, {\n            manualProjectRoot: operationManualProjectRoot,\n          });\n          if (!fullPath) {\n            log(`${stackPrefix}${unresolvedOperationName} not found`, {\n              type: \"warning\",\n            });\n            return false;\n          }\n\n          if (\n            unresolvedOperationName === operationName ||\n            stack.includes(unresolvedOperationName)\n          ) {\n            log(`${stackPrefix}cyclic dep`, { type: \"warning\" });\n            return false;\n          }\n\n          console.log(`${stackPrefix}diving into new rebuildOperation `, {\n            operationName,\n            stack,\n            unresolvedOperationName,\n          });\n          return rebuildOperation({\n            operationManualProjectRoot,\n            typerepoManualProjectRoot,\n            operationBasePath,\n            stack: stack.concat([unresolvedOperationName]),\n            debug,\n            // can't skip this one because it is a dependency\n            // however, skipping is very well defined. we can skip if shouldSkip is true!\n            // force: true,\n            noExit,\n          });\n        }\n      );\n\n      // NB: we don't rebuild this operation again if one of the dependency builds failed...\n      if (!isAllTrue(succeededArray)) {\n        log(`${stackPrefix}something failed! returning`);\n\n        await db.update(\n          \"Operation\",\n          () => true,\n          (old) => {\n            setKeyAtLocation(\n              \"operation.buildResultIndexed.dependenciesBuildsFailed\",\n              true,\n              old\n            );\n            return old;\n          },\n          { operationName, manualProjectRoot: operationManualProjectRoot }\n        );\n\n        return false;\n      }\n\n      log(`${stackPrefix}rebuilding ourselves again`);\n      // NB: all files on purpose...\n      return rebuildOperation({\n        operationManualProjectRoot,\n        typerepoManualProjectRoot,\n        operationBasePath,\n        debug,\n        force,\n        noExit,\n        noUnresolvedRebuilding: true,\n        stack: stack.concat([operationName]),\n      });\n    } else {\n      log(`${stackPrefix}all imports were resolved`);\n    }\n  }\n\n  // 2b) compiling and writing build errors to index\n  log(`${stackPrefix}writing build errors SKIPPED due to memory bug`, {\n    type: \"important\",\n  });\n\n  // await runChildProcess({\n  //   operationFolderName: \"compile-typescript\",\n  //   scriptFileName: \"writeBuildErrors.cli\",\n  //   args: [\n  //     operationBasePath,\n  //     operationManualProjectRoot,\n  //     typerepoManualProjectRoot,\n  //   ],\n  // });\n  // read errors...\n  // TODO: if this returns errors, don't continue\n\n  // 3. creating remaining operation index files\n  if (!filePaths) {\n    //files from src\n    filePaths = (\n      await Promise.all(\n        await getPackageSourcePaths({\n          operationBasePath,\n          ignoreIndexFiles: true,\n        })\n      )\n    ).filter(notEmpty);\n  }\n\n  if (filePaths.length === 0) {\n    log(`${stackPrefix}No files found for operation ${operationName}`, {\n      type: \"error\",\n    });\n  } else {\n    log(`${stackPrefix}${filePaths.length} files to index:`, {\n      type: \"important\",\n    });\n  }\n\n  // first index the files that have changed\n  await runChildProcess({\n    operationFolderName: \"index-typescript\",\n    scriptFileName: \"cli\",\n    args: [...filePaths, operationManualProjectRoot || \"null\"],\n  });\n  // after that's done, generate cli's where possible. only if it's a node operation (or can I use node for js functions that also run on the frontend?) if not, I might be better off generating a [operation-name]-cli operation for js-only operations...\n\n  // first step, just\n\n  const indexPath = await generateSimpleIndex({\n    operationName,\n    manualProjectRoot: operationManualProjectRoot,\n  });\n\n  // // because we generated a new index, let's also reindex that file!\n  // TODO: Figure out if this is REALLY NEEDED... I guess we can also infer which things are in the index, and we don't want to index things here except maybe the imports/exports!\n  // if (indexPath) {\n  //   await runChildProcess({\n  //     operationFolderName: \"index-typescript\",\n  //     scriptFileName: \"cli\",\n  //     args: manualProjectRoot ? [indexPath, manualProjectRoot] : [indexPath],\n  //   });\n\n  //   log(`indexed index :)`, {\n  //     type: \"success\",\n  //   });\n  // }\n\n  const isBuildNeeded = isOperationBuildNeeded(operationBasePath);\n\n  let buildSucceeded = true;\n\n  // NB: no build, no tests (for now)\n  if (isBuildNeeded) {\n    const skipMinify = packageJson?.operation?.skipMinify;\n\n    buildSucceeded = await yarnBuild(operationBasePath, {\n      rmFirst: false,\n      skipMinify,\n    });\n\n    // TESTING EVERYTHING, including all dependant packages\n\n    const imports = await db.get(\"TsImport\", {\n      manualProjectRoot: operationManualProjectRoot,\n    });\n    // find the ones that are unresolved\n    const dependantOperationNames = imports\n      .filter((x) => x.isModuleFromMonorepo && x.module === operationName)\n      .map((x) => x.operationName)\n      .filter(onlyUnique)\n      .filter(notEmpty);\n\n    const testableOperations = [operationName, ...dependantOperationNames];\n    const testPromises = testableOperations.map((operationName) =>\n      // NB: we need this to be a child process because it requires the tests from the index, and that file changes, while normally a require will be cached. We can't easily invalidate the cache because it can come from many files.\n      runChildProcess({\n        operationFolderName: \"k-test\",\n        scriptFileName: \"runTestsForOperation.cli\",\n        args: [operationName, operationManualProjectRoot],\n      })\n    );\n\n    await Promise.all(testPromises);\n  }\n\n  await generateJsonSchemas(operationManualProjectRoot, operationName);\n\n  await db.update(\n    \"Operation\",\n    () => true,\n    (old) => {\n      setKeyAtLocation(\n        \"operation.buildResultIndexed.buildSucceeded\",\n        true,\n        old\n      );\n      return old;\n    },\n    { operationName, manualProjectRoot: operationManualProjectRoot }\n  );\n\n  const operationSummary = await getOperationSummary({\n    operationName,\n    manualProjectRoot: operationManualProjectRoot,\n  });\n\n  if (operationSummary) {\n    // make a readme of the new index\n    await operationToMarkdown({ operationSummary, returnType: \"save\" });\n  }\n\n  await db.update(\n    \"Operation\",\n    () => true,\n    (old) => {\n      setKeyAtLocation(\n        \"operation.buildResultIndexed.indexImportExportError\",\n        \"\",\n        old\n      );\n      setKeyAtLocation(\n        \"operation.buildResultIndexed.lintProblems\",\n        lintProblems,\n        old\n      );\n\n      return old;\n    },\n    { operationName, manualProjectRoot: operationManualProjectRoot }\n  );\n\n  await recalculateOperationIndexJson(\n    operationBasePath,\n    operationManualProjectRoot\n  );\n\n  if (!noExit) {\n    await exitIfProcessDependenciesChanged(\n      operationName,\n      operationManualProjectRoot\n    );\n  }\n\n  return true;\n}"
  },
  "shouldSkip": {
    "name": "shouldSkip",
    "slug": "TsFunction",
    "id": "tfgcamhrckowijdefucakopl",
    "description": "if you don't force it, there's an operation index, there's an index folder, the src has not been touched since hte last indexation, and there's a buildfolder (if needed), then the rebuildOperation can be skipped",
    "operationName": "rebuild-operation",
    "rawText": " async (config: {\n  operationBasePath: string;\n  debug?: boolean;\n  force?: boolean;\n  operationManualProjectRoot?: string;\n  rebuildUpdatedAt?: number;\n}) => {\n  const {\n    operationBasePath,\n    debug,\n    force,\n    rebuildUpdatedAt,\n    operationManualProjectRoot,\n  } = config;\n  const operationName = getLastFolder(operationBasePath);\n\n  if (force) {\n    console.log(\"Not skipping (force)\");\n    return false;\n  }\n\n  const operation = (\n    await db.get(\"Operation\", {\n      operationName,\n      manualProjectRoot: operationManualProjectRoot,\n    })\n  )[0];\n  if (!operation.operation?.folderNameIndexed) {\n    console.log(\n      \"Not skipping because no folderNameIndexed (likely never indexed) \"\n    );\n    return false;\n  }\n\n  if (\n    rebuildUpdatedAt &&\n    (!operation.operation?.lastRebuildAt ||\n      operation.operation.lastRebuildAt <= rebuildUpdatedAt)\n  ) {\n    console.log(\"Not skipping because rebuild updated\");\n    return false;\n  }\n\n  const srcPath = path.join(operationBasePath, \"src\");\n  const srcUpdatedAt = await folderGetUpdatedAt({ folderPath: srcPath });\n\n  if (\n    !operation.operation?.lastRebuildAt ||\n    operation.operation.lastRebuildAt <= srcUpdatedAt\n  ) {\n    console.log(\"Not skipping because src updated\");\n    return false;\n  }\n\n  const hasIndexFolder = fs.existsSync(\n    path.join(operationBasePath, databaseFolderName)\n  );\n  if (!hasIndexFolder) {\n    console.log(\"Not skipping because has no db folder \");\n    return false;\n  }\n\n  const noBuildFolder = !fs.existsSync(\n    path.join(operationBasePath, buildFolderName)\n  );\n\n  const isBuildNeeded = isOperationBuildNeeded(operationBasePath);\n\n  if (noBuildFolder && isBuildNeeded) {\n    console.log(\"Not skipping because noBuildFolder\");\n    return false;\n  }\n\n  return true;\n}"
  },
  "thisProjectRoot": {
    "name": "thisProjectRoot",
    "slug": "TsVariable",
    "id": "iirrqkxwjryqhmbmwdvpjecb",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "yarnBuild": {
    "name": "yarnBuild",
    "slug": "TsFunction",
    "id": "ozkdigjtybfxwytvmzfbydap",
    "description": "Builds and minifies the src",
    "operationName": "rebuild-operation",
    "rawText": " async (\n  operationBasePath: string,\n  config?: {\n    /**\n     * if true, build folder will be removed first\n     */\n    rmFirst?: boolean;\n    skipMinify?: boolean;\n  }\n): Promise<Success> => {\n  if (config?.rmFirst && fs.existsSync(path.join(operationBasePath, \"build\"))) {\n    const removed = spawnSync(`rm -rf build`, {\n      cwd: operationBasePath,\n      encoding: \"utf8\",\n      stdio: \"inherit\",\n      shell: true,\n    });\n  }\n\n  if (!fs.existsSync(operationBasePath)) {\n    return false;\n  }\n\n  // TODO:\n  // this should only happen conditionally but for now we'll always try\n  // later we can add the option to not build if any dependant builds break because of our code changes, but this is quite complex.\n  const success = executeCommandQuietUnlessFail({\n    command: \"yarn build\",\n    cwd: operationBasePath,\n    description: `Compiling source ${operationBasePath}`,\n  });\n\n  if (!success) {\n    log(`Build failed for ${getLastFolder(operationBasePath)}`, {\n      type: \"error\",\n    });\n    return false;\n  } //\n\n  if (config?.skipMinify) {\n    console.log(\"SKIPPING MINIFY\");\n\n    return success;\n  }\n\n  const minified = await minifyBuild({\n    buildFolderPath: path.join(operationBasePath, buildFolderName),\n  });\n\n  return minified || false;\n}"
  },
  "renameOperation": {
    "name": "renameOperation",
    "slug": "TsFunction",
    "id": "ptqgoivytqkzxefrqlgbdxob",
    "description": "renames the operation (oldFolder is optional anywhere in the package)\n\nTODO: before I ever rename a much-used operation again...\nall places where this operation is imported, it should rename that import and rebuild that operation, after renaming the operation... actually it's very important that I do this because renaming operations to a clearer name is good for code overview. Now, renaming and the refactor involved just takes too much time.",
    "operationName": "rename-operation",
    "rawText": " async ({\n  oldFolderPath,\n  newName,\n}: {\n  /**\n   * old folder path. use . or leave empty if you're somewhere in the folder\n   */\n  oldFolderPath?: string;\n  /**\n   * name to rename the package to\n   */\n  newName: string;\n}): Promise<void> => {\n  const operationFolderPath = oldFolderPath\n    ? findOperationBasePath(path.resolve(oldFolderPath))\n    : findOperationBasePath(process.cwd());\n\n  if (!operationFolderPath) return;\n  const packageJsonPath = path.join(operationFolderPath, \"package.json\");\n  const packageJson = await getPackageJson({ operationFolderPath });\n\n  if (!packageJson) {\n    return;\n  }\n  const oldName = packageJson?.name;\n  const oldCamelCaseName = oldName && camelCase(oldName);\n  const newCamelCaseName = camelCase(newName);\n\n  //replace code\n  if (oldCamelCaseName) {\n    const src = path.join(operationFolderPath, \"src\");\n    const results = fs.readdirSync(src);\n    results.forEach((fileName) => {\n      const filePath = path.join(src, fileName);\n      const contents = fs.readFileSync(filePath, \"utf8\");\n      const newContents = contents.replaceAll(\n        oldCamelCaseName,\n        newCamelCaseName\n      );\n      fs.writeFileSync(filePath, newContents, \"utf8\");\n    });\n  }\n\n  //replace package.json\n  const newPackageJson = packageJson;\n  newPackageJson.name = kebabCase(newName);\n  const oldBinValue = oldName && newPackageJson.bin?.[camelCase(oldName)];\n  newPackageJson.bin = {\n    ...newPackageJson.bin,\n    [newCamelCaseName]: oldBinValue || \"./build/cli.js\",\n  };\n\n  fs.writeFileSync(packageJsonPath, JSON.stringify(newPackageJson), \"utf8\");\n\n  await fs.rename(\n    operationFolderPath,\n    path.resolve(operationFolderPath, \"..\", newCamelCaseName)\n  );\n\n  console.log(\n    `Done! Make sure you also replace all imports in other packages\n    \\n\\n\n    import xyz from \"${oldName}\"; --> import xyz from \"${kebabCase(newName)};\n    \\n\\n\n    A simple find/replace all will do!`\n  );\n  /*\n  replace imports in all other packages to use new package-name using regex\n  */\n}"
  },
  "findFirstCommentTypes": {
    "name": "findFirstCommentTypes",
    "slug": "TsFunction",
    "id": "vkpqkfvvqhdghvkrwcowkjrf",
    "description": "Tries to find tie first appearing special comment line and parses it and returns it as part of the `CommentTypeObject`",
    "operationName": "schema-util",
    "rawText": " (\n  strippedFullComment?: string\n): CommentTypeObject => {\n  if (strippedFullComment === undefined) return {};\n  const lines = strippedFullComment.split(\"\\n\");\n\n  const specialCommentTypesObject = commentTypes\n    .map((commentType) => {\n      const matchingPart = `${commentType.toUpperCase()}:`;\n      const matchingLine = lines.find((line) => {\n        const trimmedLine = line.trimStart();\n        const isMatch = trimmedLine.startsWith(matchingPart);\n        return isMatch;\n      });\n\n      if (!matchingLine) return;\n\n      const strippedMatchingLine = matchingLine.trimStart();\n      const specialCommentWithoutPrefix = strippedMatchingLine\n        .slice(matchingPart.length)\n        .trim();\n\n      return {\n        [commentType]: specialCommentWithoutPrefix,\n      };\n    })\n    .filter(notEmpty);\n\n  const fullObject = mergeObjectsArray(\n    specialCommentTypesObject\n  ) as CommentTypeObject;\n\n  return fullObject;\n}"
  },
  "getDataParameterNames": {
    "name": "getDataParameterNames",
    "slug": "TsFunction",
    "id": "hxlcygkyejbjoqolkihnsisx",
    "description": "Finds all the data parameter names that might be there on an item, based on the item object keys and the convention",
    "operationName": "schema-util",
    "rawText": " (\n  item: AugmentedAnyModelType\n): string[] => {\n  const dataParameterNames = Object.keys(item)\n    .map((key) => {\n      const { dataParameterName } = getReferenceParameterInfo(key);\n\n      return dataParameterName;\n    })\n    .filter(notEmpty);\n\n  return dataParameterNames;\n}"
  },
  "getPossibleReferenceParameterNames": {
    "name": "getPossibleReferenceParameterNames",
    "slug": "TsFunction",
    "id": "rovriyqwmbxgcwcjufzrtvlx",
    "description": "returns the reference parameterNames...\n\n\ne.g.:\n```\ntodos -> todoSlugs + todoIds\ntodo -> todoSlug + todoId\n```",
    "operationName": "schema-util",
    "rawText": " (\n  parameterName: string\n): string[] => {\n  const possibleReferenceParameterNames = isPlural(parameterName)\n    ? referencePluralParameterNames\n        .map(capitaliseFirstLetter)\n        .map((ref) => `${singularize(parameterName)}${ref}`)\n    : referenceParameterNames\n        .map(capitaliseFirstLetter)\n        .map((ref) => `${parameterName}${ref}`);\n\n  return possibleReferenceParameterNames;\n}"
  },
  "getProperties": {
    "name": "getProperties",
    "slug": "TsFunction",
    "id": "wnsvvywagzdlbihygnokpuzn",
    "description": "Gets all the properties of a schema",
    "operationName": "schema-util",
    "rawText": " (schema: Schema | undefined): SchemaProperty[] => {\n  if (!schema) return [];\n  const propertyKeys = schema.properties ? Object.keys(schema.properties) : [];\n  const properties = propertyKeys\n    .map((key) => {\n      const propertySchema = getSchema(schema.properties?.[key]);\n      return propertySchema\n        ? {\n            name: key,\n            schema: propertySchema,\n            required: schema.required?.includes(key) || false,\n          }\n        : null;\n    })\n    .filter(notEmpty);\n\n  return properties;\n}"
  },
  "getRefLink": {
    "name": "getRefLink",
    "slug": "TsFunction",
    "id": "qijmmlxmudjepzdegghlousp",
    "description": "gets the $ref from a schema and parses the interface name from it",
    "operationName": "schema-util",
    "rawText": " (ref?: string) => {\n  const refLink = ref\n    ?.split(\"/\")\n    .pop()\n    ?.replaceAll(\"%3C\", \"<\")\n    .replaceAll(\"%3E\", \">\");\n\n  return refLink;\n}"
  },
  "getReferencableModels": {
    "name": "getReferencableModels",
    "slug": "TsFunction",
    "id": "keqoqndcbgfxyjtotnezajcv",
    "description": "based on the object properties in SimplifiedSchema, returns the model names that can be referenced",
    "operationName": "schema-util",
    "rawText": " (\n  simplifiedSchema?: SimplifiedSchema\n): ReferenceParameterInfo[] | undefined => {\n  if (simplifiedSchema?.type !== \"object\") return undefined;\n  const parameterNames = simplifiedSchema.properties?.map((x) => x.name);\n\n  const referenceParameterInfo = parameterNames\n    ?.map((parameterName) => {\n      const referenceParameterInfo = getReferenceParameterInfo(parameterName);\n\n      return referenceParameterInfo;\n    })\n    .filter((x) => x.isReferenceParameter);\n\n  return referenceParameterInfo;\n}"
  },
  "getReferenceParameterInfo": {
    "name": "getReferenceParameterInfo",
    "slug": "TsFunction",
    "id": "eqfawrbxcwcvxprewxwqwegl",
    "description": "Takes a parameterName and returns information about it according to the convention `{descriptorName}_{modelName}{referenceKey}` where:\n\n- descriptorName with the suffixing underscore is optional\n- referenceKey can be slug, index, or id (or there plural variants)\n- modelName should refer to a database model",
    "operationName": "schema-util",
    "rawText": " (\n  parameterName: string\n): ReferenceParameterInfo => {\n  const descriptorModelSplit = parameterName.split(\"_\");\n  const descriptor = parameterName.includes(\"_\")\n    ? descriptorModelSplit[0]\n    : undefined;\n  const rest = parameterName.includes(\"_\")\n    ? descriptorModelSplit[1]\n    : parameterName;\n\n  const wordArray = lowerCaseArray(rest);\n\n  const singleWord = wordArray.length === 1;\n\n  const parameterLastWord = wordArray.pop()!;\n\n  const isReferenceSingleParameter =\n    !singleWord && referenceParameterNames.includes(parameterLastWord);\n  const isReferenceMultipleParameter =\n    !singleWord && referencePluralParameterNames.includes(parameterLastWord);\n\n  const isReferenceParameter =\n    isReferenceSingleParameter || isReferenceMultipleParameter;\n\n  // NB: the last item has been removed now\n  const interfaceName = isReferenceParameter\n    ? pascalCase(wordArray.join(\"-\"))\n    : undefined;\n\n  // slug or id\n  const keyInModel = isReferenceParameter\n    ? singularize(parameterLastWord)\n    : undefined;\n\n  /**\n   * the reference keyword should be removed from the parameterName to receive the dataParameterName\n   *\n   * e.g. `weirdSluggyModelSlugs` becomes `weirdSluggyModels`\n   */\n  const dataParameterName =\n    isReferenceParameter && keyInModel\n      ? replaceLastOccurence(\n          parameterName,\n          capitaliseFirstLetter(keyInModel),\n          \"\"\n        )\n      : undefined;\n\n  const referenceParameterInfo: ReferenceParameterInfo = {\n    descriptor,\n    keyInModel,\n    interfaceName,\n    isReferenceMultipleParameter,\n    isReferenceSingleParameter,\n    isReferenceParameter,\n    dataParameterName,\n    parameterName,\n  };\n\n  return referenceParameterInfo;\n}"
  },
  "getSchemaItems": {
    "name": "getSchemaItems",
    "slug": "TsFunction",
    "id": "lukoanlohplbksavknbmrauw",
    "description": "==========\n\nSince `JSONSchema7`'s property `items` is fairly hard to use, this function gets that property in an easier to use way.",
    "operationName": "schema-util",
    "rawText": " (schema: Schema | undefined) => {\n  const schemas = makeArray(schema?.items).map(getSchema).filter(notEmpty);\n  return schemas;\n}"
  },
  "getSchema": {
    "name": "getSchema",
    "slug": "TsFunction",
    "id": "ttzzthdjqtmuzuoyhgjhwadi",
    "description": "parses a JSONSchema7Definition to JSONSchema7|undefined so we can use it",
    "operationName": "schema-util",
    "rawText": " (\n  maybeSchema: JSONSchema7Definition | undefined\n): Schema | undefined =>\n  typeof maybeSchema !== \"object\" ? undefined : maybeSchema"
  },
  "simplifiedSchemaToTypeDefinitionString": {
    "name": "simplifiedSchemaToTypeDefinitionString",
    "slug": "TsFunction",
    "id": "wjezjrfpdhffitrulppxfzex",
    "description": "Converts a simplifiedSchema definition back into a type interface string\n\nWith this, types can be generated in different ways",
    "operationName": "schema-util",
    "rawText": " (\n  simplifiedSchema?: SimplifiedSchema\n) => {\n  if (!simplifiedSchema) return \"\";\n\n  if (simplifiedSchema.enum && simplifiedSchema.enum.length > 0) {\n    // NB: TODO: This is probably not satisfactory for all enums! Needs testing\n    const enumString = simplifiedSchema.enum.map((x) => String(x)).join(\" | \");\n\n    return enumString;\n  }\n\n  if (simplifiedSchema.type === \"boolean\") return \"boolean\";\n  if (simplifiedSchema.type === \"null\") return \"null\";\n  if (simplifiedSchema.type === \"number\") return \"number\";\n  if (simplifiedSchema.type === \"string\") return \"string\";\n  if (\n    simplifiedSchema.type === \"array\" &&\n    simplifiedSchema.items &&\n    simplifiedSchema.items.length >= 1\n  ) {\n    const parts: string = simplifiedSchema.items\n      .map((x) => simplifiedSchemaToTypeDefinitionString(x.schema))\n      .join(\" | \");\n\n    const partsString: string =\n      simplifiedSchema.items && simplifiedSchema.items.length >= 2\n        ? `(${parts})[]`\n        : `${parts}[]`;\n\n    return partsString;\n  }\n\n  if (simplifiedSchema.type === \"object\" && simplifiedSchema.properties) {\n    const objectParts = simplifiedSchema.properties.map((prop) => {\n      const descriptionString = prop.schema.description\n        ? `/** ${prop.schema.description} */\\n`\n        : \"\";\n      const punctuationString = `${prop.required ? \"\" : \"?\"}: `;\n      const propertyString: string = `${descriptionString}${\n        prop.name\n      }${punctuationString}${simplifiedSchemaToTypeDefinitionString(\n        prop.schema\n      )};`;\n\n      return propertyString;\n    });\n\n    const objectString = `{\\n${objectParts.join(\"\\n\")}\\n};\\n`;\n\n    return objectString;\n  }\n\n  // NB: Should never be the case, we have handled all types\n  return \"\";\n}"
  },
  "simplifySchema": {
    "name": "simplifySchema",
    "slug": "TsFunction",
    "id": "eniwteltbjqfxsqzbjbwjecr",
    "description": "Return a SimplifiedSchema by giving the JSONSchema7 schema, its name and a list of possible references in the JSONSchema.\n\nA SimplifiedSchema is a data structure that allows you to easily define type interfaces that need to build out forms.\n\n# Todo\n\nDual types aren't done right yet. I probably don't look at `anyOf` yet, which makes it result in an empty object.\n\nFor example, this one is problematic:\n\nINPUT:\n\n```json\n{\n\"schema\": {\n\"anyOf\": [\n{\"type\": \"string\"},\n{\"type\": \"array\",\"items\": {\"type\": \"string\"}}\n]\n},\n```\n\nOutput:\n```json\n{\n\"simplifiedSchema\": {\n\"properties\": [],\n\"type\": \"object\"\n},\n}\n```\n\nTo test this one, test `npx rebuildOperation filename-conventions`",
    "operationName": "schema-util",
    "rawText": " (\n  /** The name of the type interface, (this could be used as $ref). */\n  name: string | null,\n\n  /** The schema that needs to be simplified */\n  schema: JSONSchema7,\n\n  /** The array of other schemas found when crawling file this schema was found in. this also includes all refs to other type interfaces in all schemas in that file */\n  possibleRefs: {\n    /** the name of the schema, (without /definitions/ prefix like $ref) */\n    name: string;\n    schema: JSONSchema7;\n  }[],\n  /**\n   * This function is recursive. If we find any reference to another schema, we will add the name of the current schema to the rootStack and explore that schema.\n   */\n  rootStack: string[]\n): SimplifiedSchema | undefined => {\n  if (Array.isArray(schema.type)) {\n    // let's do this one later\n    log(\n      `I don't support this usecase (type is an array of multiple types)... ${schema.type.join(\n        \",\"\n      )}`,\n      {\n        type: \"debug\",\n      }\n    );\n  }\n  const type = Array.isArray(schema.type) ? schema.type[0] : schema.type;\n  const newRootStack = name ? rootStack.concat(name) : rootStack;\n  const refName = getRefLink(schema.$ref);\n\n  // NB: we already encountered this ref before, let's avoid infinite recursion here.\n\n  const isCircularRef = !!refName && rootStack.includes(refName);\n\n  if (refName && !isCircularRef) {\n    const refSchema = possibleRefs.find((r) => r.name === refName);\n    if (!refSchema) {\n      log(`ref not present: ${refName}`, { type: \"warning\" });\n      // log(\"Strange, ref was not present in the possible refs\", {\n      //   type: \"debug\",\n      // });\n\n      // console.log({\n      //   possibleRefNames: possibleRefs.map((x) => x.name),\n      //   refName,\n      // });\n    }\n\n    const thisDescription = schema.description\n      ? `${schema.description}\\n\\n`\n      : \"\";\n    const mergedSchema = refSchema?.schema\n      ? {\n          ...refSchema.schema,\n          description: `${thisDescription}${\n            refSchema.schema.description || \"\"\n          }`,\n        }\n      : undefined;\n\n    return mergedSchema\n      ? simplifySchema(refName, mergedSchema, possibleRefs, newRootStack)\n      : undefined;\n  }\n\n  const fullComment = schema.description;\n\n  const commentTypeObject = findFirstCommentTypes(fullComment);\n  // TODO: Add all other `CommentType`s as properties\n  const simplifiedPrimitive = {\n    enum: schema.enum,\n    circularRefName: refName,\n    fullComment,\n    ...commentTypeObject,\n  };\n\n  if (type === \"boolean\") {\n    return { ...simplifiedPrimitive, type: \"boolean\" };\n  }\n\n  if (type === \"integer\" || type === \"number\") {\n    // NB: integers are also numbers\n    return { ...simplifiedPrimitive, type: \"number\" };\n  }\n\n  if (type === \"null\") {\n    return { ...simplifiedPrimitive, type: \"null\" };\n  }\n\n  if (type === \"string\") {\n    return { ...simplifiedPrimitive, type: \"string\" };\n  }\n\n  if (type === \"array\") {\n    const items = getSchemaItems(schema);\n\n    const simplifiedItems: SimplifiedSchemaItem[] = items\n      .map((item) => {\n        const itemName = getRefLink(item.$ref) || null;\n        const schema = simplifySchema(\n          itemName,\n          item,\n          possibleRefs,\n          name ? rootStack.concat(name) : rootStack\n        );\n        if (!schema) return;\n        return {\n          schema,\n          name: itemName,\n        };\n      })\n      .filter(notEmpty);\n\n    return {\n      ...simplifiedPrimitive,\n      items: simplifiedItems,\n      type: \"array\",\n    };\n  }\n\n  // NB: type must be an object here, it's the only possibility left...\n  // in case of objects\n\n  const properties = getProperties(schema);\n\n  const simplifiedProperties: SimplifiedSchemaProperty[] = properties\n    .map((property) => {\n      const schema = simplifySchema(\n        property.name,\n        property.schema,\n        possibleRefs,\n        newRootStack\n      );\n\n      if (!schema) return;\n\n      const possibleReferenceParameterNames =\n        getPossibleReferenceParameterNames(property.name);\n\n      const hasReferenceParameter = !!properties.find((x) =>\n        possibleReferenceParameterNames.includes(x.name)\n      );\n\n      // NB: if the property has a model reference, we just need the model reference, not the whole model. This is only for retreiving, it's not present in the database.\n      if (hasReferenceParameter) return;\n\n      return {\n        name: property.name,\n        required: property.required,\n        schema,\n      };\n    })\n    .filter(notEmpty);\n\n  return {\n    ...simplifiedPrimitive,\n    properties: simplifiedProperties,\n    type: \"object\",\n  };\n}"
  },
  "getSimpleTypescriptFileString": {
    "name": "getSimpleTypescriptFileString",
    "slug": "TsFunction",
    "id": "dhgygliacoefudjqlxakwhoj",
    "description": "Calculates a complete file string based on a parsed item\n\n- calculate variable names based on the code + indexKey\n- use their properties to generate needed code",
    "operationName": "simple-typescript-js",
    "rawText": " (\n  parsedItem: SimpleTypescriptFile\n): string => {\n  const {\n    description,\n    freeformObject,\n    name,\n    mappedObject,\n    typeEnum,\n    typedArray,\n    indexKey,\n  } = parsedItem;\n  const docCommentString = description\n    ? `/**\\n${description}\\n*/\\n`\n    : undefined;\n\n  // freeform\n  const freeformVariableName = camelCase(singularize(name));\n  const freeformObjectString = freeformObject\n    ? `${docCommentString}export const ${freeformVariableName} = ${jsonToString(\n        freeformObject\n      )};`\n    : undefined;\n\n  // mapped object\n  const mappedObjectVariableName = camelCase(`${name}-per-${indexKey}`);\n  const mappedObjectString =\n    mappedObject && indexKey\n      ? `${docCommentString}export const ${mappedObjectVariableName} = ${jsonToString(\n          mappedObject\n        )}`\n      : undefined;\n\n  // type enum variable names\n  const typeEnumVariableNameBase =\n    camelCase(isPlural(name) ? name : pluralize(name)) +\n    (indexKey ? pascalCase(indexKey) : \"\");\n  const typeEnumConstVariableName = typeEnumVariableNameBase + \"Const\";\n  const typeEnumTypeVariableName = pascalCase(\n    typeEnumVariableNameBase + \"Type\"\n  );\n  const typeEnumVariableName = typeEnumVariableNameBase + `Array`;\n\n  // type enum strings\n  const typeEnumConstString = typeEnum\n    ? `${docCommentString}export const ${typeEnumConstVariableName} = ${jsonToString(\n        typeEnum\n      )} as const;`\n    : undefined;\n  const typeEnumTypeString = typeEnum\n    ? `${docCommentString}export type ${typeEnumTypeVariableName} = typeof ${typeEnumConstVariableName}[number];`\n    : undefined; // or just do \"${typeEnum.map(x=>`\"${x}\"`).join(\" | \")}\"\n  const typeEnumArrayString = typeEnum\n    ? `${docCommentString}export const ${typeEnumVariableName} = [...${typeEnumConstVariableName}];`\n    : undefined;\n\n  // typed array\n  const typedArrayVariableName = camelCase(\n    isPlural(name) ? name : pluralize(name)\n  );\n  const typedArrayString = typedArray\n    ? `${docCommentString}export const ${typedArrayVariableName} = ${jsonToString(\n        typedArray\n      )}`\n    : undefined;\n\n  /**\n   * sum up the parts and return that\n   */\n  const parts = [\n    // freeform object\n    freeformObjectString,\n\n    // mapped object\n    mappedObjectString,\n\n    // enum\n    typeEnumConstString,\n    typeEnumTypeString,\n    typeEnumArrayString,\n\n    // array\n    typedArrayString,\n  ].filter(notEmpty);\n\n  return parts.join(\"\\n\\n\");\n}"
  },
  "jsonToString": {
    "name": "jsonToString",
    "slug": "TsFunction",
    "id": "kzixyawosnzvydupzmfqxpcg",
    "description": "Returns prettified json",
    "operationName": "simple-typescript-js",
    "rawText": " (json: Json): string => {\n  return JSON.stringify(json, undefined, 2);\n}"
  },
  "parseRawSimpleTypescriptFile": {
    "name": "parseRawSimpleTypescriptFile",
    "slug": "TsFunction",
    "id": "qlfcqbbftuactbpfhmpazzzg",
    "description": "Parses a SimpleTypescriptFile to ensure all data is there that can be generated from a raw item",
    "operationName": "simple-typescript-js",
    "rawText": " (\n  item: SimpleTypescriptFile\n): SimpleTypescriptFile => {\n  const { name, isOperation, isSdk, description } = item;\n\n  /*not needed\n  ---\n    createdAt,\n    createdFirstAt,\n    deletedAt,\n    id,\n    operationName,\n    projectRelativePath,\n    updatedAt,\n    categoryStack,\n    description,\n    operationRelativePath,\n*/\n  const defaultItem = {\n    name,\n    description,\n    isOperation,\n    isSdk,\n  };\n\n  if (item.freeformObject) {\n    // freeformObject's are exclusive\n    return { ...defaultItem, freeformObject: item.freeformObject };\n  }\n\n  const typedArray: unknown[] | undefined = item.typedArray\n    ? item.typedArray\n    : item.mappedObject\n    ? Object.values(item.mappedObject)\n    : undefined;\n\n  const firstItemKeys =\n    typedArray && typedArray[0] ? Object.keys(typedArray[0]) : undefined;\n\n  const indexKey = item.indexKey\n    ? item.indexKey\n    : firstItemKeys?.includes(\"slug\")\n    ? \"slug\"\n    : firstItemKeys?.includes(\"name\")\n    ? \"name\"\n    : undefined;\n\n  const mappedObject = item.mappedObject\n    ? item.mappedObject\n    : typedArray && indexKey && typeof typedArray === \"object\"\n    ? createMappedObject(\n        typedArray as { [key: string]: any }[],\n        indexKey,\n        item.typedArrayMappedObjectMapFunction\n      )\n    : undefined;\n\n  const typeEnum = mappedObject ? Object.keys(mappedObject) : item.typeEnum;\n\n  return {\n    ...defaultItem,\n    typedArray,\n    indexKey,\n    mappedObject,\n    typeEnum,\n  };\n}"
  },
  "createOperationsSdkCli": {
    "name": "createOperationsSdkCli",
    "slug": "TsFunction",
    "id": "yhyptgtxiqhsviemwhlszvlf",
    "description": "",
    "operationName": "simple-typescript-node",
    "rawText": " async () => {\n  const operations = (await db.get(\"Operation\")).map((x) => ({\n    name: x.name,\n    folder: getFolder(x.projectRelativePath),\n  }));\n\n  createSimpleTypescriptFile({\n    name: \"operationPaths\",\n    description: \"operation paths\",\n    isSdk: true,\n    isOperation: false,\n    typedArray: operations,\n\n    typedArrayMappedObjectMapFunction: (item, array) => item.folder,\n    // indexKey : should be name\n  });\n}"
  },
  "createSimpleTypescriptFile": {
    "name": "createSimpleTypescriptFile",
    "slug": "TsFunction",
    "id": "raxjdnpivkmuoohabskaayhm",
    "description": "This is the most important one. Update/upsert is not really needed since we can just \"get\" from the acutal code\n\nThis function should generate as much code as possible from the item. Not all parameters are always given.\n\nNB: This doesn't necessarily need to be a part of `fs-orm`, it's super handy in itself!",
    "operationName": "simple-typescript-node",
    "rawText": " (item: SimpleTypescriptFile) => {\n  const parsedItem = parseRawSimpleTypescriptFile(item);\n  const typescriptFileString = getSimpleTypescriptFileString(parsedItem);\n\n  const alteredOperationNames = [\n    item.isSdk ? \"sdk\" : undefined,\n    item.isOperation ? `sdk-${slugify(item.name)}` : undefined,\n  ].filter(notEmpty);\n\n  // writeToFiles()\n\n  if (item.isSdk) {\n    // store as part of sdk\n  }\n\n  if (item.isOperation) {\n    // store as operation with name `sdk-{slug}`\n  }\n\n  // generate simple index for altered operation\n\n  // build, if required\n\n  return {\n    // return a `fs-orm`-like object that states the `QueryResult`\n  };\n\n  // once I did this, let's apply this in generateSdkOperations\n}"
  },
  "[operationName, manualProjectRoot]": {
    "name": "[operationName, manualProjectRoot]",
    "slug": "TsVariable",
    "id": "euntkpgmdzusugpwpleoqznn",
    "description": "",
    "operationName": "k-test"
  },
  "runTestsForOperation": {
    "name": "runTestsForOperation",
    "slug": "TsFunction",
    "id": "yqggrjeesmrugxabthxvnheq",
    "description": "runTestsForOperation(operationName) runs all tests that can be found in an operation. nicely logs and returns which funtions are working or not and why\n\nthis assumes the index file exports all tests under the `test` constant, which should be done using this framework\n\nthis also assumes your tests are exported from build/index.js (which means you need to build your code, not transpile, so it's not possible for every type of operation)",
    "operationName": "k-test",
    "rawText": " async (\n  operationName: string,\n  writeResultsToIndex?: boolean,\n  manualProjectRoot?: string\n) => {\n  // console.log(`TESTING ${operationName}`);\n  const operationBasePath = await getOperationPath(operationName, {\n    manualProjectRoot,\n  });\n  if (!operationBasePath) {\n    console.log(\"k-test:Couldn't find operation base path...\", {\n      operationName,\n    });\n    return;\n  }\n\n  const operationIndexJsPath = path.join(operationBasePath, \"build/index.js\");\n\n  if (!fs.existsSync(operationIndexJsPath)) {\n    console.log(\"Couldn't find operation build/index.js file\", {\n      operationName,\n      operationIndexJsPath,\n    });\n    return;\n  }\n\n  const tests: Test | undefined = require(operationIndexJsPath).test;\n\n  if (!tests) {\n    log(`No tests found for ${operationName}`, { type: \"debug\" });\n    return;\n  }\n\n  return runTests(tests, operationName);\n}"
  },
  "sum": {
    "name": "sum",
    "slug": "TsFunction",
    "id": "cukjmzplhkbsbrtyynlxtqwy",
    "description": "",
    "operationName": "js-util",
    "rawText": " (items: number[]) => {\n  const total = items.reduce((total, num) => {\n    if (typeof num !== \"number\") {\n      console.log(\"WTF\", num);\n    }\n    return total + num;\n  }, 0);\n\n  return total;\n}"
  },
  "isResultOfInterface": {
    "name": "isResultOfInterface",
    "slug": "TsFunction",
    "id": "deunzrbudderslyhtqclhayc",
    "description": "TODO: need validate-json-schema. also this can be its own little package, as it can be used in many other places\n\nnot sure if this should be part of make-test at all, because we want operations to be able to operate independently without the os, right? so then it won't work because you don't always have indexes...",
    "operationName": "make-test",
    "rawText": " <TResult>(\n  result: TResult,\n  jsonSchema: JSONSchema\n): boolean => {\n  return true;\n}"
  },
  "makeTest": {
    "name": "makeTest",
    "slug": "TsFunction",
    "id": "ywhmswjczsfjkwrtqikpnryq",
    "description": "create a test that is testable with `runAllTests`...",
    "operationName": "make-test",
    "rawText": " <TResult>(\n  /**\n   * callback that calls the function to test with a certain input\n   */\n  testFunction: (() => Promise<TResult>) | (() => TResult),\n  /** If not given, assumes it passes if it returns the type interface it says it returns (and it doesn't crash) */\n  isValid?: (result: TResult) => boolean\n) => {\n  // NB: don't execute the test immideately, so we return a callback that actually tests\n  return async () => {\n    // try because funning the test may crash the app if the function doesn't work properly\n    try {\n      // TODO: what's the difference between TResult and Awaited<TResult>?\n      const result: TResult = await testFunction();\n\n      /**\n       * TODO:\n       */\n      const shouldBeInterface = {};\n\n      const correctInterface = isResultOfInterface(result, shouldBeInterface);\n      const isResultValid = isValid\n        ? correctInterface && isValid(result)\n        : correctInterface;\n\n      if (!isResultValid) {\n        console.dir(\n          {\n            response: `âŒ TEST FAILED`,\n            test: testFunction.toString(),\n            result,\n          },\n          { depth: 999 }\n        );\n      } //\n\n      return isResultValid;\n    } catch (error) {\n      // TODO: check if toString here returns the right thing (a string representation of the function to test). otherwise, find a different solution.\n      console.log(`âŒ TEST FAILED: ${testFunction.toString()}`, error);\n      return false;\n    }\n  };\n}"
  },
  "getAllTsMorphSourceFiles": {
    "name": "getAllTsMorphSourceFiles",
    "slug": "TsFunction",
    "id": "mxkspnpqujwbndgxpowhiana",
    "description": "",
    "operationName": "ts-morph-util",
    "rawText": " async (operationBasePath: string) => {\n  const filePaths = await getPackageSourcePaths({\n    operationBasePath,\n  });\n  const project = getTsMorphProject(operationBasePath);\n  if (!project) {\n    log(\"couldn't load project\", { type: \"error\" });\n    return;\n  }\n\n  //select correct SourceFile from tsmorph project\n  const sourceFiles = project.getSourceFiles(filePaths);\n\n  return sourceFiles;\n}"
  },
  "getHasGeneric": {
    "name": "getHasGeneric",
    "slug": "TsFunction",
    "id": "baeuqleymwwhabadcvcyegtx",
    "description": "returns a boolean indicating whether an interface or type has one or more generic arguments",
    "operationName": "ts-morph-util",
    "rawText": " (\n  type: InterfaceDeclaration | TypeAliasDeclaration\n) => {\n  return type.getTypeParameters().length > 0;\n}"
  },
  "getTsMorphProject": {
    "name": "getTsMorphProject",
    "slug": "TsFunction",
    "id": "sbaxrqyfpubxuaptsimtdben",
    "description": "returns a ts-morph Project given a operationFolderPath, if a tsconfig.json can be found",
    "operationName": "ts-morph-util",
    "rawText": " (operationFolderPath: string) => {\n  const tsConfigFilePath = path.join(operationFolderPath, \"tsconfig.json\");\n\n  const tsConfigExists = fs.existsSync(tsConfigFilePath);\n  const srcExists = existsSync(path.join(operationFolderPath, \"src\"));\n  if (!tsConfigExists || !srcExists) {\n    log(\n      `This is not an operation: ${operationFolderPath}. (src folder or tsconfig.json are not present)`,\n      { type: \"error\" }\n    );\n    return;\n  }\n\n  const project = new Project({ tsConfigFilePath, libFolderPath: \"src\" });\n\n  return project;\n}"
  },
  "API_CUSTOM_URL_KEY": {
    "name": "API_CUSTOM_URL_KEY",
    "slug": "TsVariable",
    "id": "domacyhpnqturbnqrxlfwvel",
    "description": "",
    "operationName": "api"
  },
  "API_NO_RESPONSE_TIME_KEY": {
    "name": "API_NO_RESPONSE_TIME_KEY",
    "slug": "TsVariable",
    "id": "hamxobktxbjdledwqzqpssiy",
    "description": "",
    "operationName": "api"
  },
  "apiWithConfig": {
    "name": "apiWithConfig",
    "slug": "TsVariable",
    "id": "wjcolqnwbikqwpsenosievny",
    "description": "This object contains a api function for every function in the backend\n\nThe difference from `api` is that it allows you to also insert custom api configurations",
    "operationName": "api"
  },
  "api": {
    "name": "api",
    "slug": "Operation",
    "id": "LKkLDGQFSIHMUXTg",
    "operationName": "api"
  },
  "AUTH_TOKEN_STORAGE_KEY": {
    "name": "AUTH_TOKEN_STORAGE_KEY",
    "slug": "TsVariable",
    "id": "hjencuqxmjilstkqdyopsvjm",
    "description": "",
    "operationName": "api"
  },
  "fn1": {
    "name": "fn1",
    "slug": "TsFunction",
    "id": "tsdbzilhlgpdokamntbtvnmm",
    "description": "There is probably some doc-comments available for the function, maybe we can fix this with proxies to pass those comments... that would be insane.",
    "operationName": "api",
    "rawText": " (a: string, b: number) => {\n  return true;\n}"
  },
  "fn2": {
    "name": "fn2",
    "slug": "TsFunction",
    "id": "hzqtctblgumzqgodvjbyywjn",
    "description": "",
    "operationName": "api",
    "rawText": " (a: string, b: number) => {\n  return 282827;\n}"
  },
  "fn3": {
    "name": "fn3",
    "slug": "TsFunction",
    "id": "puzubsyzinwiegwoaofkavnl",
    "description": "",
    "operationName": "api",
    "rawText": " async (a: string, b: number) => {\n  return Promise.resolve(\"yesssss\");\n}"
  },
  "getGetApiUrl": {
    "name": "getGetApiUrl",
    "slug": "TsFunction",
    "id": "hqlnzwnvhzwsvzlyharmiazd",
    "description": "gets an api url for a context get api\n\nreturns something like `[apiUrl]/[apiFunctionName][queryString]`",
    "operationName": "api",
    "rawText": " (\n  apiUrl: string | undefined,\n  apiFunctionName: string,\n  query: { [name: string]: string[] | string | undefined }\n): string | undefined => {\n  if (!apiUrl) return;\n  const queryString = Object.keys(query).length > 0 ? toQueryString(query) : \"\";\n  const url = `${apiUrl}/function/${apiFunctionName}${queryString}`;\n  return url;\n}"
  },
  "queries": {
    "name": "queries",
    "slug": "TsVariable",
    "id": "mhbskzjdbosxievwrnplxqgp",
    "description": "This object contains a react-query `useQuery` hook for every api function",
    "operationName": "api"
  },
  "sdkExample": {
    "name": "sdkExample",
    "slug": "TsVariable",
    "id": "dyezbfospobvcilywtrmedoy",
    "description": "",
    "operationName": "api"
  },
  "untypedApiFunction": {
    "name": "untypedApiFunction",
    "slug": "TsFunction",
    "id": "alfxsjnlbumfsycurllorokr",
    "description": "Used for calling the actual api for a function with some config\n\nNB: this is not a typed function as we are just overwriting it so we don't need any inference on this",
    "operationName": "api",
    "rawText": " async (\n  fnName: string,\n  config: ApiConfig,\n  ...parameters: any\n): Promise<RealApiReturnType<any>> => {\n  // TODO: document this convention\n  const storageAuthToken: string | undefined = await getItem(\n    AUTH_TOKEN_STORAGE_KEY\n  );\n\n  const authToken = config.authToken || storageAuthToken;\n  const realApiUrl = config.apiUrl || apiUrl;\n\n  if (realApiUrl === undefined) {\n    return {\n      isSuccessful: false,\n      isNotConnected: true,\n      message: \"The API cannot be found\",\n    };\n  }\n\n  const fullUrl = `${realApiUrl}/function/${fnName}`;\n\n  try {\n    const abortController = new AbortController();\n    const id = setTimeout(\n      () => abortController.abort(),\n      config.timeout || 10000\n    );\n\n    const response = await fetch(fullUrl, {\n      method: \"POST\",\n      signal: config.timeout ? abortController.signal : undefined,\n      headers: {\n        Accept: \"application/json\",\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ authToken, parameters }),\n    })\n      .then((response) => response.json())\n      .then((response) => {\n        setItem(API_NO_RESPONSE_TIME_KEY, \"0\");\n\n        return response;\n      })\n      .catch((error) => {\n        console.log({\n          error,\n          errorStatus: error.status,\n          errorString: String(error),\n        });\n\n        setItem(API_NO_RESPONSE_TIME_KEY, String(Date.now()));\n        return {\n          isSuccessful: false,\n          isNotConnected: true,\n          message:\n            \"Your request could not be executed, you may be disconnected or the server may not be available. For more details, see the console.\",\n        };\n      });\n\n    clearTimeout(id);\n    return response;\n  } catch (e) {\n    setItem(API_NO_RESPONSE_TIME_KEY, String(Date.now()));\n\n    return {\n      isSuccessful: false,\n      isNotConnected: true,\n      message:\n        \"The API didn't resolve, and the fetch crashed because of it: \" +\n        String(e),\n    };\n  }\n}"
  },
  "apiStoreInitialValues": {
    "name": "apiStoreInitialValues",
    "slug": "TsVariable",
    "id": "ehkjwkkplllfhvsnwyqrsfma",
    "description": "",
    "operationName": "api-store"
  },
  "apiConventions": {
    "name": "apiConventions",
    "slug": "TsVariable",
    "id": "cezgrpqezotquubsqvqxxcur",
    "description": "API conventions:\n\n- `xyzGetApi` is only available via GET, the rest is only available with POST.\n- `xyzWithContext` is taking `FunctionContext` as its first parameter\n- `xyzWithContextRaw` is taking `FunctionContext` as its first parameter, and is expected to return the raw return type the function returns.",
    "operationName": "api-types"
  },
  "contextFunctionConventionSuffix": {
    "name": "contextFunctionConventionSuffix",
    "slug": "TsVariable",
    "id": "gekqafmwhphwaiexqiizqqer",
    "description": "",
    "operationName": "api-types"
  },
  "getFunctionConventionSuffix": {
    "name": "getFunctionConventionSuffix",
    "slug": "TsVariable",
    "id": "briyvasahubwnvjykaxtcegd",
    "description": "",
    "operationName": "api-types"
  },
  "rawFunctionConventionSuffix": {
    "name": "rawFunctionConventionSuffix",
    "slug": "TsVariable",
    "id": "qjvomkpwverjzjzlfrbiohyx",
    "description": "",
    "operationName": "api-types"
  },
  "makeArraysGetEndpoint": {
    "name": "makeArraysGetEndpoint",
    "slug": "TsFunction",
    "id": "zzstvtraveqdsvywqarumsrl",
    "description": "Far from ideal, but this wraps a function and sends the query parameters as arrays into it",
    "operationName": "endpoint-util",
    "rawText": " <\n  T extends { [key: string]: any } //string | number | null | boolean | undefined\n>(\n  fn: (query: T) => any\n) => {\n  return async (ctx: Context) => {\n    const arrayQuery = await objectMapSync(ctx.query, (key, value) =>\n      makeArray(value).map((x) => parsePrimitiveJson(x))\n    );\n    // NB: assuming here, that ctx.query contains the exact stuff that needs to be inserted into the function.\n    // @ts-ignore\n    return fn(arrayQuery);\n  };\n}"
  },
  "makeGetEndpoint": {
    "name": "makeGetEndpoint",
    "slug": "TsFunction",
    "id": "txhzuwzlwewiajoeemmnhqjz",
    "description": "takes any regular function with one input parameter which should be an object with only primitive things as values, and wraps that with the middleware so all query parameters are passed into that function\n\ncurrently oly the following primitives are supported\n- string\n- number\n- null\n- boolean\n- undefined",
    "operationName": "endpoint-util",
    "rawText": " <\n  T extends { [key: string]: any } //string | number | null | boolean | undefined\n>(\n  fn: (query: T) => any\n) => {\n  return (ctx: Context) => {\n    const safeQuery = objectMapSync(ctx.query, (key, value) =>\n      parsePrimitiveJson(takeFirst(value))\n    );\n    // NB: assuming here, that ctx.query contains the exact stuff that needs to be inserted into the function.\n    // @ts-ignore\n    return fn(safeQuery);\n  };\n}"
  },
  "comparePassword": {
    "name": "comparePassword",
    "slug": "TsFunction",
    "id": "umcpurkvszkqfmmcfdtvntjk",
    "description": "Method to check if a raw password should be the same as the encrypted variant. Uses `bcrypt`",
    "operationName": "encrypt-password",
    "rawText": " (\n  rawPassword: string,\n  encryptedPassword: string\n): boolean => {\n  return compareSync(rawPassword, encryptedPassword);\n}"
  },
  "executeCronFunction": {
    "name": "executeCronFunction",
    "slug": "TsFunction",
    "id": "ruqmmpvelcfvbythmvcmoxmc",
    "description": "NB: cron functions cannot have parameters",
    "operationName": "function-server",
    "rawText": " async (tsFunction: TsFunction) => {\n  if (\n    tsFunction.parameters &&\n    tsFunction.parameters.length > 0 &&\n    tsFunction.parameters.find((x) => x.required)\n  ) {\n    log(\"CRON Functions cannot have required parameters\", { type: \"error\" });\n    process.exit();\n  }\n\n  //@ts-ignore\n  sdk[tsFunction.name]?.();\n}"
  },
  "runFunctionServerCli": {
    "name": "runFunctionServerCli",
    "slug": "TsFunction",
    "id": "bwlhfpmblcqhdqgrzshbosdl",
    "description": "Argument:\n- pass true if you want the server to be watching\n- pass true true if you want the server to be watching and this is a restart (so don't launch things like browser)\n- if you pass nothing, there will be no browser start and no watcher",
    "operationName": "function-server",
    "rawText": " () => {\n  const [isWatchingString, isRestartString] = process.argv.slice(2);\n\n  runFunctionServer(\n    isWatchingString === \"true\" ? true : false,\n    isRestartString === \"true\" ? true : false\n  );\n}"
  },
  "runFunctionServerDevCli": {
    "name": "runFunctionServerDevCli",
    "slug": "TsFunction",
    "id": "bsrpfytarxqumlmhheqqmbnf",
    "description": "",
    "operationName": "function-server",
    "rawText": " () => {\n  runFunctionServerDev();\n}"
  },
  "runFunctionServerDev": {
    "name": "runFunctionServerDev",
    "slug": "TsFunction",
    "id": "hacrrfcrpcoxhupknbrcpvle",
    "description": "",
    "operationName": "function-server",
    "rawText": " () => {\n  nodemon({\n    operationName: \"function-server\",\n    cliFunctionName: \"runFunctionServer\",\n    vars: [\"true\", \"false\"],\n    restartVars: [\"true\", \"true\"],\n  });\n}"
  },
  "runFunctionServer": {
    "name": "runFunctionServer",
    "slug": "TsFunction",
    "id": "fqmaymvxqywlychndbydkgml",
    "description": "runs sdk api server using \"server\" package.\n\nserver will be exposed on port 42000",
    "operationName": "function-server",
    "rawText": " (\n  isWatching?: boolean,\n  isRestart?: boolean\n) => {\n  const { header } = server.reply;\n\n  startSearchWebIfAvailable(isWatching, isRestart);\n  const cors = [\n    /* \n     see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin\n    see https://stackoverflow.com/questions/18642828/origin-origin-is-not-allowed-by-access-control-allow-origin\n    NB: cannot set \"*\" i.c.m. cookies\n\n    a better way to allow multiple origins is probably something like this:\n\n      const allowedOrigins = ['http://127.0.0.1:8020', 'http://localhost:8020', 'http://127.0.0.1:9000', 'http://localhost:9000'];\n  const origin = req.headers.origin;\n  if (allowedOrigins.includes(origin)) {\n       res.setHeader('Access-Control-Allow-Origin', origin);\n  }\n  */\n\n    () => header(\"Access-Control-Allow-Origin\", \"*\"),\n    () =>\n      header(\n        \"Access-Control-Allow-Headers\",\n        \"Origin, X-Requested-With, Content-Type, Accept, Authorization, Set-Cookie\" // not sure if * can be put here after the others...\n      ),\n    () =>\n      header(\n        \"Access-Control-Allow-Methods\",\n        \"GET, PUT, PATCH, POST, DELETE, HEAD\"\n      ),\n\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials\n    // NB: important for cookies!\n    () => header(\"Access-Control-Allow-Credentials\", \"true\"),\n    (ctx: Context) => (ctx.method.toLowerCase() === \"options\" ? 200 : false),\n  ];\n\n  const port: number = process.env?.port\n    ? Number(process.env.port)\n    : ports[\"function-server\"];\n\n  const projectRoot = getProjectRoot();\n  const projectPublicFolder = projectRoot\n    ? path.join(projectRoot, \"public\")\n    : path.join(__dirname, \"..\", \"public\");\n\n  const serverOptions: Options = {\n    port,\n    public: projectPublicFolder,\n    security: { csrf: false },\n    parser: {\n      // NB: seems the server.js types are not 100% correct\n      data: { maxFileSize: 1024 * 1024 * 1024 * 32 } as any,\n      cookie: { maxAge: 900000, httpOnly: false },\n    },\n  };\n  // @ts-ignore\n  server(\n    serverOptions,\n    cors,\n    functionPostEndpoints,\n    functionGetEndpoints,\n\n    server.router.get(\"/\", () => \"Hello world, your Typerepo is running!\"),\n    server.router.get(\"*\", async (ctx) => {\n      return {\n        success: false,\n        message: \"Endpoint does not exist, are you sure it's a GET endpoint?\",\n      };\n    })\n  ).then(async (context) => {\n    if (\n      process.env.NODE_APP_INSTANCE === undefined ||\n      process.env.NODE_APP_INSTANCE === \"0\"\n    ) {\n      // only on the first core, schedule crons and initiate watchers\n      scheduleCronJobs();\n\n      if (isWatching) {\n        watchAll();\n      }\n    }\n\n    console.log(\n      `Typerepo is now running on port ${port}. Your node functions are now available through the \"api\" object!`\n    );\n  });\n}"
  },
  "scheduleCronJobs": {
    "name": "scheduleCronJobs",
    "slug": "TsFunction",
    "id": "nlqzuxzbwmiefcsonhqhllzj",
    "description": "",
    "operationName": "function-server",
    "rawText": " async () => {\n  const tsFunctions = await db.get(\"TsFunction\");\n\n  log(\"Scheduling CRON jobs\", { type: \"important\" });\n\n  getObjectKeysArray(scheduleObject).map((interval) => {\n    const cronExpression = scheduleObject[interval];\n    const functionsToExecute = tsFunctions.filter(\n      (x) => x.runEveryPeriod === interval\n    );\n    if (functionsToExecute.length > 0) {\n      console.log(\n        `- ${functionsToExecute.length} functions for ${interval} cron`\n      );\n      schedule(\n        cronExpression,\n        () => {\n          oneByOne(functionsToExecute, executeCronFunction);\n        },\n        { name: interval }\n      );\n    }\n  });\n}"
  },
  "scheduleObject": {
    "name": "scheduleObject",
    "slug": "TsVariable",
    "id": "sfvbdoxpkndudmjsvkyrfsiz",
    "description": "For every `RunEveryPeriodEnum`, this object provides the interval `cronExpression` string for `node-cron`",
    "operationName": "function-server"
  },
  "startSearchWebIfAvailable": {
    "name": "startSearchWebIfAvailable",
    "slug": "TsFunction",
    "id": "xrintxxkqwfcammpretqbaqs",
    "description": "",
    "operationName": "function-server",
    "rawText": " async (\n  isWatching?: boolean,\n  isRestart?: boolean\n) => {\n  const hasSearchWeb = !!operations[\"search-web\"];\n  if (!hasSearchWeb) {\n    return;\n  }\n\n  if (os.platform() === \"win32\") {\n    console.log(\"Not starting search-web on windows\");\n    return;\n  }\n\n  startApp(\"search-web\", true).then((result) => {\n    if (!result?.isSuccessful) {\n      console.log({ result });\n      log(\n        `Something went wrong starting \"search-web\". Maybe you don't have it?`,\n        { type: \"error\" }\n      );\n      return;\n    }\n\n    if (!isRestart && isWatching) {\n      // Open in browser\n      setTimeout(() => {\n        execSync(`open http://localhost:42001`);\n        log(`Opened the homepage in your browser`, { type: \"success\" });\n      }, 1000);\n    }\n  });\n}"
  },
  "calculateDeviceName": {
    "name": "calculateDeviceName",
    "slug": "TsFunction",
    "id": "yqakeappygjprkkszbizbojl",
    "description": "",
    "operationName": "function-server-endpoints",
    "rawText": " (\n  ipInfo: IPInfo,\n  userAgent: IResult\n): string => {\n  const deviceName: string = slugify(\n    `${userAgent.os.name}-${userAgent.browser.name}-${ipInfo.country}-${\n      ipInfo.region\n    }-${ipInfo.city}-${ipInfo.ip}-${generateRandomString(4)}`\n  );\n\n  return deviceName;\n}"
  },
  "executeFunctionWithParameters": {
    "name": "executeFunctionWithParameters",
    "slug": "TsFunction",
    "id": "odckhmqurxnrklvesmioltcj",
    "description": "steps for someone to use the API\n\n1) auth\n2) cache lookup\n3) input validation\n4) running function\n5) store cache\n6) store performance\n7) returning result\n\nTODO: make it possible to return result BEFORE storing cache and performance. we probably need to use the server.reply for this, which makes this function unusable in any other setting than an api, so let's make it optional",
    "operationName": "function-server-endpoints",
    "rawText": " async <\n  TFunctionName extends keyof typeof sdk\n>(\n  functionName: TFunctionName,\n  parameters: undefined | any[],\n  serverContext: Context\n): Promise<RealApiReturnType<any>> => {\n  const publicBundleConfig = await getPublicBundleConfig();\n  const executionId = generateId();\n\n  if (isGetEndpoint(functionName)) {\n    // NB: shortcut for now, until we have cookie support:\n\n    const result = await (sdk[functionName] as any)(serverContext);\n\n    return result;\n  }\n\n  const performance: (PerformanceItem | undefined)[] = [];\n\n  performance.push(getNewPerformance(\"start\", executionId, true));\n\n  // 1) upsert device\n  const device = await upsertDevice(serverContext);\n  if (!device) {\n    console.log(\"Couldn't create device\");\n    return {\n      isSuccessful: false,\n      message: \"Couldn't create device\",\n    };\n  }\n\n  performance.push(getNewPerformance(\"upsertDevice\", executionId));\n\n  // 2) get ts function\n  const tsFunction = await getTsFunction(functionName);\n  if (!tsFunction) {\n    return {\n      isSuccessful: false,\n      message: `TsFunction file could not be found in \"sdk-function-paths\" (${functionName}). Maybe you need to rebuild your operation and update your SDK?`,\n    };\n  }\n  performance.push(getNewPerformance(\"getTsFunction\", executionId));\n\n  // 4) cache lookup\n  const cacheLookupResult = cacheLookup(functionName, parameters);\n  if (cacheLookupResult.hasValidCache) {\n    return {\n      result: cacheLookupResult.result,\n      isSuccessful: true,\n      isCached: true,\n    };\n  }\n  performance.push(getNewPerformance(\"cacheLookup\", executionId));\n\n  // 5) validation\n  //@ts-ignore\n  const validationResult = validateInput(functionName, parameters, tsFunction);\n\n  // if (!validationResult.isValid) {\n  //   return {\n  //     isSuccessful: false,\n  //     errors: validationResult.errors,\n  //     message: `Your input has some errors. Input ${JSON.stringify(\n  //       parameters\n  //     )}.`,\n  //   };\n  // }\n  performance.push(getNewPerformance(\"inputValidation\", executionId));\n\n  // 6) running function\n  const fn = sdk[functionName];\n\n  if (typeof fn !== \"function\") {\n    return {\n      isSuccessful: false,\n      message: `Function not found in the api-sdk: ${functionName}`,\n    };\n  }\n\n  const { hasAuthorization, authorizations, groups } = getAuthorizationInfo(\n    device,\n    tsFunction,\n    fn\n  );\n\n  if (publicBundleConfig?.slug !== \"passionfruit\" && !hasAuthorization) {\n    return {\n      isSuccessful: false,\n      isUnauthorized: true,\n      message:\n        \"You are not authorized to execute this function, you might need to login.\",\n    };\n  }\n\n  // 3) auth\n  // OLD simple way (passionfruit-only, to be deprecated once admin signup works good enough)\n  const authToken: string | undefined = serverContext.data?.authToken;\n  if (\n    publicBundleConfig?.slug === \"passionfruit\" &&\n    privateAuthToken !== authToken\n  ) {\n    return {\n      isSuccessful: false,\n      isUnauthorized: true,\n      message:\n        \"You are not authorized to execute this function, you might need to login.\",\n    };\n  }\n\n  performance.push(getNewPerformance(\"auth\", executionId));\n\n  /**\n   * Convention\n   */\n\n  const needsReturnRaw =\n    functionName.endsWith(apiConventions.rawFunctionConventionSuffix) ||\n    functionName.endsWith(apiConventions.getFunctionConventionSuffix);\n\n  const needsFunctionContext =\n    functionName.endsWith(apiConventions.contextFunctionConventionSuffix) ||\n    needsReturnRaw;\n\n  const functionContext: FunctionContext = {\n    tsFunction,\n    authorizations,\n    device,\n    groups,\n    hasAuthorization,\n    authToken: device.authToken,\n    serverContext,\n  };\n\n  const parametersWithContext = needsFunctionContext\n    ? [functionContext].concat(parameters || [])\n    : parameters;\n\n  // console.log(`We are authorized to execute ${functionName}! Let's do it`);\n  // @ts-ignore\n  const result = await fn(...parametersWithContext);\n  performance.push(getNewPerformance(\"function\", executionId));\n\n  cleanupTimer(executionId);\n\n  //@ts-ignore\n  const resultValidation = validateResult(functionName, result, tsFunction);\n\n  // console.log({ serverwithPar: performance });\n  // 6) store performance\n  storeFunctionExecution(\n    tsFunction,\n    parameters,\n    result,\n    performance.filter(notEmpty),\n    false\n  );\n\n  // need to return this immediately without the surrounding object, because it might do stuff with that server context that needs to be returned\n  if (needsReturnRaw) return result;\n\n  if (result === undefined) {\n    return {\n      isSuccessful: true,\n      isCached: false,\n      message: \"Function was executed but did not give any response\",\n      result: undefined,\n    };\n  }\n\n  return {\n    isSuccessful: true,\n    isCached: false,\n    result,\n  };\n}"
  },
  "functionGetEndpoints": {
    "name": "functionGetEndpoints",
    "slug": "TsVariable",
    "id": "vucldythityfhmvtannuxlyk",
    "description": "routes to post and execute operation functions",
    "operationName": "function-server-endpoints"
  },
  "functionPostEndpoints": {
    "name": "functionPostEndpoints",
    "slug": "TsVariable",
    "id": "ogxkuspwqofdklaurvfpnwpw",
    "description": "routes to post and execute operation functions",
    "operationName": "function-server-endpoints"
  },
  "getAuthorizationInfo": {
    "name": "getAuthorizationInfo",
    "slug": "TsFunction",
    "id": "jlqdoypckmgbvoxezabhaqde",
    "description": "returns `AuthorizationInfo` for a device + function",
    "operationName": "function-server-endpoints",
    "rawText": " (\n  device: Storing<Device>,\n  tsFunction: TsFunction,\n  fn: { (...parameters: any): any; [key: string]: any }\n): AuthorizationInfo => {\n  const everyPersonsGroups =\n    device?.persons\n      ?.map((x) => x.groups)\n      .flat()\n      .filter(notEmpty)\n      .filter(onlyUnique2<Group>((a, b) => a.slug === b.slug)) || [];\n\n  const everyPersonsAuthorizations =\n    device?.persons?.map((x) => x.authorizations).flat() || [];\n\n  const customGroupAuthorizations = everyPersonsGroups\n    .map((group) => group.customAuthorizations)\n    .flat();\n\n  // Accumulating all authorizations: the public authorization of the function, the manual person authorizations, and the group authorizations\n  const authorizations: Authorization[] = [\n    ...everyPersonsAuthorizations,\n    ...customGroupAuthorizations,\n  ].filter(notEmpty);\n\n  const hasAuthorization = !!authorizations.find((auth) => {\n    const authAppliesToThisFunction =\n      auth.tsFunctionId === tsFunction.id ||\n      auth.authorizedOperationName === tsFunction?.operationName ||\n      (auth.authorizedProjectRelativePath &&\n        tsFunction.projectRelativePath.startsWith(\n          auth.authorizedProjectRelativePath\n        ));\n\n    return authAppliesToThisFunction && auth.canExecute;\n  });\n\n  /**\n   * Function might ne an `ApiFunction`\n   */\n  const isPublic = fn.isPublic;\n\n  return {\n    hasAuthorization: isPublic || hasAuthorization,\n    authorizations,\n    groups: everyPersonsGroups,\n  };\n}"
  },
  "isGetEndpoint": {
    "name": "isGetEndpoint",
    "slug": "TsFunction",
    "id": "hksvzkzufyeubxyqwuhkxrrp",
    "description": "",
    "operationName": "function-server-endpoints",
    "rawText": " (functionName: string) => {\n  return functionName.endsWith(apiConventions.getFunctionConventionSuffix);\n}"
  },
  "privateAuthToken": {
    "name": "privateAuthToken",
    "slug": "TsVariable",
    "id": "igxupedlpbweyqqmvzanuvbl",
    "description": "",
    "operationName": "function-server-endpoints"
  },
  "savePageVisit": {
    "name": "savePageVisit",
    "slug": "TsFunction",
    "id": "xtzbxfedqsmxkyjkwhicilhi",
    "description": "",
    "operationName": "function-server-endpoints",
    "rawText": " async (\n  deviceId: Id,\n  ipInfo: IPInfo,\n  referer: string\n) => {\n  const pageVisit: Creation<PageVisit> = { ipInfo, path: referer, deviceId };\n\n  await db.upsert(\"PageVisit\", pageVisit, { onlyInsert: true });\n}"
  },
  "storeFunctionExecution": {
    "name": "storeFunctionExecution",
    "slug": "TsFunction",
    "id": "oxvarmgtklndqgxnenmojiwh",
    "description": "wrapper function that stores execution-speed in an object with `FunctionPerformance` data-structure. Store this using `db.push` if it adds value\n.",
    "operationName": "function-server-endpoints",
    "rawText": " async (\n  tsFunction: TsFunction,\n  inputParameters: any[] | undefined,\n  output: any,\n  performance: PerformanceItem[],\n  isResultFromCache: boolean\n) => {\n  // TODO: store using db (if useful)\n\n  const functionExecution: Creation<FunctionExecution> = {\n    functionName: tsFunction.name,\n    tsFunctionId: tsFunction.id,\n    inputParameters,\n    isExample: false,\n    isTest: false,\n    isResultFromCache,\n    output,\n    performance,\n  };\n\n  //@ts-ignore\n  const result = await db.upsert(\"FunctionExecution\", functionExecution, {\n    onlyInsert: true,\n    operationName: tsFunction.operationName,\n  });\n  return;\n}"
  },
  "upsertDevice": {
    "name": "upsertDevice",
    "slug": "TsFunction",
    "id": "gqfrqfiubsagqukfcnvtpjxu",
    "description": "Returns device with all attached (logged in) `Person`s, and `currentPersonCalculated`\n\nEither finds the device and updates it according to the new request metadata, or creates a new device.\n\nShould never return `undefined` if the database functions...\n\nTODO: Use cookies (https://serverjs.io/documentation/reply/#cookie-) to login\n\nNeeded for having `authToken` with GET as well in a safe manner (e.g. for images)",
    "operationName": "function-server-endpoints",
    "rawText": " async (\n  serverContext: Context\n): Promise<Storing<Device> | undefined> => {\n  // in your function\n  const executionId = generateUniqueId();\n  const performance: (PerformanceItem | undefined)[] = [];\n\n  performance.push(getNewPerformance(\"start\", executionId, true));\n\n  const authToken: string | undefined = serverContext.data?.authToken;\n  const ip = serverContext.ip;\n\n  if (!authToken || authToken.length < 24) {\n    console.log(\"warn upsert device: no authToken\");\n    return;\n  }\n\n  // NB: range: [ <low bound of IP block>, <high bound of IP block> ], the rest is described in the type interface\n  const ipLookup = (geoip.lookup(ip) || {}) as Partial<geoip.Lookup>;\n  const {\n    city,\n    area: positionRadiusKm,\n    ll,\n    country,\n    region,\n    timezone,\n  } = ipLookup;\n\n  const position: Position | undefined =\n    !!ll?.[0] && !!ll?.[1] ? { latitude: ll[0], longitude: ll[1] } : undefined;\n\n  const userAgentString = serverContext.req.get(\"User-Agent\");\n  const userAgent: IResult = parseUserAgent(userAgentString);\n\n  const ipInfo: IPInfo = {\n    ip,\n    city,\n    position,\n    positionRadiusKm,\n    country,\n    region,\n    timezone,\n  };\n\n  const origin = serverContext.req.get(\"Origin\") as string;\n  const referer = serverContext.req.get(\"Referrer\") as string;\n\n  const dbPath = getRootPath(\"db\");\n  if (!dbPath) return;\n  const deviceFilePath = path.join(dbPath, \"devices\", `${authToken}.json`);\n\n  const exists = fs.existsSync(deviceFilePath);\n\n  const deviceBefore: Storing<Device> | null = exists\n    ? await readJsonFile<Storing<Device>>(deviceFilePath)\n    : null;\n\n  const newDevice = !exists\n    ? {\n        authToken,\n        authenticationMethods: [],\n        ...ipInfo,\n        createdAt: Date.now(),\n        createdFirstAt: Date.now(),\n        deletedAt: 0,\n        id: authToken,\n        lastOnlineAt: Date.now(),\n        name: authToken,\n        updatedAt: Date.now(),\n        userAgentString: userAgentString || \"no useragent\",\n      }\n    : null;\n\n  if (newDevice) {\n    await writeJsonToFile(deviceFilePath, newDevice);\n  }\n\n  savePageVisit(authToken, ipInfo, referer);\n\n  // attach persons and groups\n  const groups = await db.get(\"Group\");\n  const persons = (await db.get(\"Person\"))\n    .filter((x) => deviceBefore?.personIds?.includes(x.id))\n    .map((p) => {\n      return {\n        ...p,\n        groups: groups.filter((g) => p.groupSlugs?.includes(g.slug)),\n      };\n    });\n\n  const augmentedDevice: Storing<Device> = deviceBefore\n    ? { ...deviceBefore, persons }\n    : newDevice!;\n\n  // console.dir({ augmentedDevice }, { depth: 999 });\n  return augmentedDevice;\n}"
  },
  "apiUrl": {
    "name": "apiUrl",
    "slug": "TsVariable",
    "id": "glbuxovrxcthpijcjggrtkuj",
    "description": "",
    "operationName": "server-api-url"
  },
  "customApiUrl": {
    "name": "customApiUrl",
    "slug": "TsVariable",
    "id": "riozyfswwuzwjtintkrvvmle",
    "description": "",
    "operationName": "server-api-url"
  },
  "hostname": {
    "name": "hostname",
    "slug": "TsVariable",
    "id": "dhzicmfwuppptzuwybtzwlwi",
    "description": "",
    "operationName": "server-api-url"
  },
  "isDev": {
    "name": "isDev",
    "slug": "TsVariable",
    "id": "jhrukevszpqbimhnlgvuwhzf",
    "description": "",
    "operationName": "server-api-url"
  },
  "localhostServer": {
    "name": "localhostServer",
    "slug": "TsVariable",
    "id": "mrpsmuahorecpgnkpzqgdosd",
    "description": "",
    "operationName": "server-api-url"
  },
  "realCustomApiUrl": {
    "name": "realCustomApiUrl",
    "slug": "TsVariable",
    "id": "tdhlmjomkxrwwyfhidnpjzzi",
    "description": "",
    "operationName": "server-api-url"
  },
  "remoteServer": {
    "name": "remoteServer",
    "slug": "TsVariable",
    "id": "lhnbiltolfixiieshvgqeagt",
    "description": "NEEDED FOR MULTI DEPLOYMENTS (passionfruit)",
    "operationName": "server-api-url"
  },
  "runRemoteServer": {
    "name": "runRemoteServer",
    "slug": "TsVariable",
    "id": "ziazqduznhbmighwpxzrlaec",
    "description": "",
    "operationName": "server-api-url"
  },
  "addAuthenticationMethod": {
    "name": "addAuthenticationMethod",
    "slug": "TsFunction",
    "id": "gwbdgzicjbkxwxbpxekrwkga",
    "description": "sends an email or sms, or already confirms in case of emailPassword\n\ncore function for `addPersonAuthenticationMethod` and `addDeviceAuthenticatedMethod`",
    "operationName": "server-login",
    "rawText": " async (\n  method: AuthenticationMethodMethod,\n  handle: string,\n  /**\n   * TODO: check if it's unique before sending an email.\n   * This is needed in case you are a person trying to add a method, because then there might be another person with the same handle.\n   */\n  shouldBeUnique?: boolean,\n  credential?: string\n): Promise<{\n  isSuccessful: boolean;\n  message: string;\n  authenticationMethod?: AuthenticationMethod;\n}> => {\n  if (method === \"email\") {\n    // send email to `handle`\n\n    if (!isEmail(handle)) {\n      return {\n        isSuccessful: false,\n        message: \"Please provide a correct email\",\n      };\n    }\n\n    if (shouldBeUnique) {\n      const isAuthenticationMethodUnavaiable =\n        await findAuthenticatedPersonWithHandle(method, handle);\n      if (isAuthenticationMethodUnavaiable) {\n        console.log({ isAuthenticationMethodUnavaiable });\n        return {\n          isSuccessful: false,\n          message: \"That email is already taken\",\n        };\n      }\n    }\n\n    const otp = Math.round(100000 + Math.random() * 900000);\n\n    const text = `Please verify your email with this code: ${otp}. You have 10 minutes.`;\n\n    const authenticationMethod: AuthenticationMethod = {\n      method: \"email\",\n      handle,\n      isAuthenticated: false,\n      otp,\n    };\n\n    const mailResult = await sendMail({\n      to: handle,\n      subject: \"Verify your email\",\n      text,\n    });\n\n    if (!mailResult) {\n      return { isSuccessful: false, message: \"Couldn't send email\" };\n    }\n\n    return {\n      isSuccessful: true,\n      message: \"Code sent, please verify.\",\n      authenticationMethod,\n    };\n  }\n\n  if (method === \"phoneNumber\") {\n    // send sms to `handle`\n\n    if (!isPhoneNumber(handle)) {\n      return {\n        isSuccessful: false,\n        message: \"Please provide a correct phone number\",\n      };\n    }\n\n    if (shouldBeUnique) {\n      const isAuthenticationMethodUnavaiablePerson =\n        await findAuthenticatedPersonWithHandle(method, handle);\n      if (isAuthenticationMethodUnavaiablePerson) {\n        console.log({ isAuthenticationMethodUnavaiablePerson });\n        return {\n          isSuccessful: false,\n          message: \"That phone number is already taken\",\n        };\n      }\n    }\n\n    const otp = Math.round(100000 + Math.random() * 900000);\n    const body = `Please verify your phone number with this code: ${otp}. You have 10 minutes.`;\n\n    const authenticationMethod: AuthenticationMethod = {\n      method: \"phoneNumber\",\n      handle,\n      isAuthenticated: false,\n      otp,\n    };\n\n    const smsResult = await sendSms({ to: handle, body });\n\n    if (!smsResult) {\n      return { isSuccessful: false, message: \"Couldn't send sms\" };\n    }\n\n    return {\n      isSuccessful: true,\n      message: \"Code sent, please verify.\",\n      authenticationMethod,\n    };\n  }\n\n  if (method === \"usernamePassword\") {\n    // add username and password to the authenticated methods\n\n    if (!credential || !isValidPassword(credential)) {\n      return {\n        isSuccessful: false,\n        message: \"Please provide a valid password\",\n      };\n    }\n\n    const encryptedCredential = encryptPassword(credential);\n\n    const authenticationMethod: AuthenticationMethod = {\n      method: \"usernamePassword\",\n      handle,\n      encryptedCredential,\n      credential,\n      isAuthenticated: true,\n    };\n\n    return {\n      isSuccessful: true,\n      message: \"Username/password has been set.\",\n      authenticationMethod,\n    };\n  }\n\n  return { isSuccessful: false, message: \"method not implemented yet\" };\n}"
  },
  "addDeviceAuthenticationMethodConfirm": {
    "name": "addDeviceAuthenticationMethodConfirm",
    "slug": "TsFunction",
    "id": "xcddtkebfwlbziygdtsemdgf",
    "description": "adds an `authenticatedMethod` to `Device` after the OTP is correct\n\nFor now, only handles methods `phoneNumber` and `email`\n\nTODO: extrahere the core into `addAuthenticationMethodConfirm` and use it in this one and make also `addPersonAuthenticationMethodConfirm`",
    "operationName": "server-login",
    "rawText": " async (\n  /** device id */\n  deviceId: string,\n  method: AuthenticationMethodMethod,\n  /** one time password */\n  otp: number\n) => {\n  /////\n\n  const device = (await db.get(\"Device\")).find((x) => x.id === deviceId);\n\n  if (!device) {\n    return { isSuccessful: false, message: \"Couldn't find device\" };\n  }\n\n  const authenticatedMethod = device.authenticationMethods.find(\n    (m) => m.method === method\n  );\n\n  if (authenticatedMethod?.isAuthenticated) {\n    return {\n      isSuccessful: false,\n      message:\n        \"You already authenticated with this method, please delete it first before you add another one.\",\n    };\n  }\n\n  if (!authenticatedMethod) {\n    return { isSuccessful: false, message: \"Can't find method\" };\n  }\n\n  if ([\"email\", \"phoneNumber\"].includes(method)) {\n    const isSuccessful = otp === authenticatedMethod.otp;\n\n    if (isSuccessful) {\n      // add isAuthenticated to device's authenticationMethods\n\n      const newAuthenticatedMethod: AuthenticationMethod = {\n        ...authenticatedMethod,\n        otp: undefined,\n        isAuthenticated: true,\n      };\n\n      const newauthenticationMethods = device.authenticationMethods.map((x) =>\n        x.method === method && x.otp === otp ? newAuthenticatedMethod : x\n      );\n\n      const dbPath = getRootPath(\"db\")!;\n      const devicePath = path.join(dbPath, \"devices\", `${deviceId}.json`);\n\n      writeJsonToFile(devicePath, {\n        ...device,\n        authenticationMethods: newauthenticationMethods,\n      });\n    }\n    return {\n      isSuccessful,\n      message: isSuccessful ? \"Successful\" : \"Incorrect code\",\n    };\n  }\n}"
  },
  "addDeviceAuthenticationMethodWithContext": {
    "name": "addDeviceAuthenticationMethodWithContext",
    "slug": "TsFunction",
    "id": "qxubmphvtuaifgpjmemmkutq",
    "description": "returns new function context with added authenticationmethod",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext,\n  method: AuthenticationMethodMethod,\n  handle: string,\n  credential?: string\n): Promise<{\n  isSuccessful?: boolean;\n  message?: string;\n  functionContext?: FunctionContext;\n  authenticationMethod?: AuthenticationMethod;\n}> => {\n  const { isSuccessful, message, authenticationMethod } =\n    await addAuthenticationMethod(method, handle, false, credential);\n  if (!isSuccessful || !authenticationMethod) {\n    return { isSuccessful, message };\n  }\n  // removes this method if you was alrady trying the same method (basically overwrite)\n  const cleanAuthenticationMethods =\n    functionContext.device.authenticationMethods?.filter(\n      (x) => x.method !== authenticationMethod.method\n    ) || [];\n\n  // then adds the new one\n  const newAuthenticationMethods =\n    cleanAuthenticationMethods.concat(authenticationMethod);\n\n  const updateResult = await db.update(\n    \"Device\",\n    (item) => item.authToken === functionContext.authToken,\n    (old) => {\n      return {\n        ...old,\n        authenticationMethods: newAuthenticationMethods,\n      };\n    }\n  );\n\n  const newFunctionContext = mergeNestedObject(functionContext, {\n    device: {\n      authenticationMethods: newAuthenticationMethods,\n    },\n  });\n\n  return {\n    isSuccessful: updateResult.isSuccesful,\n    message: \"Method added\",\n    functionContext: newFunctionContext,\n    authenticationMethod,\n  };\n}"
  },
  "addPersonAuthenticationMethodWithContext": {
    "name": "addPersonAuthenticationMethodWithContext",
    "slug": "TsFunction",
    "id": "ucoiycyyclbeflbgitlswzfk",
    "description": "",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext,\n  method: AuthenticationMethodMethod,\n  handle: AuthenticationMethod[\"handle\"],\n  credential?: string\n) => {\n  const { isSuccessful, message, authenticationMethod } =\n    await addAuthenticationMethod(method, handle, true, credential);\n\n  if (!isSuccessful || !authenticationMethod) {\n    return { isSuccessful, message };\n  }\n\n  const updateResult = await db.update(\n    \"Person\",\n    (item) => item.id === functionContext.device.currentPersonId,\n    (old) => ({\n      ...old,\n      authenticationMethods:\n        old.authenticationMethods.concat(authenticationMethod),\n    })\n  );\n\n  return { isSuccessful: updateResult.isSuccesful, message };\n}"
  },
  "findAuthenticatedPersonWithHandle": {
    "name": "findAuthenticatedPersonWithHandle",
    "slug": "TsFunction",
    "id": "iyyfisbdpapehnigkacncnsc",
    "description": "Check if the handle is already taken by some person in the system",
    "operationName": "server-login",
    "rawText": " async (\n  method: AuthenticationMethodMethod,\n  handle: string\n) => {\n  const persons = await db.get(\"Person\");\n  const alreadyPerson = persons.find((person) => {\n    const matchingAuthMethod = person.authenticationMethods.find(\n      (authMethod) =>\n        authMethod.method === method &&\n        authMethod.isAuthenticated &&\n        authMethod.handle === handle\n    );\n\n    return !!matchingAuthMethod;\n  });\n  return alreadyPerson;\n}"
  },
  "findLoggedinPersonsWithContext": {
    "name": "findLoggedinPersonsWithContext",
    "slug": "TsFunction",
    "id": "tmvpukwoebzwarmtrmweascw",
    "description": "This finds all persons you should be logged in as according to all your device's Authentication Methods.\n\nDoes not update your device to add the found persons.",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext\n): Promise<{\n  isSuccessful: boolean;\n  persons?: Person[];\n  message: string;\n}> => {\n  const { device } = functionContext;\n\n  if (!device) {\n    return {\n      isSuccessful: false,\n      message: \"Couldn't find that device\",\n    };\n  }\n\n  const allPersons = await db.get(\"Person\");\n\n  // NB: probably need to extrahere this part so I can use it to view the authentication status while logging in...\n\n  const persons = allPersons.filter((person) => {\n    const matchingMethods = person.authenticationMethods.filter(\n      (authenticationMethod) => {\n        // NB: finds the method with the same handle and credential\n        const matchingMethod = device.authenticationMethods.find((method) => {\n          const sameMethod = method.method === authenticationMethod.method;\n\n          const sameHandle =\n            method.handle.toLowerCase() ===\n            authenticationMethod.handle.toLowerCase();\n\n          const isCredentialCorrect =\n            method.credential &&\n            authenticationMethod.encryptedCredential &&\n            comparePassword(\n              method.credential,\n              authenticationMethod.encryptedCredential\n            );\n\n          return sameMethod && sameHandle && isCredentialCorrect;\n        });\n\n        return !!matchingMethod;\n      }\n    );\n\n    const hasEnoughMethods =\n      (person.amountAuthenticationMethodsRequired || 1) <=\n      matchingMethods.length;\n\n    const hasMissingMethod = !!person.requiredAuthenticationMethods?.find(\n      (method) => {\n        const isMethodMissing = !device.authenticationMethods.find(\n          (x) => x.method === method\n        );\n        return isMethodMissing;\n      }\n    );\n\n    if (hasEnoughMethods && !hasMissingMethod) {\n      // if you have authenticated with enough methods, and aren't missing a method\n      return true;\n    }\n\n    return false;\n  });\n\n  if (!persons || persons.length === 0) {\n    console.log({ methods: device.authenticationMethods });\n    return {\n      isSuccessful: false,\n      message: \"Couldn't find anyone with those credentials\",\n    };\n  }\n\n  return { isSuccessful: true, persons, message: \"Found the persons\" };\n}"
  },
  "getMeWithContext": {
    "name": "getMeWithContext",
    "slug": "TsFunction",
    "id": "ynrvsgyuippssjhumgtuipnm",
    "description": "Get all relevant information about yourself, including all persons that are attached to you.\n\nNB: probably need to omit some fields later, but for now it's fine",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext\n): Promise<{\n  authorizations?: Authorization[] | undefined;\n  device: Storing<Device>;\n  groups?: Group[] | undefined;\n}> => {\n  const {\n    tsFunction,\n    serverContext,\n    hasAuthorization,\n    authToken,\n    ...userInfo\n  } = functionContext;\n\n  return userInfo;\n}"
  },
  "getPublicPerson": {
    "name": "getPublicPerson",
    "slug": "TsFunction",
    "id": "yyiviufkqqbkejrgxffhhlhu",
    "description": "",
    "operationName": "server-login",
    "rawText": " async (id?: string) => {\n  return (await getPublicPersons()).find((x) => x.id === id);\n}"
  },
  "getPublicPersons": {
    "name": "getPublicPersons",
    "slug": "TsFunction",
    "id": "rquidhclljrobxbximicyawt",
    "description": "",
    "operationName": "server-login",
    "rawText": " async () => {\n  const publicPersons = (await db.get(\"Person\")).map(\n    (item) => getSubsetFromObject(item, publicPersonKeys) as PublicPerson\n  );\n  return publicPersons;\n}"
  },
  "isPhoneNumber": {
    "name": "isPhoneNumber",
    "slug": "TsFunction",
    "id": "muhygqrmebyetfrmbxxipmlz",
    "description": "TODO: Implement this",
    "operationName": "server-login",
    "rawText": " (phoneNumber: string): boolean => {\n  return true;\n}"
  },
  "isValidPassword": {
    "name": "isValidPassword",
    "slug": "TsFunction",
    "id": "stnvzqcsynhwshajedahftfe",
    "description": "",
    "operationName": "server-login",
    "rawText": " (password: string): boolean => {\n  return password.length >= 6;\n}"
  },
  "loginWithContext": {
    "name": "loginWithContext",
    "slug": "TsFunction",
    "id": "itibhxstaahdhrpxhbcaudut",
    "description": "attaches the `Device` with `authToken` to a `Person` once all required authenticationMethods are provided. If not, it needs to return the required authenticationMethods so the user can attach those to the device until loggin is successful.",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext\n): Promise<{ isSuccessful: boolean; message: string }> => {\n  const { device } = functionContext;\n\n  const findPersonsResult = await findLoggedinPersonsWithContext(\n    functionContext\n  );\n\n  if (!findPersonsResult.isSuccessful) {\n    return {\n      isSuccessful: findPersonsResult.isSuccessful,\n      message: findPersonsResult.message,\n    };\n  }\n\n  const personIds = findPersonsResult.persons?.map((x) => x.id);\n\n  const updateResult = await db.update(\n    \"Device\",\n    (item) => item.id === device.id,\n    (old) => ({\n      ...old,\n      personIds,\n      authenticationMethods: [],\n      currentPersonId: personIds?.[0],\n    })\n  );\n\n  const isSuccessful = updateResult.isSuccesful || false;\n\n  return {\n    isSuccessful,\n    message: isSuccessful\n      ? \"Logged in\"\n      : updateResult.message || \"Something went wrong (weird)\",\n  };\n}"
  },
  "loginWithPasswordWithContext": {
    "name": "loginWithPasswordWithContext",
    "slug": "TsFunction",
    "id": "lbpwohgxtolqhlzcxcylsmac",
    "description": "Login with username and password\n\n1. Adds an username/password combo as auth-method to the device,\n2. Checks the persons to match the auth\n3. In case of match, moves the method to the person and connects the device",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext,\n  username: string,\n  password: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  // first we have to add the authenticationMethod to the device\n  const addAuthResult = await addDeviceAuthenticationMethodWithContext(\n    functionContext,\n    \"usernamePassword\",\n    username,\n    password\n  );\n\n  if (\n    !addAuthResult.isSuccessful ||\n    !addAuthResult.authenticationMethod ||\n    !addAuthResult.functionContext\n  ) {\n    return {\n      isSuccessful: addAuthResult.isSuccessful || false,\n      message: addAuthResult.message,\n    };\n  }\n\n  // now it should be possible to connect the auth method to the device\n  const loginResult = await loginWithContext(addAuthResult.functionContext);\n  const { isSuccessful, message } = loginResult;\n  return {\n    isSuccessful,\n    message,\n  };\n}"
  },
  "logoutWithContext": {
    "name": "logoutWithContext",
    "slug": "TsFunction",
    "id": "dcdetiderpazefernfrdifev",
    "description": "Uses cookies (https://serverjs.io/documentation/reply/#cookie-) to logout\n\nNeeded for having `authToken` with GET as well in a safe manner (e.g. for images)",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext,\n  rememberAuthentication?: boolean\n) => {\n  const { device } = functionContext;\n\n  if (!device.personIds || !device.currentPersonId) {\n    return { isSuccessful: false, message: \"You were already logged out\" };\n  }\n\n  const personAuthenticationMethods =\n    device.currentPersonCalculated?.authenticationMethods || [];\n\n  const newPersonIds = device.personIds.filter(\n    (id) => id !== device.currentPersonId\n  );\n\n  if (newPersonIds.length === device.personIds.length) {\n    return {\n      isSuccessful: false,\n      message: \"Nobody logged out, this is strange...\",\n    };\n  }\n\n  // remove the person from the device, optionally moving the auth on the device again, so you can easily login again.\n\n  const updateResult = await db.update(\n    \"Device\",\n    (item) => item.id === device.id,\n    (old) => {\n      const newAuthenticationMethods = rememberAuthentication\n        ? old.authenticationMethods.concat(personAuthenticationMethods)\n        : old.authenticationMethods;\n      return {\n        ...old,\n        personIds: newPersonIds,\n        currentPersonId: newPersonIds[newPersonIds.length - 1],\n        authenticationMethods: newAuthenticationMethods,\n      };\n    }\n  );\n\n  const isSuccessful =\n    !!updateResult.isSuccesful && updateResult.amountUpdated === 1;\n\n  return {\n    isSuccessful,\n    message: isSuccessful\n      ? \"Logged out\"\n      : updateResult.message ||\n        \"Something went wrong (No updateResult message)\",\n  };\n}"
  },
  "removeDeviceAuthenticationMethodWithContext": {
    "name": "removeDeviceAuthenticationMethodWithContext",
    "slug": "TsFunction",
    "id": "wvroedurnjpcypslxcndwxlb",
    "description": "removes an `authenticatedMethod` from `Device`\n\nUsually the authentication methods are an attempt to login into a new account, so if you remove something it doesnt have impact on the accounts you already logged into, because these authentications are not stored on the device but on the person.\n\nWe can therefore remove it without much validation",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext,\n  method: AuthenticationMethodMethod\n) => {\n  const newAuthenticationMethods =\n    functionContext.device.authenticationMethods.filter(\n      (x) => x.method !== method\n    );\n\n  const updateResult = await db.update(\n    \"Device\",\n    (item) => item.authToken === functionContext.authToken,\n    (old) => ({ ...old, authenticationMethods: newAuthenticationMethods })\n  );\n\n  return {\n    isSuccessful: updateResult.isSuccesful,\n    message: updateResult.isSuccesful ? \"Removed\" : updateResult.message,\n  };\n}"
  },
  "removePersonAuthenticationMethodWithContext": {
    "name": "removePersonAuthenticationMethodWithContext",
    "slug": "TsFunction",
    "id": "agoaxolrewwxkyeiwmxshcwa",
    "description": "removes an `authenticationMethod` from `Person` from currentPerson from authenticated device",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext,\n  method: AuthenticationMethodMethod\n) => {\n  if (\n    !functionContext.device.currentPersonId ||\n    !functionContext.device.persons\n  ) {\n    return {\n      isSuccessful: false,\n      message: \"Not logged in\",\n    };\n  }\n\n  const person = functionContext.device.persons.find(\n    (x) => x.id === functionContext.device.currentPersonId\n  );\n\n  if (!person) {\n    return {\n      isSuccessful: false,\n      message: \"Not logged in\",\n    };\n  }\n\n  const authenticationMethod = person.authenticationMethods.find(\n    (x) => x.method === method\n  );\n\n  if (!authenticationMethod) {\n    return { isSuccessful: false, message: \"You didn't add that method yet\" };\n  }\n\n  const newAuthenticationMethods = person.authenticationMethods.filter(\n    (x) => x.method !== method\n  );\n\n  const updateResult = await db.update(\n    \"Person\",\n    (item) => item.id === functionContext.device.currentPersonId,\n    (old) => ({ ...old, authenticationMethods: newAuthenticationMethods })\n  );\n\n  return {\n    isSuccessful: updateResult.isSuccesful,\n    message: updateResult.isSuccesful ? \"Removed\" : updateResult.message,\n  };\n}"
  },
  "signupWithContext": {
    "name": "signupWithContext",
    "slug": "TsFunction",
    "id": "ircqgfufdjiiqjbqiolnanei",
    "description": "Creates a new `Person` for a `Device`. Adds that person to the `Device`.\n\n- Can only be done with at least one authenticationMethod\n- Can only be done if authentication is not applied on an existing person already.\n- Function is wrappable",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext,\n  /**\n   * Data required for creating a `Person`. Can be filled in by the user partly, but also partly automatically\n   */\n  personData: SignupPersonData\n): Promise<{ isSuccessful: boolean; message: string }> => {\n  const { device } = functionContext;\n\n  console.log(`Signup with context`);\n  if (\n    device.authenticationMethods.filter((x) => x.isAuthenticated).length === 0\n  ) {\n    return { isSuccessful: false, message: \"Please authenticate first\" };\n  }\n\n  const methodsAugmented = await Promise.all(\n    device.authenticationMethods.map(async (method) => {\n      const alreadyPerson = await findAuthenticatedPersonWithHandle(\n        method.method,\n        method.handle\n      );\n\n      return { ...method, alreadyPerson };\n    })\n  );\n\n  const unavailableMethod = methodsAugmented.find(\n    (method) => method.alreadyPerson\n  );\n\n  if (unavailableMethod) {\n    const methodString = englishMethod[unavailableMethod.method].toLowerCase();\n    return {\n      isSuccessful: false,\n      message: `There is already someone else with the ${methodString} ${unavailableMethod.handle}`,\n    };\n  }\n\n  // it seesms fine , lets' create a new person\n\n  const newPersonId = generateId();\n  const newPerson: Creation<Person> = {\n    id: newPersonId,\n    authenticationMethods: device.authenticationMethods.map(\n      // remove the credential\n      ({ credential, ...other }) => other\n    ),\n    ...personData,\n  };\n\n  //@ts-ignore\n  const upsertResult = await db.upsert(\"Person\", newPerson, {\n    onlyInsert: true,\n  });\n\n  if (!upsertResult.isSuccesful) {\n    return {\n      isSuccessful: false,\n      message: upsertResult.message || \"Upsert person not successful\",\n    };\n  }\n\n  const updateResult = await db.update(\n    \"Device\",\n    (item) => item.id === device.id,\n    (old) => {\n      console.log(\n        `set new person id to ${newPersonId}, remove authenticationMethods`\n      );\n      return {\n        ...old,\n        authenticationMethods: [],\n        personIds: old.personIds\n          ? old.personIds.concat(newPersonId)\n          : [newPersonId],\n        currentPersonId: newPersonId,\n      };\n    }\n  );\n\n  return {\n    isSuccessful: updateResult.isSuccesful || false,\n    message: updateResult.isSuccesful\n      ? \"Signed up\"\n      : updateResult.isSuccesful || \"Something went wrong, no mess\",\n  };\n}"
  },
  "signupWithPasswordWithContext": {
    "name": "signupWithPasswordWithContext",
    "slug": "TsFunction",
    "id": "lmgldfceeoaqhmstlkizpjyu",
    "description": "For now only username/pass is supported due to direct verification\n\nThis function makes an authenticationmethod for the device and then signs up by creating a person for it and attaching it to the device.",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext,\n  fullName: string,\n  username: string,\n  pictureImage: BackendAsset | undefined,\n  password: string,\n  repeatPassword: string\n): Promise<{ isSuccessful: boolean; message: string }> => {\n  // processing is a oneliner for this type of functions!\n  pictureImage = await processAsset(pictureImage);\n\n  // only supported for now\n  const method: AuthenticationMethodMethod = \"usernamePassword\";\n\n  if (password !== repeatPassword) {\n    return { isSuccessful: false, message: \"Those passwords don't match\" };\n  }\n\n  const addDeviceAuthResult = await addDeviceAuthenticationMethodWithContext(\n    functionContext,\n    method,\n    username,\n    password\n  );\n\n  // console.log({ addDeviceAuthResult });\n  const {\n    functionContext: newFunctionContext,\n    authenticationMethod,\n    isSuccessful,\n    message,\n  } = addDeviceAuthResult;\n\n  if (!authenticationMethod?.isAuthenticated || !newFunctionContext) {\n    console.log(\"NOT AUTHENTICATED AFTER ADDING DEVICE\", {\n      authenticationMethod,\n      newFunctionContext,\n    });\n    return { isSuccessful: false, message: message || \"Strange\" };\n  }\n\n  const signupResult = await signupWithContext(newFunctionContext, {\n    name: fullName,\n    slug: slugify(fullName),\n    pictureImage,\n  });\n\n  return signupResult;\n}"
  },
  "switchCurrentPersonWithContext": {
    "name": "switchCurrentPersonWithContext",
    "slug": "TsFunction",
    "id": "wwmwjhzprbvqcpwlkqbcuzzh",
    "description": "",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext,\n  newCurentPersonId: string\n): Promise<{ isSuccessful: boolean; message: string }> => {\n  if (functionContext.device.currentPersonId === newCurentPersonId) {\n    return { isSuccessful: false, message: \"This account is already active\" };\n  }\n\n  const found = functionContext.device.personIds?.find(\n    (x) => x === newCurentPersonId\n  );\n\n  if (!found) {\n    return { isSuccessful: false, message: \"Can't find that account\" };\n  }\n\n  const { isSuccesful, message } = await db.update(\n    \"Device\",\n    (item) => item.id === functionContext.device.id,\n    (old) => ({ ...old, currentPersonId: newCurentPersonId })\n  );\n\n  return {\n    isSuccessful: isSuccesful || false,\n    message: isSuccesful\n      ? \"Switched\"\n      : message || \"Something went wrong (no message)\",\n  };\n}"
  },
  "updateMeWithContext": {
    "name": "updateMeWithContext",
    "slug": "TsFunction",
    "id": "yjngfmblfskhhmkfqfjapcxy",
    "description": "",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext,\n  details: PersonProfileDetails\n): Promise<{ isSuccessful: boolean; message: string }> => {\n  const person = functionContext.device.currentPersonCalculated;\n\n  const processedAsset = await processAsset(details.pictureImage);\n\n  details.pictureImage = processedAsset;\n\n  if (!person) {\n    return {\n      isSuccessful: false,\n      message: \"Couldn't find you, are you logged in?\",\n    };\n  }\n\n  const { isSuccesful, message, amountUpdated } = await db.update(\n    \"Person\",\n    (item) => item.id === person.id,\n    (old) => ({ ...old, ...details })\n  );\n\n  const isReallySuccessful = (isSuccesful && amountUpdated === 1) || false;\n\n  return {\n    isSuccessful: isReallySuccessful,\n    message: isReallySuccessful\n      ? \"Updated your profile details\"\n      : message || \"Something went wrong (no message)\",\n  };\n}"
  },
  "sayDutch": {
    "name": "sayDutch",
    "slug": "TsFunction",
    "id": "ztgkpaxyvrislmjnanrpxchf",
    "description": "",
    "operationName": "say",
    "rawText": " (message: string) => {\n  spawnSync(`say \"${message}\" --voice Xander`, { shell: true });\n}"
  },
  "sayLanguage": {
    "name": "sayLanguage",
    "slug": "TsFunction",
    "id": "pomhakzdfgapzmxwnazybxal",
    "description": "",
    "operationName": "say",
    "rawText": " (message: string, language: SayLanguageEnum) => {\n  const voice =\n    language === \"np\" ? \"Lekha\" : language === \"nl\" ? \"Xander\" : \"Alex\";\n  spawnSync(`say \"${message}\" --voice ${voice}`, { shell: true });\n}"
  },
  "sayNepali": {
    "name": "sayNepali",
    "slug": "TsFunction",
    "id": "muadlzpjdmhivwigwcobbcax",
    "description": "",
    "operationName": "say",
    "rawText": " (message: string) => {\n  spawnSync(`say \"${message}\" --voice Lekha`, { shell: true });\n}"
  },
  "saySomething": {
    "name": "saySomething",
    "slug": "TsFunction",
    "id": "czorlrhvknvhphrqzzpvkbnh",
    "description": "TODO: do research what else is out there\n\nsay [-v voice] [-r rate] [-o outfile [aud\nio format options] | -n name:port | -a device] [-f f\nile | string ...]\n\nDESCRIPTION\nThis tool uses the Speech Synthesis manager\nto convert input text to audible speech and\neither play it through the sound output\ndevice chosen in System Preferences or save\nit to an AIFF file.\n\n\nfor usage, see `man say`",
    "operationName": "say",
    "rawText": " async (\n  input: string | SayOptions\n): Promise<void> => {\n  const paramKeys =\n    typeof input === \"string\"\n      ? null\n      : (Object.keys(input) as (keyof SayOptions)[]);\n\n  const params =\n    typeof input === \"string\"\n      ? null\n      : paramKeys?.reduce((all, key) => {\n          const value = input[key];\n\n          if (value === undefined) {\n            return all;\n          }\n\n          if (key === \"message\") {\n            return `${all} \"${value}\"`;\n          }\n\n          return `${all} --${shorthands[key]}=${String(value)}`;\n        }, \"\");\n\n  const spawnInput = typeof input === \"string\" ? input : (params as string);\n\n  const result = execSync(`say ${spawnInput}`, { stdio: \"inherit\" });\n\n  return;\n  // const res= spawn(`say ${spawnInput}`, {shell:true})\n  // res.\n}"
  },
  "shorthands": {
    "name": "shorthands",
    "slug": "TsVariable",
    "id": "rzyyzdhrltyijxnuxpzbktym",
    "description": "",
    "operationName": "say"
  },
  "textToMp3": {
    "name": "textToMp3",
    "slug": "TsFunction",
    "id": "jjyplivddfulpeoghajvkwzk",
    "description": "",
    "operationName": "say",
    "rawText": " async (\n  options: Omit<SayOptions, \"outputFilePath\">,\n  /**\n   * Absolute path to the mp3\n   */\n  absoluteOutputFilePath: string\n) => {\n  const parsed = path.parse(absoluteOutputFilePath);\n  const aiffPath = path.join(parsed.dir, `${parsed.name}.aiff`);\n  const finalOptions: SayOptions = { ...options, outputFilePath: aiffPath };\n\n  await saySomething(finalOptions);\n  const finalPath = await convertToMp3(aiffPath, absoluteOutputFilePath);\n\n  if (finalPath) {\n    await fs.rm(aiffPath);\n  }\n\n  return finalPath;\n}"
  },
  "argumentsWithoutFlags": {
    "name": "argumentsWithoutFlags",
    "slug": "TsVariable",
    "id": "rywknfskqylbzvgssjjamduh",
    "description": "",
    "operationName": "ask"
  },
  "askOk": {
    "name": "askOk",
    "slug": "TsFunction",
    "id": "mwaadgupfqrtbgyhuqbqtrrm",
    "description": "",
    "operationName": "ask",
    "rawText": " async (question: string): Promise<boolean> => {\n  const answer = await ask(question);\n  return [\"yes\", \"y\", \"\"].includes(answer);\n}"
  },
  "ask": {
    "name": "ask",
    "slug": "Operation",
    "id": "kaVSSsxzjMippmUd",
    "operationName": "ask"
  },
  "getArgumentOrAsk": {
    "name": "getArgumentOrAsk",
    "slug": "TsFunction",
    "id": "obfmkziopammikbyoqqeblfw",
    "description": "",
    "operationName": "ask",
    "rawText": " async (\n  argumentPosition: number,\n  question: string,\n  isNonInteractive?: boolean\n): Promise<string> => {\n  let argument = argumentsWithoutFlags[argumentPosition + 1];\n  if (argument && argument.length > 0) return argument;\n\n  if (isNonInteractive) {\n    return \"\";\n  }\n\n  return ask(question);\n}"
  },
  "cliVersionUpdates": {
    "name": "cliVersionUpdates",
    "slug": "TsFunction",
    "id": "ypduisslcqbraqrrdhnijukj",
    "description": "Please place your description here",
    "operationName": "cli-version-updates",
    "rawText": " (): boolean => {\n  // make sure you provide an explicit return type, like shown above\n\n  return true;\n  //do something\n}"
  },
  "getPackageVersions": {
    "name": "getPackageVersions",
    "slug": "TsFunction",
    "id": "ndukorrjfmbctrravzdnefzp",
    "description": "",
    "operationName": "cli-version-updates",
    "rawText": " async (\n  name: string\n): Promise<{ latest: string; current: string } | undefined> => {\n  const latest = spawn(`npm show ${name} version`, {\n    // stdio: \"inherit\",\n    shell: true,\n    cwd: process.cwd(),\n  });\n\n  const packageDir = path.resolve(__dirname, \"..\");\n\n  const current: string = JSON.parse(\n    fs.readFileSync(path.resolve(packageDir, \"package.json\"), \"utf8\")\n  ).version;\n\n  return new Promise((resolve, reject) => {\n    // You can also use a variable to save the output\n    // for when the script closes later\n    let latestVersion = \"\";\n\n    latest.stdout.setEncoding(\"utf8\");\n    latest.stdout.on(\"data\", function (data) {\n      latestVersion += data;\n    });\n    latest.on(\"close\", function (code) {\n      //Here you can get the exit code of the script\n      if (code === 0) {\n        resolve({ latest: latestVersion, current });\n      } else {\n        reject();\n      }\n    });\n  });\n}"
  },
  "getUpdateSeverity": {
    "name": "getUpdateSeverity",
    "slug": "TsFunction",
    "id": "cttnuteskwsfkcmokcclccqv",
    "description": "",
    "operationName": "cli-version-updates",
    "rawText": " async ({\n  latest,\n  current,\n}: {\n  latest: string;\n  current: string;\n}) => {\n  const latestParts = getVersionParts(latest);\n  const currentParts = getVersionParts(current);\n\n  if (latestParts.major > currentParts.major) return \"major\";\n  if (latestParts.minor > currentParts.minor) return \"minor\";\n  if (latestParts.patch > currentParts.patch) return \"patch\";\n  return false;\n}"
  },
  "getVersionParts": {
    "name": "getVersionParts",
    "slug": "TsFunction",
    "id": "arebhciosjzplahkijzwgvtx",
    "description": "",
    "operationName": "cli-version-updates",
    "rawText": " (versionString: string) => {\n  const [major, minor, patch] = versionString.split(\".\").map(Number);\n  return { major, minor, patch };\n}"
  },
  "handleVersionUpdates": {
    "name": "handleVersionUpdates",
    "slug": "TsFunction",
    "id": "rkybgcuyvksdpmjxzlysvfgf",
    "description": "",
    "operationName": "cli-version-updates",
    "rawText": " async (\n  name: string,\n  targetDir: string,\n  isDebug?: boolean\n) => {\n  const versions = await getPackageVersions(name);\n  if (!versions) {\n    return log(\"Couldn't check your version, be warned\", { type: \"warning\" });\n  }\n\n  const updateSeverity = await getUpdateSeverity(versions);\n\n  if (!updateSeverity) return;\n\n  if (updateSeverity === \"patch\") {\n    return log(\n      `There's a new version with version ${versions.latest}. You are now on version ${versions.current}.`,\n      { type: \"important\" }\n    );\n  }\n\n  const shouldUpdate = await askOk(\n    `Theres a new ${updateSeverity} version available for ${name} (${versions.latest}). You're now on version ${versions.current}. Shall we update? yes/no`\n  );\n\n  if (shouldUpdate) {\n    // TODO: this is probably not what we want for every cli.\n    await executeCommand(\n      {\n        description: `Updating ${name}`,\n        command: `npm install --global ${name}@latest`,\n      },\n      targetDir,\n      isDebug\n    );\n\n    return process.exit(0);\n  }\n\n  return log(\n    `Continuing on an older ${updateSeverity} version. Probably mostly harmless.`,\n    { type: \"warning\" }\n  );\n}"
  },
  "chat": {
    "name": "chat",
    "slug": "TsFunction",
    "id": "wofagristrkwqeebmbycksur",
    "description": "",
    "operationName": "function-util",
    "rawText": " () => {\n  // 1- listen\n  // 2- respond\n  chat();\n}"
  },
  "converse": {
    "name": "converse",
    "slug": "TsFunction",
    "id": "dfikqyznijkzpewxatcgirtz",
    "description": "this is the `yo` cli. takes a message",
    "operationName": "function-util",
    "rawText": " async (searchMessage: string) => {\n  const sdkFunctionPaths = await getSdkFunctionPaths();\n  if (!sdkFunctionPaths) return false;\n  const sdkKeyMatches = findSentenceMatches(\n    searchMessage,\n    sdkFunctionPaths,\n    (x) => x.matcher.replaceAll(\"/\", \" \")\n  );\n\n  if (sdkKeyMatches.length === 0) {\n    log(\"Wut?\", { type: \"error\" });\n  } else if (sdkKeyMatches.length === 1) {\n    const match = sdkKeyMatches[0];\n    log(`Match: ${humanCase(match.name)}`, {\n      type: \"success\",\n    });\n\n    await getParametersAndExecute(match);\n  } else {\n    log(\n      `There are ${sdkKeyMatches.length} things we can do: \\n\\n${sdkKeyMatches\n        .map(\n          (match, index) =>\n            `${index}: ${match.name} (from ${match.relativeOperationPath})`\n        )\n        .join(\", \\n\")}`,\n      { type: \"important\" }\n    );\n\n    const n = await ask(\"Which number do you want?\");\n\n    if (isNaN(Number(n))) {\n      log(`That's not a number`, { type: \"error\" });\n      return;\n    }\n\n    const choice = sdkKeyMatches[Number(n)];\n\n    if (!choice) {\n      log(`That's not a function from the list`, { type: \"error\" });\n      return;\n    }\n\n    await getParametersAndExecute(choice);\n  }\n}"
  },
  "doCli": {
    "name": "doCli",
    "slug": "TsFunction",
    "id": "qzagsmpixdjvlmdnwiwbtrmn",
    "description": "",
    "operationName": "function-util",
    "rawText": " async () => {\n  const [cliNameString, ...parameterStrings] = process.argv.slice(2);\n  const cliPath = `src/cli/${cliNameString}.cli.ts`;\n  const tsFunction = (\n    await db.get(\"TsFunction\", {\n      filter: (fn) => fn.operationRelativeTypescriptFilePath === cliPath,\n    })\n  )[0];\n\n  if (!tsFunction || !tsFunction.operationName) {\n    console.log(\"not found\", cliPath);\n    return;\n  }\n\n  const fileId = getSrcRelativeFileId(\n    tsFunction.operationRelativeTypescriptFilePath\n  );\n\n  const operationPath = await getOperationPath(tsFunction.operationName);\n  if (!operationPath) return;\n  const jsPath = path.join(operationPath, \"build\", `${fileId}.js`);\n\n  execSync(`node ${jsPath} ${parameterStrings.join(\" \")}`, {\n    stdio: \"inherit\",\n  });\n}"
  },
  "executeSdkFunction": {
    "name": "executeSdkFunction",
    "slug": "TsFunction",
    "id": "iptfpzgmhxtihjlnflqpugsz",
    "description": "",
    "operationName": "function-util",
    "rawText": " async (\n  operationString: string,\n  parameters: string[] | undefined\n) => {\n  const sdkOperation = operationString as keyof typeof sdk;\n  const operationFunction = sdk[sdkOperation];\n\n  if (typeof operationFunction === \"function\") {\n    const result = parameters\n      ? // @ts-ignore\n        operationFunction(...parameters)\n      : // @ts-ignore\n        operationFunction();\n\n    return result;\n  } else {\n    log(`Could not find ${operationString}`, { type: \"error\" });\n  }\n}"
  },
  "exportsArray": {
    "name": "exportsArray",
    "slug": "TsVariable",
    "id": "mulrtffehgtuqsgoeiagedjb",
    "description": "",
    "operationName": "function-util"
  },
  "getCachedExportedFunctions": {
    "name": "getCachedExportedFunctions",
    "slug": "TsFunction",
    "id": "iftpgocpngwftyujcqykskcb",
    "description": "",
    "operationName": "function-util",
    "rawText": " async () => {\n  if (functions.length) return functions;\n  functions = await db.get(\"TsFunction\");\n  exportsArray = await db.get(\"TsExport\");\n  const fnIsExported = (fn: TsFunction) =>\n    exportsArray.find(\n      (e) => e?.operationName === fn?.operationName && e.name === fn.name\n    );\n  return functions.filter(fnIsExported);\n}"
  },
  "getMenu": {
    "name": "getMenu",
    "slug": "TsFunction",
    "id": "gqpjbwzfalyiohneykzypdkc",
    "description": "",
    "operationName": "function-util",
    "rawText": " async () => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n  const operationFolders: string[] = await exploreOperationFolders({\n    basePath: getPathsWithOperations(),\n  });\n  const relativeOperationFolders = operationFolders.map((p) =>\n    p.slice(projectRoot.length)\n  );\n\n  const fns = await getCachedExportedFunctions();\n  const functionsPerOperation = relativeOperationFolders.map(\n    (relativeOperationFolder) => ({\n      [relativeOperationFolder.slice(1)]: fns.filter(\n        (fn) => fn.operationName === getLastFolder(relativeOperationFolder)\n      ),\n      // optionally, maybe I should just return the function names here.\n    })\n  );\n  return {\n    success: true,\n    response: \"Menu found\",\n    menu: mergeObjectsArray(functionsPerOperation),\n  };\n}"
  },
  "getParametersAndExecute": {
    "name": "getParametersAndExecute",
    "slug": "TsFunction",
    "id": "kcpddjwbkgzdaifnguteffes",
    "description": "",
    "operationName": "function-util",
    "rawText": " async (fn: FnMatch) => {\n  console.log(`finding ${fn.name} as ${fn.matcher}`);\n\n  log(\n    `Fill in the parameters of this function (JSON or string) (Leave empty for no parameter)`\n  );\n  const parameters = await getParameters(fn.parameters);\n  await executeSdkFunction(fn.name, parameters);\n}"
  },
  "getParameters": {
    "name": "getParameters",
    "slug": "TsFunction",
    "id": "ellgiqvucvnsvuloyladpbhz",
    "description": "",
    "operationName": "function-util",
    "rawText": " async (parameters?: FunctionParameter[]) => {\n  return parameters\n    ? oneByOne(parameters, async (parameter) => {\n        /** TODO: Walking:\n         * - if a parameter is a string, it's easy\n         * - if a parameter is a number or boolean, just cast string to that\n         * - if a parameter is an object, walk over all keys\n         * - if a parameter is/can be an array, just insert the first via the above way, but ask if you want to insert another entry after that\n         * - for every entry you can also enter '?'. This will look for all operations that return something that could be used as entry here.\n         */\n        const answer = await ask(`${parameter.name} (${parameter.required})`);\n        return answer;\n      })\n    : undefined;\n}"
  },
  "getSdkFunctionPaths": {
    "name": "getSdkFunctionPaths",
    "slug": "TsFunction",
    "id": "lkazvgbmhwrhvplkahjqnrkz",
    "description": "",
    "operationName": "function-util",
    "rawText": " async (): Promise<false | FnMatch[]> => {\n  const menu = await getMenu();\n\n  if (!menu) {\n    return false;\n  }\n\n  const paths = Object.keys(menu).reduce((all, relativeOperationPath) => {\n    //@ts-ignore\n    const fnArray: TsFunction[] | undefined = menu[relativeOperationPath];\n\n    return fnArray && Array.isArray(fnArray)\n      ? all.concat(\n          fnArray.map((x) => {\n            return {\n              matcher: `${relativeOperationPath}/${x.name}`,\n              relativeOperationPath,\n              ...x,\n            };\n          })\n        )\n      : all;\n  }, [] as FnMatch[]);\n\n  return paths;\n}"
  },
  "listen": {
    "name": "listen",
    "slug": "TsFunction",
    "id": "nwzxbthkipnzwfiaxvhjloca",
    "description": "generates structured operations based on unstructured instructions\n\nThis is huge. we need to start somewhere though. Plan:\n\n- all operations can be formatted as a word[] with specified order\n- all words can have synonyms\n- some operations can have aliases or different word orders that would mean the exact same\n- speech to text is a prerequisite for speaking out instructions\n- text to speech is already there\n\nWith this in place, we can define a structured way to do things.\n\n1) find the right operation to apply\n2) every parameter needs to be filled in (or use default) or we need to use a preset (from previous input logs). this can be some sort of conversation\n3) the opo (operation output) can be added to context, if needed\n4) the opi (operation input) can be added to presets, if needed\n\nCan you imagine that? I am creating a script that runs all the time and listens and responds to anything I say. My own Siri, but much more powerful. It seems hard, but if you look at it, it's actually just a different UI for all the things I already have. Among other things, it will make it possible to work while doing anything.\n\nThe power lies in being able to recursively ask for all the parameters. if you provide a new operation instead of a value, it will ask for all its parameters in order to continue.\n\nThis conversation could actually be used to generate code! It's kind of `context.reverse().map(createTsLine);` In fact, if we can make that, we can maybe even reverse code into conversations as well! This is insanely powerful.",
    "operationName": "function-util",
    "rawText": " ({\n  instruction,\n  context,\n}: {\n  instruction: string;\n  /**\n   * should be in fifo order, so no push but unshift! the further in the array, the less important the context (forgetting)\n   */\n  context: Context[];\n}): { operation: string; input: any; certainty: number }[] => {\n  return [];\n}"
  },
  "message": {
    "name": "message",
    "slug": "TsVariable",
    "id": "wlrivgemrhuqpdouoizrqfoi",
    "description": "",
    "operationName": "function-util"
  },
  "wordArray": {
    "name": "wordArray",
    "slug": "TsVariable",
    "id": "vpcxfqjsbcktfmozriztfnus",
    "description": "",
    "operationName": "function-util"
  },
  "objectStringToJson": {
    "name": "objectStringToJson",
    "slug": "TsFunction",
    "id": "roojpihcmyerqhvkdthwkkey",
    "description": "takes an object string and parses it to JSON\n\nInstead of requiring objects to be in JSON format, they can be in the following format:\n\nkey1: value, key2: another value, key3: 9, key4: false, key5: null, key6: { subkey: true, subkey2: 0 }\n\nNB: you can have objects in parameters of objects by surrounding the same syntax with `{` and `}`",
    "operationName": "string-to-json",
    "rawText": " (\n  string: string\n): { [key: string]: JSONValue } => {\n  const chunks = string.split(\",\").map((x) => x.trim());\n  const keyValues = chunks.map((chunk) => {\n    const [key, value] = chunk.split(\":\").map((x) => x.trim());\n    return { [key]: stringToJson(value) };\n  });\n\n  const mergedObject = mergeObjectsArray(keyValues);\n\n  return mergedObject;\n}"
  },
  "parseIfJson": {
    "name": "parseIfJson",
    "slug": "TsFunction",
    "id": "stgasgyqjissrhounylbjsvv",
    "description": "if it's a string with a parsable JSON inside, parse it and return the object/array",
    "operationName": "string-to-json",
    "rawText": " (string: string) => {\n  try {\n    return JSON.parse(string);\n  } catch (e) {\n    return string;\n  }\n}"
  },
  "parsePrimitiveJson": {
    "name": "parsePrimitiveJson",
    "slug": "TsFunction",
    "id": "uiulselzthjqpvqrbfdszxkh",
    "description": "parses a string to a string, number, boolean, null or undefined.\n\noptionally you can chooose to force a type...\n\nTODO: figure out how I can do this without ts-ignores",
    "operationName": "string-to-json",
    "rawText": " <\n  TForceType extends \"string\" | \"number\" | \"boolean\"\n>(\n  value: string,\n  forceType?: TForceType\n): TForceType extends \"string\"\n  ? string | null | undefined\n  : TForceType extends \"number\"\n  ? number | null | undefined\n  : TForceType extends \"boolean\"\n  ? boolean | null | undefined\n  : string | number | boolean | null | undefined => {\n  if (value === \"null\" && !forceType) {\n    // @ts-ignore\n    return null;\n  } else if (value === \"undefined\" && !forceType) {\n    // @ts-ignore\n    return undefined;\n  } else if (value === \"true\" && (!forceType || forceType === \"boolean\")) {\n    // @ts-ignore\n    return true;\n  } else if (value === \"false\" && (!forceType || forceType === \"boolean\")) {\n    // @ts-ignore\n    return false;\n  } else if (!isNaN(Number(value)) && (!forceType || forceType === \"number\")) {\n    // NB: do this after true and false, because they also cast to numbers\n    // @ts-ignore\n    return Number(value);\n  } else {\n    // all that's left is a string\n    // @ts-ignore\n    return value;\n  }\n}"
  },
  "stringToJson": {
    "name": "stringToJson",
    "slug": "TsFunction",
    "id": "lhadvlbvxnasiwbhsdeqwwsh",
    "description": "takes any string, and parses it to JSON\n\nif you provide (nested) objects, make sure to use the following format:\n\nkey1: value, key2: another value, key3: 9, key4: false, key5: null, key6: { subkey: true, subkey2: 0 }",
    "operationName": "string-to-json",
    "rawText": " (value: string, isObject?: boolean): JSONValue => {\n  const seemsObject = value.startsWith(\"{\") && value.endsWith(\"}\");\n  if (seemsObject || isObject) {\n    // Objects\n    // NB: remove first and last character\n    const objectString = seemsObject ? value.slice(1, value.length - 2) : value;\n    return objectStringToJson(objectString);\n  } else if (value.startsWith(\"[\") && value.endsWith(\"]\")) {\n    // Arrays\n    // NB: remove first and last character\n    const arrayString = value.slice(1, value.length - 2);\n    const chunkStrings = arrayString.split(\",\");\n    const chunks = chunkStrings.map((string) => stringToJson(string));\n    return chunks;\n  } else {\n    return parsePrimitiveJson(value);\n  }\n}"
  },
  "BigButton": {
    "name": "BigButton",
    "slug": "TsFunction",
    "id": "rmyiyilxgfpwwwfcosviwftx",
    "description": "",
    "operationName": "big-button",
    "rawText": " (button: BigButton) => {\n  const [isLoading, setIsLoading] = useState(false);\n  const colors =\n    button.stylePreset === \"cancel\"\n      ? \"bg-red-800 hover:bg-red-600 dark:bg-red-600 dark:hover:bg-red-400\"\n      : \"bg-blue-800 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-400\";\n  return (\n    <Div\n      className={`cursor-pointer ${colors} p-3 rounded-md border-2 border-black`}\n      onClick={async () => {\n        setIsLoading(true);\n        await button.onClick();\n        setIsLoading(false);\n      }}\n    >\n      <Div className={`flex flex-row gap-6 items-center`}>\n        {button.isLoading || isLoading ? (\n          <FancyLoader />\n        ) : button.icon ? (\n          <Svg src={button.icon} width={24} height={24} />\n        ) : button.emoji ? (\n          <P className={`text-xl hover:scale-110`}>{button.emoji}</P>\n        ) : button.component ? (\n          <Div className=\"h-7\">{button.component()}</Div>\n        ) : null}\n        <P className=\"text-xs text-white\">{button.title}</P>\n      </Div>\n    </Div>\n  );\n}"
  },
  "BreadCrumbs": {
    "name": "BreadCrumbs",
    "slug": "TsFunction",
    "id": "umswyupmrmepgxobmuefwdog",
    "description": "Shows where we are in the filesystem",
    "operationName": "breadcrumbs",
    "rawText": " (props: { path: string }) => {\n  const { path } = props;\n  const chunks = (path || \"\").split(\"/\");\n\n  if (path === \"\") return <Div />;\n  return (\n    <Div className=\"border-b border-b-gray-300 mb-4 bg-[#FFFFFF] dark:bg-gray-900\">\n      <Div className=\"flex flex-row items-center ml-2\">\n        {renderBreadCrumbs(chunks)}\n      </Div>\n    </Div>\n  );\n}"
  },
  "renderBreadCrumbs": {
    "name": "renderBreadCrumbs",
    "slug": "TsFunction",
    "id": "zkngyoojmkqlwpkohxxyqlof",
    "description": "",
    "operationName": "breadcrumbs",
    "rawText": " (chunks: string[]) => {\n  return chunks?.map((chunk, index) => {\n    const isLast = chunks.length - 1 === index;\n\n    return (\n      <Div\n        key={`breadcrumb${index}`}\n        className=\"flex flex-row items-center text-xs\"\n      >\n        {chunk}\n        {isLast ? null : (\n          <Div className=\"px-2 text-gray-900 dark:text-gray-200\">â–¸</Div>\n        )}\n      </Div>\n    );\n  });\n}"
  },
  "ClickableIcon": {
    "name": "ClickableIcon",
    "slug": "TsFunction",
    "id": "fwynhsvuegedxtaokinvjlmz",
    "description": "Renders a simple clickable icon with some styling\n\nIcon can be either an icon (Svg src) or emoji (string)",
    "operationName": "clickable-icon",
    "rawText": " (button: ClickableIconType) => {\n  return (\n    <Button\n      className=\"flex flex-col items-center\"\n      onClick={button.disabled ? undefined : button.onClick}\n    >\n      {button.icon ? (\n        <Svg\n          src={button.icon}\n          width={24}\n          height={24}\n          className={button.disabled ? \"text-gray-500\" : \"text-black\"}\n        />\n      ) : button.emoji ? (\n        <P\n          className={`text-xl ${\n            button.disabled ? \"opacity-50\" : \"hover:scale-110\"\n          }`}\n        >\n          {button.emoji}\n        </P>\n      ) : null}\n    </Button>\n  );\n}"
  },
  "ContextMenuItemComponent": {
    "name": "ContextMenuItemComponent",
    "slug": "TsFunction",
    "id": "wyyepswogptzeyqqlbilnruy",
    "description": "",
    "operationName": "context-menu",
    "rawText": " (props: {\n  item: ContextMenuItem;\n  id: string | undefined;\n  onClose: () => void;\n  itemClassName?: string;\n}) => {\n  const { item, id, onClose, itemClassName } = props;\n\n  const [loading, setLoading] = useState(false);\n  return (\n    <P\n      onClick={async () => {\n        setLoading(true);\n        await item.onClick(id);\n        setLoading(false);\n        onClose();\n      }}\n      className={\n        itemClassName ||\n        \"select-none dark:text-black cursor-pointer lg:hover:bg-blue-300 py-2 px-4 flex flex-row\"\n      }\n    >\n      {loading ? (\n        <Span>\n          <FancyLoader />\n        </Span>\n      ) : null}{\" \"}\n      <Span>{item.getTitle(id)}</Span>\n    </P>\n  );\n}"
  },
  "useContextMenu": {
    "name": "useContextMenu",
    "slug": "TsFunction",
    "id": "extevahidtmobpdtkvoekltv",
    "description": "Use this if you want to render a context menu where the menu closes if you click one of the items.\n\nOptionally, you can create a custom renderer for it.\n\nid can be provided by the contextEvent.",
    "operationName": "context-menu",
    "rawText": " (props: {\n  items: ContextMenuItem[];\n  longTouchDurationMs?: number;\n  /**\n   * Customise the container class\n   */\n  className?: string;\n\n  /**\n   * Customise the contextMenuItem className\n   *\n   * Example:\n   *\n   * `select-none cursor-pointer lg:hover:bg-blue-300 py-2 px-4`\n   */\n  itemClassName?: string;\n  /**\n   * \n   * Overwrite the default item using this custom renderer:\n   * \n   * Example:\n   * \n   * ```tsx\n  customItemRender={(\n    contextMenuItem,\n    index,\n    onClose,\n    id\n  ) => (\n      <P\n        onClick={() => {\n          contextMenuItem.onClick(id);\n          onClose();\n        }}\n        className=\"select-none cursor-pointer lg:hover:bg-blue-300 py-2 px-4\"\n        key={`menu${index}`}\n      >\n        {contextMenuItem.getTitle(id)}\n      </P>)}\n              \n   * ```\n   */\n  customItemRender?: (\n    contextMenuItem: ContextMenuItem,\n    index: number,\n    onClose: () => any,\n    id: string | undefined\n  ) => JSX.Element | null;\n}) => {\n  const {\n    items,\n    longTouchDurationMs,\n    className,\n    customItemRender,\n    itemClassName,\n  } = props;\n  const {\n    renderContextPopper: renderContextMenu,\n    openContextPopperProps: openContextMenuProps,\n    onClose,\n    isOpen,\n  } = useContextPopper({\n    longTouchDurationMs,\n    renderPopper: (props) => {\n      const { id } = props;\n      return (\n        <Div\n          className={\n            // className ||\n            \"bg-white dark:bg-gray-700 border border-black max-h-80 overflow-y-scroll\"\n          }\n        >\n          {items\n            .filter((x) => (x.getIsEnabled ? x.getIsEnabled(id) : true))\n            .map((contextMenuItem, index) => {\n              if (customItemRender) {\n                return customItemRender(contextMenuItem, index, onClose, id);\n              }\n\n              return (\n                <ContextMenuItemComponent\n                  id={id}\n                  item={contextMenuItem}\n                  key={`menuItem${index}`}\n                  onClose={onClose}\n                  itemClassName={itemClassName}\n                />\n              );\n            })}\n        </Div>\n      );\n    },\n  });\n\n  // ensure it only updates when you open the menu. this breaks the whole thing! lol.\n  const result = useMemo(\n    () => ({ renderContextMenu, openContextMenuProps, onClose, isOpen }),\n    [isOpen]\n  );\n\n  return { renderContextMenu, openContextMenuProps, onClose, isOpen };\n}"
  },
  "useContextPopper": {
    "name": "useContextPopper",
    "slug": "TsFunction",
    "id": "qhgbsgrlzfyossadxdoivvom",
    "description": "Use this hook if you want to create your own custom render that opens on the right location once the `.onContextMenu` is fired.",
    "operationName": "context-menu",
    "rawText": " (props: {\n  renderPopper: (props: { id?: string }) => JSX.Element;\n  longTouchDurationMs?: number;\n}): {\n  isOpen: boolean;\n  /**\n   * Render this function anywhere in your component. Ensure it's high enough up the tree to make sure the positioning is correct. Not tested in modals and scrollable divs...\n   */\n  renderContextPopper: () => JSX.Element | null;\n\n  /**\n   * Callback to close the popper from anywhere\n   */\n  onClose: () => void;\n  /**\n   * Attach these props to the element that should be right-clickable or long-pressable\n   *\n   * You can also pass an id to this element in order to pass this to the callback\n   * e.g.\n   *\n   * ```tsx\n   * <div id=\"some-id\" {...openContextPopperProps}>your html</div>\n   * ```\n   *\n   * If you also want to attach your own properties, you can destructure this and wrap the individual props in your final prop.\n   */\n  openContextPopperProps: {\n    ref: React.RefObject<HTMLDivElement>;\n    onContextMenu: (event: React.MouseEvent<Element, MouseEvent>) => void;\n    onTouchStart: (event: React.TouchEvent<Element>) => void;\n    onTouchEnd: () => void;\n    onClick: (mouseEvent: React.MouseEvent<Element, MouseEvent>) => void;\n    style: React.CSSProperties;\n  };\n} => {\n  const { longTouchDurationMs } = props;\n  const [contextEvent, setContextEvent] = useState<ContextEvent | null>(null);\n\n  useEffect(() => {\n    if (typeof window === \"undefined\") return;\n\n    // Needed to make it go away when clicking outside of the popper, doesn't work for textarea though\n    window.addEventListener(\"click\", () => {\n      setContextEvent(null);\n    });\n  }, []);\n\n  const contextProps = useContext(\n    (contextEvent) => {\n      setContextEvent(contextEvent);\n      console.log(\"callback called\", props, contextEvent);\n    },\n    { longTouchDurationMs }\n  );\n\n  const virtualReference = useMemo(() => {\n    if (!contextEvent) {\n      //   console.log(\"NO context event,SHOULD NOT HAPPEN\");\n      return;\n    }\n\n    // console.log(\"YAY\");\n\n    // console.log({\n    //   contextEvent,\n    //   x: contextEvent?.clientX,\n    //   y: contextEvent?.clientY,\n    // });\n    return {\n      // This is going to create a virtual reference element\n\n      getBoundingClientRect() {\n        // console.log({ contextEvent });\n\n        const clientRect: ClientRect = {\n          top: contextEvent?.clientY || 10,\n          left: contextEvent?.clientX || 10,\n          bottom: 0,\n          right: 0,\n          width: 0,\n          height: 0,\n          x: 0,\n          y: 0,\n          toJSON() {\n            return \"\";\n          },\n        };\n        return clientRect;\n      },\n    };\n  }, [contextEvent]);\n\n  const popperRef = useRef<HTMLDivElement>(null);\n  const { styles, attributes } = usePopper(\n    virtualReference,\n    popperRef.current,\n    {\n      strategy: \"fixed\",\n      placement: \"auto-start\",\n      modifiers: [{ name: \"preventOverflow\", enabled: false }],\n    }\n  );\n\n  const renderContextPopper = () =>\n    virtualReference && contextEvent ? (\n      <div\n        onClick={(e) => {\n          // NB: needed to ensure it doesn't close due to the window.click\n          e.stopPropagation();\n        }}\n        style={styles.popper}\n        {...attributes.popper}\n      >\n        {props.renderPopper({ id: contextEvent.id })}\n      </div>\n    ) : null;\n\n  const openContextPopperProps = {\n    ...contextProps,\n    ref: popperRef,\n  };\n\n  const onClose = () => setContextEvent(null);\n\n  return {\n    openContextPopperProps,\n    renderContextPopper,\n    onClose,\n    isOpen: !!contextEvent,\n  };\n}"
  },
  "useContext": {
    "name": "useContext",
    "slug": "TsFunction",
    "id": "rdwkiyvvtscylorjfnohiiem",
    "description": "Use this if you want to create a completely custom behavior from a context action. On top of the default `.onContextMenu` behavior, this hook enables the possibility for a custom hold duration on mobile.",
    "operationName": "context-menu",
    "rawText": " (\n  /**\n   * The callback that activates whenever you right-click or long-press\n   */\n  callback: (position: ContextEvent) => any,\n  config?: {\n    /**\n     * Customise the time for a longpress to enable the callback. Defaults to browser default (onContextMenu default). If you set this, we detect the duration ourselves via the onTouchStart and onTouchEnd events.\n     */\n    longTouchDurationMs?: number;\n  }\n) => {\n  const [timeoutRef, setTimeoutRef] = useState<NodeJS.Timeout | null>(null);\n\n  const openTouchMenu = (event: React.TouchEvent) => {\n    const touch = event.touches.item(event.touches.length - 1);\n    const { clientX, clientY, screenX, screenY } = touch;\n    const id = event.currentTarget?.id;\n    callback({ clientX, clientY, screenX, screenY, id });\n    setTimeoutRef(null);\n  };\n\n  const openContextMenu = (event: React.MouseEvent) => {\n    const { clientX, clientY, screenX, screenY } = event;\n    const id = event.currentTarget?.id;\n    callback({ clientX, clientY, screenX, screenY, id });\n  };\n\n  const onTouchStart = (event: React.TouchEvent) => {\n    // Only allow for a single timeout\n    if (timeoutRef) return;\n    if (!config?.longTouchDurationMs) return;\n    const timeout = setTimeout(\n      () => openTouchMenu(event),\n      config.longTouchDurationMs\n    );\n    setTimeoutRef(timeout);\n  };\n\n  /**\n   * Required for ensuring that you don't close  the menu immediately when opening it on mobile, because a click-event is also fired there\n   */\n  const onClick = (mouseEvent: React.MouseEvent) => {\n    // this also makes it impossible to close big markdown files!\n    // mouseEvent.stopPropagation();\n  };\n\n  const onTouchEnd = () => {\n    if (timeoutRef) {\n      clearTimeout(timeoutRef);\n    }\n  };\n\n  const onContextMenu = (event: React.MouseEvent) => {\n    event.preventDefault();\n    // NB: needed to stop it from opening anywhere above (mobile)\n    event.stopPropagation();\n    openContextMenu(event);\n  };\n  //\n  const contextProps = {\n    onContextMenu,\n    // onContextMenuCapture: (event: React.MouseEvent) => {\n    //   event.preventDefault();\n    //   event.stopPropagation();\n    // },\n    onTouchStart,\n    onTouchEnd,\n    onClick,\n    style: {}, //userSelect: \"none\" as React.CSSProperties[\"userSelect\"]\n  };\n  return contextProps;\n}"
  },
  "errorToast": {
    "name": "errorToast",
    "slug": "TsFunction",
    "id": "cpmkuoxnjeshsxqpnilezdnm",
    "description": "",
    "operationName": "cool-toast",
    "rawText": " (message?: string) => {\n  toast(\n    {\n      title: \"\",\n      body: message || \"Something went wrong\",\n    },\n    { hideProgressBar: true, position: \"bottom-right\", type: \"error\" }\n  );\n}"
  },
  "infoToast": {
    "name": "infoToast",
    "slug": "TsFunction",
    "id": "gsikcezuboqdajkbbpemlkgk",
    "description": "",
    "operationName": "cool-toast",
    "rawText": " (message?: string) => {\n  toast(\n    {\n      title: \"\",\n      body: message || \"This is interesting\",\n    },\n    { hideProgressBar: true, position: \"bottom-right\", type: \"info\" }\n  );\n}"
  },
  "showStandardResponse": {
    "name": "showStandardResponse",
    "slug": "TsFunction",
    "id": "yzweqoyzfwogzcfvarurvlud",
    "description": "Useful to show if the api has a standard response",
    "operationName": "cool-toast",
    "rawText": " (apiResult: StandardizedApiReturnType) => {\n  if (apiResult.errors) {\n    console.log({ errors: apiResult.errors });\n  }\n\n  if (apiResult.isUnauthorized) {\n    errorToast(apiResult.message);\n    return;\n  }\n\n  if (apiResult.isNotConnected) {\n    warningToast(apiResult.message || \"Not connected\");\n    return;\n  }\n\n  if (!apiResult.isSuccessful) {\n    errorToast(apiResult.message || \"Something went wrong\");\n    return;\n  }\n\n  if (!apiResult.result) {\n    successToast(\"Done\");\n    return;\n  }\n\n  if (!apiResult.result.isSuccessful) {\n    errorToast(apiResult.result.message || \"Something went wrong\");\n    return;\n  }\n\n  successToast(apiResult.result.message || \"Done\");\n}"
  },
  "successToast": {
    "name": "successToast",
    "slug": "TsFunction",
    "id": "sozuilflerwygyqlepohygrb",
    "description": "",
    "operationName": "cool-toast",
    "rawText": " (message?: string) => {\n  toast(\n    {\n      title: \"\",\n      body: message || \"Done\",\n    },\n    { hideProgressBar: true, position: \"bottom-right\", type: \"success\" }\n  );\n}"
  },
  "warningToast": {
    "name": "warningToast",
    "slug": "TsFunction",
    "id": "dnpocdustlzizweuegxwuxkk",
    "description": "",
    "operationName": "cool-toast",
    "rawText": " (message?: string) => {\n  toast(\n    {\n      title: \"\",\n      body: message || \"This is not a good idea\",\n    },\n    { hideProgressBar: true, position: \"bottom-right\", type: \"warning\" }\n  );\n}"
  },
  "FancyLoader": {
    "name": "FancyLoader",
    "slug": "TsFunction",
    "id": "ovvrehnnliupzojiiuiizcol",
    "description": "",
    "operationName": "fancy-loader",
    "rawText": " ({\n  big,\n  medium,\n}: {\n  big?: boolean;\n  medium?: boolean;\n}) => (\n  <Div\n    className={`rounded-full ${\n      big ? \"w-12 h-12\" : medium ? \"w-7 h-7\" : \"w-4 h-4\"\n    } border-b-orange-400 border-l-blue-400 border-t-red-400 border-r-green-400 ${\n      big ? \"border-4\" : medium ? \"border-2\" : \"border\"\n    } animate-spin`}\n  />\n)"
  },
  "getFileType": {
    "name": "getFileType",
    "slug": "TsFunction",
    "id": "fofovwypcfnozautsywwowmk",
    "description": "",
    "operationName": "file-icons",
    "rawText": " (fullPath: string): keyof typeof typeIcons => {\n  if (fullPath.endsWith(\".ts\")) return \"typescript\";\n  if (fullPath.endsWith(\".tsx\")) return \"typescript\";\n  if (fullPath.endsWith(\".js\")) return \"javascript\";\n  if (fullPath.endsWith(\".jsx\")) return \"javascript\";\n  if (fullPath.endsWith(\".md\")) return \"markdown\";\n  if (fullPath.endsWith(\".mdx\")) return \"markdown\";\n  if (fullPath.endsWith(\".json\")) return \"json\";\n  if (!fullPath.split(\"/\").pop()?.includes(\".\")) return \"folder\";\n\n  return \"other\";\n}"
  },
  "typeIcons": {
    "name": "typeIcons",
    "slug": "TsVariable",
    "id": "bgammkwbwhkpglgbrqdanshk",
    "description": "",
    "operationName": "file-icons"
  },
  "isAltB": {
    "name": "isAltB",
    "slug": "TsFunction",
    "id": "nvrrjvtffscbdnjfwkighwbl",
    "description": "âŽ‡ B",
    "operationName": "hotkeys",
    "rawText": " (keyboardEvent: KeyboardEvent) => {\n  const { altKey, code } = keyboardEvent;\n  return altKey && code === \"KeyB\";\n}"
  },
  "isAltN": {
    "name": "isAltN",
    "slug": "TsFunction",
    "id": "sqsgvwgbdvcyruznzjckwvne",
    "description": "",
    "operationName": "hotkeys",
    "rawText": " (keyboardEvent: KeyboardEvent) => {\n  const { altKey, code } = keyboardEvent;\n  return altKey && code === \"KeyN\";\n}"
  },
  "isAltO": {
    "name": "isAltO",
    "slug": "TsFunction",
    "id": "iqhirzjkrjvpqrnjwroryvmg",
    "description": "",
    "operationName": "hotkeys",
    "rawText": " (keyboardEvent: KeyboardEvent) => {\n  const { altKey, code } = keyboardEvent;\n  return altKey && code === \"KeyO\";\n}"
  },
  "isAltW": {
    "name": "isAltW",
    "slug": "TsFunction",
    "id": "laendfkogqkjmnbotrsvxjxm",
    "description": "",
    "operationName": "hotkeys",
    "rawText": " (keyboardEvent: KeyboardEvent) => {\n  const { altKey, code } = keyboardEvent;\n  return altKey && code === \"KeyW\";\n}"
  },
  "isCtrlBacktick": {
    "name": "isCtrlBacktick",
    "slug": "TsFunction",
    "id": "ihndizrysxsknbutrjttfoqj",
    "description": "^ `",
    "operationName": "hotkeys",
    "rawText": " (keyboardEvent: KeyboardEvent) => {\n  const { ctrlKey, code } = keyboardEvent;\n\n  return ctrlKey && code === \"Backquote\";\n}"
  },
  "isCtrlP": {
    "name": "isCtrlP",
    "slug": "TsFunction",
    "id": "kekhbhnxktqfypyfcelranvi",
    "description": "^ P",
    "operationName": "hotkeys",
    "rawText": " (keyboardEvent: KeyboardEvent) => {\n  const { ctrlKey, code } = keyboardEvent;\n\n  return ctrlKey && code === \"KeyP\";\n}"
  },
  "isCtrlS": {
    "name": "isCtrlS",
    "slug": "TsFunction",
    "id": "myrrsfuloscjewitnbonalip",
    "description": "^ S",
    "operationName": "hotkeys",
    "rawText": " (keyboardEvent: KeyboardEvent) => {\n  const { ctrlKey, code } = keyboardEvent;\n\n  return ctrlKey && code === \"KeyS\";\n}"
  },
  "isCtrlSpace": {
    "name": "isCtrlSpace",
    "slug": "TsFunction",
    "id": "ptwchakhvqhbqdunatbrjvyg",
    "description": "^ `",
    "operationName": "hotkeys",
    "rawText": " (keyboardEvent: KeyboardEvent) => {\n  const { code, ctrlKey } = keyboardEvent;\n  return ctrlKey && code === \"Space\";\n}"
  },
  "useHotkey": {
    "name": "useHotkey",
    "slug": "TsFunction",
    "id": "sbtrvzynnlrjvayvoyvsyfwz",
    "description": "hook that creates an eventlistener for keydown and cleans it up when needed",
    "operationName": "hotkeys",
    "rawText": " (\n  /**\n   * callback that needs to launch on any keyboard event\n   */\n  isRightKey: (keyboardEvent: KeyboardEvent) => boolean,\n  /**\n   * function to be executed when hotkey occurs\n   */\n  callback: () => void,\n  /**\n   * when the callback needs to be reloaded\n   */\n  dependencies: any[]\n) => {\n  const fullCallback = (keyboardEvent: KeyboardEvent) => {\n    if (isRightKey(keyboardEvent)) {\n      callback();\n    }\n  };\n  return useHotkeys(dependencies, fullCallback);\n}"
  },
  "useHotkeys": {
    "name": "useHotkeys",
    "slug": "TsFunction",
    "id": "rhyvkqnntnefdgvxsrbfpfsv",
    "description": "hook that creates an eventlistener for keydown and cleans it up when needed",
    "operationName": "hotkeys",
    "rawText": " (\n  /**\n   * when the callback needs to be reloaded\n   */\n  dependencies: any[],\n  /**\n   * callback that needs to launch on any keyboard event\n   */\n  callback: (keyboardEvent: KeyboardEvent) => void\n) => {\n  return useEffect(() => {\n    if (typeof window === \"undefined\") return;\n    window.addEventListener(\"keydown\", callback);\n    return () => window.removeEventListener(\"keydown\", callback);\n  }, dependencies);\n}"
  },
  "LabeledButton": {
    "name": "LabeledButton",
    "slug": "TsFunction",
    "id": "jkshyipulilupqmyemkdgtvz",
    "description": "",
    "operationName": "labeled-button",
    "rawText": " (button: LabeledButtonType, index: number) => {\n  const size = button.size === \"small\" ? 12 : 24;\n  const heightClass = button.size === \"small\" ? \"h-4\" : \"h-7\";\n  const textSizeClass = button.size === \"small\" ? \"text-xs\" : \"text-xl\";\n  return (\n    <Button\n      key={`labeledbutton${index}`}\n      className={`flex flex-col items-center`}\n      onClick={button.onClick}\n    >\n      <Div\n        className={`w-10 ${\n          button.isActive ? \"bg-blue-900 dark:bg-blue-600 rounded-full\" : \"\"\n        }`}\n      >\n        {button.icon ? (\n          <Svg src={button.icon} width={size} height={size} />\n        ) : button.emoji ? (\n          <P className={`${textSizeClass} hover:scale-110`}>{button.emoji}</P>\n        ) : button.component ? (\n          <Div className={heightClass}>{button.component()}</Div>\n        ) : null}\n      </Div>\n      {button.size === \"small\" ? null : (\n        <P className=\"text-xs\">{button.title}</P>\n      )}\n    </Button>\n  );\n}"
  },
  "getFullPath": {
    "name": "getFullPath",
    "slug": "TsFunction",
    "id": "ufqzovfuzrpjwbetyadgogbj",
    "description": "gets a path string from `next.js` `router.query`.",
    "operationName": "next-paths",
    "rawText": " (\n  /**\n   * paths coming from `router.query`\n   *\n   * supposed to be a path/url refering to a file/page that can be represented with slashes in between\n   */\n  paths: string | string[] | undefined\n): string => {\n  return typeof paths === \"string\"\n    ? paths\n    : Array.isArray(paths)\n    ? paths.join(\"/\")\n    : \"\";\n}"
  },
  "getLastPathsChunk": {
    "name": "getLastPathsChunk",
    "slug": "TsFunction",
    "id": "hiynmuuikidqzfrqyzmqxsyj",
    "description": "returns the last chunk of the path",
    "operationName": "next-paths",
    "rawText": " (\n  /**\n   * paths coming from `router.query`\n   */\n  paths: string | string[] | undefined\n) => {\n  return Array.isArray(paths) ? paths[paths.length - 1] : paths;\n}"
  },
  "usePath": {
    "name": "usePath",
    "slug": "TsFunction",
    "id": "hfertoebkaxpeviycyndawnh",
    "description": "uses `useRouter` from `next.js` to get the lastChunk and the `fullPath` out of the `paths`. Assumes you have a page in your next.js project called `[...paths]`.",
    "operationName": "next-paths",
    "rawText": " () => {\n  const router = useRouter();\n  const paths = router.query?.paths;\n  const lastChunk = getLastPathsChunk(paths);\n  const fullPath = getFullPath(paths);\n  return { lastChunk, fullPath };\n}"
  },
  "contextKey": {
    "name": "contextKey",
    "slug": "TsFunction",
    "id": "ijffnppjhygcmzwwdzrhnnra",
    "description": "",
    "operationName": "react-with-native-store",
    "rawText": " (key: string) => `${key}Context`"
  },
  "contexts": {
    "name": "contexts",
    "slug": "TsVariable",
    "id": "ggolmgoawgvivstagpebmhzy",
    "description": "",
    "operationName": "react-with-native-store"
  },
  "createStoreProvider": {
    "name": "createStoreProvider",
    "slug": "TsFunction",
    "id": "jbbhekehpcngmomfpfemfcpw",
    "description": "Function to create the StoreProvider\n\nNB: this function uses a local variable on the main scope of javascript in order to create the Context components dynamically. Beware!",
    "operationName": "react-with-native-store",
    "rawText": " <TStore extends object>(\n  config: StoreConfig<TStore>\n) => {\n  if (config.debug) {\n    debug = config.debug;\n  }\n  if (debug) {\n    console.log(\"Create StoreProvider\");\n  }\n\n  const keys = Object.keys(config.initialValues) as Keys<TStore>[];\n\n  const newContext = keys.reduce((acc, key) => {\n    const Context = React.createContext(null);\n    return {\n      ...acc,\n      [contextKey(key)]: Context,\n    };\n  }, {});\n\n  contexts = { ...contexts, ...newContext };\n\n  // console.log({ keys, contexts });\n\n  const MainProvider = ({ children }: { children: any }) =>\n    keys.reduce((acc, key) => {\n      const context = contexts[contextKey(key)];\n\n      // console.log({ context });\n      return (\n        <StoreContextProvider\n          config={config}\n          storeKey={key}\n          DynamicContext={context}\n        >\n          {acc}\n        </StoreContextProvider>\n      );\n    }, children);\n\n  return ({ children }: { children: any }) => {\n    return <MainProvider>{children}</MainProvider>;\n  };\n}"
  },
  "createStore": {
    "name": "createStore",
    "slug": "TsFunction",
    "id": "daczukouqhhwturtiuoqugpm",
    "description": "One function is all you need to make a new store!\n\nExample:\n\n\n```ts\n\nimport { createStore } from \"react-with-native-store\";\nimport { TypeA, TypeB } from \"your-types\";\n\nexport const writerInitialValues: {\nitemA: TypeA;\nitemB: TypeB;\n} = {\nitemA: \"\",\nitemB: {},\n};\nexport const { useStore, StoreProvider } = createStore(writerInitialValues);\n\n\n```\n\nSimple as pie ðŸ°",
    "operationName": "react-with-native-store",
    "rawText": " <K extends object>(initialValues: K) => ({\n  StoreProvider: createStoreProvider({ initialValues }),\n  useStore: createUseStore(initialValues),\n})"
  },
  "createUseStore": {
    "name": "createUseStore",
    "slug": "TsFunction",
    "id": "jiwcwzubrxstgtfslaihebml",
    "description": "Function to create a hook for accessing the store",
    "operationName": "react-with-native-store",
    "rawText": " <TStore extends object>(\n  initialValues: TStore\n) => {\n  if (debug) {\n    console.log(\"Create useStore\");\n  }\n  const useStore = <K extends Keys<TStore>>(key: K) => {\n    if (!Object.keys(initialValues).includes(key)) {\n      throw new Error(`Using undefined key in useStore: ${key}`);\n    }\n    const context = getContext(key);\n    if (!context) {\n      throw new Error(\n        `Failed loading the context with key: ${key}. Did you wrap your component/app with a StoreProvider?`\n      );\n    }\n    const useStoreHook = React.useContext<UseStoreType<TStore>>(context);\n\n    const useStoreHookType = typeof useStoreHook;\n\n    if (useStoreHookType !== \"function\") {\n      console.error(\n        `useStoreHookType for ${key} is ${useStoreHookType}... wtf?`\n      );\n    }\n\n    return useStoreHook?.(key);\n  };\n  return useStore;\n}"
  },
  "debug": {
    "name": "debug",
    "slug": "TsVariable",
    "id": "dmmgnbudktwsgnidetwtbeaf",
    "description": "",
    "operationName": "react-with-native-store"
  },
  "getItemSync": {
    "name": "getItemSync",
    "slug": "TsFunction",
    "id": "uiuyhcihlfvthexoeombdhsx",
    "description": "ONLY web",
    "operationName": "react-with-native-store",
    "rawText": " (key: string) => {\n  if (typeof window === \"undefined\") {\n    return undefined;\n  }\n  const item = localStorage.getItem(key);\n  return item ? JSON.parse(item) : undefined;\n}"
  },
  "getItem": {
    "name": "getItem",
    "slug": "TsFunction",
    "id": "crpmofgrzqmpesxmwgreamcv",
    "description": "If you don't have access to the `useStore` hook, maybe because you're doing something outside of react... you can directly use the storage with javascript using this function",
    "operationName": "react-with-native-store",
    "rawText": " async (key: string) => {\n  if (typeof window === \"undefined\") {\n    return undefined;\n  }\n  const item = localStorage.getItem(key);\n  return item ? JSON.parse(item) : undefined;\n}"
  },
  "getKey": {
    "name": "getKey",
    "slug": "TsFunction",
    "id": "yzqzqaiixescwodlfgfrabwq",
    "description": "",
    "operationName": "react-with-native-store",
    "rawText": " (key: string, baseKey?: string) =>\n  baseKey ? `${baseKey}.${key}` : key"
  },
  "setItem": {
    "name": "setItem",
    "slug": "TsFunction",
    "id": "gdhefunrqpjuxsbtvrbmmlrt",
    "description": "If you don't have access to the `useStore` hook, maybe because you're doing something outside of react... you can directly use the storage with javascript using this function\n\nBEWARE! Updating this won't update your react components!",
    "operationName": "react-with-native-store",
    "rawText": " async (key: string, value: any) => {\n  if (typeof window === \"undefined\") {\n    return;\n  }\n  localStorage.setItem(key, JSON.stringify(value));\n}"
  },
  "StoreContextProvider": {
    "name": "StoreContextProvider",
    "slug": "TsFunction",
    "id": "gnuadzvsukjamitvthaztpnl",
    "description": "",
    "operationName": "react-with-native-store",
    "rawText": " <TStore extends object, K extends Keys<TStore>>({\n  DynamicContext,\n  children,\n  config,\n  storeKey,\n}: {\n  DynamicContext: React.Context<any>;\n  children: any;\n  config: StoreConfig<TStore>;\n  storeKey: K;\n}) => {\n  const [hydrated, setHydrated] = useState(false);\n  const [store, setStore] = useState<TStore[K]>(\n    config?.initialValues[storeKey]\n  ); //null or some object or string or whatever\n  const baseKey = config?.baseKey;\n\n  // On mount, get the current value from storage\n  useEffect(() => {\n    const fullKey = getKey(storeKey, baseKey);\n    getItem(fullKey).then((value) => {\n      if (debug) {\n        console.log(`Hydrated store for ${fullKey}:`, value);\n      }\n      setStore(value);\n      setHydrated(true);\n    });\n  }, []);\n\n  const initialValues = config?.initialValues;\n\n  const useStoreHook: UseStoreType<TStore> = <K2 extends Keys<TStore>>(\n    key: K2\n  ) => {\n    const fullKey = getKey(key, baseKey);\n\n    const defaultValue = initialValues[key];\n    // @ts-ignore\n    const value: TStore[K2] =\n      store !== undefined\n        ? store\n        : defaultValue !== undefined\n        ? defaultValue\n        : null;\n\n    const dispatch: (value: TStore[K2]) => Promise<void> = async (value) => {\n      //should do a deep equal here, and only set the store and item if the value actually has changed\n      //@ts-ignore\n      setStore(value);\n      await setItem(fullKey, value);\n    };\n\n    return [value, dispatch, { hydrated }];\n  };\n\n  return (\n    <DynamicContext.Provider value={useStoreHook}>\n      {children}\n    </DynamicContext.Provider>\n  );\n}"
  },
  "SwipeHomepage": {
    "name": "SwipeHomepage",
    "slug": "TsFunction",
    "id": "eqpzribmnctrhpotuxglptia",
    "description": "This homepage component assumes you provide it some CTA's (ideally 2 or 3) and some items.\n\n- The items will be swipable\n- The logo should be available in `public/logo.png`\n\n![Example](../assets/SwipeHomepage.mov)",
    "operationName": "swipe-homepage",
    "rawText": " (props: {\n  ctas: { text: string; href: string }[];\n  items: SwipeItem[];\n}) => {\n  const { ctas, items } = props;\n  const buttonClass =\n    \"bg-white/60 rounded-full hover:bg-white cursor-pointer text-black p-2\";\n\n  return (\n    <Div>\n      <Div className=\"h-screen overflow-auto snap-mandatory snap-y\">\n        {items.map((item, index) => {\n          const finalMarkdown = item.isMarkdownNoLimit\n            ? item.markdown\n            : item.markdown?.substring(0, 500) +\n              ((item.markdown?.length || 0) > 500 ? \"...\" : \"\");\n          const nameSizeClass =\n            item.title.length > 10 ? \"text-2xl\" : \"text-6xl\";\n          return (\n            <Div\n              key={`item${index}`}\n              style={{\n                backgroundImage: item.imagePath\n                  ? `url(\"${item.imagePath}\")`\n                  : undefined,\n                backgroundRepeat: \"no-repeat\",\n                backgroundSize: \"cover\",\n                backgroundPosition: \"center 75%\",\n              }}\n              className={`snap-center h-screen w-screen flex flex-col justify-center relative items-center ${\n                item.imagePath ? \"text-white\" : \"text-black dark:text-white\"\n              }`}\n            >\n              <ALink\n                href={item.href || \"#\"}\n                className={`absolute top-20 left-20 font-bold drop-shadow bg-green-500/20 rounded-md px-4 py-2 backdrop-blur-sm ${nameSizeClass} ${\n                  item.href ? \"cursor-pointer\" : \"cursor-default\"\n                }`}\n              >\n                {item.title}\n              </ALink>\n\n              {item.markdown && item.markdownSourcePath && finalMarkdown ? (\n                <Div className={\"w-[80vw]\"}>\n                  {renderMarkdownContent(finalMarkdown, {\n                    projectRelativeMarkdownFilePath: item.markdownSourcePath,\n                    projectRelativeBaseFolderPath: getFolderJs(\n                      item.markdownSourcePath\n                    ),\n                  })}\n                </Div>\n              ) : null}\n              {item.description ? (\n                <ALink\n                  href={item.href || \"#\"}\n                  className={`absolute bottom-10 mx-4 rounded-md p-6 bg-white/30 backdrop-blur-sm ${\n                    item.href ? \"cursor-pointer\" : \"cursor-default\"\n                  }`}\n                >\n                  {item.description}\n                </ALink>\n              ) : null}\n            </Div>\n          );\n        })}\n      </Div>\n      <Div className=\"z-index-1 absolute bottom-4 w-full flex flex-row justify-around\">\n        {ctas.map((cta) => {\n          return (\n            <ALink href={cta.href} className={buttonClass}>\n              {cta.text}\n            </ALink>\n          );\n        })}\n      </Div>\n\n      <Div className=\"z-index-1 absolute bg-white/60 rounded-full w-12 h-12 top-4 left-4\">\n        <Image src=\"/logo.png\" width={50} height={50} />\n      </Div>\n    </Div>\n  );\n}"
  },
  "DEFAULT_HOVER_TIMEOUT_MS": {
    "name": "DEFAULT_HOVER_TIMEOUT_MS",
    "slug": "TsVariable",
    "id": "euzrmbvsdhumdmjgrpikjyym",
    "description": "",
    "operationName": "tooltip"
  },
  "Tooltip": {
    "name": "Tooltip",
    "slug": "TsFunction",
    "id": "lbegmeaplufczhpfwdzsvlnm",
    "description": "",
    "operationName": "tooltip",
    "rawText": " (props: {\n  tooltip: React.ReactElement | null;\n  children: React.ReactNode;\n  hoverTimeout?: number;\n  placement?: Placement;\n}) => {\n  const timeoutMs = props.hoverTimeout || DEFAULT_HOVER_TIMEOUT_MS;\n  const [hoverLink, setHoverLink] = useState(false);\n\n  const [tooltipTimeout, setTooltipTimeout] = useState<NodeJS.Timeout | null>(\n    null\n  );\n  const [linkTimeout, setLinkTimeout] = useState<NodeJS.Timeout | null>(null);\n\n  const btnRef = createRef<HTMLAnchorElement>();\n  const popoverRef = createRef<HTMLSpanElement>();\n  const [hoverTooltip, setHoverTooltip] = useState(false);\n\n  const onEnterLink = () => {\n    if (!btnRef.current || !popoverRef.current) return;\n    createPopper(btnRef.current, popoverRef.current, {\n      placement: props.placement || \"auto\",\n    });\n    setHoverLink(true);\n    if (linkTimeout) {\n      clearTimeout(linkTimeout);\n    }\n  };\n\n  const onLeaveLink = () => {\n    const timeout = setTimeout(() => setHoverLink(false), timeoutMs);\n    setLinkTimeout(timeout);\n  };\n\n  const popoverShow = hoverTooltip || hoverLink;\n\n  const onEnterTooltip = () => {\n    if (tooltipTimeout) {\n      clearTimeout(tooltipTimeout);\n    }\n    setHoverTooltip(true);\n  };\n\n  const onLeaveTooltip = () => {\n    const timeout = setTimeout(() => setHoverTooltip(false), timeoutMs);\n    setTooltipTimeout(timeout);\n  };\n\n  return (\n    <span>\n      {props.tooltip ? (\n        <span\n          onMouseEnter={onEnterTooltip}\n          onMouseLeave={onLeaveTooltip}\n          className={`mb-8 dark:text-gray-100 text-black bg-slate-200 dark:bg-slate-800 p-2 z-30 text-sm max-w-xs break-words rounded-md${\n            popoverShow ? \" block\" : \" hidden\"\n          }`}\n          ref={popoverRef}\n        >\n          {props.tooltip}\n        </span>\n      ) : null}\n      <span onMouseEnter={onEnterLink} onMouseLeave={onLeaveLink} ref={btnRef}>\n        {props.children}\n      </span>\n    </span>\n  );\n}"
  },
  "createCodeblockMarkdown": {
    "name": "createCodeblockMarkdown",
    "slug": "TsFunction",
    "id": "btfgzwauwsnokyrivjedcuil",
    "description": "small util function to create a markdown for a string.",
    "operationName": "ui-util",
    "rawText": " (\n  text: string,\n  /**\n   * Extension that should be used for color highlighting the text\n   *\n   * Set to `null` if you don't want to specify a language\n   *\n   * defaults to \"ts\"\n   */\n  language: string | null = \"ts\"\n) => {\n  return `\n  \\`\\`\\`${language === null ? \"\" : language || \"ts\"}\n  ${text}\n  \\`\\`\\`\n  `;\n}"
  },
  "useCustomUrlStore": {
    "name": "useCustomUrlStore",
    "slug": "TsFunction",
    "id": "xvjkuidwxpqihfikrjptfkuj",
    "description": "---\nisStory: true\n---\n\nHook to store simple data in the URL\n\nI spent the last 4 hours on this: I think it's pretty useful. It's a hook that makes it possible to use your URL as a state store. It works with arrays and single values of strings, booleans and numbers. It's a drop in replacement of useStore or useState. The advantage is that the user can share the URL which will also share their state. Usage in a component looks like this:\n\n```ts\nconst [name, setName] = useUrl(\"name\");\n```\n\nI was looking for ways to make the api more straightforward, especially the stuff in useUrl seems a bit messy. However, I couldn't find any way to make it better. Any tips are welcome!\n\nTODO: make it work in react-native as well, either via a wrapper around useStore or via using the react-navigation param-store\n\n## Example usage\n\n```ts\nimport {useCustomUrlStore}from \"use-url-store\";\n\nexport const useUrl = <T extends keyof typeof queryStore>(queryKey: T) => {\n\nconst queryStore = {\n\"type-index-type\": useCustomUrlStore<string | undefined>(\"type-index-type\", {\ntype: \"string\",\n}),\n\n\"has-comment-types\": useCustomUrlStore<string[]>(\"has-comment-types\", {\ntype: \"string\",\nisArray: true,\n}),\n\"interface-is-db-model\": useCustomUrlStore<boolean>(\"interface-is-db-model\", {\ntype: \"boolean\",\n}),\npath: useCustomUrlStore<string | undefined>(\"path\", { type: \"string\" }),\nname: useCustomUrlStore<string | undefined>(\"name\", { type: \"string\" }),\ntype: useCustomUrlStore<string | undefined>(\"type\", { type: \"string\" }),\n};\n\nreturn queryStore[queryKey];\n};\n```",
    "operationName": "use-url-store",
    "rawText": " <\n  T extends\n    | string\n    | number\n    | boolean\n    | string[]\n    | boolean[]\n    | number[]\n    | undefined\n>(\n  queryKey: string,\n  config: CustomUrlStoreConfig\n): [T, (newValue: T | undefined) => Promise<boolean>] => {\n  const router = useRouter();\n  const queryValue = makeArray(router.query[queryKey]);\n  const parsed = queryValue.map((v) => parsePrimitiveJson(v, config.type));\n\n  const defaultValue =\n    config.type === \"boolean\"\n      ? false\n      : config.type === \"number\"\n      ? 0\n      : config.type === \"string\"\n      ? \"\"\n      : undefined;\n\n  const value = (\n    queryValue.length === 0\n      ? config.isArray\n        ? []\n        : undefined\n      : config.isArray\n      ? parsed\n      : parsed[0]\n      ? parsed[0]\n      : config.allowUndefined\n      ? undefined\n      : defaultValue\n  ) as T;\n\n  const setter = async (newValue: T | undefined) => {\n    const stringified =\n      newValue === undefined\n        ? undefined\n        : Array.isArray(newValue)\n        ? newValue.map((v) => String(v))\n        : [String(newValue)];\n    const queryPart =\n      stringified === undefined ? \"\" : getQueryPart(stringified, queryKey);\n\n    const previousQueryFiltered = { ...router.query };\n    delete previousQueryFiltered[queryKey];\n\n    const keysNow = Object.keys(router.query);\n    const allKeys = keysNow.includes(queryKey)\n      ? keysNow\n      : keysNow.concat(queryKey);\n\n    const newQueryString = allKeys.reduce((queryString, key) => {\n      const prefix = queryString === \"\" ? \"?\" : \"&\";\n\n      if (key === queryKey) {\n        return queryString.concat(prefix + queryPart);\n      }\n\n      if (router.query[key]) {\n        const queryPart = getQueryPart(makeArray(router.query[key]), key);\n        return queryString.concat(prefix + queryPart);\n      }\n\n      return queryString;\n    }, \"\");\n\n    const pushed = await router.push(\n      `${router.pathname}${newQueryString}`,\n      undefined,\n      {\n        shallow: true,\n      }\n    );\n    return pushed;\n  };\n\n  return [value, setter];\n}"
  },
  "ALink": {
    "name": "ALink",
    "slug": "TsFunction",
    "id": "ypixynzhhtyogjlxjkpgpqed",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " ({\n  children,\n  href,\n  target,\n  rel,\n  linkProps,\n  ...otherAProps\n}: { linkProps?: LinkProps } & AType) => {\n  return (\n    <Link {...linkProps} href={href || \"#\"} passHref>\n      <A {...otherAProps} rel={rel} target={target}>\n        {children}\n      </A>\n    </Link>\n  );\n}"
  },
  "A": {
    "name": "A",
    "slug": "TsFunction",
    "id": "qrcyhzhwwyyqfliazldmvsus",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, className, textClassName, ...props }: AType) => {\n  return <a {...props} className={joinClassNames(className, textClassName)} />;\n}"
  },
  "ActivityIndicator": {
    "name": "ActivityIndicator",
    "slug": "TsFunction",
    "id": "urlierxgwnhdtzznkfqartqi",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " (props: ActivityIndicatorType) => {\n  const sizeClass =\n    typeof props.size === \"number\"\n      ? \"\"\n      : props.size === \"large\"\n      ? \"w-16 h-16\"\n      : \"w-6 h-6\";\n  const sizeStyle =\n    typeof props.size === \"number\"\n      ? { width: props.size, height: props.size }\n      : undefined;\n\n  const borderClass =\n    props.color === \"white\"\n      ? \"border-white dark:border-gray-900\"\n      : \"border-gray-900 dark:border-white\";\n\n  const className = `${sizeClass} border-b-2 ${borderClass} rounded-full animate-spin ${\n    props.className || \"\"\n  }`;\n\n  return <div style={sizeStyle} className={className} />;\n}"
  },
  "Aside": {
    "name": "Aside",
    "slug": "TsFunction",
    "id": "ftquzjsvtvecbynuhpnocpbv",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({\n  native,\n  textClassName,\n  className,\n  children,\n}: AsideType) => {\n  const tailwind = useTailwind();\n  const { style, ...nativeWithoutStyle } = native || {};\n  const tailwindStyle = className ? tailwind(trimClassName(className)) : {};\n  return (\n    <View style={[tailwindStyle, style]} {...nativeWithoutStyle}>\n      {wrapInTextIfNeeded(children, textClassName)}\n    </View>\n  );\n}"
  },
  "Button": {
    "name": "Button",
    "slug": "TsFunction",
    "id": "eljtwqwllnhxnytqxaljlsrz",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({\n  native,\n  className,\n  textClassName,\n  ...props\n}: ButtonType) => {\n  return (\n    <button {...props} className={joinClassNames(className, textClassName)} />\n  );\n}"
  },
  "Div": {
    "name": "Div",
    "slug": "TsVariable",
    "id": "mqjctfdrchjvopkmaavakrpk",
    "description": "",
    "operationName": "react-with-native"
  },
  "Form": {
    "name": "Form",
    "slug": "TsFunction",
    "id": "mrvubyawvlsodtocnycctbgz",
    "description": "Form is just a html form on web. On react-native, it's a View",
    "operationName": "react-with-native",
    "rawText": " ({\n  native,\n  className,\n  textClassName,\n  ...props\n}: FormType) => {\n  return (\n    <form {...props} className={joinClassNames(className, textClassName)} />\n  );\n}"
  },
  "getTailwindModules": {
    "name": "getTailwindModules",
    "slug": "TsFunction",
    "id": "ldjajcnczjvyxlthlztzpmov",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " (options: {\n  /**\n   * if you are using a sensible v1 monorepo, put the packages with tailwind-based ui here\n   */\n  packages?: string[] /**\n  if you are using any tailwind-based node-modules, put them here.\n */;\n  modules?: string[];\n  /**\n *  if this is a yarn workspace, put true here\n\n */\n  isWorkspace?: boolean;\n}) => {\n  const packages =\n    options.packages?.map((module) => {\n      return `../../packages/${module}/src/**/*.{ts,tsx,js,jsx}`;\n    }) || [];\n\n  const modules =\n    options.modules?.map((module) => {\n      return options.isWorkspace\n        ? `../../node_modules/${module}/{src,build,dist}/**/*.{ts,tsx,js,jsx}`\n        : `./node_modules/${module}/{src,build,dist}/**/*.{ts,tsx,js,jsx}`;\n    }) || [];\n\n  return packages?.concat(modules);\n}"
  },
  "H2": {
    "name": "H2",
    "slug": "TsFunction",
    "id": "lvamelwitaglwukyscmnwwyw",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, ...props }: H2Type) => {\n  return <h2 {...props} />;\n}"
  },
  "I": {
    "name": "I",
    "slug": "TsFunction",
    "id": "jeorcpzygnlpdqmggxxiwvue",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, ...props }: IType) => {\n  return <i {...props} />;\n}"
  },
  "Image": {
    "name": "Image",
    "slug": "TsFunction",
    "id": "abygyzhdmcdwfzhwfiipojfb",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, ...props }: ImgType) => {\n  //@ts-ignore TODO: what's this?\n  return <img {...props} />;\n}"
  },
  "Input": {
    "name": "Input",
    "slug": "TsFunction",
    "id": "hkrdkhihpsgohkwglaefalrq",
    "description": "",
    "operationName": "react-with-native-form",
    "rawText": " <\n  TInputs extends AllPluginInputTypes,\n  T extends keyof TInputs\n>({\n  type,\n  plugin,\n  title,\n  onChange,\n  value,\n  isLast,\n  startSection,\n  sectionTitle,\n  next,\n  extra,\n  errors,\n  reference,\n  description,\n  config,\n  uniqueFieldId,\n  renderInputContainer,\n  errorClassName,\n  fieldName,\n}: {\n  plugin: PluginComponent<TInputs[T]>;\n  type: string;\n  fieldName: string;\n  config: TInputs[T][\"config\"];\n  extra: TInputs[T][\"extra\"];\n  next: any;\n  title?: string;\n  onChange: OnChange<TInputs[T]>;\n  value: TInputs[T][\"value\"];\n  errors?: Error[];\n  isLast: boolean;\n  startSection?: boolean;\n  sectionTitle?: string;\n  reference?: RefObject<HTMLDivElement>;\n  description?: string;\n  /**\n   * format: {uniqueGeneratedNumber}.{fieldName}\n   */\n  uniqueFieldId: string;\n  renderInputContainer?: RenderInputContainerType;\n  errorClassName?: string;\n}) => {\n  const InputComponent = plugin;\n  const InputContainer = renderInputContainer || DefaultInputContainer;\n  return (\n    <Div ref={reference}>\n      <InputContainer\n        {...{\n          description,\n          sectionTitle,\n          startSection,\n          title,\n          next,\n          isLast,\n          id: uniqueFieldId,\n          type,\n          error:\n            !plugin.hideContainerError &&\n            errors?.find(errorOnField(fieldName))?.message,\n          extra,\n          config,\n          errorClassName,\n        }}\n      >\n        <InputComponent\n          {...{\n            uniqueFieldId,\n            fieldName,\n            config,\n            extra,\n            onChange,\n            value,\n            errors,\n            errorClassName,\n          }}\n        />\n      </InputContainer>\n    </Div>\n  );\n}"
  },
  "joinClassNames": {
    "name": "joinClassNames",
    "slug": "TsFunction",
    "id": "slfrsixqrjqeevpcgbgbovfx",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " (...args: (string | undefined)[]) => {\n  return args.filter((x) => !!x).join(\" \");\n}"
  },
  "Label": {
    "name": "Label",
    "slug": "TsFunction",
    "id": "pfvsxnmwbqfugsfjsgmsetyi",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, ...props }: LabelType) => {\n  return <label {...props} />;\n}"
  },
  "Li": {
    "name": "Li",
    "slug": "TsFunction",
    "id": "bzuuiiwuojcukyapzrptmhvx",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, className, textClassName, ...props }: LiType) => {\n  return <li {...props} className={joinClassNames(className, textClassName)} />;\n}"
  },
  "Nav": {
    "name": "Nav",
    "slug": "TsFunction",
    "id": "bdllurhsrdprulscjsbilrru",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({\n  native,\n  textClassName,\n  className,\n  children,\n}: NavType) => {\n  const tailwind = useTailwind();\n  const { style, ...nativeWithoutStyle } = native || {};\n  const tailwindStyle = className ? tailwind(trimClassName(className)) : {};\n\n  return (\n    <View\n      style={[\n        tailwindStyle,\n        style,\n        {\n          flexDirection: \"row\",\n          alignItems: \"center\",\n          elevation: 0,\n        },\n      ]}\n      {...nativeWithoutStyle}\n    >\n      {wrapInTextIfNeeded(children, textClassName)}\n    </View>\n  );\n}"
  },
  "Ol": {
    "name": "Ol",
    "slug": "TsFunction",
    "id": "usrteyuweenbfrwatfvuxvrd",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, className, textClassName, ...props }: OlType) => {\n  return <ol {...props} className={joinClassNames(className, textClassName)} />;\n}"
  },
  "P": {
    "name": "P",
    "slug": "TsFunction",
    "id": "ukrbkqwtrktjzbcvjxwdwwvj",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, ...props }: PType) => {\n  return <p {...props} />;\n}"
  },
  "Pressable": {
    "name": "Pressable",
    "slug": "TsFunction",
    "id": "unewlcxyyllmxtucfhkqbiao",
    "description": "button on web, pressable on react-native",
    "operationName": "react-with-native",
    "rawText": " ({\n  native,\n  textClassName,\n  className,\n  ...props\n}: PressableType) => {\n  return (\n    <button {...props} className={joinClassNames(className, textClassName)} />\n  );\n}"
  },
  "PureAside": {
    "name": "PureAside",
    "slug": "TsFunction",
    "id": "hdttumxeqbmxygpcpfsajdny",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " (\n  { native, className, textClassName, ...props }: AsideType,\n  ref: any\n) => {\n  return (\n    <aside\n      {...props}\n      ref={ref}\n      className={joinClassNames(className, textClassName)}\n    />\n  );\n}"
  },
  "PureDiv": {
    "name": "PureDiv",
    "slug": "TsFunction",
    "id": "ikbnfmlgcvmutfokrxxjpeex",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " (\n  { native, className, textClassName, scroll, ...props }: DivType,\n  ref: any\n) => {\n  return (\n    <div\n      {...props}\n      ref={ref}\n      className={joinClassNames(className, textClassName)}\n    />\n  );\n}"
  },
  "PureNav": {
    "name": "PureNav",
    "slug": "TsFunction",
    "id": "uhsygvrtgzbplvqkntpjpnlq",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " (\n  { native, className, textClassName, ...props }: NavType,\n  ref: any\n) => {\n  return (\n    <nav\n      {...props}\n      ref={ref}\n      className={joinClassNames(className, textClassName)}\n    />\n  );\n}"
  },
  "Select": {
    "name": "Select",
    "slug": "TsFunction",
    "id": "qulsvfnofediitrtifxlbrmw",
    "description": "renders either a SelectDropdown or SelectDrawer, based on screensize",
    "operationName": "react-with-native-select",
    "rawText": " <T extends unknown>({\n  options,\n  onChange,\n  value,\n  title,\n  containerClassName,\n  selectFirstOption,\n  autoSuggest,\n  //unused atm\n  children,\n  className,\n  noPlaceholder,\n  placeholder,\n  ios,\n}: SelectProps<T>) => {\n  const [temporaryValue, setTemporaryValue] = useState(\"\");\n  const [id] = useState(`list${String(Math.round(Math.random() * 100000))}`);\n\n  const realValue = getRealValue({ value, selectFirstOption, options, title });\n\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/datalist\n\n  const onChangeSelect = (event: ChangeEvent<HTMLSelectElement>) => {\n    const value = event.target.value;\n    const newValue = options.find((x) => String(x.value) === value) || null;\n\n    onChange?.(newValue);\n  };\n\n  const renderOptions = () => {\n    return (\n      <>\n        {options.map((option, index) => {\n          return (\n            <option value={String(option.value)} key={index}>\n              {option.label}\n            </option>\n          );\n        })}\n      </>\n    );\n  };\n\n  return (\n    <div className={containerClassName}>\n      {autoSuggest ? (\n        <span>\n          <input\n            list={id}\n            placeholder={\n              !noPlaceholder ? placeholder || \"Type or select one\" : undefined\n            }\n            onChange={(event) => {\n              const value = event.target.value;\n\n              const foundOption = options.find((x) => x.value === value);\n              if (foundOption) {\n                onChange?.(foundOption);\n                setTemporaryValue(\"\");\n              } else {\n                setTemporaryValue(value);\n              }\n            }}\n            className={className}\n            value={\n              temporaryValue && temporaryValue.length > 0\n                ? temporaryValue\n                : value?.value\n                ? String(value?.value)\n                : \"\"\n            }\n          />\n\n          <datalist placeholder={title} id={id}>\n            {renderOptions()}\n          </datalist>\n        </span>\n      ) : (\n        <select\n          onChange={onChangeSelect}\n          className={className}\n          value={String(value?.value)}\n        >\n          {renderOptions()}\n        </select>\n      )}\n    </div>\n  );\n}"
  },
  "Span": {
    "name": "Span",
    "slug": "TsFunction",
    "id": "rlvxwcsfdamdsnbamdkkqszs",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({\n  native,\n  className,\n  textClassName,\n  ...props\n}: SpanType) => {\n  return (\n    <span {...props} className={joinClassNames(className, textClassName)} />\n  );\n}"
  },
  "Strong": {
    "name": "Strong",
    "slug": "TsFunction",
    "id": "mbwzfxcsoeahmailrwgoquia",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, ...props }: StrongType) => {\n  return <strong {...props} />;\n}"
  },
  "Svg": {
    "name": "Svg",
    "slug": "TsFunction",
    "id": "vaicbqgwshzxeyqktqftxhip",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ src, width, height, className, style }: SvgType) => {\n  const Icon: any = src;\n  return (\n    <Icon width={width} height={height} className={className} style={style} />\n  );\n}"
  },
  "TextArea": {
    "name": "TextArea",
    "slug": "TsFunction",
    "id": "llztwpnkyjximtvjusmupsaz",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({\n  native,\n  className,\n  textClassName,\n  ...props\n}: TextAreaType) => {\n  return (\n    <textarea {...props} className={joinClassNames(className, textClassName)} />\n  );\n}"
  },
  "Text": {
    "name": "Text",
    "slug": "TsFunction",
    "id": "omjgfrarkgigaadrxsxbauea",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, ...props }: TextType) => {\n  return <p {...props} />;\n}"
  },
  "Toggle": {
    "name": "Toggle",
    "slug": "TsFunction",
    "id": "gdoaucmxkdhvbyduvrsyqnww",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, onChange, checked, ...props }: ToggleType) => {\n  return (\n    <input\n      type=\"checkbox\"\n      checked={checked}\n      onChange={(e) => onChange(e.target.checked)}\n      {...props}\n    />\n  );\n}"
  },
  "TouchableOpacity": {
    "name": "TouchableOpacity",
    "slug": "TsFunction",
    "id": "yrhqyepcssnyzxuvoywbaory",
    "description": "button on web, pressable on react-native",
    "operationName": "react-with-native",
    "rawText": " ({\n  native,\n  textClassName,\n  className,\n  ...props\n}: TouchableOpacityType) => {\n  return (\n    <button {...props} className={joinClassNames(className, textClassName)} />\n  );\n}"
  },
  "trimClassName": {
    "name": "trimClassName",
    "slug": "TsFunction",
    "id": "rdpnkrvhjhpysznqfdfxruos",
    "description": "in react-native not all classNames are supported",
    "operationName": "react-with-native",
    "rawText": " (className: string) => {\n  return className;\n}"
  },
  "Ul": {
    "name": "Ul",
    "slug": "TsFunction",
    "id": "zcjmjkdqfpdharmvxtyxtoim",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, className, textClassName, ...props }: UlType) => {\n  return <ul {...props} className={joinClassNames(className, textClassName)} />;\n}"
  },
  "wrapInTextIfNeeded": {
    "name": "wrapInTextIfNeeded",
    "slug": "TsFunction",
    "id": "qogrhpwbycvvyfwqampjfnio",
    "description": "NB: figure out a way to do the styles of the text right.",
    "operationName": "react-with-native",
    "rawText": " (children: any, textClassName?: string) => {\n  return typeof children === \"string\" ? (\n    <Text className={textClassName}>{children}</Text>\n  ) : (\n    children\n  );\n}"
  },
  "AlertContext": {
    "name": "AlertContext",
    "slug": "TsVariable",
    "id": "xdaljblzsaefcfxelhrtqqnl",
    "description": "",
    "operationName": "react-with-native-alert"
  },
  "AlertProvider": {
    "name": "AlertProvider",
    "slug": "TsFunction",
    "id": "hmcerlluupcxvhscytzosmaz",
    "description": "",
    "operationName": "react-with-native-alert",
    "rawText": " ({ children }: { children: any }) => {\n  // console.log(\"normal alertprovider\");\n  const [alertState, setAlertState] = useState<AlertState[]>([]);\n\n  const firstAlert: AlertState | undefined = alertState[0];\n\n  // console.log({ firstAlert, alertState });\n  const alert: AlertFn = (title, message, buttons, options) => {\n    const newState = { title, message, buttons, options };\n    const newAlertState = alertState.concat([newState]);\n\n    // console.log(\"push alert state\", { newState, alertState, newAlertState });\n    setAlertState(newAlertState);\n  };\n\n  const renderAlert = (firstAlert: AlertState | undefined) => {\n    if (!firstAlert) {\n      // console.log(\"HMMMM\");\n      return null;\n    }\n\n    // console.log(\"Should render alert\");\n\n    const { title, buttons, message, options } = firstAlert;\n\n    const value = undefined; //TODO: make it possible to fill in value here (prompt-alert)\n\n    return (\n      <div className=\"absolute w-screen h-screen inset-0\">\n        <Transition appear show={true} as={Fragment}>\n          <HeadlessUiDialog\n            as=\"div\"\n            className=\"fixed inset-0 z-50 overflow-y-auto backdrop-blur-sm\"\n            onClose={() => {\n              if (options?.cancelable === false) return;\n\n              options?.onDismiss?.();\n\n              setAlertState(alertState.slice(1));\n            }}\n          >\n            <div className=\"min-h-screen px-4 text-center\">\n              <Transition.Child\n                as={Fragment}\n                enter=\"ease-out duration-300\"\n                enterFrom=\"opacity-0\"\n                enterTo=\"opacity-100\"\n                leave=\"ease-in duration-200\"\n                leaveFrom=\"opacity-100\"\n                leaveTo=\"opacity-0\"\n              >\n                <HeadlessUiDialog.Overlay className=\"fixed inset-0\" />\n              </Transition.Child>\n\n              {/* This element is to trick the browser into centering the modal contents. */}\n              <span\n                className=\"inline-block h-screen align-middle\"\n                aria-hidden=\"true\"\n              >\n                &#8203;\n              </span>\n              <Transition.Child\n                as={Fragment}\n                enter=\"ease-out duration-300\"\n                enterFrom=\"opacity-0 scale-95\"\n                enterTo=\"opacity-100 scale-100\"\n                leave=\"ease-in duration-200\"\n                leaveFrom=\"opacity-100 scale-100\"\n                leaveTo=\"opacity-0 scale-95\"\n              >\n                <Div\n                  className={\n                    \"inline-block w-full max-w-lg p-6 my-8 overflow-hidden text-left align-middle transition-all transform bg-white shadow-xl rounded-2xl\"\n                  }\n                >\n                  {title ? (\n                    <HeadlessUiDialog.Title\n                      as=\"h3\"\n                      className={\"text-lg font-medium leading-6 text-gray-900\"}\n                    >\n                      {title}\n                    </HeadlessUiDialog.Title>\n                  ) : null}\n                  <P className=\"py-6\">{message}</P>\n                  <Div className=\"flex flex-row gap-4\">\n                    {buttons?.map((button, index) => {\n                      const buttonColor =\n                        button.style === \"cancel\"\n                          ? \"bg-gray-300 hover:bg-gray-400\"\n                          : button.style === \"destructive\"\n                          ? \"bg-red-500 hover:bg-red-600\"\n                          : \"bg-blue-500 hover:bg-blue-600\";\n                      return (\n                        <Div\n                          onClick={() => {\n                            button.onPress?.(value);\n                            setAlertState(alertState.slice(1));\n                          }}\n                          key={`button${index}`}\n                          className={`cursor-pointer py-2 ${buttonColor} rounded-md flex flex-1 items-center justify-center`}\n                        >\n                          {button.text}\n                        </Div>\n                      );\n                    })}\n                  </Div>\n                </Div>\n              </Transition.Child>\n            </div>\n          </HeadlessUiDialog>\n        </Transition>\n      </div>\n    );\n  };\n\n  return (\n    <AlertContext.Provider value={alert}>\n      {renderAlert(firstAlert)}\n      {children}\n    </AlertContext.Provider>\n  );\n}"
  },
  "useAlert": {
    "name": "useAlert",
    "slug": "TsFunction",
    "id": "jxfuuschowpvqpzzdafobljj",
    "description": "",
    "operationName": "react-with-native-alert",
    "rawText": " () => {\n  const alert = React.useContext(AlertContext);\n  return alert;\n}"
  },
  "DataForm": {
    "name": "DataForm",
    "slug": "TsFunction",
    "id": "qtbnfwplrsohdliytdkryucf",
    "description": "",
    "operationName": "react-with-native-form",
    "rawText": " <TInputs, TState extends { [key: string]: any }>({\n  fields,\n  defaultValues,\n  initialValues,\n  onSubmit,\n  withSubmitProps,\n  noSubmit,\n  submitButtonText,\n  submitButtonColor,\n  title,\n  backButton,\n  plugins,\n  renderSubmitComponent,\n  renderInputContainer,\n  stickySubmit,\n  renderTitle,\n  submitClassName,\n  errorClassName,\n  successClassName,\n}: DataFormProps<TInputs, TState>) => {\n  //sometimes use defaultValues (deprecated)\n\n  initialValues = initialValues ? initialValues : defaultValues;\n  if (!plugins) {\n    throw new Error(\"No plugins given\");\n  }\n  //Generate unique id for the form\n  const [id] = useState(`Form${String(Math.round(Math.random() * 1000000))}`);\n\n  const [fieldsWithReferences, setFieldsWithReferences] = useState<\n    ExtendedField<TInputs, Keys<TInputs>>[]\n  >([]);\n\n  // need to have because we want to see when it's changed\n  const [fieldsWithoutReferences, setFieldsWithoutReferences] = useState<\n    Field<TInputs, Keys<TInputs>>[]\n  >([]);\n\n  useEffect(() => {\n    const fieldsWithoutReferencesLocal = fields.map((f) => f());\n\n    if (\n      // fieldsWithoutReferences.length === 0 && //NB: why was this here? caused the fields not to refresh\n      !sameFieldArray<Field<TInputs, Keys<TInputs>>[], TInputs>(\n        fieldsWithoutReferencesLocal,\n        fieldsWithoutReferences\n      )\n    ) {\n      setFieldsWithReferences(\n        fieldsWithoutReferencesLocal.map((fieldWithoutReference) => {\n          return {\n            ...fieldWithoutReference,\n            reference: createRef<HTMLDivElement>(),\n          };\n        })\n      );\n      setFieldsWithoutReferences(fieldsWithoutReferencesLocal);\n    }\n  }, [fields]);\n\n  const initialValuesPartial: TState = fields.reduce((all, field) => {\n    const type = field().type!;\n    const plugin = getPlugin(type, plugins);\n    const defaultInital = plugin.component.defaultInitialValue;\n    const initial = field().initialValue;\n    const key = field().field;\n    const value =\n      initial !== undefined\n        ? initial\n        : defaultInital !== undefined\n        ? defaultInital\n        : undefined;\n\n    return {\n      ...all,\n      [key]: value,\n    };\n  }, {}) as TState;\n\n  const initialState = { ...initialValuesPartial, ...initialValues };\n\n  const [state, setState] = useState<TState>(initialState);\n\n  //used to check if the initialValues have changed\n  const [initialValuesState, setInitialValuesState] = useState<\n    TState | undefined\n  >();\n\n  useEffect(() => {\n    if (!initialValuesState || !deepEqual(initialState, initialValuesState)) {\n      // console.log(\"initialValues have changed\");\n      setState(initialState);\n      setInitialValuesState(initialState);\n    }\n  }, [initialState]);\n\n  const [loading, setLoading] = useState(false);\n\n  const [errors, setErrors] = useState<Error[]>([]);\n  const [success, setSuccess] = useState<string | undefined>();\n\n  const notReadyFields = fieldsWithReferences.filter(\n    (x) => !x.shouldHide?.(state) && x.hasError?.(state[x.field], state)\n  );\n\n  const setErrorsReject: RejectType = (stringOrErrorArray) => {\n    if (stringOrErrorArray) {\n      //if the rejection provides a string, just return an array with 1 element: that string, on the global property path\n      //however, if it's an error array, return that. But make sure that if the propertyPath doesn't exist, it's still rendered globally.\n      const newErrors: Error[] =\n        typeof stringOrErrorArray === \"string\"\n          ? [\n              {\n                propertyPath: GLOBAL_PROPERTY_PATH,\n                message: stringOrErrorArray,\n              },\n            ]\n          : stringOrErrorArray.map(({ propertyPath, message }) => ({\n              message,\n              propertyPath: fields\n                .map((f) => f().field)\n                .find(\n                  (x) => propertyPath === x || propertyPath.startsWith(`${x}.`)\n                )\n                ? propertyPath\n                : GLOBAL_PROPERTY_PATH,\n            }));\n\n      //this only happens when there are no frontend errors, so it's safe to replace errors\n      setErrors(newErrors);\n\n      //scroll to the first field that contains an error\n      const firstNotReadyField = fieldsWithReferences.filter(\n        (x) => newErrors.find(errorOnField(x.field)) !== undefined\n      )[0];\n\n      if (isWeb) {\n        const top =\n          (firstNotReadyField?.reference?.current?.getBoundingClientRect?.()\n            .top || 0) +\n          (window.scrollY || 0) -\n          100;\n\n        // console.log(\"setErrorsReject: scrolling to first error field\");\n\n        window.scrollTo?.({\n          top,\n          behavior: \"smooth\",\n        });\n      }\n    }\n  };\n\n  const firstErrorRef = notReadyFields[0]?.reference?.current;\n\n  function onClickSubmit(state: TState) {\n    const frontendErrorArray = fields.reduce((all, field) => {\n      const shouldNotHide = !field().shouldHide?.(state);\n      const errorMessage = field().hasError?.(state[field().field], state);\n      const hasError = shouldNotHide && errorMessage;\n\n      const errors =\n        typeof hasError === \"string\"\n          ? [{ propertyPath: field().field, message: hasError }]\n          : Array.isArray(hasError)\n          ? hasError\n          : [];\n\n      return [...all, ...errors];\n    }, [] as Error[]);\n\n    setErrors(frontendErrorArray);\n    //\n    if (frontendErrorArray?.length === 0) {\n      //no errors\n\n      setLoading(true);\n      onSubmit(\n        state,\n        (successMessage) => {\n          setSuccess(successMessage);\n          setLoading(false);\n        },\n        (stringOrErrorArray) => {\n          setErrorsReject(stringOrErrorArray);\n          setLoading(false);\n        }\n      );\n    } else {\n      //scroll to the error\n      /// onError(\"Please fill in all fields correctly\");\n\n      if (isWeb) {\n        const top =\n          (firstErrorRef?.getBoundingClientRect().top || 0) +\n          window.scrollY -\n          100;\n        // console.log(\"onClickSubmit: scrolling to first error field\");\n\n        window.scrollTo?.({\n          top,\n          behavior: \"smooth\",\n        });\n      }\n    }\n  }\n\n  const available = !loading && notReadyFields.length === 0;\n\n  const submitProps: SubmitProps = {\n    loading,\n    available,\n    submitButtonText,\n    submitButtonColor,\n    //should be overwritten on state change\n    onSubmit: () => onClickSubmit(state),\n    state,\n  };\n\n  useEffect(() => {\n    //console.log({ withSubmitProps: submitProps });\n    withSubmitProps?.(submitProps);\n  }, [loading, available, submitButtonText, submitButtonColor, firstErrorRef]);\n\n  const Title = renderTitle || DefaultTitle;\n\n  const Submit = () =>\n    noSubmit ? null : renderSubmitComponent ? (\n      renderSubmitComponent(submitProps)\n    ) : (\n      <Button\n        disabled={loading}\n        className={`${\n          available\n            ? `${submitButtonColor ? submitButtonColor : \"bg-green-500\"}`\n            : \"bg-gray-300\"\n        }  flex justify-center flex-row w-full px-4 py-2 text-sm font-medium text-white border border-transparent rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500`}\n        onClick={() => onClickSubmit(state)}\n        //......Extra\n        style={{\n          backgroundColor: \"#4ade80\",\n          color: \"white\",\n          width: \"100%\",\n          marginTop: 5,\n          marginBottom: 5,\n          display: \"flex\",\n          justifyContent: \"center\",\n          borderRadius: 10,\n          alignItems: \"center\",\n          borderColor: \"white\",\n          padding: 8,\n        }}\n      >\n        {loading ? (\n          <Div className=\"mr-2\">\n            <ActivityIndicator />\n          </Div>\n        ) : null}\n        <Label style={{ color: \"white\", fontWeight: \"bold\" }}>\n          {submitButtonText || \"Save\"}\n        </Label>\n      </Button>\n    );\n  const globalError = errors?.find(\n    (x) => x.propertyPath === GLOBAL_PROPERTY_PATH\n  );\n  return (\n    <Form\n      className=\"w-full\"\n      onSubmit={(e) => {\n        e.preventDefault();\n        onClickSubmit(state);\n      }}\n    >\n      <Div className=\"w-full\">\n        <Title title={title} backButton={backButton} />\n\n        {success ? <P className={successClassName}>{success}</P> : null}\n        {globalError ? (\n          <P className={errorClassName || \"text-red-600\"}>\n            {globalError.message}\n          </P>\n        ) : null}\n\n        {fieldsWithReferences.map((field, index) => {\n          // Take the first plugin if the plugin isn't defined.\n          const plugin = getPlugin(field.type, plugins);\n\n          if (!plugin) {\n            return (\n              <P>\n                Plugin not found ({field.field}, {field.type})\n              </P>\n            );\n          }\n\n          const next = fields[index + 1]?.();\n\n          const onChange = (state: TState) => (newValue: any) => {\n            const newState = { [field.field]: newValue };\n            const newFullState = { ...state, ...newState };\n            const fieldErrors = errors.filter(errorOnField(field.field));\n\n            //check if field still has error(s)\n            const newFieldErrors = field.hasError?.(newValue, newFullState);\n            const newFieldErrorsAmount =\n              typeof newFieldErrors === \"string\"\n                ? 1\n                : Array.isArray(newFieldErrors)\n                ? newFieldErrors.length\n                : 0;\n            if (\n              fieldErrors.length > 0 &&\n              newFieldErrorsAmount !== fieldErrors.length\n            ) {\n              const newErrors = errors.filter(\n                (error) => !errorOnField(field.field)(error)\n              );\n              const newFieldErrorsArray: Error[] =\n                typeof newFieldErrors === \"string\"\n                  ? [{ message: newFieldErrors, propertyPath: field.field }]\n                  : Array.isArray(newFieldErrors)\n                  ? newFieldErrors\n                  : [];\n\n              setErrors([...newErrors, ...newFieldErrorsArray]);\n            }\n\n            setState(newFullState);\n            //NB: make sure to add the new state to the submitprops\n            withSubmitProps?.({\n              ...submitProps,\n              state: newFullState,\n              onSubmit: () => onClickSubmit(newFullState),\n            });\n          };\n\n          const uniqueFieldId = `${id || \"\"}.${field.field}`;\n\n          const inputErrors = errors.filter(\n            (e) =>\n              e.propertyPath === field.field ||\n              e.propertyPath.startsWith(`${field.field}.`)\n          );\n\n          return field.shouldHide?.(state) ? null : (\n            <Input\n              fieldName={field.field}\n              renderInputContainer={renderInputContainer}\n              uniqueFieldId={uniqueFieldId}\n              config={plugin.config}\n              plugin={plugin.component}\n              extra={field.extra}\n              reference={field.reference}\n              next={next}\n              key={`field-${field.field}`}\n              type={field.type!}\n              title={\n                field.titleFromState ? field.titleFromState(state) : field.title\n              }\n              value={state[field.field]}\n              onChange={onChange(state)}\n              isLast={index === fields?.length - 1}\n              startSection={field.startSection}\n              sectionTitle={field.sectionTitle}\n              description={field.description}\n              errors={inputErrors}\n            />\n          );\n        })}\n      </Div>\n      {Submit ? (\n        <Div\n          className={`${stickySubmit ? \"sticky bottom-0\" : \"\"} ${\n            submitClassName || \"mb-2 py-2\"\n          }`}\n        >\n          <Submit />\n        </Div>\n      ) : null}\n    </Form>\n  );\n}"
  },
  "DefaultInputContainer": {
    "name": "DefaultInputContainer",
    "slug": "TsFunction",
    "id": "gtmbcwnbzpdrngdoiwbbppmy",
    "description": "",
    "operationName": "react-with-native-form",
    "rawText": " ({\n  children,\n  startSection,\n  sectionTitle,\n  title,\n  description,\n  error,\n  errorClassName,\n}: InputContainerProps) => (\n  <Div>\n    {startSection ? (\n      <Div\n        style={{\n          display: \"flex\",\n          height: 40,\n          justifyContent: \"center\",\n          paddingLeft: 10,\n        }}\n      >\n        {sectionTitle ? (\n          <P>\n            <Strong>{sectionTitle}</Strong>\n          </P>\n        ) : (\n          <Div style={{ height: 40 }} />\n        )}\n      </Div>\n    ) : null}\n\n    {/* This is the section title */}\n    <Div className=\"pt-0 mb-6\" style={{ marginBottom: 10 }}>\n      {title ? <Label className=\"mb-2 text-sm font-bold\">{title}</Label> : null}\n      {description && (\n        <Div className={`flex mx-3 mb-2 items-start `}>\n          <P className={`text-gray-500 italic`}>{description}</P>\n        </Div>\n      )}\n      {error ? (\n        <P className={errorClassName || `mr-3 mb-2 text-red-500`}>\n          {error || \"Invalid value\"}\n        </P>\n      ) : null}\n\n      <Div>{children}</Div>\n    </Div>\n  </Div>\n)"
  },
  "DefaultTitle": {
    "name": "DefaultTitle",
    "slug": "TsFunction",
    "id": "edilrintrbwdnmvatbmrhlnk",
    "description": "",
    "operationName": "react-with-native-form",
    "rawText": " ({\n  title,\n  backButton,\n}: {\n  title?: string;\n  backButton?: () => void;\n}) => {\n  return title ? (\n    <Div className=\"flex items-center mb-10 \">\n      {backButton && (\n        <Div onClick={backButton} className={`p-4 cursor-pointer`}>\n          back\n        </Div>\n      )}\n      <H2 className=\"text-2xl font-bold\">{title}</H2>\n    </Div>\n  ) : null;\n}"
  },
  "errorOnField": {
    "name": "errorOnField",
    "slug": "TsFunction",
    "id": "wtsrrvmabznkogqktrmgfded",
    "description": "",
    "operationName": "react-with-native-form",
    "rawText": " (fieldName: string) => (error: Error) =>\n  error.propertyPath === fieldName ||\n  error.propertyPath.startsWith(fieldName + \".\")"
  },
  "getPlugin": {
    "name": "getPlugin",
    "slug": "TsFunction",
    "id": "anmjhjdkmxqentvwnqfiytiw",
    "description": "",
    "operationName": "react-with-native-form",
    "rawText": " <TInputs extends AllPluginInputTypes>(\n  type: string | undefined,\n  plugins: Plugins<TInputs>\n) => {\n  return type\n    ? plugins[type]\n    : plugins[Object.keys(plugins)[0] as keyof Plugins<TInputs>];\n}"
  },
  "GLOBAL_PROPERTY_PATH": {
    "name": "GLOBAL_PROPERTY_PATH",
    "slug": "TsVariable",
    "id": "uadijaoytgigmfzismqobegi",
    "description": "",
    "operationName": "react-with-native-form"
  },
  "inputClassWithoutWidth": {
    "name": "inputClassWithoutWidth",
    "slug": "TsVariable",
    "id": "jsaazqkyxvgtdacbmrjlfyef",
    "description": "",
    "operationName": "react-with-native-form"
  },
  "isWeb": {
    "name": "isWeb",
    "slug": "TsVariable",
    "id": "xroiktbqahauxqldkynoympo",
    "description": "",
    "operationName": "react-with-native-form"
  },
  "makeInputField": {
    "name": "makeInputField",
    "slug": "TsFunction",
    "id": "mzmufixxtqmhxckrroquytgh",
    "description": "",
    "operationName": "react-with-native-form",
    "rawText": " <TInputs, T extends Keys<TInputs>>(\n  type: T,\n  config: Omit<Field<TInputs, T>, \"type\">\n) => {\n  return () => ({ type, ...config });\n}"
  },
  "sameFieldArray": {
    "name": "sameFieldArray",
    "slug": "TsFunction",
    "id": "nzlurzgxukzntwdtuihizmhc",
    "description": "",
    "operationName": "react-with-native-form",
    "rawText": " <\n  T extends Field<TInputs, Keys<TInputs>>[],\n  TInputs extends any\n>(\n  arr1: T,\n  arr2: T\n) => {\n  const simpleArr1 = arr1.map(\n    ({ shouldHide, titleFromState, hasError, ...item }) => item\n  );\n  const simpleArr2 = arr2.map(\n    ({ shouldHide, titleFromState, hasError, ...item }) => item\n  );\n\n  const isDeepEqual = deepEqual(simpleArr1, simpleArr2);\n  // console.log({ simpleArr1, simpleArr2, isDeepEqual });\n  return isDeepEqual;\n}"
  },
  "InputSize": {
    "name": "InputSize",
    "slug": "TsVariable",
    "id": "armxhfuknmzlneigkqkiuroo",
    "description": "Inheritance of different button themes",
    "operationName": "react-with-native-form-asset-input"
  },
  "InputTheme": {
    "name": "InputTheme",
    "slug": "TsVariable",
    "id": "dbwzalbysedklgrdvcuimeen",
    "description": "Inheritance of different button themes",
    "operationName": "react-with-native-form-asset-input"
  },
  "castToNumber": {
    "name": "castToNumber",
    "slug": "TsFunction",
    "id": "xxvxjghsacpdqjexwblcqghc",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " (\n  numberString: string | null | undefined\n): null | undefined | number => {\n  if (numberString === null) return null;\n  if (numberString === undefined) return undefined;\n  if (numberString === \"\") return undefined;\n\n  const number = Number(numberString);\n\n  if (isNaN(number)) return undefined;\n\n  return number;\n}"
  },
  "DateInput": {
    "name": "DateInput",
    "slug": "TsFunction",
    "id": "vysiodmjztptjyudogkipqcf",
    "description": "CSS Modules, react-datepicker-cssmodules.css",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  value,\n  onChange,\n}) => {\n  return (\n    <DatePicker\n      selected={value}\n      onChange={(date: Date) => {\n        console.log(\"date\", date);\n        onChange(date);\n      }}\n      dateFormat=\"dd-MM-yyyy\"\n      className={UI.dateInput}\n    />\n  );\n}"
  },
  "DatetimeInput": {
    "name": "DatetimeInput",
    "slug": "TsFunction",
    "id": "klqgvtvqofofhwgatiikuwwu",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  extra,\n  value,\n  onChange,\n  ...props\n}) => {\n  const newExtra: DatetimeInputType[\"extra\"] = { ...extra, type: \"dateTime\" };\n  const [date, setDate] = useState<Date>(new Date());\n  //return <TextInput {...props} extra={newExtra} />;\n  const handleChange = (date: any) => {\n    console.warn(\"A date has been picked: \", date);\n    setDate(date);\n    onChange(date);\n  };\n  return (\n    <div>\n      {/* <div>Selected date: </div> */}\n      {/* <div>{date && date.toDateString() + ` ` + date.toLocaleTimeString()}</div> */}\n      {\n        // @ts-ignore\n        <Datetime\n          {...props}\n          value={value ? new Date(value) : new Date()}\n          initialValue={date}\n          onChange={(value: any) => {\n            handleChange(new Date(value));\n          }}\n          className={UI.dateInput}\n        />\n      }\n    </div>\n  );\n}"
  },
  "defaultLatidue": {
    "name": "defaultLatidue",
    "slug": "TsVariable",
    "id": "rwcyzacfdfjlktkeqxdmeysp",
    "description": "",
    "operationName": "react-with-native-form-inputs"
  },
  "defaultLongitude": {
    "name": "defaultLongitude",
    "slug": "TsVariable",
    "id": "enfxmuezzrofmxekmlrfugxm",
    "description": "",
    "operationName": "react-with-native-form-inputs"
  },
  "defaultZoom": {
    "name": "defaultZoom",
    "slug": "TsVariable",
    "id": "wfucevhiaowqxzouifxxzupe",
    "description": "",
    "operationName": "react-with-native-form-inputs"
  },
  "isNumber": {
    "name": "isNumber",
    "slug": "TsFunction",
    "id": "ndxsdejkrkmplfniegrmyjpd",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " (numberString: string | null | undefined) => {\n  if (\n    numberString === null ||\n    numberString === undefined ||\n    numberString === \"\"\n  )\n    return false;\n\n  if (isNaN(Number(numberString))) return false;\n\n  return true;\n}"
  },
  "LabelsInput": {
    "name": "LabelsInput",
    "slug": "TsFunction",
    "id": "tfrxqenyvjhrorwtbznredwm",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  value,\n  extra,\n  onChange,\n  uniqueFieldId,\n}) => {\n  const [textValue, setTextValue] = useState(\"\");\n\n  const processText = (text: string) => {\n    if (text.endsWith(\",\")) {\n      const newValue = value;\n      const trimmedText = text.slice(0, text.length - 1).trim();\n      if (!value.includes(trimmedText)) {\n        value.push(trimmedText);\n      }\n      onChange(newValue);\n      setTextValue(\"\");\n    } else {\n      setTextValue(text);\n    }\n  };\n\n  return (\n    <Div className=\"flex flex-row flex-wrap\">\n      {value.map((text, index) => (\n        <Button\n          onClick={() => {\n            const newValue = value.filter((x) => x !== text);\n            onChange(newValue);\n          }}\n          key={`selected${uniqueFieldId}${index}`}\n          className={`mr-3 px-3 py-2 rounded-md border border-gray-400`}\n        >\n          <P>\n            {text} <Span textClassName=\"text-red-500\">(x)</Span>\n          </P>\n        </Button>\n      ))}\n\n      <Input\n        className={`${UI.bareInput} py-3`}\n        onChange={({ target: { value: text } }) => processText(text)}\n        value={textValue}\n        native={{ onChangeText: processText }}\n      />\n    </Div>\n  );\n}"
  },
  "MapInput": {
    "name": "MapInput",
    "slug": "TsFunction",
    "id": "xfgxconojlzbhxxuqjejdqgy",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  value,\n  onChange,\n  extra,\n  config,\n}) => {\n  //amsterdam\n  const mapRef = useRef<MapRef>(null);\n  const [search, setSearch] = useState(\"\");\n  const [suggestions, setSuggestions] = useState<Suggestion[]>([]);\n  const [viewport, setViewport] = useState({\n    width: \"100%\",\n    height: 300,\n    latitude: value?.latitude,\n    longitude: value?.longitude,\n    zoom: value?.zoom,\n  });\n\n  // Teach Autosuggest how to calculate suggestions for any given input value.\n  const getSuggestions = async (value: string): Promise<Suggestion[]> => {\n    const inputValue = value.trim().toLowerCase();\n\n    if (inputValue?.length === 0) {\n      return [];\n    }\n\n    const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${inputValue}.json?access_token=${config?.mapboxKey}&limit=4`;\n\n    const suggestions = await fetch(url, {\n      method: \"GET\",\n      headers: {\n        Accept: \"application/json\",\n        \"Content-Type\": \"application/json\",\n        // \"User-Agent\": \"*\",\n      },\n    })\n      .then((response) => response.json())\n      .then((response) => {\n        return response;\n      })\n      .catch((error) => {\n        console.error(error);\n      });\n\n    return inputValue?.length === 0 ? [] : suggestions?.features || [];\n  };\n\n  // const debouncedGetSuggestions = useMemo(\n  //   () => debounce(getSuggestions, 2000, { trailing: true }),\n  //   []\n  // );\n\n  // When suggestion is clicked, Autosuggest needs to populate the input\n  // based on the clicked suggestion. Teach Autosuggest how to calculate the\n  // input value for every given suggestion.\n  const getSuggestionValue = (suggestion: Suggestion) => suggestion.place_name;\n\n  // Use your imagination to render suggestions.\n  const renderSuggestion = (suggestion: Suggestion) => {\n    const text = suggestion.place_name;\n\n    return (\n      <div className={`bg-white hover:bg-gray-200 p-4`}>\n        {text?.length > 30 ? text.slice(0, 28) + \"..\" : text}\n      </div>\n    );\n  };\n  const inputProps = {\n    placeholder: \"Find your place\",\n    value: search,\n    onChange: (e: any, { newValue }: { newValue: string }) =>\n      setSearch(newValue),\n  };\n\n  // Autosuggest will call this function every time you need to update suggestions.\n  // You already implemented this logic above, so just use it.\n  const onSuggestionsFetchRequested = async ({ value }: { value: string }) => {\n    const newSuggestions = await getSuggestions(value);\n    if (newSuggestions) {\n      setSuggestions(newSuggestions);\n    }\n  };\n\n  // Autosuggest will call this function every time you need to clear suggestions.\n  const onSuggestionsClearRequested = () => {\n    setSuggestions([]);\n  };\n\n  const selectSuggestion = (_: any, suggestion: { suggestion: Suggestion }) => {\n    const latitude = suggestion.suggestion.center[1];\n    const longitude = suggestion.suggestion.center[0];\n\n    console.log(\"sugg\", suggestion.suggestion);\n    let zoom = 14;\n    if (suggestion.suggestion.bbox) {\n      const latDiff =\n        suggestion.suggestion.bbox[3] - suggestion.suggestion.bbox[1];\n      const lngDiff =\n        suggestion.suggestion.bbox[2] - suggestion.suggestion.bbox[0];\n\n      const avgDiff = (latDiff + lngDiff) / 2;\n\n      zoom = Math.round(Math.log(2500 / avgDiff));\n    }\n\n    const nextViewport: ViewPort = {\n      width: \"100%\",\n      height: 300,\n      latitude,\n      longitude,\n      zoom: zoom,\n    };\n    //@ts-ignore\n    setViewport(nextViewport);\n\n    onChange({\n      latitude: nextViewport.latitude as number,\n      longitude: nextViewport.longitude,\n      zoom: nextViewport?.zoom,\n    });\n  };\n\n  return (\n    <div className={`w-full bg-white border rounded-lg`}>\n      <div className={`w-full bg-white`}>\n        {/* <ReactMapGL\n          doubleClickZoom={false}\n          ref={mapRef}\n          mapStyle=\"mapbox://styles/picozzimichele/ckty78kzo0q4t17qubs9yi8ok\"\n          // className={`w-full h-40`}\n          mapboxAccessToken=\"\"={config?.mapboxKey}\n          {...viewport}\n          // TODO: Fix this, doesn't seem to exist anymore\n          // onViewportChange={(nextViewport: ViewPort | undefined) => {\n          //   //@ts-ignore\n          //   setViewport(nextViewport);\n          //   onChange({\n          //     latitude: nextViewport?.latitude as number,\n          //     longitude: nextViewport?.longitude as number,\n          //     zoom: nextViewport?.zoom as number,\n          //   });\n          // }}\n        ><div>\n          <div\n            onClick={() => {\n              setViewport({ ...viewport, zoom: viewport.zoom + 1 });\n              onChange({\n                latitude: value?.latitude as number,\n                longitude: value?.longitude,\n                zoom: viewport?.zoom + 1,\n              });\n            }}\n            className={`z-10 cursor-pointer absolute top-4 right-4 w-10 h-10 bg-white rounded flex justify-center items-center`}\n          >\n            +\n          </div>\n\n          <div\n            onClick={() => {\n              setViewport({ ...viewport, zoom: viewport.zoom - 1 });\n              onChange({\n                latitude: value?.latitude as number,\n                longitude: value?.longitude,\n                zoom: viewport?.zoom - 1,\n              });\n            }}\n            className={`z-10 cursor-pointer absolute top-16 right-4 w-10 h-10 bg-white rounded flex justify-center items-center`}\n          >\n            -\n          </div>\n\n          <div className={`z-10 absolute top-4 left-0 bg-white mx-10`}>\n            <Autosuggest\n              suggestions={suggestions}\n              onSuggestionsFetchRequested={onSuggestionsFetchRequested}\n              onSuggestionsClearRequested={onSuggestionsClearRequested}\n              getSuggestionValue={getSuggestionValue}\n              renderSuggestion={renderSuggestion}\n              onSuggestionSelected={selectSuggestion}\n              // renderSuggestionsContainer={({ children }) => {\n              //   return <div className={`h-60 overflow-scroll`}>{children}</div>;\n              // }}\n              inputProps={inputProps}\n            />\n          </div>\n          {value && value.latitude && value.longitude && extra?.showMarker && (\n            <Marker\n              latitude={value.latitude}\n              longitude={value.longitude}\n              offsetLeft={0}\n              offsetTop={0}\n            >\n              <p className=\"text-2xl cursor-pointer animate-bounce\">\n                <Svg\n                  src={HiOutlineLocationMarker}\n                  className=\"h-6 text-blue-500\"\n                />\n              </p>\n            </Marker>\n          )}\n          </div>\n        </ReactMapGL> */}\n      </div>\n      <div className={`m-3`}>\n        <p>\n          <strong>Latitude:</strong> {value?.latitude?.toFixed(4)}\n        </p>\n        <p>\n          <strong>Longitude:</strong> {value?.longitude?.toFixed(4)}\n        </p>\n        {extra?.showZoom && (\n          <p>\n            <strong>Zoom:</strong> {value?.zoom?.toFixed(1)}\n          </p>\n        )}\n      </div>\n    </div>\n  );\n}"
  },
  "NumberInput": {
    "name": "NumberInput",
    "slug": "TsFunction",
    "id": "oxhhrlzuwdkgqofbicyiilhp",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  extra,\n  onChange,\n  value,\n  ...props\n}) => {\n  const stringifiedValue =\n    value === null || value === undefined ? \"\" : String(value);\n\n  const [numberStringValue, setNumberStringValue] = useState(stringifiedValue);\n\n  const newExtra: NumberInputType[\"extra\"] = { type: \"text\", ...extra };\n\n  return (\n    <TextInput\n      {...props}\n      value={numberStringValue}\n      onChange={(value) => {\n        setNumberStringValue(value);\n\n        if (isNumber(value)) {\n          const casted = castToNumber(value);\n          onChange(casted);\n        }\n      }}\n      extra={newExtra}\n    />\n  );\n}"
  },
  "PasswordInput": {
    "name": "PasswordInput",
    "slug": "TsFunction",
    "id": "trvekmfoydyjiyrnjqdsonrg",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  extra,\n  ...props\n}) => {\n  const newExtra: PasswordInputType[\"extra\"] = { ...extra, isPassword: true };\n  return <TextInput {...props} extra={newExtra} />;\n}"
  },
  "PhoneInput": {
    "name": "PhoneInput",
    "slug": "TsFunction",
    "id": "qfzihggujulrxwhxqjythkvz",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  extra,\n  ...props\n}) => {\n  const newExtra: PhoneInputType[\"extra\"] = { ...extra, type: \"phone\" };\n  return <TextInput {...props} extra={newExtra} />;\n}"
  },
  "SelectInput": {
    "name": "SelectInput",
    "slug": "TsFunction",
    "id": "kroynqmjqtreaqukvppruelu",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " (props) => {\n  //console.log({ value, extraOptions: extra.options });\n  const { value, extra, onChange, className } = props;\n  return (\n    <Select\n      autoSuggest={extra.autoSuggest}\n      // containerClassName={UI.input}\n      className={className || UI.selectInput}\n      title={extra.title || \"\"}\n      options={extra.options}\n      value={value}\n      onChange={(value) => {\n        if (value) {\n          onChange(value);\n        }\n      }}\n    />\n  );\n}"
  },
  "SelectMultipleInput": {
    "name": "SelectMultipleInput",
    "slug": "TsFunction",
    "id": "bkrinbgoippeaflhtiyuoxbc",
    "description": "",
    "operationName": "react-with-native-select",
    "rawText": " <T extends unknown>(\n  props: SelectMultipleInputProps<T>\n) => {\n  const {\n    onChange,\n    options,\n    className,\n    value,\n    autoSuggest,\n    noPlaceholder,\n    placeholder,\n    title,\n    uniqueFieldId,\n  } = props;\n\n  //console.log({ value, extraOptions: extra.options });\n  const defaultOption: Item<T | null> = {\n    label: title || \"Choose a value\",\n    value: \"\",\n  };\n\n  const optionsLeft = [defaultOption]\n    .concat(options)\n    .filter((x) => !value.find((i) => x.value === i.value));\n  return (\n    <Div className=\"flex flex-row flex-wrap\">\n      {value.map((item, index) => (\n        <Button\n          onClick={() => {\n            const newValue = value.filter((x) => x.value !== item.value);\n            onChange(newValue);\n          }}\n          key={`selected${uniqueFieldId}${index}`}\n          className={`mr-3 px-3 py-2 rounded-md border border-gray-400`}\n        >\n          <P className=\"text-xs\">\n            {item.label} <Span textClassName=\"text-red-500 text-xs\">(x)</Span>\n          </P>\n        </Button>\n      ))}\n\n      {optionsLeft.length > 1 ? (\n        <Select\n          placeholder={placeholder}\n          noPlaceholder={noPlaceholder}\n          autoSuggest={autoSuggest}\n          className={className || UI.selectInput}\n          title={title || \"\"}\n          options={optionsLeft}\n          onChange={(selected) => {\n            // console.log({ selected });\n            if (selected) {\n              const newValue = [...value];\n\n              newValue.push(selected);\n\n              // console.log({ value, newValue });\n              onChange(newValue);\n            }\n          }}\n        />\n      ) : null}\n    </Div>\n  );\n}"
  },
  "StarsInput": {
    "name": "StarsInput",
    "slug": "TsFunction",
    "id": "fpbxbvvdlthdygyxhfodpmcm",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  onChange,\n  value,\n  extra,\n  config,\n}) => {\n  config = config || {};\n\n  // later, this can be extrahered into a react-with-native-stars component, because now this will only work on web\n  return (\n    <ReactStars\n      className={`m-3`}\n      count={5}\n      value={typeof value === \"number\" ? value : 0}\n      onChange={onChange}\n      half={false}\n      size={24}\n      color2={\"#ffd700\"}\n    />\n  );\n}"
  },
  "TextAreaInput": {
    "name": "TextAreaInput",
    "slug": "TsFunction",
    "id": "vuyjucgqrghvewshdsmrypzb",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  value,\n  extra,\n  config,\n  onChange,\n  errors,\n}) => {\n  const hasError = errors && errors.length > 0;\n  const errorClass = hasError ? config?.errorClassName || \"border-red-600\" : \"\";\n\n  return (\n    <TextArea\n      rows={extra?.rows}\n      maxLength={extra?.maxLength}\n      className={\n        config?.replaceClassName ||\n        `${UI.input} ${errorClass} ${config?.extraClassName}`\n      }\n      value={value}\n      onChange={(event) => {\n        onChange(event.target.value);\n      }}\n      native={{ onChangeText: onChange, value }}\n    />\n  );\n}"
  },
  "TextInput": {
    "name": "TextInput",
    "slug": "TsFunction",
    "id": "iyghngiskhltflegzqqqcoqv",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  onChange,\n  value,\n  extra,\n  config,\n  errors,\n}) => {\n  config = config || {};\n  const hasError = errors && errors.length > 0;\n\n  const inputClassWithError = `my-2 ${UI.textInput}${\n    hasError\n      ? config.errorClassName\n        ? config.errorClassName\n        : \" border border-red-400\"\n      : \"\"\n  }`;\n\n  const onChangeText = (value: TextInputType[\"value\"]) => onChange(value);\n  const placeholder = extra?.placeholder;\n  const maxLength = extra?.maxLength;\n\n  return (\n    <Input\n      type={\n        extra?.type ? extra.type : extra?.isPassword ? \"password\" : undefined\n      }\n      className={inputClassWithError}\n      //why doesn't it get applied corectly?\n      style={{\n        padding: 5,\n        paddingTop: 8,\n        paddingBottom: 8,\n        marginTop: 5,\n        marginBottom: 5,\n      }}\n      value={value}\n      onChange={(event) => onChangeText(event.target.value)}\n      placeholder={placeholder}\n      maxLength={extra?.maxLength}\n      autoComplete={extra?.autoComplete}\n      required={extra?.required}\n      disabled={extra?.disabled}\n      native={{\n        value,\n        onChangeText,\n        placeholder,\n        maxLength,\n        secureTextEntry: extra?.isPassword,\n      }}\n    />\n  );\n}"
  },
  "TimeInput": {
    "name": "TimeInput",
    "slug": "TsFunction",
    "id": "eavjgkxinbhjtwxwjrwnxrhj",
    "description": "CSS Modules, react-datepicker-cssmodules.css",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  extra,\n  value,\n  onChange,\n}) => {\n  return (\n    <TimePicker\n      onChange={(time: any) => onChange(time)}\n      value={Moment(value)}\n      showSecond={false}\n      format=\"h:mm a\"\n      use12Hours\n      className={UI.dateInput}\n      // className={inputClass}\n    />\n  );\n}"
  },
  "ToggleInput": {
    "name": "ToggleInput",
    "slug": "TsFunction",
    "id": "wbbcufxxczmuuwciwuqlxqky",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  onChange,\n  value,\n  extra,\n  config,\n  uniqueFieldId,\n  errors,\n  className,\n}) => {\n  config = config || {};\n\n  const defaultClass = \"\";\n  const hasError = errors && errors.length > 0;\n  const errorClass = hasError\n    ? config.errorClassName\n      ? config.errorClassName\n      : \" border border-red-400\"\n    : \"\";\n\n  const classWithError = config.replaceClassName\n    ? `${config.replaceClassName} ${errorClass}`\n    : `${defaultClass} ${config.extraClassName} ${errorClass}`;\n\n  return (\n    <Div className={`flex flex-row items-center ${className || \"\"}`}>\n      <Toggle\n        id={uniqueFieldId}\n        // class not working with border on checkbox\n        className={classWithError}\n        checked={value}\n        onChange={(value: ToggleInputType[\"value\"]) => onChange(value)}\n      />\n      {extra?.label ? (\n        <Label\n          className={`pl-3 select-none ${hasError ? \"text-red-500\" : \"\"}`}\n          htmlFor={uniqueFieldId}\n        >\n          {extra.label}\n        </Label>\n      ) : null}\n    </Div>\n  );\n}"
  },
  "ModalContext": {
    "name": "ModalContext",
    "slug": "TsVariable",
    "id": "ftydifpwgkqurvwdaikyrohd",
    "description": "",
    "operationName": "react-with-native-modal"
  },
  "ModalProvider": {
    "name": "ModalProvider",
    "slug": "TsFunction",
    "id": "fjbozenwxfprbvycidieicyn",
    "description": "",
    "operationName": "react-with-native-modal",
    "rawText": " ({ children }: { children: any }) => {\n  let { showModal, handleModal, modalContent, title } = useModalState();\n  return (\n    <Provider value={{ showModal, handleModal, modalContent, title }}>\n      <Modal />\n      {children}\n    </Provider>\n  );\n}"
  },
  "{ Provider }": {
    "name": "{ Provider }",
    "slug": "TsVariable",
    "id": "xeoxohzaptxvbevgltkuqdvk",
    "description": "",
    "operationName": "react-with-native-modal"
  },
  "useModalState": {
    "name": "useModalState",
    "slug": "TsFunction",
    "id": "zamoqvcbwvieeavrcgsvsoto",
    "description": "",
    "operationName": "react-with-native-modal",
    "rawText": " () => {\n  const [showModal, setShowModal] = useState(false);\n  const [modalContent, setModalContent] = useState<ModalContent>(null);\n  const [title, setTitle] = useState(\"\");\n\n  const handleModal: HandleModal = (\n    content: ModalContent = null,\n    title?: string\n  ) => {\n    setShowModal(!showModal);\n    if (content) {\n      setModalContent(content);\n    }\n    if (title) {\n      setTitle(title);\n    }\n  };\n\n  return { showModal, handleModal, modalContent, title };\n}"
  },
  "useModal": {
    "name": "useModal",
    "slug": "TsFunction",
    "id": "ssqsrgtvjsncbywickcqyuax",
    "description": "",
    "operationName": "react-with-native-modal",
    "rawText": " () => useContext(ModalContext)"
  },
  "ToastContainer": {
    "name": "ToastContainer",
    "slug": "TsFunction",
    "id": "sghyousdhtewfudkvtflyloo",
    "description": "",
    "operationName": "react-with-native-notification",
    "rawText": " () => {\n  return null;\n}"
  },
  "toast": {
    "name": "toast",
    "slug": "TsFunction",
    "id": "mfmqsyzubzqiboqslnqmdeup",
    "description": "title is only shown on native",
    "operationName": "react-with-native-notification",
    "rawText": " (\n  message: { title: string; body: string },\n  options?: ToastOptions\n) => {\n  toastifyToast(message.body, options);\n}"
  },
  "useRouter": {
    "name": "useRouter",
    "slug": "TsFunction",
    "id": "paebyumxgxwbtrwyhghzvycw",
    "description": "",
    "operationName": "react-with-native-router",
    "rawText": " (): NextRouter => {\n  const navigation = useNavigation();\n\n  const push = async (route: any, options: any) => {\n    const realRoute = route === \"/\" ? \"index\" : route;\n    //@ts-ignore\n    navigation.navigate(realRoute, options?.query);\n    return true;\n  };\n\n  const route = \"\";\n\n  const replace = async (\n    url: NextURL,\n    as?: NextURL | undefined,\n    options?:\n      | {\n          shallow?: boolean;\n          locale?: string | false;\n          scroll?: boolean;\n        }\n      | undefined\n  ) => true;\n\n  const reload = () => {};\n  const back = () => navigation.goBack();\n\n  const prefetch = async (\n    url: string,\n    asPath?: string | undefined,\n    options?: PrefetchOptions | undefined\n  ) => {};\n  const events: MittEmitter<RouterEvent> = {\n    on: (type: RouterEvent, handler: () => void) => {},\n    off: () => {},\n    emit: () => {},\n  };\n\n  const beforePopState = (\n    cb: (state: {\n      url: string;\n      as: string;\n      options: TransitionOptions;\n    }) => boolean\n  ) => {};\n  return {\n    push,\n    route,\n    isLocaleDomain: true,\n    pathname: \"\",\n    query: {},\n    asPath: \"\",\n    isFallback: false,\n    basePath: \"\",\n    locale: \"\",\n    locales: [\"\"],\n    defaultLocale: \"\",\n    isReady: true,\n    isPreview: false,\n    replace,\n    reload,\n    back,\n    prefetch,\n    beforePopState,\n    events,\n  };\n}"
  },
  "getRealValue": {
    "name": "getRealValue",
    "slug": "TsFunction",
    "id": "mtzplwhzgdwlzfygbfttuhxa",
    "description": "",
    "operationName": "react-with-native-select",
    "rawText": " <T extends unknown>({\n  value,\n  selectFirstOption,\n  options,\n  title,\n}: {\n  title: string;\n  options: Item<T>[];\n  value?: Item<T> | null;\n  selectFirstOption?: boolean;\n}): Item<T> => {\n  const result = value\n    ? value\n    : selectFirstOption\n    ? options[0]\n    : { label: title, value: \"\", data: undefined };\n\n  return result;\n}"
  },
  "useSelectMultiple": {
    "name": "useSelectMultiple",
    "slug": "TsFunction",
    "id": "tmovnnzmibasedomoyuzoxxm",
    "description": "Create a value selector in a single line of code, including its state!",
    "operationName": "react-with-native-select",
    "rawText": " <T extends unknown>(\n  items?: Item<T | null>[],\n  initialValue?: Item<T | null>[],\n  /**\n   * Optionally you can do other things with the value as well, like setting it to a global store\n   */\n  withValue?: (value: Item<T | null>[]) => void,\n  config?: Omit<SelectMultipleInputProps<T>, \"onChange\" | \"value\" | \"options\">\n): [\n  Component: () => JSX.Element,\n  value: Item<T | null>[],\n  setValue: (value: Item<T | null>[]) => void\n] => {\n  const realItems = items || [];\n  const [value, setValue] = useState<Item<T | null>[]>(initialValue || []);\n\n  const realOnChange = (v: Item<T | null>[]) => {\n    setValue(v);\n\n    if (v) {\n      withValue?.(v);\n    }\n  };\n\n  const Component = () => (\n    <SelectMultipleInput\n      {...config}\n      onChange={realOnChange}\n      value={value}\n      options={realItems}\n    />\n  );\n  return [Component, value, realOnChange];\n}"
  },
  "useSelect": {
    "name": "useSelect",
    "slug": "TsFunction",
    "id": "nbytnjpcdxfnrzhnwmqtczqw",
    "description": "Create a value selector in a single line of code, including its state!\n\n# **Usage**\n\n```ts\nconst [SelectView, view, setView] = useSelect(views);\n```",
    "operationName": "react-with-native-select",
    "rawText": " <T extends unknown>(\n  items?: Item<T>[],\n  initialValue?: Item<T>,\n  /**\n   * Optionally you can do other things with the value as well, like setting it to a global store\n   */\n  withValue?: (value: Item<T> | undefined) => void\n): [\n  Component: () => JSX.Element,\n  value: Item<T> | null,\n  setValue: (value: Item<T> | null) => void\n] => {\n  const realItems = items || [];\n  const [value, setValue] = useState<Item<T> | null>(initialValue || null);\n\n  const Component = () => (\n    <Select\n      className=\"bg-transparent\"\n      title=\"Test\"\n      onChange={(v) => {\n        setValue(v);\n\n        if (v) {\n          withValue?.(v);\n        }\n      }}\n      value={value}\n      options={realItems}\n    />\n  );\n  return [Component, value, setValue];\n}"
  },
  "getColumns": {
    "name": "getColumns",
    "slug": "TsFunction",
    "id": "bonpchpptohsvikqsxsxxfdr",
    "description": "gets all columns you can present based on a modelname, the interfaces of that model, and the data",
    "operationName": "react-with-native-table",
    "rawText": " (\n  modelName: string,\n  interfaces: TsInterface[] | undefined,\n  data: any[]\n): ColumnType<any>[] => {\n  /**\n   * needed in case something goes wrong with the index\n   */\n  const getDumbColumns = (): ColumnType<any>[] => {\n    return data[0] && typeof data[0] === \"object\"\n      ? Object.keys(data[0])\n          .map((objectParameterKey) => {\n            const value = data[0][objectParameterKey];\n            if (\n              ![\"string\", \"boolean\", \"number\", \"null\"].includes(typeof value)\n            ) {\n              return null;\n            }\n            return {\n              name: humanCase(objectParameterKey),\n              objectParameterKey,\n              presentationType: \"text\" as \"text\",\n            };\n          })\n          .filter(notEmpty)\n      : [];\n  };\n  if (!interfaces) return getDumbColumns();\n\n  const properties = interfaces.find((x) => x.name === modelName)?.type\n    .typeDefinition?.properties;\n\n  if (!properties) return getDumbColumns();\n\n  const columns: ColumnType<any>[] = Object.keys(properties)\n    .map((objectParameterKey) => {\n      const maybeProperty = properties[objectParameterKey];\n      const property =\n        typeof maybeProperty !== \"boolean\" ? maybeProperty : undefined;\n\n      if (!property) return;\n\n      if (\n        makeArray(property.type).find((x) => [\"object\", \"array\"].includes(x))\n      ) {\n        // there are arrays or objects among the type of this property\n        return;\n      }\n\n      const column: ColumnType<any> = {\n        name: humanCase(objectParameterKey),\n        objectParameterKey,\n        presentationType: \"text\",\n      };\n\n      return column;\n    })\n    .filter(notEmpty);\n  return columns;\n}"
  },
  "renderColumn": {
    "name": "renderColumn",
    "slug": "TsFunction",
    "id": "zwsxjopuglxzrjyvyvqrjhjc",
    "description": "",
    "operationName": "react-with-native-table",
    "rawText": " <TModel extends { [key: string]: any }>(\n  column: ColumnType<TModel>,\n  row: TModel,\n  index: number\n) => {\n  if (column.presentationType === \"text\") {\n    const rawValue = row[column.objectParameterKey];\n\n    const value: string =\n      rawValue === undefined ? \"\" : rawValue === \"\" ? \"''\" : String(rawValue);\n    /**\n     * This is a text item that presents just one string\n     */\n    return <td className={tdClassName}>{value}</td>;\n  } else if (column.presentationType === \"backendAsset\") {\n    const backendAssets = row[column.objectParameterKey]\n      ? (makeArray(row[column.objectParameterKey]) as BackendAsset[])\n      : undefined;\n\n    return (\n      <td className={tdClassName}>\n        {backendAssets\n          ? backendAssets.map((backendAsset) => {\n              return (\n                <ModelItemAssetView\n                  item={row as unknown as AugmentedAnyModelType}\n                  backendAsset={backendAsset}\n                />\n              );\n            })\n          : null}\n      </td>\n    );\n  } else if (column.presentationType === \"referenceSingle\") {\n    // Any parameter with pattern xxxSlug or xxxId should link to that instance in the referred model (link to `db?model={model}#{id}`)\n    const referenceId: string | undefined = row[column.objectParameterKey];\n\n    const referenceParameterInfo = getReferenceParameterInfo(\n      column.objectParameterKey\n    );\n\n    return (\n      <td className={tdClassName}>\n        <a\n          href={`/${referenceParameterInfo.interfaceName}?${referenceParameterInfo.keyInModel}=${referenceId}`}\n        >\n          {referenceId}\n        </a>\n      </td>\n    );\n  } else if (column.presentationType === \"referenceMultiple\") {\n    // Any parameter with pattern xxxSlugs or xxxIds should link to those instance in the referred model (link to `db?model={model}&xxx={id}`) for every instance\n    // NB: it can also be a string in case markdown storage format is used, if there is just one...\n    const referenceIds: undefined | string[] | string =\n      row[column.objectParameterKey];\n    const referenceIdsArray = referenceIds\n      ? makeArray(referenceIds)\n      : undefined;\n\n    const referenceParameterInfo = getReferenceParameterInfo(\n      column.objectParameterKey\n    );\n\n    return (\n      <td className={tdClassName}>\n        {referenceIdsArray?.map((referenceId) => {\n          return (\n            <a\n              href={`/${referenceParameterInfo.interfaceName}?${referenceParameterInfo.keyInModel}=${referenceId}`}\n            >\n              {referenceId}\n            </a>\n          );\n        })}\n      </td>\n    );\n  } else {\n    return <td className={tdClassName}>Unknown Presentation Type</td>;\n  }\n}"
  },
  "Skeleton": {
    "name": "Skeleton",
    "slug": "TsFunction",
    "id": "gidiplemqdkmoiycodzeieqs",
    "description": "",
    "operationName": "react-with-native-table",
    "rawText": " () => (\n  <td className={tdClassName}>\n    <div className=\"bg-gray-200 w-full p-2 animate-pulse rounded-lg h-5\" />\n  </td>\n)"
  },
  "TableHeadItem": {
    "name": "TableHeadItem",
    "slug": "TsFunction",
    "id": "osezaptgmjotfmojiczttvgo",
    "description": "",
    "operationName": "react-with-native-table",
    "rawText": " (column: ColumnType<any>) => (\n  <th\n    scope=\"col\"\n    className=\"whitespace-nowrap py-3.5 pl-4 pr-3 text-left text-sm font-semibold text-gray-900 dark:text-gray-100 sm:pl-6 md:pl-0\"\n  >\n    <Div>{column.name}</Div>\n  </th>\n)"
  },
  "TableRow": {
    "name": "TableRow",
    "slug": "TsFunction",
    "id": "iexqwezljyezxfgqhtcjfgca",
    "description": "",
    "operationName": "react-with-native-table",
    "rawText": " <T extends { [key: string]: any } = any>({\n  row,\n  columns,\n  renderExtraColumns,\n  extraColumnsAtStart,\n  shouldHighlight,\n}: RowType<T>) => {\n  /**\n   * Check which presentation type is set for this column and return this component\n   */\n  return (\n    <tr className={shouldHighlight ? \"bg-blue-300\" : undefined}>\n      {extraColumnsAtStart && (\n        <td className={tdClassName}>{renderExtraColumns?.(row)}</td>\n      )}\n      {columns.map((column, index) => {\n        if (!row) {\n          return <Skeleton />;\n        }\n\n        // we can optionally have a custom presentation for any column\n        if (column.customPresentation) {\n          return column.customPresentation(row);\n        }\n\n        return renderColumn(column, row, index);\n      })}\n\n      {!extraColumnsAtStart && (\n        <td className={tdClassName}>{renderExtraColumns?.(row)}</td>\n      )}\n    </tr>\n  );\n}"
  },
  "Table": {
    "name": "Table",
    "slug": "TsFunction",
    "id": "priajkefsxneyhlotjhwwrxr",
    "description": "",
    "operationName": "react-with-native-table",
    "rawText": " <TModel extends { [key: string]: any }>({\n  data,\n  columns,\n  renderExtraColumns,\n  extraColumnsAtStart,\n  onEndReached,\n  shouldHighlightItem,\n}: TableType<TModel>) => {\n  const endOfTableDiv = useRef<HTMLDivElement>(null);\n  const isEndReached = useIsInViewport(endOfTableDiv);\n  useEffect(() => {\n    // console.log(\"END REACHED\");\n    onEndReached?.();\n  }, [isEndReached]);\n  return (\n    <Div className=\"px-4 sm:px-6 lg:px-8\">\n      <Div className=\"mt-8 flex flex-col\">\n        <Div className=\"-my-2 -mx-4 overflow-x-auto sm:-mx-6 lg:-mx-8\">\n          <Div className=\"inline-block min-w-full py-2 align-middle md:px-6 lg:px-8\">\n            <table className=\"min-w-full divide-y divide-gray-300\">\n              <thead>\n                <tr>\n                  {extraColumnsAtStart ? (\n                    <TableHeadItem name=\"\" objectParameterKey={\"\"} />\n                  ) : null}\n                  {columns.map((column, index) => (\n                    // NB: here we are destructuring column to provide all the props to a component\n                    <TableHeadItem {...column} />\n                  ))}\n                  {renderExtraColumns && !extraColumnsAtStart ? (\n                    <TableHeadItem objectParameterKey={\"\"} name=\"\" />\n                  ) : null}\n                </tr>\n              </thead>\n              <tbody className=\"divide-y divide-gray-200\">\n                {data\n                  ? // If data is undefined, we have to render the skelletonview\n                    data.map((item, index) => {\n                      const shouldHighlight = shouldHighlightItem?.(item);\n                      return (\n                        <TableRow\n                          shouldHighlight={shouldHighlight}\n                          key={`row${index}`}\n                          row={item}\n                          columns={columns}\n                          renderExtraColumns={renderExtraColumns}\n                          extraColumnsAtStart={extraColumnsAtStart}\n                        />\n                      );\n                    })\n                  : // Without data we are assuming it's still loading and show 10 skelletons, which are simply TableRow's without any data\n                    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map((_, index) => (\n                      <TableRow\n                        key={`skeleton${index}`}\n                        row={undefined}\n                        columns={columns}\n                      />\n                    ))}\n              </tbody>\n            </table>\n            <div ref={endOfTableDiv}>&nbsp;</div>\n          </Div>\n        </Div>\n      </Div>\n    </Div>\n  );\n}"
  },
  "tdClassName": {
    "name": "tdClassName",
    "slug": "TsVariable",
    "id": "vqydsyecqsafpmzpdzxefmlc",
    "description": "",
    "operationName": "react-with-native-table"
  },
  "bareInputClass": {
    "name": "bareInputClass",
    "slug": "TsVariable",
    "id": "cyflkpaeosydkreyprdmblqf",
    "description": "",
    "operationName": "react-with-native-ui"
  },
  "inputClass": {
    "name": "inputClass",
    "slug": "TsVariable",
    "id": "ycljmmnauwwluiugeigzucpk",
    "description": "",
    "operationName": "react-with-native-ui"
  },
  "UI": {
    "name": "UI",
    "slug": "TsVariable",
    "id": "isulhxodlkhqpybatvcfqayu",
    "description": "",
    "operationName": "react-with-native-ui"
  },
  "fileTabsInitialValues": {
    "name": "fileTabsInitialValues",
    "slug": "TsVariable",
    "id": "sjuybnetqysrhqbiwxjmnpjd",
    "description": "",
    "operationName": "file-tabs"
  },
  "FileTabs": {
    "name": "FileTabs",
    "slug": "TsFunction",
    "id": "frbkcfkybbyqgcvttkeywhws",
    "description": "",
    "operationName": "file-tabs",
    "rawText": " <TPagesObject extends PagesObjectShape>(props: {\n  pagesObject: TPagesObject;\n}) => {\n  const { pagesObject } = props;\n\n  const router = useRouter();\n  const { query } = router;\n  const alert = useAlert();\n  const { fullPath } = usePath();\n\n  const [showOpenPages, setShowOpenPages] = useState(true);\n  const [openPages, setOpenPages] = useStore(\"openPages\");\n  const [unsavedFiles, setUnsavedFiles] = useStore(\"unsavedFiles\");\n\n  const unsavedFilePaths = Object.keys(unsavedFiles).filter(\n    (projectRelativePath) => unsavedFiles[projectRelativePath] !== undefined\n  );\n\n  const notOpenUnsavedFilesPages: OpenPage<Keys<TPagesObject>>[] =\n    unsavedFilePaths\n      .map((projectRelativeFilePath) => {\n        const already = !!openPages.find(\n          (x) => getFullPath(x.query.paths) === projectRelativeFilePath\n        );\n\n        if (already) return;\n\n        const openPage: OpenPage<Keys<TPagesObject>> = {\n          id: generateId(),\n          page: \"index\" as Keys<TPagesObject>,\n          query: {\n            paths: projectRelativeFilePath.split(\"/\"),\n          },\n          lastOpenedAt: Date.now(),\n          isUnsaved: true,\n          temporary: true,\n        };\n        return openPage;\n      })\n      .filter(notEmpty);\n\n  const currentOpenPage: OpenPage<Keys<TPagesObject>> = {\n    page: getActivePage(router.pathname, pagesObject),\n    query,\n    lastOpenedAt: 0,\n    temporary: true,\n    /*** NB: id isn't correct */\n    id: generateId(),\n  };\n\n  const openAndUnsavedPages = openPages.concat(notOpenUnsavedFilesPages);\n\n  const already = openAndUnsavedPages.find((x) => {\n    const url = getOpenPageUrl(x, pagesObject);\n    const currentUrl = router.asPath.slice(1);\n    return url === currentUrl;\n  });\n\n  const allOpenPages =\n    !already && router.asPath !== \"/\"\n      ? openAndUnsavedPages.concat(currentOpenPage)\n      : openAndUnsavedPages;\n\n  // Alt + N: new file\n  useHotkey(isAltN, () => goToOpenPage(undefined), []);\n  // `alt+o`: toggle hiding file-tabs\n  useHotkey(isAltO, () => setShowOpenPages((value) => !value), []);\n  // Alt+W: close page\n  useHotkey(isAltW, () => closeOpenPage(currentOpenPage, true), [\n    currentOpenPage.id,\n  ]);\n\n  useHotkeys([], (keyboardEvent) => {\n    const { altKey, code, shiftKey } = keyboardEvent;\n    if (altKey && code === \"Tab\") {\n      if (shiftKey) {\n        alert?.(\"Previous page\");\n      } else {\n        alert?.(\"Next page\");\n      }\n    }\n  });\n\n  const goToOpenPage = (openPage?: OpenPage<keyof TPagesObject>) => {\n    if (openPage) {\n      router.push(getOpenPageUrl(openPage, pagesObject));\n    } else {\n      router.push(`/`);\n    }\n  };\n\n  const closeOpenPage = (\n    openPage: OpenPage<keyof TPagesObject>,\n    isActive: boolean\n  ) => {\n    const newOpenPages = openPages.filter((x) =>\n      x.id === openPage.id ? false : true\n    );\n\n    setOpenPages(newOpenPages);\n\n    // if you were there, go to another page that's open\n    if (isActive) {\n      const anotherPage = newOpenPages[0];\n      goToOpenPage(anotherPage);\n    }\n  };\n\n  const renderOpenPage = (openPage: OpenPage<string>, i: number) => {\n    const type = getFileType(getOpenPageUrl(openPage, pagesObject));\n    const typeIcon = typeIcons[type];\n    const thisFullPath = getOpenPageUrl(openPage, pagesObject);\n    const isActive = thisFullPath === fullPath;\n\n    const title =\n      openPage.page === \"index\"\n        ? `${typeIcon} ${getLastPathsChunk(openPage.query.paths)}`\n        : openPage.page === \"menu\"\n        ? \"ðŸ“\"\n        : \"?\";\n\n    const clickableIcons: ClickIcon[] = [\n      {\n        visible: openPage.pinned,\n        //  svgSrc: PinIcon,\n        emoji: \"ðŸ”’\",\n        // unpin\n        onClick: (e) => {\n          const newOpenPages = openPages.map((x) =>\n            x.id === openPage.id ? { ...x, pinned: false } : x\n          );\n          setOpenPages(newOpenPages);\n        },\n      },\n      {\n        visible: !openPage.isUnsaved && !openPage.pinned,\n        // svgSrc: CloseIcon,\n        emoji: \"â¨¯\",\n        // close\n        onClick: (e) => {\n          e.stopPropagation();\n\n          closeOpenPage(openPage, isActive);\n        },\n      },\n      {\n        visible: openPage.isUnsaved,\n        // svgSrc: CloseIcon,\n        emoji: \"â—\",\n        // close\n        // onClick: (e) => {\n        //   e.stopPropagation();\n\n        //   closeOpenPage(openPage, isActive);\n        // },\n      },\n    ];\n\n    return (\n      <Div\n        key={`openPage${i}`}\n        className={`m-0.5 flex flex-row items-center border rounded-md border-gray-900 ${\n          isActive\n            ? \"bg-gray100 dark:bg-gray-900\"\n            : \"bg-gray-200 dark:bg-gray-700\"\n        }`}\n      >\n        <ALink\n          onDoubleClick={() => {\n            if (openPage.temporary) {\n              const thisOpenPageNotTemporary: OpenPage<string> = {\n                ...openPage,\n                temporary: false,\n                isUnsaved: undefined,\n              };\n\n              setOpenPages(openPages.concat(thisOpenPageNotTemporary));\n            }\n          }}\n          onContextMenu={(e) => {\n            e.preventDefault();\n\n            //  pin/unpin\n            const newOpenPages = openPages.map((x) =>\n              x.id === openPage.id\n                ? { ...x, pinned: !x.pinned, isUnsaved: undefined }\n                : x\n            );\n            setOpenPages(newOpenPages);\n          }}\n          href={getOpenPageUrl(openPage, pagesObject)}\n          key={`p${i}`}\n        >\n          <P\n            className={`${\n              openPage.temporary\n                ? \"italic text-black dark:text-gray-200\"\n                : \"text-black dark:text-gray-200\"\n            }`}\n          >\n            {title}\n          </P>\n        </ALink>\n        {clickableIcons.filter((x) => x.visible).map(renderIcon)}\n      </Div>\n    );\n  };\n\n  return showOpenPages ? (\n    <Div className={`bg-gray-100 dark:bg-gray-900`}>\n      <Div className=\"flex flex-row flex-wrap\">\n        {allOpenPages.map(renderOpenPage)}\n      </Div>\n    </Div>\n  ) : null;\n}"
  },
  "getActivePage": {
    "name": "getActivePage",
    "slug": "TsFunction",
    "id": "kuiqocpykeyieetnhesorgdy",
    "description": "",
    "operationName": "file-tabs",
    "rawText": " <TPagesObject extends PagesObjectShape>(\n  pathname: string,\n  pagesObject: TPagesObject\n): Keys<TPagesObject> => {\n  const p = pathname.substring(1);\n\n  if (Object.keys(pagesObject).includes(p))\n    return p as Keys<typeof pagesObject>;\n\n  return \"index\" as Keys<typeof pagesObject>;\n}"
  },
  "getOpenPageUrl": {
    "name": "getOpenPageUrl",
    "slug": "TsFunction",
    "id": "knmwdxdfegxsuhcmhhyccfsm",
    "description": "gets the url of the open page\n\n- paths is a special query key that is expanded as path, not as query\n- index page should be on /",
    "operationName": "file-tabs",
    "rawText": " <TPagesObject extends PagesObjectShape>(\n  openPage: OpenPage<keyof TPagesObject>,\n  pagesObject: TPagesObject\n) => {\n  const page =\n    openPage.page === \"index\"\n      ? getFullPath(openPage.query.paths)\n      : (openPage.page as string);\n\n  const query = { ...openPage.query };\n  delete query.paths;\n\n  const queryString = toQueryString(query);\n\n  const url = `${page}${queryString}`;\n  return url;\n}"
  },
  "renderIcon": {
    "name": "renderIcon",
    "slug": "TsFunction",
    "id": "dlihhwiucyrpfiqdfzykzyhl",
    "description": "<Svg src={svgSrc} className=\"w-4 h-4 text-gray-900 dark:text-gray-200\" />",
    "operationName": "file-tabs",
    "rawText": " (item: ClickIcon, index: number) => {\n  const { onClick, emoji } = item;\n  return (\n    <Button\n      key={`icon${index}`}\n      onClick={onClick}\n      className=\"hover:bg-yellow-100 rounded-sm m-0.5 p-0.5\"\n    >\n      {emoji}\n    </Button>\n  );\n}"
  },
  "defaultExpandedMode": {
    "name": "defaultExpandedMode",
    "slug": "TsVariable",
    "id": "fkykdltwkopvwyhlxzushiwr",
    "description": "",
    "operationName": "markdown"
  },
  "defaultMinimalMode": {
    "name": "defaultMinimalMode",
    "slug": "TsVariable",
    "id": "uxmvjwrhthfsjhalfipiwmza",
    "description": "",
    "operationName": "markdown"
  },
  "getRealSrc": {
    "name": "getRealSrc",
    "slug": "TsFunction",
    "id": "jeewvjjulritpbnoxoljliof",
    "description": "Based on markdown info, gest the real source for an asset",
    "operationName": "markdown",
    "rawText": " (\n  src: string | undefined,\n  config: MarkdownParseRenderConfig\n) => {\n  // src from static folder of next.js\n  const relativeUrlStrategy =\n    config.isDev || !config.isStatic ? \"api\" : \"static\";\n\n  if (!src) return undefined;\n\n  if (\n    isPathRelative(src) &&\n    config.projectRelativeBaseFolderPath &&\n    config.projectRelativeMarkdownFilePath\n  ) {\n    return getUrlFromRelativeUrl(\n      src,\n      relativeUrlStrategy,\n      config.projectRelativeBaseFolderPath,\n      config.projectRelativeMarkdownFilePath\n    );\n  }\n\n  return src;\n}"
  },
  "getUrlFromRelativeUrl": {
    "name": "getUrlFromRelativeUrl",
    "slug": "TsFunction",
    "id": "qdviicxgqhybmwohtcgwlooj",
    "description": "gets the renderable asset url from the relative url",
    "operationName": "markdown",
    "rawText": " (\n  relativeUrl: string,\n  relativeUrlStrategy: \"api\" | \"static\",\n  projectRelativeBaseFolderPath: string,\n  projectRelativeMarkdownFilePath: string\n) => {\n  if (relativeUrlStrategy === \"static\")\n    return path.join(projectRelativeBaseFolderPath, relativeUrl);\n\n  const relativeUrlWithoutStart = relativeUrl.slice(2);\n\n  return getReferencedAssetApiUrl(\n    apiUrl,\n    projectRelativeMarkdownFilePath,\n    relativeUrlWithoutStart\n  );\n}"
  },
  "getYoutubeId": {
    "name": "getYoutubeId",
    "slug": "TsFunction",
    "id": "zizoozcqurdkjravqdgsgdbq",
    "description": "",
    "operationName": "markdown",
    "rawText": " (url: string | undefined): string | undefined => {\n  if (!url) return;\n\n  const regExp =\n    /^.*(youtu.be\\/|v\\/|u\\/\\w\\/|embed\\/|watch\\?v=|\\&v=|\\?v=)([^#\\&\\?]*).*/;\n  const match = url.match(regExp);\n\n  if (match && match[2].length == 11) {\n    return match[2];\n  }\n  return;\n}"
  },
  "HtmlHeader": {
    "name": "HtmlHeader",
    "slug": "TsFunction",
    "id": "mqmxygcaovcbxpfnbwcbqpii",
    "description": "",
    "operationName": "markdown",
    "rawText": " ({ level, children }) => {\n  const levelSize =\n    level === 1\n      ? \"text-3xl\"\n      : level === 2\n      ? \"text-2xl\"\n      : level === 3\n      ? \"text-xl\"\n      : level === 4\n      ? \"text-lg\"\n      : level === 5\n      ? \"text-md\"\n      : level === 6\n      ? \"text-sm\"\n      : \"text-xs\";\n  // {...props\n  return (\n    <Div id={getImplicitId(String(children))} className={levelSize}>\n      {children}\n    </Div>\n  );\n}"
  },
  "MarkdownCodeblock": {
    "name": "MarkdownCodeblock",
    "slug": "TsFunction",
    "id": "hqkfvixzhdbepenzxqkgyicl",
    "description": "Renders a markdown codeblock with a text as content and an optional extension",
    "operationName": "markdown",
    "rawText": " (props: {\n  /**\n   * STRING! don't put a JSON object here,  first use JSON.stringify!\n   */\n  text: string;\n  extension?: string;\n  /**\n   * If set, this is the mode when minimised\n   */\n  minimalMode?: CodeblockMode;\n  /**\n   * If set, this is the mode when expanded\n   */\n  expandedMode?: CodeblockMode;\n  /**\n   * if true, by default it's expanded\n   */\n  isInitiallyExpanded?: boolean;\n  /**\n   * if true, mode cannot be changed\n   */\n  isModeStatic?: boolean;\n}) => {\n  const {\n    text,\n    extension,\n    expandedMode,\n    isInitiallyExpanded,\n    minimalMode,\n    isModeStatic,\n  } = props;\n\n  const [isExpanded, setIsExpanded] = useState(isInitiallyExpanded);\n\n  const mode = isExpanded\n    ? expandedMode || defaultExpandedMode\n    : minimalMode || defaultMinimalMode;\n\n  const realText =\n    mode === \"preview\"\n      ? text.length > 200\n        ? text.slice(0, 198) + \"..\"\n        : text\n      : text;\n\n  const nothingToExpand = mode === \"preview\" && text === realText;\n  return (\n    <Div className=\"w-full\">\n      {isModeStatic ? null : nothingToExpand ? null : (\n        <Div>\n          <ClickableIcon\n            onClick={() => {\n              setIsExpanded(!isExpanded);\n            }}\n            emoji={isExpanded ? \"âž– Minimise\" : \"âž• Expand\"}\n          />\n        </Div>\n      )}\n\n      <Div\n        className={\n          mode === \"scroll\"\n            ? \"overflow-y-auto max-h-[60vh] max-w-[60vw]\"\n            : mode === \"preview\"\n            ? \"opacity-25 bg-black\"\n            : undefined\n        }\n      >\n        {renderMarkdownContent(\n          createCodeblockMarkdown(realText, extension || null),\n          // The config below is not needed since all that is renderedd is a codeblock, which doesn't need to render links etc.\n          {\n            projectRelativeBaseFolderPath: \"\",\n            projectRelativeMarkdownFilePath: \"\",\n          }\n        )}\n      </Div>\n    </Div>\n  );\n}"
  },
  "MarkdownContentRender": {
    "name": "MarkdownContentRender",
    "slug": "TsFunction",
    "id": "zayjkabtmigrqsjuuoylunfx",
    "description": "",
    "operationName": "markdown",
    "rawText": " (props: {\n  content: string;\n  config: MarkdownParseRenderConfig;\n}) => {\n  const { config, content } = props;\n\n  const markdownRender = (\n    <ReactMarkdown\n      className={config?.big ? \"max-w-lg\" : undefined}\n      rehypePlugins={[rehypeHighlight, remarkGfm, rehypeRaw]}\n      components={{\n        h1: HtmlHeader,\n        h2: HtmlHeader,\n        h3: HtmlHeader,\n        h4: HtmlHeader,\n        h5: HtmlHeader,\n        h6: HtmlHeader,\n\n        img: ({ src, alt }) => {\n          if (!src) return <Div>Bad asset src</Div>;\n          const isRelative = isPathRelative(src);\n          if (isRelative && !config.projectRelativeMarkdownFilePath) {\n            // We can't show the asset in this scenario\n            return (\n              <P>\n                ![${alt}](${src})\n              </P>\n            );\n          }\n\n          const url = isRelative ? undefined : src;\n          const relativePath = isRelative ? src : undefined;\n          const asset: Asset = { alt, relativePath, absoluteUrl: url };\n\n          return (\n            <AssetView\n              asset={asset}\n              projectRelativeReferencingFilePath={\n                config.projectRelativeMarkdownFilePath\n              }\n              hideDownloadLink\n              className=\"w-96\"\n            />\n          );\n        },\n        //Fix newlines with `<br>`\n        br: ({ node, ...props }: any) => (\n          // @ts-ignore\n          <br {...props} />\n        ),\n\n        details: ({ node, ...props }) => {\n          return (\n            // @ts-ignore\n            <details\n              className=\"group border border-gray-600 rounded-lg\"\n              {...props}\n            />\n          );\n        },\n\n        summary: ({ node, ...props }: any) => {\n          return (\n            // @ts-ignore\n            <summary\n              className=\"bg-gray-200 dark:bg-gray-700 p-2 rounded-lg group-open:rounded-b-none group-open:border group-open:border-b-gray-600 select-none\"\n              {...props}\n            />\n          );\n        },\n\n        td: ({ node, children, ...props }: any) => {\n          return (\n            // @ts-ignore\n            <td\n              className=\"border-spacing-1 border-t border-r last:border-r-0 border-gray-600 dark:border-gray-100 p-2\"\n              {...props}\n            >\n              {children?.map((child: any) =>\n                child === \"<br />\" ? <br /> : child\n              )}\n            </td>\n          );\n        },\n        th: ({ node, ...props }) => (\n          // @ts-ignore\n          <th className=\"\" {...props} />\n        ),\n\n        table: ({ node, ...props }) => (\n          // @ts-ignore\n          <div className=\"inline-block rounded-lg border shadow-2xl\">\n            <table className=\"\" {...props} />\n          </div>\n        ),\n\n        tbody: ({ node, ...props }) => (\n          // @ts-ignore\n          <tbody className=\"border-gray-600 dark:border-gray-100\" {...props} />\n        ),\n\n        tr: ({ node, ...props }) => (\n          // @ts-ignore\n          <tr\n            className=\"dark:even:bg-black even:bg-gray-400 even:bg-opacity-30\"\n            {...props}\n          />\n        ),\n\n        ol: ({ node, ...props }: any) => (\n          <ol className=\"list-decimal mx-3 p-2\" {...props} />\n        ),\n        ul: ({ node, ...props }: any) => (\n          <ul\n            style={{ listStyleType: \"circle\" }}\n            className=\"mx-3 p-2\"\n            {...props}\n          />\n        ),\n\n        p: ({ node, ...props }) => {\n          // TODO: make this work for components as well, now only works if the children of p is raw text...\n          // const text = makeArray(props.children)\n          //   .map((x) => {\n          //     if (typeof x === \"string\" || typeof x === \"number\") {\n          //       return String(x);\n          //     }\n          //     return undefined;\n          //   })\n          //   .filter(notEmpty)\n          //   .join(\"\");\n\n          // const selectionResultsThisParagraph =\n          //   config.selectionContextualPromptResults?.filter((x) =>\n          //     x.selectionString ? text.includes(x.selectionString) : false\n          //   );\n\n          return (\n            <p\n              style={{\n                marginTop: 15,\n                marginBottom: 15,\n                whiteSpace: \"pre-line\",\n              }}\n              {...props}\n            />\n          );\n\n          // <>\n\n          {\n            /* {selectionResultsThisParagraph?.map((result) => {\n                return (\n                  <Div key={`result-${result.id}`}>\n                    {result.contextualPromptSlug}: {result.resultText}{\" \"}\n                    (selection: {result.selectionString})\n                  </Div>\n                );\n              })} */\n          }\n          {\n            /* </> */\n          }\n        },\n        li: ({ node, ...props }: any) => <li className=\"\" {...props} />,\n\n        code: ({ node, children, ...props }) => {\n          // NB: There's a big problem with this because all code elements get put in a `<pre>` element. I don't think this is easy to remove, but we can look in the issues. we can also look in google for how to improve it with css because i couldn't figure it out myself\n          const word: React.ReactNode | string = children[0];\n\n          const wordString: string | undefined =\n            typeof word === \"string\" ? word : undefined;\n\n          return wordString?.startsWith(\".\") ? (\n            <Parameter text={wordString} />\n          ) : (\n            <code\n              className=\"dark:bg-gray-700\"\n              {...props}\n              style={{\n                color: \"darkcyan\",\n                // NB: the below doesn't work!\n                wordBreak: \"break-all\",\n                wordWrap: \"break-word\",\n              }}\n            >\n              {children}\n            </code>\n          );\n        },\n        a: ({ node, href, title, ...props }) => {\n          const youtubeId = getYoutubeId(href);\n          if (youtubeId) {\n            return (\n              <iframe\n                className=\"aspect-video w-full\"\n                src={`https://www.youtube.com/embed/${youtubeId}`}\n                title=\"Youtube vid\"\n                frameBorder=\"0\"\n                allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n                allowFullScreen\n              ></iframe>\n            );\n          }\n          return (\n            <Tooltip\n              placement=\"left\"\n              tooltip={\n                title ? (\n                  <div className=\"px-3\">\n                    <MarkdownContent content={title} config={{}} />\n                  </div>\n                ) : (\n                  <div></div>\n                )\n              }\n            >\n              <a\n                className=\"dark:text-blue-200 text-blue-500\"\n                href={href}\n                {...props}\n              />\n            </Tooltip>\n          );\n        },\n      }}\n    >\n      {content}\n    </ReactMarkdown>\n  );\n\n  return markdownRender;\n}"
  },
  "MarkdownContent": {
    "name": "MarkdownContent",
    "slug": "TsFunction",
    "id": "giblixunhtqsuwzgqhdculow",
    "description": "Renders a markdown string (without frontmatter)",
    "operationName": "markdown",
    "rawText": " (props: {\n  content: string;\n  config: MarkdownParseRenderConfig;\n}): JSX.Element => {\n  const { config, content } = props;\n\n  if (!content) return <Div>No content</Div>;\n\n  return <MarkdownContentRender content={content} config={config} />;\n}"
  },
  "Parameter": {
    "name": "Parameter",
    "slug": "TsFunction",
    "id": "xsqtqkcwhdfkynwufothgecp",
    "description": "In markdown, if you wish to refer to a parameter, you can backtick it and put a \".\" in front. You can also add a value to it if you wish, by adding the \":\" and the value afterwards.",
    "operationName": "markdown",
    "rawText": " (props: { text: string }) => {\n  const { text } = props;\n  if (!text) return null;\n  const [parameter, value] = text\n    .slice(1)\n    .split(\":\")\n    .map((x) => x.trim());\n  return (\n    <Span className=\"rounded-md bg-purple-400 dark:bg-purple-800 px-1\">\n      {parameter ? <Span>{parameter}</Span> : null}\n      {value ? <Span className=\"bg-white bg-opacity-50\">{value}</Span> : null}\n    </Span>\n  );\n}"
  },
  "renderFrontmatter": {
    "name": "renderFrontmatter",
    "slug": "TsFunction",
    "id": "tnvdzzbcdmoipvmndrtvgrcf",
    "description": "Renders markdown frontmatter parameters (and optionally a spacer)",
    "operationName": "markdown",
    "rawText": " (\n  parameters: Frontmatter,\n  config?: { renderSpacer?: boolean }\n) => {\n  const frontMatterKeys = Object.keys(parameters);\n\n  return frontMatterKeys.length > 0 ? (\n    <Div>\n      <Div>\n        {frontMatterKeys.map((key) => (\n          <P>\n            {key}: {parameters[key]}\n          </P>\n        ))}\n      </Div>\n\n      {config?.renderSpacer ? <P>------------</P> : null}\n    </Div>\n  ) : null;\n}"
  },
  "renderMarkdownChunk": {
    "name": "renderMarkdownChunk",
    "slug": "TsFunction",
    "id": "mkyplhqpxjdxaqyzvwkmdqes",
    "description": "renders a MarkdownChunk interface",
    "operationName": "markdown",
    "rawText": " (\n  chunk: MarkdownChunk,\n  config: MarkdownParseRenderConfig\n) => {\n  const title = chunk.title\n    ? renderMarkdownTitle(chunk.title, chunk.level)\n    : null;\n  return (\n    <Div>\n      {title}\n      {chunk.content ? renderMarkdownContent(chunk.content, config) : null}\n      {chunk.children?.map((chunk) => renderMarkdownChunk(chunk, config))}\n    </Div>\n  );\n}"
  },
  "renderMarkdownContent": {
    "name": "renderMarkdownContent",
    "slug": "TsFunction",
    "id": "eelxyvrcjrdmqomexxgfpyzr",
    "description": "Renders a markdown string (without frontmatter)\n\nTODO:\n\n- **Show selection prompt-results** In `renderMarkdownContent`, augment the alineas with the `ContextualPromptResult`. Would be great to see the results when hovering over the selected thing, or maybe showing it with a button, or inline, even.",
    "operationName": "markdown",
    "rawText": " (\n  content: string,\n  config: MarkdownParseRenderConfig\n): JSX.Element => {\n  const contextSelection = null; //useLastSelection();\n  const { openContextMenuProps, renderContextMenu } = useSelectionPromptsMenu(\n    config.selectionPrompts || [],\n    {\n      contextContent: content,\n      context_projectRelativeFilePath: config.projectRelativeMarkdownFilePath,\n      contextSelection,\n    }\n  );\n  if (!content) return <Div>No content</Div>;\n\n  const markdownRender = (\n    <ReactMarkdown\n      className={config?.big ? \"max-w-lg\" : undefined}\n      rehypePlugins={[rehypeHighlight, remarkGfm, rehypeRaw]}\n      components={{\n        h1: HtmlHeader,\n        h2: HtmlHeader,\n        h3: HtmlHeader,\n        h4: HtmlHeader,\n        h5: HtmlHeader,\n        h6: HtmlHeader,\n\n        img: ({ src, alt }) => {\n          if (!src) return <Div>Bad asset src</Div>;\n          const isRelative = isPathRelative(src);\n          if (isRelative && !config.projectRelativeMarkdownFilePath) {\n            // We can't show the asset in this scenario\n            return (\n              <P>\n                ![${alt}](${src})\n              </P>\n            );\n          }\n\n          const url = isRelative ? undefined : src;\n          const relativePath = isRelative ? src : undefined;\n          const asset: Asset = { alt, relativePath, absoluteUrl: url };\n\n          return (\n            <AssetView\n              asset={asset}\n              projectRelativeReferencingFilePath={\n                config.projectRelativeMarkdownFilePath\n              }\n              hideDownloadLink\n              className=\"w-96\"\n            />\n          );\n        },\n        //Fix newlines with `<br>`\n        br: ({ node, ...props }: any) => (\n          // @ts-ignore\n          <br {...props} />\n        ),\n\n        details: ({ node, ...props }) => {\n          return (\n            // @ts-ignore\n            <details\n              className=\"group border border-gray-600 rounded-lg\"\n              {...props}\n            />\n          );\n        },\n\n        summary: ({ node, ...props }: any) => {\n          return (\n            // @ts-ignore\n            <summary\n              className=\"bg-gray-200 dark:bg-gray-700 p-2 rounded-lg group-open:rounded-b-none group-open:border group-open:border-b-gray-600 select-none\"\n              {...props}\n            />\n          );\n        },\n\n        td: ({ node, children, ...props }: any) => {\n          return (\n            // @ts-ignore\n            <td\n              className=\"border-spacing-1 border-t border-r last:border-r-0 border-gray-600 dark:border-gray-100 p-2\"\n              {...props}\n            >\n              {children?.map((child: any) =>\n                child === \"<br />\" ? <br /> : child\n              )}\n            </td>\n          );\n        },\n        th: ({ node, ...props }) => (\n          // @ts-ignore\n          <th className=\"\" {...props} />\n        ),\n\n        table: ({ node, ...props }) => (\n          // @ts-ignore\n          <div className=\"inline-block rounded-lg border shadow-2xl\">\n            <table className=\"\" {...props} />\n          </div>\n        ),\n\n        tbody: ({ node, ...props }) => (\n          // @ts-ignore\n          <tbody className=\"border-gray-600 dark:border-gray-100\" {...props} />\n        ),\n\n        tr: ({ node, ...props }) => (\n          // @ts-ignore\n          <tr\n            className=\"dark:even:bg-black even:bg-gray-400 even:bg-opacity-30\"\n            {...props}\n          />\n        ),\n\n        ol: ({ node, ...props }: any) => (\n          <ol className=\"list-decimal mx-3 p-2\" {...props} />\n        ),\n        ul: ({ node, ...props }: any) => (\n          <ul\n            style={{ listStyleType: \"circle\" }}\n            className=\"mx-3 p-2\"\n            {...props}\n          />\n        ),\n\n        p: ({ node, ...props }) => {\n          // TODO: make this work for components as well, now only works if the children of p is raw text...\n          const text = makeArray(props.children)\n            .map((x) => {\n              if (typeof x === \"string\" || typeof x === \"number\") {\n                return String(x);\n              }\n              return undefined;\n            })\n            .filter(notEmpty)\n            .join(\"\");\n\n          const selectionResultsThisParagraph =\n            config.selectionContextualPromptResults?.filter((x) =>\n              x.selectionString ? text.includes(x.selectionString) : false\n            );\n\n          return (\n            <>\n              <p\n                style={{\n                  marginTop: 15,\n                  marginBottom: 15,\n                  whiteSpace: \"pre-line\",\n                }}\n                {...props}\n              />\n              {selectionResultsThisParagraph?.map((result) => {\n                return (\n                  <Div key={`result-${result.id}`}>\n                    {result.contextualPromptSlug}: {result.resultText}{\" \"}\n                    (selection: {result.selectionString})\n                  </Div>\n                );\n              })}\n            </>\n          );\n        },\n        li: ({ node, ...props }: any) => <li className=\"\" {...props} />,\n\n        code: ({ node, children, ...props }) => {\n          // NB: There's a big problem with this because all code elements get put in a `<pre>` element. I don't think this is easy to remove, but we can look in the issues. we can also look in google for how to improve it with css because i couldn't figure it out myself\n          const word: React.ReactNode | string = children[0];\n\n          const wordString: string | undefined =\n            typeof word === \"string\" ? word : undefined;\n\n          const foundWord: AugmentedWord | undefined = wordString\n            ? config?.augmentedWordObject?.[wordString]\n            : undefined;\n\n          return foundWord &&\n            foundWord.spoiler &&\n            foundWord.spoiler.length > 0 ? (\n            <Tooltip\n              placement=\"left\"\n              tooltip={\n                <>\n                  <div className=\"font-semibold px-3 mb-0 border-b border-solid border-gray-100 rounded-t-lg\">\n                    {foundWord.word}\n                  </div>\n                  <div className=\"px-3\">\n                    {renderMarkdownContent(foundWord.spoiler, {\n                      projectRelativeBaseFolderPath: getFolderJs(\n                        foundWord.projectRelativeMarkdownSourcePath\n                      )!,\n                      projectRelativeMarkdownFilePath:\n                        foundWord.projectRelativeMarkdownSourcePath,\n                    })}\n                  </div>\n                </>\n              }\n            >\n              <a\n                href={`/${foundWord?.queryPath}`}\n                style={{ color: \"darkred\" }}\n                {...props}\n              >\n                {children}\n              </a>\n            </Tooltip>\n          ) : wordString?.startsWith(\".\") ? (\n            <Parameter text={wordString} />\n          ) : (\n            <code\n              className=\"dark:bg-gray-700\"\n              {...props}\n              style={{\n                color: \"darkcyan\",\n                // NB: the below doesn't work!\n                wordBreak: \"break-all\",\n                wordWrap: \"break-word\",\n              }}\n            >\n              {children}\n            </code>\n          );\n        },\n        a: ({ node, href, ...props }) => {\n          const youtubeId = getYoutubeId(href);\n          if (youtubeId) {\n            return (\n              <iframe\n                width=\"560\"\n                height=\"315\"\n                src={`https://www.youtube.com/embed/${youtubeId}`}\n                title=\"YouTube video player\"\n                frameBorder=\"0\"\n                allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n                allowFullScreen\n              ></iframe>\n            );\n          }\n          return (\n            <a\n              className=\"dark:text-blue-200 text-blue-500\"\n              href={href}\n              {...props}\n            />\n          );\n        },\n      }}\n    >\n      {content}\n    </ReactMarkdown>\n  );\n\n  if (config.disableSelectionContextMenu) return markdownRender;\n\n  // console.log(\"Need to render:\", content);\n  return (\n    <div {...openContextMenuProps}>\n      {renderContextMenu()}\n      {markdownRender}\n    </div>\n  );\n}"
  },
  "renderMarkdownParse": {
    "name": "renderMarkdownParse",
    "slug": "TsFunction",
    "id": "fekwshooqdgpjivykstxiahj",
    "description": "renders the MardkownParse interface (including frontmatter)",
    "operationName": "markdown",
    "rawText": " (\n  markdownParse: MarkdownParse,\n  config: MarkdownParseRenderConfig\n) => {\n  // NB: not sure if this is the best way, there may be mulitiple markdown parses....\n  useOpenHashDetails();\n\n  return (\n    <Div>\n      {renderFrontmatter(markdownParse.parameters, { renderSpacer: true })}\n      {/* NB: Previously we needed renderMarkdownTtile, renderMarkdownChunk etc... but this was not rightly parsed, so we are going to use the regular raw parser now from `react-markdown` instead... */}\n      {renderMarkdownContent(markdownParse.raw, config)}\n    </Div>\n  );\n}"
  },
  "renderMarkdownTitle": {
    "name": "renderMarkdownTitle",
    "slug": "TsFunction",
    "id": "bwnokafhdbevhesudmmpvtdo",
    "description": "renders a markdown title (level should be 1 for h1 and 6 for h6)",
    "operationName": "markdown",
    "rawText": " (title: string, level: number) => {\n  const levelSize =\n    level === 1\n      ? \"text-3xl\"\n      : level === 2\n      ? \"text-2xl\"\n      : level === 3\n      ? \"text-xl\"\n      : level === 4\n      ? \"text-lg\"\n      : level === 5\n      ? \"text-md\"\n      : level === 6\n      ? \"text-sm\"\n      : \"text-xs\";\n\n  return (\n    <P id={getImplicitId(title)} className={levelSize}>\n      {title}\n    </P>\n  );\n}"
  },
  "useOpenHashDetails": {
    "name": "useOpenHashDetails",
    "slug": "TsFunction",
    "id": "uhfiazzerhjonpnubfsvkxrd",
    "description": "",
    "operationName": "markdown",
    "rawText": " () => {\n  React.useEffect(() => {\n    const openHashDetailsEventHandler = () => {\n      //  console.log(\"openHashEventHander\");\n      if (typeof window === \"undefined\") return;\n\n      const hash = location.hash.substring(1);\n\n      if (!hash) return;\n\n      //  console.log(`hash: ${hash}`);\n\n      const idElement = document.getElementById(hash);\n      const maybeDetails = idElement?.closest(\"details\");\n\n      // console.log({ idElement, maybeDetails });\n\n      if (!idElement || !maybeDetails) return;\n      maybeDetails.open = true;\n\n      //console.log(\"OPENED\");\n\n      scrollToId(idElement);\n    };\n\n    const scrollToId = (idElement: HTMLElement) => {\n      //console.log(\"Scroll To ID\");\n      history.scrollRestoration = \"manual\";\n      idElement.scrollIntoView({ behavior: \"smooth\" });\n      history.scrollRestoration = \"auto\";\n    };\n\n    if (document.readyState === \"complete\") {\n      openHashDetailsEventHandler();\n    }\n    addEventListener(\"load\", openHashDetailsEventHandler);\n    addEventListener(\"hashchange\", openHashDetailsEventHandler);\n\n    return () => {\n      removeEventListener(\"hashchange\", openHashDetailsEventHandler);\n      removeEventListener(\"load\", openHashDetailsEventHandler);\n    };\n  }, []);\n}"
  },
  "getRealItemRecursive": {
    "name": "getRealItemRecursive",
    "slug": "TsFunction",
    "id": "ypckcvgdwybzpedfxoaceqhb",
    "description": "",
    "operationName": "nested-menu",
    "rawText": " (item: NestedWebPage): NestedWebPage => {\n  const getTitleExtension = (item: NestedWebPage) =>\n    item.children && item.children.length === 1\n      ? getTitle(item.children[0])\n      : \"\";\n\n  // with exactly 1 child, the titles should be combined, the menu should be flattened\n  return item.children && item.children.length === 1\n    ? getRealItemRecursive({\n        ...item.children[0],\n        menuTitle: getTitle(item) + \" â€£ \" + getTitleExtension(item),\n      })\n    : item;\n}"
  },
  "getTitle": {
    "name": "getTitle",
    "slug": "TsFunction",
    "id": "mrwbvdjmuniofrjonikhqpms",
    "description": "",
    "operationName": "nested-menu",
    "rawText": " (item: WebPage<null>): string => {\n  return item.menuTitle || getFileOrFolderName(item.queryPath);\n}"
  },
  "NestedMenuItem": {
    "name": "NestedMenuItem",
    "slug": "TsFunction",
    "id": "xygbdjvqathcpztlvmgynzaj",
    "description": "General purpose NestedMenuItem.\n----\n\nTODO:\n\n- tooltip support",
    "operationName": "nested-menu",
    "rawText": " (\n  props: {\n    item: NestedWebPage;\n    /**\n     * If true, items with a single child will be merged into the parent\n     */\n    mergeSingleChilds?: boolean;\n    headersClickable?: boolean;\n    level?: number;\n  } & MouseEventCallbacks\n) => {\n  const {\n    onClick,\n    onDoubleClick,\n    onContextMenu,\n    item,\n    level,\n    headersClickable,\n    mergeSingleChilds,\n  } = props;\n\n  const realItem: NestedWebPage = mergeSingleChilds\n    ? getRealItemRecursive(item)\n    : item;\n\n  const {\n    children,\n    target,\n    isMenuHidden,\n    menuTitleAugmentation,\n    menuTitleTooltip,\n    queryPath,\n  } = realItem;\n\n  const shownChildren = children?.filter((x) => !x.isMenuHidden);\n\n  const title = getTitle(realItem);\n\n  const router = useRouter();\n  const currentPath = router.asPath.substring(1).split(\"?\")[0];\n\n  const [isExpanded, toggleExpanded, setIsExpanded, setNotExpanded] =\n    useExpanded(queryPath);\n\n  const [isMobileMenuEnabled, setIsMobileMenuEnabled] = useStore(\n    \"menu.isMobileMenuEnabled\"\n  );\n\n  const isSelected = currentPath === queryPath;\n  const realLevel = level || 0;\n\n  const hasChildren = shownChildren && shownChildren.length > 0;\n\n  const isClickable = headersClickable || !hasChildren;\n  const textClassName = isClickable\n    ? `${isSelected ? \"text-blue-500\" : \"\"} hover:text-blue-800 `\n    : undefined;\n\n  const href = isSelected\n    ? undefined\n    : isClickable\n    ? !queryPath || queryPath.length === 0\n      ? \"/\"\n      : queryPath\n    : undefined;\n\n  const allChildrenWereHidden = children?.length && !shownChildren?.length;\n  return allChildrenWereHidden ? null : (\n    <Div className=\"w-full\">\n      <Div\n        className={`w-full flex flex-row justify-center items-center pr-4 ${\n          isClickable\n            ? `hover:bg-gray-200 hover:dark:bg-gray-800 ${\n                isSelected ? \"bg-gray-200 dark:bg-gray-800 \" : \"\"\n              }`\n            : \"\"\n        }`}\n      >\n        <ALink\n          style={{\n            paddingLeft: realLevel * 10 + 5,\n            paddingBottom: 10,\n            paddingTop: 10,\n          }}\n          className=\"flex flex-row justify-between\"\n          textClassName=\"flex flex-1 text-xs\"\n          href={href}\n          target={target}\n          onDoubleClick={(event) => event && onDoubleClick?.(event, realItem)}\n          onContextMenu={(event) => onContextMenu?.(event, realItem)}\n          onClick={(event) => {\n            if (isExpanded && isSelected) {\n              setNotExpanded();\n            } else {\n              onClick?.(event, realItem);\n              setIsExpanded();\n              if (!realItem.children) {\n                setIsMobileMenuEnabled(false);\n              }\n            }\n          }}\n        >\n          <Span\n            //line-clamp-1 truncate text-ellipsis\n            textClassName={textClassName}\n          >\n            {title}\n          </Span>\n          <Span className=\"flex flex-row\">\n            {menuTitleAugmentation ? (\n              <Span>{menuTitleAugmentation}</Span>\n            ) : null}\n          </Span>\n        </ALink>\n        {hasChildren ? (\n          <Div\n            className=\"text-3xl cursor-pointer\"\n            onClick={() => toggleExpanded()}\n          >\n            {isExpanded ? \"â–¾\" : \"â–¸\"}\n          </Div>\n        ) : null}\n      </Div>\n\n      {hasChildren && isExpanded ? (\n        <Div className=\"w-full\">\n          {shownChildren.map((child, i) => {\n            return (\n              <NestedMenuItem\n                key={`menu-${href}-${i}`}\n                item={child}\n                headersClickable={headersClickable}\n                level={realLevel + 1}\n              />\n            );\n          })}\n        </Div>\n      ) : null}\n    </Div>\n  );\n}"
  },
  "nestedMenuStoreInitialValues": {
    "name": "nestedMenuStoreInitialValues",
    "slug": "TsVariable",
    "id": "mziwsmbvbgcmusmdzbwylocu",
    "description": "",
    "operationName": "nested-menu"
  },
  "NestedMenu": {
    "name": "NestedMenu",
    "slug": "TsFunction",
    "id": "oqlcugjmwuguigtwzntiuake",
    "description": "General purpose nested menu component\n\nPlease make sure that you also wrap your app with `MenuStoreProvider`, or this will crash...!",
    "operationName": "nested-menu",
    "rawText": " (\n  props: {\n    items?: NestedWebPage[];\n    headersClickable?: boolean;\n  } & MouseEventCallbacks\n) => {\n  const router = useRouter();\n  const [expanded, setExpanded, { hydrated }] = useStore(\"menu.expanded\");\n\n  const expandCompleteUrlInMenu = () => {\n    const parts = trimSlashes(router.asPath).split(\"/\");\n    const cummulativeParts = parts\n      .map((part, index, array) => {\n        if (part === \"\") return;\n        return array.slice(0, index + 1).join(\"/\");\n      })\n      .filter(notEmpty);\n    const cumulativePartsExpandedObject = mergeObjectsArray(\n      cummulativeParts.map((url) => ({ [url]: true }))\n    );\n    setExpanded({ ...expanded, ...cumulativePartsExpandedObject });\n  };\n  useEffect(() => {\n    expandCompleteUrlInMenu();\n  }, [router.asPath]);\n\n  const { items, ...menuItemProps } = props;\n  const menuItems = items\n    ?.filter((x) => !x.isMenuHidden)\n    .map((nestedWebPage, index) => {\n      return (\n        <NestedMenuItem\n          mergeSingleChilds\n          item={nestedWebPage}\n          key={`menu${index}`}\n          {...menuItemProps}\n        />\n      );\n    });\n\n  return <Div className=\"w-full\">{menuItems}</Div>;\n}"
  },
  "useExpanded": {
    "name": "useExpanded",
    "slug": "TsFunction",
    "id": "arazbhrnzpuzwjeykspvxpfy",
    "description": "",
    "operationName": "nested-menu",
    "rawText": " (queryPath: string = \"\") => {\n  const [expanded, setExpanded, { hydrated }] = useStore(\"menu.expanded\");\n\n  const isExpanded =\n    expanded[queryPath] !== undefined ? expanded[queryPath] : false;\n\n  // console.log({ queryPath, isExpanded });\n  const setIsExpanded = () => {\n    return setExpanded({ ...expanded, [queryPath]: true });\n  };\n\n  const setNotExpanded = () => {\n    return setExpanded({ ...expanded, [queryPath]: false });\n  };\n\n  const toggleExpanded = () => {\n    return setExpanded({\n      ...expanded,\n      [queryPath]: !isExpanded,\n    });\n  };\n\n  const tuple: [\n    boolean,\n    () => Promise<void>,\n    () => Promise<void>,\n    () => Promise<void>,\n    { hydrated: boolean }\n  ] = [isExpanded, toggleExpanded, setIsExpanded, setNotExpanded, { hydrated }];\n\n  return tuple;\n}"
  },
  "getKeysAtPathFromNestedObject": {
    "name": "getKeysAtPathFromNestedObject",
    "slug": "TsFunction",
    "id": "qnrsqtpuwgqlttuwoolvgtun",
    "description": "Gets all children keys of a nested object at a certain (nested) location in the nested object\n\n`nestedObject` should extend the `NestedObject`.\n\nThe reduce is a bit vague, I need to  test this function further to make sure it does exactly what I want.",
    "operationName": "recursive-util",
    "rawText": " <T extends { [key: string]: any }>( //NestedObject<null>\n  nestedObject: T,\n  /**\n   * Something like a/b/c/d\n   */\n  objectPath: string\n) => {\n  const pathParts = objectPath.split(\"/\");\n  const objectAtLocation = pathParts.reduce((objectSubset, part) => {\n    // basecase should never happen\n    if (!objectSubset) return;\n    const subset = objectSubset[part];\n    return subset;\n  }, nestedObject as T);\n\n  const children = objectAtLocation ? Object.keys(objectAtLocation) : [];\n\n  return children;\n}"
  },
  "getMenuPagesObject": {
    "name": "getMenuPagesObject",
    "slug": "TsFunction",
    "id": "tuhtszomvhrpsurgyosggnao",
    "description": "",
    "operationName": "recursive-util",
    "rawText": " <T>(\n  flat: WebPage<T>[]\n): MenuObjectType<T> => {\n  // NB: to make the NestedWebPage[], we don't want the pageData.\n  const flatWithoutPageData: WebPage[] = flat.map((x) => {\n    return { ...x, pageData: null, __check: true };\n  });\n\n  const nestedObject = makeNestedObjectFromQueryPathObject(\n    flatWithoutPageData,\n    {}\n  );\n\n  const keyToWebPage = (nestedObject: NestedObject<WebPage>, key: string) => {\n    return { ...nestedObject, pageData: null, queryPath: \"\" };\n  };\n\n  const nested: NestedWebPage[] = nestedObjectToChildObject(\n    nestedObject,\n    keyToWebPage\n  );\n\n  return { flat, nested };\n}"
  },
  "makeNestedObjectFromQueryPathObject": {
    "name": "makeNestedObjectFromQueryPathObject",
    "slug": "TsFunction",
    "id": "efrtinzwylcsegyprpjruwtk",
    "description": "",
    "operationName": "recursive-util",
    "rawText": " <T extends QueryPathObject>(\n  objectArray: T[],\n  initialValue: NestedObject<T>\n): NestedObject<T> => {\n  // copy queryPath into chunk\n  const reducableObjectArray = objectArray.map((x) => ({\n    ...x,\n    __chunk: x.__chunk || x.queryPath,\n  }));\n\n  const nestedPathObject = reducableObjectArray.reduce((previous, current) => {\n    const parts: string[] = current.__chunk.split(\"/\");\n    const firstPart = parts[0];\n\n    // Base case 1: if we already have it, skip it\n    if (Object.keys(previous).includes(firstPart)) {\n      return previous;\n    }\n\n    const queryPathsHere = reducableObjectArray\n      .filter((p) => p.__chunk.startsWith(`${firstPart}/`))\n      .map((p) => {\n        return { ...p, __chunk: p.__chunk.substring(firstPart.length + 1) };\n      });\n\n    // Base case 2: if it's a leaf (last item), and it has NO children, return it with its own value\n    if (parts.length === 1 && queryPathsHere.length === 0) {\n      const leaf = { ...previous, [firstPart]: current };\n      return leaf;\n    }\n\n    // Recursion case: find all queryPaths starting with the same branch\n    const newNestedPathObject: NestedObject<T> = {\n      ...previous,\n      [firstPart]: makeNestedObjectFromQueryPathObject(queryPathsHere, {}),\n    };\n\n    return newNestedPathObject;\n  }, initialValue) as NestedObject<T>;\n\n  return nestedPathObject;\n}"
  },
  "nestedObjectToChildObject": {
    "name": "nestedObjectToChildObject",
    "slug": "TsFunction",
    "id": "avzqrtnnhcztrvurrxauteby",
    "description": "if T is an object, provide __check as one of its properties, to make it possible to check that it's a leaf. This property will be omitted in the ChildObject array",
    "operationName": "recursive-util",
    "rawText": " <T extends { [key: string]: any }>(\n  /**\n   * if T is an object, provide __check to check that it's a leaf\n   */\n  nestedObject: NestedObject<T>,\n  /**\n   * Map the folder to T. You can omit queryPath, it will be overwritten\n   */\n  mapFolderToT: (nestedObject: NestedObject<T>, key: string) => T,\n  stack: string[] = []\n): ChildObject<T>[] => {\n  const keys = Object.keys(nestedObject);\n  const children = keys.map((key) => {\n    const t = mapFolderToT(nestedObject, key);\n    const value = nestedObject[key];\n\n    const isLeaf = typeof value !== \"object\" || !!value.__check;\n\n    if (isLeaf) {\n      const { __check, ...valueWithoutCheck } = value;\n      return valueWithoutCheck;\n    }\n\n    const newStack = stack.concat(key);\n    const queryPath = newStack.join(\"/\");\n\n    return {\n      ...t,\n      queryPath,\n      children: nestedObjectToChildObject(value, mapFolderToT, newStack),\n    };\n  }) as ChildObject<T>[];\n\n  return children;\n}"
  },
  "nestedPathObjectToNestedMenuRecursive": {
    "name": "nestedPathObjectToNestedMenuRecursive",
    "slug": "TsFunction",
    "id": "dfsraolnnuhedjqgeibtictw",
    "description": "Transform a nested path object into a nested menu (MenuType), recursively",
    "operationName": "recursive-util",
    "rawText": " (\n  /**\n   * your nested path object that you want to create a menu for\n   */\n  nestedPathObject: NestedPathObject | null,\n  /**\n   * used for recursion to get the final url (defaults to empty array)\n   */\n  pathStack: string[] = [],\n  config?: {\n    target?: \"_blank\";\n    /**\n     * optionally , provide a callback function that returns the actual path\n     */\n    getHref?: (fullPath: string) => string;\n  }\n): MenuItemType[] | undefined => {\n  const target = config?.target;\n  const getHref = config?.getHref;\n\n  // base case\n  if (!nestedPathObject) return;\n\n  const menu: MenuItemType[] = Object.keys(nestedPathObject).map((path) => {\n    const newPathStack = pathStack.concat(path);\n    const fullPath = newPathStack.join(\"/\");\n    const children = nestedPathObjectToNestedMenuRecursive(\n      nestedPathObject[path],\n      newPathStack,\n      config\n    );\n\n    const href = getHref ? getHref(fullPath) : fullPath;\n\n    const menuItem: MenuItemType = {\n      // NB: if there is no path, the title  of the page should be \"home\"\n      title: path.length === 0 ? \"Home\" : path,\n      href,\n      target,\n      children,\n    };\n\n    return menuItem;\n  });\n\n  return menu;\n}"
  },
  "nestifyQueryPathObjectRecursive": {
    "name": "nestifyQueryPathObjectRecursive",
    "slug": "TsFunction",
    "id": "bqtcwpvrftttygjwmlsmoygw",
    "description": "",
    "operationName": "recursive-util",
    "rawText": " <T extends QueryPathObject>(\n  queryPathObjects: T[],\n  level?: number\n): NestedQueryPathObject<T>[] => {\n  console.log({ level });\n  const nestedPathObject: NestedQueryPathObject<T>[] = queryPathObjects.reduce(\n    (previous, current, currentIndex, queryPathObjects) => {\n      const queryPathRemainder =\n        current.queryPathRemainder || current.queryPath;\n      const parts: string[] = queryPathRemainder.split(\"/\");\n      const firstPart = parts.find((x) => x.length !== 0);\n\n      const hasFirstPartAlready = !!previous.find(\n        (x) => x.queryPathChunk === firstPart\n      );\n\n      if (hasFirstPartAlready) {\n        // Base case 1: if we already have it, skip it, go to the next\n        return previous;\n      }\n\n      const children = queryPathObjects\n        // not myself!\n        .filter((x) => x.queryPath !== current.queryPath)\n        .filter((x) => {\n          const queryPath = x.queryPathRemainder || x.queryPath;\n          const isMatch = queryPath.startsWith(firstPart + \"/\");\n          return isMatch;\n        })\n        .map((x) => {\n          // everything after the first part\n          const queryPathRemainder = x.queryPath.split(firstPart!)[1];\n          return { ...x, queryPathRemainder };\n        });\n\n      const newNestedQueryPathObject = {\n        ...current,\n        // queryPath: folderQueryPath,\n        children:\n          children.length === 0\n            ? undefined\n            : [\n                current,\n                ...nestifyQueryPathObjectRecursive(children, (level || 0) + 1),\n              ],\n        queryPathChunk: firstPart,\n      } as NestedQueryPathObject<T>;\n      // add the new one to the array\n      return [...previous, newNestedQueryPathObject];\n    },\n    [] as NestedQueryPathObject<T>[]\n  );\n\n  return nestedPathObject;\n}"
  },
  "queryPathsArrayToNestedPathObject": {
    "name": "queryPathsArrayToNestedPathObject",
    "slug": "TsFunction",
    "id": "pjvmkvzczljhtsuenwpitcxn",
    "description": "Handy function to transform an array of `querypaths` into a nested menu, assuming you want to create a new sub-menu for every path\n\nMay also work for relative filePaths\n\nInput:\n\n[\"hello/world\",\"hello/moon\",\"hello/sun\"]\n\nOutput:\n\n{\n\"hello\":{\n\"moon\":null,\n\"world\":null,\n\"sun\":null\n}\n}",
    "operationName": "recursive-util",
    "rawText": " (\n  queryPaths: string[]\n): NestedPathObject => {\n  const nestedPathObject: NestedPathObject = reduceQueryPathsRecursively(\n    queryPaths,\n    {}\n  );\n  return nestedPathObject;\n}"
  },
  "reduceQueryPathsRecursively": {
    "name": "reduceQueryPathsRecursively",
    "slug": "TsFunction",
    "id": "arbpnzlgcguexlpskkwnwgyw",
    "description": "",
    "operationName": "recursive-util",
    "rawText": " (\n  queryPaths: string[],\n  initialValue: NestedPathObject\n): NestedPathObject => {\n  const nestedPathObject = queryPaths.reduce((nestedPathObject, queryPath) => {\n    const parts: string[] = queryPath.split(\"/\");\n    const firstPart = parts[0];\n\n    // Base case 1: if we already have it, skip it\n    if (Object.keys(nestedPathObject).includes(firstPart)) {\n      return nestedPathObject;\n    }\n\n    const queryPathsHere = queryPaths\n      .filter((p) => p.startsWith(`${firstPart}/`))\n      .map((p) => p.substring(firstPart.length + 1));\n\n    // Base case 2: if it's a leaf (last item), and it has NO children, return it with value null\n    if (parts.length === 1 && queryPathsHere.length === 0) {\n      return { ...nestedPathObject, [firstPart]: null };\n    }\n\n    // Recursion case: find all queryPaths starting with the same branch\n    const newNestedPathObject: NestedPathObject = {\n      ...nestedPathObject,\n      [firstPart]: reduceQueryPathsRecursively(queryPathsHere, {}),\n    };\n\n    return newNestedPathObject;\n  }, initialValue);\n\n  return nestedPathObject;\n}"
  },
  "AppsMenu": {
    "name": "AppsMenu",
    "slug": "TsFunction",
    "id": "kzzwtzphryalsffyfymxohwr",
    "description": "",
    "operationName": "apps-menu",
    "rawText": " () => {\n  const [loading, setLoading] = useState<{ [appName: string]: boolean }>({});\n  const appsQuery = queries.useGetAllAppOperations();\n  const alert = useAlert();\n  return (\n    <Div className=\"flex flex-row flex-wrap justify-center gap gap-2\">\n      {appsQuery.data?.result\n        ?.filter((x) => x.name !== \"function-server\")\n        .map((appOperation) => {\n          return (\n            <Div\n              key={appOperation.name}\n              className=\"z-50 flex flex-col items-center cursor-pointer\"\n              onClick={async () => {\n                const goToSite = () => {\n                  const url = `http://localhost:${appOperation.port}`;\n                  window.open(url, \"_blank\");\n                };\n\n                if (!appOperation.isOnline) {\n                  setLoading({ ...loading, [appOperation.name]: true });\n                  const { result, isSuccessful, message } = await api.startApp(\n                    appOperation.name,\n                    true\n                  );\n\n                  if (!isSuccessful || !result?.isSuccessful) {\n                    alert?.(\n                      `Error`,\n                      result?.error?.message || message || \"No message\"\n                    );\n                    setLoading({ ...loading, [appOperation.name]: false });\n                    return;\n                  }\n\n                  // TODO: apparently we need to wait a second before the next.js project is really start up... we can easily improve this by watching the stdout on the server and look for a message that says \"it's running on http://localhost:PORT\"\n                  setTimeout(() => {\n                    goToSite();\n                    appsQuery.refetch();\n                    setLoading({ ...loading, [appOperation.name]: false });\n                  }, 1000);\n\n                  return;\n                }\n                // if the app is already turned on, don't load, don't open api, just go there...\n                goToSite();\n              }}\n            >\n              <Tooltip\n                placement=\"top\"\n                tooltip={\n                  <MarkdownContent\n                    content={\n                      appOperation.description ||\n                      appOperation.name ||\n                      \"No description set\"\n                    }\n                    config={{}}\n                  />\n                }\n              >\n                <Div className=\"bg-white border border-black mb-2 rounded-lg w-12 h-12 flex items-center justify-center hover:scale-150 hover:mt-3 hover:-mb-3 transition-all\">\n                  {loading[appOperation.name] === true ? (\n                    <FancyLoader medium />\n                  ) : (\n                    <P title={appOperation.name} className=\"text-4xl\">\n                      {appOperation.emoji ||\n                        appOperation.name.charAt(0).toLocaleUpperCase()}\n                    </P>\n                  )}\n                </Div>\n              </Tooltip>\n\n              {appOperation.isOnline ? (\n                <Div className=\"w-2 h-2 rounded-full bg-gray-700 dark:bg-gray-200\" />\n              ) : (\n                <Div className=\"w-2 h-2\" />\n              )}\n            </Div>\n          );\n        })}\n    </Div>\n  );\n}"
  },
  "AuthenticationMethodsCrud": {
    "name": "AuthenticationMethodsCrud",
    "slug": "TsFunction",
    "id": "yztxdzowqulurhuqfcqokaze",
    "description": "",
    "operationName": "authentication",
    "rawText": " () => {\n  return <Div>Coming soon!</Div>;\n}"
  },
  "LoginForm": {
    "name": "LoginForm",
    "slug": "TsFunction",
    "id": "heloxmbuezpwuaftznxbkxrw",
    "description": "",
    "operationName": "authentication",
    "rawText": " () => {\n  const router = useRouter();\n  const meQuery = queries.useGetMeWithContext();\n\n  return (\n    <Div className=\"flex flex-1 flex-col mx-10\">\n      <P className=\"text-4xl\">Login</P>\n\n      {/* <Input\n        className={UI.textInput}\n        placeholder=\"Password\"\n        type=\"password\"\n        value={pass}\n        onChange={(e) => setPass(e.target.value)}\n      />\n      <BigButton title=\"Login\" onClick={() => router.reload()} /> */}\n\n      {/* New way */}\n      <FunctionForm\n        tsFunction={Index}\n        withApiResult={(\n          result: RealApiReturnType<\"loginWithPasswordWithContext\">\n        ) => {\n          if (result.isSuccessful && result.result?.isSuccessful) {\n            router.push(\"/\");\n          }\n          meQuery.refetch();\n          showStandardResponse(result);\n        }}\n      />\n      <ALink href=\"/signup\">Or click here to sign up</ALink>\n    </Div>\n  );\n}"
  },
  "LoginWrapper": {
    "name": "LoginWrapper",
    "slug": "TsFunction",
    "id": "uyrqeihawnlaezascmussvar",
    "description": "ensures the auth-token is set",
    "operationName": "authentication",
    "rawText": " (props: { children: any }) => {\n  const { children } = props;\n  const [authToken, setAuthToken, { hydrated }] = useStore(\"api.authToken\");\n\n  // Ensure there is an authToken\n  useEffect(() => {\n    if (!hydrated) return;\n    if (!authToken || authToken.length === 0) {\n      setAuthToken(generateId());\n    }\n  }, [authToken, hydrated]);\n\n  return children;\n}"
  },
  "MeAuthenticationInfo": {
    "name": "MeAuthenticationInfo",
    "slug": "TsFunction",
    "id": "rpgawuzfuovdcwtyxzqowaxg",
    "description": "little component for in banner that shows your info on top, and links to signup/login etc",
    "operationName": "authentication",
    "rawText": " () => {\n  const meQuery = queries.useGetMeWithContext();\n\n  const personInfo: PersonInfo = destructureOptionalObject(\n    meQuery.data?.result?.device\n  );\n\n  // console.log({ personInfo, meQuery: meQuery.data?.result });\n\n  const router = useRouter();\n  // if no persons are connected, show circle with ? in front of user icon, with menu \"sign up\" and \"login\" next to it\n\n  // if person is connected, that icon becomes your currentaPerson picture, the text your name. if you click on it, it drops down to show the other persons connected to your device, but also \"login and sign up\"\n\n  const nobodyOrCurrent: PictureWithInfo<Person> =\n    personInfo.currentPersonCalculated\n      ? {\n          pictureUrl: itemGetBackendAssetUrl({\n            item: personInfo.currentPersonCalculated,\n            backendAsset: personInfo.currentPersonCalculated.pictureImage,\n          }),\n          info: personInfo.currentPersonCalculated?.name,\n          data: personInfo.currentPersonCalculated,\n        }\n      : {\n          info: \"Sign in\",\n          pictureUrl: undefined,\n        };\n\n  const dropdown: PictureWithInfo<Person>[] =\n    personInfo.persons?.map((x) => {\n      return {\n        pictureUrl: itemGetBackendAssetUrl({\n          item: x,\n          backendAsset: x.pictureImage,\n        }),\n        info: x.name,\n        data: x,\n        isCurrent: x.id === personInfo.currentPersonId,\n      };\n    }) || [];\n\n  return (\n    <PictureWithInfoDropdown\n      current={nobodyOrCurrent}\n      dropdown={dropdown}\n      extraItems={[\n        {\n          text: \"2FA Settings\",\n          onClick: () => router.push(`/2fa`),\n        },\n\n        {\n          text: \"Edit your profile\",\n          onClick: () => router.push(`/edit-profile`),\n        },\n\n        {\n          text: \"See your profile\",\n          onClick: () =>\n            router.push(`/profile?id=${personInfo.currentPersonId}`),\n        },\n        {\n          text: \"Login into another account\",\n          onClick: () => router.push(\"/login\"),\n        },\n        { text: \"Create a new account\", onClick: () => router.push(\"/signup\") },\n        {\n          text: `Logout from ${personInfo.currentPersonCalculated?.name}`,\n          onClick: async () => {\n            const { result, isSuccessful, message } =\n              await api.logoutWithContext();\n\n            meQuery.refetch();\n            successToast(\n              result?.message || message || \"something went wrong (no message)\"\n            );\n          },\n        },\n      ]}\n      isLoading={meQuery.isLoading}\n      onClickCurrent={\n        personInfo.currentPersonCalculated\n          ? undefined\n          : () => router.push(\"/signup\")\n      }\n      onSelectDropdownItem={async (item) => {\n        if (item?.id) {\n          const { result } = await api.switchCurrentPersonWithContext(item?.id);\n\n          toast(\n            {\n              title: result?.isSuccessful ? \"Done\" : \"Error\",\n              body: result?.message || \"Somethign went wrong\",\n            },\n            { hideProgressBar: true, position: \"bottom-right\", type: \"success\" }\n          );\n\n          meQuery.refetch();\n        }\n      }}\n    />\n  );\n}"
  },
  "PersonProfileDetailsForm": {
    "name": "PersonProfileDetailsForm",
    "slug": "TsFunction",
    "id": "oqmerblfnxbnbskfcecqjgqc",
    "description": "",
    "operationName": "authentication",
    "rawText": " (props: {\n  personProfileDetails: PersonProfileDetails;\n}) => {\n  const meQuery = queries.useGetMeWithContext();\n\n  const projectRelativeStorageFilePath =\n    meQuery.data?.result?.device?.currentPersonCalculated?.projectRelativePath;\n  const [form, details, onChange] = useTsInterfaceForm(\n    PersonProfileDetailsIndex as Storing<TsInterface>,\n    \"test\",\n    props.personProfileDetails,\n    projectRelativeStorageFilePath,\n    \"Person\"\n  );\n\n  return form ? (\n    <FormContainer\n      onSubmit={async () => {\n        if (!details || !projectRelativeStorageFilePath) return;\n        const apiResult = await api.updateMeWithContext(details);\n        showStandardResponse(apiResult);\n        await meQuery.refetch();\n      }}\n    >\n      {form}\n    </FormContainer>\n  ) : null;\n}"
  },
  "PictureWithInfoDropdown": {
    "name": "PictureWithInfoDropdown",
    "slug": "TsFunction",
    "id": "lbdngoqpzfrscimbnysdfviz",
    "description": "Dumb (presentational) component for a picture with info and a dropdown",
    "operationName": "authentication",
    "rawText": " <T extends unknown>(props: {\n  current: PictureWithInfo<T>;\n  dropdown: PictureWithInfo<T>[];\n  extraItems?: { onClick: () => void; text: string }[];\n  isLoading: boolean;\n  /**\n   * if not given, dropdown is opened\n   */\n  onClickCurrent?: () => void;\n  onSelectDropdownItem: (selected: PictureWithInfo<T>[\"data\"]) => void;\n}) => {\n  const {\n    current,\n    dropdown,\n    isLoading,\n    onClickCurrent,\n    onSelectDropdownItem,\n    extraItems,\n  } = props;\n\n  const router = useRouter();\n\n  const [showDropdown, setShowDropdown] = useState(false);\n\n  const toggleDropdown = () => {\n    setShowDropdown(!showDropdown);\n  };\n\n  return (\n    <Div className=\"relative\">\n      <Div\n        className=\"cursor-pointer flex flex-row justify-end pr-2 items-center gap gap-2\"\n        onClick={onClickCurrent || toggleDropdown}\n      >\n        {isLoading ? (\n          <FancyLoader />\n        ) : current.pictureUrl ? (\n          <Image\n            src={current.pictureUrl}\n            className=\"rounded-full w-8 h-8 border border-black p-0.5 bg-gray-400\"\n          />\n        ) : null}\n        <P>{current.info}</P>\n      </Div>\n      <Div className=\"relative\">\n        {showDropdown ? (\n          <Div className=\"absolute top-0 right-0 bg-slate-400 min-w-[200px] rounded-md\">\n            <b>Your accounts</b>\n            {dropdown.map((item) => {\n              return (\n                <Div\n                  className={`${\n                    item.isCurrent\n                      ? \"bg-slate-600\"\n                      : \"hover:rounded-md hover:bg-slate-600\"\n                  } px-2 cursor-pointer py-1`}\n                  onClick={() => {\n                    if (item.isCurrent) return;\n                    if (item.url) {\n                      router.push(item.url);\n                      return;\n                    }\n                    toggleDropdown();\n                    onSelectDropdownItem(item.data);\n                  }}\n                >\n                  {item.info}\n                </Div>\n              );\n            })}\n\n            <Div className=\"h-4\" />\n            <b>More</b>\n\n            {extraItems?.map((item) => {\n              return (\n                <Div\n                  className=\"hover:bg-slate-600 hover:rounded-md text-xs cursor-pointer p-2\"\n                  onClick={() => {\n                    toggleDropdown();\n                    item.onClick();\n                  }}\n                >\n                  {item.text}\n                </Div>\n              );\n            })}\n          </Div>\n        ) : null}\n      </Div>\n    </Div>\n  );\n}"
  },
  "PublicPersonComponent": {
    "name": "PublicPersonComponent",
    "slug": "TsFunction",
    "id": "dkdlvwoykevuphxeznclaauw",
    "description": "",
    "operationName": "authentication",
    "rawText": " (props: {\n  publicPerson: PublicPerson | undefined;\n}) => {\n  const { publicPerson } = props;\n\n  return !publicPerson ? null : (\n    <Div className=\"w-ful\">\n      <ModelItemAssetView\n        item={publicPerson}\n        backendAsset={publicPerson?.pictureImage}\n        hideDownloadLink\n        className=\"w-full\"\n      />\n      <P>{publicPerson.name}</P>\n    </Div>\n  );\n}"
  },
  "PublicProfile": {
    "name": "PublicProfile",
    "slug": "TsFunction",
    "id": "acohvquwvygchepxtopirtnt",
    "description": "",
    "operationName": "authentication",
    "rawText": " () => {\n  const router = useRouter();\n\n  const id = router.query?.id ? takeFirst(router.query.id) : undefined;\n  const publicPersonQuery = queries.useGetPublicPerson(id);\n\n  const publicPerson = publicPersonQuery.data?.result;\n\n  return (\n    <Div>\n      {publicPersonQuery.isLoading ? <FancyLoader /> : null}\n\n      <PublicPersonComponent publicPerson={publicPerson} />\n    </Div>\n  );\n}"
  },
  "SignupForm": {
    "name": "SignupForm",
    "slug": "TsFunction",
    "id": "rjemsyrufdnxbtjehnnihckx",
    "description": "",
    "operationName": "authentication",
    "rawText": " () => {\n  const router = useRouter();\n  const meQuery = queries.useGetMeWithContext();\n\n  return (\n    <Div className=\"flex flex-1 flex-row mx-10\">\n      <Div className=\"flex flex-1 flex-col\">\n        <P className=\"text-4xl\">Sign up</P>\n        <FunctionForm\n          modelName=\"Person\"\n          projectRelativeStorageFilePath=\"db/persons.json\"\n          tsFunction={Index}\n          withApiResult={(\n            result: RealApiReturnType<\"signupWithPasswordWithContext\">\n          ) => {\n            if (result.isSuccessful && result.result?.isSuccessful) {\n              router.push(\"/\");\n            }\n            meQuery.refetch();\n            showStandardResponse(result);\n          }}\n        />\n        <ALink href=\"/login\">Or click here to login</ALink>\n      </Div>\n    </Div>\n  );\n}"
  },
  "UpdateMeForm": {
    "name": "UpdateMeForm",
    "slug": "TsFunction",
    "id": "eemeakbmqqyjdghimumaxsdz",
    "description": "",
    "operationName": "authentication",
    "rawText": " () => {\n  const meQuery = queries.useGetMeWithContext();\n\n  const person = meQuery.data?.result?.device?.currentPersonCalculated;\n  const personProfileDetails: PersonProfileDetails | undefined = person\n    ? {\n        name: person.name,\n        amountAuthenticationMethodsRequired:\n          person.amountAuthenticationMethodsRequired,\n        interestSlugs: person.interestSlugs,\n        media: person.media,\n        pictureImage: person.pictureImage,\n        preferred_mediaChannelId: person.preferred_mediaChannelId,\n        requiredAuthenticationMethods: person.requiredAuthenticationMethods,\n      }\n    : undefined;\n\n  return (\n    <Div className=\"flex flex-1 flex-row justify-center items-center\">\n      <Div className=\"w-96\">\n        <P className=\"text-4xl\">Update your profile</P>\n\n        {personProfileDetails ? (\n          <PersonProfileDetailsForm\n            personProfileDetails={personProfileDetails}\n          />\n        ) : null}\n      </Div>\n    </Div>\n  );\n}"
  },
  "CrudGrid": {
    "name": "CrudGrid",
    "slug": "TsFunction",
    "id": "eovgppslaglqhacjoelyipvd",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (props: CrudViewProps) => {\n  const { actions, data, highlight, tsInterface, onEndReached } = props;\n\n  return (\n    <Div className=\"flex flex-row flex-wrap\">\n      {data?.map((item) => {\n        const imageUrl = itemGetBackendAssetUrl({\n          item,\n          backendAsset: (item as any).pictureImage,\n        });\n        return imageUrl && typeof imageUrl === \"string\" ? (\n          <SpaceCard\n            ctaText=\"More info\"\n            imageUrl={imageUrl}\n            darkened={false}\n            secondaryImageUrl={imageUrl}\n            subtitle=\"Subtitle\"\n            title=\"Title\"\n          />\n        ) : (\n          \"no img url\"\n        );\n      })}\n    </Div>\n  );\n}"
  },
  "CrudTable": {
    "name": "CrudTable",
    "slug": "TsFunction",
    "id": "tzxtqubxouivtkudtkwbdhzz",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (props: CrudViewProps) => {\n  const { tsInterface, onEndReached, data, highlight, actions } = props;\n\n  const alert = useAlert();\n  const properties = getProperties(tsInterface?.type?.typeDefinition);\n  const dataParameterNames = getPropertiesDataParameterNames(properties);\n\n  const columns: ColumnType<any>[] = properties\n    // Omit referenced data\n    .filter((property) => !dataParameterNames.includes(property.name))\n    .map((property) => {\n      const referenceParameterInfo = getReferenceParameterInfo(property.name);\n      const {\n        descriptor,\n        interfaceName,\n        isReferenceMultipleParameter,\n        isReferenceParameter,\n        isReferenceSingleParameter,\n      } = referenceParameterInfo;\n\n      const isBackendAssetParameter = getAssetInputType(property.name);\n      const presentationType = isReferenceSingleParameter\n        ? \"referenceSingle\"\n        : isReferenceMultipleParameter\n        ? \"referenceMultiple\"\n        : isBackendAssetParameter\n        ? \"backendAsset\"\n        : \"text\";\n\n      const name =\n        isReferenceParameter && interfaceName\n          ? descriptor\n            ? humanCase(`${descriptor}-${interfaceName}`)\n            : humanCase(interfaceName)\n          : humanCase(property.name);\n\n      const column: ColumnType<any> = {\n        name,\n        objectParameterKey: property.name,\n        presentationType,\n      };\n      return column;\n    })\n    .filter(notEmpty);\n\n  return (\n    <Table\n      data={data}\n      onEndReached={onEndReached}\n      shouldHighlightItem={(item: any) =>\n        !!(\n          (highlight.id && item.id === highlight.id) ||\n          (highlight.slug && item.slug === highlight.slug)\n        )\n      }\n      columns={columns}\n      renderExtraColumns={(item) => {\n        return (\n          <Div className=\"flex flex-row\">\n            {item\n              ? actions.map((action) => {\n                  return (\n                    <LabeledButton\n                      onClick={() => action.action(item)}\n                      title={action.name}\n                      emoji={action.emoji}\n                      size=\"small\"\n                    />\n                  );\n                })\n              : null}\n          </Div>\n        );\n      }}\n      extraColumnsAtStart\n    />\n  );\n}"
  },
  "CrudTimeline": {
    "name": "CrudTimeline",
    "slug": "TsFunction",
    "id": "tltmecuaodputmhwggkeinoa",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (props: CrudViewProps) => {\n  return <Div />;\n}"
  },
  "CrudTree": {
    "name": "CrudTree",
    "slug": "TsFunction",
    "id": "pkmkcgnrtsvcuraazjjdeuyf",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (props: CrudViewProps) => {\n  return <Div />;\n}"
  },
  "DatasetForm": {
    "name": "DatasetForm",
    "slug": "TsFunction",
    "id": "tsekutjabckawdzbevyoaccb",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (props: { modelName: string }) => {\n  const { modelName } = props;\n\n  const [datasetConfig, setDatasetConfig] = useStore(\"db-crud.datasetConfig\");\n\n  const [form, datasetConfigForm] = useTsInterfaceForm(\n    DatasetConfigIndex as Storing<TsInterface>,\n    datasetConfig?.id || \"noid\",\n    datasetConfig\n  );\n\n  const addDatasetFromDatasetConfig = async () => {\n    if (!modelName) return;\n\n    let name = prompt(\"What should be the name?\", \"untitled\");\n    const dataset: Creation<Dataset> = {\n      ...datasetConfigForm,\n      modelName,\n      name: name || \"untitled\",\n    };\n\n    const { isSuccessful, result, message } = await api.upsertDbModel(\n      \"Dataset\",\n      //@ts-ignore\n      dataset,\n      true\n    );\n\n    metadataQuery.refetch();\n\n    successToast(\n      isSuccessful && result?.isSuccesful\n        ? \"Succesfully added\"\n        : result?.message || message || \"Error\"\n    );\n  };\n\n  const metadataQuery = queries.useGetDbModelMetadata(modelName as DbModelEnum);\n  const { datasets, tsInterface } = destructureOptionalObject(\n    metadataQuery.data?.result\n  );\n\n  const removeDataset = async () => {\n    if (!datasetConfig?.id) return;\n\n    const { isSuccessful, result, message } = await api.deleteDbModel(\n      \"Dataset\",\n      datasetConfig.id\n    );\n\n    // refetch datasets\n    metadataQuery.refetch();\n    setDatasetConfig(null);\n\n    successToast(\n      isSuccessful && result?.isSuccesful\n        ? \"Succesfully removed\"\n        : result?.message || message || \"Error\"\n    );\n  };\n\n  const properties = getProperties(tsInterface?.type?.typeDefinition);\n\n  return (\n    <Div className=\"border rounded-md border-gray-700\">\n      <P className=\"text-3xl\">Dataset Configuration</P>\n\n      {form}\n\n      <ClickableIcon\n        emoji=\"âž• New dataset\"\n        onClick={addDatasetFromDatasetConfig}\n      />\n\n      <ClickableIcon\n        emoji=\"ðŸ§ª Apply\"\n        onClick={() =>\n          datasetConfigForm !== undefined\n            ? setDatasetConfig(datasetConfigForm)\n            : null\n        }\n      />\n\n      <ClickableIcon\n        emoji=\"ðŸ§¹ Clear dataset\"\n        onClick={() => setDatasetConfig(null)}\n      />\n      {datasetConfig?.id ? (\n        <ClickableIcon emoji=\"ðŸ—‘ Remove dataset\" onClick={removeDataset} />\n      ) : null}\n    </Div>\n  );\n}"
  },
  "dbCrudInitialValues": {
    "name": "dbCrudInitialValues",
    "slug": "TsVariable",
    "id": "allzjhwgppkjqamrmtvyovqr",
    "description": "",
    "operationName": "db-crud"
  },
  "DbPage": {
    "name": "DbPage",
    "slug": "TsFunction",
    "id": "hkglbehmbkdqfqyblqjhkopi",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (props: {\n  filter?: (item: AugmentedAnyModelType) => boolean;\n  modelName?: string;\n}) => {\n  const router = useRouter();\n  const { modelName, filter } = props;\n  const paths = router.query.paths ? makeArray(router.query.paths) : [];\n  const modelQuery = modelName || paths.pop();\n  const [slug] = useUrl(\"slug\");\n  const [id] = useUrl(\"id\");\n\n  return (\n    <Div scroll>\n      <ModelComponent modelName={modelQuery} highlight={{ slug, id }} />\n    </Div>\n  );\n}"
  },
  "defaultLimit": {
    "name": "defaultLimit",
    "slug": "TsVariable",
    "id": "vsxzmrvouwusxxcvojrarola",
    "description": "",
    "operationName": "db-crud"
  },
  "{ deleteDbModel }": {
    "name": "{ deleteDbModel }",
    "slug": "TsVariable",
    "id": "mjwcyfbygpoyrvffbpbkarok",
    "description": "",
    "operationName": "db-crud"
  },
  "{ getDbModel }": {
    "name": "{ getDbModel }",
    "slug": "TsVariable",
    "id": "bnrjhjiwvjzrtqvhuxcvbnlh",
    "description": "",
    "operationName": "db-crud"
  },
  "getPropertiesDataParameterNames": {
    "name": "getPropertiesDataParameterNames",
    "slug": "TsFunction",
    "id": "dpsnphycipymmepnxsxjyega",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (\n  properties: SchemaProperty[]\n) => {\n  const dataParameterNames = properties\n    .map((property) => {\n      const { dataParameterName } = getReferenceParameterInfo(property.name);\n\n      return dataParameterName;\n    })\n    .filter(notEmpty);\n\n  return dataParameterNames;\n}"
  },
  "IndexInstanceContainer": {
    "name": "IndexInstanceContainer",
    "slug": "TsFunction",
    "id": "wfkuqlyswoqbalayawsozjrs",
    "description": "container for any index instance that needs to be rendered in the explore page",
    "operationName": "db-crud",
    "rawText": " ({\n  title,\n  children,\n  buttons,\n}: {\n  title: string;\n  children: any;\n  buttons: LabeledButtonType[];\n}) => {\n  return (\n    <Div className=\"p-2 m-2 border rounded-xl border-gray-500\">\n      <Div className=\"flex flex-row justify-between items-center\">\n        <P className=\"text-3xl\">{title}</P>\n\n        <Div className=\"flex flex-row gap-3\">{buttons.map(LabeledButton)}</Div>\n      </Div>\n\n      {children}\n    </Div>\n  );\n}"
  },
  "{ isBetaEnabled }": {
    "name": "{ isBetaEnabled }",
    "slug": "TsVariable",
    "id": "vryfsgpdzsdqwyupbyaajscq",
    "description": "",
    "operationName": "db-crud"
  },
  "ModelComponent": {
    "name": "ModelComponent",
    "slug": "TsFunction",
    "id": "ztdpphkwirmrlgxuwnrimsro",
    "description": "In the table headings, all xxxSlug, xxxId etc should be called xxx.\n\nIn the table values, all slugs and ids should show the name of the instance of the refered model.\n\nIt has to be possible to navigate to an id or slug using `#[id] or #[slug]` in the URL, just add div ids to all rows",
    "operationName": "db-crud",
    "rawText": " (props: {\n  modelName?: string;\n  highlight: Highlight;\n}) => {\n  const { modelName, highlight } = props;\n  const alert = useAlert();\n  const router = useRouter();\n\n  const views = modelViews.map((modelView) => ({\n    value: modelView.view,\n    label: `${modelView.emoji} ${modelView.view}`,\n  }));\n\n  const [SelectView, viewItem] = useSelect(views, views[0]);\n  const view = viewItem!.value;\n\n  const metadataQuery = queries.useGetDbModelMetadata(modelName as DbModelEnum);\n  const { datasets, tsInterface } = destructureOptionalObject(\n    metadataQuery.data?.result\n  );\n\n  const datasetItems = datasets?.map((dataset) => ({\n    label: dataset.name,\n    value: dataset.id,\n    data: dataset,\n  }));\n\n  const datasetSelectItems: Item<Dataset>[] = [\n    { value: \"\", label: \"Select a dataset\" },\n    ...(datasetItems || []),\n    { value: \"new\", label: \"(+) New dataset\" },\n  ];\n\n  const [SelectDataset] = useSelect(\n    datasetSelectItems,\n    undefined,\n    (newValue) => {\n      if (newValue?.value === \"new\") {\n        // show a blank screen\n        setDatasetConfig({ key: `config${Math.random()}` });\n        return;\n      }\n\n      if (newValue?.value === \"\") {\n        setDatasetConfig(null);\n        return;\n      }\n\n      if (newValue?.data) {\n        setDatasetConfig({ ...newValue.data, key: `config${Math.random()}` });\n        return;\n      }\n    }\n  );\n\n  const [datasetConfig, setDatasetConfig] = useStore(\"db-crud.datasetConfig\");\n\n  const model = useInfiniteGetDbModel();\n  const modelReferences = queries.useGetReferencableModelData(\n    modelName as DbModelEnum\n  );\n\n  const isLoading = model.isLoading || model.isRefetching || model.isFetching;\n\n  const allData = model?.data?.pages\n    .map((x) => x.result?.data)\n    .flat()\n    .filter(notEmpty);\n\n  // const  count = sum(model.data?.pages.map((x) => x.result?.data.length || 0) || []);\n\n  const indexDescription = tsInterface ? (\n    <Div>\n      <P className=\"font-bold\">{tsInterface.name}</P>\n\n      <MarkdownContent\n        content={tsInterface.description || \"no description\"}\n        config={{\n          projectRelativeBaseFolderPath: getFolderJs(\n            tsInterface.projectRelativePath\n          ),\n          projectRelativeMarkdownFilePath: tsInterface.projectRelativePath,\n        }}\n      />\n    </Div>\n  ) : isLoading ? (\n    <Div />\n  ) : (\n    \"No index found\"\n  );\n\n  const headerButtons = (\n    <Div className=\"flex flex-row items-center\">\n      <LabeledButton\n        onClick={() => router.push(`/upsert/${modelName}`)}\n        title=\"New\"\n        emoji=\"âž•\"\n      />\n\n      <LabeledButton\n        {...{\n          onClick: () => model.refetch(),\n          title: \"Reload\",\n          emoji: isLoading ? undefined : \"ðŸ”„\",\n          component: isLoading ? () => <FancyLoader medium /> : undefined,\n        }}\n      />\n\n      {isBetaEnabled ? <SelectView /> : null}\n\n      {isBetaEnabled ? <SelectDataset /> : null}\n\n      <SearchBar />\n    </Div>\n  );\n\n  const onEndReached = () => {\n    const pages = model.data?.pages;\n\n    const lastPage = pages ? pages[pages.length - 1] : undefined;\n\n    const hasMore = lastPage?.result?.hasMore;\n\n    if (hasMore && !model.isFetchingNextPage) {\n      model.fetchNextPage();\n    }\n  };\n\n  const deleteItem = (item: AugmentedAnyModelType) => {\n    alert?.(\"Are you sure?\", \"Do you want to delete this one?\", [\n      {\n        text: \"Yes\",\n        style: \"destructive\",\n        onPress: () => {\n          if (item?.id) {\n            // console.log({ id: item.id });\n            deleteDbModel(modelName as any, item.id).then((result) => {\n              model.refetch();\n              modelReferences.refetch();\n            });\n          }\n        },\n      },\n      { text: \"Cancel\", style: \"cancel\" },\n    ]);\n  };\n\n  const deleteAction: ItemAction = {\n    action: deleteItem,\n    emoji: \"âŒ\",\n    name: \"Delete\",\n  };\n\n  const updateItem = (item: AugmentedAnyModelType) =>\n    router.push(`/upsert/${modelName}?id=${item?.id}`);\n\n  const updateAction: ItemAction = {\n    name: \"Update\",\n    emoji: \"âœï¸\",\n    action: updateItem,\n  };\n\n  const actions: ItemAction[] = [deleteAction, updateAction];\n\n  const CrudView = {\n    table: CrudTable,\n    grid: CrudGrid,\n    timeline: CrudTimeline,\n    tree: CrudTree,\n  }[view];\n\n  const crudViewProps: CrudViewProps = {\n    actions,\n\n    //@ts-ignore\n    data: allData,\n    highlight,\n    tsInterface,\n    onEndReached,\n  };\n\n  return (\n    <Div>\n      <Div className=\"px-8 lg:px-20 py-4\">\n        {headerButtons}\n        {indexDescription}\n\n        {datasetConfig && modelName && isBetaEnabled ? (\n          <DatasetForm key={datasetConfig.key} modelName={modelName} />\n        ) : null}\n      </Div>\n\n      {/* NB: here a table view should be rendered */}\n      {Array.isArray(allData) && allData.length > 0 && CrudView ? (\n        <CrudView {...crudViewProps} />\n      ) : null}\n    </Div>\n  );\n}"
  },
  "openWhatsapp": {
    "name": "openWhatsapp",
    "slug": "TsFunction",
    "id": "yoghsjbkpjhbofxfnassgjsd",
    "description": "",
    "operationName": "db-crud",
    "rawText": " ({\n  phone,\n  text,\n}: {\n  phone: string;\n  text: string;\n}) => {\n  const url =\n    \"https://api.whatsapp.com/send/\" +\n    toQueryString({ phone, text, app_absent: 0 });\n  window.open(url, \"_blank\")?.focus();\n}"
  },
  "shimmer": {
    "name": "shimmer",
    "slug": "TsFunction",
    "id": "tnzhzfnawnfmjduvzelcmuan",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (w: number, h: number) => `\n<svg width=\"${w}\" height=\"${h}\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n  <defs>\n    <linearGradient id=\"g\">\n      <stop stop-color=\"#CCC\" offset=\"20%\" />\n      <stop stop-color=\"#AAA\" offset=\"50%\" />\n      <stop stop-color=\"#CCC\" offset=\"70%\" />\n    </linearGradient>\n  </defs>\n  <rect width=\"${w}\" height=\"${h}\" fill=\"#CCC\" />\n  <rect id=\"r\" width=\"${w}\" height=\"${h}\" fill=\"url(#g)\" />\n  <animate xlink:href=\"#r\" attributeName=\"x\" from=\"-${w}\" to=\"${w}\" dur=\"1s\" repeatCount=\"indefinite\"  />\n</svg>`"
  },
  "SimplifiedSchemaFormDebug": {
    "name": "SimplifiedSchemaFormDebug",
    "slug": "TsFunction",
    "id": "uraqxjvwxsthharpsskfffeb",
    "description": "",
    "operationName": "db-crud",
    "rawText": " ({\n  parameters,\n  values,\n}: {\n  parameters: FunctionParameter[] | undefined;\n  values: any[];\n}) => {\n  const [showParams, setShowParams] = useState(false);\n  return (\n    <Div>\n      <P>values</P>\n      <MarkdownContent\n        content={createCodeblockMarkdown(\n          JSON.stringify(values, null, 2),\n          \"json\"\n        )}\n        config={{}}\n      />\n      <P\n        className=\"hover:underline cursor-pointer\"\n        onClick={() => setShowParams(!showParams)}\n      >\n        params (toggle)\n      </P>{\" \"}\n      {showParams ? (\n        <MarkdownContent\n          content={createCodeblockMarkdown(\n            JSON.stringify(parameters, null, 2),\n            \"json\"\n          )}\n          config={{}}\n        />\n      ) : null}\n    </Div>\n  );\n}"
  },
  "sortToItem": {
    "name": "sortToItem",
    "slug": "TsFunction",
    "id": "edcmllujjgowegxgvaypteuw",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (sort: DatasetSort): Item<DatasetSort> => {\n  return {\n    label: `${sort.sortDirection === \"ascending\" ? \"â†‘\" : \"â†“\"} ${humanCase(\n      sort.objectParameterKey\n    )}`,\n    value: `${sort.objectParameterKey},${sort.sortDirection}`,\n    data: sort,\n  };\n}"
  },
  "SpaceCard": {
    "name": "SpaceCard",
    "slug": "TsFunction",
    "id": "zqmmpmdjdjigkonlmbivrakv",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (props: {\n  secondaryImageUrl: string | null;\n  darkened: boolean;\n  base64?: string;\n  imageUrl: string;\n  ctaText: string;\n  title: string;\n  subtitle: string;\n  action?: () => any;\n}) => {\n  const {\n    secondaryImageUrl,\n    darkened,\n    base64,\n    ctaText,\n    imageUrl,\n    subtitle,\n    title,\n    action,\n  } = props;\n  const [isImageReady, setIsImageReady] = useState(false);\n\n  const onLoadCallBack = () => {\n    setIsImageReady(true);\n  };\n\n  return (\n    <ALink onClick={() => action?.()}>\n      <a\n        target={\"_blank\"}\n        className=\"transition duration-300 ease-out transform cursor-pointer mb-2\"\n      >\n        <div\n          className={`relative m-2 overflow-hidden text-center rounded-xl lg:h-[268px] lg:w-[268px] h-72 w-72 ${\n            darkened ? \"bg-black\" : \"\"\n          }`}\n        >\n          {!isImageReady && (\n            <div className={`bg-gray-300 rounded-xl flex flex-1`} />\n          )}\n          {secondaryImageUrl ? (\n            <img\n              className={`rounded-xl ${darkened ? \"opacity-50\" : \"\"}`}\n              src={secondaryImageUrl}\n              // layout=\"fill\"\n              // alt=\"banner\"\n              // onLoad={onLoadCallBack}\n              // placeholder=\"blur\"\n              // objectFit=\"cover\"\n              // blurDataURL={\n              //   base64 ||\n              //   `data:image/svg+xml;base64,${toBase64(shimmer(320, 320))}`\n              // }\n            />\n          ) : null}\n          <div className=\"absolute inset-0 duration-300 ease-in-out rounded-lg group hover:bg-black hover:bg-opacity-40\">\n            <button className=\"invisible px-4 py-2 text-sm border-2 rounded-md text-white group-hover:visible group-hover:transition duration-450 mt-28\">\n              <p className=\"flex\">\n                <div className=\"\">ðŸ”</div>\n                <p className=\"ml-2 font-bold\">{ctaText}</p>\n              </p>\n            </button>\n          </div>\n        </div>\n        <div className=\"flex justify-between mx-2 mt-2\">\n          <div className=\"flex space-x-2\">\n            {imageUrl ? (\n              <img\n                alt=\"host image\"\n                src={imageUrl}\n                width={40}\n                height={37}\n                className=\"rounded-full\"\n                // objectFit=\"cover\"\n              />\n            ) : null}\n            <div className=\"flex flex-col\">\n              <h3 className=\"text-black text-sm\">{title}</h3>\n              <h3 className=\"text-sm text-[#C4C4C4]\">{subtitle}</h3>\n            </div>\n          </div>\n        </div>\n      </a>\n    </ALink>\n  );\n}"
  },
  "toBase64": {
    "name": "toBase64",
    "slug": "TsFunction",
    "id": "anxhrimlsjcfgljlxclsmuql",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (str: string) =>\n  typeof window === \"undefined\"\n    ? Buffer.from(str).toString(\"base64\")\n    : window.btoa(str)"
  },
  "{ upsertDbModel }": {
    "name": "{ upsertDbModel }",
    "slug": "TsVariable",
    "id": "vbywxgkfminjvrwscuptmfic",
    "description": "",
    "operationName": "db-crud"
  },
  "UpsertForm": {
    "name": "UpsertForm",
    "slug": "TsFunction",
    "id": "vcycupnwxnttiojadrjnihzr",
    "description": "TODO: Provide all the fetched data with `hasMore` and `fetchAll` to the `SimplifiedJsonForm`",
    "operationName": "db-crud",
    "rawText": " (props: {\n  /**\n   * the schema for the model we want to update/create\n   */\n  simplifiedSchema: SimplifiedSchema;\n  /**\n   * an instance, if it's an update form\n   */\n  instance: any;\n  /**\n   * NB: this thing will make hooks appear, so it must be constant!\n   */\n  referencableModelNames?: string[];\n  /**\n   * Provide this\n   */\n  modelName: string;\n}) => {\n  const { instance, simplifiedSchema, referencableModelNames, modelName } =\n    props;\n  const router = useRouter();\n  const alert = useAlert();\n  const [debug, setDebug] = useState(false);\n  const [id] = useState<string>(generateId());\n  const [loading, setLoading] = useState(false);\n  const [body, setBody] = useState<any>(instance);\n  const [result, setResult] = useState<any>();\n  const modelFromUrl = useModelFromUrl();\n  const metadataQuery = queries.useGetDbModelMetadata(modelFromUrl);\n  const model = useInfiniteGetDbModel();\n  const projectRelativeStorageFilePath =\n    metadataQuery.data?.result?.projectRelativeStorageFilePath;\n\n  // NB: all items that this model has can be referenced to in other forms also need to refresh\n\n  const getReferencableModelDataQuery = queries.useGetReferencableModelData(\n    modelFromUrl as DbModelEnum\n  );\n\n  const referencableModelData = useReferencableModelData(simplifiedSchema);\n\n  const parameters: RenderableFunctionParameter[] = [\n    {\n      name: \"\",\n      required: true,\n      simplifiedSchema,\n      renderButtons: () => <Span />,\n      isDbModel: true,\n    },\n  ];\n  const values = [body];\n\n  const onSubmitForm = () => {\n    if (!modelFromUrl) return;\n\n    setLoading(true);\n\n    upsertDbModel(modelFromUrl as any, body)\n      .then(async (result) => {\n        if (!result.result?.isSuccesful) {\n          // If the upsert fails for some reason, this should be made clear\n          alert?.(\"Error\", result.result?.message || result.message);\n          setLoading(false);\n        } else {\n          // NB: we are not waiting for this, we're going back immediately, assuming that there will be loading indicators\n          getReferencableModelDataQuery.refetch();\n          model.refetch();\n\n          setLoading(false);\n          router.back();\n        }\n      })\n      .catch((e) => {\n        setLoading(false);\n        setResult(e);\n      });\n  };\n\n  const explainButton = {\n    onClick: () => {\n      setDebug(!debug);\n    },\n    title: \"Explain\",\n    emoji: \"ðŸ§\",\n  };\n\n  const buttons: LabeledButtonType[] = [explainButton];\n\n  // console.log({ referencableModelData });\n  return (\n    <Div>\n      <IndexInstanceContainer\n        buttons={buttons}\n        title={humanCase(modelFromUrl || \"\")}\n      >\n        {simplifiedSchema ? (\n          <Div>\n            <FormContainer onSubmit={onSubmitForm} isLoading={loading}>\n              <SimplifiedSchemaForm\n                modelName={modelName}\n                itemNameOrId={body?.name || body?.id}\n                parameterNameStack={undefined}\n                projectRelativeStorageFilePath={projectRelativeStorageFilePath}\n                id={id}\n                parameters={parameters}\n                values={values}\n                onChange={(values) => setBody(values[0])}\n                referencableModelData={referencableModelData}\n                isDebug={debug}\n              />\n            </FormContainer>\n            <Div className=\"mt-6\">\n              <ClickableIcon emoji=\"âŒ Go back\" onClick={() => router.back()} />\n            </Div>\n            {result ? <P>{JSON.stringify(result)}</P> : null}\n            {debug ? (\n              <SimplifiedSchemaFormDebug\n                parameters={parameters}\n                values={values}\n              />\n            ) : null}\n          </Div>\n        ) : null}\n      </IndexInstanceContainer>\n    </Div>\n  );\n}"
  },
  "UpsertPage": {
    "name": "UpsertPage",
    "slug": "TsFunction",
    "id": "xsxjejhayncjbpztsvsvdwbt",
    "description": "",
    "operationName": "db-crud",
    "rawText": " () => {\n  const router = useRouter();\n  const query = mapValuesSync(router.query, (value) => takeFirst(value));\n  const model = useInfiniteGetDbModel();\n  const allItems = model?.data?.pages\n    ?.map((x) => x.result?.data)\n    .flat()\n    .filter(notEmpty) as AugmentedAnyModelType[];\n  const instance = allItems?.find((x) => x.id === query.id);\n  const modelName = useModelFromUrl();\n  const metadataQuery = queries.useGetDbModelMetadata(modelName);\n  const { tsInterface } = destructureOptionalObject(metadataQuery.data?.result);\n  const simplifiedSchema = tsInterface?.type?.simplifiedSchema;\n  const referencableModelNames = getReferencableModels(simplifiedSchema)\n    ?.map((x) => x.interfaceName)\n    .filter(notEmpty);\n\n  return (\n    <Div scroll className=\"py-4 px-8 lg:px-20\">\n      {model.isLoading ? (\n        <FancyLoader />\n      ) : !simplifiedSchema || !modelName ? (\n        <Div>Something's wrong</Div>\n      ) : (\n        <UpsertForm\n          modelName={modelName}\n          simplifiedSchema={simplifiedSchema}\n          instance={instance}\n          referencableModelNames={referencableModelNames}\n        />\n      )}\n    </Div>\n  );\n}"
  },
  "useInfiniteGetDbModel": {
    "name": "useInfiniteGetDbModel",
    "slug": "TsFunction",
    "id": "hayokecmaisjhkfryxpvdqvx",
    "description": "",
    "operationName": "db-crud",
    "rawText": " () => {\n  const modelName = useModelFromUrl();\n\n  const [datasetConfig] = useStore(\"db-crud.datasetConfig\");\n  const [search] = useStore(\"db-crud.search\");\n\n  const dependencies = [\"getDbModel\", modelName, datasetConfig, search];\n\n  const hook = useInfiniteQuery(\n    dependencies,\n    (context) => {\n      const params = context.pageParam as PageParam | undefined;\n\n      const configuration = {\n        ...datasetConfig,\n        startFromIndex:\n          (datasetConfig?.startFromIndex || 0) + (params?.start || 0),\n        maxRows: datasetConfig?.maxRows || params?.limit || defaultLimit,\n      };\n\n      // @ts-ignore\n      const result = getDbModel(modelName!, configuration, search);\n      return result;\n    },\n    {\n      getNextPageParam: (lastPage, allPages) => {\n        const realLimit =\n          lastPage.result?.datasetConfig?.maxRows || defaultLimit;\n        const oldStart = lastPage.result?.datasetConfig?.startFromIndex || 0;\n        const pageParam: PageParam = {\n          start: oldStart + realLimit,\n          limit: realLimit,\n        };\n\n        return pageParam;\n      },\n    }\n  );\n\n  return hook;\n}"
  },
  "useModelFromUrl": {
    "name": "useModelFromUrl",
    "slug": "TsFunction",
    "id": "ddkyrtztrxjstdwmijdksavs",
    "description": "takes the model from the url",
    "operationName": "db-crud",
    "rawText": " () => {\n  const router = useRouter();\n  const paths = router.query.paths ? makeArray(router.query.paths) : [];\n  const modelQuery = paths.pop();\n  return modelQuery;\n}"
  },
  "useUrl": {
    "name": "useUrl",
    "slug": "TsFunction",
    "id": "gievtktkttzhcqpuohmuescx",
    "description": "",
    "operationName": "db-crud",
    "rawText": " <T extends keyof typeof queryStore>(queryKey: T) => {\n  /**\n   * Here you can define your global storages that can be present in any URL\n   *\n   * Make sure you use the CustomUrlConfig type\n   */\n  const queryStore = {\n    path: useCustomUrlStore<string | undefined>(\"path\", { type: \"string\" }),\n    name: useCustomUrlStore<string | undefined>(\"name\", { type: \"string\" }),\n    type: useCustomUrlStore<string | undefined>(\"type\", { type: \"string\" }),\n\n    // for db page\n    slug: useCustomUrlStore<string | undefined>(\"slug\", { type: \"string\" }),\n    id: useCustomUrlStore<string | undefined>(\"id\", { type: \"string\" }),\n  };\n\n  return queryStore[queryKey];\n}"
  },
  "FileWriter": {
    "name": "FileWriter",
    "slug": "TsFunction",
    "id": "jxlvzjtguclwveswujurrxpi",
    "description": "",
    "operationName": "file-writer",
    "rawText": " (props: {\n  markdownModelName?: keyof DbModels;\n  projectRelativeFilePath: string;\n  initialWriterView?: WriterViewEnum;\n  disabledMenuItems?: string[];\n}) => {\n  const {\n    markdownModelName,\n    projectRelativeFilePath,\n    initialWriterView,\n    disabledMenuItems,\n  } = props;\n\n  // fullPath is the project relative path\n  const {\n    data: fileContentsResult,\n    isLoading,\n    refetch,\n  } = useGetFileContents(projectRelativeFilePath);\n  const fileContents = fileContentsResult?.result?.fileContents;\n\n  // console.log({ fileContents });\n  const [unsavedFiles, setUnsavedFiles] = useStore(\"unsavedFiles\");\n  const isSaved = unsavedFiles[projectRelativeFilePath] === undefined;\n\n  const value = isSaved\n    ? fileContents || \"\"\n    : unsavedFiles[projectRelativeFilePath] || \"\";\n  const onChange = (text: string) => {\n    setUnsavedFiles({ ...unsavedFiles, [projectRelativeFilePath]: text });\n  };\n\n  const save = async () => {\n    const apiResult = await saveFileContents(projectRelativeFilePath, value);\n    await refetch();\n    const { isSuccessful, result, message } = apiResult;\n\n    if (!isSuccessful || !result?.isSuccessful) {\n      toast({\n        title: \"Error\",\n        body: result?.message || message || \"Something went wrong\",\n      });\n    } else {\n      // removing the file that is now saved\n      const newUnsavedFiles = { ...unsavedFiles };\n      // NB: for some reason, delete` doesn't let the updated store rerender the object. React doesn't see the change! The solution is to also set it to undefined first.\n      newUnsavedFiles[projectRelativeFilePath] = undefined;\n      delete unsavedFiles[projectRelativeFilePath];\n\n      await setUnsavedFiles(newUnsavedFiles);\n    }\n  };\n\n  useHotkey(isCtrlS, save, [projectRelativeFilePath, value]);\n\n  const errorMessage = !fileContentsResult?.isSuccessful\n    ? fileContentsResult?.message\n    : !fileContentsResult?.result?.isSuccessful\n    ? fileContentsResult?.result?.message\n    : null;\n\n  return (\n    <Div className=\"flex flex-1 flex-col h-full\">\n      {errorMessage ? (\n        <P>{errorMessage}</P>\n      ) : (\n        <WriterInput\n          key={projectRelativeFilePath}\n          isLoading={isLoading}\n          onChange={onChange}\n          value={value}\n          projectRelativeFilePath={projectRelativeFilePath}\n          reload={refetch}\n          save={save}\n          initialWriterView={initialWriterView}\n          isSaved={isSaved}\n          markdownModelName={markdownModelName}\n          disabledMenuItems={disabledMenuItems}\n        />\n      )}\n    </Div>\n  );\n}"
  },
  "OpenFileWriterPages": {
    "name": "OpenFileWriterPages",
    "slug": "TsFunction",
    "id": "ptqqpbqalsdkrnujjxfzvoma",
    "description": "",
    "operationName": "file-writer",
    "rawText": " (props: {\n  pagesObject: PagesObjectShape;\n}) => {\n  const { pagesObject } = props;\n  return <FileTabs pagesObject={pagesObject} />;\n}"
  },
  "{ saveFileContents }": {
    "name": "{ saveFileContents }",
    "slug": "TsVariable",
    "id": "vrcnwvzyjwkfmyxunohisrxe",
    "description": "",
    "operationName": "file-writer"
  },
  "{ useGetFileContents }": {
    "name": "{ useGetFileContents }",
    "slug": "TsVariable",
    "id": "nerhiryndmlmastmsvjotzxt",
    "description": "",
    "operationName": "file-writer"
  },
  "WriterLayout": {
    "name": "WriterLayout",
    "slug": "TsFunction",
    "id": "nesaindqxwxbvnpcoxjruryt",
    "description": "",
    "operationName": "file-writer",
    "rawText": " (props: { children: JSX.Element }) => {\n  const { fullPath } = usePath();\n\n  return (\n    <Div\n      className={`flex flex-col flex-1 h-full`}\n      textClassName=\"dark:text-white\"\n    >\n      <Div className=\"sticky top-0\">\n        <OpenFileWriterPages pagesObject={{}} />\n        <BreadCrumbs path={fullPath || \"\"} />\n      </Div>\n      {props.children}\n    </Div>\n  );\n}"
  },
  "FunctionForm": {
    "name": "FunctionForm",
    "slug": "TsFunction",
    "id": "dnkzxdcflxhwklupwvqjptde",
    "description": "FunctionForm is a very easy way to create a frontend component that is connected with an api that is connected with a function on your backend (that can do anything)\n\nAll you need to provide is a `TsFunction`\n\nThis component only works if your `api` is up-to-date and your function is succesfully indexed using `typerepo`. For authentication, the `api` convention is used. See the `api` docs.\n\n@see TsFunction",
    "operationName": "function-form",
    "rawText": " <T extends (...params: any[]) => any>(props: {\n  /**\n   * Must be given if you want to store assets with this\n   */\n  projectRelativeStorageFilePath?: string;\n  /**\n   * Must be given if you want to store assets with this\n   */\n  modelName?: string;\n  /**\n   * Add the tsfunction here imported from `your-operation/db/ts-functions/[function-name].json` directly\n   *\n   * Typed as `any` because you can import it from JSON, but this should be a `TsFunction`.\n   *\n   * @see TsFunction\n   */\n  tsFunction: any;\n  /**\n   * For js functions, provide the function to be executed here. If not given, it will try to use the api.\n   *\n   * NB: this should be the same function as the function you provide the index of at `tsFunction`\n   */\n  submitFunction?: T;\n  /**\n   * If you provide a `submitFunction`, you can also provide a callback that does something with the result of the function\n   */\n  withResult?: (result: WithoutPromise<ReturnType<T>>) => void;\n  /**\n   * callback to call after the api has resulted with a result\n   *\n   * Please type this yourself as `RealApiReturnType<\"functionName\">`\n   *\n   * If you don't provide this but an api call is done, we'll call `showStandardResponse`\n   */\n  withApiResult?: (result: any) => void;\n  initialValues?: any[];\n  showResult?: boolean;\n  /**\n   * Provide referencable model data if you want to\n   */\n  referencableModelData?: ReferencableModelData;\n}) => {\n  const {\n    initialValues,\n    modelName,\n    projectRelativeStorageFilePath,\n    tsFunction,\n    submitFunction,\n    withResult,\n    withApiResult,\n    showResult,\n    referencableModelData,\n  } = props;\n  const { parameters, name } = tsFunction;\n  const isFirstParameterFunctionContext =\n    parameters?.[0]?.name === \"functionContext\";\n\n  const slicedParameters = isFirstParameterFunctionContext\n    ? parameters?.slice(1)\n    : parameters;\n\n  const [isLoading, setIsLoading] = useState(false);\n\n  const [values, setValues] = useState<any[]>(\n    slicedParameters?.map((_: any, index: number) => initialValues?.[index])\n  );\n\n  // console.log({ slicedParameters, initialValues, values });\n\n  const [result, setResult] = useState<RealApiReturnType<any> | undefined>(\n    undefined\n  );\n\n  if (!slicedParameters) {\n    console.log({\n      tsFunction,\n      parameters,\n      slicedParameters,\n      isFirstParameterFunctionContext,\n    });\n    return (\n      <Div>No parameters found, please find the tsFunction in console</Div>\n    );\n  }\n\n  const renderResult = () => {\n    return (\n      <Div>\n        {result?.isUnauthorized ? (\n          <P className=\"text-red-500 font-bold\">Unauthorized!</P>\n        ) : null}\n        {result?.errors?.map((error) => (\n          <P className=\"text-red-500\">{error.error}</P>\n        ))}\n        {result?.message ? (\n          <P\n            className={result.isSuccessful ? \"text-green-500\" : \"text-red-500\"}\n          >\n            {result.message}\n          </P>\n        ) : null}\n\n        {result?.result ? (\n          <textarea\n            className=\"w-full h-[300px]\"\n            value={JSON.stringify(result.result, undefined, 2)}\n          />\n        ) : null}\n      </Div>\n    );\n  };\n  return (\n    <Div>\n      <FormContainer\n        isLoading={isLoading}\n        onSubmit={async () => {\n          setIsLoading(true);\n\n          if (submitFunction) {\n            //@ts-ignore\n            const result = await submitFunction(...values);\n            withResult?.(result);\n\n            setIsLoading(false);\n\n            return;\n          }\n\n          // @ts-ignore\n          const apiFunction = api[name];\n\n          if (!apiFunction || typeof apiFunction !== \"function\") {\n            showStandardResponse({\n              isSuccessful: false,\n              message: \"Could not find this function in the SDK\",\n            });\n            setIsLoading(false);\n            return;\n          }\n\n          // Apply it if it's there\n          const apiResult = await apiFunction(...values);\n          setResult(apiResult);\n\n          if (withApiResult) {\n            withApiResult(apiResult);\n          } else {\n            showStandardResponse(apiResult);\n          }\n\n          setIsLoading(false);\n        }}\n      >\n        {showResult ? renderResult() : null}\n\n        <SimplifiedSchemaForm\n          projectRelativeStorageFilePath={projectRelativeStorageFilePath}\n          modelName={modelName}\n          parameters={slicedParameters}\n          id={name}\n          onChange={(values) => {\n            setValues(values);\n          }}\n          values={values}\n          referencableModelData={referencableModelData}\n        />\n      </FormContainer>\n    </Div>\n  );\n}"
  },
  "AuthenticationLayout": {
    "name": "AuthenticationLayout",
    "slug": "TsFunction",
    "id": "wvnthtrrfnxfffzqhwdiupit",
    "description": "Layout that includes default pages and header for authentication",
    "operationName": "layout",
    "rawText": " (props: {\n  /**\n   * If given, menu will be rendered\n   */\n  menu?: MenuProps;\n\n  overwriteDefaultPages?: string[];\n  customHeader?: React.ReactNode;\n  custom404Page?: React.ReactNode;\n  // how to build up the menu\n\n  // typed as any needed because of react-bug\n  nextPage?: any;\n  pageProps?: any;\n}) => {\n  const publicBundleConfig = queries.useGetPublicBundleConfig().data?.result;\n  const {\n    nextPage,\n    pageProps,\n    menu,\n    customHeader,\n    custom404Page,\n    overwriteDefaultPages,\n  } = props;\n  const router = useRouter();\n  const path = router.asPath.substring(1).split(\"?\")[0];\n\n  const pages: { [key: string]: (props?: any) => JSX.Element } = {\n    login: LoginForm,\n    signup: SignupForm,\n    \"edit-profile\": UpdateMeForm,\n    profile: PublicProfile,\n    \"2fa\": AuthenticationMethodsCrud,\n  };\n\n  const NextPage = nextPage;\n\n  // seems unneeded\n\n  // const hasQueryPath = !!menu?.queryPaths?.includes(path);\n  // const hasWebPage = !!menu?.webPagesFlat?.find((x) => x.queryPath === path);\n\n  // const hasWebPageInThisFolder = !!menu?.webPagesFlat?.find((x) =>\n  //   x.queryPath.startsWith(path)\n  // );\n\n  // const shouldRenderCustom =\n  //   hasQueryPath || hasWebPage || path === \"\" || hasWebPageInThisFolder;\n\n  const DefaultPage = pages[path] ? pages[path] : undefined;\n\n  const children =\n    DefaultPage && !overwriteDefaultPages?.includes(path) ? (\n      <DefaultPage />\n    ) : (\n      <NextPage {...pageProps} />\n    );\n\n  const header = (\n    <Div>\n      {customHeader !== undefined ? (\n        customHeader\n      ) : (\n        <Header publicBundleConfig={publicBundleConfig} />\n      )}\n    </Div>\n  );\n\n  return (\n    <LoginWrapper>\n      <LayoutGrid header={header} menu={menu}>\n        {children}\n      </LayoutGrid>\n    </LoginWrapper>\n  );\n}"
  },
  "Header": {
    "name": "Header",
    "slug": "TsFunction",
    "id": "dexmgkfzargymyisxsxkgaph",
    "description": "",
    "operationName": "reader-ui",
    "rawText": " (props: {\n  publicBundleConfig?: PublicBundleConfig | null;\n}) => {\n  const [isMobileMenuEnabled, setIsMobileMenuEnabled] = useStore(\n    \"menu.isMobileMenuEnabled\"\n  );\n  const { publicBundleConfig } = props;\n  const title =\n    publicLocalEnvironmentVariables.markdownReaderTitle ||\n    publicEnvironmentVariables.markdownReaderTitle ||\n    publicBundleConfig?.name;\n\n  return (\n    <Div\n      style={{\n        backgroundColor: props.publicBundleConfig?.primaryColor,\n        justifyContent: \"space-between\",\n        display: \"flex\",\n        flexDirection: \"row\",\n        alignItems: \"center\",\n      }}\n    >\n      <ALink\n        href={\n          typeof window !== \"undefined\"\n            ? location.protocol + \"//\" + location.host\n            : \"#\"\n        }\n        style={{ fontSize: 32 }}\n      >\n        {props.publicBundleConfig?.emoji}\n      </ALink>\n\n      <Div>\n        <P className=\"font-bold text-white \">{title}</P>\n        <P className=\"text-xs text-white italic\">\n          {props.publicBundleConfig?.description}\n        </P>\n      </Div>\n\n      <Div className=\"flex flex-row\">\n        <Div className=\"lg:hidden\">\n          <ClickableIcon\n            emoji=\"ðŸ”\"\n            onClick={() => setIsMobileMenuEnabled(!isMobileMenuEnabled)}\n          />\n        </Div>\n        {props.publicBundleConfig?.isGitRepoPublic &&\n        props.publicBundleConfig.gitRepoUrl ? (\n          <ALink target=\"_blank\" href={props.publicBundleConfig.gitRepoUrl}>\n            GitHub\n          </ALink>\n        ) : null}\n      </Div>\n    </Div>\n  );\n}"
  },
  "LayoutGrid": {
    "name": "LayoutGrid",
    "slug": "TsFunction",
    "id": "xepbcyxkonpmnbhqmoexgagw",
    "description": "Style for creating a grid for the layout that is mobile friendly and has menu support\n\n\n\nI run into this problem all the time\n\nhttps://stackoverflow.com/questions/71616561/css-tailwind-grid-height-100vh-not-working\n\nfinal solution came from here\n\nhttps://stackoverflow.com/questions/47094742/fullscreen-flex-layouts-necessity-of-intermediate-flex-boxes\n\nUnfortunately, I can't seem to hide stuff anymore for some reason on non-mobile. \"lg:flex hidden\" just doesn't work, just hides!\n\nMy elegant solution was to just use visible/invisible and make the mobile layout hover over the invisible one in case of a small screen, it works!",
    "operationName": "layout",
    "rawText": " (props: {\n  children: React.ReactNode;\n  header: React.ReactNode;\n  /**\n   * Menu is only rendered if you pass it here\n   */\n  menu?: MenuProps;\n}) => {\n  const { children, header, menu } = props;\n\n  const [isMobileMenuEnabled] = useStore(\"menu.isMobileMenuEnabled\");\n\n  const renderMenu = () => {\n    return menu ? <Menu {...menu} message={undefined} /> : null;\n  };\n\n  return (\n    <main className=\"dark:bg-zinc-900 dark:text-white relative\">\n      {/* mobile layout */}\n      <Div className=\"lg:invisible absolute overflow-y-scroll top-0 left-0 w-screen h-screen\">\n        {header}\n        {isMobileMenuEnabled ? <Div>{renderMenu()}</Div> : children}\n      </Div>\n\n      {/* Big screen layout */}\n      <Div\n        className={`w-screen h-screen flex flex-1 invisible lg:visible flex-col`}\n      >\n        {header}\n\n        <Div\n          className={`h-full overflow-hidden flex-1 flex ${\n            menu?.menuPosition === \"left\" ? \"flex-row-reverse\" : \"flex-row\"\n          }`}\n        >\n          <Div className=\"min-h-0 overflow-y-scroll w-full h-full inline-block\">\n            {children}\n          </Div>\n          {menu ? (\n            <Div className=\"inline-block min-h-0 overflow-y-scroll h-full w-80\">\n              {renderMenu()}\n            </Div>\n          ) : null}\n        </Div>\n      </Div>\n    </main>\n  );\n}"
  },
  "PingApi": {
    "name": "PingApi",
    "slug": "TsFunction",
    "id": "sxthtqczhphlxydnfttzqpga",
    "description": "",
    "operationName": "layout",
    "rawText": " () => {\n  const [isOffline, setIsOffline] = useState(false);\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      getItem(API_NO_RESPONSE_TIME_KEY).then((value) => {\n        if (!value) {\n          if (isOffline) {\n            setIsOffline(false);\n            return;\n          }\n        }\n\n        const lastNoResponse = Number(value);\n        const timeAgo = Date.now() - lastNoResponse;\n        if (timeAgo < timeBeforeNotOffline && isOffline) {\n          setIsOffline(false);\n        } else {\n          setIsOffline(true);\n        }\n      });\n    }, 1000);\n\n    return () => clearInterval(intervalId);\n  }, []);\n\n  return (\n    <Div className=\"mx-4\">\n      <ALink href=\"/settings\">{isOffline ? \"ðŸ”º\" : \"ðŸ’š\"} API</ALink>\n    </Div>\n  );\n}"
  },
  "timeBeforeNotOffline": {
    "name": "timeBeforeNotOffline",
    "slug": "TsVariable",
    "id": "gtzfzdhfwfykyjudercydign",
    "description": "",
    "operationName": "layout"
  },
  "getLegacyMenu": {
    "name": "getLegacyMenu",
    "slug": "TsFunction",
    "id": "uujnybvlywiocvaijpqpfsdq",
    "description": "",
    "operationName": "menu",
    "rawText": " (queryPaths: string[]) => {\n  const projectNestedPathObject = queryPaths\n    ? queryPathsArrayToNestedPathObject(queryPaths)\n    : undefined;\n\n  /**\n   * This one too\n   */\n  const nestedMenu = projectNestedPathObject\n    ? nestedPathObjectToNestedMenuRecursive(projectNestedPathObject, [], {\n        getHref: (fullPath) => {\n          return fullPath;\n        },\n      })\n    : undefined;\n\n  const result = nestedMenu?.map((item) => {\n    const webPage: WebPage<null> = {\n      queryPath: item.title,\n      menuTitleTooltip: \"Should be replaced with WebPage model\",\n      pageData: null,\n    };\n\n    return webPage;\n  });\n\n  return result;\n}"
  },
  "AugmentedWordComponent": {
    "name": "AugmentedWordComponent",
    "slug": "TsFunction",
    "id": "qvpcizawlvlcxuucjnqdjxcf",
    "description": "",
    "operationName": "reader-ui",
    "rawText": " (props: {\n  augmentedWord: AugmentedWord;\n  augmentedWordObject: MappedObject<AugmentedWord>;\n}) => {\n  const { augmentedWord, augmentedWordObject } = props;\n\n  const projectRelativeBaseFolderPath = getFolderJs(\n    augmentedWord.projectRelativeMarkdownSourcePath\n  )!;\n\n  const projectRelativeMarkdownFilePath =\n    augmentedWord.projectRelativeMarkdownSourcePath;\n  return (\n    <Div className=\"border border-gray-500 rounded-md m-2 p-2\">\n      <P className=\"font-bold\">{augmentedWord.word}</P>\n      {augmentedWord.spoiler ? (\n        <P>\n          {renderMarkdownContent(augmentedWord.spoiler, {\n            isDev,\n            isStatic: false,\n            projectRelativeMarkdownFilePath,\n            projectRelativeBaseFolderPath,\n            augmentedWordObject,\n          })}\n        </P>\n      ) : null}\n    </Div>\n  );\n}"
  },
  "Dictionary": {
    "name": "Dictionary",
    "slug": "TsFunction",
    "id": "ggkwbrjdbnnegyludvfvcmhi",
    "description": "",
    "operationName": "reader-ui",
    "rawText": " (props: {\n  augmentedWordObject: MappedObject<AugmentedWord>;\n  word?: string;\n}) => {\n  const [_, setIsMobileMenuEnabled] = useStore(\"menu.isMobileMenuEnabled\");\n\n  const { augmentedWordObject, word } = props;\n\n  const augmentedWord = word ? augmentedWordObject[word] : undefined;\n\n  return (\n    <>\n      <Div className=\"lg:hidden\">\n        <Div className=\"flex flex-row justify-between px-4\">\n          <Div />\n          <ClickableIcon\n            emoji=\"âƒ›\"\n            onClick={() => {\n              setIsMobileMenuEnabled(true);\n            }}\n          />\n        </Div>\n      </Div>\n\n      <Div className=\"p-4\">\n        {augmentedWord ? (\n          <Div className=\"bg-blue-200 p-4 border border-blue-800 rounded-xl mb-20\">\n            <AugmentedWordComponent\n              augmentedWordObject={augmentedWordObject}\n              augmentedWord={augmentedWord}\n            />\n          </Div>\n        ) : null}\n\n        <P className=\"text-3xl\">Dictionary</P>\n        {Object.keys(augmentedWordObject).map((word, index) => {\n          const augmentedWord = augmentedWordObject[word];\n\n          if (!augmentedWord) return null;\n          return (\n            <AugmentedWordComponent\n              key={`aug${index}`}\n              augmentedWordObject={augmentedWordObject}\n              augmentedWord={augmentedWord}\n            />\n          );\n        })}\n      </Div>\n    </>\n  );\n}"
  },
  "DocsReaderLayout": {
    "name": "DocsReaderLayout",
    "slug": "TsFunction",
    "id": "dhngzdooziwvtdmsnjtataon",
    "description": "",
    "operationName": "reader-ui",
    "rawText": " (props: MarkdownReaderPageProps) => {\n  const router = useRouter();\n  const queryPath = getQueryPath(router.query);\n  const word: string | undefined = Array.isArray(router.query?.word)\n    ? router.query?.word?.[0]\n    : router.query.word;\n\n  return (\n    <Layout\n      publicBundleConfig={props.publicBundleConfig}\n      augmentedWordObject={props.content?.augmentedWordObject}\n      menu={props.menu}\n    >\n      {queryPath === \"dictionary\" && props.content?.augmentedWordObject ? (\n        <Dictionary\n          augmentedWordObject={props.content?.augmentedWordObject}\n          word={word}\n        />\n      ) : (\n        <ReaderPageContent {...props.content} />\n      )}\n    </Layout>\n  );\n}"
  },
  "ReaderPageContent": {
    "name": "ReaderPageContent",
    "slug": "TsFunction",
    "id": "lzwunyeigflyxfrudtohviuz",
    "description": "This is rendering a `WebMarkdownFile` and optionally navigation.",
    "operationName": "reader-ui",
    "rawText": " (props: ReaderPageContentProps) => {\n  const router = useRouter();\n  const queryPath = getQueryPath(router.query);\n  const [_, setIsMobileMenuEnabled] = useStore(\"menu.isMobileMenuEnabled\");\n\n  const {\n    augmentedWordObject,\n    children,\n    description,\n    markdownFile,\n    nextQueryPath,\n    previousQueryPath,\n    projectRelativeMarkdownPath,\n    title,\n  } = props;\n\n  const [view, setView] = useState(\"view\" as \"view\" | \"presentation\");\n\n  const renderBottomNavigation = () => {\n    return (\n      <Div className=\"flex flex-row w-full justify-between\">\n        {previousQueryPath ? (\n          <ALink href={`${previousQueryPath}`}>\n            <Div className=\"w-60 h-40 border-2 border-black rounded-3xl m-4 p-4 flex flex-col justify-center items-center\">\n              <P className=\"font-bold text-xl\">\n                {previousQueryPath.split(\"/\").pop()}\n              </P>\n              <P className=\"font-bold text-6xl\">â¬…</P>\n            </Div>\n          </ALink>\n        ) : (\n          <Div />\n        )}\n\n        {nextQueryPath ? (\n          <ALink href={`${nextQueryPath}`}>\n            <Div className=\"w-60 h-40 border-2 border-black rounded-3xl m-4 p-4 flex flex-col justify-center items-center\">\n              <P className=\"font-bold text-xl\">\n                {nextQueryPath.split(\"/\").pop()}\n              </P>\n              <P className=\"font-bold text-6xl\">âž¡</P>\n            </Div>\n          </ALink>\n        ) : (\n          <Div />\n        )}\n      </Div>\n    );\n  };\n\n  const markdownParse: MarkdownParse | null = markdownFile?.markdown\n    ? mdToJsonParse(markdownFile?.markdown)\n    : null;\n\n  const renderMarkdownView = () => {\n    const projectRelativeMarkdownFilePath = projectRelativeMarkdownPath;\n    const projectRelativeBaseFolderPath = projectRelativeMarkdownPath\n      ? getFolderJs(projectRelativeMarkdownPath)\n      : undefined;\n\n    if (\n      !markdownParse ||\n      projectRelativeBaseFolderPath === undefined ||\n      projectRelativeMarkdownFilePath === undefined ||\n      projectRelativeMarkdownFilePath === null\n    ) {\n      return null;\n    }\n\n    const markdownParseRenderConfig = {\n      augmentedWordObject,\n      projectRelativeBaseFolderPath,\n      projectRelativeMarkdownFilePath,\n      isDev,\n      isStatic: true,\n    };\n\n    return (\n      <MarkdownView\n        markdownParse={markdownParse}\n        markdownParseRenderConfig={markdownParseRenderConfig}\n        view={view}\n      />\n    );\n  };\n\n  const renderPage = () => {\n    const hasNoMainTitle =\n      markdownParse?.content?.filter((x) => !!x.title && x.level === 1)\n        .length !== 1;\n\n    // console.log({ hasNoMainTitle, f: props.markdownFile?.name });\n\n    return (\n      <Div>\n        <Div className=\"flex flex-row justify-between\">\n          {queryPath.length > 1 ? (\n            <ClickableIcon\n              emoji=\"â¬…\"\n              onClick={() => {\n                const parts = queryPath.split(\"/\");\n                parts.pop();\n                const oneFolderUp = parts.join(\"/\");\n                router.push(oneFolderUp.length === 0 ? \"/\" : oneFolderUp);\n              }}\n            />\n          ) : null}\n\n          <Div className=\"flex flex-row\">\n            <Div className=\"lg:hidden\">\n              <ClickableIcon\n                emoji=\"âƒ›\"\n                onClick={() => {\n                  setIsMobileMenuEnabled(true);\n                }}\n              />\n            </Div>\n            <ClickableIcon\n              emoji=\"ðŸ‘\"\n              onClick={() => {\n                setView(view === \"presentation\" ? \"view\" : \"presentation\");\n              }}\n            />\n          </Div>\n        </Div>\n\n        {hasNoMainTitle && markdownFile?.name ? (\n          <P className=\"text-3xl\">{humanCase(markdownFile.name)}</P>\n        ) : null}\n\n        {renderMarkdownView()}\n\n        {previousQueryPath || nextQueryPath ? renderBottomNavigation() : null}\n      </Div>\n    );\n  };\n\n  const renderNav = () => {\n    return (\n      <Div>\n        <Div className=\"flex flex-row items-center\">\n          <ClickableIcon\n            emoji=\"â¬…\"\n            onClick={() => {\n              const parts = queryPath.split(\"/\");\n              parts.pop();\n              const oneFolderUp = parts.join(\"/\");\n              router.push(oneFolderUp.length === 0 ? \"/\" : oneFolderUp);\n            }}\n          />\n          <P className=\"text-xl lg:text-4xl w-full\">&nbsp;&nbsp;{title}</P>\n\n          <Div className=\"lg:hidden\">\n            <ClickableIcon\n              emoji=\"âƒ›\"\n              onClick={() => {\n                setIsMobileMenuEnabled(true);\n              }}\n            />\n          </Div>\n        </Div>\n\n        {description && projectRelativeMarkdownPath ? (\n          <Div>\n            {renderMarkdownContent(description, {\n              projectRelativeMarkdownFilePath: projectRelativeMarkdownPath,\n              augmentedWordObject,\n              projectRelativeBaseFolderPath: getFolderJs(\n                projectRelativeMarkdownPath\n              )!,\n            })}\n          </Div>\n        ) : null}\n\n        <Div className=\"flex flex-row flex-wrap\">\n          {children?.map((child, index) => {\n            return (\n              <ALink\n                key={`child${child.projectRelativeMarkdownPath}-${index}`}\n                href={`${queryPath}/${child.folderName}`}\n              >\n                <Div className=\"w-60 border-2 border-black rounded-3xl m-4 p-4 flex flex-col justify-center items-center\">\n                  <P className=\"font-bold text-xl\">{child.title}</P>\n                  {child.firstParagraph && child.projectRelativeMarkdownPath ? (\n                    <Div>\n                      {renderMarkdownContent(child.firstParagraph, {\n                        projectRelativeBaseFolderPath: getFolderJs(\n                          child.projectRelativeMarkdownPath\n                        )!,\n                        projectRelativeMarkdownFilePath:\n                          child.projectRelativeMarkdownPath,\n                        augmentedWordObject,\n                      })}\n                    </Div>\n                  ) : null}\n                </Div>\n              </ALink>\n            );\n          })}\n        </Div>\n      </Div>\n    );\n  };\n\n  // console.log({ markdownFile });\n  return (\n    <Div>\n      {markdownFile?.headerImage ||\n      markdownFile?.headerTitle ||\n      markdownFile?.header_markdownCallToActionSlugs ? (\n        <ReaderPageHeader\n          markdownFile={markdownFile}\n          projectRelativeMarkdownPath={projectRelativeMarkdownPath}\n        />\n      ) : null}\n      <Div className=\"pb-4 px-4\">\n        {props.children ? renderNav() : renderPage()}\n      </Div>\n    </Div>\n  );\n}"
  },
  "ReaderPageHeader": {
    "name": "ReaderPageHeader",
    "slug": "TsFunction",
    "id": "ddetfthgwtbkduoatfgwkybo",
    "description": "",
    "operationName": "reader-ui",
    "rawText": " (props: {\n  markdownFile?: WebMarkdownFile | null;\n  projectRelativeMarkdownPath?: string | null;\n}) => {\n  const { markdownFile, projectRelativeMarkdownPath } = props;\n\n  if (!markdownFile) return null;\n\n  const { src } = destructureOptionalObject(\n    useAsset(markdownFile.headerImage, projectRelativeMarkdownPath, !isDev)\n  );\n\n  const backgroundImage = src ? `url(\"${src}\")` : undefined;\n\n  return (\n    <Div\n      style={{\n        backgroundImage,\n        backgroundRepeat: \"no-repeat\",\n        backgroundSize: \"cover\",\n        backgroundPosition: \"center 75%\",\n      }}\n      className={`w-full ${\n        markdownFile.headerBig ? \"h-screen\" : \"h-[350px]\"\n      } flex flex-col items-center justify-center`}\n    >\n      {markdownFile.headerTitle ? (\n        <P className=\"drop-shadow-lg decoration-8 font-bold text-white text-4xl\">\n          {markdownFile.headerTitle}\n        </P>\n      ) : null}\n      {markdownFile.headerSubTitle ? (\n        <P className=\"drop-shadow-lg text-white text-2xl\">\n          {markdownFile.headerSubTitle}\n        </P>\n      ) : null}\n\n      {markdownFile.header_markdownCallToActions?.map((cta) => {\n        const { title, description, ctaButtonText, hostname, path } = cta;\n        console.log({ cta, ctaButtonText, hostname });\n        return (\n          <ALink\n            href={path}\n            title={description}\n            className=\"bg-blue-500 rounded-full p-4 flex items-center justify-center\"\n          >\n            {title}\n          </ALink>\n        );\n      })}\n    </Div>\n  );\n}"
  },
  "Share": {
    "name": "Share",
    "slug": "TsFunction",
    "id": "lczsdekvcjmghfvnjqneuiwt",
    "description": "and\n\n",
    "operationName": "share",
    "rawText": " (props: {\n  /**\n   * Can be a more specific text instead of the text of the whole page. Can be omitted. Will just take full page text\n   */\n  contextText?: string;\n}) => {\n  const { contextText } = props;\n  const { handleModal } = useModal();\n\n  const contextualPromptQuery =\n    queries.useGetReferencableModelData(\"ContextualPrompt\");\n  const alert = useAlert();\n  const allText = useAllText();\n  const lastSelection = useLastSelection();\n\n  const modalContent = (\n    <Div className=\"h-[60vh] overflow-y-auto\">\n      {/* \n        - show text + selection, both editable\n        - show prompt input to ask chat-gpt\n        - open prompt textbox based on text and selection\n        */}\n      <FunctionForm\n        tsFunction={Index}\n        initialValues={[\n          contextText || allText || \"\",\n          lastSelection || \"\",\n          undefined,\n          \"\",\n          \"\",\n          \"\",\n        ]}\n        referencableModelData={{\n          ContextualPrompt: {\n            isLoading: contextualPromptQuery.isLoading,\n            data: contextualPromptQuery.data?.result,\n          },\n        }}\n        projectRelativeStorageFilePath=\"README.md\"\n        modelName=\"\"\n        withApiResult={(result: RealApiReturnType<\"processChatGptPrompt\">) => {\n          console.log({ result });\n\n          if (!result.result?.isSuccessful) {\n            errorToast(\n              result?.result?.message ||\n                result.message ||\n                \"Something went wrong\"\n            );\n            return;\n          }\n\n          handleModal(null);\n          const text = result?.result?.result?.text;\n          alert?.(\"You did it\", text, [\n            { text: \"Share\", style: \"default\" },\n            { text: \"Do nothing\", style: \"destructive\" },\n          ]);\n        }}\n      />\n    </Div>\n  );\n\n  return (\n    <ClickableIcon\n      emoji=\"ðŸ’¡\"\n      onClick={() => {\n        // opens modal\n        handleModal(modalContent);\n      }}\n    />\n  );\n}"
  },
  "Shareable": {
    "name": "Shareable",
    "slug": "TsFunction",
    "id": "ruvjxurkuodlsyhihvextkvv",
    "description": "",
    "operationName": "share",
    "rawText": " (props: { children: React.ReactNode }) => {\n  const { ref, getImage, projectRelativeFilePath } =\n    useProjectRelativeScreenshot();\n\n  React.useEffect(() => {\n    if (!projectRelativeFilePath) return;\n    console.log(\"we have projectRelative change:\", projectRelativeFilePath);\n\n    // api.postTweetOnTwitter({\n    //   email: \"test\",\n    //   password: \"test\",\n    //   phoneNo: \"test\",\n    //   tweetMessage: \"yo this is ridic\",\n    // });\n  }, [projectRelativeFilePath]);\n\n  return (\n    <div>\n      <ClickableIcon emoji=\"ðŸ—£\" onClick={getImage} />\n      <div ref={ref}>{props.children}</div>\n    </div>\n  );\n}"
  },
  "useAllText": {
    "name": "useAllText",
    "slug": "TsFunction",
    "id": "wlhgpvgowoerbrpljyqttwfp",
    "description": "",
    "operationName": "share",
    "rawText": " () => {\n  // Use a state to store the current value of the body element's text\n  const [text, setText] = React.useState(\n    typeof document === \"undefined\" ? undefined : document.body.innerText\n  );\n\n  // When the text of the body element changes, update the state\n  React.useEffect(() => {\n    if (typeof document === \"undefined\") return;\n\n    const observer = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        if (mutation.type === \"childList\") {\n          setText(document.body.innerText);\n        }\n      });\n    });\n\n    observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n    });\n\n    // Return a cleanup function that stops observing changes\n    return () => observer.disconnect();\n  }, []);\n\n  // Return the current text of the body element\n  return text;\n}"
  },
  "useLastSelection": {
    "name": "useLastSelection",
    "slug": "TsFunction",
    "id": "ysmpqujipjgbeostcsskrbzy",
    "description": "",
    "operationName": "share",
    "rawText": " (isDisabled?: boolean): string | null => {\n  // Initialize a ref to store the last selection\n  const [selection, setSelection] = useState<string | null>(null);\n\n  // Create a callback that updates the ref when the user makes a selection\n  const updateLastSelection = () => {\n    if (typeof window === \"undefined\") return null;\n\n    const newSelection = window.getSelection()?.toString() || null;\n\n    if (!newSelection) return null;\n\n    setSelection(newSelection);\n\n    return null;\n  };\n\n  // Add the event listener when the hook is called\n  useEffect(() => {\n    // Add the event listener to the document, so it will fire whenever the user makes a selection anywhere on the page\n    document.addEventListener(\"selectionchange\", updateLastSelection);\n\n    // Return a cleanup function that removes the event listener\n    return () => {\n      document.removeEventListener(\"selectionchange\", updateLastSelection);\n    };\n  }, []); // We only want to add the event listener once, so we pass an empty array as the second argument to useEffect\n\n  if (isDisabled) return \"\";\n  // Return the last selection\n  return selection;\n}"
  },
  "useProjectRelativeScreenshot": {
    "name": "useProjectRelativeScreenshot",
    "slug": "TsFunction",
    "id": "wzsotsshdidhylvkxyosmeir",
    "description": "Use https://www.npmjs.com/package/use-react-screenshot to get a blob of any component with the click a button\n\nUpload the blob immediately using `processAsset`, which will result in a file in the file system.",
    "operationName": "share",
    "rawText": " () => {\n  const ref = useRef<HTMLDivElement>(null);\n\n  const [image, takeScreenshot] = useScreenshot();\n  const getImage = () => {\n    takeScreenshot(ref.current);\n  };\n  const [projectRelativeFilePath, setProjectRelativeFilePath] = useState<\n    string | null\n  >(null);\n\n  useEffect(() => {\n    if (!image) return;\n    console.log(\"got a blob I think\", image);\n\n    setProjectRelativeFilePath(\"jajajaj\");\n  }, [image]);\n\n  return { getImage, projectRelativeFilePath, ref };\n}"
  },
  "ArrayForm": {
    "name": "ArrayForm",
    "slug": "TsFunction",
    "id": "zpqdzqsawoocweobfprhuovq",
    "description": "Component to render a parameter that holds an array\n\nThis is simply a wrapper around another `SimplifiedSchemaForm` where the `onChange` and `values` are slightly different\n\nThis component renders a `SimplifiedSchemaForm` for every item in the array, and adds buttons to insert/remove new items.",
    "operationName": "simplified-schema-form",
    "rawText": " (props: {\n  itemNameOrId?: string;\n  parameterNameStack?: string[];\n  projectRelativeStorageFilePath?: string;\n  parameter: FunctionParameter;\n  /**\n   * In this case this must be an array or undefined\n   */\n  parameterValue: any[] | undefined;\n  onChangeParameter: (newValue: any) => void;\n  isDebug?: boolean;\n  referencableModelData?: ReferencableModelData;\n  id: string;\n  modelName?: string;\n}) => {\n  const {\n    itemNameOrId,\n    parameterNameStack,\n    projectRelativeStorageFilePath,\n    parameter,\n    isDebug,\n    id,\n    referencableModelData,\n    onChangeParameter,\n    parameterValue,\n    modelName,\n  } = props;\n\n  if (!parameter.simplifiedSchema) {\n    return null;\n  }\n\n  // we can only render the array if it has items...\n  if (\n    !parameter.simplifiedSchema.items ||\n    parameter.simplifiedSchema.items.length === 0\n  ) {\n    console.log(\"Array without schema items\", { parameter });\n    return isDebug ? (\n      <P className=\"text-red-500\">\n        Array without schema items ({parameter.name}){\" \"}\n        {JSON.stringify(parameter.simplifiedSchema)}\n      </P>\n    ) : null;\n  }\n\n  // TODO: make these actions work!\n  const addItemAbove = (index: number) => {\n    // insert into array\n    if (!parameterValue) return;\n    const newArray = insertAt(parameterValue, undefined, index);\n    onChangeParameter(newArray);\n  };\n\n  const addItemBelow = (index: number) => {\n    // insert into array\n    if (!parameterValue) return;\n    const newArray = insertAt(parameterValue, undefined, index + 1);\n    onChangeParameter(newArray);\n  };\n\n  const removeItem = (index: number) => {\n    if (!parameterValue) return;\n    const newArray = removeIndexFromArray(parameterValue, index);\n    onChangeParameter(newArray);\n  };\n\n  const createArray = () => {\n    if (parameterValue && parameterValue.length > 0) return;\n    onChangeParameter([undefined]);\n  };\n  const shouldShowClear = parameter.required\n    ? parameterValue && parameterValue.length > 0\n    : parameterValue !== undefined;\n  const clearArray = () => {\n    // NB: clearing will set it to undefined, unless the array is required, then we should just set it to an empty array.\n    onChangeParameter(parameter.required ? [] : undefined);\n  };\n\n  const requiredText = parameter.required ? \"(Required)\" : \"(Optional)\";\n  const arrayLengthText = parameterValue\n    ? parameterValue.length > 0\n      ? `Array (${parameterValue.length})`\n      : `Empty array`\n    : `undefined`;\n  return (\n    <Div\n      className={\"ml-2 pl-2 my-4 border-l border-gray-900 dark:border-gray-100\"}\n    >\n      <Div className=\"flex flex-row justify-between\">\n        <P>\n          <Span className=\"font-bold\">{humanCase(parameter.name || \"\")} </Span>\n          {requiredText} {arrayLengthText}\n        </P>\n        <Div className=\"flex flex-row\">\n          {shouldShowClear ? (\n            <ClickableIcon onClick={clearArray} emoji=\"âŒ\" />\n          ) : null}\n          {parameterValue === undefined || parameterValue.length === 0 ? (\n            <ClickableIcon onClick={createArray} emoji=\"âž•\" />\n          ) : null}\n        </Div>\n      </Div>\n\n      {isDebug ? (\n        <P className=\"italic text-gray-600\">\n          {parameter.simplifiedSchema.description}\n        </P>\n      ) : null}\n\n      {/* NB: we need a form for every item in the array */}\n      {parameterValue?.map((arrayItem, arrayIndex) => {\n        const simplifiedSchema: SimplifiedSchema | undefined =\n          parameter.simplifiedSchema?.items?.[0]?.schema;\n\n        const hasName = parameter.name ? parameter.name.length > 0 : false;\n        return (\n          <Div>\n            <SimplifiedSchemaForm\n              modelName={modelName}\n              itemNameOrId={itemNameOrId}\n              projectRelativeStorageFilePath={projectRelativeStorageFilePath}\n              isDebug={isDebug}\n              parameterNameStack={\n                hasName\n                  ? parameterNameStack\n                    ? [...parameterNameStack, parameter.name]\n                    : [parameter.name]\n                  : parameterNameStack\n              }\n              parameters={[\n                {\n                  name: `${parameter.name} item ${arrayIndex + 1}`,\n                  required: true,\n                  simplifiedSchema,\n                  isDbModel: false,\n                  renderButtons: () => {\n                    return (\n                      <Div className=\"flex flex-row\">\n                        {arrayIndex === 0 ? (\n                          <ClickableIcon\n                            onClick={() => addItemAbove(arrayIndex)}\n                            emoji=\"â†‘\"\n                          />\n                        ) : null}\n                        <ClickableIcon\n                          onClick={() => addItemBelow(arrayIndex)}\n                          emoji=\"â†“\"\n                        />\n                        <ClickableIcon\n                          onClick={() => removeItem(arrayIndex)}\n                          emoji=\"ËŸ\"\n                        />\n                      </Div>\n                    );\n                  },\n                },\n              ]}\n              onChange={(newArrayValues) => {\n                const newArrayValue = newArrayValues[0];\n\n                // set this index of the array to the new value taken from the form\n                parameterValue[arrayIndex] = newArrayValue;\n                // only change the value that contains the array\n                onChangeParameter(parameterValue);\n              }}\n              values={[arrayItem]}\n              // just passing this\n              referencableModelData={referencableModelData}\n              id={`${id}.${arrayIndex}`}\n            />\n          </Div>\n        );\n      })}\n    </Div>\n  );\n}"
  },
  "FormContainer": {
    "name": "FormContainer",
    "slug": "TsFunction",
    "id": "yxqelysyktafzeqnuhxvihyl",
    "description": "A `FormContainer` is a simple container that can wrap your `SimplifiedSchemaForm` to give it a button that also sends when hitting enter on your keyboard. To achieve this, a `<form>` is created in this component.\n\nBesides this, you can also add some texts, but styling is not possible to change for this component at this point (except for the form className). If you want a completely different style, it's probably better to build it yourself.\n\nNB: TODO: There is a bug now where onSubmit gets called too often. Not sure how to fix this. Because of this, I'll simply remove the onSubmit action in the onsubmit for now, and prevent the default.",
    "operationName": "simplified-schema-form",
    "rawText": " (props: {\n  className?: string;\n  onSubmit: () => void;\n  title?: string;\n  isLoading?: boolean;\n  submitButtonText?: string;\n  children?: any;\n}) => {\n  const { className, onSubmit, isLoading, title, children, submitButtonText } =\n    props;\n\n  return (\n    <form\n      autoComplete=\"off\"\n      className={className}\n      onSubmit={(e) => {\n        e.preventDefault();\n        // onSubmit();\n      }}\n      // may be needed for file upload\n      // encType=\"multipart/form-data\"\n    >\n      {title ? <P className=\"text-3xl\">{title}</P> : null}\n\n      {children}\n\n      <button type=\"submit\">\n        <BigButton\n          isLoading={isLoading}\n          onClick={onSubmit}\n          title={submitButtonText || \"Submit\"}\n        />\n      </button>\n    </form>\n  );\n}"
  },
  "getReferencedModelDataItem": {
    "name": "getReferencedModelDataItem",
    "slug": "TsFunction",
    "id": "sqlffqeopakdlnmwxepmpmxw",
    "description": "",
    "operationName": "simplified-schema-form",
    "rawText": " (\n  parameterName: string,\n  referencedModelData?: ReferencableModelData\n): ReferencedModelDataItem | undefined => {\n  const interfaceInfo = getReferenceParameterInfo(parameterName);\n  const referencedData: ReferenceItemsObject | undefined =\n    interfaceInfo &&\n    interfaceInfo.interfaceName &&\n    referencedModelData &&\n    referencedModelData[interfaceInfo.interfaceName]\n      ? referencedModelData[interfaceInfo.interfaceName]\n      : undefined;\n\n  return interfaceInfo\n    ? {\n        ...referencedData,\n        ...interfaceInfo,\n      }\n    : undefined;\n}"
  },
  "ObjectForm": {
    "name": "ObjectForm",
    "slug": "TsFunction",
    "id": "ftaunjtfafphrzoischmtlto",
    "description": "Component to render a parameter that holds an object\n\nThis is simply a wrapper around another SimplifiedSchemaForm where the onChange and values are slightly different",
    "operationName": "simplified-schema-form",
    "rawText": " (props: {\n  itemNameOrId?: string;\n  parameterNameStack?: string[];\n  projectRelativeStorageFilePath?: string;\n  parameter: RenderableFunctionParameter;\n  /**\n   * In this case this must be an object or undefined\n   */\n  parameterValue: { [key: string]: any } | undefined;\n  onChangeParameter: (newValue: any) => void;\n\n  isDebug?: boolean;\n  referencableModelData?: ReferencableModelData;\n  referencedModelDataIsLoading?: boolean;\n\n  /**\n   * Unique id for this ObjectForm\n   */\n  id: string;\n  modelName?: string;\n}) => {\n  const {\n    modelName,\n    itemNameOrId,\n    parameterNameStack,\n    projectRelativeStorageFilePath,\n    parameter,\n    onChangeParameter,\n    parameterValue,\n    isDebug,\n    id,\n    referencableModelData,\n    referencedModelDataIsLoading,\n  } = props;\n\n  /**\n   * By default, the thing is expanded if the parameter is required, or if there is already a parameter value. If it is \"true\" by default, you can also not minimise\n   */\n  const defaultExpandedState = parameter.required ? true : !!parameterValue;\n\n  const [isExpanded, setIsExpanded] = useState(defaultExpandedState);\n\n  if (!parameter.simplifiedSchema) {\n    return null;\n  }\n\n  // we can only render the object if it has properties...\n  if (\n    !parameter.simplifiedSchema.properties ||\n    parameter.simplifiedSchema.properties.length === 0\n  ) {\n    // console.log(\"Object without properties\", { parameter });\n    return isDebug ? (\n      <P className=\"text-red-500\">\n        Object without properties {parameter.name}{\" \"}\n        {JSON.stringify(parameter.simplifiedSchema)}\n      </P>\n    ) : null;\n  }\n\n  // for each parameter, recurse this form builder\n\n  const onChangeSubset = (objectParameterValues: any[]) => {\n    // NB: every item in the array is linked with a parameter in the object\n    const objectParts = parameter.simplifiedSchema?.properties?.map((x, i) => ({\n      [x.name]: objectParameterValues[i],\n    }));\n    const objectOrNot = objectParts\n      ? mergeObjectsArray(objectParts)\n      : undefined;\n\n    onChangeParameter(objectOrNot);\n  };\n\n  const valuesSubset: any[] = parameter.simplifiedSchema.properties.map(\n    (x) => parameterValue?.[x.name]\n  );\n\n  const parameters: RenderableFunctionParameter[] =\n    parameter.simplifiedSchema.properties.map((x) => ({\n      name: x.name,\n      required: x.required,\n      simplifiedSchema: x.schema,\n      isDbModel: parameter.isDbModel,\n    }));\n\n  // console.log({ parameters, parameter, isExpanded });\n\n  const renderExpandButton = () => {\n    if (defaultExpandedState) return null;\n\n    return (\n      <ClickableIcon\n        onClick={() => setIsExpanded(!isExpanded)}\n        emoji={isExpanded ? \"-\" : \"+\"}\n      />\n    );\n  };\n\n  const hasName = parameter.name ? parameter.name.length > 0 : false;\n\n  return (\n    <Div\n      className={\"ml-2 pl-2 my-4 border-l border-gray-900 dark:border-gray-100\"}\n    >\n      {renderParameterTitle(parameter, isDebug, true, () =>\n        renderExpandButton()\n      )}\n\n      {isExpanded ? (\n        <SimplifiedSchemaForm\n          modelName={modelName}\n          itemNameOrId={itemNameOrId}\n          parameterNameStack={\n            hasName\n              ? parameterNameStack\n                ? [...parameterNameStack, parameter.name]\n                : [parameter.name]\n              : parameterNameStack\n          }\n          projectRelativeStorageFilePath={projectRelativeStorageFilePath}\n          isDebug={isDebug}\n          parameters={parameters}\n          onChange={onChangeSubset}\n          values={valuesSubset}\n          // just passing this\n          referencableModelData={referencableModelData}\n          id={id}\n        />\n      ) : null}\n    </Div>\n  );\n}"
  },
  "ReferenceInput": {
    "name": "ReferenceInput",
    "slug": "TsFunction",
    "id": "lsatuqgpqqmoiiewfoshvzfx",
    "description": "This component renders an input to select an item to reference from another model (or multiple)",
    "operationName": "simplified-schema-form",
    "rawText": " (props: {\n  parameter: FunctionParameter;\n  parameterValue: any;\n  onChangeParameter: (newValue: any) => void;\n  referencedModelDataItem: ReferencedModelDataItem;\n  defaultInputFields: {\n    uniqueFieldId: string;\n    fieldName: string;\n  };\n  isDebug?: boolean;\n}) => {\n  const {\n    isDebug,\n    parameter,\n    parameterValue,\n    onChangeParameter,\n    defaultInputFields,\n    referencedModelDataItem,\n  } = props;\n\n  const isLoading = referencedModelDataItem.isLoading;\n\n  const addModelItem = () => {\n    return (\n      <ClickableIcon\n        emoji=\"âž•\"\n        onClick={() => {\n          if (typeof window === undefined) return;\n\n          window.open(\n            `upsert/${referencedModelDataItem.interfaceName}`,\n            \"_blank\"\n          );\n        }}\n      />\n    );\n  };\n\n  // selectbox, if referencedModelData is available\n  if (referencedModelDataItem.isReferenceMultipleParameter) {\n    // select multiple\n    const value = (parameterValue || []) as string[];\n\n    const onChangeMultiple = (selected: Item<string>[]) => {\n      const newValue =\n        selected.length === 0 && !parameter.required\n          ? undefined\n          : selected.map((x) => x.value);\n      onChangeParameter(newValue);\n    };\n\n    const options: Item<string>[] =\n      referencedModelDataItem.data\n        ?.map((x) => {\n          const label = x.name || x.id;\n          const value = referencedModelDataItem.keyInModel\n            ? (x[\n                referencedModelDataItem.keyInModel as keyof ReferenceItem\n              ] as string)\n            : undefined;\n          if (!value) return;\n\n          return {\n            value,\n            label,\n          };\n        })\n        .filter(notEmpty) || [];\n\n    const selectedValues = value\n      .map((v) => options.find((x) => x.value === v))\n      .filter(notEmpty);\n\n    return (\n      <Div>\n        {renderParameterTitle(parameter, isDebug, false, addModelItem)}\n        {isLoading ? (\n          <FancyLoader />\n        ) : (\n          <SelectMultipleInput\n            {...defaultInputFields}\n            onChange={onChangeMultiple}\n            value={selectedValues}\n            extra={{\n              options,\n              autoSuggest: options.length > 10,\n            }}\n            config={{}}\n          />\n        )}\n      </Div>\n    );\n  } else {\n    // select single\n\n    // If a referenced model contains the `categoryStack` parameter, this data should be used to group the selectbox. Without categoryStack parameter, simply use the name.\n\n    const value = parameterValue as string | undefined;\n\n    const onChangeSingle = (selected: Item<string> | null) => {\n      const newValue =\n        !selected && !parameter.required ? undefined : selected?.value;\n      onChangeParameter(newValue);\n    };\n\n    const options: Item<string>[] =\n      referencedModelDataItem.data\n        ?.map((x) => {\n          const categoryStack = x.categoryStack;\n\n          const value = referencedModelDataItem.keyInModel\n            ? (x[\n                referencedModelDataItem.keyInModel as keyof ReferenceItem\n              ] as string)\n            : undefined;\n\n          if (!value) return;\n          /**\n           * This must be something. Name is not always there, but ID should be!\n           */\n          const identifier: string = x.name || x.id;\n          const label = categoryStack\n            ? categoryStack.concat(identifier).join(\" â€º \")\n            : identifier;\n\n          return {\n            value,\n            label,\n          };\n        })\n        .filter(notEmpty) || [];\n\n    const selectValue = value\n      ? {\n          label:\n            referencedModelDataItem.data?.find((x) =>\n              referencedModelDataItem.keyInModel\n                ? x[\n                    referencedModelDataItem.keyInModel as keyof ReferenceItem\n                  ] === value\n                : false\n            )?.name || \"Select an option\",\n          value,\n        }\n      : null;\n\n    const optionsAndFirst: Item<string>[] = [\n      { label: \"Select an option\", value: \"\" },\n    ].concat(options);\n\n    return (\n      <Div>\n        {renderParameterTitle(parameter, isDebug, false, addModelItem)}\n        {isLoading ? (\n          <FancyLoader />\n        ) : (\n          <SelectInput\n            {...defaultInputFields}\n            onChange={onChangeSingle}\n            value={selectValue}\n            extra={{\n              options: optionsAndFirst,\n              autoSuggest: optionsAndFirst.length > 10,\n            }}\n            config={{}}\n          />\n        )}\n      </Div>\n    );\n  }\n}"
  },
  "renderParameterTitle": {
    "name": "renderParameterTitle",
    "slug": "TsFunction",
    "id": "tauhateaeuzzvoklftfeuvwo",
    "description": "",
    "operationName": "simplified-schema-form",
    "rawText": " (\n  parameter: RenderableFunctionParameter,\n  isDebug: boolean | undefined,\n  isBolded?: boolean,\n  renderAdditionalButtons?: () => JSX.Element | null\n) => {\n  const info = getReferenceParameterInfo(parameter.name);\n\n  const title =\n    parameter.simplifiedSchema?.title ||\n    (info.isReferenceParameter\n      ? humanCase(`${info.descriptor || \"\"} ${info.interfaceName}`)\n      : humanCase(parameter.name));\n\n  const descriptionIndicator = parameter.simplifiedSchema?.description\n    ? \" â„¹ï¸\"\n    : \"\";\n  return (\n    <Div>\n      {/* Start of a section */}\n      {parameter.simplifiedSchema?.section ? (\n        <P className=\"font-bold underline\">\n          {parameter.simplifiedSchema?.section}\n        </P>\n      ) : null}\n\n      <Div className=\"w-full flex flex-row justify-between\">\n        <P\n          data-tip={parameter.simplifiedSchema?.description}\n          className={`${\n            parameter.simplifiedSchema?.description\n              ? \"cursor-context-menu\"\n              : \"cursor-default\"\n          }${isBolded ? \" font-bold\" : \"\"}`}\n        >\n          {title}\n          {descriptionIndicator}\n          {/* {parameter.required ? \"(Required)\" : \"(Optional)\"}{\" \"} */}\n        </P>\n\n        {parameter.renderButtons?.(parameter)}\n        {renderAdditionalButtons?.()}\n      </Div>\n      {isDebug ? (\n        <P className=\"italic text-gray-400\">\n          [{parameter.simplifiedSchema?.type}]:{\" \"}\n          <Span className=\"text-gray-600\">\n            {parameter.simplifiedSchema?.fullComment}\n          </Span>\n        </P>\n      ) : null}\n    </Div>\n  );\n}"
  },
  "SimplifiedSchemaForm": {
    "name": "SimplifiedSchemaForm",
    "slug": "TsFunction",
    "id": "qnbdkxrifvdiuwctjmdvwlao",
    "description": "Recursive component that renders a form for a SimplifiedSchema",
    "operationName": "simplified-schema-form",
    "rawText": " <TValues extends any[]>(props: {\n  /** unique id for this form */\n  id: string;\n\n  /**\n   * Stack of parameterNames of parents if the form was loaded as a child (subset) of another form, the first item being the grandest parent.\n   */\n  parameterNameStack?: string[];\n  /**\n   * sometimes you have multiple schemas that you want to put in a form, for example if you have a function that takes multiple parameters\n   */\n  parameters: RenderableFunctionParameter[];\n  /**\n   * the value is a json with the structure of the simplified schema. with this you can also prefill the form\n   *\n   * every item in the value array represents the value of the respective parameter\n   */\n  values: undefined | TValues;\n  onChange: (values: TValues) => void;\n  /**\n   * model data (can be filtered) that can be referenced in the schema. This is used to fill the form select inputs so a value can be selected.\n   *\n   * Only fields needed: name, id, slug\n   */\n  referencableModelData?: ReferencableModelData;\n  /** show more info for devs */\n  isDebug?: boolean;\n  /**\n   * used for showing assets in the textarea view\n   */\n  projectRelativeStorageFilePath?: string;\n  /**\n   * If you're editing or creating an item, this should be its name. Can be used for naming assets\n   *\n   * Preferably, this must be realtime, based on the state of this very form, so the default-name of assets can change with the form state...\n   */\n  itemNameOrId?: string;\n  /**\n   * Must be provided in case an asset is stored in a db model\n   */\n  modelName?: string;\n}) => {\n  const {\n    modelName,\n    itemNameOrId,\n    id,\n    onChange,\n    parameters,\n    values,\n    referencableModelData,\n    projectRelativeStorageFilePath,\n    parameterNameStack,\n    isDebug,\n  } = props;\n\n  useEffect(() => {\n    if (!Array.isArray(values)) {\n      const allUndefined = parameters.map(() => undefined) as TValues;\n      onChange(allUndefined);\n    }\n  }, []);\n\n  if (!values) return null;\n\n  /** helper function to change a single parameter */\n  const onChangeParameter = (index: number, value: any) => {\n    // only change the parameter we need to change\n    const newValues = values.map((v, i) =>\n      i === index ? value : v\n    ) as TValues;\n    onChange(newValues);\n  };\n\n  const parameterNames = parameters.map((x) => x.name);\n\n  // For every parameter we are going to return elements\n  const elements = parameters\n    .map((parameter, index) => {\n      if (!parameter.simplifiedSchema) return;\n      const uniqueFieldId = `${id}.${parameter.name}`;\n\n      /**\n       * values[index]\n       */\n      const parameterValue = values[index];\n      const defaultInputFields = {\n        uniqueFieldId,\n        fieldName: uniqueFieldId,\n      };\n\n      const assetInputType = getAssetInputType(\n        parameter.name,\n        parameter.simplifiedSchema?.type\n      );\n\n      // console.log({\n      //   parameter,\n      //   assetInputType,\n      //   projectRelativeStorageFilePath,\n      // });\n      if (assetInputType && projectRelativeStorageFilePath) {\n        // Something like: [function-name]-[nested]-[property]-[item-name/id]\n        const defaultAssetName = [\n          ...(parameterNameStack || []),\n          singularize(parameter.name),\n          itemNameOrId,\n        ]\n          .filter(notEmpty)\n          .join(\"-\");\n\n        const assetInputExtra: AssetInputType[\"extra\"] = {\n          modelName,\n          defaultAssetName,\n          size: \"lg\" as \"lg\",\n          theme: \"Outlined\" as \"Outlined\",\n          projectRelativeReferencingFilePath: projectRelativeStorageFilePath,\n          attachTokenToFilename: true,\n          allowMultiple: assetInputType.isMultiple,\n          inputTypes:\n            // NB: many things are omitted here since they're still a work in progress\n            assetInputType.type === \"asset\"\n              ? undefined\n              : assetInputType.type === \"audio\"\n              ? [\"recordAudio\", \"files\"]\n              : assetInputType.type === \"file\"\n              ? [\"files\"]\n              : assetInputType.type === \"image\"\n              ? [\"camera\", \"files\"]\n              : assetInputType.type === \"video\"\n              ? [\"files\", \"recordScreen\", \"recordVideo\"]\n              : undefined,\n        };\n\n        return (\n          <Div key={uniqueFieldId}>\n            {renderParameterTitle(parameter, isDebug)}\n\n            <AssetInput\n              value={parameterValue ? makeArray(parameterValue) : []}\n              onChange={(newValue) => {\n                onChangeParameter(index, newValue);\n              }}\n              className=\"w-96\"\n              extra={assetInputExtra}\n              // parameter={parameter}\n              config={{}}\n              fieldName={parameter.name}\n              uniqueFieldId={parameter.name}\n            />\n          </Div>\n        );\n      }\n\n      // First, let's see if the parametername is a reference parameter.\n      const referencedModelDataItem = getReferencedModelDataItem(\n        parameter.name,\n        referencableModelData\n      );\n\n      // console.log({ referencedModelDataItem });\n      if (referencedModelDataItem?.isReferenceParameter) {\n        return (\n          <ReferenceInput\n            key={uniqueFieldId}\n            parameter={parameter}\n            parameterValue={parameterValue}\n            onChangeParameter={(value: any) => onChangeParameter(index, value)}\n            referencedModelDataItem={referencedModelDataItem}\n            defaultInputFields={defaultInputFields}\n            isDebug={isDebug}\n          />\n        );\n      }\n\n      if (parameter.isDbModel && isCalculatedParameter(parameter.name)) {\n        //skip!\n        // NB: if you are wondering how to skip model parameters (e.g. todos when there is a todoSlugs, please check `simplifySchema`, as it has this by default.)\n        return;\n      }\n\n      const possibleReferenceParameterNames =\n        getPossibleReferenceParameterNames(parameter.name);\n      const hasReferenceParameter = !!parameterNames.find((name) =>\n        possibleReferenceParameterNames.includes(name)\n      );\n      // NB: if the property has a model reference, we just need the model reference, not the whole model. This is only for retreiving, it's not present in the database. NB: this is also done when simplifying a schema. Adding it here too is kind of unneccessary if you can assume the schemas are correct, so we should probably remove it later!\n      if (hasReferenceParameter) return;\n\n      if (parameter.simplifiedSchema.type === \"array\") {\n        return (\n          <ArrayForm\n            modelName={modelName}\n            key={uniqueFieldId}\n            parameter={parameter}\n            parameterValue={parameterValue}\n            onChangeParameter={(value: any) => onChangeParameter(index, value)}\n            // passing props\n            itemNameOrId={itemNameOrId}\n            parameterNameStack={parameterNameStack}\n            referencableModelData={referencableModelData}\n            isDebug={isDebug}\n            id={uniqueFieldId}\n            projectRelativeStorageFilePath={projectRelativeStorageFilePath}\n          />\n        );\n      }\n\n      if (parameter.simplifiedSchema.type === \"object\") {\n        return (\n          <ObjectForm\n            modelName={modelName}\n            parameter={parameter}\n            parameterValue={parameterValue}\n            onChangeParameter={(value: any) => onChangeParameter(index, value)}\n            // passing props\n            itemNameOrId={itemNameOrId}\n            parameterNameStack={parameterNameStack}\n            referencableModelData={referencableModelData}\n            isDebug={isDebug}\n            id={uniqueFieldId}\n            key={uniqueFieldId}\n            projectRelativeStorageFilePath={projectRelativeStorageFilePath}\n          />\n        );\n      }\n\n      if (parameter.simplifiedSchema?.type === \"number\") {\n        const value = values[index] as number | null | undefined;\n\n        const onChangeNumber = (newNumber: number | null | undefined) => {\n          const realNewNumber =\n            !parameter.required &&\n            (newNumber === null || newNumber === undefined)\n              ? undefined\n              : newNumber || 0;\n\n          const newValues = values.map((x, i) =>\n            // NB: only change the index we are on\n            i === index ? realNewNumber : x\n          ) as TValues;\n\n          onChange(newValues);\n        };\n\n        return (\n          <Div key={uniqueFieldId}>\n            {renderParameterTitle(parameter, isDebug)}\n            <NumberInput\n              {...defaultInputFields}\n              onChange={onChangeNumber}\n              value={value}\n              extra={{}}\n              config={{}}\n            />\n          </Div>\n        );\n      }\n\n      if (parameter.simplifiedSchema?.type === \"boolean\") {\n        const value = values[index] as boolean | undefined;\n\n        const onChangeBoolean = (newBoolean: boolean) => {\n          const newValues = values.map((x, i) =>\n            // NB: only change the index we are on\n            i === index\n              ? // NB: ony return undefined for an empty string that's not required\n                !parameter.required && newBoolean === false\n                ? undefined\n                : newBoolean\n              : x\n          ) as TValues;\n\n          onChange(newValues);\n        };\n\n        return (\n          <Div key={uniqueFieldId}>\n            <ToggleInput\n              {...defaultInputFields}\n              onChange={onChangeBoolean}\n              value={value || false}\n              extra={{ label: renderParameterTitle(parameter, isDebug) }}\n              config={{}}\n            />\n          </Div>\n        );\n      }\n\n      // NB: only string text left... sometimes it can be markdown though (textArea would be great here)... But we can't see this yet due to indexation\n\n      const value = values[index] as string | undefined;\n\n      if (parameter.simplifiedSchema?.enum) {\n        const onChangeEnum = (newItemValue: string | null) => {\n          const newValues = values.map((x, i) =>\n            // NB: only change the index we are on\n            i === index\n              ? //   NB: ony return undefined for an empty string that's not required\n                !newItemValue\n                ? null\n                : newItemValue\n              : x\n          ) as TValues;\n\n          onChange(newValues);\n        };\n        const enumItems = parameter.simplifiedSchema.enum.map((enumString) => {\n          return {\n            value: String(enumString),\n            label: humanCase(String(enumString)),\n          };\n        });\n\n        const firstEnumValue = parameter.simplifiedSchema?.enum[0];\n        const firstEnumValueString = firstEnumValue\n          ? String(firstEnumValue)\n          : null;\n\n        // NB: we are changing the state here to set the enum to the first value, if it's not specified\n\n        if (value === undefined) {\n          onChangeEnum(firstEnumValueString);\n        }\n        const currentEnumItemValue = value || firstEnumValueString;\n\n        const currentEnumItem = enumItems.find(\n          (x) => x.value === currentEnumItemValue\n        )!;\n\n        return (\n          <Div key={uniqueFieldId}>\n            {renderParameterTitle(parameter, isDebug)}\n\n            <SelectInput\n              {...defaultInputFields}\n              onChange={(item) => onChangeEnum(item?.value || null)}\n              value={currentEnumItem}\n              extra={{ options: enumItems, autoSuggest: enumItems.length > 10 }}\n              config={{}}\n            />\n          </Div>\n        );\n      }\n\n      const onChangeText = (newText: string) => {\n        const newValues = values.map((x, i) =>\n          // NB: only change the index we are on\n          i === index\n            ? //   NB: ony return undefined for an empty string that's not required\n              !parameter.required && newText.length === 0\n              ? undefined\n              : newText\n            : x\n        ) as TValues;\n\n        onChange(newValues);\n      };\n\n      const lastWord = lowerCaseArray(parameter.name).pop()!;\n      const isTextArea = markdownTextParameterNames.includes(lastWord);\n\n      if (isTextArea) {\n        return (\n          <Div key={uniqueFieldId}>\n            {renderParameterTitle(parameter, isDebug)}\n\n            <Div className=\"w-full h-[300px]\">\n              <WriterInput\n                className={`${UI.bareInput} h-[300px] bg-white`}\n                value={value || \"\"}\n                onChange={onChangeText}\n                hideButtons\n                initialWriterView=\"edit\"\n                type=\"markdown\"\n                projectRelativeFilePath={projectRelativeStorageFilePath}\n              />\n            </Div>\n          </Div>\n        );\n      }\n\n      const RightTextInput = passwordTextParameterNames.includes(parameter.name)\n        ? PasswordInput\n        : TextInput;\n\n      return (\n        <Div key={uniqueFieldId}>\n          {renderParameterTitle(parameter, isDebug)}\n\n          <RightTextInput\n            {...defaultInputFields}\n            onChange={onChangeText}\n            value={value || \"\"}\n            extra={{}}\n            config={{}}\n          />\n        </Div>\n      );\n    })\n    .filter(notEmpty);\n\n  return <Div>{elements}</Div>;\n}"
  },
  "useReferencableModelData": {
    "name": "useReferencableModelData",
    "slug": "TsFunction",
    "id": "fchqmedkyvgfdbujpmhwvarh",
    "description": "Hook to retreive `ReferencableModelData` to supply to `SimplifiedSchemaForm`.\n\nUnderwater, this calculates all referencableModelNames for a schema, and then it fetches the `ReferencableItem`[] for every one of those models, using `react-query` `useQuery` hooks\n\nNB: be careful, not to change the simplifiedSchema after using this hook for the first time. This will change the amount of hooks and this can break react!\n\n(it will give `Error: Rendered more hooks than during the previous render`)",
    "operationName": "simplified-schema-form",
    "rawText": " (\n  simplifiedSchema: SimplifiedSchema\n): ReferencableModelData | undefined => {\n  const referencableModelNames = getReferencableModels(simplifiedSchema)\n    ?.map((x) => x.interfaceName)\n    .filter(notEmpty);\n\n  if (!referencableModelNames) return;\n\n  /**\n   * NB: here we just get the referencable model data for the referencable model names in this form. But since they are decoupled, useQuery is caching them, across forms!\n   */\n  const referencableModelDataArray = referencableModelNames\n    .map((dbModelName) => {\n      const realDbModelName = dbModelName as keyof DbModels;\n      const { data: apiResult, isLoading } =\n        queries.useGetReferencableModelData(realDbModelName);\n\n      const data = apiResult?.result;\n\n      return { [dbModelName]: { data, isLoading } };\n    })\n    .filter(notEmpty);\n\n  const referencableModelData: ReferencableModelData | undefined =\n    referencableModelDataArray\n      ? mergeObjectsArray(referencableModelDataArray)\n      : undefined;\n\n  return referencableModelData;\n}"
  },
  "useTsInterfaceForm": {
    "name": "useTsInterfaceForm",
    "slug": "TsFunction",
    "id": "odubpnujgwplzycqemkclpoz",
    "description": "hook to create a form for a TsInterface\n\n# Usage\n\n```ts\nimport { useTsInterfaceForm } from \"simplified-schema-form\";\nimport DatasetConfigJson from \"code-types/db/ts-interfaces/datasetconfig.json\";\nimport { DatasetConfig, TsInterface } from \"code-types\";\nimport { Storing } from \"model-types\";\n\nin your component:\nconst initialValue:DatasetConfig = {} as any;\nconst [Form, value, onChange] = useTsInterfaceForm(DatasetConfigJson as Storing<TsInterface>,initialValue);\n```",
    "operationName": "simplified-schema-form",
    "rawText": " <T extends unknown>(\n  /**\n   * NB: Don't change this! The amount of hooks depends on this\n   */\n  tsInterface: Storing<TsInterface>,\n  id?: string,\n  /**\n   * Only works if set on first render\n   */\n  initialValue?: T,\n  /**\n   * Tell the form where the model will be stored so the form can render assets correctly\n   *\n   * If not given, it is tried to be taken from tthe initialValue (will only work if it's a db-model instance with a `.projectRelativePath`)\n   */\n  projectRelativeStorageFilePath?: string,\n  /**\n   * must be provided in case of a db model\n   */\n  modelName?: string,\n  /**\n   * do something with changes\n   */\n  withValue?: (value: T | undefined) => void\n): [\n  form?: JSX.Element,\n  value?: T | undefined,\n  onChange?: (value: T) => void\n] => {\n  const [realId] = useState(id || `s${String(Math.random())}`);\n  const [values, onChange] = useState<[value: T | undefined]>([initialValue]);\n\n  // NB: only the first item matters\n  const value = values[0];\n  const onChangeValue = (value: T) => {\n    onChange([value]);\n  };\n\n  // NB: we must have the simplifiedSchema, it's not always indexed\n  const simplifiedSchema = tsInterface.type.simplifiedSchema;\n  if (!simplifiedSchema) return [];\n\n  const referencableModelData = useReferencableModelData(simplifiedSchema);\n\n  const form = (\n    <SimplifiedSchemaForm\n      modelName={modelName}\n      key={realId}\n      id={realId}\n      onChange={(values) => {\n        onChange(values);\n        withValue?.(values[0]);\n      }}\n      values={values}\n      itemNameOrId={\n        (value as AugmentedAnyModelType)?.name ||\n        (value as AugmentedAnyModelType)?.id\n      }\n      parameters={[\n        {\n          name: \"\",\n          required: true,\n          simplifiedSchema,\n          isDbModel: true,\n        },\n      ]}\n      projectRelativeStorageFilePath={\n        projectRelativeStorageFilePath ||\n        (initialValue as AnyModelType)?.projectRelativePath\n      }\n      referencableModelData={referencableModelData}\n    />\n  );\n\n  return [form, value, onChangeValue];\n}"
  },
  "markdownReaderTsFunctionActions": {
    "name": "markdownReaderTsFunctionActions",
    "slug": "TsVariable",
    "id": "ibzcdenvwlkpemujhtpjyvle",
    "description": "",
    "operationName": "ui-generation"
  },
  "execAsync": {
    "name": "execAsync",
    "slug": "TsFunction",
    "id": "kyqbaqxbguyiinjcnfnahuds",
    "description": "promises to exec something with response and success as result (Promised)",
    "operationName": "child-process-helper",
    "rawText": " (\n  command: string\n): Promise<{ success: boolean; response: string }> => {\n  return new Promise((resolve) => {\n    exec(command, (error, stdout, stderr) => {\n      if (error) {\n        console.log(error);\n        resolve({ success: false, response: stderr });\n      } else {\n        resolve({ success: true, response: stdout });\n      }\n    });\n  });\n}"
  },
  "spawnAsync": {
    "name": "spawnAsync",
    "slug": "TsFunction",
    "id": "clwslmzqdluhmlfacjsgqgec",
    "description": "i don't know if this is ever useful...",
    "operationName": "child-process-helper",
    "rawText": " (\n  command: string,\n  options: SpawnOptionsWithoutStdio\n): Promise<{ success: boolean; response: string; data?: string[] }> => {\n  return new Promise((resolve) => {\n    const spawned = spawn(command, options);\n\n    const data: string[] = [];\n    spawned\n      .on(\"exit\", (code) => {\n        resolve({ response: String(code), success: false, data });\n      })\n      .on(\"message\", (message) => {\n        //not sure if this does anything\n      })\n      .on(\"data\", (message) => {\n        //not sure if this does anything\n        data.push(message);\n      })\n      .on(\"error\", (err) => {\n        resolve({ response: String(err), success: false, data });\n      });\n  });\n}"
  },
  "cloc": {
    "name": "cloc",
    "slug": "Operation",
    "id": "wxfdtiovdlfwbhafgngmdxye",
    "operationName": "cloc"
  },
  "camelCase": {
    "name": "camelCase",
    "slug": "TsFunction",
    "id": "opeoezptjsdmmstdngijqovr",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (text: string) => convertCase(text, \"camel\")"
  },
  "capitalCase": {
    "name": "capitalCase",
    "slug": "TsFunction",
    "id": "jgelexpgtybpipqzijljdoeq",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (text: string) => convertCase(text, \"capital\")"
  },
  "capitaliseFirstLetter": {
    "name": "capitaliseFirstLetter",
    "slug": "TsFunction",
    "id": "liiiavqqqwgtxtvtdokmrszd",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (word: string) => {\n  return word.charAt(0).toUpperCase().concat(word.substring(1));\n}"
  },
  "convertCase": {
    "name": "convertCase",
    "slug": "TsFunction",
    "id": "ozxlniopqxgsxawstkvhfcuv",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (\n  /**\n   * NB: texts of more than a sentence are not supported\n   */\n  text: string,\n  target: Casing\n) =>\n  text\n    .split(nonCasingDelimiters)\n    .reduce(\n      (all, word) => all.concat(splitCasingDelimiters(word)),\n      [] as string[]\n    )\n    .map((word, index) => convertToTargetCasing(word, index, target))\n    .join(getDelimiter(target))"
  },
  "convertToTargetCasing": {
    "name": "convertToTargetCasing",
    "slug": "TsFunction",
    "id": "gfcbcypyrxbjlgkcjzfqaeuo",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (word: string, index: number, target: Casing) => {\n  if (target === \"capital\") return word.toUpperCase();\n  if (target === \"kebab\" || target === \"snake\") return word.toLowerCase();\n  if (target === \"pascal\") return capitaliseFirstLetter(word);\n  if (target === \"camel\")\n    return index === 0 ? word.toLowerCase() : capitaliseFirstLetter(word);\n\n  //human case\n  return index === 0 ? capitaliseFirstLetter(word) : word.toLowerCase();\n}"
  },
  "getDelimiter": {
    "name": "getDelimiter",
    "slug": "TsFunction",
    "id": "kpmhnnowtpztjnhhajfzhtls",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (target: Casing) => {\n  if (target === \"capital\") return \"_\";\n  if (target === \"human\") return \" \";\n  if (target === \"kebab\") return \"-\";\n  if (target === \"snake\") return \"_\";\n  return \"\";\n}"
  },
  "humanCase": {
    "name": "humanCase",
    "slug": "TsFunction",
    "id": "zzpaplobyurzhlicldolyilg",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (text: string) => convertCase(text, \"human\")"
  },
  "kebabCase": {
    "name": "kebabCase",
    "slug": "TsFunction",
    "id": "fevqriowoalogvomgyzsopwv",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (text: string) => convertCase(text, \"kebab\")"
  },
  "lowerCaseArray": {
    "name": "lowerCaseArray",
    "slug": "TsFunction",
    "id": "xckarjtvzjvgihktgxuwepiy",
    "description": "converts any string to an array of lowercase words\n\nformat [\"word1\",\"word2\",\"word3\"] from a string of any casing.",
    "operationName": "convert-case",
    "rawText": " (text: string) => {\n  return kebabCase(text).split(\"-\");\n}"
  },
  "nonCasingDelimiters": {
    "name": "nonCasingDelimiters",
    "slug": "TsVariable",
    "id": "samqztusrnvrunwdcporufdu",
    "description": "",
    "operationName": "convert-case"
  },
  "pascalCase": {
    "name": "pascalCase",
    "slug": "TsFunction",
    "id": "wzurxelyvmxthgrkoozfupqs",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (text: string) => convertCase(text, \"pascal\")"
  },
  "snakeCase": {
    "name": "snakeCase",
    "slug": "TsFunction",
    "id": "qrvrwewtwfpjhcmdlqmwkhht",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (text: string) => convertCase(text, \"snake\")"
  },
  "splitCasingDelimiters": {
    "name": "splitCasingDelimiters",
    "slug": "TsFunction",
    "id": "qhtunfyqpduojafssutlvsmm",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (word: string): string[] => {\n  const letters = word.split(\"\");\n  const allWords = letters.reduce(\n    (words, letter) => {\n      //get the last word, we know it's always defined because of the initial value of the reduce\n      const lastWord: string = words.pop()!;\n      //let's also get the last letter\n      const lastLetter = lastWord.substring(-1);\n      const lastLetterIsLowercase = lastLetter.toUpperCase() !== lastLetter;\n      const letterIsUppercase = letter.toUpperCase() === letter;\n      const createNewWord = lastLetterIsLowercase && letterIsUppercase;\n      const newSequence = createNewWord\n        ? [lastWord, letter]\n        : [`${lastWord}${letter}`];\n      const newWords = words.concat(newSequence);\n      return newWords;\n    },\n    [\"\"]\n  );\n\n  return allWords;\n  // if it was lowercase but it became upper, it's a new word\n}"
  },
  "DEBUG_COMMANDS": {
    "name": "DEBUG_COMMANDS",
    "slug": "TsVariable",
    "id": "zygtzsriwlfrlfzhzqzywzls",
    "description": "",
    "operationName": "execute-command"
  },
  "executeCommand": {
    "name": "executeCommand",
    "slug": "TsFunction",
    "id": "vagqngkdxbvzbucvcvqsonrb",
    "description": "",
    "operationName": "execute-command",
    "rawText": " (\n  command: Command,\n  dir: string,\n  debug?: boolean\n) => {\n  // if command is disabled, immediately resolve so it is skippped.\n  if (command.isDisabled) {\n    return new Promise<void>((resolve) => resolve());\n  }\n  //tell the user what is happening, with a dot every second\n\n  process.stdout.write(command.description);\n  const interval = setInterval(() => process.stdout.write(\".\"), 1000);\n\n  return new Promise<void>((resolve) => {\n    const messages: string[] = [];\n\n    const onFinish = ({ success }: { success: boolean }) => {\n      //once done, clear the console\n      console.clear();\n      clearInterval(interval);\n      if (success) {\n        resolve();\n      }\n    };\n\n    if (DEBUG_COMMANDS) {\n      log(`${Date.toString()}: extecuted ${command} in ${dir}`);\n      resolve();\n    } else if (command.command) {\n      const commandString = getCommand(command);\n\n      if (!commandString) {\n        onFinish({ success: true });\n        return;\n      }\n\n      spawn(commandString, {\n        stdio: debug ? \"inherit\" : \"ignore\",\n        shell: true,\n        cwd: dir,\n      })\n        .on(\"exit\", (code) => {\n          const CODE_SUCCESSFUL = 0;\n\n          if (code === CODE_SUCCESSFUL) {\n            onFinish({ success: true });\n          } else {\n            onFinish({ success: false });\n            log(messages.join(\"\\n\"));\n\n            log(\n              `The following command failed (code ${code}): \"${command.command}\"`\n            );\n            process.exit(1);\n          }\n        })\n        //save all output so it can be printed on an error\n        .on(\"message\", (message) => {\n          messages.push(message.toString());\n        })\n        .on(\"error\", (err) => {\n          onFinish({ success: false });\n          log(messages.join(\"\\n\"));\n          log(`The following command failed: \"${command.command}\": \"${err}\"`);\n          process.exit(1);\n        });\n    } else {\n      onFinish({ success: true });\n    }\n  });\n}"
  },
  "getCommand": {
    "name": "getCommand",
    "slug": "TsFunction",
    "id": "jivrtnfnxqqtehgzmpwnchmz",
    "description": "",
    "operationName": "execute-command",
    "rawText": " (command: Command): string | false => {\n  if (!command.command) {\n    return false;\n  }\n\n  if (isCommandPerOs(command.command)) {\n    const cmd = command.command[os] || command.command.default!;\n    return cmd;\n  }\n  return command.command;\n}"
  },
  "isCommandPerOs": {
    "name": "isCommandPerOs",
    "slug": "TsFunction",
    "id": "cvdqzjqkviizdbjlcrekvpzj",
    "description": "",
    "operationName": "execute-command",
    "rawText": " (\n  command: CommandPerOs | string\n): command is CommandPerOs => {\n  if (typeof command === \"object\") {\n    return true;\n  }\n  return false;\n}"
  },
  "os": {
    "name": "os",
    "slug": "TsVariable",
    "id": "covgxgzxnqbruhkwqcdcclil",
    "description": "",
    "operationName": "execute-command"
  },
  "getDbPath": {
    "name": "getDbPath",
    "slug": "TsFunction",
    "id": "pjndvxfdqwweqyavcghhcvng",
    "description": "",
    "operationName": "geo-parse",
    "rawText": " (dbRelativePath: string) => {\n  const dbPath = path.join(__dirname, \"../..\", \"db\");\n  return path.join(dbPath, dbRelativePath);\n}"
  },
  "makeKvmdLocationsFile": {
    "name": "makeKvmdLocationsFile",
    "slug": "TsFunction",
    "id": "lqihukwigulkbuuekkytqoui",
    "description": "",
    "operationName": "geo-parse",
    "rawText": " async () => {\n  const countries = await db.get(\"Country\");\n  const cities = await db.get(\"City\");\n\n  const kvmdArray: Storing<Location>[] = countries\n    .map((country) => {\n      const locationStorings: Storing<Location>[] =\n        cities\n          .filter((item) => item.countrySlug === country.slug)\n          .filter((item) => item.population > 200000)\n          .map((item) => {\n            const kvmdCity: Storing<Location> = {\n              name: item.name,\n              slug: kebabCase(item.name),\n              id: kebabCase(item.name),\n              categoryStack: [],\n              comment: null,\n              isHeaderCalculated: false,\n              value: null,\n              parent_locationSlug: kebabCase(country.name),\n            };\n\n            return kvmdCity;\n          }) || [];\n\n      const kvmdCountry: Storing<Location> = {\n        name: country.name,\n        slug: kebabCase(country.name),\n        id: kebabCase(country.name),\n        comment: null,\n        value: null,\n        parent_locationSlug: kebabCase(country.subContinent),\n        categoryStack: [],\n        isHeaderCalculated: true,\n      };\n\n      const countryCityArray: Storing<Location>[] = [\n        kvmdCountry,\n        ...locationStorings,\n      ];\n\n      return countryCityArray;\n    })\n    .flat();\n\n  const kvmdParse: KeyValueMarkdownParse = {\n    data: kvmdArray.map((x) => ({\n      ...x,\n      operationName: \"geo-parse\",\n      projectRelativePath: \"\",\n      operationRelativePath: \"db/locations.md\",\n    })),\n    parameters: {},\n  };\n\n  const mdString = kvmdParseToMarkdownString(kvmdParse);\n\n  const result = await writeStringToFile(getDbPath(\"locations.md\"), mdString);\n}"
  },
  "parseCountries": {
    "name": "parseCountries",
    "slug": "TsFunction",
    "id": "fhrfqzqcejydvdxwuaemcnfe",
    "description": "",
    "operationName": "geo-parse",
    "rawText": " () => {\n  const countriesPath = getDbPath(\"countries.json\");\n\n  const countries = countryPolygons.features.map((country) => {\n    const { coordinates } = country.geometry;\n\n    const {\n      iso_a2,\n      label_x,\n      label_y,\n      continent,\n      subregion,\n      sov_a3,\n      pop_est,\n      gdp_md,\n      sovereignt,\n      admin,\n      geounit,\n      subunit,\n    } = country.properties;\n\n    return {\n      polygon: coordinates,\n      code2Letters: iso_a2,\n      code3Letters: sov_a3,\n      population: pop_est,\n      gdp: gdp_md,\n      name: sovereignt,\n      name2: admin,\n      name3: geounit,\n      name4: subunit,\n      latitude: label_x,\n      longitude: label_y,\n      continent,\n      subContinent: subregion,\n    };\n  });\n\n  writeJsonToFile(countriesPath, countries);\n}"
  },
  "parseToMarkdown": {
    "name": "parseToMarkdown",
    "slug": "TsFunction",
    "id": "ldhnmuxosrwzwcrwzpukfztw",
    "description": "",
    "operationName": "geo-parse",
    "rawText": " async () => {\n  const citiesJson = await readJsonFile<\n    { country: string; name: string; lat: string; lng: string }[]\n  >(getDbPath(\"cities.json\"));\n\n  const kvmdArray: Storing<Location>[] = countriesJson\n    .map((country) => {\n      const cities: Storing<Location>[] =\n        citiesJson\n          ?.map((item) => ({\n            countryCode2Letters: item.country,\n            city: item.name,\n            latitude: item.lat,\n            longitude: item.lng,\n          }))\n\n          .filter((item) => item.countryCode2Letters === country.code2Letters)\n          .map((item) => {\n            const kvmdCity: Storing<Location> = {\n              name: item.city,\n              slug: kebabCase(item.city),\n              id: kebabCase(item.city),\n              categoryStack: [],\n              comment: null,\n              isHeaderCalculated: false,\n              value: `${item.latitude};${item.longitude}`,\n              parent_locationSlug: kebabCase(country.name),\n            };\n\n            return kvmdCity;\n          }) || [];\n\n      const kvmdCountry: Storing<Location> = {\n        name: country.name,\n        slug: kebabCase(country.name),\n        id: kebabCase(country.name),\n        comment: null,\n        value: `${country.latitude};${country.longitude}`,\n        parent_locationSlug: kebabCase(country.subContinent),\n        categoryStack: [],\n        isHeaderCalculated: true,\n      };\n\n      const countryCityArray: Storing<Location>[] = [kvmdCountry, ...cities];\n\n      return countryCityArray;\n    })\n    .flat();\n\n  const kvmdParse: KeyValueMarkdownParse = {\n    data: kvmdArray.map((x) => ({\n      ...x,\n      operationName: \"geo-types\",\n      projectRelativePath: \"\",\n      operationRelativePath: \"db/locations.md\",\n    })),\n    parameters: {},\n  };\n\n  const mdString = kvmdParseToMarkdownString(kvmdParse);\n\n  const result = await writeStringToFile(getDbPath(\"locations.md\"), mdString);\n}"
  },
  "parse": {
    "name": "parse",
    "slug": "TsFunction",
    "id": "xulhfvhnldgzvnaowmhdtijt",
    "description": "",
    "operationName": "parse-address-henrik",
    "rawText": " async () => {\n  const dataPath = path.join(__dirname, \"..\", \"data\", \"test.csv\");\n  const result = (await readCsvFile(dataPath)) as OldFormat[];\n\n  const newFormatArray: NewFormat[] = result.map(oldToNew);\n\n  const newFormatCsvString: string = createCsvString(newFormatArray);\n\n  const newFilePath = path.join(__dirname, \"..\", \"data\", \"result.csv\");\n\n  await fs.writeFile(newFilePath, newFormatCsvString, \"utf-8\");\n\n  return;\n}"
  },
  "rawPolygonToPolygon": {
    "name": "rawPolygonToPolygon",
    "slug": "TsFunction",
    "id": "ibzvyruiwekxbljeellwrfvs",
    "description": "",
    "operationName": "geo-parse",
    "rawText": " (\n  rawPolgyon: number[][][] | number[][][][]\n): Polygon[] => {\n  const polygons: Polygon[] = rawPolgyon.map((polygon) => {\n    const positions = polygon.map((coordinates) => {\n      let real: Position;\n      const hasOnlyArrays = isAllTrue(coordinates.map(Array.isArray));\n\n      if (hasOnlyArrays) {\n        const x = (coordinates as number[][]).flat(1);\n        real = { latitude: x[0], longitude: x[1] };\n      } else {\n        const realCoordinates = coordinates as number[];\n        real = { latitude: realCoordinates[0], longitude: realCoordinates[1] };\n      }\n\n      return real;\n    });\n\n    return positions;\n  });\n  return polygons;\n}"
  },
  "apply": {
    "name": "apply",
    "slug": "TsFunction",
    "id": "rforddllbrwoeragmhbjkkrq",
    "description": "sum([1, 2, 3]);\n\nfunction that takes an array of functions and applies them one by one, on the value or the result of the previous function. Only possible if the type of the value stays the same.",
    "operationName": "js-util",
    "rawText": " <T>(functions: ((input: T) => T)[], value: T) => {\n  return functions.reduce((val, fn) => {\n    return fn(val);\n  }, value);\n}"
  },
  "concatenate": {
    "name": "concatenate",
    "slug": "TsFunction",
    "id": "dcftdyzhrzckczufjdakcjua",
    "description": "",
    "operationName": "js-util",
    "rawText": " async (letter: string) => `${letter}+${letter}`"
  },
  "createEnum": {
    "name": "createEnum",
    "slug": "TsFunction",
    "id": "uxldfodlyabihekayjxlqbjt",
    "description": "creates an enum object from a readonly const array so you don't have to\n------\nconst taskNames = [\"a\",\"b\",\"c\"] as const;\ntype TaskNames = typeof taskNames[number];\nconst enummm = createEnum(taskNames);\n(value of enummm: { a: \"a\", b: \"b\", c: \"c\" })",
    "operationName": "js-util",
    "rawText": " <T extends readonly string[]>(\n  array: T\n): { [K in typeof array[number]]: K } =>\n  array.reduce((previous, current) => {\n    return { ...previous, [current]: current };\n  }, {} as any)"
  },
  "createMappedObject": {
    "name": "createMappedObject",
    "slug": "TsFunction",
    "id": "uyrosirzplyvfkmoveuqfegz",
    "description": "Creates a `MappedObject` of an array of any type. `MappedObject`s are great for increasing efficiency to get an item from an array. Especially useful when finds are needed on a specific key match for huge arrays. Instead of finding on the array you can simply get the right property from this object.\n\nNB: Don't use this inside of render functions, it's a very slow function, the whole idea is that this makes it faster, so just do it once!",
    "operationName": "js-util",
    "rawText": " <T extends { [key: string]: any }, U = T>(\n  array: T[],\n  /**\n   Key to make the map from. Must be unique or it could be overwritten. Key must be a string\n   */\n  mapKey: keyof T,\n  /**\n   * If the result of the mapped object, based on the object should have mapped values, provide this mapfunction to get them.\n   */\n  mapFn?: (value: T, array: T[]) => U\n): MappedObject<U> => {\n  const mappedObject = mergeObjectsArray(\n    array.map((item) => {\n      const key: string = item[mapKey];\n      const value = mapFn ? mapFn(item, array) : (item as unknown as U);\n\n      return {\n        [key]: value,\n      };\n    })\n  );\n\n  return mappedObject;\n}"
  },
  "destructureOptionalObject": {
    "name": "destructureOptionalObject",
    "slug": "TsFunction",
    "id": "bfjbgomyzqfsfjfpsindsdcm",
    "description": "Easy way to destructure your object even if it may be `undefined` or `null`.\n\nHave you ever had a function with an optional configuration parameter, but you want to access all its properties? It's a hassle. This function lets you turn `doSomething` into `doSomethingBetter`. Check the code.\n\n```ts\n\n\nconst doSomething = (config?: { a: string; b: boolean; c: number }) => {\nconst a = config?.a;\nconst b = config?.b;\nconst c = config?.c;\n\nreturn \"something\" + a + b + c;\n};\n\nconst doSomethingBetter = (config?: { a: string; b: boolean; c: number }) => {\nconst { a, b, c } = destructureOptionalObject(config);\nreturn \"something\" + a + b + c;\n};\n\n```\n\n<!-- It would be great if I could also make examples that not only refer to input/output combos but maybe another function that showcases it's usage... -->",
    "operationName": "js-util",
    "rawText": " <T extends { [key: string]: any }>(\n  object: T | null | undefined\n): Partial<T> => {\n  if (!object) return {} as Partial<T>;\n  return object;\n}"
  },
  "findLastIndex": {
    "name": "findLastIndex",
    "slug": "TsFunction",
    "id": "grhmhfdrrrppvzqoharfgdlb",
    "description": "finds the last index of an array where a certain filter holds true",
    "operationName": "js-util",
    "rawText": " <T>(array: T[], findFn: (item: T) => boolean) => {\n  const lastIndex = array\n    .map((item, index) => ({ item, index }))\n    .filter(({ item }) => findFn(item))\n    .pop()?.index;\n\n  return lastIndex;\n}"
  },
  "getObjectFromParamsString": {
    "name": "getObjectFromParamsString",
    "slug": "TsFunction",
    "id": "ewfnbmczjiioqvillnumkqkb",
    "description": "useful for cli's that only take strings. This creates an object from a string\n\ninput: \"x:a, y:b, z:c\"\noutput: { x: \"a\", y: \"b\", z: \"c\" }\n\nTODO: would be nice if we can validate this string immediately using a JSON SCHEMA",
    "operationName": "js-util",
    "rawText": " (paramsString: string) =>\n  mergeObjectsArray(\n    paramsString\n      .split(\",\")\n      .map((x) => x.trim().split(\":\"))\n      .map((pair) =>\n        pair[0] && pair[1] ? { [pair[0].trim()]: pair[1] } : null\n      )\n      .filter(notEmpty)\n  )"
  },
  "getObjectKeysArray": {
    "name": "getObjectKeysArray",
    "slug": "TsFunction",
    "id": "mzsbcusvhclgipwpqotlwueo",
    "description": "Handy function to get the keys of an object, but typed.\n\nNB: The only difference from Object.keys is that this returns the keys in a typesafe manner",
    "operationName": "js-util",
    "rawText": " <TObject extends { [key: string]: any }>(\n  object: TObject\n) => {\n  return Object.keys(object) as Extract<keyof TObject, string>[];\n}"
  },
  "getParameterAtLocation": {
    "name": "getParameterAtLocation",
    "slug": "TsFunction",
    "id": "rfyoxbnpeyzwzhfiswqlcbum",
    "description": "utility function to get a parameter inside of a nested object",
    "operationName": "js-util",
    "rawText": " <T = any>(\n  object: { [key: string]: any },\n  location: string[]\n): T => {\n  const firstParameter = object[location[0]];\n\n  if (location.length === 1) return firstParameter;\n\n  return getParameterAtLocation(firstParameter, location.slice(1));\n}"
  },
  "getSubsetFromObject": {
    "name": "getSubsetFromObject",
    "slug": "TsFunction",
    "id": "cawunnwhefnatboiurscedbt",
    "description": "takes an object and a subset of its keys and returns a subset of that object\n\ninput: { x: \"a\", y: \"b\", z: \"c\" } and [\"x\"]\n\noutput: { x: \"a\" }",
    "operationName": "js-util",
    "rawText": " <T, K extends readonly (keyof T)[]>(\n  object: T,\n  keys: K\n) => {\n  type Subset = typeof keys[number];\n\n  const subsetObject = keys.reduce((obj, key) => {\n    return { ...obj, [key]: object[key] };\n  }, {} as Partial<T>) as Pick<T, Subset>;\n  return subsetObject;\n}"
  },
  "groupByKey": {
    "name": "groupByKey",
    "slug": "TsFunction",
    "id": "edqakvyyvrtivzdggsgnfvoc",
    "description": "key should be of type string!\n\ninput = [{path:\"xyz\"},{path:\"xyz\"},{path:\"abc\"}]\ngroupByKey(input, \"path\")\nouput: { xyz: [{path:\"xyz\"},{path:\"xyz\"}], abc: [{path:\"abc\"}]}",
    "operationName": "js-util",
    "rawText": " <T extends { [key: string]: any }>(\n  array: T[],\n  key: keyof T\n) => {\n  return array.reduce((all, item) => {\n    const newAll = all;\n\n    const keyToUse: string = item[key as string];\n\n    const already = newAll[keyToUse];\n    if (!already) {\n      // create a new parameter in the group-object\n      newAll[item[key]] = [item];\n    } else {\n      // push to existing group-object parameter\n      newAll[item[key]].push(item);\n    }\n\n    return newAll;\n  }, {} as { [key: string]: T[] });\n}"
  },
  "hasAllLetters": {
    "name": "hasAllLetters",
    "slug": "TsFunction",
    "id": "tjkzrpjnlzaaoedfpynmdtwz",
    "description": "all letters of b can be found in a, in order (but other letters in between are allowed)",
    "operationName": "js-util",
    "rawText": " (a: string, b: string) => {\n  const lettersLeft = a\n    .split(\"\")\n    .reduce((lettersLeft, lowercaseValueLetter) => {\n      if (lettersLeft[0] === lowercaseValueLetter) {\n        lettersLeft.shift();\n      }\n\n      return lettersLeft;\n    }, b.split(\"\"));\n\n  return lettersLeft.length === 0;\n}"
  },
  "insertAt": {
    "name": "insertAt",
    "slug": "TsFunction",
    "id": "qzhszjiirxmogyndzxrgbyyh",
    "description": "Insert an array or item inside of an array before a certain index\n\nExample:\n\n```ts\n\nconst testArray = [1, 2, 3, 4, 5];\nconst result = insertAt(testArray, [99, 100], 2);\nconsole.log({ testArray, result });\n\n```",
    "operationName": "js-util",
    "rawText": " <T>(\n  array: T[],\n  items: T | T[],\n  /**\n   *\n   */\n  beforeIndex: number\n): T[] => {\n  const itemsArray = Array.isArray(items) ? items : [items];\n\n  // NB: slice makes copies\n  const before = array.slice(0, beforeIndex);\n  const after = array.slice(beforeIndex);\n  return [...before, ...itemsArray, ...after];\n}"
  },
  "isAllTrue": {
    "name": "isAllTrue",
    "slug": "TsFunction",
    "id": "rdnqxdavfrykvieuqvyoodao",
    "description": "checks if all items in an array are true",
    "operationName": "js-util",
    "rawText": " (array: boolean[]): boolean => {\n  return !array.find((x) => !x);\n}"
  },
  "makeArray": {
    "name": "makeArray",
    "slug": "TsFunction",
    "id": "mqydwnxjnwyrfxedecadkviz",
    "description": "if something is not an array, returns it as the first element of an array\n\nif the input is undefined, an empty array will be returned.\n\nNB: TODO: find out the workings of the array constructor (`Array(\"any value\")`), because maybe it does something very similar. No need to have a dependency then if it's similar.",
    "operationName": "js-util",
    "rawText": " <T>(...arrayOrNotArray: (T | T[] | undefined)[]) => {\n  return arrayOrNotArray\n    .map((arrayOrNot) => {\n      const array: T[] = arrayOrNot\n        ? Array.isArray(arrayOrNot)\n          ? arrayOrNot\n          : [arrayOrNot]\n        : [];\n\n      return array;\n    })\n    .flat();\n}"
  },
  "mapAsync": {
    "name": "mapAsync",
    "slug": "TsFunction",
    "id": "phvcamakgbcuqqhjgtnoqmxa",
    "description": "mapAsync makes it possible to map over an array async without having to do the promise.all afterwards\n\nIt saves a lot of lines of code, and makes it more readable\nExample usage:\n\n\n```ts\n\nconst myNumbers = [1, 2, 3, 4, 5];\n\nconst doubleAsync = (num) => Promise.resolve(num + num);\nconst sqrtAsync = (sum) => Promise.resolve(sum * sum);\nconst halfAsync = (time) => Promise.resolve(time / 2);\n\nconst doubleSqrtHalfs = await mapAsync(myNumbers, doubleAsync)\n.then((sums) => mapAsync(sums, sqrtAsync))\n.then((times) => mapAsync(times, halfAsync));\n```",
    "operationName": "js-util",
    "rawText": " <T, U>(\n  array: T[],\n  callback: (value: T, index: number, array: T[]) => Promise<U>\n) => {\n  const u = Promise.all(array.map(callback));\n  return u;\n}"
  },
  "mapItem": {
    "name": "mapItem",
    "slug": "TsFunction",
    "id": "rufmjrtehbcxbfjijxkaoirv",
    "description": "",
    "operationName": "js-util",
    "rawText": " async <T, U>(\n  mapFn: MapFn<T, U>,\n  currentValue: T,\n  index: number,\n  array: T[]\n): Promise<{\n  status: \"fulfilled\" | \"rejected\";\n  value?: U;\n  reason?: unknown;\n}> => {\n  try {\n    return {\n      status: \"fulfilled\",\n      value: await mapFn(currentValue, index, array),\n    };\n  } catch (reason) {\n    return {\n      status: \"rejected\",\n      reason,\n    };\n  }\n}"
  },
  "mapKeys": {
    "name": "mapKeys",
    "slug": "TsFunction",
    "id": "xanjfrdrljeuimrpejuunbnm",
    "description": "maps over all keys in an object and replaces them using a mapfn",
    "operationName": "js-util",
    "rawText": " async (\n  object: { [key: string]: any },\n  mapFn: (key: string) => string | Promise<string> | undefined\n) => {\n  const keyPairs = await Promise.all(\n    Object.keys(object).map(async (oldKey) => {\n      return { oldKey, newKey: await mapFn(oldKey) };\n    })\n  );\n\n  return mergeObjectsArray(\n    keyPairs\n      .map((pair) => {\n        return pair.newKey ? { [pair.newKey]: object[pair.oldKey] } : null;\n      })\n      .filter(notEmpty)\n  );\n}"
  },
  "mapMany": {
    "name": "mapMany",
    "slug": "TsFunction",
    "id": "mryjljsfkqrnjdbjjytgkrbc",
    "description": "Lets you map over any array with a async function while setting a max. concurrency\n\nTaken and improved from https://codeburst.io/async-map-with-limited-parallelism-in-node-js-2b91bd47af70",
    "operationName": "js-util",
    "rawText": " async <T, U>(\n  array: T[],\n  mapFn: (item: T, index: number, array: T[]) => Promise<U>,\n  /**\n   * Limit of amount of items at the same time\n   */\n  limit?: number\n): Promise<U[]> => {\n  const result: U[] = [];\n\n  if (array.length === 0) {\n    return result;\n  }\n\n  const generator = arrayGenerator(array);\n  const realLimit = Math.min(limit || array.length, array.length);\n  const workers = new Array(realLimit);\n\n  for (let i = 0; i < realLimit; i++) {\n    workers.push(worker(i, generator, mapFn, result));\n  }\n\n  // console.log(`Initialized ${limit} workers`);\n\n  await Promise.all(workers);\n\n  return result;\n}"
  },
  "mapValuesSync": {
    "name": "mapValuesSync",
    "slug": "TsFunction",
    "id": "mlahoapflssxtcgdrqbecovp",
    "description": "maps over all values in an object and replaces them using a mapfn\n\nsync",
    "operationName": "js-util",
    "rawText": " <T, U>(\n  object: { [key: string]: T },\n  mapFn: (value: T) => U\n) => {\n  const valueObjectParts = Object.keys(object).map((key) => {\n    return { [key]: mapFn(object[key]) };\n  });\n\n  return mergeObjectsArray(valueObjectParts);\n}"
  },
  "mergeNestedObjectTest": {
    "name": "mergeNestedObjectTest",
    "slug": "TsFunction",
    "id": "ozdmenlebrpbkmoiypqnofbz",
    "description": "",
    "operationName": "js-util",
    "rawText": " () => {\n  const testObject: {\n    a: string;\n    b: number;\n    c: { x: string; y: number; z: { a: string; b: number; c: { x: \"wow\" } } };\n  } = {\n    a: \"lol\",\n    b: 8,\n    c: { x: \"lol\", y: 88, z: { a: \"wow\", b: 888, c: { x: \"wow\" } } },\n  };\n\n  const result = mergeNestedObject(testObject, {\n    c: { z: { c: { x: undefined }, b: 999 } },\n  });\n\n  console.dir({ testObject, result }, { depth: 999 });\n}"
  },
  "mergeNestedObject": {
    "name": "mergeNestedObject",
    "slug": "TsFunction",
    "id": "rcwxheqjxcappefitmdyjgbh",
    "description": "type X = IsOptional<string|undefined>;\n\nMerges an object into an object, ensuring typesafety. The second object needs to be a recursive subset of the first.\n\nLIMITATION: When you set a value to undefined, ensure that it is allowed by the original object, we are not checking for this!\n\nTODO: is it possible to remove this type unsafety? It would be nice to only be able to set it to undefined if that is allowed by T. Not sure if it's possible to check the difference bewteen a key not being present and a key being present and the value being undefined... Look it up!\n\nExample:\n\n\n```ts\n\nconst testObject: {\na: string;\nb: number;\nc: { x: string; y: number; z: { a: string; b: number; c: { x: \"wow\" } } };\n} = {\na: \"lol\",\nb: 8,\nc: { x: \"lol\", y: 88, z: { a: \"wow\", b: 888, c: { x: \"wow\" } } },\n};\n\nconst result = mergeNestedObject(testObject, {\nc: { z: { c: { x: undefined }, b: 999 } },\n});\n\nconsole.dir({ testObject, result }, { depth: 10 });\n\nresult will be: { a: 'lol', b: 8, c: { x: 'lol', y: 88, z: { a: 'wow', b: 999, c: { x: undefined } } }\n}\n\n```\n\nIt's great, because you can't make any type mistakes, and your code becomes much shorter for altering an object",
    "operationName": "js-util",
    "rawText": " <T extends O>(\n  object: T,\n  otherObject: NestedPartial<T> | undefined\n): T => {\n  if (object === undefined && otherObject !== undefined) {\n    // basecase that is used if the original object has some optional value undefined. in that case, the otherObject is used to set that key\n    return otherObject as T;\n  }\n  if (otherObject === undefined) return object;\n  // put `otherObject` on object, make sure\n\n  // const withoutUndefinedOtherObject = omitUndefinedValues(otherObject);\n  const partialNewObject = mergeObjectsArray(\n    // go over all keys in otherObject...\n    getObjectKeysArray(otherObject).map((key) => {\n      // get the value for it\n      const otherObjectValue = otherObject[key];\n\n      //   if it's defined, but not an object.. the value is definite.\n      // NB: arrays are also objects, but in this case they should also return\n      if (\n        typeof otherObjectValue !== \"object\" ||\n        Array.isArray(otherObjectValue)\n      ) {\n        return { [key]: otherObject[key] };\n      }\n\n      //   if it's defined and its type is an object, that object needs to be merged with the full object\n      const newValue = mergeNestedObject(object[key], otherObject[key]);\n\n      return { [key]: newValue };\n    })\n  ) as T;\n\n  //   ensure to merge the result with the original object to also do the first level\n  return { ...object, ...partialNewObject };\n}"
  },
  "mergeObjectParameters": {
    "name": "mergeObjectParameters",
    "slug": "TsFunction",
    "id": "jhcqjmeczmvpmadlaahgfzgc",
    "description": "merges two objects: a config object and a defaults object. If the config object has something missing, a default will be used from the defaults object.\n\nIn short: merges two objects, for every parameter, use the default as a fallback\n\nDEPRECATED: in favor of mergeObjects",
    "operationName": "js-util",
    "rawText": " <T>(\n  config: T | undefined,\n  defaults: T | undefined\n) => {\n  const parameters = Object.keys({\n    ...config,\n    ...defaults,\n  }) as (keyof T)[];\n\n  const mergedConfig = parameters.reduce(\n    (getConfig, p) => ({ ...getConfig, [p]: config?.[p] || defaults?.[p] }),\n    {} as Partial<T>\n  );\n  return mergedConfig;\n}"
  },
  "mergeObjectsArray": {
    "name": "mergeObjectsArray",
    "slug": "TsFunction",
    "id": "yzgkukaojngqdjcgnseljhco",
    "description": "TODO: find a way to return the correct type interface",
    "operationName": "js-util",
    "rawText": " <T extends { [key: string]: any }>(\n  objectsArray: T[]\n): T => {\n  const result = objectsArray.reduce((previous, current) => {\n    return { ...previous, ...current };\n  }, {} as T);\n\n  return result;\n}"
  },
  "mergeObjects": {
    "name": "mergeObjects",
    "slug": "TsFunction",
    "id": "eeqjzrmrmydlzaxddlxsrkgt",
    "description": "merges multiple objects, overwriting the previous one with the next. Can be useful for configs where there are multiple layers of configs that overwrite each other.\n\nPlease note though, that only the root keys of the object are overwriting each other, so if there is nested datastructures, the last one with a specific key overwrites the previous ones copletely\n\nPlease note that you can provide partial objects as well, as long as you are sure that the final object is full, the type interface is correct.\n\nPlease note that if a latter object has a key which holds \"undefined\", it will NOT overwrite it. Anything else WILL",
    "operationName": "js-util",
    "rawText": " <T extends { [key: string]: any | undefined }>(\n  ...objects: (Partial<T> | undefined)[]\n): T | undefined => {\n  if (objects.length === 0) return;\n\n  const firstObject = objects[0];\n\n  const mergedObject = objects.reduce((previous, current) => {\n    if (!current) return previous;\n\n    const currentWithoutUndefined = omitUndefinedValues(current);\n\n    const newObject: Partial<T> | undefined = !previous\n      ? current\n      : { ...previous, ...currentWithoutUndefined };\n\n    return newObject;\n    // NB: we cannot guarantee this based on the input!\n  }, firstObject) as T;\n\n  return mergedObject;\n}"
  },
  "noEmptyString": {
    "name": "noEmptyString",
    "slug": "TsFunction",
    "id": "ljstksrbfbzhpndtdzfybpop",
    "description": "",
    "operationName": "js-util",
    "rawText": " (\n  input: string | undefined\n): string | undefined => {\n  if (input === \"\") return undefined;\n  return input;\n}"
  },
  "objectMapAsync": {
    "name": "objectMapAsync",
    "slug": "TsFunction",
    "id": "xawxfwmzrvikixukfwgwiazo",
    "description": "Map an object asynchronously and return the same object with the mapped result in its values\n\nExample usage:\n\n\n```ts\n\nconst srcFileContentObject = {\n\"index.ts\": indexString,\n\"public-local.ts\": publicLocalTypescriptFileString,\n\"public.ts\": publicTypescriptFileString,\n};\n\nconst srcFileWriteSuccessObject = await objectMapAsync(srcFileContentObject, async (operationRelativeTypescriptFilePath,content)=>{\n\ntry {\nawait fs.writeFile(\npath.join(operationBasePath, \"src\", operationRelativeTypescriptFilePath),\ncontent,\n\"utf8\"\n);\n\nreturn true;\n\n} catch {\nreturn false;\n}\n\n});\n\n```",
    "operationName": "js-util",
    "rawText": " async <\n  TObject extends { [key: string]: any },\n  TResultValue,\n  TResultObject extends {\n    [key in keyof TObject]: TResultValue;\n  }\n>(\n  object: TObject,\n  mapFn: (\n    key: Extract<keyof TObject, string>,\n    value: TObject[keyof TObject]\n  ) => Promise<TResultValue>\n): Promise<TResultObject> => {\n  const keys = getObjectKeysArray(object);\n\n  const result = mergeObjectsArray(\n    await Promise.all(\n      keys.map(async (key) => {\n        const value = object[key];\n        return { [key]: await mapFn(key, value) };\n      })\n    )\n  ) as unknown as TResultObject;\n\n  return result;\n}"
  },
  "objectMapSync": {
    "name": "objectMapSync",
    "slug": "TsFunction",
    "id": "fynfzqfvnygwmzthhanvzcym",
    "description": "maps over all values in an object and replaces them using a mapfn\n\nExample usage:\n\n```ts\n\nconst result = objectMapSync({ hello: \"world\", isTrue: true }, (key,value) => {\nreturn `${value}123`;\n});\n```",
    "operationName": "js-util",
    "rawText": " <\n  TObject extends { [key: string]: any },\n  TMapResult,\n  TResultObject extends { [key in keyof TObject]: TMapResult }\n>(\n  object: TObject,\n  mapFn: (key: keyof TObject, value: TObject[keyof TObject]) => TMapResult\n): TResultObject => {\n  const valueObjectParts = getObjectKeysArray(object).map((key) => {\n    return { [key]: mapFn(key, object[key]) };\n  });\n\n  const merged = mergeObjectsArray(\n    valueObjectParts\n  ) as unknown as TResultObject;\n\n  return merged;\n}"
  },
  "objectValuesMap": {
    "name": "objectValuesMap",
    "slug": "TsFunction",
    "id": "djqznicdhjfaxindbiwutwei",
    "description": "not sure if this is the best way, but it does save some lines of code!\n\nmaps over an object's values with a map function\n\nDEPRECATED in favour of objectMapSync and objectMapAsync",
    "operationName": "js-util",
    "rawText": " <\n  T extends { [key: string]: T[string] },\n  U extends unknown\n>(\n  object: T,\n  mapFn: (key: string, value: T[string]) => U\n): { [key: string]: U } => {\n  return Object.keys(object).reduce(function (result, key) {\n    result[key] = mapFn(key, object[key]);\n    return result;\n  }, {} as any);\n}"
  },
  "omitUndefinedValues": {
    "name": "omitUndefinedValues",
    "slug": "TsFunction",
    "id": "nmyeowbfgdbffqiwbqgigqsk",
    "description": "",
    "operationName": "js-util",
    "rawText": " <T extends { [key: string]: any }>(\n  object: T\n) => {\n  Object.keys(object).map((key) => {\n    const value = object[key];\n    if (value === undefined) {\n      delete object[key];\n    }\n  });\n\n  return object;\n}"
  },
  "onlyUnique2": {
    "name": "onlyUnique2",
    "slug": "TsFunction",
    "id": "brqihoammgbmelhojkkjyyed",
    "description": "function that returns a filter function that can be used as a filter for any array. removes duplicates.\n\noptionally takes a compare function that should return a \"true\" if two instances are equal. if you use this function, make sure to pass a generic of the type the items will have, in order to make this equality function type safe as well",
    "operationName": "js-util",
    "rawText": "\n  <U>(isEqualFn?: (a: U, b: U) => boolean) =>\n  <T extends U>(value: T, index: number, self: T[]) => {\n    return (\n      self.findIndex((v) => (isEqualFn ? isEqualFn(v, value) : v === value)) ===\n      index\n    );\n  }"
  },
  "pickRandomArrayItem": {
    "name": "pickRandomArrayItem",
    "slug": "TsFunction",
    "id": "mzepkmitzkrsopxprszhtibp",
    "description": "",
    "operationName": "js-util",
    "rawText": " <T>(array: T[]) => {\n  return array[Math.floor((array.length - 1) * Math.random())];\n}"
  },
  "putIndexAtIndex": {
    "name": "putIndexAtIndex",
    "slug": "TsFunction",
    "id": "vcronwnoujmmkstncksoxdhl",
    "description": "Takes an item from an index of an array and put it somewhere at another index",
    "operationName": "js-util",
    "rawText": " <T>(\n  array: T[],\n  index: number,\n  toIndex: number\n) => {\n  const item = array[index];\n  const arrayWithoutIndex = removeIndexFromArray(array, index);\n  const changedArray = insertAt(arrayWithoutIndex, item, toIndex);\n  return changedArray;\n}"
  },
  "removeIndexFromArray": {
    "name": "removeIndexFromArray",
    "slug": "TsFunction",
    "id": "lmmkqitwtacjemublasxxllj",
    "description": "removes an index from an array\n\nexample:\n\n```ts\nconst exampleArray = [\"a\", \"b\", \"c\", \"d\", \"e\"];\nconsole.log(removeIndexFromArray(exampleArray, 2)); //c should be removed\n```",
    "operationName": "js-util",
    "rawText": " <T>(array: T[], index: number) => {\n  const before = array.slice(0, index);\n  const after = array.slice(index + 1);\n  return [...before, ...after];\n}"
  },
  "removeOptionalKeysFromObjectStrings": {
    "name": "removeOptionalKeysFromObjectStrings",
    "slug": "TsFunction",
    "id": "nsnvyjzvsakcfqwtjuhfbmpo",
    "description": "",
    "operationName": "js-util",
    "rawText": " <TObject extends O>(\n  object: TObject,\n  keys: string[]\n): TObject => {\n  const newObject = keys.reduce((objectNow, key) => {\n    return {\n      ...objectNow,\n      [key]: undefined,\n    };\n  }, object);\n\n  return newObject;\n}"
  },
  "removeOptionalKeysFromObject": {
    "name": "removeOptionalKeysFromObject",
    "slug": "TsFunction",
    "id": "kcwksloockwaaiipkzkktxbf",
    "description": "",
    "operationName": "js-util",
    "rawText": " <TObject extends O>(\n  object: TObject,\n  keys: OptionalKeys<TObject>[]\n): TObject => {\n  return removeOptionalKeysFromObjectStrings(object, keys);\n}"
  },
  "replaceLastOccurence": {
    "name": "replaceLastOccurence",
    "slug": "TsFunction",
    "id": "dehtyrxopktybxcfojgjkjyy",
    "description": "Replaces the last occerence of something in a string by something else\n\nExample:\n\n```ts\nconst result = replaceLastOccurence(\"theBestSlugSlugSlug\", \"Slug\", \"Slack\");\nconsole.log(result); // returns theBestSlugSlugSlack\n```\n\nNB: this is not the most efficient method, as it reverses the string by making it an array, twice. It can probably be done more efficiently by using `String.lastIndexOf`",
    "operationName": "js-util",
    "rawText": " (\n  string: string,\n  searchValue: string,\n  replaceValue: string\n) => {\n  const [reversedString, reversedSearchValue, reversedReplaceValue] = [\n    string,\n    searchValue,\n    replaceValue,\n  ].map(reverseString);\n\n  const replacedReversedString = reversedString.replace(\n    reversedSearchValue,\n    reversedReplaceValue\n  );\n\n  const replacedString = reverseString(replacedReversedString);\n\n  return replacedString;\n}"
  },
  "reverseString": {
    "name": "reverseString",
    "slug": "TsFunction",
    "id": "psnnlsnwdulpoouwkegeludp",
    "description": "",
    "operationName": "js-util",
    "rawText": " (string: string): string => {\n  return string.split(\"\").reverse().join(\"\");\n}"
  },
  "sumAllKeys": {
    "name": "sumAllKeys",
    "slug": "TsFunction",
    "id": "musebofqdxzxtoltoyusvbop",
    "description": "sums all keys of an array of objects, assuming the objects have the same datastructure and assuming the values contain either numbers or undefined",
    "operationName": "js-util",
    "rawText": " <T extends { [key: string]: number | undefined }>(\n  objectArray: T[],\n  keys: (keyof T)[]\n): T => {\n  const sumObject = objectArray.reduce((total, item) => {\n    // NB: not needed normally, but there seems to be some corrupt data here and there\n    if (!item) return total;\n    const newTotal = mergeObjectsArray(\n      keys.map((key) => {\n        const value1: number = total ? total[key] || 0 : 0;\n        const value2: number = item?.[key] || 0;\n\n        const sum =\n          (!total || total[key] === undefined) && item[key] === undefined\n            ? undefined\n            : value1 + value2;\n\n        return { [key]: sum };\n      })\n    ) as T;\n\n    return newTotal;\n  }, null as null | T) as T;\n\n  return sumObject;\n}"
  },
  "sumObjectParameters": {
    "name": "sumObjectParameters",
    "slug": "TsFunction",
    "id": "quhxugtkoyfgckskvbrtkazl",
    "description": "sums all parameters in two objects together",
    "operationName": "js-util",
    "rawText": " <TObject extends { [key: string]: number }>(\n  object1: TObject,\n  object2: TObject\n): TObject => {\n  const objectKeys: (keyof TObject)[] = Object.keys(object1);\n  const summedObject = mergeObjectsArray(\n    objectKeys.map((key) => {\n      const summedObjectPart = { [key]: object1[key] + object2[key] };\n\n      return summedObjectPart;\n    })\n  ) as TObject;\n  // NB: too bad we still need `as TObject` here. I would love to learn how to prevent that\n\n  return summedObject;\n}"
  },
  "takeFirst": {
    "name": "takeFirst",
    "slug": "TsFunction",
    "id": "qvgqkzgbhjjmosbrujrilwfi",
    "description": "takes any type T or an array of T and returns T or the first of the array (which is T)",
    "operationName": "js-util",
    "rawText": " <T>(arrayOrNot: T | T[]) => {\n  return makeArray(arrayOrNot)[0];\n}"
  },
  "trimSlashes": {
    "name": "trimSlashes",
    "slug": "TsFunction",
    "id": "oqqstzpmdxxlflxozfkhcvbw",
    "description": "Trims a slash on both sides in any path",
    "operationName": "js-util",
    "rawText": " (absoluteOrRelativePath: string) => {\n  const isFirstCharacterSlash = absoluteOrRelativePath.charAt(0) === \"/\";\n  const isLastCharacterSlash =\n    absoluteOrRelativePath.charAt(absoluteOrRelativePath.length - 1) === \"/\";\n\n  const withoutSlashPrefix = isFirstCharacterSlash\n    ? absoluteOrRelativePath.slice(1)\n    : absoluteOrRelativePath;\n  const withoutSlashSuffix = isLastCharacterSlash\n    ? withoutSlashPrefix.slice(0, withoutSlashPrefix.length - 1)\n    : withoutSlashPrefix;\n\n  return withoutSlashSuffix;\n}"
  },
  "devCli": {
    "name": "devCli",
    "slug": "TsFunction",
    "id": "kokuqqviwbapisjgzhrcypli",
    "description": "The dev-cli runs the `dev` command which watches your operations with restarts\n\nYou can specify a customManualProjectRoot, which can be a relative or absolute path. If relative, it will use your cwd with the relative path to make an absolute path, that will in turn be passed to the `dev` function.",
    "operationName": "k-dev",
    "rawText": " async () => {\n  const [customManualProjectRoot] = process.argv.slice(2);\n\n  if (!customManualProjectRoot) return dev();\n\n  if (customManualProjectRoot.startsWith(\".\")) {\n    // relative path\n    const realProjectRootPath = path.join(\n      process.cwd(),\n      customManualProjectRoot\n    );\n\n    return dev(realProjectRootPath);\n  }\n\n  // absolute path\n  dev(customManualProjectRoot);\n}"
  },
  "dev": {
    "name": "dev",
    "slug": "TsFunction",
    "id": "wpihejfhnvynnbshaufbtblz",
    "description": "Running this function will start a watcher that watches all your operations for changes and rebuilds the operation on every change (compiling and indexing the altered file(s))",
    "operationName": "k-dev",
    "rawText": " (\n  /**\n   * manual project root for finding the operations\n   */\n  manualProjectRoot?: string\n): void => {\n  if (manualProjectRoot && !fs.existsSync(manualProjectRoot)) {\n    console.log(\"Please enter a manualProjectRoot that exists\");\n    return;\n  }\n\n  const vars = manualProjectRoot ? [manualProjectRoot] : undefined;\n  nodemon(\"watch-operations\", \"watchOperations\", vars);\n}"
  },
  "DEBUG": {
    "name": "DEBUG",
    "slug": "TsVariable",
    "id": "eclyttivmibxqomkjbjxuvmc",
    "description": "if true, also shows debug messages",
    "operationName": "log"
  },
  "getCallerFileName": {
    "name": "getCallerFileName",
    "slug": "TsFunction",
    "id": "qzhjicvbtknafbqdusqdtwrt",
    "description": "TODO: this is great. now also get the operationName. If the operationName appears in the config, for debug, show the log, otherwise don't show",
    "operationName": "log",
    "rawText": " () => {\n  const stack = new Error().stack;\n  if (!stack) return;\n\n  // console.log(\"Complete stack\", stack);\n  const firstRelevantLine = stack.split(\"\\n\")[3];\n  if (!firstRelevantLine) return;\n\n  const jsFilePath = firstRelevantLine.split(\"at \")[1].split(\":\")[0];\n\n  if (!jsFilePath) return;\n\n  const srcPath = jsFilePath.replace(\"/build/\", \"/src/\").replace(\".js\", \".ts\");\n\n  return srcPath;\n}"
  },
  "log": {
    "name": "log",
    "slug": "Operation",
    "id": "utIDjwWGsHDpuZby",
    "operationName": "log"
  },
  "options": {
    "name": "options",
    "slug": "TsVariable",
    "id": "olyfxvyfoimbrbfpefllotsb",
    "description": "special character combinations that make the console message be printed differently",
    "operationName": "log"
  },
  "parseTitle": {
    "name": "parseTitle",
    "slug": "TsFunction",
    "id": "nsbqwoxiitnmhyoojcxcszyn",
    "description": "TODO: Should parse a title from markdown",
    "operationName": "log",
    "rawText": " (markdown: string) => {\n  const sentences = markdown\n    .split(\"\\n\")\n    .map((x) => x.split(\".\"))\n    .flat();\n\n  const [title, ...rest] = sentences;\n\n  return { title, rest: rest.filter((x) => x.length > 0).join(\"\\n\") };\n}"
  },
  "resetString": {
    "name": "resetString",
    "slug": "TsVariable",
    "id": "nlkfxatmkoekvizjudgmcepn",
    "description": "",
    "operationName": "log"
  },
  "cleanupTimer": {
    "name": "cleanupTimer",
    "slug": "TsFunction",
    "id": "lrzawfpocemqlsmnwefttkxz",
    "description": "Ensure you run this after finishing the measurement, or you'll run into memory leaks!",
    "operationName": "measure-performance",
    "rawText": " (uniqueId: string) => {\n  delete timer[uniqueId];\n}"
  },
  "generateUniqueId": {
    "name": "generateUniqueId",
    "slug": "TsFunction",
    "id": "ltevqbklhkskbesuihjgekpc",
    "description": "Bit annoying that we need to use all model-types here xD.\n\nTODO: Let's extrahere this",
    "operationName": "measure-performance",
    "rawText": " () => generateId()"
  },
  "getNewPerformance": {
    "name": "getNewPerformance",
    "slug": "TsFunction",
    "id": "abaqbnuyoiczrdhhxtyiwacn",
    "description": "Function that lets you measure performance inside any function with ease.\n\nUsage:\n\nFirstly, make a performance array, and a unique execution id, and start the measurement, like so:\n\n```ts\nimport { generateUniqueId, getNewPerformance, PerformanceItem, cleanupTimer } from \"measure-performance\";\n\nat the start of your function\n\nconst executionId = generateUniqueId();\nconst performance: (PerformanceItem | undefined)[] = [];\ngetNewPerformance(\"start\", executionId, true)\n```\n\n\nAfter that, push a new performance item at every step you want to measure. Provide your label describing what happened before this (the step you are measuring).\n\n\n```ts\nperformance.push(getNewPerformance(\"your label\", executionId));\n```\n\nAt the end of your function, you can view your performance array by printing it on the console (or store it somewhere if you like)\n\nDon't forget to run `cleanupTimer`, or you'll run into memory leaks!\n\n```ts\ncleanupTimer(executionId);\n```",
    "operationName": "measure-performance",
    "rawText": " (\n  label: string,\n  uniqueId: string,\n  isNew?: boolean\n): PerformanceItem | undefined => {\n  const timePrevious = timer[uniqueId];\n  const timeNow = Date.now();\n  timer[uniqueId] = timeNow;\n\n  if (isNew) return;\n\n  const durationMs = timeNow - timePrevious;\n\n  return { label, durationMs };\n}"
  },
  "timer": {
    "name": "timer",
    "slug": "TsVariable",
    "id": "hqgapslvuzjgddfsjchnkpjg",
    "description": "TODO: This stores into memory. May cause memory leaks in the long run if not cleaned up!",
    "operationName": "measure-performance"
  },
  "nodemon": {
    "name": "nodemon",
    "slug": "Operation",
    "id": "IzGAOgwTzdWieQVE",
    "operationName": "nodemon"
  },
  "oneByOne": {
    "name": "oneByOne",
    "slug": "TsFunction",
    "id": "arqtrikqrnogqhljfjofppch",
    "description": "for every item in an array, executes an async callback, one by one.\npromises an array of the results of every callback once it's done",
    "operationName": "one-by-one",
    "rawText": " async <T, U>(\n  array: T[],\n  callback: (instance: T, index: number) => Promise<U>\n): Promise<U[]> => {\n  const getResults = async (\n    results: Promise<U[]>,\n    instance: T,\n    index: number\n  ) => {\n    const awaitedResults = await results;\n    const result: U = await callback(instance, index);\n    const newResults = [...awaitedResults, result];\n    return newResults;\n  };\n\n  const result = await array.reduce(\n    getResults,\n    new Promise<U[]>((resolve) => resolve([]))\n  );\n\n  return result;\n}"
  },
  "isPlural": {
    "name": "isPlural",
    "slug": "TsFunction",
    "id": "mkvnspzkwckfeujwrzcxophb",
    "description": "",
    "operationName": "pluralize",
    "rawText": " (parameterName: string) => {\n  return parameterName.endsWith(\"s\");\n}"
  },
  "isSingular": {
    "name": "isSingular",
    "slug": "TsFunction",
    "id": "iikpwvdwavxihavzgqwbjbqk",
    "description": "",
    "operationName": "pluralize",
    "rawText": " (parameterName: string) => {\n  return !isPlural(parameterName);\n}"
  },
  "pluralize": {
    "name": "pluralize",
    "slug": "Operation",
    "id": "NfHZnxRqNZvFFLsW",
    "operationName": "pluralize"
  },
  "singularize": {
    "name": "singularize",
    "slug": "TsFunction",
    "id": "aqagtbyvtgzxwwiicdejbqng",
    "description": "Removes the 's' if it is found at the end of the parameter name",
    "operationName": "pluralize",
    "rawText": " (parameterName: string) => {\n  return parameterName.endsWith(\"s\")\n    ? parameterName.substring(0, parameterName.length - 1)\n    : parameterName;\n}"
  },
  "[argument]": {
    "name": "[argument]",
    "slug": "TsVariable",
    "id": "wcmvbyherhkbmqqtogjpklfi",
    "description": "",
    "operationName": "run-child-process"
  },
  "runChildProcess": {
    "name": "runChildProcess",
    "slug": "TsFunction",
    "id": "tzcpzdhfwnsthelokwybwvns",
    "description": "spawns a child process and returns its output after it's done",
    "operationName": "run-child-process",
    "rawText": " async (config: {\n  operationFolderName: string;\n  /**\n   * the location of the script in the build folder\n   * NB: this must be a CLI that that actually executes the function!\n   */\n  scriptFileName: string;\n  /**\n   * all arguments you wish to pass to the script. If an argument is undefined, it will not be passed. Arguments to be passed must be strings\n   */\n  args?: (string | undefined)[];\n}) => {\n  const { operationFolderName, scriptFileName, args } = config;\n\n  const childOperationPath = await getOperationPath(operationFolderName);\n  if (!childOperationPath) {\n    log(\n      `Couldn't find childOperationPath for operation ${operationFolderName}`,\n      { type: \"error\" }\n    );\n    return;\n  }\n  const scriptPath = path.join(\n    childOperationPath,\n    `build/${scriptFileName}.js`\n  );\n\n  if (!fs.existsSync(scriptPath)) {\n    log(\n      `Couldn't find scriptFile ${scriptFileName} which should be at build/${scriptFileName}.js`,\n      { type: \"error\" }\n    );\n    return;\n  }\n\n  const readable = await canRead(scriptPath);\n\n  if (!readable) {\n    log(`Can't read ${scriptPath}`, { type: \"error\" });\n    return;\n  }\n\n  const command = `node ${scriptPath} ${\n    args?.filter(notEmpty).join(\" \") || \"\"\n  }`;\n\n  // log(`going to execute: ${command}`, { type: \"important\" });\n\n  const result = spawnSync(command, {\n    shell: true,\n    stdio: \"inherit\",\n    encoding: \"utf8\",\n  });\n\n  return result.output;\n}"
  },
  "chatGPTAuth": {
    "name": "chatGPTAuth",
    "slug": "TsFunction",
    "id": "yqogvinkgtgvlcyzmopkipfk",
    "description": "",
    "operationName": "chatgpt-controller",
    "rawText": " async (page: Page): Promise<LoginResponse> => {\n  try {\n    console.log(\"Chatgpt login chandler called\");\n    const credentials: MediaCredential[] = await db.get(\"MediaCredential\");\n    console.log({ credentials });\n    const openAICredential = credentials?.find(\n      (c) => c.username === \"openai\"\n    ) || {\n      email: \"bhagyasah4u@gmail.com\",\n      password: \"openai@199201\",\n    };\n    console.log({ openAICredential });\n    if (!openAICredential)\n      return { isSuccessfull: false, message: \"Credential not found\" };\n    const { email, password } = openAICredential || openAICredential;\n    await page.goto(\"https://chat.openai.com/auth/login\", {\n      waitUntil: \"domcontentloaded\",\n    });\n\n    const isSecurePageApear = await page.$x(\n      \"//h2[contains(., 'Checking if the site connection is secure')]\"\n    );\n\n    if (isSecurePageApear) {\n      console.log(\"Need to captcha solution\");\n      const isCaptchaExistRes = await isCaptchaExist(page);\n      console.log({ isCaptchaExistRes });\n      await page.waitForSelector(\n        'button[class=\"btn flex justify-center gap-2 btn-primary\"]'\n      );\n    }\n\n    const isLoginPageApear = await page.$x(\"//button[contains(., 'Log in')]\");\n    if (Boolean(isLoginPageApear[0])) {\n      console.log(\"LOGIN PAGE DETECTED\");\n      //@ts-ignore\n      isLoginPageApear[0].click();\n      await page.waitForNavigation({ waitUntil: \"domcontentloaded\" });\n      await page.waitForSelector('input[id=\"username\"]');\n      const usernameInput = await page.$('input[id=\"username\"]');\n\n      if (usernameInput) {\n        //@ts-ignore\n        usernameInput.click();\n        //@ts-ignore\n        await page.keyboard.type(email);\n      }\n      //Checking and solving the captcha\n      const { captchas } = await isCaptchaExist(page);\n      if (captchas.length > 0) {\n        console.log(\"CAPTCHA DETECTED\");\n        const captchaSolveResponse = await solveReptcha(page);\n        console.log({\n          captchaSolveResponse: JSON.stringify(captchaSolveResponse),\n        });\n        if (!captchaSolveResponse.error) {\n          await page.waitForSelector('button[type=\"submit\"]');\n          await page.click('button[type=\"submit\"]');\n          await page.waitForSelector('input[name=\"password\"]', {\n            timeout: 30000,\n          });\n          await page.focus('input[name=\"password\"]');\n          await page.keyboard.type(password);\n          await page.waitForSelector('button[type=\"submit\"]');\n          await page.click('button[type=\"submit\"]');\n          page.waitForNavigation({ waitUntil: \"domcontentloaded\" });\n          return { isSuccessfull: true, message: \"Login Succcessfull\" };\n        }\n      }\n    }\n    return { isSuccessfull: false, message: \"Login faild\" };\n  } catch (e: Error | any) {\n    return { isSuccessfull: false, message: e?.message };\n  }\n}"
  },
  "detectChatGptPage": {
    "name": "detectChatGptPage",
    "slug": "TsFunction",
    "id": "cvmsoqwxrhghqvuglbzmuelp",
    "description": "",
    "operationName": "chatgpt-controller",
    "rawText": " async (\n  page: Page\n): Promise<\"Login\" | \"Chat\" | \"Secure\"> => {\n  await page.goto(\"https://chat.openai.com/chat\", {\n    waitUntil: \"domcontentloaded\",\n  });\n\n  const sendMessageButton = await page.$(\n    'button[class=\"absolute p-1 rounded-md text-gray-500 bottom-1.5 right-1 md:bottom-2.5 md:right-2 hover:bg-gray-100 dark:hover:text-gray-400 dark:hover:bg-gray-900 disabled:hover:bg-transparent dark:disabled:hover:bg-transparent\"]'\n  );\n\n  const isTextAreaExist = await page.$(\"textarea\");\n\n  if (sendMessageButton && isTextAreaExist) {\n    return \"Chat\";\n  }\n\n  const isSecurePageApear = await page.$x(\n    \"//h2[contains(., 'Checking if the site connection is secure')]\"\n  );\n\n  const isLogin = 'button[class=\"btn flex justify-center gap-2 btn-primary\"]';\n  console.log({ isLogin });\n  if (isSecurePageApear && isLogin) {\n    console.log(\"Unexpected page appear please solve manually\");\n    const { captchas } = await isCaptchaExist(page);\n    if (captchas.length > 0) {\n      console.log(\"CAPTCHA DETECTED\");\n      const captchaSolveResponse = await solveReptcha(page);\n      console.log({ captchaSolveResponse });\n    }\n    try {\n      await page.waitForSelector(\n        'button[class=\"btn flex justify-center gap-2 btn-primary\"]',\n        { timeout: 60000 }\n      );\n      console.log('\"Login button appear');\n      return \"Login\";\n    } catch (e: Error | any) {\n      console.error(\"Erro to to get login page so may be its a chat page open\");\n      return \"Chat\";\n    }\n  }\n  return \"Secure\";\n}"
  },
  "openAIChat": {
    "name": "openAIChat",
    "slug": "TsFunction",
    "id": "ttzylsllxlictfeflyebbfjq",
    "description": "Send the propt to chatgpt and return the chatgpt response",
    "operationName": "chatgpt-controller",
    "rawText": " async (\n  props: OpenAIChatProps\n): Promise<ProcessPromptFunctionResult> => {\n  const { prompt, thread, isHeadless } = props;\n  console.log(\"openAIChat Called\", props);\n  // chat login test ...\n\n  const page = await openPage(thread);\n\n  if (!page) return { isSuccessful: false, message: \"Faild to create page.\" };\n  //@ts-ignore\n  const pageId = await page.target()._targetId;\n  //setting current page is not idle\n  await setBrowserPageIdle(pageId, false);\n  if (thread !== pageId) {\n    await page.goto(\"https://chat.openai.com/chat\", {\n      waitUntil: \"domcontentloaded\",\n    });\n  }\n\n  let sendMessageButton = await page.$(\n    'button[class=\"absolute p-1 rounded-md text-gray-500 bottom-1.5 right-1 md:bottom-2.5 md:right-2 hover:bg-gray-100 dark:hover:text-gray-400 dark:hover:bg-gray-900 disabled:hover:bg-transparent dark:disabled:hover:bg-transparent\"]'\n  );\n\n  let textAreaElementHandle = await page.$(\"textarea\");\n\n  if (!textAreaElementHandle || !sendMessageButton) {\n    const pageType = await detectChatGptPage(page);\n    console.log({ pageType });\n    if (pageType === \"Login\") {\n      const authResponse = await chatGPTAuth(page);\n      // console.log({ authResponse });\n      await new Promise((r) => setTimeout(r, 5000));\n    }\n  }\n\n  // Wating and typing the prompt in the textarea field\n  await page.waitForSelector(\"textarea\", { timeout: 60000 });\n  await page.waitForSelector(\n    'button[class=\"absolute p-1 rounded-md text-gray-500 bottom-1.5 right-1 md:bottom-2.5 md:right-2 hover:bg-gray-100 dark:hover:text-gray-400 dark:hover:bg-gray-900 disabled:hover:bg-transparent dark:disabled:hover:bg-transparent\"]',\n    { timeout: 60000 }\n  );\n\n  sendMessageButton = await page.$(\n    'button[class=\"absolute p-1 rounded-md text-gray-500 bottom-1.5 right-1 md:bottom-2.5 md:right-2 hover:bg-gray-100 dark:hover:text-gray-400 dark:hover:bg-gray-900 disabled:hover:bg-transparent dark:disabled:hover:bg-transparent\"]'\n  );\n  textAreaElementHandle = await page.$(\"textarea\");\n\n  if (!textAreaElementHandle || !sendMessageButton) {\n    return {\n      isSuccessful: false,\n      message: \"Text area not found\",\n      result: {\n        thread: pageId,\n      },\n    };\n  }\n\n  console.log(\"inside of set value\");\n  await new Promise(async (resolve, reject) => {\n    console.log(\"inside promise\");\n    resolve(\n      await page.evaluate((evPrompt) => {\n        const promtTextAreaField = document.getElementsByTagName(\"textarea\");\n        console.log({ promtTextAreaField });\n        if (promtTextAreaField[0]) {\n          //@ts-ignore\n          promtTextAreaField[0].focus();\n          promtTextAreaField[0].click();\n          promtTextAreaField[0].value = evPrompt;\n          const button = document.querySelector(\n            'button[class=\"absolute p-1 rounded-md text-gray-500 bottom-1.5 right-1 md:bottom-2.5 md:right-2 hover:bg-gray-100 dark:hover:text-gray-400 dark:hover:bg-gray-900 disabled:hover:bg-transparent dark:disabled:hover:bg-transparent\"]'\n          );\n          //@ts-ignore\n          button?.click();\n          return true;\n        }\n        console.log(\"TEXT AREA NOT FOUND\");\n      }, prompt)\n    );\n  });\n\n  // Waiting for re-appear send message button that show current prompt is completed\n  await page.waitForSelector(\n    'button[class=\"absolute p-1 rounded-md text-gray-500 bottom-1.5 right-1 md:bottom-2.5 md:right-2 hover:bg-gray-100 dark:hover:text-gray-400 dark:hover:bg-gray-900 disabled:hover:bg-transparent dark:disabled:hover:bg-transparent\"]',\n    { timeout: 300000 }\n  );\n\n  console.log(\"ANSWER IS COMPLETED\");\n\n  // finding the last answer\n  const result: string | undefined = await new Promise(\n    async (resolve, reject) => {\n      resolve(\n        await page.evaluate(() => {\n          // document.title = \"bhagya 1234\";\n          const allAnswer = document.querySelectorAll(\n            'div[class=\"w-full border-b border-black/10 dark:border-gray-900/50 text-gray-800 dark:text-gray-100 group bg-gray-50 dark:bg-[#444654]\"]'\n          );\n          console.log({ allAnswer });\n          let lastAnswer = \"\";\n          if (allAnswer.length > 0) {\n            lastAnswer = allAnswer[allAnswer.length - 1].outerHTML;\n            console.log({ lastAnswer });\n          }\n          return lastAnswer;\n        })\n      );\n    }\n  );\n\n  if (!result) {\n    return { isSuccessful: false, message: \"Empty result found\" };\n  }\n\n  const finalResult = html2md(result);\n  //Setting page back to idle for next prompt\n  await setBrowserPageIdle(pageId, true);\n  return {\n    isSuccessful: true,\n    message: \"Successfully done\",\n    result: {\n      text: finalResult,\n      thread: pageId,\n    },\n  };\n}"
  },
  "browserLunchOptions": {
    "name": "browserLunchOptions",
    "slug": "TsVariable",
    "id": "pkklayjzigysnbfzobqvktiz",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "clickOnSpanTag": {
    "name": "clickOnSpanTag",
    "slug": "TsFunction",
    "id": "rtrdixtdflwjdeyfjvqkhmkr",
    "description": "it takes the current page and span text and its click on the text span",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  page: Page;\n  spanText: string;\n}) => {\n  const { page, spanText } = props;\n  // getting and clicking on the write something button to post the content\n  await page.waitForFunction(\n    `document.querySelector(\"body\").innerText.includes(\"${spanText}\")`\n  );\n  const targetSpanTag = await page.$x(`//span[contains(text(),\"${spanText}\")]`);\n  if (targetSpanTag[0]) {\n    //@ts-ignore\n    targetSpanTag[0]?.click();\n  } else {\n    return { success: false, message: `${spanText} tag not found.` };\n  }\n}"
  },
  "delay": {
    "name": "delay",
    "slug": "TsFunction",
    "id": "tjawhnkedaaeioszgxdmwhdk",
    "description": "Handling the new page by checking all browser tabs and if exist then return the existing one for reuse\nor create new one",
    "operationName": "puppeteer-utils",
    "rawText": " (ms: number) => new Promise((res) => setTimeout(res, ms))"
  },
  "facebookLogin": {
    "name": "facebookLogin",
    "slug": "TsFunction",
    "id": "tyuoiernhohfdkcymdglozkr",
    "description": "takes facebook credentials and login to facebook",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: FacebookLoginPropsType) => {\n  const { email, password, page } = props;\n  // type email\n  await typeInTheInputField({\n    page,\n    value: email,\n    selector: 'input[name=\"email\"]',\n  });\n  // type password\n  await typeInTheInputField({\n    page,\n    selector: 'input[name=\"pass\"]',\n    value: password,\n  });\n  // clicking the login button\n  await page.click(\"button[name=login]\");\n}"
  },
  "foundOrNotXpath": {
    "name": "foundOrNotXpath",
    "slug": "TsFunction",
    "id": "rdbxjixyowdaeshbnkqmsncx",
    "description": "Utility function that always returns a boolean instead of throwing an error.\nXPath version.",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  /** the page element from puppeteer got with browser.pages */\n  page: Page;\n  /** the xpath selector to search for */\n  selector: string;\n}): Promise<{\n  /** was the element found or not */\n  found: boolean;\n  /** if the element was found, it is returned */\n  element?: any;\n}> => {\n  const { page, selector } = props;\n  return new Promise(async (resolve, reject) => {\n    // Correct Method\n    await page\n      .waitForXPath(selector)\n      .then((element: any) => {\n        resolve({\n          found: true,\n          element,\n        });\n      })\n      .catch((e: any) => {\n        resolve({\n          found: false,\n        });\n      });\n  });\n}"
  },
  "foundOrNot": {
    "name": "foundOrNot",
    "slug": "TsFunction",
    "id": "olsztehheyndaypyytenshpq",
    "description": "Utility function that always returns a boolean instead of throwing an error.",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  /** the page element from puppeteer got with browser.pages */\n  page: Page;\n  /** the css selector to search for */\n  selector: string;\n  /** (optional) change default timeout to wait for selector */\n  timeoutMilliseconds?: number;\n}): Promise<boolean> => {\n  const { page, selector, timeoutMilliseconds } = props;\n  return new Promise(async (resolve, reject) => {\n    // Correct Method\n    await page\n      .waitForSelector(selector, { timeout: timeoutMilliseconds || 30 * 1000 })\n      .then(() => {\n        resolve(true);\n      })\n      .catch((e: any) => {\n        resolve(false);\n      });\n  });\n}"
  },
  "getBrowserPageById": {
    "name": "getBrowserPageById",
    "slug": "TsFunction",
    "id": "qdvoxqkoelebdmqhlqaalheb",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (browser: Browser, pageId: string) => {\n  const allPages = await browser.pages();\n  const targetPage = allPages.find(\n    //@ts-ignore\n    (p) => p.target()._targetId === pageId\n  );\n  await targetPage?.setBypassCSP(true);\n  return targetPage;\n}"
  },
  "getBrowserTabs": {
    "name": "getBrowserTabs",
    "slug": "TsFunction",
    "id": "zohhbsohdxfxuesywsjgmxrj",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (\n  browserInfo: BrowserSession\n): Promise<Page[]> => {\n  const browser = await puppeteer.connect({\n    browserWSEndpoint: browserInfo.browserSessionId,\n  });\n  let allTabs: Page[] = await browser.pages();\n  console.log({ allTabs });\n  return allTabs;\n}"
  },
  "getChromeExecutablePath": {
    "name": "getChromeExecutablePath",
    "slug": "TsFunction",
    "id": "luqkybdnsbxlfgfqnztxakvk",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " () => {\n  if (platform() === \"linux\") {\n    return \"/usr/bin/google-chrome-stable\";\n  } else {\n    return \"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\";\n    // return \"/usr/local/bin/chromium\";\n  }\n}"
  },
  "getConnectedBrowsers": {
    "name": "getConnectedBrowsers",
    "slug": "TsFunction",
    "id": "ivfgzblveubaqwgukvlhdper",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (): Promise<BrowserSession[]> => {\n  // const allBrowsers = getBrowserSession();\n  // console.log({ allBrowsers });\n  let connectedBrowser: BrowserSession[] = [];\n  // for await (let browser of allBrowsers) {\n  //   await puppeteer\n  //     .connect({\n  //       browserWSEndpoint: browser.browserSessionId,\n  //     })\n  //     .then((cb) => {\n  //       connectedBrowser.push(browser);\n  //     })\n  //     .catch((e) => {\n  //       console.error(\"Error in connecting browser\", e);\n  //       db.remove(\"BrowserSession\", (b) => b.id !== browser.id);\n  //     });\n  // }\n  // console.log({ connectedBrowser });\n  return connectedBrowser;\n}"
  },
  "getIdlePage": {
    "name": "getIdlePage",
    "slug": "TsFunction",
    "id": "ygcohgovqapchoxdhwnnzotk",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (\n  browser: Browser\n): Promise<Page | undefined> => {\n  // console.log(\"Get Idle Page Called\");\n  const idlePage = (await db.get(\"BrowserPage\")).find((p) => p.isIdle);\n  console.log({ idlePage });\n\n  const allPages = await browser.pages();\n  const targetPage = allPages.find(\n    //@ts-ignore\n    (p) => p.target()._targetId === idlePage?.pageId\n  );\n\n  return targetPage;\n}"
  },
  "getNewPage": {
    "name": "getNewPage",
    "slug": "TsFunction",
    "id": "confqzbbehmjpwoimahnfadd",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (\n  browser: Browser\n): Promise<Page | undefined> => {\n  const allPage = await browser.pages();\n  const allPageTitle = await Promise.all(allPage.map(async (p) => p.title()));\n  let indexOfIdlePage = allPageTitle.indexOf(\"\");\n  if (indexOfIdlePage === -1) {\n    const idlePage = await getIdlePage(browser);\n    return idlePage;\n  }\n  return allPage[indexOfIdlePage];\n}"
  },
  "gmailLogin": {
    "name": "gmailLogin",
    "slug": "TsFunction",
    "id": "wuhzloypjzytxatnqejsnlxt",
    "description": "Helps to login into gmail account",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: GmailLoginPropsType) => {\n  // waiting for email input and set email value\n  const { page, email, password } = props;\n  // setting email address\n  await setInputValue({\n    page,\n    inputValue: email,\n    selector: \"input[type=email]\",\n  });\n\n  // clicking on the next button after email input\n  await clickOnSpanTag({ page, spanText: \"Next\" });\n  await page.setBypassCSP(true);\n  // clicking on the next button after password input\n\n  await page.waitForFunction(\n    `document.querySelector(\"body\").innerText.includes(\"Next\")`\n  );\n\n  // waiting for the password field to load and set the password\n  await setInputValue({\n    page,\n    inputValue: password,\n    selector: \"input[type=password]\",\n  });\n\n  // clicking next button after password entered\n  await clickOnSpanTag({ page, spanText: \"Next\" });\n}"
  },
  "isCaptchaExist": {
    "name": "isCaptchaExist",
    "slug": "TsFunction",
    "id": "riyprecezfrxbejrioccsifw",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (\n  page: Page\n): Promise<{ captchas: CaptchaInfo[] }> => {\n  try {\n    let recaptchaResult = await page.findRecaptchas();\n    const { captchas } = recaptchaResult;\n    return { captchas };\n  } catch (e: Error | any) {\n    console.log(\"isCaptchaExist Error\", e?.message);\n    return { captchas: [] };\n  }\n}"
  },
  "logConsoleIfDebug": {
    "name": "logConsoleIfDebug",
    "slug": "TsFunction",
    "id": "vtrljxmusdmfnirunspgnldz",
    "description": "Utility function to log console only if a Debug flag is set.\nIf the flag is not set, doesn't print anything.",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  message: string;\n  debug: boolean;\n}) => {\n  const { debug, message } = props;\n  if (debug) {\n    console.log(message);\n  }\n}"
  },
  "openMultiTabs": {
    "name": "openMultiTabs",
    "slug": "TsFunction",
    "id": "yeviknkzcmbpirorjlpwahog",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: OpenMultiTabProps) => {\n  const { noOfTabs, tabUrl, browser } = props;\n  const allTabs = [];\n  for (let i = 0; i < noOfTabs; i++) {\n    allTabs.push(browser.newPage());\n  }\n  const allPages = await Promise.all(allTabs);\n\n  const allPageIds: string[] = await Promise.all(\n    //@ts-ignore\n    allPages.map((p) => p.target()._targetId)\n  );\n  //@ts-ignore\n  const allPageIdsCreations: Creation<BrowserPage[]> = allPageIds.map(\n    (pid) => ({ pageId: pid, isIdle: true })\n  );\n  await db.upsert(\"BrowserPage\", allPageIdsCreations);\n}"
  },
  "openNewBrowserOnChildProcess": {
    "name": "openNewBrowserOnChildProcess",
    "slug": "TsFunction",
    "id": "crolhkbittejhwbnlpkdrhur",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async () => {\n  const operationFolderPath = await getOperationPath(\"puppeteer-utils\");\n  console.log(\"Child Process called\", operationFolderPath);\n  const browserSession = await db.get(\"BrowserSession\");\n  if (browserSession.length === 0) {\n    const newProcess = fork(\n      `${operationFolderPath}/build/cli/runBrowser.cli.js`,\n      {\n        detached: true,\n        // stdio: \"ignore\",\n      }\n    );\n    newProcess.unref();\n  }\n}"
  },
  "openNewBrowser": {
    "name": "openNewBrowser",
    "slug": "TsFunction",
    "id": "ttvdcaiheboeeufcgghvtmid",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (): Promise<Browser | undefined> => {\n  console.log(\"OPEN BROWSER CALLED\");\n  const existingBrowserSession = await db.get(\"BrowserSession\");\n  if (existingBrowserSession[0]) {\n    const { browserSessionId } = existingBrowserSession[0];\n    try {\n      puppeteer.use(\n        RecaptchaPlugin({\n          provider: {\n            id: \"2captcha\",\n            token: \"243f9da05482cc8e9b76203a184943c9\", // REPLACE THIS WITH YOUR OWN 2CAPTCHA API KEY âš¡\n          },\n          visualFeedback: true, // colorize reCAPTCHAs (violet = detected, green = solved)\n        })\n      );\n      const existingBrowser = await puppeteer.connect({\n        browserWSEndpoint: browserSessionId,\n      });\n      const isBrowserConnected = existingBrowser.isConnected();\n      console.log({ isBrowserConnected });\n      return existingBrowser;\n    } catch (e: Error | any) {\n      console.log(\"Error in open browser\", e);\n      await db.clear(\"BrowserSession\");\n      await openNewBrowserOnChildProcess();\n      return;\n    }\n  } else {\n    await db.clear(\"BrowserSession\");\n    await openNewBrowserOnChildProcess();\n    return;\n  }\n}"
  },
  "openPage": {
    "name": "openPage",
    "slug": "TsFunction",
    "id": "efpfpyfuuzozibfempplcrgu",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (pageId?: string): Promise<Page | undefined> => {\n  const browser = await openNewBrowser();\n  if (!browser) {\n    console.log(\"BROSER NOT FOUND\");\n    await delay(5000);\n    console.log(\"TRY AGAIN\");\n    const browser = await openNewBrowser();\n    if (!browser) return;\n    if (browser) {\n      if (pageId) {\n        return getBrowserPageById(browser, pageId);\n      }\n\n      const page = await getNewPage(browser);\n      await page?.setBypassCSP(true);\n      return page;\n    }\n    return;\n  }\n\n  if (pageId) {\n    return getBrowserPageById(browser, pageId);\n  }\n\n  const page = await getNewPage(browser);\n  await page?.setBypassCSP(true);\n  return page;\n}"
  },
  "racePromises": {
    "name": "racePromises",
    "slug": "TsFunction",
    "id": "txqulrbrtpurraanfynmpqvm",
    "description": "Typescript",
    "operationName": "puppeteer-utils",
    "rawText": " async (\n  promises: Promise<any>[]\n): Promise<number> => {\n  const indexedPromises: Array<Promise<number>> = promises.map(\n    (promise, index) =>\n      new Promise<number>((resolve) =>\n        promise\n          .then(() => resolve(index))\n          .catch((err) => {\n            console.log(\"RACE PROMISE INDEX \" + index + \" TIMED OUT !!!\");\n          })\n      )\n  );\n  return Promise.race(indexedPromises);\n}"
  },
  "retryClickAndWaitSelector": {
    "name": "retryClickAndWaitSelector",
    "slug": "TsFunction",
    "id": "dehysgonkntbowxsfwnvfvpi",
    "description": "Utility function that loops waiting a second and checking\nif selector showed up. Fails if it takes more than 30 seconds.\n\nthis is good to use instead of page.waitForTimeout + page.waitForSelector",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  /** the page element from puppeteer got with browser.pages */\n  page: any;\n  /** the css selector to search for */\n  selector: string | string[];\n  /** the options */\n  selectorOptions?: any;\n  /** the css selector to click after */\n  selectorToClick: string;\n  /**  maxium time to retry. defaults to 30 seconds. */\n  maxTime: number;\n}): Promise<{ success: boolean; found?: any }> => {\n  const {\n    page,\n    selector,\n    selectorOptions,\n    selectorToClick,\n    maxTime = 30000,\n  } = props;\n  return new Promise(async (resolve, reject) => {\n    let totalTime = 0;\n    while (totalTime < maxTime) {\n      try {\n        const found = await page.waitForSelector(selector, {\n          ...selectorOptions,\n          timeout: 1000,\n        });\n        resolve({ success: true, found });\n        return;\n      } catch (err) {\n        try {\n          await page.click(selectorToClick);\n        } catch (insideErr) {\n          //console.log('inside error ! continuing...');\n        }\n\n        totalTime += 1000;\n        console.log(\"retrying...\");\n      }\n    }\n    resolve({ success: false });\n  });\n}"
  },
  "retryWaitSelector": {
    "name": "retryWaitSelector",
    "slug": "TsFunction",
    "id": "owygqvkerxnktevlenkxwjwz",
    "description": "Utility function that loops waiting a second and checking\nif selector showed up. Fails if it takes more than 30 seconds.\n\nthis is good to use instead of page.waitForTimeout + page.waitForSelector",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  /** the page element from puppeteer got with browser.pages */\n  page: Page;\n  /** the css selector to search for */\n  selector: string;\n  /**  maxium time to retry. defaults to 30 seconds. */\n  maxTime: number;\n}): Promise<{ success: boolean; found?: any }> => {\n  const { page, selector, maxTime = 30000 } = props;\n  return new Promise(async (resolve, reject) => {\n    let totalTime = 0;\n    while (totalTime < maxTime) {\n      try {\n        const found = await page.waitForSelector(selector, { timeout: 1000 });\n        resolve({ success: true, found });\n      } catch (err) {\n        totalTime += 1000;\n        console.log(\"retrying... \" + selector + \" / totalTime \" + totalTime);\n      }\n    }\n    resolve({ success: false });\n  });\n}"
  },
  "runBrowser": {
    "name": "runBrowser",
    "slug": "TsFunction",
    "id": "shgfjwndewkmjqejgiabztha",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (): Promise<Browser> => {\n  console.log(\"Run browser called\");\n  puppeteer.use(\n    RecaptchaPlugin({\n      provider: {\n        id: \"2captcha\",\n        token: \"243f9da05482cc8e9b76203a184943c9\", // REPLACE THIS WITH YOUR OWN 2CAPTCHA API KEY âš¡\n      },\n      visualFeedback: true, // colorize reCAPTCHAs (violet = detected, green = solved)\n    })\n  );\n\n  puppeteer.use(StealthPlugin());\n  const browser = await puppeteer.launch(browserLunchOptions);\n  const browserWSEndpoint = browser.wsEndpoint();\n  const browserSession: Creation<BrowserSession> = {\n    browserName: \"browser\",\n    browserSessionId: browserWSEndpoint,\n  };\n  console.log(\"browserId\", browser.wsEndpoint());\n  // Remove all the old session\n  await db.clear(\"BrowserSession\");\n  await db.clear(\"BrowserPage\");\n  await db.upsert(\"BrowserSession\", browserSession);\n  openMultiTabs({\n    noOfTabs: 10,\n    tabUrl: \"https://chat.openai.com/chat\",\n    browser,\n  });\n  return browser;\n}"
  },
  "setBrowserPageIdle": {
    "name": "setBrowserPageIdle",
    "slug": "TsFunction",
    "id": "hyjuvamtpxrkuzhcuwmijzwu",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (pageId: string, status: boolean) => {\n  await db.update(\n    \"BrowserPage\",\n    (c) => c.pageId === pageId,\n    (content) => ({ ...content, isIdle: status })\n  );\n}"
  },
  "setInnerHtml": {
    "name": "setInnerHtml",
    "slug": "TsFunction",
    "id": "ovwkztwionmtaqtcgrzfetsy",
    "description": "Help to set the html element on the provided selector",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  page: Page;\n  selector: string;\n  value: string;\n}) => {\n  const { page, selector, value } = props;\n  console.log(\"select in fnc\", selector, value);\n  await page.evaluate(\n    ({ value, selector }) => {\n      const h3Element: ElementType | null = document.querySelector(\n        `${selector}`\n      );\n      if (h3Element) {\n        h3Element.click?.();\n        h3Element.focus?.();\n        h3Element.innerHTML = value;\n      }\n    },\n    { value, selector }\n  );\n}"
  },
  "setInputValue": {
    "name": "setInputValue",
    "slug": "TsFunction",
    "id": "tdisstkwwjpukpypoqishezr",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (params: SetInputValueType) => {\n  const { page, selector, inputValue } = params;\n  await page.waitForSelector(selector);\n  await page.$eval(\n    selector,\n    (elem: ElementType, args: any) => {\n      elem.value = args.value;\n    },\n    { value: inputValue }\n  );\n}"
  },
  "solveReptcha": {
    "name": "solveReptcha",
    "slug": "TsFunction",
    "id": "snqeektccpzmdxhurcsytcbr",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (\n  page: Page\n): Promise<SolveRecaptchasResult> => {\n  const solveRecaptchaResult = await page?.solveRecaptchas();\n  return solveRecaptchaResult;\n}"
  },
  "trueClick": {
    "name": "trueClick",
    "slug": "TsFunction",
    "id": "cyqzuvbzqcrjxncikkaneses",
    "description": "Utility function to call the element onclick event directly.\nSuccess when clicking is improved over puppeteer page.click('selector')",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  /** the page element from puppeteer got with browser.pages */\n  page: Page;\n  /** the css selector to click */\n  selector: string;\n}): Promise<{ success: boolean }> => {\n  try {\n    const { page, selector } = props;\n    await page.evaluate((sendButtonSelector: string) => {\n      let a = document.querySelector(sendButtonSelector);\n      (a as HTMLElement).click?.();\n    }, selector);\n    return {\n      success: true,\n    };\n  } catch (err) {\n    return {\n      success: false,\n    };\n  }\n}"
  },
  "twitterLogin": {
    "name": "twitterLogin",
    "slug": "TsFunction",
    "id": "ryspmjmwymygsmotryfquzib",
    "description": "Method that help to login into twitter",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  page: Page;\n  email: string;\n  phoneNo: string;\n  password: string;\n}) => {\n  const { page, email, phoneNo, password } = props;\n  await page.goto(\"https://twitter.com/login\");\n  // Adding listener for console\n  page.on(\"console\", (message) => console.log(`${message.text()}`));\n  // wait for username input field to appear\n  await typeInTheInputField({\n    page,\n    selector: 'input[autocomplete=\"username\"]',\n    value: phoneNo,\n  });\n\n  // clicking next button\n  await page.click(\n    'div[class=\"css-18t94o4 css-1dbjc4n r-sdzlij r-1phboty r-rs99b7 r-ywje51 r-usiww2 r-2yi16 r-1qi8awa r-1ny4l3l r-ymttw5 r-o7ynqc r-6416eg r-lrvibr r-13qz1uu\"]'\n  );\n\n  // wait for the password field to appear\n  await typeInTheInputField({\n    page,\n    selector: 'input[autocomplete=\"current-password\"]',\n    value: password,\n  });\n  // waiting and clicking on the login button\n  await page.waitForSelector(\n    'div[class=\"css-901oao r-1awozwy r-6koalj r-18u37iz r-16y2uox r-37j5jr r-a023e6 r-b88u0q r-1777fci r-rjixqe r-bcqeeo r-q4m81j r-qvutc0\"]'\n  );\n  await page.click(\n    'div[class=\"css-901oao r-1awozwy r-6koalj r-18u37iz r-16y2uox r-37j5jr r-a023e6 r-b88u0q r-1777fci r-rjixqe r-bcqeeo r-q4m81j r-qvutc0\"]'\n  );\n}"
  },
  "typeInTheInputField": {
    "name": "typeInTheInputField",
    "slug": "TsFunction",
    "id": "wozxlvfnbxybifnxpikkmiiz",
    "description": "Help to type in the field in given selector by setting value",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  page: Page;\n  selector: string;\n  value: string;\n}) => {\n  const { page, selector, value } = props;\n  // wait for selector\n  await page.waitForSelector(selector, { timeout: 30000 });\n  // click, focus and enter the value\n  await page.click(selector);\n  await page.focus(selector);\n  // throw 'test message';\n  await page.keyboard.type(value);\n}"
  },
  "typeOnTheTargetWithXpathSelector": {
    "name": "typeOnTheTargetWithXpathSelector",
    "slug": "TsFunction",
    "id": "ndjmhvtibprusvfbjgdzcsmy",
    "description": "Help to type in the input field using x-path",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  page: Page;\n  selector: string;\n  text: string;\n}) => {\n  const { page, selector, text } = props;\n  const targetedElement = await page.$x(selector);\n\n  if (targetedElement[0]) {\n    await targetedElement[0].focus();\n    //@ts-ignore\n    await targetedElement[0].click();\n    console.log(\n      \"selector find and click\",\n      await (await targetedElement[0].getProperty(\"role\")).jsonValue()\n    );\n  }\n  console.log(\"Aout to type\", text);\n  await page.keyboard.type(text);\n}"
  },
  "checkAndGetSlackFileUrl": {
    "name": "checkAndGetSlackFileUrl",
    "slug": "TsFunction",
    "id": "jvewviwfhobjnqfwlxsqjvdj",
    "description": "It extract the file url from the given slack chat element",
    "operationName": "slack-controller",
    "rawText": " (el: Element): string => {\n  const fileElement = el.querySelectorAll(\".c-files_container\")[0];\n\n  let fileUrl = \"\";\n  if (fileElement) {\n    const videoElem = fileElement.querySelectorAll(\n      \".p-video_message_file__poster\"\n    )[0];\n    if (videoElem) {\n      const videofileUrl = videoElem.getAttribute(\"style\") || \"\";\n      if (videofileUrl) {\n        fileUrl = videofileUrl.split('\"')[1];\n      }\n    }\n    const imageElem = fileElement.querySelectorAll(\n      'a[data-qa=\"message_file_image_thumbnail\"]'\n    )[0];\n    if (imageElem) {\n      fileUrl = imageElem.getAttribute(\"href\") || \"\";\n    }\n  }\n  return fileUrl;\n}"
  },
  "elementExists": {
    "name": "elementExists",
    "slug": "TsFunction",
    "id": "qoextaxysrchyvxkybbhcrpf",
    "description": "Check either element is exist or not based on selector",
    "operationName": "slack-controller",
    "rawText": " async (selector: string, page: Page) => {\n  const element = await page.$$(selector);\n  if (!element[0] || (element[0] && JSON.stringify(element[0]) != \"{}\")) {\n    return false;\n  }\n  return true;\n}"
  },
  "getAllMessages": {
    "name": "getAllMessages",
    "slug": "TsFunction",
    "id": "fccmdocxdlebqtnqvanghpyt",
    "description": "Channels can be posts, or persons, or channels\nChannels neeeds have platform Like, slack, facebook,\n\ntype should be return and create a package and return statement should be the same for all the packages\n\nAdd from date(default: Only 100 messages ) - to date( default: today) unix timestamp in ms\n\nGet latest messages",
    "operationName": "slack-controller",
    "rawText": " async (props: {\n  workspace: string;\n  email: string;\n  password: string;\n  channel: string;\n}) => {\n  try {\n    const { workspace, channel, email, password } = props;\n    const { page, message } = await slackLogin({\n      mode: \"gmail\",\n      credentials: {\n        email,\n        password,\n      },\n    });\n    if (!page) {\n      return { success: false, message };\n    }\n    await selectSlackWorkspace({ page, workspace });\n\n    /**\n     * Clicks if it's channel messages\n     */\n\n    await selectSlackChannel({ page, channel });\n    /**\n     * Get's messages\n     */\n    await page.waitForSelector('div[data-qa=\"slack_kit_scrollbar\"]', {\n      timeout: 10000,\n    });\n    await page.waitForTimeout(5000);\n\n    await scrollToTop({\n      page,\n      targetSelector: 'div[data-qa=\"slack_kit_scrollbar\"]',\n    });\n\n    return {\n      success: true,\n      message: \"Latest message get successfull\",\n      data: [],\n    };\n  } catch (e: any | Error) {\n    return { success: false, message: e.message };\n  }\n}"
  },
  "getLatestMessages": {
    "name": "getLatestMessages",
    "slug": "TsFunction",
    "id": "akipkzgjyrmlycpbwrddeelq",
    "description": "Add from date(default: Only 100 messages ) - to date( default: today) unix timestamp in ms\n\nGet latest messages",
    "operationName": "slack-controller",
    "rawText": " async (props: {\n  workspace: string;\n  email: string;\n  password: string;\n  channel: string;\n}) => {\n  try {\n    const { workspace, channel, email, password } = props;\n    const { page, message } = await slackLogin({\n      mode: \"gmail\",\n      credentials: {\n        email,\n        password,\n      },\n    });\n    if (!page) {\n      return { success: false, message };\n    }\n    await selectSlackWorkspace({ page, workspace });\n\n    /**\n     * Clicks if it's channel messages\n     */\n\n    await selectSlackChannel({ page, channel });\n    /**\n     * Get's messages\n     */\n    await page.waitForSelector('div[data-qa=\"message_content\"]', {\n      timeout: 10000,\n    });\n    await page.waitForTimeout(5000);\n    const messages = await page.$$eval(\n      'div[data-qa=\"message_content\"]',\n      (elements) => {\n        let messageObject: MessageType = {\n          sender: \"\",\n          messages: [],\n        };\n        const messages: MessageType[] = [];\n        elements.map((el) => {\n          const senderElement = el.querySelectorAll(\n            'span[data-qa=\"message_sender\"]'\n          )[0];\n          const messageElement = el.querySelectorAll(\".p-rich_text_section\")[0];\n          const fileElement = el.querySelectorAll(\".c-files_container\")[0];\n          const codeViewElement = el.querySelectorAll(\".c-mrkdwn__pre\")[0];\n          // Check and get file name\n          let fileUrl = \"\";\n          if (fileElement) {\n            const videoElem = fileElement.querySelectorAll(\n              \".p-video_message_file__poster\"\n            )[0];\n            if (videoElem) {\n              const videofileUrl = videoElem.getAttribute(\"style\") || \"\";\n              if (videofileUrl) {\n                fileUrl = videofileUrl.split('\"')[1];\n              }\n            }\n            const imageElem = fileElement.querySelectorAll(\n              'a[data-qa=\"message_file_image_thumbnail\"]'\n            )[0];\n            if (imageElem) {\n              fileUrl = imageElem.getAttribute(\"href\") || \"\";\n            }\n          }\n          const senderInfo = senderElement?.textContent;\n          const messageText = messageElement?.textContent;\n          const codeViewMessage = codeViewElement?.textContent;\n          if (senderInfo) {\n            messages.push(messageObject);\n            messageObject = {\n              sender: senderInfo,\n              messages: [messageText || \"\", codeViewMessage || \"\", fileUrl],\n            };\n          } else {\n            messageObject = {\n              messages: [\n                ...messageObject.messages,\n                messageText || \"\",\n                fileUrl || \"\",\n                codeViewMessage || \"\",\n              ],\n            };\n          }\n        });\n        if (messageObject.messages.length > 0) {\n          messages.push(messageObject);\n        }\n        return messages;\n      }\n    );\n\n    return {\n      success: true,\n      message: \"Latest message get successfull\",\n      data: messages,\n    };\n  } catch (e: any | Error) {\n    return { success: false, message: e.message };\n  }\n}"
  },
  "getSlackChannelMemberList": {
    "name": "getSlackChannelMemberList",
    "slug": "TsFunction",
    "id": "wagwpktjsqucvsdvuzdjycsg",
    "description": "This method helps to scrap the all members of the slack channel",
    "operationName": "slack-controller",
    "rawText": " async (\n  props: GetSlackChannelMemberParamsType\n): Promise<{\n  success: boolean;\n  message: string;\n  data?: string[];\n}> => {\n  const { email, password, workspace, channelName } = props;\n  const { page, success, message } = await slackLogin({\n    credentials: { email, password },\n    mode: \"gmail\",\n  });\n  if (!page) {\n    return { success: false, message: \"Page not found\" };\n  }\n\n  // Opening the related workspace\n  await selectSlackWorkspace({ page, workspace });\n\n  // Open related channel\n  await selectSlackChannel({ page, channel: channelName });\n\n  // clickin on the channel name dropedown menu\n  await page.waitForSelector('button[data-qa=\"channel_name_button\"]');\n  await page.$eval('button[data-qa=\"channel_name_button\"]', (menu) => {\n    console.log(\"MENU==>\", { menu });\n    //@ts-ignore\n    menu.click();\n  });\n\n  await page.waitForSelector('button[data-qa=\"channel_details_members_tab\"]');\n  console.log(\"clicking on the \");\n  await page.$eval(\n    'button[data-qa=\"channel_details_members_tab\"]',\n    (menuItem) => {\n      //@ts-ignore\n      menuItem.click();\n    }\n  );\n\n  //class=\"c-scrollbar__hider\"\n  // const interval = setInterval(async () => {\n  await page.waitForSelector('div[class=\"c-virtual_list__scroll_container\"]');\n  const allElements = await page.$$(\n    'div[class=\"c-virtual_list__scroll_container\"]'\n  );\n  // console.log({ allElements });\n  const targetElement = allElements[1];\n  if (targetElement) {\n    await targetElement.focus(\n      //@ts-ignore\n      'div[class=\"c-virtual_list__scroll_container\"]'\n    );\n    await page.mouse.move(300, 300);\n    // await page.mouse.wheel({ deltaY: 300 });\n    await page.waitForSelector('strong[data-qa=\"member_name\"]');\n    const allNamesElems: any[] = [];\n    const allNameList: any[] = await new Promise(async (resolve, reject) => {\n      resolve(\n        page.$$eval('strong[data-qa=\"member_name\"]', (nameElements) => {\n          console.log(\"NAMES\", { nameElements });\n          let nameList: any[] = [];\n          nameElements.forEach((elem) => {\n            //@ts-ignore\n            const name = elem.innerText;\n            const isExist = nameList.find((obj) => obj.name === name);\n            if (!isExist) {\n              console.log({ name });\n              //@ts-ignore\n              nameList.push({ element: elem, name: name });\n            }\n          });\n          console.log(\"NAME LIST F\", nameList);\n          const getAllMemberUrl = new Promise(async (resolve, reject) => {\n            console.log(\"NAME PROMISE\", nameList);\n            for await (let elem of nameList) {\n              console.log(\"NAME\", { elem });\n              elem.click();\n            }\n          });\n          return nameList;\n        })\n      );\n    });\n    console.log({ allNameList });\n    // clearInterval(interval);\n  }\n  // }, 2000);\n\n  // await page.mouse.move(300, 300);\n  // await scrollToTop({\n  //   page,\n  //   targetSelector: 'div[class=\"c-scrollbar__hider\"]',\n  // });\n\n  // await page.click('div[class=\"p-ia_details_popover__members_list\"]');\n  console.log();\n  return {\n    success: true,\n    message: \"Getting channel people list successfull\",\n    data: [],\n  };\n}"
  },
  "getSlackChannels": {
    "name": "getSlackChannels",
    "slug": "TsFunction",
    "id": "ygripyemonummhcjnncpcpvn",
    "description": "Get's all the slack channels from workspace",
    "operationName": "slack-controller",
    "rawText": " async (props: {\n  workspace: string;\n  email: string;\n  password: string;\n}): Promise<{\n  page?: Page;\n  success: boolean;\n  message: string;\n  data?: { channels: string[]; people: string[] };\n}> => {\n  try {\n    const { workspace, email, password } = props;\n    const { page, success } = await slackLogin({\n      mode: \"gmail\",\n      credentials: {\n        email,\n        password,\n      },\n    });\n    if (!page || !success) {\n      return { success: false, message: \"Login faild\" };\n    }\n\n    await page.waitForTimeout(5000);\n    if (page.url() !== WORKSPACE_URL) {\n      await page.goto(WORKSPACE_URL);\n    }\n\n    /**\n     * Clicks the workspace\n     */\n    await selectSlackWorkspace({ page, workspace });\n    /**\n     * Go to the channel/direct message\n     */\n    const allChannels = await page.$$eval(\n      'div[aria-label=\"Channels and direct messages\"] > div > div > span',\n      (elements) => {\n        const channels: string[] = [];\n        elements.map((el) => {\n          if (\n            el.textContent &&\n            el.textContent !== \"Threads\" &&\n            el.textContent !== \"More\"\n          ) {\n            channels.push(el.textContent);\n          }\n        });\n        return channels;\n      }\n    );\n\n    /**\n     * Get all channels\n     */\n\n    const allPeople = await page.$$eval(\n      'div[data-qa=\"channel_item_container\"] > div > span',\n      (elements) => {\n        const people: string[] = [];\n        elements.map((el) => {\n          if (el.children.length === 1 && el.children[0].textContent) {\n            people.push(el.children[0].textContent);\n          }\n        });\n        return people;\n      }\n    );\n\n    return {\n      page,\n      success: true,\n      message: \"get all channel succesfull\",\n      data: {\n        channels: allChannels,\n        people: allPeople,\n      },\n    };\n  } catch (e: any | Error) {\n    return { success: false, message: e.message };\n  }\n}"
  },
  "getSlackMessageFrom": {
    "name": "getSlackMessageFrom",
    "slug": "TsFunction",
    "id": "pykpgnbretwrpzcoadjfsxkb",
    "description": "Get's slack messages from channels/direct message",
    "operationName": "slack-controller",
    "rawText": " async (props: {\n  workspace: string;\n  page: Page;\n  channel: string;\n}) => {\n  const { workspace, page, channel } = props;\n  await page.waitForTimeout(5000);\n  if (page.url() !== WORKSPACE_URL) {\n    await page.goto(WORKSPACE_URL);\n  }\n\n  /**\n   * Clicks the workspace requested\n   */\n  await page.$$eval(\n    \".p-workspace_info__title\",\n    (elements, workspace) => {\n      elements.map((el) => {\n        console.log(\n          el.textContent,\n          \"workspaces from messages\",\n          el.textContent?.indexOf(workspace as string)\n        );\n        if (\n          el.textContent &&\n          el.textContent?.indexOf(workspace as string) > -1\n        ) {\n          const workspaceElement = el as HTMLElement;\n          const parentElement =\n            workspaceElement.parentElement?.parentElement?.parentElement;\n\n          parentElement?.setAttribute(\"target\", \"_self\");\n          parentElement?.click();\n        }\n      });\n    },\n    workspace\n  );\n\n  await page.waitForTimeout(15000);\n\n  /**\n   * Finds the channel name and clicks\n   */\n  await page.$$eval(\n    'div[aria-label=\"Channels and direct messages\"] > div > div > span',\n    (elements, channel) => {\n      elements.map((el) => {\n        if (el.textContent && el.textContent.indexOf(channel as string) > -1) {\n          const channel = el as HTMLElement;\n          channel.click();\n        }\n      });\n    },\n    channel\n  );\n\n  /**\n   * Finds the person name and clicks\n   */\n\n  await page.$$eval(\n    'div[data-qa=\"channel_item_container\"] > div > span',\n    (elements, channel) => {\n      elements.map((el) => {\n        if (\n          el.children.length === 1 &&\n          el.children[0].textContent &&\n          el.children[0].textContent?.indexOf(channel as string) > -1\n        ) {\n          const person = el as HTMLElement;\n          person.click();\n        }\n      });\n    },\n    channel\n  );\n\n  /**\n   * Get all new message sender's name (channels/person )\n   */\n  const messageFrom = await page.$$eval(\n    \".p-channel_sidebar__channel--unread\",\n    (elements) => {\n      console.log(elements, \"elements\");\n      const messageArray: string[] = [];\n      elements.map((el) => {\n        const unreadElement = el as HTMLElement;\n        const titleElement = unreadElement.querySelector(\n          \".p-channel_sidebar__name\"\n        );\n        if (titleElement?.textContent)\n          messageArray.push(titleElement?.textContent);\n      });\n\n      return messageArray;\n    }\n  );\n\n  return {\n    success: true,\n    data: messageFrom,\n    message: \"Clicked\",\n  };\n}"
  },
  "getSlackWorkspaces": {
    "name": "getSlackWorkspaces",
    "slug": "TsFunction",
    "id": "vouuamqzkexvasvulaozuxcc",
    "description": "",
    "operationName": "slack-controller",
    "rawText": " async (\n  props: GetSlackWorkSpaceParamsTypes\n) => {\n  try {\n    const { email, password } = props;\n    const { page, success } = await slackLogin({\n      mode: \"gmail\",\n      credentials: {\n        email,\n        password,\n      },\n    });\n\n    if (!page) {\n      return { success: false, message: \"Login faild\" };\n    }\n\n    // await page.waitForTimeout(15000);\n    await page.waitForSelector(\".p-expanding_workspace_list__workspaces\", {\n      timeout: 10000,\n    });\n    /**\n     * Checks if list is present\n     */\n    const workspaceExist = await elementExists(\n      \".p-expanding_workspace_list__workspaces\",\n      page\n    );\n\n    /**\n     * Returns the name of all workspaces available\n     */\n    if (workspaceExist) {\n      const workspace = await page.$$eval(\n        \".p-workspace_info__title\",\n        (elements) => elements.map((el) => el.textContent)\n      );\n\n      return {\n        page,\n        data: workspace,\n        response: \"All workspaces\",\n        success: true,\n      };\n    } else {\n      return {\n        sucess: false,\n        message: \"Something is wrong. Error while fetching workspaces\",\n      };\n    }\n  } catch (e: any | Error) {\n    return { success: false, message: e.message };\n  }\n}"
  },
  "launchOptions": {
    "name": "launchOptions",
    "slug": "TsVariable",
    "id": "bjsdiplwrscyzwfjtqoymyct",
    "description": "Login Slack\nSigns in with gmail or email and returns {status}",
    "operationName": "slack-controller"
  },
  "scrapeSlackMessage": {
    "name": "scrapeSlackMessage",
    "slug": "TsFunction",
    "id": "twvmxyvcvjyeojppbtnewnua",
    "description": "scraping the text, image url and video postar from element",
    "operationName": "slack-controller",
    "rawText": " () => {\n  const elements = document.querySelectorAll('div[data-qa=\"message_content\"]');\n  let messageObject: MessageType = {\n    sender: \"\",\n    messages: [],\n  };\n  const messages: MessageType[] = [];\n  elements.forEach((el) => {\n    const senderElement = el.querySelectorAll(\n      'span[data-qa=\"message_sender\"]'\n    )[0];\n    const messageElement = el.querySelectorAll(\".p-rich_text_section\")[0];\n    const fileElement = el.querySelectorAll(\".c-files_container\")[0];\n    const codeViewElement = el.querySelectorAll(\".c-mrkdwn__pre\")[0];\n    // Check and get file name\n    let fileUrl = \"\";\n    if (fileElement) {\n      const videoElem = fileElement.querySelectorAll(\n        \".p-video_message_file__poster\"\n      )[0];\n      if (videoElem) {\n        const videofileUrl = videoElem.getAttribute(\"style\") || \"\";\n        if (videofileUrl) {\n          fileUrl = videofileUrl.split('\"')[1];\n        }\n      }\n      const imageElem = fileElement.querySelectorAll(\n        'a[data-qa=\"message_file_image_thumbnail\"]'\n      )[0];\n      if (imageElem) {\n        fileUrl = imageElem.getAttribute(\"href\") || \"\";\n      }\n    }\n    const senderInfo = senderElement?.textContent;\n    const messageText = messageElement?.textContent;\n    const codeViewMessage = codeViewElement?.textContent;\n    if (senderInfo) {\n      messages.push(messageObject);\n      messageObject = {\n        sender: senderInfo,\n        messages: [messageText || \"\", codeViewMessage || \"\", fileUrl],\n      };\n    } else {\n      messageObject = {\n        messages: [\n          ...messageObject.messages,\n          messageText || \"\",\n          fileUrl || \"\",\n          codeViewMessage || \"\",\n        ],\n      };\n    }\n  });\n}"
  },
  "scrollToTop": {
    "name": "scrollToTop",
    "slug": "TsFunction",
    "id": "hwnaozmlgusldmdrhhllesgp",
    "description": "This operation able to scroll to top and down on targetSelector",
    "operationName": "slack-controller",
    "rawText": " async (props: {\n  page: Page;\n  targetSelector: string;\n}) => {\n  const { page, targetSelector } = props;\n  await page.waitForSelector(targetSelector);\n  // await page.exposeFunction(\"scrapeMessage\", scrapeMessage);\n  await page.evaluate((selector) => {\n    let prevScrollHeightBottom = 0;\n    let prevScrollHeightTop = 0;\n    const scrollableSectionAll = document.querySelectorAll(selector);\n    console.log({ scrollableSectionAll });\n    const scrollableSection = scrollableSectionAll[3];\n    if (scrollableSection) {\n      let interVervalTop = setInterval(() => {\n        if (prevScrollHeightBottom < scrollableSection.scrollHeight) {\n          prevScrollHeightBottom = scrollableSection.scrollHeight;\n          console.log(\"SCROLL TOP\");\n          scrollableSection.scrollTop = 300;\n        } else {\n          console.log(\"SCROLL STOP TOP\");\n          clearInterval(interVervalTop);\n          const intervalBottom = setInterval(() => {\n            if (prevScrollHeightTop < scrollableSection.scrollHeight) {\n              // ######################\n              console.log(\"SCROLL HEIGHT\", prevScrollHeightTop);\n              prevScrollHeightTop = prevScrollHeightTop + 1200;\n              scrollableSection.scrollTop = prevScrollHeightTop;\n            } else {\n              console.log(\"SCROLL STOP BOTTOM\");\n              clearInterval(intervalBottom);\n            }\n          }, 500);\n        }\n      }, 1000);\n    }\n  }, targetSelector);\n}"
  },
  "selectSlackChannel": {
    "name": "selectSlackChannel",
    "slug": "TsFunction",
    "id": "tkodezifarymqqvkendwjjop",
    "description": "This help to find and select the slack channel",
    "operationName": "slack-controller",
    "rawText": " async (props: {\n  page: Page;\n  channel: string;\n}) => {\n  const { page, channel } = props;\n  await page.waitForSelector('div[aria-label=\"Channels and direct messages\"]');\n  // Getting channel id for channel name\n  const channelId = await page.$$eval(\n    'div[aria-label=\"Channels and direct messages\"] > div ',\n    (elements, channel) => {\n      const selectedMessage = elements.find((el) => {\n        const index = el.textContent?.indexOf(channel as string) as number;\n        if (index > -1) {\n          return true;\n        }\n        return false;\n      }) as HTMLElement;\n      const channelId = selectedMessage.getAttribute(\"id\");\n      return channelId;\n    },\n    channel\n  );\n\n  if (channelId) {\n    const currentUrl = await page.url();\n    let targetUrlArr = currentUrl.split(\"/\").slice(0, 5);\n    console.log({ targetUrlArr });\n    targetUrlArr.push(channelId);\n    const finalChannelUrl = targetUrlArr.join(\"/\");\n    console.log({ finalChannelUrl });\n    await page.goto(finalChannelUrl);\n  } else {\n    return { success: false, message: \"Channel not found\" };\n  }\n}"
  },
  "selectSlackWorkspace": {
    "name": "selectSlackWorkspace",
    "slug": "TsFunction",
    "id": "xfwepbczxyrvyzgueelyzqsc",
    "description": "This method help to find and select slack workspace",
    "operationName": "slack-controller",
    "rawText": " async (props: {\n  page: Page;\n  workspace: string;\n}) => {\n  const { page, workspace } = props;\n  await page.waitForTimeout(5000);\n  // Selects and clicks the slacks workspace\n  await page\n    .mainFrame()\n    .waitForSelector(\n      \"#get_started_app_root > div.p-refreshed_page > div.p-workspaces_view__container > div > section > div > div.p-expanding_workspace_list > div.p-expanding_workspace_list__workspaces.p-expanding_workspace_list__workspaces\"\n    );\n\n  await page.$$eval(\n    \"#get_started_app_root > div.p-refreshed_page > div.p-workspaces_view__container > div > section > div > div.p-expanding_workspace_list > div.p-expanding_workspace_list__workspaces.p-expanding_workspace_list__workspaces > a \",\n    (elements, workspace) => {\n      console.log(\"WorkSpace\", elements);\n      const selectedWorkspace = elements.find((el) => {\n        const index = el.innerHTML.indexOf(workspace as string) as number;\n        if (index > -1) {\n          return true;\n        }\n        return false;\n      }) as HTMLElement;\n      selectedWorkspace?.setAttribute(\"target\", \"_self\");\n      selectedWorkspace?.click();\n    },\n    workspace\n  );\n  await page.waitForTimeout(15000);\n}"
  },
  "sendSlackMessage": {
    "name": "sendSlackMessage",
    "slug": "TsFunction",
    "id": "xzpfcwhxowdwkzfpegzaegxr",
    "description": "",
    "operationName": "slack-controller",
    "rawText": " async (\n  credentials: slackSendMessagePropTypes,\n  options?: { dryrun?: boolean }\n) => {\n  try {\n    const { workspace, channel, message, email, password } = credentials;\n    const { dryrun } = options || {};\n\n    // login into the slack\n    const { page, success } = await slackLogin({\n      mode: \"gmail\",\n      credentials: {\n        email,\n        password,\n      },\n    });\n\n    console.log(\"login data\", success, message, page);\n    if (!success || !page) {\n      return { success: false, message: \"Login faild\" };\n    }\n    // Selecting and clicking on the workspace\n    await selectSlackWorkspace({ page, workspace });\n\n    // Select channel\n    await selectSlackChannel({ page, channel });\n    //\n    // Types in message\n    await page.waitForSelector(\"div.ql-editor\", { timeout: 10000 });\n    await page.$$eval(\n      \"div.ql-editor\",\n      (elements, message) => {\n        const getParagraph = elements[0];\n        getParagraph.removeChild(getParagraph.children[0]);\n        const paragraph = document.createElement(\"p\");\n        getParagraph.appendChild(paragraph);\n        getParagraph.children[0].append(message as string);\n      },\n      message\n    );\n    if (!dryrun) {\n      await page.$$eval('button[aria-label=\"Send now\"]', (elements) => {\n        const sendButton = elements[0] as HTMLElement;\n        sendButton.click();\n      });\n    }\n    return {\n      success: true,\n      message: \"Message send successfully\",\n    };\n  } catch (e: Error | any) {\n    return { success: false, message: e?.message };\n  }\n}"
  },
  "SIGN_IN_URL": {
    "name": "SIGN_IN_URL",
    "slug": "TsVariable",
    "id": "xqsquvwamftacfgbojxfjmdj",
    "description": "",
    "operationName": "slack-controller"
  },
  "slackLogin": {
    "name": "slackLogin",
    "slug": "TsFunction",
    "id": "zxmpdglieumtodaradgrhnvp",
    "description": "",
    "operationName": "slack-controller",
    "rawText": " async (\n  props: SlackLoginArguments\n): Promise<ResponseType> => {\n  try {\n    const {\n      mode,\n      credentials: { email, password },\n    } = props;\n    console.log(\"LOGIN URL\", cwd());\n    /**\n     * check if it's already logged in\n     */\n\n    const browser = await puppeteer.launch(launchOptions);\n    //@ts-ignore\n    let page: Page = await browser.newPage();\n    await page.setBypassCSP(true);\n\n    await page.setExtraHTTPHeaders({\n      \"accept-language\": \"en-US,en;q=0.9,hy;q=0.8\",\n    });\n\n    await page.goto(SIGN_IN_URL, {\n      waitUntil: \"domcontentloaded\",\n    });\n\n    /**\n     * Waiting for page to laod\n     */\n\n    await page.waitForTimeout(5000);\n    /**\n     * Gmail mode\n     */\n\n    if (mode === \"gmail\") {\n      /**\n       * Sign in Button Handler for evaluation\n       */\n      const signInButtonHandle = await page.$(\n        \"#get_started_app_root > div.p-refreshed_page > div.p-get_started_signin > div > button\"\n      );\n\n      /**\n       * Click the Goole sign in button\n       */\n\n      await page.evaluate((el: any) => {\n        const element = el as unknown as HTMLElement;\n        element.click();\n        // return;\n      }, signInButtonHandle);\n\n      /**\n       * Waits for 3 seconds for page load\n       */\n\n      await page.waitForTimeout(3000);\n\n      /**\n       * check if there's email input box\n       */\n      const identifierExists = await elementExists(\n        \"input[id=identifierId]\",\n        page\n      );\n      /**\n       * If not, clicks it will select the email to sign in\n       */\n      await page.screenshot({ path: \"slackscreen.png\" });\n      await page.setBypassCSP(true);\n\n      if (!identifierExists) {\n        await page.$$eval(`div[data-identifier=\"${email}\"]`, (el: any) => {\n          const element = el[0] as HTMLElement;\n          element.click();\n        });\n        return { page, success: true, message: \"Login successfull\" };\n      }\n\n      /**\n       * Check for input Box, type email and click next\n       */\n      await page.mainFrame().waitForSelector(\"#identifierId\");\n\n      await page.type(\"#identifierId\", email, { delay: 100 });\n\n      await page.mainFrame().waitForSelector(\"#identifierNext > div > button\");\n      await page.click(\"#identifierNext > div > button\");\n\n      /**\n       * Waits for 5 seconds and types password and clicks sign in\n       */\n\n      await page.waitForTimeout(5000);\n      await page.screenshot({ path: \"slackscreen.png\" });\n      await page.screenshot({ path: \"passwordScreen.png\" });\n      await page.waitForSelector(\"input[type=password]\");\n      await page.screenshot({ path: \"slackscreen.png\" });\n      if (password)\n        await Promise.all([\n          await page.waitForSelector(\"input[type=password]\"),\n          await page.type(\"input[type=password]\", password, {\n            delay: 100,\n          }),\n          await page.click(\"#passwordNext > div > button\"),\n        ]);\n      return { page, success: true, message: \"Logged in\" };\n    }\n  } catch (e: any | Error) {\n    return { success: false, message: e.message };\n  }\n  return { success: false, message: \"Something went wrong\" };\n}"
  },
  "storeAllSlackChannel": {
    "name": "storeAllSlackChannel",
    "slug": "TsFunction",
    "id": "nerusoogsrseankkjwdkjzlb",
    "description": "Get the all channels of related workspace and store on the `MediaChannel` model",
    "operationName": "slack-controller",
    "rawText": " async (props: {\n  workspace: string;\n  email: string;\n  password: string;\n}): Promise<StoreChannelReturnType> => {\n  const { workspace, email, password } = props;\n\n  const { data } = await getSlackChannels({\n    email,\n    password,\n    workspace,\n  });\n\n  if (!data) return { success: false, message: \"slack chhannels not found\" };\n\n  const { channels } = data;\n  console.log(\"Get Channel Res\", channels);\n  if (channels.length === 0) {\n    return { success: false, message: \"No chhanel found\" };\n  }\n\n  // @ts-ignore\n  const newMediaChannel: Creation<MediaChannel>[] = channels.map((c) => ({\n    name: c,\n  }));\n\n  await db.upsert(\"MediaChannel\", newMediaChannel);\n\n  return { success: true, message: \"Channel store successfully\" };\n}"
  },
  "storeSlackChannelMember": {
    "name": "storeSlackChannelMember",
    "slug": "TsFunction",
    "id": "dazdwblxqujgwkwrotnrqana",
    "description": "Get the all channels of related workspace and store on the `MediaChannel` model",
    "operationName": "slack-controller",
    "rawText": " async (props: {\n  workspace: string;\n  email: string;\n  password: string;\n  channelName: string;\n}): Promise<{\n  isSuccessful: boolean;\n  message: string;\n}> => {\n  const { workspace, email, password, channelName } = props;\n\n  const { data } = await getSlackChannelMemberList({\n    email,\n    password,\n    workspace,\n    channelName: channelName,\n  });\n\n  if (!data) {\n    return {\n      isSuccessful: false,\n      message: \"slack chhannel people list not found\",\n    };\n  }\n\n  console.log(\"Get Channel people Res\", data);\n  if (data.length === 0) {\n    return { isSuccessful: false, message: \"No chhanel found\" };\n  }\n\n  //@ts-ignore\n  const personDataToCreate: Creation<Person>[] = data.map((c) => ({ name: c }));\n  await db.upsert(\"Person\", personDataToCreate);\n\n  return { isSuccessful: true, message: \"Channel store successfully\" };\n}"
  },
  "WORKSPACE_URL": {
    "name": "WORKSPACE_URL",
    "slug": "TsVariable",
    "id": "jeyriaoavektmxausfquflws",
    "description": "",
    "operationName": "slack-controller"
  },
  "getAbsolutePathMdFileName": {
    "name": "getAbsolutePathMdFileName",
    "slug": "TsFunction",
    "id": "pwkdlqwnfggajmvwfxjeiajr",
    "description": "",
    "operationName": "social-media-node",
    "rawText": " (\n  absolutePath: string,\n  omitExtention: string\n): string => {\n  const fileName = absolutePath.split(\"/\").pop() || \"\";\n  const fileNameWithoutSubExtension = fileName\n    .split(\".\")\n    .filter((t) => t !== omitExtention)\n    .join(\".\");\n  return fileNameWithoutSubExtension;\n}"
  },
  "getAllPostables": {
    "name": "getAllPostables",
    "slug": "TsFunction",
    "id": "wrdjyenzboflleitwwhqvqon",
    "description": "",
    "operationName": "social-media-node",
    "rawText": " async (): Promise<{\n  postablesMenu: WebPage<unknown>[];\n}> => {\n  const getTodosPaths = await getTodoPaths();\n  const allPostables = getTodosPaths.filter((absolutePath) =>\n    hasSubExtension(absolutePath, \"postable\")\n  );\n  console.log({ allPostables });\n\n  const flatPostablesMenu: WebPage<unknown>[] = allPostables?.map((p) => {\n    const [before, after] = p.split(\"/todo/\");\n    const lastFolderBeforeTodo = getLastFolder(before);\n    const todoRelativeFileId = withoutExtension(after);\n    const fileName = getLastFolder(todoRelativeFileId);\n    /**\n     * Idea: parsing the file for amount of items with and without checkmark, showing the % done and (x/y)\n     */\n    const menuTitle = humanCase(fileName);\n\n    return {\n      queryPath: `Postables/${lastFolderBeforeTodo}/${todoRelativeFileId}`,\n      menuTitle: getAbsolutePathMdFileName(p, \"postable\"),\n      pageData: {\n        projectRelativeFilePath: p,\n      },\n    };\n  });\n  return { postablesMenu: flatPostablesMenu };\n}"
  },
  "getPersonDetails": {
    "name": "getPersonDetails",
    "slug": "TsFunction",
    "id": "ojwfzcvyiunawesedldxhazo",
    "description": "",
    "operationName": "social-media-node",
    "rawText": " async (\n  personId: string\n): Promise<Person | undefined> => {\n  const personInfo = await (\n    await db.get(\"Person\")\n  ).find((p) => p.id === personId);\n  return personInfo;\n}"
  },
  "getPersonsMenu": {
    "name": "getPersonsMenu",
    "slug": "TsFunction",
    "id": "slzojmffxhejhkcmgivqysha",
    "description": "",
    "operationName": "social-media-node",
    "rawText": " async (): Promise<{\n  personsMenu: WebPage<unknown>[];\n}> => {\n  const allMediaChanels = await db.get(\"Person\");\n\n  const flatPersonMenu: WebPage<unknown>[] = allMediaChanels?.map((c) => {\n    return {\n      queryPath: `Channel/Person/${c.id}`,\n      menuTitle: c.name,\n      pageData: undefined,\n    };\n  });\n\n  return { personsMenu: flatPersonMenu };\n}"
  },
  "getSocialMediaChannelsMenu": {
    "name": "getSocialMediaChannelsMenu",
    "slug": "TsFunction",
    "id": "wkssybfhgqhmmorrzvxhlfud",
    "description": "",
    "operationName": "social-media-node",
    "rawText": " async (): Promise<{\n  mediaChannelsMenu: WebPage<unknown>[];\n}> => {\n  const allMediaChanels = await db.get(\"MediaChannel\");\n  const allPersons = await db.get(\"Person\");\n\n  const flatPersonMenu: WebPage<unknown>[] = allPersons?.map((c) => {\n    return {\n      queryPath: `Channel/Media-Channel/${c.id}`,\n      menuTitle: `ðŸ‘¤ ${c.name}`,\n      pageData: undefined,\n    };\n  });\n\n  const flatMediaChannelMenu: WebPage<unknown>[] = allMediaChanels?.map((c) => {\n    return {\n      queryPath: `Channel/Media-Channel/${c.id}`,\n      menuTitle: `ðŸ‘¥ ${c.name}`,\n      pageData: undefined,\n    };\n  });\n\n  return { mediaChannelsMenu: [...flatMediaChannelMenu, ...flatPersonMenu] };\n}"
  },
  "getSocialMediaMenu": {
    "name": "getSocialMediaMenu",
    "slug": "TsFunction",
    "id": "ybsqgeiceknockdoawbinhdj",
    "description": "Its generate the side menu of social media page",
    "operationName": "social-media-node",
    "rawText": " async (): Promise<{\n  nested: NestedWebPage[];\n  flat: WebPage<unknown>[];\n}> => {\n  console.log(\"Social media menu called\");\n  const { postablesMenu } = await getAllPostables();\n  const { personsMenu } = await getPersonsMenu();\n  const { mediaChannelsMenu } = await getSocialMediaChannelsMenu();\n  const flat: WebPage<unknown>[] = [\n    {\n      queryPath: \"configuration/Interest\",\n      menuTitle: \"Interest\",\n      pageData: undefined,\n    },\n    {\n      queryPath: \"configuration/PersonInformation\",\n      menuTitle: \"PersonInformation\",\n      pageData: undefined,\n    },\n    {\n      queryPath: \"configuration/Persona\",\n      menuTitle: \"Persona\",\n      pageData: undefined,\n    },\n    {\n      queryPath: \"configuration/MediaCredential\",\n      menuTitle: \"MediaCredential\",\n      pageData: undefined,\n    },\n    {\n      queryPath: \"configuration/MediaChannel\",\n      menuTitle: \"MediaChannel\",\n      pageData: undefined,\n    },\n    {\n      queryPath: \"upsert/Interest\",\n      pageData: undefined,\n      isMenuHidden: true,\n    },\n    {\n      queryPath: \"upsert/PersonInformation\",\n      pageData: undefined,\n      isMenuHidden: true,\n    },\n    {\n      queryPath: \"upsert/Persona\",\n      pageData: undefined,\n      isMenuHidden: true,\n    },\n    {\n      queryPath: \"upsert/MediaCredential\",\n      pageData: undefined,\n      isMenuHidden: true,\n    },\n    {\n      queryPath: \"upsert/MediaChannel\",\n      pageData: undefined,\n      isMenuHidden: true,\n    },\n\n    // {\n    //   queryPath: \"Channel\",\n    //   menuTitle: \"Person\",\n    //   pageData: undefined,\n    ...personsMenu,\n    // },\n    // todo: get(\"Person\") and generate this menu\n\n    // {\n    //   queryPath: \"Channel\",\n    //   menuTitle: \"MediaChannel\",\n    //   pageData: undefined,\n    // },\n\n    // {queryPath:\"channel/[id]\", menuTtile:\"ðŸ‘¥\" / \"ðŸ‘¤\" + [name] }\n    // todo db.get(\"MediaChannel\") and generate this menu\n    ...mediaChannelsMenu,\n    {\n      queryPath: \"Postables\",\n      menuTitle: \"Postables\",\n      pageData: undefined,\n    },\n\n    // todo: get our own get/update for TodoFile and WebMarkownFile and then we can dynamically generate this menu\n    // todo: for this, have a look at todo-web and writer-web and the functions they use, see how that works\n    // `getTodoPaths` and `getProjectRelativePaths`\n    // `readMarkdownFileToModel` to parse into `WebMarkdownfile`\n    // todo: create our own of the above to parse into `TodoFile` as well\n    ...postablesMenu,\n  ];\n\n  return getMenuPagesObject(flat);\n}"
  },
  "getSubExtensions": {
    "name": "getSubExtensions",
    "slug": "TsFunction",
    "id": "buijayjeqzvybyedhjtbtvkg",
    "description": "",
    "operationName": "social-media-node",
    "rawText": " (absolutePath: string): string[] => {\n  const mdFileName = absolutePath.split(\"/\").pop();\n  const allSubExtensionsArray = mdFileName?.split(\".\") || [];\n  const allSubExtensions = allSubExtensionsArray.slice(\n    1,\n    allSubExtensionsArray.length - 1\n  );\n  return allSubExtensions;\n}"
  },
  "Chat": {
    "name": "Chat",
    "slug": "TsFunction",
    "id": "tzcxojyreizungbhagyftybw",
    "description": "",
    "operationName": "social-media-web",
    "rawText": " () => {\n  const router = useRouter();\n  const { paths } = router?.query;\n  const personId = paths ? paths[2] : \"\";\n  const personQuery = queries.useGetPersonDetails(personId);\n  let personDetail: Person | undefined = personQuery.data?.result;\n  const [message, updateMessage] = useState(\"\");\n\n  const messageSendHandler = () => {\n    // send message api called here\n  };\n\n  if (personQuery.isLoading) return <Div>Loading...</Div>;\n\n  return (\n    <Div className=\"m-3 w-[500px]\">\n      <Div>\n        <Div className=\"mt-[50px] text-blue-700\">\n          {personDetail && <h2 className=\"text-lg\">{personDetail.name}</h2>}\n        </Div>\n        <TextArea\n          className=\"border mr- w-[500px] h-[100px] p-1\"\n          value={message}\n          placeholder=\"Write your message here...\"\n          onChange={(e) => updateMessage(e.target.value)}\n        ></TextArea>\n      </Div>\n      <Div className=\"flex justify-end\">\n        <Button\n          className=\"bg-slate-700 text-white p-2 \"\n          onClick={messageSendHandler}\n        >\n          Send\n        </Button>\n      </Div>\n    </Div>\n  );\n}"
  },
  "PersonSetting": {
    "name": "PersonSetting",
    "slug": "TsFunction",
    "id": "tdunqvngudrgzmzouzkbiplb",
    "description": "",
    "operationName": "social-media-web",
    "rawText": " () => {\n  const router = useRouter();\n  const { paths } = router?.query;\n  const personId = paths ? paths[2] : \"\";\n  const personQuery = queries.useGetPersonDetails(personId);\n  let personDetail: Person | undefined = personQuery.data?.result;\n\n  if (personQuery.isLoading) return <Div>Loading...</Div>;\n  return (\n    <Div className=\"m-3 w-[500px] ml-8\">\n      {personDetail ? (\n        <Div>\n          {/* <Div>{`Person Id: ${personId}`}</Div> */}\n          <Div>{`Name: ${personDetail.name}`}</Div>\n        </Div>\n      ) : (\n        \"No Details Found\"\n      )}\n    </Div>\n  );\n}"
  },
  "Person": {
    "name": "Person",
    "slug": "TsFunction",
    "id": "cupiwkbzezhgraarbgthxedp",
    "description": "",
    "operationName": "social-media-web",
    "rawText": " () => {\n  const [currentTab, setTab] = useState(\"chat\");\n\n  const changeTab = (tab: string) => {\n    setTab(tab);\n  };\n\n  const getTabContent = (type: string) => {\n    if (currentTab === \"chat\") {\n      return;\n    }\n    if (currentTab === \"setting\") {\n      return <PersonSetting />;\n    }\n  };\n\n  return (\n    <Div>\n      {/* <Tabs\n        title=\"test\"\n        tabs={[\n          {\n            title: \"Chat\",\n            emoji: \"ðŸ’¬\",\n            renderTab: () => <Chat />,\n          },\n          {\n            title: \"Setting\",\n            emoji: \"ðŸ‘¤\",\n            renderTab: () => <PersonSetting />,\n          },\n        ]}\n      /> */}\n      <Div className=\"flex justify-start\">\n        <Div className=\"mr-3\">\n          <Button\n            onClick={() => changeTab(\"chat\")}\n            className={`${currentTab === \"chat\" && \"bg-slate-700\"} ${\n              currentTab === \"chat\" && \"text-white\"\n            }  p-1 border-r-2`}\n          >{`ðŸ’¬ Chat`}</Button>\n        </Div>\n        <Div>\n          <Button\n            onClick={() => changeTab(\"setting\")}\n            className={`${currentTab === \"setting\" && \"bg-slate-700\"} ${\n              currentTab === \"setting\" && \"text-white\"\n            }  p-1 border-r-2`}\n          >{`ðŸ‘¤ Settings`}</Button>\n        </Div>\n      </Div>\n      <Div>{getTabContent(currentTab)}</Div>\n    </Div>\n  );\n}"
  },
  "addSocialMediaCredential": {
    "name": "addSocialMediaCredential",
    "slug": "TsFunction",
    "id": "ixlrxkytwzjtszcguzhngpna",
    "description": "Add credentials for different platform in the  `SocialMediaCredentail` model",
    "operationName": "social-media-wrapper",
    "rawText": " async (\n  credentail: SocialMediaCrentialType\n) => {\n  const { email, password, phoneNumber, username, mediaType } = credentail;\n  //@ts-ignore\n  const credentailAddResponse = await db.upsert(\"SocialMediaCredentail\", {\n    email,\n    password,\n    mediaType,\n    phoneNumber,\n    username,\n  });\n  return credentailAddResponse;\n}"
  },
  "canBePosted": {
    "name": "canBePosted",
    "slug": "TsFunction",
    "id": "edsuvztpjyptynyzmyareazd",
    "description": "Filter only `socialMediaPost` are able to post",
    "operationName": "social-media-wrapper",
    "rawText": " (socialMediaPost: MediaPost) =>\n  !socialMediaPost.isPosted &&\n  socialMediaPost.isPostable &&\n  socialMediaPost.isVerified"
  },
  "createAllSocialMediaPost": {
    "name": "createAllSocialMediaPost",
    "slug": "TsFunction",
    "id": "prnbzfsglscqordmdoskzsvg",
    "description": "Getting all social media post and intiate all controllers for post\n\nTodo: limiting the number of social media post at a time",
    "operationName": "social-media-wrapper",
    "rawText": " async () => {\n  // getting all social media posts\n  const allPostableSocialMediaPosts = await (\n    await db.get(\"MediaPost\")\n  ).filter(canBePosted);\n  console.log({ allPostableSocialMediaPosts });\n  // making promises for post\n  const allSocialPostPomises = allPostableSocialMediaPosts.map(\n    createSocialMediaPost\n  );\n  const allPostResponses = await Promise.all(allSocialPostPomises);\n  console.log({ allPostResponses });\n}"
  },
  "createSocialMediaPost": {
    "name": "createSocialMediaPost",
    "slug": "TsFunction",
    "id": "dikgbrqyxwaqnvrozudpkrwc",
    "description": "Take `socialMediaPost` as paramater and initiate\nsocial media controller based on `socialMediaPlatform` type",
    "operationName": "social-media-wrapper",
    "rawText": " async (\n  socialMediaPost: MediaPost\n): Promise<SocialMediaPostTypeReturnType> => {\n  const { mediaPlatform } = socialMediaPost;\n  console.log({ mediaPlatform });\n  if (mediaPlatform) {\n    if (mediaPlatform === \"facebook\")\n      return postSocialMediaPostToFacebook(socialMediaPost);\n    if (mediaPlatform === \"medium\")\n      return postSocialMediaPostToMedium(socialMediaPost);\n    if (mediaPlatform === \"reddit\")\n      return postSocialMediaPostToReddit(socialMediaPost);\n    if (mediaPlatform === \"twitter\")\n      return postSocialMediaPostToTwitter(socialMediaPost);\n    if (mediaPlatform === \"devto\")\n      return postSocialMediaPostToDevto(socialMediaPost);\n  }\n  return { isSuccess: false, message: \"platform not found\" };\n}"
  },
  "devtoCotentAnalyzer": {
    "name": "devtoCotentAnalyzer",
    "slug": "TsFunction",
    "id": "arbfuhmrahtqtagleiylxvik",
    "description": "",
    "operationName": "social-media-wrapper",
    "rawText": " (\n  markdownFile: TodoFile | WebMarkdownFile\n): Partial<MediaPost> | undefined => {\n  const parsedTitle = markdownFile.title;\n  const parsedContent = markdownFile.markdown;\n  if (parsedContent && parsedTitle) {\n    const contentLength = parsedContent.length;\n    if (contentLength > 30000) {\n      return {\n        parsedContent,\n        parsedTitle,\n        mediaPlatform: \"devto\",\n        postableId: markdownFile.id,\n        isPostable: false,\n        isVerified: false,\n        unpostableReason: \"Content is too large\",\n      };\n    }\n    return {\n      parsedContent,\n      parsedTitle,\n      mediaPlatform: \"devto\",\n      postableId: markdownFile.id,\n      isPostable: true,\n      isVerified: false,\n    };\n  }\n}"
  },
  "facebookContentAnalyzer": {
    "name": "facebookContentAnalyzer",
    "slug": "TsFunction",
    "id": "xljdxlwirpsfrzbscfhrctat",
    "description": "1. Analyzing the conent and title existing or not\n2. Analyzing the length of the content is enough or not for facebook post",
    "operationName": "social-media-wrapper",
    "rawText": " (\n  markdownFile: TodoFile | WebMarkdownFile\n): Partial<MediaPost> | undefined => {\n  const parsedTitle = markdownFile.title;\n  const parsedContent = markdownFile.markdown;\n  if (parsedContent) {\n    const contentLength = parsedContent.length;\n    if (contentLength > 30000) {\n      return {\n        parsedTitle,\n        parsedContent,\n        mediaPlatform: \"facebook\",\n        postableId: markdownFile.id,\n        isVerified: false,\n        isPostable: false,\n        unpostableReason: \"Content is more than 30000 characters\",\n      };\n    }\n    return {\n      parsedTitle,\n      parsedContent,\n      mediaPlatform: \"facebook\",\n      postableId: markdownFile.id,\n      isPostable: true,\n      isVerified: false,\n    };\n  }\n}"
  },
  "getBrowser": {
    "name": "getBrowser",
    "slug": "TsFunction",
    "id": "jqiqsisuvmvolnaflfkmzveo",
    "description": "",
    "operationName": "social-media-wrapper",
    "rawText": " async () => {\n  const browser = await runBrowser();\n  const browserUrl = await browser.wsEndpoint();\n\n  const browser1 = await puppeteer.connect({ browserWSEndpoint: browserUrl });\n  const page = await browser1.newPage();\n  await page.goto(\"https://facebook.com\");\n  const browser2 = await puppeteer.connect({ browserWSEndpoint: browserUrl });\n\n  const page2 = await browser2.newPage();\n  await page2.goto(\"https://google.com\");\n\n  const tabs = await browser.pages();\n  console.log({ tabs });\n\n  for await (let tab of tabs) {\n    const url = await tab.url();\n    const title = await tab.title();\n    console.log({ url, title });\n  }\n  if (tabs.length > 0) {\n    const result = await new Promise((resolve, rejects) => {\n      resolve(\n        tabs[1].$eval('h2[class=\"_8eso\"]', (elem) => {\n          const texts = elem.innerText;\n          console.log(\"run by puppeteer\", { texts });\n          return texts;\n        })\n      );\n    });\n    console.log({ result });\n  }\n}"
  },
  "getSocialMediaCredentials": {
    "name": "getSocialMediaCredentials",
    "slug": "TsFunction",
    "id": "abmxzlqvkgxcbghkwpjxgosc",
    "description": "Get the social media type and return the credential",
    "operationName": "social-media-wrapper",
    "rawText": " async (\n  mediaType: MediaPlatformEnum\n) => {\n  const credential = await (\n    await db.get(\"MediaCredential\")\n  ).find((c) => c.mediaType === mediaType);\n  return credential;\n}"
  },
  "mediumCotentAnalyzer": {
    "name": "mediumCotentAnalyzer",
    "slug": "TsFunction",
    "id": "gdnqqtvxofsivvcwysmyafmd",
    "description": "",
    "operationName": "social-media-wrapper",
    "rawText": " (\n  markdownFile: TodoFile | WebMarkdownFile\n): Partial<MediaPost> | undefined => {\n  const parsedTitle = markdownFile.title;\n  const parsedContent = markdownFile.markdown;\n  if (parsedContent && parsedTitle) {\n    const contentLength = parsedContent.length;\n    if (contentLength > 30000) {\n      return {\n        parsedContent,\n        parsedTitle,\n        mediaPlatform: \"medium\",\n        postableId: markdownFile.id,\n        isPostable: false,\n        isVerified: false,\n        unpostableReason: \"Content is too large\",\n      };\n    }\n    return {\n      parsedContent,\n      parsedTitle,\n      mediaPlatform: \"medium\",\n      postableId: markdownFile.id,\n      isPostable: true,\n      isVerified: false,\n    };\n  }\n}"
  },
  "postSocialMediaPostToDevto": {
    "name": "postSocialMediaPostToDevto",
    "slug": "TsFunction",
    "id": "bgxakpulhqvrdhevhysgpygv",
    "description": "Calling `publishBlogOnDevTo` to post the `SocialMediaPost` content on the dev.to\nand updating the `SocialMediaPost` with response by calling `updateSocialMediaPost`",
    "operationName": "social-media-wrapper",
    "rawText": " async (\n  socialMediapost: MediaPost\n): Promise<SocialMediaPostTypeReturnType> => {\n  const { parsedContent, parsedTitle } = socialMediapost;\n  const credentails = await getSocialMediaCredentials(\"devto\");\n\n  if (!credentails?.email || !credentails?.password) {\n    return {\n      isSuccess: false,\n      message: \"No credential found\",\n    };\n  }\n\n  if (!parsedContent || !parsedTitle) {\n    return {\n      isSuccess: false,\n      message: \"No content found\",\n    };\n  }\n\n  const { isSuccess, message, postUrl } = await publishBlogOnDevTo({\n    email: credentails.email,\n    password: credentails.password,\n    content: parsedContent,\n    title: parsedTitle,\n  });\n\n  if (!isSuccess) {\n    return {\n      isSuccess: false,\n      message,\n    };\n  }\n\n  // update the SocialMediaPost model\n  const updateResult = await updateSocialMediaPost(socialMediapost, postUrl);\n\n  return { isSuccess, message, postUrl };\n}"
  },
  "postSocialMediaPostToFacebook": {
    "name": "postSocialMediaPostToFacebook",
    "slug": "TsFunction",
    "id": "zczflgwkshidkvkqqqibaufm",
    "description": "Calling `publishBlogOnDevTo` to post the `SocialMediaPost` content on the facebook.com\nand updating the `SocialMediaPost` with response by calling `updateSocialMediaPost`",
    "operationName": "social-media-wrapper",
    "rawText": " async (\n  socialMediaPost: MediaPost\n): Promise<SocialMediaPostTypeReturnType> => {\n  const { parsedContent, channelOrGroup } = socialMediaPost;\n  const credentails = await getSocialMediaCredentials(\"facebook\");\n\n  if (!credentails?.email || !credentails?.password) {\n    return {\n      isSuccess: false,\n      message: \"No credential found\",\n    };\n  }\n\n  if (!parsedContent) {\n    return {\n      isSuccess: false,\n      message: \"No content found\",\n    };\n  }\n\n  const { isSuccess, message, postUrl } = await facebookPost({\n    email: credentails.email,\n    password: credentails.password,\n    post: parsedContent,\n    groupName: channelOrGroup,\n  });\n  if (!isSuccess) {\n    return {\n      isSuccess: false,\n      message,\n    };\n  }\n\n  // update the SocialMediaPost model\n  const updateResult = await updateSocialMediaPost(socialMediaPost, postUrl);\n  return { isSuccess, message, postUrl };\n}"
  },
  "postSocialMediaPostToMedium": {
    "name": "postSocialMediaPostToMedium",
    "slug": "TsFunction",
    "id": "xlatbbhhzjxpgriiulyoajjo",
    "description": "Calling `publishBlogOnDevTo` to post the `SocialMediaPost` content on the medium.com\nand updating the `SocialMediaPost` with response by calling `updateSocialMediaPost`",
    "operationName": "social-media-wrapper",
    "rawText": " async (\n  socialMediaPost: MediaPost\n): Promise<SocialMediaPostTypeReturnType> => {\n  const { parsedContent, parsedTitle, channelOrGroup } = socialMediaPost;\n  const credentails = await getSocialMediaCredentials(\"medium\");\n\n  if (!credentails?.email || !credentails?.password) {\n    return {\n      isSuccess: false,\n      message: \"No credential found\",\n    };\n  }\n\n  if (!parsedContent || !parsedTitle) {\n    return {\n      isSuccess: false,\n      message: \"No content found\",\n    };\n  }\n\n  const { isSuccess, message, postUrl } = await publishBlogOnMedium({\n    email: credentails.email,\n    password: credentails.password,\n    content: parsedContent,\n    title: parsedTitle,\n    loginWith: \"facebook\",\n  });\n  if (!isSuccess) {\n    return {\n      isSuccess: false,\n      message,\n    };\n  }\n  // update the SocialMediaPost model\n  const updateResult = await updateSocialMediaPost(socialMediaPost, postUrl);\n  return { isSuccess, message, postUrl };\n}"
  },
  "postSocialMediaPostToReddit": {
    "name": "postSocialMediaPostToReddit",
    "slug": "TsFunction",
    "id": "djcfajcugksmefoourqeqkux",
    "description": "Calling `publishBlogOnDevTo` to post the `SocialMediaPost` content on the reddit.com\nand updating the `SocialMediaPost` with response by calling `updateSocialMediaPost`",
    "operationName": "social-media-wrapper",
    "rawText": " async (\n  socialMediaPost: MediaPost\n): Promise<SocialMediaPostTypeReturnType> => {\n  const { parsedContent, parsedTitle, channelOrGroup } = socialMediaPost;\n  const credentails = await getSocialMediaCredentials(\"reddit\");\n  if (!credentails?.email || !credentails.username) {\n    return {\n      isSuccess: false,\n      message: \"No credential found\",\n    };\n  }\n\n  if (!channelOrGroup || !parsedContent || !parsedTitle) {\n    return {\n      isSuccess: false,\n      message: \"No content found\",\n    };\n  }\n\n  const { isSuccess, message, postUrl } = await publishBlogOnReddit({\n    email: credentails.email,\n    password: credentails.password,\n    username: credentails.username,\n    content: parsedContent,\n    title: parsedTitle,\n    groupName: channelOrGroup,\n  });\n  if (!isSuccess) {\n    return {\n      isSuccess: false,\n      message,\n    };\n  }\n\n  // update the SocialMediaPost model\n  const updateResult = await updateSocialMediaPost(socialMediaPost, postUrl);\n  return { isSuccess, message, postUrl };\n}"
  },
  "postSocialMediaPostToTwitter": {
    "name": "postSocialMediaPostToTwitter",
    "slug": "TsFunction",
    "id": "nftdmtbqfcfrbrpqxqpdwwwr",
    "description": "Calling `publishBlogOnDevTo` to post the `SocialMediaPost` content on the twitter.com\nand updating the `SocialMediaPost` model with response by calling `updateSocialMediaPost`",
    "operationName": "social-media-wrapper",
    "rawText": " async (\n  socialMediaPost: MediaPost\n): Promise<SocialMediaPostTypeReturnType> => {\n  const { parsedContent, parsedTitle, channelOrGroup } = socialMediaPost;\n  const credentails = await getSocialMediaCredentials(\"twitter\");\n\n  if (!credentails?.email || !credentails?.phoneNumber) {\n    return {\n      isSuccess: false,\n      message: \"No credential found\",\n    };\n  }\n\n  if (!parsedContent) {\n    return {\n      isSuccess: false,\n      message: \"No content found\",\n    };\n  }\n\n  const { isSuccess, message, postUrl } = await postTweetOnTwitter({\n    email: credentails.email,\n    password: credentails.password,\n    phoneNo: credentails.phoneNumber,\n    tweetMessage: parsedContent,\n  });\n  if (!isSuccess) {\n    return {\n      isSuccess: false,\n      message,\n    };\n  }\n\n  // update the SocialMediaPost model\n  const updateResult = await updateSocialMediaPost(socialMediaPost, postUrl);\n\n  return { isSuccess, message, postUrl };\n}"
  },
  "redditContentAnalyzer": {
    "name": "redditContentAnalyzer",
    "slug": "TsFunction",
    "id": "abfspeisgseuxswhtirkzhjx",
    "description": "",
    "operationName": "social-media-wrapper",
    "rawText": " (\n  markdownFile: TodoFile | WebMarkdownFile\n): Partial<MediaPost> | undefined => {\n  const parsedTitle = markdownFile.title;\n  const parsedContent = markdownFile.markdown;\n  if (parsedContent && parsedTitle) {\n    const contentLength = parsedContent.length;\n    if (contentLength > 30000) {\n      return {\n        parsedContent,\n        parsedTitle,\n        mediaPlatform: \"reddit\",\n        postableId: markdownFile.id,\n        isPostable: false,\n        isVerified: false,\n        channelOrGroup: \"annoucements\",\n        unpostableReason: \"Content is too large\",\n      };\n    }\n    return {\n      parsedContent,\n      parsedTitle,\n      channelOrGroup: \"annoucements\",\n      mediaPlatform: \"reddit\",\n      postableId: markdownFile.id,\n      isPostable: true,\n      isVerified: false,\n    };\n  }\n}"
  },
  "socialMediaPostPlanner": {
    "name": "socialMediaPostPlanner",
    "slug": "TsFunction",
    "id": "izpokqubgthkangbswtwtgsu",
    "description": "import {\n\ngetTodoFilePostables,\n\ngetWebMarkdownFilePostables,\n\n} from \"./getPostables\";\n\nGetting the parsed content from different platform and adding into the\n`SocialMediaPost` model and update the `Postable` model to `isPlanned` for post",
    "operationName": "social-media-wrapper",
    "rawText": " async () => {\n  // const webMarkdownFiles: WebMarkdownFile[] =\n  //   await getWebMarkdownFilePostables();\n  // const todoFiles: TodoFile[] = await getTodoFilePostables();\n  // const allUnplannedPost = webMarkdownFiles.filter(\n  //   (postable) => !postable.isPlanned && !postable.isDraft\n  // );\n  // const allMediaPostContents = allUnplannedPost\n  //   .map((postable) => [\n  //     facebookContentAnalyzer(postable),\n  //     mediumCotentAnalyzer(postable),\n  //     redditContentAnalyzer(postable),\n  //     twitterContentAnalyzer(postable),\n  //     devtoCotentAnalyzer(postable),\n  //   ])\n  //   .flat();\n  // // TODO: take upsert outside of for loop AND make the type interface work (Creation<MediaPost>)\n  // const socimediaPostInsertResponse = await db.upsert(\"MediaPost\", []);\n  // if (socimediaPostInsertResponse.isSuccesful) {\n  //   // manually update to set `.isPlanned: true` for every file.\n  // }\n}"
  },
  "startSocialMediaController": {
    "name": "startSocialMediaController",
    "slug": "TsFunction",
    "id": "aqftkgmaprvduavlgkzxeosu",
    "description": "Start the cron job for planing post on the `SocialMediaPost` and start the\nsocial media post",
    "operationName": "social-media-wrapper",
    "rawText": " async () => {\n  // cron.schedule(\"*/5 * * * * *\", () => {\n  // Plannign post on every cron interval\n  // socialMediaPostPlanner();\n  // start posting after the 5mins\n  //   setTimeout(() => {\n  createAllSocialMediaPost();\n  //   }, 5 * 60 * 1000);\n  // });\n}"
  },
  "twitterContentAnalyzer": {
    "name": "twitterContentAnalyzer",
    "slug": "TsFunction",
    "id": "zerpwsmneudwjipzlafdgzha",
    "description": "",
    "operationName": "social-media-wrapper",
    "rawText": " (\n  markdownFile: TodoFile | WebMarkdownFile\n): Partial<MediaPost> | undefined => {\n  const parsedTitle = markdownFile.title;\n  const parsedContent = markdownFile.markdown;\n  if (parsedContent && parsedTitle) {\n    const contentLength = parsedContent.length;\n    if (contentLength > 280) {\n      return {\n        parsedContent,\n        parsedTitle,\n        mediaPlatform: \"twitter\",\n        postableId: markdownFile.id,\n        isPostable: false,\n        isVerified: false,\n        unpostableReason: \"Content is too large\",\n      };\n    }\n    return {\n      parsedContent,\n      parsedTitle,\n      mediaPlatform: \"twitter\",\n      postableId: markdownFile.id,\n      isPostable: true,\n      isVerified: false,\n    };\n  }\n}"
  },
  "updateSocialMediaPost": {
    "name": "updateSocialMediaPost",
    "slug": "TsFunction",
    "id": "pnnyqkyndzigwtzyfqtibeqm",
    "description": "Updating `SocialMediaPost` with postedUrl and  isPosted => true",
    "operationName": "social-media-wrapper",
    "rawText": " async (\n  socialMediaPost: MediaPost,\n  postedUrl?: string\n) => {\n  await db.update(\n    \"MediaPost\",\n    (content) => content.id === socialMediaPost.id,\n    (post) => {\n      const newPost = { ...post, isPosted: true, postedUrl };\n      return newPost;\n    }\n  );\n}"
  },
  "basePaths": {
    "name": "basePaths",
    "slug": "TsVariable",
    "id": "nyscbmwunyxwgwrjlbwbbmaa",
    "description": "",
    "operationName": "code-from-nepal-web"
  },
  "ctas": {
    "name": "ctas",
    "slug": "TsVariable",
    "id": "znkajsznriamxtridulijvuv",
    "description": "",
    "operationName": "code-from-nepal-web"
  },
  "items": {
    "name": "items",
    "slug": "TsVariable",
    "id": "fhttkxmpazeqtknepvydnqmj",
    "description": "",
    "operationName": "code-from-nepal-web"
  },
  "alterArrayTest": {
    "name": "alterArrayTest",
    "slug": "TsFunction",
    "id": "jjffruclwoizmxrrajkayrpo",
    "description": "What will be the output of the console and why?",
    "operationName": "course-basics",
    "rawText": " () => {\n  const x = [1234, 456, 888];\n\n  const y = [...x];\n  const z = x;\n  y.push(1234);\n\n  // console.log(x.pop());\n\n  console.log({ x, y, z });\n}"
  },
  "alterObjectTest": {
    "name": "alterObjectTest",
    "slug": "TsFunction",
    "id": "wbxnbcyrxjjhtbujpolvfqlz",
    "description": "alterArrayTest();\n\nWhat will be the output of the console and why?",
    "operationName": "course-basics",
    "rawText": " () => {\n  const x = { abc: \"def\", xyz: 1234 };\n  const y = x;\n  const z = { ...x };\n  z.abc = \"oh no\";\n  x.xyz = 999999;\n  console.log({ x, y, z });\n}"
  },
  "divideNumber": {
    "name": "divideNumber",
    "slug": "TsFunction",
    "id": "ozxjbgrwwuxwtxryzscdlsqi",
    "description": "",
    "operationName": "course-basics",
    "rawText": " (number: number) => number / 2"
  },
  "divideNumbers": {
    "name": "divideNumbers",
    "slug": "TsFunction",
    "id": "viwmljmmaryxdkckwhalsrat",
    "description": "",
    "operationName": "course-basics",
    "rawText": " () => {\n  const divideNumberArray = numbers.map(divideNumber);\n  console.log(divideNumberArray);\n}"
  },
  "doubleNumber": {
    "name": "doubleNumber",
    "slug": "TsFunction",
    "id": "leitrmyjxlrblafscrdvzjyi",
    "description": "sumNumbers()\n\nSuyog, write a function called `doubleNumbers` that logs an array in the console where all numbers are doubled",
    "operationName": "course-basics",
    "rawText": " (number: number) => number * 2"
  },
  "doubleNumbers": {
    "name": "doubleNumbers",
    "slug": "TsFunction",
    "id": "mgpgteqbpzwkznaearblujvu",
    "description": "",
    "operationName": "course-basics",
    "rawText": " () => {\n  const doubleNumbersArray = numbers.map(doubleNumber);\n  console.log(doubleNumbersArray);\n}"
  },
  "doubledNumbers": {
    "name": "doubledNumbers",
    "slug": "TsVariable",
    "id": "yksshdidwrlhpcqwzgowoysk",
    "description": "",
    "operationName": "course-basics"
  },
  "getHighNumbers": {
    "name": "getHighNumbers",
    "slug": "TsFunction",
    "id": "nxvzijkciptrdvamiicnpzgy",
    "description": "",
    "operationName": "course-basics",
    "rawText": " (): number[] => {\n  const highNumbers = numbersArray.filter(\n    (number: number) => number >= minimumHighNumber\n  );\n  console.log(highNumbers);\n  return highNumbers;\n}"
  },
  "makeExercises": {
    "name": "makeExercises",
    "slug": "TsFunction",
    "id": "mrlawaqdfkdolbnzhxaplwfj",
    "description": "",
    "operationName": "course-basics",
    "rawText": " async () => {\n  const functions = await db.get(\"TsFunction\");\n\n  const exercises = functions.map((tsFunction) => {\n    const descriptionRequirement = tsFunction.description\n      ? `    - can be described like this: \n    \n    ${createCodeblockMarkdown(tsFunction.description, \"md\")}`\n      : undefined;\n\n    const parametersInfo = tsFunction.parameters?.map(\n      (functionParameter, index) => {\n        const requiredText = functionParameter.required\n          ? \"required\"\n          : \"optional\";\n        const parameterInfo = `Parameter ${index} is ${requiredText} can be called ${functionParameter.name} and should have a type ${functionParameter.simplifiedSchema?.type}`;\n\n        return parameterInfo;\n      }\n    );\n    const inputRequirement =\n      !tsFunction.parameters || tsFunction.parameters?.length === 0\n        ? \"Has no input parameters\"\n        : `Has ${\n            tsFunction.parameters?.length\n          } parameters: \\n\\n ${parametersInfo?.join(\"\\n\\n\")}`;\n\n    const outputRequirement = `Its return type should be ${tsFunction.returnType.rawType}`;\n    const requirements = [\n      descriptionRequirement,\n      inputRequirement,\n      outputRequirement,\n    ].filter(notEmpty);\n\n    const exercise = `Write a function named ${tsFunction.name} (related to ${\n      tsFunction.operationName\n    }). It has the following requirements:\n    \n${requirements.join(\"\\n\\n\")}`;\n\n    return exercise;\n  });\n\n  return exercises;\n}"
  },
  "minimumHighNumber": {
    "name": "minimumHighNumber",
    "slug": "TsVariable",
    "id": "dlfinkbcmeurjftxvdnkseve",
    "description": "",
    "operationName": "course-basics"
  },
  "newString": {
    "name": "newString",
    "slug": "TsVariable",
    "id": "qpnrsjluygmnqpmkurvaakij",
    "description": "",
    "operationName": "course-basics"
  },
  "numberStrings": {
    "name": "numberStrings",
    "slug": "TsVariable",
    "id": "hndjihhezxhnonmzrwqqiqds",
    "description": "",
    "operationName": "course-basics"
  },
  "numbers2": {
    "name": "numbers2",
    "slug": "TsVariable",
    "id": "eksxzninnszbaxhsjwxqumfk",
    "description": "",
    "operationName": "course-basics"
  },
  "numbersArray": {
    "name": "numbersArray",
    "slug": "TsVariable",
    "id": "nblcyembdklacuugglhhtamv",
    "description": "",
    "operationName": "course-basics"
  },
  "numbers": {
    "name": "numbers",
    "slug": "TsVariable",
    "id": "fvzgfgyezhbmwzgagfsgnrsv",
    "description": "",
    "operationName": "course-basics"
  },
  "string": {
    "name": "string",
    "slug": "TsVariable",
    "id": "nufnegjpxvuzsxaisaomyayo",
    "description": "",
    "operationName": "course-basics"
  },
  "sumNumbers": {
    "name": "sumNumbers",
    "slug": "TsFunction",
    "id": "txadqwozkqhvbwbuqjvxepvb",
    "description": "",
    "operationName": "course-basics",
    "rawText": " () => {\n  const sum = numbers.reduce((total, current) => {\n    return total + current;\n  }, 0);\n  console.log(sum);\n}"
  },
  "writeExercises": {
    "name": "writeExercises",
    "slug": "TsFunction",
    "id": "xrwbfqgjxohoavootbbjwotc",
    "description": "",
    "operationName": "course-basics",
    "rawText": " async () => {\n  const exercises = await makeExercises();\n  const assetsPath = path.join(__dirname, \"..\", \"assets\");\n  exercises.map((content, index) => {\n    writeStringToFile(path.join(assetsPath, `exersize${index}.md`), content);\n  });\n}"
  },
  "driverLogin": {
    "name": "driverLogin",
    "slug": "TsFunction",
    "id": "wnwohuploccnulnhqdrjtddk",
    "description": "login form for the driver to login",
    "operationName": "himalayajeep-functions",
    "rawText": " async (\n  emailOrPhone: string,\n  password: string\n): Promise<{\n  isSuccessful: boolean;\n  message: string;\n  loginToken?: string;\n}> => {\n  const jeeps = await db.get(\"JeepType\");\n\n  console.log({ password, emailOrPhone });\n\n  const augmentedJeeps = await Promise.all(\n    jeeps.map(async (jeep) => {\n      const passwordMatches = jeep.encrypedPassword\n        ? await comparePassword(password, jeep.encrypedPassword)\n        : false;\n\n      return { ...jeep, passwordMatches };\n    })\n  );\n\n  const ourJeep = augmentedJeeps.find((jeep) => {\n    const isHandleMatch =\n      jeep.phone === emailOrPhone || jeep.email === emailOrPhone;\n\n    if (isHandleMatch && jeep.passwordMatches) {\n      return true;\n    }\n\n    return false;\n  });\n\n  if (!ourJeep) {\n    return {\n      isSuccessful: false,\n      message: \"Couldn't find anyone with those credentials\",\n    };\n  }\n\n  return {\n    isSuccessful: true,\n    message: \"You're logged in\",\n    loginToken: ourJeep.loginToken,\n  };\n}"
  },
  "driverSignup": {
    "name": "driverSignup",
    "slug": "TsFunction",
    "id": "bgjyumkhfobamofsjycugszi",
    "description": "Driver signup",
    "operationName": "himalayajeep-functions",
    "rawText": " async (\n  driverInfo: SignupJeepType\n): Promise<{ isSuccesful: boolean; message: string }> => {\n  const loginToken = generateRandomString(32);\n\n  const { email, name, phone, password, repeatPassword } = driverInfo;\n\n  if (!name || name.length < 3) {\n    return {\n      isSuccesful: false,\n      message: \"Please enter a name (at least 3 characters)\",\n    };\n  }\n\n  if (!email && !phone) {\n    return {\n      isSuccesful: false,\n      message: \"Please enter a phone or email\",\n    };\n  }\n\n  if (phone && phone.length < 10) {\n    return {\n      isSuccesful: false,\n      message: \"Please enter a correct phone number\",\n    };\n  }\n\n  if (email && !isEmail(email)) {\n    return {\n      isSuccesful: false,\n      message: \"Please enter a correct email\",\n    };\n  }\n\n  if (password !== repeatPassword) {\n    return {\n      isSuccesful: false,\n      message: \"Those passwords do not match\",\n    };\n  }\n\n  if (!password || !isValidPassword(password)) {\n    return {\n      isSuccesful: false,\n      message: \"Please provide a safer password (min. 6 characters)\",\n    };\n  }\n\n  const encrypedPassword = encryptPassword(password);\n\n  const allCurrentJeeps = await db.get(\"JeepType\");\n\n  const foundEmailJeep = allCurrentJeeps.find((jeep) => jeep.email === email);\n  const isEmailCorrect = !email || !foundEmailJeep;\n\n  if (!isEmailCorrect) {\n    return {\n      isSuccesful: false,\n      message:\n        \"There is already a driver with that email. Please try logging in, or sign up with a different phone or email.\",\n    };\n  }\n\n  const foundPhoneJeep = allCurrentJeeps.find((jeep) => jeep.phone === phone);\n  const isPhoneCorrect = !phone || !foundPhoneJeep;\n\n  if (!isPhoneCorrect) {\n    return {\n      isSuccesful: false,\n      message:\n        \"There is already a driver with that phone number. Please try logging in, or sign up with a different phone or email.\",\n    };\n  }\n\n  const data: Creation<JeepType> | Creation<JeepType>[] = {\n    phone,\n    name,\n    email,\n    note: \"\",\n    amountLuggageUnitsLeft: 0,\n    amountSeatsLeft: 0,\n    isVerified: false,\n    loginToken,\n    encrypedPassword,\n  };\n  const config: UpsertQueryConfig | undefined = undefined;\n\n  //@ts-ignore\n  const upsertResult = await db.upsert(\"JeepType\", data, config);\n\n  if (upsertResult.isSuccesful === false) {\n    console.log({ upsertResult });\n    return { isSuccesful: false, message: \"Something went wrong\" };\n  }\n\n  return {\n    isSuccesful: true,\n    message:\n      \"You have succesfully registered. Your account now needs to be verified before your jeep will appear on the app. Please hang on and drive safely.\",\n  };\n}"
  },
  "getMyJeep": {
    "name": "getMyJeep",
    "slug": "TsFunction",
    "id": "gveonjibvhagkmbipeqifyyh",
    "description": "",
    "operationName": "himalayajeep-functions",
    "rawText": " async (\n  loginToken: string\n): Promise<{\n  isSuccessful: boolean;\n  message?: string;\n  myJeep?: MyJeepType;\n}> => {\n  const jeeps = await db.get(\"JeepType\");\n  const jeep = jeeps.find((x) => x.loginToken === loginToken);\n\n  if (!jeep) {\n    return {\n      isSuccessful: false,\n      message: \"Can't find that jeep\",\n    };\n  }\n\n  const {\n    amountLuggageUnitsLeft,\n    amountSeatsLeft,\n    createdAt,\n    id,\n    isVerified,\n    name,\n    note,\n    updatedAt,\n    citizenshipNumber,\n    email,\n    licenseNumber,\n    locationsCalculated,\n    numberPlate,\n    phone,\n  } = jeep;\n\n  const myJeep: MyJeepType = {\n    amountLuggageUnitsLeft,\n    amountSeatsLeft,\n    createdAt,\n    id,\n    isVerified,\n    name,\n    note,\n    updatedAt,\n    citizenshipNumber,\n    email,\n    licenseNumber,\n    locationsCalculated,\n    numberPlate,\n    phone,\n  };\n\n  return {\n    isSuccessful: true,\n    myJeep,\n  };\n}"
  },
  "getPublicJeeps": {
    "name": "getPublicJeeps",
    "slug": "TsFunction",
    "id": "ngoejujepsrddsgoopgoslpo",
    "description": "",
    "operationName": "himalayajeep-functions",
    "rawText": " async (\n  position?: Position\n): Promise<{\n  publicJeeps: PublicJeepType[];\n}> => {\n  const jeeps = await db.get(\"JeepType\");\n\n  const publicJeeps = jeeps.map((jeep) => {\n    const {\n      amountLuggageUnitsLeft,\n      amountSeatsLeft,\n      createdAt,\n      id,\n      name,\n      note,\n      updatedAt,\n      email,\n      locationsCalculated,\n      phone,\n    } = jeep;\n\n    const publicJeep: PublicJeepType = {\n      amountLuggageUnitsLeft,\n      amountSeatsLeft,\n      createdAt,\n      id,\n      name,\n      note,\n      updatedAt,\n      email,\n      locationsCalculated,\n      phone,\n    };\n\n    return publicJeep;\n  });\n\n  const sorted = publicJeeps.sort((a, b) => {\n    const distanceA = earthDistance(\n      a.locationsCalculated?.pop()?.latitude || 0,\n      a.locationsCalculated?.pop()?.longitude || 0,\n      position?.latitude || 0,\n      position?.longitude || 0,\n      \"m\"\n    );\n    const distanceB = earthDistance(\n      b.locationsCalculated?.pop()?.latitude || 0,\n      b.locationsCalculated?.pop()?.longitude || 0,\n      position?.latitude || 0,\n      position?.longitude || 0,\n      \"m\"\n    );\n\n    return distanceA < distanceB ? -1 : 1;\n  });\n\n  return {\n    publicJeeps: sorted,\n  };\n}"
  },
  "updateMyProfile": {
    "name": "updateMyProfile",
    "slug": "TsFunction",
    "id": "bbcitulgtnnozxbndzegutrh",
    "description": "",
    "operationName": "himalayajeep-functions",
    "rawText": " async (\n  loginToken: string,\n  myJeep: Omit<\n    MyJeepType,\n    \"id\" | \"createdAt\" | \"updatedAt\" | keyof MyJeepAdminTypes\n  >\n): Promise<{\n  isSuccesful: boolean;\n  message: string;\n}> => {\n  const jeeps = await db.get(\"JeepType\");\n  const jeep = jeeps.find((x) => x.loginToken === loginToken);\n\n  if (!jeep) {\n    return {\n      isSuccesful: false,\n      message: \"Can't find that jeep\",\n    };\n  }\n\n  const { isSuccesful, message } = await db.update(\n    \"JeepType\",\n    (item) => item.id === jeep.id,\n    (old) => {\n      const newJeep: JeepType = { ...old, ...myJeep };\n      return newJeep;\n    }\n  );\n\n  return {\n    isSuccesful: isSuccesful || false,\n    message: isSuccesful\n      ? \"You've updated your profile\"\n      : message || \"Something went wrong\",\n  };\n}"
  },
  "EditProfile": {
    "name": "EditProfile",
    "slug": "TsFunction",
    "id": "zihwwrckmzyyjkmzqotwkdem",
    "description": "",
    "operationName": "himalayajeep-ui",
    "rawText": " (props: MainPageProps) => {\n  const alert = useAlert();\n  const [loginToken] = useStore(\"api.loginToken\");\n\n  const myJeep = queries.useGetMyJeep(loginToken).data?.result?.myJeep;\n\n  console.log({ myJeep });\n  return (\n    <Layout pages={props.pages}>\n      <P>Edit profile</P>\n\n      {myJeep ? (\n        <FunctionForm\n          // filterParameters={(parameter: FunctionParameter) =>\n          //   parameter.name !== \"loginToken\"\n          // }\n          initialValues={[loginToken, myJeep]}\n          tsFunction={TsFunction}\n          withApiResult={(result: RealApiReturnType<\"updateMyProfile\">) => {\n            const title = result.result?.isSuccesful ? \"Successful\" : \"Error\";\n            const message =\n              result.result?.message ||\n              \"Something went wrong (no message avaiable)\";\n            alert?.(title, message);\n          }}\n        />\n      ) : null}\n    </Layout>\n  );\n}"
  },
  "getPageTitle": {
    "name": "getPageTitle",
    "slug": "TsFunction",
    "id": "pqurrzmjefcxxozckluzbtjp",
    "description": "utility function to get a title from a page",
    "operationName": "passionfruit-ui",
    "rawText": " (page: PageType) =>\n  page.title || page.key.charAt(0).toUpperCase().concat(page.key.slice(1))"
  },
  "JeepList": {
    "name": "JeepList",
    "slug": "TsFunction",
    "id": "xjchezrtjwrphpcdddjpqloc",
    "description": "",
    "operationName": "himalayajeep-ui",
    "rawText": " (props: MainPageProps) => {\n  const publicJeepsQuery = useGetPublicJeeps();\n\n  return (\n    <Layout pages={props.pages}>\n      {publicJeepsQuery.data?.result?.publicJeeps.map((item) => {\n        return <PublicJeep key={item.id} item={item} />;\n      })}\n    </Layout>\n  );\n}"
  },
  "JeepLogin": {
    "name": "JeepLogin",
    "slug": "TsFunction",
    "id": "vkgqgginmqblcfttfahngvth",
    "description": "",
    "operationName": "himalayajeep-ui",
    "rawText": " (props: MainPageProps) => {\n  const alert = useAlert();\n  const [loginToken, setLoginToken] = useStore(\"api.loginToken\");\n  return (\n    <Layout pages={props.pages}>\n      <P>Login page</P>\n\n      <FunctionForm\n        tsFunction={DriverLoginFunction}\n        withApiResult={(result: RealApiReturnType<\"driverLogin\">) => {\n          const title = result.result?.isSuccessful ? \"Logged in\" : \"Error\";\n          const message =\n            result.result?.message ||\n            \"Something went wrong (no message avaiable)\";\n\n          alert?.(title, message);\n          console.log({ result });\n\n          if (result.result?.loginToken) {\n            setLoginToken(result.result?.loginToken);\n          }\n        }}\n      />\n    </Layout>\n  );\n}"
  },
  "JeepSignupPage": {
    "name": "JeepSignupPage",
    "slug": "TsFunction",
    "id": "kyzchobqawzkkwwdjxahkspc",
    "description": "jeep driver needs to sign up",
    "operationName": "himalayajeep-ui",
    "rawText": " (props) => {\n  const alert = useAlert();\n\n  return (\n    <Layout pages={props.pages}>\n      <Div>\n        <P>Hello, please sign up here (drivers only)</P>\n\n        <FunctionForm\n          tsFunction={DriverSignupFunction}\n          withApiResult={(result: RealApiReturnType<\"driverSignup\">) => {\n            const title = result.result?.isSuccesful ? \"Signed up\" : \"Error\";\n            const message = result.result?.message || \"Something went wrong\";\n\n            alert?.(title, message);\n            result.result?.message;\n\n            console.log({ result });\n          }}\n        />\n      </Div>\n    </Layout>\n  );\n}"
  },
  "JeepView": {
    "name": "JeepView",
    "slug": "TsFunction",
    "id": "fhzsqygjykhaubbkjahrzuxm",
    "description": "",
    "operationName": "himalayajeep-ui",
    "rawText": " (props: MainPageProps) => {\n  return (\n    <Layout pages={props.pages}>\n      <P>Jeep view (viewing a single jeep with driver contact info, etc)</P>\n    </Layout>\n  );\n}"
  },
  "MenuItem": {
    "name": "MenuItem",
    "slug": "TsFunction",
    "id": "oobanjvtdrsaidaxyemaoxnf",
    "description": "",
    "operationName": "himalayajeep-ui",
    "rawText": " (props: { onClick: () => void; children: unknown }) => {\n  const { children, onClick } = props;\n\n  return (\n    <Div\n      className=\"cursor-pointer hover:bg-gray-200 py-4 pl-2\"\n      textClassName=\"hover:font-bold\"\n      onClick={onClick}\n    >\n      <P>{children}</P>\n    </Div>\n  );\n}"
  },
  "pageKeys": {
    "name": "pageKeys",
    "slug": "TsVariable",
    "id": "ggkxobdvkhzsluhidagtligm",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "pagesObject": {
    "name": "pagesObject",
    "slug": "TsVariable",
    "id": "tyhypvnprjhmupkqlryjzaar",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "pages": {
    "name": "pages",
    "slug": "TsVariable",
    "id": "olpksszmfvzhimhwwhycgdpd",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "PublicJeep": {
    "name": "PublicJeep",
    "slug": "TsFunction",
    "id": "sndyroavqakjqppnlneuzzwn",
    "description": "",
    "operationName": "himalayajeep-ui",
    "rawText": " (props: { item: PublicJeepType }) => {\n  const { item } = props;\n\n  return (\n    <Div className=\"p-2 border border-black m-2\">\n      <P>{item.name}</P>\n      <P>{item.amountSeatsLeft} seats left</P>\n      <P>{item.amountLuggageUnitsLeft} luggage spots left</P>\n\n      <P>{item.note}</P>\n    </Div>\n  );\n}"
  },
  "{ useGetPublicJeeps }": {
    "name": "{ useGetPublicJeeps }",
    "slug": "TsVariable",
    "id": "sbcooalgmcbvluhwheidthqe",
    "description": "",
    "operationName": "himalayajeep-ui"
  },
  "getAllOperations": {
    "name": "getAllOperations",
    "slug": "TsFunction",
    "id": "ukzglijjcixmlfokknektiik",
    "description": "",
    "operationName": "github-operation-sync",
    "rawText": " async (): Promise<Operation[]> => {\n  const operations = await db.get(\"Operation\");\n  return operations;\n}"
  },
  "getAllPackagesNames": {
    "name": "getAllPackagesNames",
    "slug": "TsFunction",
    "id": "atmitfjympqwpzcmedrqygab",
    "description": "",
    "operationName": "github-operation-sync",
    "rawText": " async () => {\n  const allPackagesNames = (await db.get(\"Operation\")).map((x) => x.name);\n  return allPackagesNames;\n}"
  },
  "getGithubPersonalAccessToken": {
    "name": "getGithubPersonalAccessToken",
    "slug": "TsFunction",
    "id": "uxmurixdqpapktzostulygye",
    "description": "",
    "operationName": "github-operation-sync",
    "rawText": " async () => {\n  const personalAccessToken = (await db.get(\"Persona\")).find(\n    (x) => !!x.githubAccessToken\n  )?.githubAccessToken;\n\n  return personalAccessToken;\n}"
  },
  "getGithubRepoLastCommitInfo": {
    "name": "getGithubRepoLastCommitInfo",
    "slug": "TsFunction",
    "id": "azefkvrleznvwhwyxozqpcoj",
    "description": "- see last commit datetime\n- see if it's after `lastPullTime` yes or no?\n- compare dates: `Operation.lastPullTime`, last file change in src, remote last commit time",
    "operationName": "github-operation-sync",
    "rawText": " async (\n  repoName: string,\n  personalAccessToken: string\n): Promise<{\n  isSuccessful: boolean;\n  message: string;\n  lastCommit?: CommitInfo;\n}> => {\n  try {\n    const octokit = new Octokit({\n      auth: personalAccessToken,\n    });\n\n    const repos = await octokit.rest.repos.listForAuthenticatedUser({\n      affiliation: \"owner,collaborator,organization_member\",\n      per_page: 100, //The number of results per page (max 100).\n      //page: 1 //Page number of the results to fetch.\n    });\n\n    const found = repos.data.find((repo: any) => repo.name === repoName);\n\n    if (!found) {\n      return {\n        isSuccessful: false,\n        message:\n          \"The repo owner WAS NOT FOUND !! \" +\n          \"repo list: \" +\n          JSON.stringify(repos.data.map((repo: any) => repo.name)),\n      };\n    }\n    /**\n      if the repo is found, get owner name, and get a list of commits.\n     */\n    const { data: arrayCommits } = await octokit.rest.repos.listCommits({\n      owner: found.owner.login,\n      repo: repoName,\n    });\n\n    const lastCommitAtDateString = arrayCommits[0].commit.author?.date;\n\n    const committedAt = lastCommitAtDateString\n      ? new Date(lastCommitAtDateString).valueOf()\n      : undefined;\n\n    const commitMessage = arrayCommits[0].commit.message;\n\n    return {\n      isSuccessful: true,\n      message: \"Checked Status Successfully.\",\n      lastCommit: {\n        commitSha: arrayCommits[0].sha,\n        committedAt,\n        commitMessage,\n      },\n    };\n  } catch (err: any) {\n    return {\n      isSuccessful: false,\n      message: JSON.stringify(err),\n    };\n  }\n}"
  },
  "getRepoNameFromRepositoryUrl": {
    "name": "getRepoNameFromRepositoryUrl",
    "slug": "TsFunction",
    "id": "yxrbhcacelykxefdmfvamjlv",
    "description": "",
    "operationName": "github-operation-sync",
    "rawText": " (\n  url: string\n): string | undefined => {\n  if (!url.startsWith(\"https://github.com/\")) return;\n\n  // TODO:\n  const parts = url.split(\"/\");\n\n  const lastPart = parts.pop(); // either the repoName or {repoName}.git\n\n  if (!lastPart) return;\n\n  if (lastPart.endsWith(\".git\")) {\n    return lastPart.slice(0, lastPart.length - \".git\".length);\n  }\n\n  return lastPart;\n}"
  },
  "initializeGitOrUseExistingAndPull": {
    "name": "initializeGitOrUseExistingAndPull",
    "slug": "TsFunction",
    "id": "bvxxrnxbrvldjjkiuvekoqcc",
    "description": "",
    "operationName": "github-operation-sync",
    "rawText": " async (\n  dir: string,\n  remoteUrl: string\n) => {\n  /** create simplegit options */\n  const options: Partial<SimpleGitOptions> = {\n    baseDir: dir,\n    binary: \"git\",\n    maxConcurrentProcesses: 6,\n    trimmed: false,\n  };\n  const gitBackupFolder = path.resolve(dir, \".git.backup\");\n  /** if the git.backup folder exists */\n  if (fs.existsSync(gitBackupFolder)) {\n    /** rename it to .git */\n    fs.renameSync(path.resolve(dir, \".git.backup\"), path.resolve(dir, \".git\"));\n    /** then add everything, commit and force pull */\n    const git: SimpleGit = simpleGit(options);\n    await git.pull(\"origin\", \"main\", [\"--force\"]);\n  } else {\n    /** if backup folder doesn't exist */\n    const gitFolder = path.resolve(dir, \".git\");\n    if (fs.existsSync(gitFolder)) {\n      fs.rmSync(gitFolder, { recursive: true, force: true });\n    }\n    const git: SimpleGit = simpleGit(options);\n    await git.init().addRemote(\"origin\", remoteUrl);\n    await git.pull(\"origin\", \"main\", [\"--force\"]);\n  }\n}"
  },
  "initializeGitOrUseExistingAndPush": {
    "name": "initializeGitOrUseExistingAndPush",
    "slug": "TsFunction",
    "id": "lfgyjsxaqjwilhuawhcpzolg",
    "description": "",
    "operationName": "github-operation-sync",
    "rawText": " async (\n  dir: string,\n  remoteUrl: string,\n  commitMessage: string\n) => {\n  /** create simplegit options */\n  const options: Partial<SimpleGitOptions> = {\n    baseDir: dir,\n    binary: \"git\",\n    maxConcurrentProcesses: 6,\n    trimmed: false,\n  };\n  const gitBackupFolder = path.resolve(dir, \".git.backup\");\n  /** if the git.backup folder exists */\n  if (fs.existsSync(gitBackupFolder)) {\n    console.log(\"renaming\");\n    /** rename it to .git */\n    fs.renameSync(path.resolve(dir, \".git.backup\"), path.resolve(dir, \".git\"));\n    /** then add everything, commit and force push */\n    const git: SimpleGit = simpleGit(options);\n    await git.add(\".\");\n    await git.commit(commitMessage);\n    await git.push(\"origin\", \"main\", [\"--force\"]);\n  } else {\n    console.log(\"deleting\");\n    /** if backup folder doesn't exist */\n    const gitFolder = path.resolve(dir, \".git\");\n    if (fs.existsSync(gitFolder)) {\n      fs.rmSync(gitFolder, { recursive: true, force: true });\n    }\n    const git: SimpleGit = simpleGit(options);\n    await git\n      .init({ \"--initial-branch\": \"main\" })\n      .addRemote(\"origin\", remoteUrl);\n    await git.add(\".\");\n    await git.commit(commitMessage);\n    await git.push(\"origin\", \"main\", [\"--force\"]);\n  }\n}"
  },
  "operationGithubPull": {
    "name": "operationGithubPull",
    "slug": "TsFunction",
    "id": "bpwnhknyltbfmdsafanugqyg",
    "description": "`git init` in operation\n`git set remote` in there\n`git pull --force`\n\nset operation.repository indexation info\n\n`mv .git .git.backup`",
    "operationName": "github-operation-sync",
    "rawText": " async (\n  operationName: string,\n  /**\n   * If you don't provide it we get it from the database\n   */\n  personalAccessToken?: string\n): Promise<{\n  isSuccessful: boolean;\n  message: string;\n  operationName?: string;\n}> => {\n  const projectRoot = getProjectRoot();\n\n  const operationsPath = getRootPath(\"operations\");\n  if (!projectRoot || !operationsPath) {\n    return { isSuccessful: false, message: \"No project root\" };\n  }\n\n  const realPersonalAccessToken =\n    personalAccessToken || (await getGithubPersonalAccessToken());\n\n  if (!realPersonalAccessToken) {\n    return {\n      isSuccessful: false,\n      message: \"Please provide PAT\",\n    };\n  }\n\n  const projectRelativeOperationPath = operations[\n    operationName as keyof typeof operations\n  ] as string | undefined;\n\n  const newPath = path.join(operationsPath, \"new\", operationName);\n\n  const absoluteOperationPath = projectRelativeOperationPath\n    ? path.join(projectRoot, projectRelativeOperationPath)\n    : newPath;\n\n  try {\n    const octokit = new Octokit({\n      auth: realPersonalAccessToken,\n    });\n\n    /**\n      docs: https://docs.github.com/en/rest/repos/repos#list-repositories-for-the-authenticated-user\n     */\n    const repos = await octokit.rest.repos.listForAuthenticatedUser({\n      affiliation: \"owner,collaborator,organization_member\",\n      per_page: 100, //The number of results per page (max 100).\n      //page: 1 //Page number of the results to fetch.\n    });\n\n    const found = repos.data.find((repo: any) => repo.name === operationName);\n\n    if (!found) {\n      return {\n        isSuccessful: false,\n        message: `Repository was not found for operation ${operationName}`,\n        operationName,\n      };\n    }\n\n    if (!fs.existsSync(absoluteOperationPath)) {\n      fs.mkdirSync(absoluteOperationPath);\n    }\n\n    const remoteUrl = found.ssh_url;\n\n    await initializeGitOrUseExistingAndPull(absoluteOperationPath, remoteUrl);\n\n    //docs: https://octokit.github.io/rest.js/v19#repos-list-collaborators\n    const collaborators = await octokit.rest.repos.listCollaborators({\n      owner: found.owner.login,\n      repo: found.name,\n      affiliation: \"all\", //outside | direct | all,\n      //per_page: 100, //The number of results per page (max 100).\n      //page: 1 //Page number of the results to fetch.\n    });\n    /** after everything rename the .git folder to .git.backup */\n    fs.renameSync(\n      path.join(absoluteOperationPath, \".git\"),\n      path.join(absoluteOperationPath, \".git.backup\")\n    );\n\n    const updateResult = await db.update(\n      \"Operation\",\n      (item) => item.operationName === operationName,\n      (old) => {\n        const newRepository: OperationRepositoryInfo = {\n          url: remoteUrl,\n          htmlUrl: found.html_url,\n          collaborators: collaborators.data.map(\n            (collaborator: any) => collaborator.login\n          ),\n          forksCount: found.forks_count,\n          stargazersCount: found.stargazers_count,\n          watchersCount: found.watchers_count,\n          openIssuesCount: found.open_issues_count,\n          size: found.size,\n          visibility: found.visibility,\n          defaultBranch: found.default_branch,\n        };\n        return { ...old, repository: newRepository };\n      }\n    );\n\n    const isSuccessful = updateResult.isSuccesful || false;\n\n    return {\n      isSuccessful,\n      message: isSuccessful\n        ? \"Pulled successfully, operation package.json has been updated\"\n        : updateResult.message || \"Something went wrong\",\n      operationName,\n    };\n  } catch (err) {\n    return {\n      isSuccessful: false,\n      message: \"Error: \" + err,\n      operationName,\n    };\n  }\n\n  //\n}"
  },
  "operationGithubPush": {
    "name": "operationGithubPush",
    "slug": "TsFunction",
    "id": "egubxigixgznfsiazyumqasf",
    "description": "",
    "operationName": "github-operation-sync",
    "rawText": " async (\n  operationName: string\n): Promise<PushOperationResult> => {\n  try {\n    /* \n\n    //This is breaking\n    //I'll just pass the operationName for now\n\n    const { repository } = (await db.get(\"PackageJson\", { operationName }))[0];\n\n    if (!repository) {\n      return {\n        success: false,\n        message: `target package.json has no \"repository\" field`,\n      };\n    }\n    */\n    // create repo if not existent\n    const octokit = new Octokit({\n      auth: process.env.PERSONAL_ACESSS_TOKEN,\n    });\n\n    const repos = await octokit.rest.repos.listForAuthenticatedUser({\n      affiliation: \"owner,collaborator,organization_member\",\n      per_page: 100, //The number of results per page (max 100).\n      //page: 1 //Page number of the results to fetch.\n    });\n\n    const repoName = operationName;\n    let createdRepoUrl = \"\";\n    /** If repo already exists in remote server */\n    const found = repos.data.find((repo: any) => repo.name === operationName);\n\n    if (found) {\n      const dir = path.resolve(PATH_TO_YOUR_BUNDLE, operationName);\n      await initializeGitOrUseExistingAndPush(\n        dir,\n        found.clone_url,\n        \"Improvements\"\n      );\n      /** after everything rename the .git folder to .git.backup */\n      fs.renameSync(\n        path.resolve(dir, \".git\"),\n        path.resolve(dir, \".git.backup\")\n      );\n      return {\n        success: true,\n        message: \"The repo already existed and was updated.\",\n        data: {\n          operationName,\n        },\n      };\n    } else {\n      //https://octokit.github.io/rest.js/v19#repos\n      //Creates a new repository for the authenticated user.\n      const { data: createdRepo } =\n        await octokit.rest.repos.createForAuthenticatedUser({\n          name: repoName,\n        });\n      createdRepoUrl = createdRepo.clone_url;\n\n      const dir = path.resolve(PATH_TO_YOUR_BUNDLE, operationName);\n\n      await initializeGitOrUseExistingAndPush(\n        dir,\n        createdRepo.clone_url,\n        \"first commit\"\n      );\n\n      return {\n        success: true,\n        message: \"Created repo url: \" + createdRepoUrl,\n        data: {\n          operationName,\n          createdRepoUrl,\n        },\n      };\n    }\n  } catch (err) {\n    return {\n      success: false,\n      message: \"Something went wrong !!!\" + JSON.stringify(err),\n      data: {\n        operationName,\n      },\n    };\n  }\n}"
  },
  "PATH_TO_YOUR_BUNDLE": {
    "name": "PATH_TO_YOUR_BUNDLE",
    "slug": "TsVariable",
    "id": "kxgaacfuhkmjgpitfcmdbprl",
    "description": "- git init\n- github create repo if not existent and then set `PackageJson.repository`\n- git set remote\n- git push --force\n- rm -rf .git\nâ€‹\n> Question: can we have a master git folder in the project root (main or bundle) without having to remove the `.git` every time? Maybe by renaming the `.git` in the operation to `operation.git` temporarily every time we don't use it? Probably better not to force pull/push every time and loose tons of git features...\nâ€‹\nTODO:\n\n1. put url on Operation `.repository.url`\n\nTODO: How do I get this path programatically ??",
    "operationName": "github-operation-sync"
  },
  "pullMultipleOperations": {
    "name": "pullMultipleOperations",
    "slug": "TsFunction",
    "id": "hordkioqjiitquzoejiekcdq",
    "description": "",
    "operationName": "github-operation-sync",
    "rawText": " async (\n  operationNames: string[]\n): Promise<{\n  isSuccessful: boolean;\n  message: string;\n  results?: {\n    isSuccessful: boolean;\n    message: string;\n    operationName?: string | undefined;\n  }[];\n}> => {\n  const personalAccessToken = await getGithubPersonalAccessToken();\n  if (!personalAccessToken) {\n    return {\n      isSuccessful: false,\n      message:\n        \"You don't have any persona setup with a GitHub personal access token, please update your Personas.\",\n    };\n  }\n\n  console.log(\"pulling multiple\");\n  const results = await Promise.all(\n    operationNames.map(async (operationName) =>\n      operationGithubPull(operationName, personalAccessToken)\n    )\n  );\n\n  console.log(\"returning pull multiple: \" + JSON.stringify(results));\n\n  return { isSuccessful: true, message: \"Yeah!\", results };\n}"
  },
  "pushMultipleOperations": {
    "name": "pushMultipleOperations",
    "slug": "TsFunction",
    "id": "swgvqvklxzzsgufqmizmndze",
    "description": "",
    "operationName": "github-operation-sync",
    "rawText": " async (operationNames: string[]) => {\n  let results: PushOperationResult[] = [];\n  console.log(\"pushing multiple\");\n  console.log(\"operation list: \" + JSON.stringify(operationNames));\n  await Promise.all(\n    operationNames.map(async (operationName) => {\n      const res = await operationGithubPush(operationName);\n      results.push(res);\n    })\n  );\n  console.log(\"returning push multiple: \" + JSON.stringify(results));\n  return results;\n}"
  },
  "readAndWriteToPackageJsonExample": {
    "name": "readAndWriteToPackageJsonExample",
    "slug": "TsFunction",
    "id": "bvqtvegdifkkwfmqbwwtyphu",
    "description": "",
    "operationName": "github-operation-sync",
    "rawText": " async () => {\n  //TODO:REFACTOR\n  const result = (\n    await db.get(\"Operation\", { operationName: \"nodejs-test\" })\n  )[0];\n\n  await db.update(\n    \"Operation\",\n    (item) => item.operationName === \"nodejs-test\",\n    (old) => {\n      if (old.repository) {\n        //\n      }\n      return { ...old, repository: \"test-repository.com\" };\n    }\n  );\n  // return result.repository;\n}"
  },
  "updateAllOperationStatusTest": {
    "name": "updateAllOperationStatusTest",
    "slug": "TsFunction",
    "id": "ejeuaqxrbaxohhtbmtfvfbjs",
    "description": "",
    "operationName": "github-operation-sync",
    "rawText": " async () => {\n  const result = await updateAllOperationStatus(true);\n}"
  },
  "updateAllOperationStatus": {
    "name": "updateAllOperationStatus",
    "slug": "TsFunction",
    "id": "dlqgzlkgmblsekqcpvafwsmc",
    "description": "---\n---\n\nrunEveryPeriod: hour\n\nTODO: TEST, then do this",
    "operationName": "github-operation-sync",
    "rawText": " async (\n  dryrun?: boolean\n): Promise<{\n  isSuccessful: boolean;\n  message?: string;\n}> => {\n  const operations = await db.get(\"Operation\");\n\n  const personalAccessToken = (await db.get(\"Persona\")).find(\n    (x) => !!x.githubAccessToken\n  )?.githubAccessToken;\n\n  if (!personalAccessToken) {\n    return {\n      isSuccessful: false,\n      message:\n        \"You don't have any persona setup with a GitHub personal access token, please update your Personas.\",\n    };\n  }\n\n  const operationNameWithLastCommitInfoArray = (\n    await mapMany(\n      operations,\n      async (operation) => {\n        if (!operation.repository) {\n          log(`No repository found for ${operation.name}`, { type: \"warning\" });\n          return;\n        }\n\n        const repoName =\n          typeof operation.repository === \"string\"\n            ? getRepoNameFromRepositoryUrl(operation.repository)\n            : getRepoNameFromRepositoryUrl(operation.repository.url);\n\n        if (!repoName) {\n          log(`No repoName found for ${operation.name}`, { type: \"warning\" });\n          return;\n        }\n\n        const status = await getGithubRepoLastCommitInfo(\n          repoName,\n          personalAccessToken\n        );\n\n        if (!status.isSuccessful || !status.lastCommit) return;\n\n        return {\n          lastCommit: status.lastCommit,\n          name: operation.name,\n        };\n      },\n      10\n    )\n  ).filter(notEmpty);\n\n  if (dryrun) {\n    console.log({\n      operationNameWithLastCommitInfoArray,\n    });\n\n    return { isSuccessful: true, message: \"Did dryrun\" };\n  }\n\n  const updateResult = await db.update(\n    \"Operation\",\n    () => true,\n    (old) => {\n      const lastCommitInfo = operationNameWithLastCommitInfoArray.find(\n        (x) => x.name === old.name\n      )?.lastCommit;\n\n      if (!lastCommitInfo) return old;\n\n      // const newOperation = mergeNestedObject(old, {\n      //   operation: { lastCommitInfo },\n      // });\n\n      const url =\n        typeof old.repository === \"string\"\n          ? old.repository\n          : old.repository?.url;\n\n      const oldRepositoryInfo =\n        typeof old.repository === \"object\" ? old.repository : {};\n\n      const newRepository: OperationRepositoryInfo = {\n        url: url!,\n        ...oldRepositoryInfo,\n        lastCommitInfo,\n      };\n\n      return { ...old, repository: newRepository };\n    }\n  );\n\n  return {\n    isSuccessful: updateResult.isSuccesful || false,\n    message: updateResult.message,\n  };\n}"
  },
  "migratePackageJsonToOperation": {
    "name": "migratePackageJsonToOperation",
    "slug": "TsFunction",
    "id": "iopoaanccftvwuwxpuqhzszd",
    "description": "- put `PackageJson`, `OperationIndex` and `OperationConfig` into a migration typescript script (get from backup).\n- migrate all of those into `package.json` to apply new `Operation` model. Use `readJsonFile`, `readMarkdownFile` and `writeJsonFile` instead of `db.udpate`. First write to `assets` to check if it works well.",
    "operationName": "migrate-operation-model",
    "rawText": " () => {\n  forAllFolders({\n    type: \"operations\",\n    basePath: getPathsWithOperations(),\n    callback: async (folderPath, index) => {\n      const operationName = getLastFolder(folderPath);\n      log(`#${index}: Migrating ${operationName}`, {\n        type: \"success\",\n      });\n\n      const packageJsonPath = path.join(folderPath, \"package.json\");\n      const operationIndexPath = path.join(\n        folderPath,\n        \"db\",\n        \"operation-index.json\"\n      );\n      const operationConfigPath = path.join(folderPath, \"OPERATION.md\");\n\n      const markdownParse = await readMarkdownFile(operationConfigPath);\n      const operationConfig: OperationConfig | undefined = markdownParse\n        ? ({\n            ...markdownParse.parameters,\n            markdown: markdownParse.raw,\n          } as OperationConfig)\n        : undefined;\n      const packageJson = await readJsonFile<PackageJson>(packageJsonPath);\n      const operationIndex = await readJsonFile<OperationIndex>(\n        operationIndexPath\n      );\n\n      if (!packageJson) {\n        console.log(`wtf ${folderPath} , ${!!packageJson} ${!!operationIndex}`);\n        return;\n      }\n\n      const {\n        id,\n        author,\n        bin,\n        dependencies,\n        description,\n        devDependencies,\n        homepage,\n        main,\n        peerDependencies,\n        repository,\n        scripts,\n        source,\n        version,\n        workspaces,\n      } = packageJson;\n\n      const {\n        buildSucceeded,\n        classification: uncastedClassification,\n        coreDependencies,\n        createdAt,\n        createdFirstAt,\n        deletedAt,\n        dependenciesBuildsFailed,\n        folderName,\n        indexErrors,\n        indexImportExportError,\n        indexInteracesErrors,\n        language,\n        lintProblems,\n        name,\n        operationDependencies,\n        operationRelativePath,\n        packageDependencies,\n        packageName,\n        projectRelativePath,\n        relativeOperationLocationPath,\n        size,\n        slug,\n        updatedAt,\n      } = destructureOptionalObject(operationIndex);\n\n      const classification = uncastedClassification as any;\n\n      // NB: i also did the `OperationClassification` refactor...\n      const classificationIndexed =\n        classification === \"js\"\n          ? \"cjs\"\n          : classification === \"node\"\n          ? \"node-cjs\"\n          : classification === \"server\"\n          ? \"server-cjs\"\n          : classification === \"web\"\n          ? \"ui-web\"\n          : classification === \"app\"\n          ? \"ui-app\"\n          : classification === \"ui-es5\"\n          ? \"ui-cjs\"\n          : classification === \"ui-es6\"\n          ? \"ui-ts\"\n          : classification;\n      const {\n        authors,\n        contributors,\n        indirectDependencies,\n        shortDescriptionText,\n        markdown,\n      } = destructureOptionalObject(operationConfig);\n\n      if (!packageJson.name) {\n        console.log(\"no name for \", packageJson);\n        return;\n      }\n      const operation: Omit<Operation, \"projectRelativePath\"> = {\n        id,\n        operationName,\n        author,\n        bin,\n        dependencies,\n        description,\n        devDependencies,\n        homepage,\n        main,\n        path: packageJson.path,\n        peerDependencies,\n        private: packageJson.private,\n        repository,\n        scripts,\n        source,\n        version,\n        workspaces,\n        name: packageJson.name,\n        createdAt: Date.now(),\n        createdFirstAt: Date.now(),\n        deletedAt: 0,\n        language: \"english\",\n        slug: packageJson.name,\n        updatedAt: Date.now(),\n        operation: {\n          authors: operationConfig?.authors,\n          buildResultIndexed: {\n            buildSucceeded,\n            dependenciesBuildsFailed,\n            indexErrors,\n            indexImportExportError,\n            indexInteracesErrors,\n            lintProblems,\n          },\n          classificationIndexed,\n          contributors,\n          coreDependenciesIndexed: coreDependencies,\n          folderNameIndexed: folderName,\n          hasGeneratedDependenciesIndexed:\n            packageJson.sensible?.hasGeneratedDependencies,\n          indirectDependencies:\n            indirectDependencies || packageJson.operation?.indirectDependencies,\n          isBundle: packageJson.sensible?.isSensibleProject,\n          isNotSdkable: packageJson.sensible?.isNotSdkable,\n          lastPullTimeAtIndexed: 0,\n          lastRebuildAt: 0,\n          operationDependenciesIndexed: operationDependencies,\n          packageDependenciesIndexed: packageDependencies,\n          relativeOperationLocationPathIndexed: relativeOperationLocationPath,\n          markdown,\n          sizeIndexed: size,\n          skipMinify: packageJson.sensible?.skipMinify,\n        },\n      };\n\n      // await writeToAssets(__filename, operation, `${packageJson.name}.json`);\n      await db.update(\n        \"Operation\",\n        (item) => item.name === packageJson.name,\n        (old) => ({\n          ...operation,\n          projectRelativePath: old.projectRelativePath,\n        }),\n        { operationName: packageJson.name }\n      );\n    },\n  });\n}"
  },
  "calculateFullCompany": {
    "name": "calculateFullCompany",
    "slug": "TsFunction",
    "id": "nixyvfhtixipzrlrvxcwvgmx",
    "description": "Gets a full `Company` with all of its calculated properties, of a single company. A lot of information is needed to calculate this. Aggregates all functions that calculate every calculated property of an individual company.\n\n1. uses `companyAttachContributionInformation` function.\n2. uses `companyAttachRequirements` function\n3. uses `companyAttachTransparency` function.\n4. uses `companyAttachEsgMetricProofStates` function.\n\nReturns `Company` with all calculated properties",
    "operationName": "foodchain-recipes",
    "rawText": " (\n  company: Company,\n  data: {\n    contributions: Contribution[];\n    locations: Location[];\n    companyRequirements: CompanyRequirement[];\n    proofStates: ProofState[];\n    esgMetrics: EsgMetric[];\n  }\n): Company => {\n  const {\n    companyRequirements,\n    contributions,\n    esgMetrics,\n    locations,\n    proofStates,\n  } = data;\n\n  const companyWithContributionInformation =\n    companyAttachContributionInformation(company, contributions, locations);\n\n  const companyWithRequirements = companyAttachRequirements(\n    companyWithContributionInformation,\n    companyRequirements,\n    proofStates\n  );\n\n  const companyWithTransparency = companyAttachTransparency(\n    companyWithRequirements\n  );\n\n  const fullCompany = companyAttachEsgMetricProofStates(\n    companyWithTransparency,\n    esgMetrics,\n    proofStates\n  );\n\n  return fullCompany;\n}"
  },
  "companyAttachContributionInformation": {
    "name": "companyAttachContributionInformation",
    "slug": "TsFunction",
    "id": "pjmiiktupptawfpukippoawf",
    "description": "Attach contribution information to a company\n\nAttaches these fields:\n\n- `contribution_productSlugsCalculated`\n- `contribution_locationSlugsCalculated`\n- `contribution_activitySlugsCalculated`\n\nNB: we need `valueChainPhase` on every contribution!",
    "operationName": "foodchain-recipes",
    "rawText": " (\n  company: Company,\n  contributions: Contribution[],\n  locations: Location[]\n) => {\n  const companyContributions = contributions.filter(\n    (contribution) => contribution.companySlug === company.slug\n  );\n\n  const contribution_productSlugsCalculated = companyContributions\n    .map((contribution) => {\n      const productSlugs = [\n        contribution.sub_productSlug,\n        contribution.final_productSlug,\n      ].filter(notEmpty);\n\n      return productSlugs;\n    })\n    .flat()\n    .filter(onlyUnique2());\n\n  const contribution_rootLocationSlugs = companyContributions\n    .map((contribution) => contribution.locationSlug)\n    .filter(notEmpty);\n\n  // NB: also get the complete stack, so if someone operates in Milan, they also operate in Italy and Europe\n  const contribution_locationSlugsCalculated = contribution_rootLocationSlugs\n    .map((locationSlug) => {\n      const categoryStack = locations.find(\n        (x) => x.slug === locationSlug\n      )?.categoryStack;\n      return categoryStack ? [locationSlug, ...categoryStack] : [locationSlug];\n    })\n    .flat()\n    .filter(onlyUnique2());\n\n  const contribution_activitySlugsCalculated = companyContributions\n    .map((contribution) => contribution.valueChainPhase?.activitySlug)\n    .filter(notEmpty);\n\n  const contribution_tiersCalculated = companyContributions\n    .map((contribution) => contribution.tier)\n    .filter(notEmpty);\n\n  const augmentedCompany: Company = {\n    ...company,\n    contribution_productSlugsCalculated,\n    contribution_locationSlugsCalculated,\n    contribution_activitySlugsCalculated,\n    contribution_tiersCalculated,\n  };\n\n  return augmentedCompany;\n}"
  },
  "companyAttachEsgMetricProofStates": {
    "name": "companyAttachEsgMetricProofStates",
    "slug": "TsFunction",
    "id": "ugcdokgvbfxpfpicbgqchsjm",
    "description": "attaches `companyEsgMetricProofStatesCalculated` to company",
    "operationName": "foodchain-recipes",
    "rawText": " (\n  company: Company,\n  esgMetrics: EsgMetric[],\n  proofStates: ProofState[]\n): Company => {\n  const companyProofStates = proofStates.filter(\n    (x) => x.companyId === company.id\n  );\n\n  const companyEsgMetricProofStatesCalculated = esgMetrics.map((esgMetric) => {\n    // Step 1: get all esg metrics, including all children\n    const allChildren = esgMetrics.filter((x) =>\n      x.categoryStack.includes(esgMetric.slug)\n    );\n    const all = allChildren.concat(esgMetric);\n\n    // Step 2: group the `ProofState`s by their status for the esgMetric\n    const negativeProofsCalculated = companyProofStates.filter((proofState) => {\n      return hasEsgMetricWithStatus(\"negative\", proofState, all);\n    });\n    const positiveProofsCalculated = companyProofStates.filter((proofState) => {\n      return hasEsgMetricWithStatus(\"positive\", proofState, all);\n    });\n    const notAssessedProofsCalculated = companyProofStates.filter(\n      (proofState) => {\n        return hasEsgMetricWithStatus(\"notAssessed\", proofState, all);\n      }\n    );\n\n    const augmentedEsgMetric: EsgMetric = {\n      ...esgMetric,\n      positiveProofsCalculated,\n      negativeProofsCalculated,\n      notAssessedProofsCalculated,\n    };\n\n    /*\n    if (company.id === \"xiLfwwQieCiSPQSR\") {\n      console.log(\"xiLfwwQieCiSPQSR\", {\n        proofStates: proofStates.length,\n        companyProofStates: companyProofStates.length,\n        neg: negativeProofsCalculated.length,\n        positiveProofsCalculated: positiveProofsCalculated.length,\n        notAssessedProofsCalculated: notAssessedProofsCalculated.length,\n      });\n    }*/\n\n    return augmentedEsgMetric;\n  });\n\n  const augmentedCompany: Company = {\n    ...company,\n    companyEsgMetricProofStatesCalculated,\n  };\n\n  return augmentedCompany;\n}"
  },
  "companyAttachRequirements": {
    "name": "companyAttachRequirements",
    "slug": "TsFunction",
    "id": "cdrizhbjxionvnnppmvmhihw",
    "description": "Attaches the requirements that apply to a company and then attaches the proofstates to every requirement. Returns a company with `companyRequirementsCalculated` with that information",
    "operationName": "foodchain-recipes",
    "rawText": " (\n  company: Company,\n  companyRequirements: CompanyRequirement[],\n  proofStates: ProofState[]\n): Company => {\n  // Step 2: Check which requirements apply to this company\n  const companyRequirementsCalculated = companyRequirements\n    .filter(\n      (requirement) =>\n        requirementAppliesToCompany(company, requirement).hasAllRequirements\n    )\n    .map((requirement) =>\n      requirementAttachProofStates(company, requirement, proofStates)\n    );\n\n  return {\n    ...company,\n    companyRequirementsCalculated,\n  };\n}"
  },
  "companyAttachTransparency": {
    "name": "companyAttachTransparency",
    "slug": "TsFunction",
    "id": "hagsmtpgtgjdzoxoiyegeaaa",
    "description": "",
    "operationName": "foodchain-recipes",
    "rawText": " (company: Company) => {\n  if (!company.companyRequirementsCalculated) {\n    return company;\n  }\n\n  const requiredFormFields: (keyof Company)[] = [\n    \"name\",\n    \"ggn\",\n    \"address\",\n    \"location\",\n    // \"branches\",\n    \"companySize\",\n    \"companyType\",\n  ];\n\n  const notFilledInFormFields = requiredFormFields.filter((fieldKey) => {\n    return company[fieldKey] === undefined;\n  });\n\n  const notFilledInFormFieldsCount = notFilledInFormFields.length;\n\n  const totalFormFields = requiredFormFields.length;\n\n  const filledInFormFieldsCount = totalFormFields - notFilledInFormFieldsCount;\n\n  /*\n  \n    Company.name\n    Company.ggn\n    Company.address\n    Company.locationSlug\n    Company.branches\n    Company.companySize\n    Company.companyType\n  \n    formScore = count / 7  (%)\n    \n    */\n\n  const formScore = filledInFormFieldsCount / totalFormFields;\n\n  /**\n  \n    Company.companyRequirementsCalculated[].company_proofStatesCalculated[].status\n  \n    requirementScore = doing/done requirements (for at least one proof) / total requirements (%)\n  \n    */\n\n  const filterHasNoDoingOrDoneProof = (\n    requirement: CompanyRequirement\n  ): boolean => {\n    const todoProofs = requirement.company_proofStatesCalculated\n      ? requirement.company_proofStatesCalculated.filter(\n          (proofState) => proofState.status === \"todo\"\n        )\n      : [];\n\n    const hasNoDoingOrDoneProof =\n      todoProofs.length ===\n      (requirement.company_proofStatesCalculated?.length || 0);\n\n    return hasNoDoingOrDoneProof;\n  };\n\n  const requirementsTodo = company.companyRequirementsCalculated.filter(\n    filterHasNoDoingOrDoneProof\n  );\n\n  const requirementsTodoNames = requirementsTodo.map((requirement) =>\n    requirement.proofSlugs\n      ? requirement.proofSlugs?.flatMap((proof) => proof).join(\", \")\n      : \"\"\n  );\n\n  const requirementsTodoCount = requirementsTodo.length;\n  const totalRequirements = company.companyRequirementsCalculated.length;\n  const totalRequirementsHasDoingOrDone =\n    totalRequirements - requirementsTodoCount;\n\n  const requirementScore =\n    totalRequirements === 0\n      ? 1\n      : totalRequirementsHasDoingOrDone / totalRequirements;\n\n  /**\n   * TOTAL transparency = (formScore + requirementScore) / 2 = %\n   */\n  const transparencyPercentageCalculated = Math.round(\n    ((formScore + requirementScore) / 2) * 100\n  );\n\n  const transparencyDetailsCalculated = {\n    notFilledInFormFields,\n    formScore,\n    requirementScore,\n    requirementsTodoNames,\n  };\n\n  const fullCompany: Company = {\n    ...company,\n    transparencyDetailsCalculated,\n    transparencyPercentageCalculated,\n    numberOfOpenRequirementsCalculated: requirementsTodoCount,\n  };\n\n  return fullCompany;\n}"
  },
  "concatenateItems": {
    "name": "concatenateItems",
    "slug": "TsFunction",
    "id": "lyiomjfcamwwkiowvdhqjelv",
    "description": "Concatenates two arrays of `AugmentedAnyModelType`, ensuring there are no duplicates",
    "operationName": "foodchain-recipes",
    "rawText": " <T extends AugmentedAnyModelType>(\n  a: T[] | undefined,\n  b: T[] | undefined\n) => {\n  const firstKey = (a || []) as T[];\n  const secondKey = (b || []) as T[];\n\n  if (!Array.isArray(firstKey) || !Array.isArray(secondKey)) return;\n\n  const concatenated = [...firstKey, ...secondKey] as T[];\n\n  const unique = concatenated.filter(onlyUnique2<T>((a, b) => a.id === b.id));\n\n  return unique;\n}"
  },
  "contributionAddNextContributions": {
    "name": "contributionAddNextContributions",
    "slug": "TsFunction",
    "id": "yvrwbufumijxexkjxkyjpbor",
    "description": "Adds `next_contributionsCalculated` to a contribution",
    "operationName": "foodchain-recipes",
    "rawText": " (\n  contribution: Contribution,\n  index: number,\n  contributions: Contribution[]\n) => {\n  const next_contributionsCalculated = contributions.filter((x) =>\n    x.previous_contributionIds?.includes(contribution.id)\n  );\n\n  const fullContribution: Contribution = {\n    ...contribution,\n    next_contributionsCalculated,\n  };\n\n  return fullContribution;\n}"
  },
  "getActivities": {
    "name": "getActivities",
    "slug": "TsFunction",
    "id": "gsqzzonijpusdqudykddglfv",
    "description": "Endpoint that returns all activities, and for every activity,\n\n- all companies that do this activity in one of their contributions\n- `esgMetricProofStatesCalculated`\n- average transparency for all companies doing the activity",
    "operationName": "foodchain-recipes",
    "rawText": " async (): Promise<Activity[]> => {\n  const rawCompanys = await db.get(\"Company\");\n\n  const fullCompanyData = await getFullCompanyData();\n  const companies: Company[] = rawCompanys.map((company) =>\n    calculateFullCompany(company, fullCompanyData)\n  );\n\n  const activities = (await db.get(\"Activity\")).map((activity) => {\n    const companysCalculated = companies.filter((x) =>\n      x.contribution_activitySlugsCalculated?.includes(activity.slug)\n    );\n\n    const esgMetricProofStatesCalculated =\n      sumEsgMetricProofStates(companysCalculated);\n\n    const averageTransparencyPercentageCalculated = getAverage(\n      companysCalculated.map(\n        (company) => company.transparencyPercentageCalculated!\n      )\n    );\n\n    const fullActivity: Activity = {\n      ...activity,\n      companysCalculated,\n      esgMetricProofStatesCalculated,\n      averageTransparencyPercentageCalculated,\n    };\n\n    return fullActivity;\n  });\n\n  return activities;\n}"
  },
  "getAverage": {
    "name": "getAverage",
    "slug": "TsFunction",
    "id": "wygtxbsfmsswfbzsycdmzqyp",
    "description": "Get an average of a number array",
    "operationName": "foodchain-recipes",
    "rawText": " (numbers: number[]): number => {\n  if (numbers.length === 0) return 0;\n\n  const sum = numbers.reduce((total, number) => total + number, 0);\n\n  return sum / numbers.length;\n}"
  },
  "getCompanies": {
    "name": "getCompanies",
    "slug": "TsFunction",
    "id": "rquxmbmgbvtkhhpbrzzwossu",
    "description": "Returns fully calculated `Company`[]",
    "operationName": "foodchain-recipes",
    "rawText": " async (): Promise<Company[]> => {\n  const rawCompanies = await db.get(\"Company\", {\n    include: [\n      { referenceKey: \"companyTypeSlug\" },\n      { referenceKey: \"companySizeSlug\" },\n      { referenceKey: \"locationSlug\" },\n    ],\n  });\n\n  const fullCompanyData = await getFullCompanyData();\n  const companies: Company[] = rawCompanies.map((company) =>\n    calculateFullCompany(company, fullCompanyData)\n  );\n\n  return companies;\n}"
  },
  "getFinalProducts": {
    "name": "getFinalProducts",
    "slug": "TsFunction",
    "id": "jyswrtgfolwvuudyoiyidoop",
    "description": "Listing all value chain main products\n\nTODO: make this faster",
    "operationName": "foodchain-recipes",
    "rawText": " async (): Promise<ProductValueChain[]> => {\n  const finalProducts = await db.get(\"Product\", {\n    filter: (item) => item.productType === \"finalProduct\",\n  });\n\n  const data = await getRequiredValueChainData();\n  const finalProductValueChainPromises = finalProducts.map((product) =>\n    getProductValueChainForProduct(product, data)\n  );\n\n  const finalProductValueChains = (\n    await Promise.all(finalProductValueChainPromises)\n  ).filter(notEmpty);\n  return finalProductValueChains;\n}"
  },
  "getFullCompanyData": {
    "name": "getFullCompanyData",
    "slug": "TsFunction",
    "id": "prenvygzhnamnrdlrqrfzwmb",
    "description": "gets all data required for the function `calculateFullCompany` from the db",
    "operationName": "foodchain-recipes",
    "rawText": " async () => {\n  const contributions = await db.get(\"Contribution\", {\n    include: { referenceKey: \"valueChainPhaseSlug\" },\n  });\n  const locations = await db.get(\"Location\");\n  const companyRequirements = await db.get(\"CompanyRequirement\", {\n    include: [\n      { referenceKey: \"esgMetricSlugs\" },\n      // NB: we don't support categories here yet, just individual proofs\n      { referenceKey: \"proofSlugs\" },\n    ],\n  });\n  const proofStates = await db.get(\"ProofState\");\n  const esgMetrics = await db.get(\"EsgMetric\");\n\n  return {\n    contributions,\n    locations,\n    companyRequirements,\n    proofStates,\n    esgMetrics,\n  };\n}"
  },
  "getIngredientProducts": {
    "name": "getIngredientProducts",
    "slug": "TsFunction",
    "id": "vbuwindtfkxrgrxmufnwwfxw",
    "description": "listing all ingredient products",
    "operationName": "foodchain-recipes",
    "rawText": " async () => {\n  const products = await db.get(\"Product\", {\n    include: { referenceKey: \"productCategorySlug\" },\n  });\n\n  const ingredientProducts = products.filter(\n    (x) => x.productType === \"ingredient\"\n  );\n  return ingredientProducts;\n}"
  },
  "getProductValueChainForProduct": {
    "name": "getProductValueChainForProduct",
    "slug": "TsFunction",
    "id": "bpuxstpppkttpdjkrbgyrkpw",
    "description": "Gets the `ProductValueChain` for a `Product` with `type`=\"final\"",
    "operationName": "foodchain-recipes",
    "rawText": " async (\n  /**\n   * must be a final product\n   */\n  product: Product,\n  data: ProductValueChainData\n): Promise<undefined | ProductValueChain> => {\n  const {\n    companyRequirements,\n    contributions,\n    locations,\n    proofStates,\n    valueChainPhases,\n    esgMetrics,\n  } = data;\n  if (product.productType !== \"finalProduct\") return;\n\n  const contributionsWithTransparency = contributions\n    .filter((contribution) => contribution.final_productSlug === product.slug)\n    .map((contribution) => {\n      if (!contribution.company) return contribution;\n\n      const fullCompany = calculateFullCompany(contribution.company, {\n        contributions,\n        locations,\n        companyRequirements,\n        proofStates,\n        esgMetrics,\n      });\n\n      console.log(fullCompany);\n      return { ...contribution, company: fullCompany };\n    })\n    .map(contributionAddNextContributions);\n\n  const sub_products = contributionsWithTransparency\n    .map((x) => x.sub_product)\n    .filter(notEmpty);\n  const companys = contributionsWithTransparency\n    .map((x) => x.company)\n    .filter(notEmpty);\n\n  const thisValueChainPhases = valueChainPhases\n    .filter((x) => x.productSlug === product.slug)\n    .map((phase) => {\n      const allContributionTransparencyPercentages =\n        contributionsWithTransparency\n          .filter((x) => x.valueChainPhaseSlug === phase.slug)\n          .map((x) => x.company?.transparencyPercentageCalculated)\n          .filter(notEmpty);\n\n      const transparencyPercentageCalculated = getAverage(\n        allContributionTransparencyPercentages\n      );\n\n      return { ...phase, transparencyPercentageCalculated };\n    });\n\n  const activeInCountriesCalculated = contributionsWithTransparency\n    .map((x) => {\n      // NB: gets the country, which is either the first thing in the categorystack (if the location is a city) or just the main slug of the location (if the location is a country already)\n      const country = x.location\n        ? x.location.categoryStack && x.location.categoryStack.length > 0\n          ? x.location.categoryStack[0]\n          : x.location.slug\n        : undefined;\n\n      // console.log({ name: x.name, country });\n\n      return country;\n    })\n    .filter(notEmpty)\n    .filter(onlyUnique2());\n\n  const amountOfContributionsCalculated = contributionsWithTransparency.length;\n\n  const contributionTransparencyPercentages = contributionsWithTransparency\n    .map((x) => x.company?.transparencyPercentageCalculated)\n    .filter(notEmpty);\n  const transparencyPercentageCalculated = getAverage(\n    contributionTransparencyPercentages\n  );\n  const amountOpenRequirementsCalculated = companys\n    .map((x) => x.numberOfOpenRequirementsCalculated)\n    .reduce((total, number) => total + number, 0);\n\n  const esgMetricProofStatesCalculated = sumEsgMetricProofStates(companys);\n\n  const productValueChain: ProductValueChain = {\n    product,\n    productId: product.id,\n    name: product.name,\n    slug: product.slug,\n    description: product.description,\n\n    activeInCountriesCalculated,\n    amountOfContributionsCalculated,\n    transparencyPercentageCalculated,\n    amountOpenRequirementsCalculated,\n    esgMetricProofStatesCalculated,\n    // all products therein\n    contributions: contributionsWithTransparency,\n    companys,\n    sub_products,\n    valueChainPhases: thisValueChainPhases,\n  };\n\n  return productValueChain;\n}"
  },
  "getProductValueChain": {
    "name": "getProductValueChain",
    "slug": "TsFunction",
    "id": "pbvmvhuwhglkdjjqdijkevph",
    "description": "showing a complete value chain",
    "operationName": "foodchain-recipes",
    "rawText": " async (\n  finalProductId: string\n): Promise<{\n  success: boolean;\n  message?: string;\n  productValueChain?: ProductValueChain;\n}> => {\n  const allProducts = await db.get(\"Product\");\n  const product = allProducts.find(\n    (x) => x.id === finalProductId && x.productType === \"finalProduct\"\n  );\n\n  if (!product) {\n    return { success: false, message: \"Could not find product\" };\n  }\n\n  const data = await getRequiredValueChainData(product.slug);\n  const productValueChain = await getProductValueChainForProduct(product, data);\n\n  if (!productValueChain) {\n    return { success: false, message: \"Couldn't find final product\" };\n  }\n\n  return {\n    success: true,\n    productValueChain,\n  };\n}"
  },
  "getRequiredValueChainData": {
    "name": "getRequiredValueChainData",
    "slug": "TsFunction",
    "id": "lqpqhzzsvlbucutwckdhwlgj",
    "description": "Gets all data needed for making a `ProductValueChain` for a given `finalProductSlug`",
    "operationName": "foodchain-recipes",
    "rawText": " async (\n  /**\n   * If given ,will only get contributions for this product\n   */\n  finalProductSlug?: string\n): Promise<ProductValueChainData> => {\n  const contributions = await db.get(\"Contribution\", {\n    filter: finalProductSlug\n      ? (item) => item.final_productSlug === finalProductSlug\n      : undefined,\n    include: [\n      { referenceKey: \"final_productSlug\" },\n      { referenceKey: \"companySlug\" },\n      { referenceKey: \"valueChainPhaseSlug\" },\n      { referenceKey: \"locationSlug\" },\n      { referenceKey: \"sub_productSlug\" },\n    ],\n  });\n\n  const valueChainPhases = await db.get(\"ValueChainPhase\", {\n    include: { referenceKey: \"activitySlug\" },\n  });\n\n  // Needed for company transparency\n  const locations = await db.get(\"Location\");\n  const companyRequirements = await db.get(\"CompanyRequirement\", {\n    include: [\n      { referenceKey: \"esgMetricSlugs\" },\n      // NB: we don't support categories here yet, just individual proofs\n      { referenceKey: \"proofSlugs\" },\n    ],\n  });\n  const proofStates = await db.get(\"ProofState\");\n  const esgMetrics = await db.get(\"EsgMetric\");\n\n  return {\n    proofStates,\n    companyRequirements,\n    locations,\n    valueChainPhases,\n    contributions,\n    esgMetrics,\n  };\n}"
  },
  "getSustainabilityPlan": {
    "name": "getSustainabilityPlan",
    "slug": "TsFunction",
    "id": "nlgrqcnmjlvtxhckoqaehhgn",
    "description": "gets the sustainabilityplan with all requirements",
    "operationName": "foodchain-recipes",
    "rawText": " async (): Promise<{\n  success: boolean;\n  sustainabilityPlan?: SustainabilityPlan;\n  message?: string;\n}> => {\n  const contributions = await db.get(\"Contribution\", {\n    include: { referenceKey: \"valueChainPhaseSlug\" },\n  });\n  const locations = await db.get(\"Location\");\n  const companies = (await db.get(\"Company\")).map((company) =>\n    companyAttachContributionInformation(company, contributions, locations)\n  );\n\n  const sustainabilityPlans = await db.get(\"SustainabilityPlan\");\n  const sustainabilityPlan = sustainabilityPlans[0];\n\n  if (!sustainabilityPlan) {\n    return { success: false, message: \"There is no sustainabilityplan\" };\n  }\n\n  const allRequirements = await db.get(\"CompanyRequirement\", {\n    include: [\n      { referenceKey: \"proofSlugs\" },\n      { referenceKey: \"companyTypeSlugs\" },\n      { referenceKey: \"productSlugs\" },\n      { referenceKey: \"activitySlugs\" },\n      { referenceKey: \"contribution_locationSlugs\" },\n      { referenceKey: \"esgMetricSlugs\" },\n    ],\n  });\n\n  const companyRequirementsCalculated: CompanyRequirement[] = allRequirements\n    .filter((x) => x.sustainabilityPlanSlug === sustainabilityPlan.slug)\n    .map((requirement) => {\n      // NB: we are also easily able here to return more info about the company, if we want\n      const totalCompanysCalculated = companies.filter((company) =>\n        requirementAppliesToCompany(company, requirement)\n      ).length;\n\n      return { ...requirement, totalCompanysCalculated };\n    });\n\n  const fullSustainabilityPlan: SustainabilityPlan = {\n    ...sustainabilityPlan,\n    companyRequirementsCalculated,\n  };\n\n  return {\n    success: true,\n    sustainabilityPlan: fullSustainabilityPlan,\n  };\n}"
  },
  "hasEsgMetricWithStatus": {
    "name": "hasEsgMetricWithStatus",
    "slug": "TsFunction",
    "id": "vhbnjlxpuvlpfdmyqfagvmmz",
    "description": "Filter functions that returns true if a `ProofState` is confirmed to be a certain `status` for a `ESGMetric` or one of its children",
    "operationName": "foodchain-recipes",
    "rawText": " (\n  status: EsgMetricStatus,\n  proofState: ProofState,\n  allChildrenAndItselfEsgMetrics: EsgMetric[]\n): boolean =>\n  proofState.esgMetricStatus\n    ?.filter((status) => {\n      return allChildrenAndItselfEsgMetrics.find(\n        (x) => x.slug === status.esgMetricSlug\n      );\n    })\n    .filter((x) => x.status === status).length > 0"
  },
  "requirementAttachProofStates": {
    "name": "requirementAttachProofStates",
    "slug": "TsFunction",
    "id": "jrjmsnztnwfnldtoijebzgiy",
    "description": "Attaches company_proofStatesCalculated to a requirement for a company",
    "operationName": "foodchain-recipes",
    "rawText": " (\n  company: Company,\n  requirement: CompanyRequirement,\n  proofStates: ProofState[]\n): CompanyRequirement => {\n  const company_proofStatesCalculated = requirement.proofSlugs?.map(\n    (proofSlug) => {\n      const alreadyProofState = proofStates.find(\n        (x) => x.companyId === company.id && x.proofSlug === proofSlug\n      );\n\n      console.log({\n        proofSlug,\n        proofStates: proofStates.length,\n        alreadyProofState,\n      });\n\n      if (alreadyProofState) return alreadyProofState;\n\n      const newProofState: Creation<ProofState> = {\n        auditReport_assets: [],\n        certificate_assets: [],\n        other_assets: [],\n        companyId: company.id,\n        proofSlug,\n        status: \"todo\",\n        esgMetricStatus: [],\n      };\n\n      return newProofState;\n    }\n  );\n\n  return { ...requirement, company_proofStatesCalculated };\n}"
  },
  "sumEsgMetricProofStates": {
    "name": "sumEsgMetricProofStates",
    "slug": "TsFunction",
    "id": "rekqtivrbkebnngcidkiaokm",
    "description": "Sums esg metric proof states of multiple companies",
    "operationName": "foodchain-recipes",
    "rawText": " (companies: Company[]) => {\n  const esgMetrics = companies\n    .map((x) => x.companyEsgMetricProofStatesCalculated)\n    .filter(notEmpty)\n    /**\n     * This looks scary but it just reduces the proofStates for every company into a single list of ProofStates, ensuring that the same proofStates don't occur twice if they both adhere to a certain ESG metric\n     */\n    .reduce((previous, current) => {\n      // NB: removes the duplicates after the previous\n      const all = previous\n        .concat(current)\n        .filter(onlyUnique2<EsgMetric>((a, b) => a.id === b.id));\n\n      const concatenated: EsgMetric[] = all.map((esgMetric) => {\n        const sameEsgMetric = current.find((x) => x.id === esgMetric.id);\n\n        const newEsgMetric: EsgMetric = {\n          ...esgMetric,\n          positiveProofsCalculated: concatenateItems(\n            esgMetric.positiveProofsCalculated,\n            sameEsgMetric?.positiveProofsCalculated\n          ),\n          negativeProofsCalculated: concatenateItems(\n            esgMetric.negativeProofsCalculated,\n            sameEsgMetric?.negativeProofsCalculated\n          ),\n          notAssessedProofsCalculated: concatenateItems(\n            esgMetric.notAssessedProofsCalculated,\n            sameEsgMetric?.notAssessedProofsCalculated\n          ),\n        };\n\n        return newEsgMetric;\n      });\n\n      return concatenated;\n    }, [] as EsgMetric[]);\n\n  return esgMetrics;\n}"
  },
  "getCompanyRequirementDescription": {
    "name": "getCompanyRequirementDescription",
    "slug": "TsFunction",
    "id": "iovdoohhwldudroplvwwyscr",
    "description": "Returns something like this: Because your are farming (activity) tomatoes (product) in Argentina(location) we think there is a risk on ESG Metric, so we would like to work on a GRASP certificate (preferred proof) or Audit report (proof)",
    "operationName": "foodchain-recipes-js",
    "rawText": " (\n  company: Company,\n  companyRequirement: CompanyRequirement\n) => {\n  const {\n    hasAllRequirements,\n    hasActivity,\n    hasCompanyType,\n    hasLocation,\n    hasProduct,\n    foundActivitySlug,\n    foundCompanyType,\n    foundLocationSlug,\n    foundProductSlug,\n  } = requirementAppliesToCompany(company, companyRequirement);\n\n  // if (!hasAllRequirements)\n  //   return `${company.name} does not need to adhere to the ${companyRequirement.name} requirement`;\n\n  // const activityReason = foundActivitySlug\n  //   ? `- activity: ${foundActivitySlug}`\n  //   : undefined;\n  // const companyTypeReason = foundCompanyType\n  //   ? `- company type: ${foundCompanyType}`\n  //   : undefined;\n  // const locationReason = foundLocationSlug\n  //   ? `- location: ${foundLocationSlug}`\n  //   : undefined;\n  // const productReason = foundProductSlug\n  //   ? `- product: ${foundProductSlug}`\n  //   : undefined;\n\n  const activityReason = foundActivitySlug ? foundActivitySlug : undefined;\n  const companyTypeReason = foundCompanyType ? foundCompanyType : undefined;\n  const locationReason = foundLocationSlug ? foundLocationSlug : undefined;\n  const productReason = foundProductSlug ? foundProductSlug : undefined;\n\n  const reason = [\n    activityReason,\n    companyTypeReason,\n    locationReason,\n    productReason,\n  ]\n    .filter(notEmpty)\n    .join(\"\\n\");\n\n  return [\n    {\n      slug: activityReason,\n      type: \"Activity\",\n      desc: \"The activity you peform\",\n      category: \"activity\",\n    },\n    { slug: productReason, type: \"Products\", desc: \"\", category: \"product\" },\n    {\n      slug: companyTypeReason,\n      type: \"Organisation type\",\n      desc: \"\",\n      category: \"companyType\",\n    },\n    {\n      slug: locationReason,\n      type: \"Active in countries\",\n      desc: \"\",\n      category: \"location\",\n    },\n  ];\n\n  // `We think there is a risk on ${companyRequirement.esgMetricSlugs?.join()},\n  //   so we would like to work on a ${companyRequirement.proofSlugs?.join(\n  //     \" or \"\n  //   )}. This is based on the following reasons:\\n\\n ${reason}`;\n}"
  },
  "requirementAppliesToCompany": {
    "name": "requirementAppliesToCompany",
    "slug": "TsFunction",
    "id": "fdxjgqleqtiymywyudebkjob",
    "description": "filter function that checks whether a requirement applies to a company\n\nreturns both `hasAllRequirements` boolean as well as a boolean indicating every filter requirement\n\nNB: only works if `companyAttachContributionInformation` has been applied",
    "operationName": "foodchain-recipes-js",
    "rawText": " (\n  company: Company,\n  requirement: CompanyRequirement\n): {\n  hasAllRequirements: boolean;\n  foundCompanyType?: string;\n  foundActivitySlug?: string;\n  foundLocationSlug?: string;\n  foundProductSlug?: string;\n  hasProduct: boolean;\n  hasLocation: boolean;\n  hasActivity: boolean;\n  hasCompanyType: boolean;\n} => {\n  const requirementNoProductSlugs =\n    requirement.productSlugs === undefined ||\n    (Array.isArray(requirement.productSlugs) &&\n      requirement.productSlugs.length === 0);\n\n  /**\n   * contribution with product that adheres to product requirement\n   */\n  const foundProductSlug = requirementNoProductSlugs\n    ? undefined\n    : company.contribution_productSlugsCalculated?.find((slug) =>\n        requirement.productSlugs?.includes(slug)\n      );\n\n  const hasProduct = requirementNoProductSlugs ? true : !!foundProductSlug;\n\n  const requirementNoLocationSlugs =\n    requirement.contribution_locationSlugs === undefined ||\n    (Array.isArray(requirement.contribution_locationSlugs) &&\n      requirement.contribution_locationSlugs.length === 0);\n\n  /**\n   * contribution with location that adheres to location requirement\n   */\n  const foundLocationSlug = requirementNoLocationSlugs\n    ? undefined\n    : company.contribution_locationSlugsCalculated?.find((slug) =>\n        requirement.contribution_locationSlugs?.includes(slug)\n      );\n  const hasLocation = requirementNoLocationSlugs ? true : !!foundLocationSlug;\n\n  const noActivitySlugs =\n    requirement.activitySlugs === undefined ||\n    (Array.isArray(requirement.activitySlugs) &&\n      requirement.activitySlugs.length === 0);\n\n  /**\n   * contribution with activity that adheres to activity requirement\n   */\n  const foundActivitySlug = noActivitySlugs\n    ? undefined\n    : company.contribution_activitySlugsCalculated?.find((slug) =>\n        requirement.activitySlugs?.includes(slug)\n      );\n  const hasActivity = noActivitySlugs ? true : !!foundActivitySlug;\n\n  const noCompanyTypes =\n    requirement.companyTypeSlugs === undefined ||\n    (Array.isArray(requirement.companyTypeSlugs) &&\n      requirement.companyTypeSlugs.length === 0);\n\n  const foundCompanyType = noCompanyTypes\n    ? undefined\n    : requirement.companyTypeSlugs?.find(\n        (companyType) => companyType === company.companyTypeSlug\n      );\n\n  const hasCompanyType = noCompanyTypes ? true : !!foundCompanyType || false;\n\n  const hasAllRequirements =\n    !!hasProduct && !!hasLocation && !!hasActivity && !!hasCompanyType;\n\n  return {\n    hasAllRequirements,\n    foundCompanyType,\n    foundActivitySlug,\n    foundLocationSlug,\n    foundProductSlug,\n    hasProduct,\n    hasLocation,\n    hasActivity,\n    hasCompanyType,\n  };\n}"
  },
  "AdminLinks": {
    "name": "AdminLinks",
    "slug": "TsFunction",
    "id": "bxrhvsgurksxrkshsayhorwl",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " () => {\n  return (\n    <Div className=\"pb-4 w-52\" scroll>\n      <LinkGroupLabel text=\"External links\" />\n      <Div className=\" mx-4\">\n      <ALink href={`/db/Activity`}>\n          <StyledButton\n            theme=\"Plain\"\n            size=\"Inherit\"\n            extraClassName=\"flex flex-row font-normal gap-x-5 pl-2 pr-2 h-10 \n            items-center text-sm text-accent-500 fill-transparant  \n            hover:bg-accent-100 stroke-accent-400 rounded-md\n            hover:text-accent-700 \"\n          >\n            <StyledIcon color=\"Inherit\" size=\"sm\" icon=\"AdminIconSolid\" />\n            <P>Activities</P>\n          </StyledButton>\n        </ALink>\n\n        <ALink href={`/db/EsgMetric`}>\n          <StyledButton\n            theme=\"Plain\"\n            size=\"Inherit\"\n            extraClassName=\"flex flex-row font-normal gap-x-5 pl-2 pr-2 h-10 \n            items-center text-sm text-accent-500 fill-transparant  \n            hover:bg-accent-100 stroke-accent-400 rounded-md\n            hover:text-accent-700 \"\n          >\n            <StyledIcon color=\"Inherit\" size=\"sm\" icon=\"AdminIconSolid\" />\n            <P>ESG Metrics</P>\n          </StyledButton>\n        </ALink>\n\n        <ALink href={`/db/ProductCategory`}>\n          <StyledButton\n            theme=\"Plain\"\n            size=\"Inherit\"\n            extraClassName=\"flex flex-row font-normal gap-x-5 pl-2 pr-2 h-10 \n            items-center text-sm text-accent-500 fill-transparant  \n            hover:bg-accent-100 stroke-accent-400 rounded-md\n            hover:text-accent-700 \"\n          >\n            <StyledIcon color=\"Inherit\" size=\"sm\" icon=\"AdminIconSolid\" />\n            <P>Product categories</P>\n          </StyledButton>\n        </ALink>\n\n        <ALink href={`/db/Proof`}>\n          <StyledButton\n            theme=\"Plain\"\n            size=\"Inherit\"\n            extraClassName=\"flex flex-row font-normal gap-x-5 pl-2 pr-2 h-10 \n            items-center text-sm text-accent-500 fill-transparant  \n            hover:bg-accent-100 stroke-accent-400 rounded-md\n            hover:text-accent-700 \"\n          >\n            <StyledIcon color=\"Inherit\" size=\"sm\" icon=\"AdminIconSolid\" />\n            <P>Proofs</P>\n          </StyledButton>\n        </ALink>\n      </Div>\n    </Div>\n  );\n}"
  },
  "AverageMetricDougnut": {
    "name": "AverageMetricDougnut",
    "slug": "TsFunction",
    "id": "strmyvjrnrvknzihnnnqcyib",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " (props: CountryHorizontalType) => {\n  const { data } = props;\n  function getAllMetrics(companies: Company[] | undefined, key: keyof Company) {\n    const metrics = companies\n      ? companies\n          .map((x) => x.companyRequirementsCalculated)\n          .flatMap((requirement) =>\n            requirement\n              ?.flatMap((x) => x.company_proofStatesCalculated)\n              .flatMap((x) => x?.status)\n          )\n      : null;\n    const summarizedMetrics = metrics?.reduce(\n      (acc: any, item: any) => ((acc[item] = (acc[item] || 0) + 1), acc),\n      []\n    );\n\n    console.log({ metrics: summarizedMetrics });\n    return summarizedMetrics;\n  }\n\n  const allMetrics = getAllMetrics(\n    data,\n    \"companyEsgMetricProofStatesCalculated\"\n  );\n  const labels = allMetrics ? Object?.keys(allMetrics) : null;\n  const countedValues = allMetrics ? Object?.values(allMetrics) : null;\n\n  return (\n    <Doughnut\n      width={32}\n      height={32}\n      options={{\n        indexAxis: \"y\" as const,\n        cutout: 24,\n        maintainAspectRatio: false,\n\n        layout: {},\n        plugins: {\n          legend: {\n            fullSize: true,\n            position: \"center\",\n            align: \"center\",\n            textDirection: \"center\",\n            display: true,\n            labels: {\n              boxWidth: 8,\n              boxHeight: 8,\n              usePointStyle: true,\n            },\n          },\n        },\n        scales: {\n          yAxis: {\n            ticks: {\n              display: false,\n            },\n            grid: {\n              display: false,\n              drawTicks: false,\n              tickLength: 0,\n              drawBorder: false,\n            },\n          },\n          xAxis: {\n            ticks: {\n              display: false,\n            },\n            grid: {\n              display: false,\n              tickLength: 0,\n              drawBorder: false,\n              drawTicks: false,\n            },\n          },\n        },\n        elements: {\n          arc: {\n            backgroundColor: [\"#fff\", \"#fff\", \"#fff\"],\n            borderJoinStyle: \"round\",\n            borderRadius: 8,\n            borderWidth: 0,\n            offset: 4,\n            borderColor: \"rgba(255, 255,255, 0)\",\n            hoverBorderColor: \"rgba(255, 255,255, 0.2)\",\n          },\n\n          point: {\n            pointStyle: \"line\",\n          },\n        },\n      }}\n      data={{\n        labels: labels || undefined,\n        datasets: [\n          {\n            weight: 4,\n            borderWidth: 4,\n\n            data: countedValues,\n          },\n        ],\n      }}\n    />\n  );\n}"
  },
  "AverageTransparencyDougnut": {
    "name": "AverageTransparencyDougnut",
    "slug": "TsFunction",
    "id": "cwpdbpuijqvcngluidzxxnel",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " (props: TransparencyCalculated) => {\n  const { value } = props;\n  const labels = [\"\"];\n  const isTransparentNumber = value;\n  const notTransparentNumber = 100 - isTransparentNumber;\n\n  return (\n    <Doughnut\n      width={200}\n      height={50}\n      options={{\n        indexAxis: \"y\" as const,\n        cutout: 50,\n        maintainAspectRatio: false,\n\n        layout: {},\n        plugins: {\n          legend: {\n            fullSize: true,\n            position: \"center\",\n            align: \"center\",\n            textDirection: \"center\",\n            display: true,\n            labels: {\n              boxWidth: 8,\n              boxHeight: 8,\n              usePointStyle: true,\n            },\n          },\n        },\n        scales: {\n          yAxis: {\n            ticks: {\n              display: false,\n            },\n            grid: {\n              display: false,\n              drawTicks: false,\n              tickLength: 0,\n              drawBorder: false,\n            },\n          },\n          xAxis: {\n            ticks: {\n              display: false,\n            },\n            grid: {\n              display: false,\n              tickLength: 0,\n              drawBorder: false,\n              drawTicks: false,\n            },\n          },\n        },\n        elements: {\n          arc: {\n            backgroundColor: [\"#5347DF\", \"#e5e7eb\"],\n            borderJoinStyle: \"round\",\n            borderRadius: 8,\n            borderWidth: 0,\n            offset: 4,\n            borderColor: \"rgba(255, 255,255, 0)\",\n            hoverBorderColor: \"rgba(255, 255,255, 0.2)\",\n          },\n\n          point: {\n            pointStyle: \"line\",\n          },\n        },\n      }}\n      data={{\n        labels: labels || undefined,\n        datasets: [\n          {\n            weight: 4,\n            borderWidth: 4,\n\n            data: [isTransparentNumber, notTransparentNumber],\n          },\n        ],\n      }}\n    />\n  );\n}"
  },
  "CardRow": {
    "name": "CardRow",
    "slug": "TsFunction",
    "id": "kghgfvphmxkybjdcpdfpynvn",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " ({\n  icon,\n  value,\n  isVisible,\n  popoverValue,\n  hasPopover,\n}: CardRowType) =>\n  isVisible ? (\n    <Popover enabled={hasPopover} value={popoverValue} placement=\"bottom\">\n      <Div className=\"flex flex-row value-center py-0.5 items-center text-accent-400  hover:text-accent-700 \">\n        <Span className=\"pr-2\">\n          <StyledIcon color=\"OutlineWeak\" size=\"sm\" icon={icon}></StyledIcon>\n        </Span>\n\n        {value ? (\n          <P className=\"text-sm font-normal  gap-4 truncate\">\n            {\" \"}\n            {typeof value === \"string\"\n              ? value.length > 18\n                ? `${value.slice(0, 16)}..`\n                : value\n              : value}{\" \"}\n          </P>\n        ) : (\n          <P className=\"text-sm font-normal  gap-4 truncate text-accent-150\">\n            No data\n          </P>\n        )}\n      </Div>\n    </Popover>\n  ) : null"
  },
  "columns": {
    "name": "columns",
    "slug": "TsVariable",
    "id": "bfrhpusqyotngvjgblixpciy",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "CompanyInfoTab": {
    "name": "CompanyInfoTab",
    "slug": "TsFunction",
    "id": "aiiivvagknknevehsyjcmfmq",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " ({ data }: { data?: Company | any }) => {\n  const toCount = data\n    ? data?.transparencyDetailsCalculated?.notFilledInFormFields\n    : null;\n  return (\n    <TabContent toCount={toCount} title=\"Info\" icon=\"companyTypeOutline\" />\n  );\n}"
  },
  "CompanyInfo": {
    "name": "CompanyInfo",
    "slug": "TsFunction",
    "id": "jnxfvlsmklxakyetrfxbhpld",
    "description": "Now your form can be rendered like this\n\nMake sure to provide the generic based on the inputs type interfaces\n\notherwise your form won't be typesafe!\n\nicon component that shows the right icon based on the ESG metric",
    "operationName": "passionfruit-ui",
    "rawText": " (props: { data: Company | undefined }) => {\n  const { data } = props;\n  console.log({ companyInfoData: data });\n  const tabs: TabType<Company>[] = [\n    {\n      id: \"info\",\n      label: <CompanyInfoTab data={data} />,\n      data: (\n        <CompanyForm\n          companyId={data?.id}\n          // LK: TD: Added a extra companySlug to fix a bug. Need to change later.\n          companySlug={data?.slug}\n          data={{\n            name: data?.name || \"\",\n            address: data?.address || \"\",\n            companySize: {\n              label: data?.companySize?.name || \"\",\n              value: data?.companySize?.slug || \"\",\n            },\n            companyType: {\n              label: data?.companyType ? data?.companyType.name || \"\" : \"\",\n              value: data?.companyType ? data?.companyType.slug || \"\" : \"\",\n            },\n            ggn: data?.ggn || \"\",\n            location: {\n              label: data?.location ? data?.location.name || \"\" : \"\",\n              value: data?.location ? data?.location.slug || \"\" : \"\",\n            },\n          }}\n        />\n      ),\n    },\n\n    {\n      id: \"goals\",\n      label: <GoalsTab data={data} />,\n      data: (\n        <Requirements\n          companyName={data?.name}\n          requirements={data?.companyRequirementsCalculated}\n        />\n      ),\n    },\n    {\n      id: \"environmental\",\n      label: <EnvironmentTab />,\n      data: (\n        <EsgPerformance\n          data={\n            data?.companyEsgMetricProofStatesCalculated?.filter(\n              (esgMetric) => esgMetric.parent_esgMetricSlug === \"environment\"\n            ) || []\n          }\n        />\n      ),\n    },\n    {\n      id: \"social\",\n      label: <SocialTab />,\n      data: (\n        <EsgPerformance\n          data={\n            data?.companyEsgMetricProofStatesCalculated?.filter(\n              (esgMetric) => esgMetric.parent_esgMetricSlug === \"social\"\n            ) || []\n          }\n        />\n      ),\n    },\n  ];\n  return (\n    <Div scroll className=\"py-2 \">\n      <Tabs urlHook=\"sidePanelSubTab\" tabs={tabs} xPadding={\"8\"} />\n    </Div>\n  );\n}"
  },
  "ContributionNodeComponent": {
    "name": "ContributionNodeComponent",
    "slug": "TsFunction",
    "id": "cwukwqlrxbdphjmyueytjtdj",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " ({ data }) => {\n  // const onChange = useCallback((evt) => {\n  //   console.log(evt.target.value);\n  // }, []);\n  const [_, setSelectedContributionId] = useUrl(\"selectedContributionId\");\n  const [showCardId, __] = useStore(\"activeCard\");\n\n  const defaultHandleStyle = {\n    backgroundColor: \"#fff\",\n    height: \"16px\",\n    width: \"16px\",\n    zIndex: 1,\n    border: \"3px solid #9ca3af80\",\n  };\n\n  return (\n    <>\n      <Handle\n        type=\"target\"\n        style={defaultHandleStyle}\n        position={Position.Left}\n      />\n\n      <ValueChainCard\n        active={showCardId === data.id}\n        openSidePanel={(node) => {\n          setSelectedContributionId(data.id);\n        }}\n        isVisible={true}\n        contribution={data}\n      />\n      <Handle\n        type=\"source\"\n        onConnect={(params) => console.log(\"handle onConnect\", params)}\n        style={defaultHandleStyle}\n        position={Position.Right}\n        id=\"a\"\n      />\n    </>\n  );\n}"
  },
  "CountriesHorizontalBar": {
    "name": "CountriesHorizontalBar",
    "slug": "TsFunction",
    "id": "vcbfrrsvpgbqacjpawvyflke",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " (props: CountryHorizontalType) => {\n  const { data } = props;\n\n  function getAllCountries(\n    companies: Company[] | undefined,\n    key: keyof Company\n  ) {\n    const countries = companies\n      ? companies.flatMap((x) => x.contribution_locationSlugsCalculated)\n      : null;\n    const summarizedCountries = countries?.reduce(\n      (acc: any, item: any) => ((acc[item] = (acc[item] || 0) + 1), acc),\n      []\n    );\n\n    return summarizedCountries;\n  }\n\n  const allCountries = getAllCountries(\n    data,\n    \"contribution_locationSlugsCalculated\"\n  );\n\n  const labels = allCountries ? Object?.keys(allCountries) : null;\n  const countedValues = allCountries ? Object?.values(allCountries) : null;\n\n  // Change these settings to change the display for different parts of the X axis\n  // grid configuiration\n\n  const countryData = {\n    labels: labels,\n    datasets: [\n      {\n        data: countedValues,\n        barThickness: 24,\n      },\n    ],\n    borderWidth: 0,\n  };\n\n  return (\n    <Bar\n      options={{\n        indexAxis: \"y\" as const,\n        maintainAspectRatio: false,\n        plugins: {\n          legend: { display: false },\n        },\n        scales: {\n          yAxis: {\n            grid: {\n              display: false,\n            },\n          },\n        },\n        elements: {\n          point: {\n            pointStyle: \"line\",\n          },\n          bar: {\n            backgroundColor: [\"#c2410c\", \"#FFCB47\", \"#fed7aa\"],\n            borderRadius: 4,\n            base: 1,\n          },\n        },\n      }}\n      data={countryData}\n      className=\"pl-8 w-100% \"\n    />\n  );\n}"
  },
  "defaultStatusOption": {
    "name": "defaultStatusOption",
    "slug": "TsVariable",
    "id": "ihgveranzsrbnlymoyfqlzfk",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "edgeType": {
    "name": "edgeType",
    "slug": "TsVariable",
    "id": "fzljlxhudixucrmaazqllckq",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "EnvironmentTab": {
    "name": "EnvironmentTab",
    "slug": "TsFunction",
    "id": "mxqeadaxgcxxunsimwbzxanr",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " ({ data }: { data?: Company }) => {\n  return <TabContent title=\"Environmental\" icon=\"environmentalOutline\" />;\n}"
  },
  "EsgPerformance": {
    "name": "EsgPerformance",
    "slug": "TsFunction",
    "id": "hpwlermnaqythfwyqkpnuces",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " (props: { data: EsgMetric }) => {\n  const { data } = props;\n\n  console.log({ esgPerformanceData: data });\n  const newArray = sortedArray(data, \"slug\");\n  console.log({ e: newArray });\n  return (\n    <Div>\n      <Div scroll className=\"py-2 px-8 w-full flex flex-col relative \">\n        <Div className=\" fill-gray-500 h-full flex-1\">\n          {data ? (\n            <Table\n              scroll={false}\n              data={newArray}\n              containerStyle={\"h-full\"}\n              columns={columns}\n            />\n          ) : null}\n        </Div>\n      </Div>\n      <SidePanelExplainer title=\"What does this mean?\" text={explainingText} />\n    </Div>\n  );\n}"
  },
  "explainingText": {
    "name": "explainingText",
    "slug": "TsVariable",
    "id": "hzgqspsnzjaaaksnvzoappwb",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "FilterContainer": {
    "name": "FilterContainer",
    "slug": "TsFunction",
    "id": "fafqaxqfuxztsywywufxkpcx",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  props: SearchFieldType<TModel>\n) => {\n  const { data } = props;\n\n  const [searchInput, setSearchInput] = useState(\"\");\n  const [filterProduct, setFilterProduct] = useState(\"\");\n  const [filteredResults, setFilteredResults] = useStore<Company[] | undefined>(\n    []\n  );\n\n  const cleanData = data?.filter((x: TModel) => x !== undefined);\n\n  // const sortedData = filteredCompanies?.sort(\n  //   (a: Company, b: Company) =>\n  //     (b[\"transparencyPercentageCalculated\"] || 0) -\n  //     (a[\"transparencyPercentageCalculated\"] || 0)\n  // )\n\n  /** QUICK FIX: filter for druiven  */\n  const sortedData = cleanData?.filter((item: TModel) => {\n    return Object.values(item).join(\"\").toLowerCase().includes(\"\");\n  });\n\n  // const filterProduct = sortedData?.filter((item) => {\n  //   return Object.values(item).join(\"\").toLowerCase().includes(\"tomatoes\");\n  // });\n  // console.log({ druiven: filterProduct });\n\n  // console.log(filteredResults);\n  const searchItems = (searchValue: string) => {\n    setSearchInput(searchValue);\n    if (searchInput !== \"\") {\n      sortedData?.filter((item: TModel) => {\n        return Object.values(item)\n          .join(\"\")\n          .toLowerCase()\n          .includes(searchInput.toLowerCase());\n      });\n      setFilteredResults(filteredData);\n    } else {\n      setFilteredResults(sortedData);\n    }\n  };\n\n  const filteredData = sortedData?.filter((item: TModel) => {\n    return Object.values(item)\n      .join(\"\")\n      .toLowerCase()\n      .includes(searchInput.toLowerCase() + filterProduct);\n  });\n\n  return (\n    <Div className=\"relative\">\n      <Div className=\"flex flex-row h-14  items-center gap-x-4\">\n        <Div className=\"max-w-md w-full pb-4\">\n          <SearchField\n            searchInput={searchInput}\n            clearInput={() => searchItems(\"\")}\n            handleChange={(searchValue: string) => searchItems(searchValue)}\n          />\n        </Div>\n        <Dropdown size=\"md\" theme=\"Outline\" options={[]}></Dropdown>\n      </Div>\n    </Div>\n  );\n}"
  },
  "getPageIcon": {
    "name": "getPageIcon",
    "slug": "TsFunction",
    "id": "vzkypdwiajoopieepkstuvtd",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " (page: PageType) => page.icon"
  },
  "GoalsOverview": {
    "name": "GoalsOverview",
    "slug": "TsFunction",
    "id": "oqbkglycakgidbibdspqqfbi",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " (props: GoalOverviewType) => {\n  const { data, key } = props;\n\n  const companyRequirements = data;\n  console.log(data);\n  console.log(data);\n  /** Getting company requirments */\n  // const totalGoals = data?.map((x) =>\n  //   x.companyRequirementsCalculated?.map((x) => x.name)\n  // );\n\n  // const mergedCompanyRequirements = totalGoals?.reduce(function (\n  //   acc: any,\n  //   curr: any\n  // ) {\n  //   return acc[curr] ? ++acc[curr] : (acc[curr] = 1), acc;\n  // },\n  // []);\n\n  // const statusses = data?.map((x) =>\n  //   x.companyRequirementsCalculated?.map((x) =>\n  //     x.company_proofStatesCalculated.map((x) => x.status)\n  //   )\n  // );\n\n  /** the columns for the table */\n  const columns: ColumnType<CompanyRequirement>[] = [\n    {\n      name: \"Goals\",\n      targetPageName: \"sustainability-plan\",\n      objectParameterKey: \"name\",\n      customPresentation: (item) =>\n        renderGetSidePanel(\n          item,\n          \"name\",\n          \"sustainabilityPlanSlug\",\n          undefined,\n          undefined\n        ),\n    },\n    {\n      name: \"Priority\",\n      objectParameterKey: \"priority\",\n      customPresentation: (item) => renderGetPriority(item),\n    },\n    {\n      name: \"Ongoing Actions\",\n      objectParameterKey: \"proofs\",\n      customPresentation: (item) => renderGetArrayNames(item, \"proofs\"),\n    },\n    {\n      name: \"Actions started\",\n      objectParameterKey: \"totalCompanysCalculated\",\n      presentationType: \"text\",\n      textAfterValue: \"actions\",\n    },\n    {\n      name: \"Actions completed\",\n      objectParameterKey: \"totalCompanysCalculated\",\n      presentationType: \"text\",\n      textAfterValue: \"actions\",\n    },\n  ];\n  console.log(data);\n  return (\n    <Div className=\"grid grid-flow-col w-full overflow-hidden\">\n      <Div className=\" overflow-clip\">\n        {companyRequirements && Array.isArray(companyRequirements) ? (\n          <Table\n            containerStyle=\"max-w-full\"\n            data={data}\n            columns={columns}\n            scroll\n          />\n        ) : null}\n      </Div>\n    </Div>\n  );\n}"
  },
  "GoalsTab": {
    "name": "GoalsTab",
    "slug": "TsFunction",
    "id": "wfobvghiuwqfulaqsyonlrno",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " ({ data }: { data?: Company }) => {\n  const toCount = data ? data?.companyRequirementsCalculated : null;\n  return (\n    <TabContent\n      // toCount={toCount}\n      title=\"Actions\"\n      icon=\"CheckSolid\"\n    />\n  );\n}"
  },
  "ListHeader": {
    "name": "ListHeader",
    "slug": "TsFunction",
    "id": "fhwtkjduzwutqtpqlswbkbcq",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " ({\n  title,\n  icon,\n}: {\n  title: string;\n  icon?: keyof typeof iconVariants;\n}) => {\n  return (\n    <Div className=\"flex flex-row gap-x-2 items-center pb-2\">\n      {icon ? <StyledIcon icon={icon} color=\"OutlineWeak\" size=\"xs\" /> : null}\n      <P className=\"text-sm font-semibold truncate text-gray-700 \">{title}</P>\n    </Div>\n  );\n}"
  },
  "ListItem": {
    "name": "ListItem",
    "slug": "TsFunction",
    "id": "bfxuygxibtudawgpemallbui",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>({\n  icon,\n  item,\n  label,\n}: {\n  icon?: keyof typeof iconVariants;\n  item: TModel & string;\n  label?: any;\n}) => {\n  return (\n    <Div className=\"flex flex-row pr-2 w-full justify-between gap-1 align-middle border-accent-100\">\n      <Div className=\"flex flex-row gap-2 align-middle \">\n        <Div className=\"self-center max-w-max truncate text-gray-600\">\n          {item ? humanCase(item) : item}\n        </Div>\n      </Div>\n      <Div className=\"w-24 flex justify-end \">\n        <ProofValueChip data={label} />\n      </Div>\n    </Div>\n  );\n}"
  },
  "List": {
    "name": "List",
    "slug": "TsFunction",
    "id": "dbzyrgrlmwzhrksrbkrfycmw",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>({\n  label,\n  icon,\n  data,\n  title,\n}: {\n  title: string;\n  data: TModel;\n  icon?: keyof typeof iconVariants;\n  label: any;\n}) => {\n  return (\n    <Div className=\"flex flex-col align-middle justify-start w-80 gap-1 pb-4\">\n      {title ? <ListHeader title={title} icon={icon} /> : null}\n      {data?.map((listItem: any, index: string) => (\n        <ListItem\n          label={label}\n          icon={icon}\n          item={listItem}\n          key={`item${index}`}\n        />\n      ))}\n    </Div>\n  );\n}"
  },
  "PHASE_HEIGHT": {
    "name": "PHASE_HEIGHT",
    "slug": "TsVariable",
    "id": "qgfvrrznsaqjqpdssuatctdp",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "PhaseNodeComponent": {
    "name": "PhaseNodeComponent",
    "slug": "TsFunction",
    "id": "acdgcgwucnaulpdibehjpslv",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " ({\n  data,\n}) => {\n  return (\n    <Div\n      style={{ width: PHASE_WIDTH, height: PHASE_HEIGHT }}\n      className={`w-full overflow-clip  rounded-xl bg-gradient-to-tr bg-white shadow-lg text-accent-700  `}\n    >\n      {\" \"}\n      <Div className=\"z-4 bg-gray\">\n        <CardColorBar\n          color={\n            data.activitySlug\n              ? colorLabelEnum[data?.activitySlug]\n              : colorLabelEnum[\"activity\"]\n          }\n        />\n      </Div>\n      <Div className=\" p-4 w-full flex flex-col px-4  gap-4\">\n        <Div className=\"flex flex-row gap-2 \">\n          <P className=\"text-lg font-semibold truncate capitalize\">\n            {data.name}\n          </P>\n        </Div>\n        <Div className=\"flex flex-row gap-2 items-center w-48 fill-transparent stroke-accent-500/80\">\n          <StyledIcon icon=\"transparencyOutline\" size=\"sm\" color=\"Inherit\" />\n          <ProgressBarSingle\n            color=\"purple\"\n            theme=\"light\"\n            label\n            value={data.transparencyPercentageCalculated}\n          />\n        </Div>\n      </Div>\n      <div className=\"absolute -right-6  h-4  top-0 mt-10 border-y-8 w-8 -z-20  border-y-transparent  bg-gray-300\"></div>\n    </Div>\n  );\n}"
  },
  "PHASE_WIDTH": {
    "name": "PHASE_WIDTH",
    "slug": "TsVariable",
    "id": "vkstxrydiumnzrmnpmshlevo",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "position": {
    "name": "position",
    "slug": "TsVariable",
    "id": "fcikiugsdwhzgmqaloscerno",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "PriorityChip": {
    "name": "PriorityChip",
    "slug": "TsFunction",
    "id": "aqxxwlcyejykicgyooefmcqe",
    "description": "This is priority chip that is used to communicate the priority of an company requirement outside of tables",
    "operationName": "passionfruit-ui",
    "rawText": " ({ data }: { data?: CompanyRequirement }) => {\n  const priorityColors: { [data: string]: ChipColorEnum } = {\n    basicCondition: \"FilledSecondary\",\n    nextStep: \"FilledBlue\",\n  };\n  const color: ChipColorEnum = data?.priority\n    ? priorityColors[data?.priority]\n    : priorityColors[\"\"];\n\n  return (\n    <Div className=\"align-middle items-center min-w-fit\">\n      <StyledChip color={color} size=\"sm\" value={data?.priority} />\n    </Div>\n  );\n}"
  },
  "ProofStateForm": {
    "name": "ProofStateForm",
    "slug": "TsFunction",
    "id": "zsyexlbsjpkzpsdtpylhelgq",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " (props: {\n  esgMetrics: CompanyRequirement[\"esgMetrics\"];\n  proofState: ProofState | Creation<ProofState> | undefined;\n}) => {\n  const { esgMetrics, proofState } = props;\n  const companiesQuery = useCompanies();\n  // const [selectedCompanyId] = useUrl(\"selectedCompanyId\");\n\n  // console.log({ proofState });\n  const esgMetricFields =\n    esgMetrics?.map((esgMetric, index) => {\n      const esgMetricProofState = proofState?.esgMetricStatus?.find(\n        (x) => x.esgMetricSlug === esgMetric.slug\n      );\n\n      return makeField(\"select\", {\n        sectionTitle:\n          index === 0 ? `Does this meets the requirements?` : undefined,\n        startSection: index === 0,\n        initialValue: statusOptions.find(\n          (x) => x.value === esgMetricProofState?.status\n        ),\n        field: `esgMetric.${esgMetric.slug}`,\n        title: esgMetric.name,\n        description: esgMetric.value ? String(esgMetric.value) : undefined,\n        extra: {\n          options: statusOptions,\n          theme: \"Outlined\",\n          size: \"md\",\n        },\n      });\n    }) || [];\n\n  /** generating fields */\n  const fields = [\n    makeField(\"select\", {\n      field: \"status\",\n      icon: true,\n      title: \"Status\",\n      initialValue: proofStateStatusOptions.find(\n        (x) => x.value === proofState?.status\n      ),\n      extra: {\n        options: proofStateStatusOptions,\n        size: \"md\",\n        theme: \"Outlined\",\n      },\n    }),\n    makeField(\"textArea\", {\n      initialValue: proofState?.comment,\n      field: \"comment\",\n      title: \"Notes\",\n      extra: {\n        placeholder: \"Write a comment\",\n      },\n    }),\n\n    makeField(\"asset\", {\n      initialValue: proofState?.certificate_assets,\n      startSection: true,\n      sectionTitle: \"Certificate\",\n      field: \"certificate_assets\",\n      title: \"Certificate\",\n      extra: {\n        inputTypes: [\"files\"],\n        allowMultiple: true,\n        attachTokenToFilename: true,\n        defaultAssetName: \"certificate\",\n        projectRelativeReferencingFilePath: \"db/proof-states.json\",\n        theme: \"Outlined\",\n        size: \"md\",\n      },\n    }),\n\n    makeField(\"date\", {\n      initialValue: new Date(\n        proofState?.certificate_validUntilAt || Date.now()\n      ),\n      field: \"certificate_validUntilAt\",\n      title: \"Certificate valid until\",\n      extra: {\n        theme: \"Outlined\",\n        size: \"md\",\n      },\n    }),\n\n    makeField(\"asset\", {\n      startSection: true,\n      sectionTitle: \"Audit report\",\n      initialValue: proofState?.auditReport_assets,\n      field: \"auditReport_assets\",\n      title: \"Audit report\",\n      extra: {\n        inputTypes: [\"files\"],\n        allowMultiple: true,\n        theme: \"Outlined\",\n        size: \"md\",\n        attachTokenToFilename: true,\n        defaultAssetName: \"auditreport\",\n        projectRelativeReferencingFilePath: \"db/proof-states.json\",\n      },\n    }),\n\n    makeField(\"date\", {\n      initialValue: new Date(\n        proofState?.auditReport_validUntilAt || Date.now()\n      ),\n      field: \"auditReport_validUntilAt\",\n      title: \"Audit report valid until\",\n      extra: {\n        theme: \"Outlined\",\n        size: \"md\",\n      },\n    }),\n\n    makeField(\"asset\", {\n      startSection: true,\n      sectionTitle: \"More proofs\",\n      initialValue: proofState?.other_assets,\n      field: \"other_assets\",\n      title: \"More proofs\",\n      extra: {\n        inputTypes: [\"files\"],\n        allowMultiple: true,\n        theme: \"Outlined\",\n        size: \"md\",\n        attachTokenToFilename: true,\n        defaultAssetName: \"other\",\n        projectRelativeReferencingFilePath: \"db/proof-states.json\",\n      },\n    }),\n\n    ...esgMetricFields,\n  ];\n\n  return (\n    <Div className=\"pr-8  mb-44 ml-1 w-full justify-center rounded-lg shadow-xs   outline-t-2\">\n      <Form<ProofStateFormFields>\n        fields={fields}\n        onSubmit={async (values, resolve, reject) => {\n          const {\n            auditReport_assets,\n            certificate_assets,\n            other_assets,\n            auditReport_validUntilAt,\n            certificate_validUntilAt,\n            comment,\n            status,\n            ...esgMetricProof\n          } = values;\n          const esgMetricStatus: {\n            esgMetricSlug: Slug;\n            status: EsgMetricStatus;\n          }[] = getObjectKeysArray(esgMetricProof).map((key) => {\n            const esgMetricSlug = key.slice(\"esgMetric.\".length);\n\n            return {\n              esgMetricSlug,\n              status: esgMetricProof[key]?.value as EsgMetricStatus,\n            };\n          });\n          const proofSlug = proofState?.proofSlug;\n\n          if (!proofSlug) {\n            reject(\"No action found\");\n            return;\n          }\n\n          //NB: we need to omit undefined values because we don't want to set id to 'undefined'\n          const newProofState: Creation<ProofState> = omitUndefinedValues({\n            id: proofState?.id,\n            proofSlug,\n            companyId: proofState.companyId,\n            auditReport_assets,\n            auditReport_validUntilAt: certificate_validUntilAt?.valueOf(),\n            certificate_assets,\n            certificate_validUntilAt: certificate_validUntilAt?.valueOf(),\n            comment,\n            other_assets,\n            status: status?.value as ProofStateStatus,\n            esgMetricStatus,\n          });\n          const apiResult = await api.upsertDbModel(\n            \"ProofState\",\n            newProofState as any\n          );\n          companiesQuery.refetch();\n          if (!apiResult.isSuccessful)\n            reject(apiResult.message || \"Something went wrong\");\n          if (!apiResult.result?.isSuccesful)\n            reject(apiResult.result?.message || \"Something went wrong\");\n          resolve(apiResult.result?.message || \"Successfully updated\");\n        }}\n        stickySubmit={true}\n        renderInputContainer={HorizontalInputContainer}\n      />\n    </Div>\n  );\n}"
  },
  "proofStateStatusOptions": {
    "name": "proofStateStatusOptions",
    "slug": "TsVariable",
    "id": "cofqldrcaysegvprduptfcba",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "ProofStatusChip": {
    "name": "ProofStatusChip",
    "slug": "TsFunction",
    "id": "qdgnjsvmoqfmfntxgfzzeqko",
    "description": "This is priority chip that is used to communicate the priority of an company requirement outside of tables",
    "operationName": "passionfruit-ui",
    "rawText": " ({ data }: { data: ProofStateStatus }) => {\n  const proofStatusColors: { [data: string]: ChipColorEnum } = {\n    completed: \"FilledGreen\",\n    workingOnIt: \"FilledOrange\",\n    todo: \"FilledWeak\",\n  };\n  const color: ChipColorEnum = proofStatusColors[data];\n\n  return (\n    <Div className=\"align-middle items-center \">\n      <StyledChip color={color} size=\"sm\" value={data}></StyledChip>\n    </Div>\n  );\n}"
  },
  "ProofValueChip": {
    "name": "ProofValueChip",
    "slug": "TsFunction",
    "id": "fzwbkeqrlyjjermubzdgeipv",
    "description": "This is priority chip that is used to communicate the priority of an company requirement outside of tables",
    "operationName": "passionfruit-ui",
    "rawText": " ({ data }: { data: ProofState }) => {\n  const proofValueColors: { [data: string]: ChipColorEnum } = {\n    yes: \"OutlineGreen\",\n    no: \"OutlineRed\",\n    notAssessed: \"OutlineWeak\",\n  };\n  const color: ChipColorEnum = proofValueColors[data];\n\n  return (\n    <Div className=\"align-middle items-center\">\n      <StyledChip color={color} size=\"sm\" value={data} />\n    </Div>\n  );\n}"
  },
  "RenderCompanyEsgPolarArea": {
    "name": "RenderCompanyEsgPolarArea",
    "slug": "TsFunction",
    "id": "gvhkxiqzwvelkyofgyzmxngy",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " (props: PolarAreaType) => {\n  const { data, type } = props;\n\n  const esgMetrics = data?.map((x) =>\n    x?.companyEsgMetricProofStatesCalculated?.filter(\n      (x) => x?.categoryStack[0] === type\n    )\n  );\n\n  const totalPositive = esgMetrics\n    ?.map(\n      (esgMetric) =>\n        esgMetric\n          ?.map((x: EsgMetric) => x?.positiveProofsCalculated?.length || 0)\n          ?.reduce(\n            (previous: number, current: number) => previous + current,\n            0\n          ) || 0\n    )\n    .reduce((previous: number, current: number) => previous + current, 0);\n\n  const totalNegative = esgMetrics\n    ?.map(\n      (esgMetric) =>\n        esgMetric\n          ?.map((x: EsgMetric) => x?.negativeProofsCalculated?.length || 0)\n          ?.reduce(\n            (previous: number, current: number) => previous + current,\n            0\n          ) || 0\n    )\n    .reduce((previous: number, current: number) => previous + current, 0);\n\n  const totalNotAssessed = esgMetrics\n    ?.map(\n      (esgMetric) =>\n        esgMetric\n          ?.map((x: EsgMetric) => x?.notAssessedProofsCalculated?.length || 0)\n          ?.reduce(\n            (previous: number, current: number) => previous + current,\n            0\n          ) || 0\n    )\n    .reduce((previous: number, current: number) => previous + current, 0);\n  console.log({ totalPositive: totalPositive });\n  // const totalNotAssessed =\n  // companies\n  //     ?.map((esgMetric) => esgMetric.notAssessedProofsCalculated?.length || 0)\n  //     .reduce((previous: number, current: number) => previous + current, 0) ||\n  //   0;\n\n  // const totalPositive =\n  //   esgMetrics\n  //     ?.map((esgMetric) => esgMetric.positiveProofsCalculated?.length || 0)\n  //     .reduce((previous: number, current: number) => previous + current, 0) ||\n  //   0;\n\n  // const totalNegative =\n  //   esgMetrics\n  //     ?.map((esgMetric) => esgMetric.negativeProofsCalculated?.length || 0)\n  //     .reduce((previous: number, current: number) => previous + current, 0) ||\n  //   0;\n  const ESGData = {\n    labels: [\"TotalPositive\", \"TotalNegative\", \"Total not assessed\"],\n    datasets: [\n      {\n        label: \"My First Dataset\",\n        data: [totalPositive, totalNegative, totalNotAssessed],\n        backgroundColor: [\"#8075FF\", \"rgb(244 114 182\", \"#fafafa\"],\n      },\n    ],\n  };\n  return (\n    <>\n      <Div className=\"whitespace-nowrap bg-purple-40 py-1 pr-3 text-sm w-52  first-of-type:font-medium text-accent-500 first-of-type:text-accent-800 \">\n        <StyledPolarArea data={ESGData} />\n      </Div>\n    </>\n  );\n}"
  },
  "renderCompanyESGdetails": {
    "name": "renderCompanyESGdetails",
    "slug": "TsFunction",
    "id": "dzchpfudymxykcplksyjylqt",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " ({ item }: { item: EsgMetric[] }) => {\n  const negative = item?.map(\n    (x: Company) => x?.environmentalPerformanceCalculated?.notAssessed\n  );\n  // const positive = item?.positiveProofsCalculated?.map((x) => `${x.proofSlug}`);\n  // const notAssessed = item?.notAssessedProofsCalculated?.map(\n  //   (x) => `${x.proofSlug}`\n  // );\n\n  return (\n    <Div className=\"flex  flex-col p-4\">\n      <Div className=\"mb-4 pb-4  \">\n        <P className=\"font-semibold text-accent-600 flex flex-row\">\n          <P className=\"text-accent-800\">{item} </P> &nbsp; is valued in:\n        </P>\n      </Div>\n      {/* {notAssessed ? (\n        <TooltipGroup item={notAssessed}>\n          <List\n            label=\"notAssessed\"\n            icon=\"DocumentTextIconSolid\"\n            data={notAssessed}\n          />\n        </TooltipGroup>\n      ) : null}\n      {positive ? (\n        <TooltipGroup item={positive}>\n          <List label=\"positive\" icon=\"DocumentTextIconSolid\" data={positive} />\n        </TooltipGroup>\n      ) : null} */}\n      {negative ? (\n        <TooltipGroup item={negative}>\n          <List\n            title=\"\"\n            label=\"negative\"\n            icon=\"DocumentOutline\"\n            data={negative}\n          />\n        </TooltipGroup>\n      ) : null}\n    </Div>\n  );\n}"
  },
  "renderEsgProgressBar": {
    "name": "renderEsgProgressBar",
    "slug": "TsFunction",
    "id": "ndlbbikqtgdeltunqsnlnoje",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  item: TModel,\n  key: keyof TModel,\n  type: \"environment\" | \"social\",\n  popover?: TModel\n) => {\n  const esgMetrics = item[key]?.filter(\n    (x: TModel) => x.categoryStack[0] === type\n  );\n\n  const totalNotAssessed =\n    esgMetrics\n      ?.map(\n        (esgMetric: TModel) =>\n          esgMetric.notAssessedProofsCalculated?.length || 0\n      )\n      .reduce((previous: number, current: number) => previous + current, 0) ||\n    0;\n\n  const totalPositive =\n    esgMetrics\n      ?.map(\n        (esgMetric: TModel) => esgMetric.positiveProofsCalculated?.length || 0\n      )\n      .reduce((previous: number, current: number) => previous + current, 0) ||\n    0;\n\n  const totalNegative =\n    esgMetrics\n      ?.map(\n        (esgMetric: TModel) => esgMetric.negativeProofsCalculated?.length || 0\n      )\n      .reduce((previous: number, current: number) => previous + current, 0) ||\n    0;\n  const total = totalNegative + totalNotAssessed + totalPositive;\n\n  return (\n    <>\n      {total}\n      {/* {total !== 0 ? (\n        <Popover enabled={true} label={popover} placement=\"bottom\">\n          <Div className=\"whitespace-nowrap py-1 pr-3 text-sm w-52  first-of-type:font-medium text-accent-500 first-of-type:text-accent-800 \">\n            <ProgressBarMultiple\n              notAssessed={totalNotAssessed}\n              successful={totalPositive}\n              unsuccessful={totalNegative}\n              label={total}\n            />\n          </Div>\n        </Popover>\n      ) : (\n        \"\"\n      )} */}\n    </>\n  );\n}"
  },
  "renderESGMetricdetails": {
    "name": "renderESGMetricdetails",
    "slug": "TsFunction",
    "id": "zvogxxstcipuqtuusnvebath",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " (item: EsgMetric) => {\n  const negative = item?.negativeProofsCalculated?.map((x) => `${x.proofSlug}`);\n  const positive = item?.positiveProofsCalculated?.map((x) => `${x.proofSlug}`);\n  const notAssessed = item?.notAssessedProofsCalculated?.map(\n    (x) => `${x.proofSlug}`\n  );\n\n  return (\n    <Div className=\"flex  flex-col p-4\">\n      <Div className=\"border-b border-accent-200 mb-4 pb-4  \">\n        <P className=\"font-semibold text-accent-600 flex flex-row\">\n          {/* Does the docuemnt &nbsp; <P className=\"text-blue-600\">{item.name}</P> sufficient: */}\n          Does it meets the requirements?\n        </P>\n      </Div>\n\n      {positive ? (\n        <TooltipGroup item={positive}>\n          <List label=\"yes\" data={positive} />\n        </TooltipGroup>\n      ) : null}\n      {negative ? (\n        <TooltipGroup item={negative}>\n          <List label=\"no\" data={negative} />\n        </TooltipGroup>\n      ) : null}\n      {notAssessed ? (\n        <TooltipGroup item={notAssessed}>\n          <List label=\"notAssessed\" data={notAssessed} />\n        </TooltipGroup>\n      ) : null}\n    </Div>\n  );\n}"
  },
  "renderGetArrayLength": {
    "name": "renderGetArrayLength",
    "slug": "TsFunction",
    "id": "blqmkhkwpvonqlfahthajtki",
    "description": "render arrays that only return a string",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  item: TModel,\n  key: keyof TModel\n) => {\n  return (\n    <Div className=\"flex gap-x-1 items-center\">\n      <CategoryIcon category={key} size=\"xs\" color=\"OutlineWeak\" />\n      <Div className=\"capitalize gap-2 \">{item[key]?.length}</Div>\n    </Div>\n  );\n}"
  },
  "renderGetArrayNames": {
    "name": "renderGetArrayNames",
    "slug": "TsFunction",
    "id": "hppdjeeoswytnakkszfewaah",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  item: TModel,\n  key:\n    | \"contribution_locations\"\n    | \"esgMetrics\"\n    | \"companyTypes\"\n    | \"activitys\"\n    | \"proofs\"\n    | \"products\"\n    | \"companyRequirementsCalculated\"\n    | \"contribution_activitySlugsCalculated\"\n) => {\n  return (\n    <Div className=\"flex flex-col align-top gap-2 max-w-fit\">\n      {item[key].length ? (\n        item[key]?.map((item: any) => (\n          <StyledTooltipChip word={item.name}></StyledTooltipChip>\n        ))\n      ) : (\n        <P className=\"text-accent-300\">All selected</P>\n      )}\n    </Div>\n  );\n}"
  },
  "renderGetArray": {
    "name": "renderGetArray",
    "slug": "TsFunction",
    "id": "lpzxrdenvrydfjzhfjtqziao",
    "description": "render arrays that only return a string",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  item: TModel,\n  key: keyof TModel\n) => {\n  return (\n    <Div>\n      <Div className=\"capitalize gap-2 \">\n        {item[key]?.map((item: any) => (\n          <Div className=\"pb-2 last-of-type:pb-0 \">\n            <StyledTooltipChip word={item}></StyledTooltipChip>\n          </Div>\n        ))}\n      </Div>\n    </Div>\n  );\n}"
  },
  "renderGetCategoryIcons": {
    "name": "renderGetCategoryIcons",
    "slug": "TsFunction",
    "id": "desohooauqugayyoprxuakgv",
    "description": "TO Build: Making it possible to render icons from different depth levels in the database",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  item: TModel,\n  targetPageName?: string,\n  key?: keyof TModel,\n  firstIconKey?: keyof TModel | undefined,\n  secondIconKey?: any\n) => {\n  return firstIconKey ? (\n    <CategoryIcon\n      size=\"sm\"\n      color={\n        secondIconKey\n          ? item?.[firstIconKey]?.[secondIconKey]\n          : item?.[firstIconKey]\n      }\n      category={\n        secondIconKey\n          ? item?.[firstIconKey]?.[secondIconKey]\n          : item?.[firstIconKey]\n      }\n    />\n  ) : null;\n}"
  },
  "renderGetCategoryLabel": {
    "name": "renderGetCategoryLabel",
    "slug": "TsFunction",
    "id": "hoidwszsfxjywldrmnhpybzz",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  item: TModel,\n  targetPageName?: string,\n  key?: keyof TModel,\n  firstIconKey?: keyof TModel | undefined,\n  secondIconKey?: any,\n  fallbackIcon?: keyof typeof categoryIconEnum\n) => {\n  return firstIconKey ? (\n    <CategoryLabel\n      size=\"sm\"\n      category={\n        firstIconKey\n          ? secondIconKey\n            ? item?.[firstIconKey]?.[secondIconKey]\n            : item?.[firstIconKey]\n          : fallbackIcon\n      }\n    />\n  ) : null;\n}"
  },
  "renderGetCompanyLogo": {
    "name": "renderGetCompanyLogo",
    "slug": "TsFunction",
    "id": "rdjhnscfiacetzabuhndtbha",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  item: TModel,\n  key?: keyof TModel,\n  companyDomain?: string\n) => {\n  return companyDomain ? (\n    <Div className=\"w-12 h-12 p-2 items-center bg-white flex  border border-black/10 rounded-md overflow-clip\">\n      <img\n        src={`https://logo.clearbit.com/${companyDomain}?size=42`}\n        data-default-src=\"https://upload.wikimedia.org/wikipedia/commons/c/ce/Example_image.png\"\n      ></img>\n    </Div>\n  ) : null;\n}"
  },
  "renderGetCompanyTranspTooltip": {
    "name": "renderGetCompanyTranspTooltip",
    "slug": "TsFunction",
    "id": "qgmendqogcremmvuysvzspvr",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " (\n  item: Company | undefined,\n  key: keyof Company\n) => {\n  const companyInfo =\n    item?.transparencyDetailsCalculated?.notFilledInFormFields;\n  const goals = item?.transparencyDetailsCalculated?.requirementsTodoNames;\n\n  return (\n    <Div className=\"flex flex-col p-4 gap-4 pb-4\">\n      <Div className=\"border-b border-accent-200 \">\n        <Div className=\"pb-4\">\n          <ProgressBarSingle\n            color=\"purple\"\n            value={item?.transparencyPercentageCalculated}\n            label\n          />\n        </Div>\n        <P className=\"font-semibold text-gray-800 pb-1\">What are we missing?</P>\n      </Div>\n      <TooltipGroup item={companyInfo}>\n        <List\n          label=\"\"\n          title=\"Company info\"\n          icon=\"companyTypeOutline\"\n          data={companyInfo}\n        />\n      </TooltipGroup>\n      <TooltipGroup item={goals}>\n        <List\n          label=\"\"\n          title=\"Ongoing actions\"\n          icon=\"sustainabilityOutline\"\n          data={goals}\n        />\n      </TooltipGroup>\n    </Div>\n  );\n}"
  },
  "RenderGetEnvPerformance": {
    "name": "RenderGetEnvPerformance",
    "slug": "TsFunction",
    "id": "blrumrewipjycgdgfcswfkte",
    "description": "Render environmental progressbar and show details on popover",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  item: Company,\n  key: keyof TModel\n) => {\n  return (\n    <Div className=\"bg-white\">\n      <ProgressBarMultiple\n        label={12}\n        notAssessed={24}\n        successful={12}\n        unsuccessful={4}\n      />\n    </Div>\n  );\n}"
  },
  "renderGetIconText": {
    "name": "renderGetIconText",
    "slug": "TsFunction",
    "id": "jgndjrzfjalbecqrzoifcggf",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  item: TModel,\n  key: keyof TModel,\n  firstIconKey: keyof TModel | undefined,\n  secondIconKey?: any\n) => {\n  return (\n    <Div className=\"flex flex-row align-top gap-2 max-w-full  fill-white stroke-gray-800\">\n      <Div className=\"max-w-full\">\n        {renderGetCategoryIcons(item, key, firstIconKey, secondIconKey)}\n      </Div>\n      <P className=\"text-gray-600 w-56 truncate\">{item.name}</P>\n    </Div>\n  );\n}"
  },
  "renderGetMainLink": {
    "name": "renderGetMainLink",
    "slug": "TsFunction",
    "id": "krofandgtwqbvoaactubvzfw",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  item: TModel,\n  targetPageName: string,\n  key: keyof TModel,\n  firstIconKey: keyof TModel | undefined,\n  secondIconKey?: any\n) => {\n  return (\n    <ALink href={`/${targetPageName}?id=${item.id || item.productId}`}>\n      <Div className=\"flex flex-row fill-transparent gap-3 w-full align-middle\">\n        {renderGetCategoryLabel(\n          item,\n          targetPageName,\n          key,\n          firstIconKey,\n          secondIconKey\n        )}\n        <P className=\"row-start-1 font-medium md:w-48 lg:w-full self-center truncate \">\n          {item.name}\n        </P>\n        <Div className=\"w-16 \">\n          <Span className=\"hidden group-hover:inline-block \">\n            <StyledButton size=\"sm\" theme=\"Outlined\">\n              Open\n            </StyledButton>\n          </Span>\n        </Div>\n      </Div>\n    </ALink>\n  );\n}"
  },
  "renderGetPriority": {
    "name": "renderGetPriority",
    "slug": "TsFunction",
    "id": "yeipkqyaylnpgvtubjsmiykc",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  item: TModel\n) => {\n  /**\n   * This is priority chip that is used to communicate the priority of an company requirement\n   */\n\n  const priorityColors: { [key: string]: ChipColorEnum } = {\n    basicCondition: \"FilledSecondary\",\n    nextStep: \"FilledSecondary\",\n  };\n\n  const color: ChipColorEnum = priorityColors[item.priority];\n\n  return (\n    <Div className=\"align-middle items-center\">\n      <StyledChip color={color} size=\"sm\" value={humanCase(item.priority)} />\n    </Div>\n  );\n}"
  },
  "renderGetProgressBarSingle": {
    "name": "renderGetProgressBarSingle",
    "slug": "TsFunction",
    "id": "tcvgridflkjhtjkumozayglp",
    "description": "Render transparency progressbar and show details on popover",
    "operationName": "passionfruit-ui",
    "rawText": " <\n  TModel extends { [key: string]: any }\n>(\n  item: Company,\n  key: keyof TModel,\n  tooltip?: boolean\n) => {\n  return (\n    <Div className=\"pt-1\">\n      <ProgressBarSingle\n        theme=\"light\"\n        color=\"purple\"\n        value={item.transparencyPercentageCalculated}\n        label\n        height=\"sm\"\n        tooltipEnabled={tooltip}\n        tooltipLabel={renderGetCompanyTranspTooltip(\n          item,\n          \"companyEsgMetricProofStatesCalculated\"\n        )}\n      />\n    </Div>\n  );\n}"
  },
  "renderGetProofState": {
    "name": "renderGetProofState",
    "slug": "TsFunction",
    "id": "nrrdptqvmdyvehpfifuzcpnv",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  item: TModel,\n  key: \"company_proofStatesCalculated\"\n) => {\n  const statusColors: { [key: string]: ChipColorEnum } = {\n    completed: \"OutlineGreen\",\n    \"working on it\": \"OutlineOrange\",\n    todo: \"OutlineWeak\",\n  };\n\n  const color: ChipColorEnum =\n    statusColors[item[key]?.map((item: any) => item.status)];\n\n  return (\n    <Div>\n      <Div className=\"capitalize gap-2\">\n        {item[key]?.map((item: any) => (\n          <StyledChip\n            color={color}\n            size=\"sm\"\n            value={humanCase(item.status)}\n          ></StyledChip>\n        ))}\n      </Div>\n    </Div>\n  );\n}"
  },
  "renderGetRequirementStatus": {
    "name": "renderGetRequirementStatus",
    "slug": "TsFunction",
    "id": "rgkicgrltpexyftppukqzltu",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " <\n  TModel extends { [key: string]: any }\n>(\n  item: TModel,\n  key: keyof TModel,\n  popover?: TModel\n) => {\n  const proofStatus = item[key]?.map((x: CompanyRequirement) =>\n    x?.company_proofStatesCalculated?.map((proof) => proof.status)\n  );\n\n  const mergedStatusses = proofStatus\n    ? []?.concat(...proofStatus)?.reduce(function (acc: any, curr: any) {\n        return acc[curr] ? ++acc[curr] : (acc[curr] = 1), acc;\n      }, {})\n    : null;\n\n  const allDone = mergedStatusses?.completed ? mergedStatusses.completed : 0;\n  const allDoing = mergedStatusses?.workingOnIt\n    ? mergedStatusses.workingOnIt\n    : 0;\n  const allTodo = mergedStatusses?.todo ? mergedStatusses.todo : 0;\n  const allStatussess = allDone + allDoing + allTodo;\n  const presentStatus =\n    allDone !== 0 ? (\n      <Div className=\"flex flex-row\">\n        <Div className=\"flex flex-row  gap-x-2 pl-2 text-sm font-normal rounded-full\">\n          <Div className=\"self-center gap-x-1 flex py-0.5 rounded-md  items-center \">\n            {allDone}/{allStatussess}\n            <StyledIcon icon=\"CheckOutline\" color=\"OutlineSuccess\" size=\"sm\" />\n          </Div>\n        </Div>\n      </Div>\n    ) : (\n      <Div className=\"flex flex-row gap-x-2\">\n        <Div className=\"flex flex-row gap-x-1  p-0.5 text-sm font-normal rounded-md\">\n          <Div className=\"self-center flex  px-2 rounded-md text-gray-300\">\n            {allDone}/{allStatussess}\n          </Div>\n        </Div>{\" \"}\n      </Div>\n    );\n\n  return (\n    <>\n      <Div className=\"capitalize gap-2 \">{presentStatus}</Div>\n    </>\n  );\n}"
  },
  "renderGetRequirement": {
    "name": "renderGetRequirement",
    "slug": "TsFunction",
    "id": "zueoaglofbjhcmebromjqhnv",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  item: TModel,\n  key: keyof TModel,\n  onClick: () => void\n) => {\n  return (\n    <Div>\n      <Div className=\"flex flex-row gap-4 align-middle\">\n        <P className=\"row-start-1 w-full self-center truncate\">{item.name}</P>\n        <Div className=\"w-12 -my-1 \">\n          <Span className=\"hidden group-hover:inline-block\">\n            <StyledButton onClick={onClick} size=\"sm\" theme=\"Outlined\">\n              Open\n            </StyledButton>\n          </Span>\n        </Div>\n      </Div>\n    </Div>\n  );\n}"
  },
  "renderGetSidePanel": {
    "name": "renderGetSidePanel",
    "slug": "TsFunction",
    "id": "flxtnmcbuybfypessejhhibz",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  item: TModel,\n  key: keyof TModel,\n  firstIconKey: keyof TModel | string,\n  secondIconKey?: keyof TModel | undefined,\n  onClick?: () => void\n) => {\n  return (\n    <Div className=\" w-full\">\n      <Div className=\"flex flex-row gap-5 fill-transparent items-center \">\n        {renderGetCategoryLabel(\n          item,\n          undefined,\n          key,\n          firstIconKey,\n          secondIconKey,\n          \"companyType\"\n        )}\n        {/* <Div className=\"w-12 h-12\">\n          {renderGetCompanyLogo(item, key, \"www.declementeconserve.com/\")}\n        </Div> */}\n        <P className=\"row-start-1 font-medium w-full self-center truncate \">\n          {item.name}\n        </P>{\" \"}\n        <Div className=\"w-12 -my-1 \">\n          <Span className=\"hidden group-hover:inline-block \">\n            <StyledButton onClick={onClick} size=\"sm\" theme=\"Outlined\">\n              Open\n            </StyledButton>\n          </Span>\n        </Div>\n      </Div>\n    </Div>\n  );\n}"
  },
  "renderGetStaticIconArray": {
    "name": "renderGetStaticIconArray",
    "slug": "TsFunction",
    "id": "bbceukrjmguskprlcczowfjz",
    "description": "render arrays that only return a string",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  item: TModel,\n  key: keyof TModel,\n  // icon: typeof iconVariants\n  icon: any\n) => {\n  return (\n    <Div>\n      <Div className=\"capitalize gap-2 \">\n        {item[key]?.map((item: any) => (\n          <Div className=\"pb-2 w-full  last-of-type:pb-0 flex flex-row align-middle fill-gray-200 items-center \">\n            {/* <Span className=\"opacity-70\">\n              <StyledIcon icon={icon} size={\"sm\"} color={\"Inherit\"} />\n            </Span> */}\n            <StyledTooltipChip word={item}></StyledTooltipChip>\n          </Div>\n        ))}\n      </Div>\n    </Div>\n  );\n}"
  },
  "renderGetSumArray": {
    "name": "renderGetSumArray",
    "slug": "TsFunction",
    "id": "biynnifdemgkextarpzarhpt",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  item: TModel,\n  key: keyof TModel\n) => {\n  return (\n    <Div className=\"flex flex-row align-top gap-2 fill-white stroke-accent-400\">\n      <P className=\"text-sm\">{item[key]?.length}</P>\n      {/* <TooltipGroup item={item}>\n        <List title=\"Company info\" icon=\"XIconCircleIconsolid\" data={item} />\n      </TooltipGroup> */}\n    </Div>\n  );\n}"
  },
  "renderGetSummarizedArray": {
    "name": "renderGetSummarizedArray",
    "slug": "TsFunction",
    "id": "nwixkggfeobozezufxnlfdyk",
    "description": "render arrays that only return a string",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  props: RenderGetSummarizedArray<TModel>\n) => {\n  const { item, key } = props;\n  const summary = item[key]?.reduce(\n    (acc: any, item: any) => ((acc[item] = (acc[item] || 0) + 1), acc),\n    []\n  );\n  const summarizedArr = Object?.keys(summary)?.map(function (key) {\n    return (\n      <Div className=\"flex flex-row gap-1 align-middle\">\n        <StyledTooltipChip word={humanCase(key)}></StyledTooltipChip>\n        {summary[key] > 1 ? (\n          <Div></Div>\n        ) : (\n          // <Div className=\"px-1.5 text-accent-500 bg-blueGray-100 flex flex-row font-medium rounded-md  \">\n          //   <P className=\"text-xs self-center\">{summary[key]}</P>\n          //   <P className=\"text-xs self-center lowercase\">x</P>\n          // </Div>\n          \"\"\n        )}\n      </Div>\n    );\n  });\n  return (\n    <Div>\n      <Div className=\"capitalize gap-2 \">\n        {summarizedArr?.map((item: any) => (\n          <Div className=\"pb-2 last-of-type:pb-0 \">\n            <P>{item}</P>\n          </Div>\n        ))}\n      </Div>\n    </Div>\n  );\n}"
  },
  "renderGetTier": {
    "name": "renderGetTier",
    "slug": "TsFunction",
    "id": "htksctdczskqrpeheloruihv",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  item: TModel,\n  key: keyof TModel\n) => {\n  const values = item[key]?.filter(notEmpty);\n  const value = values\n    ? values?.map((tier: number) => (\n        <StyledChip\n          color=\"FilledSecondary\"\n          size=\"sm\"\n          value={`${\n            tier === 0\n              ? \"owner\"\n              : tier === 1\n              ? \"contract supplier\"\n              : \"tier\" + tier\n          }`}\n        ></StyledChip>\n      ))\n    : null;\n  // .join(\"\\n\");\n\n  return <Div className=\"flex flex-col  gap-2\">{value}</Div>;\n}"
  },
  "renderMetricProgressBar": {
    "name": "renderMetricProgressBar",
    "slug": "TsFunction",
    "id": "jjwvwjjkfxqpcwneyjbqydwb",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " (\n  item: EsgMetric,\n  popover: EsgMetric,\n  label?: Company\n) => {\n  const totalNegative = item?.negativeProofsCalculated;\n  const totalPositive = item.positiveProofsCalculated;\n  const totalNotAssessed = item?.notAssessedProofsCalculated;\n\n  // check if undefined\n  const totalNegativeNumber =\n    totalNegative !== undefined ? totalNegative?.length : 0;\n  const totalPositiveNumber =\n    totalPositive !== undefined ? totalPositive?.length : 0;\n  const totalNotAssessedNumber =\n    totalNotAssessed !== undefined ? totalNotAssessed?.length : 0;\n  const total =\n    totalNegativeNumber + totalPositiveNumber + totalNotAssessedNumber;\n  console.log(item);\n  return (\n    <>\n      {total !== 0 ? (\n        <Popover label={popover} enabled={true} placement=\"bottom\">\n          <Div className=\"whitespace-nowrap py-1 pr-3 text-sm w-32 overflow-hidden  first-of-type:font-medium text-accent-600 first-of-type:text-accent-800 \">\n            <Div className=\"flex flex-row gap-x-1 w-full items-center\">\n              <Span className=\"flex flex-row gap-x-1 items-center pr-1 text-sm text-gray-900 font-normal\">\n                <StyledIcon\n                  icon=\"DocumentOutline\"\n                  color=\"OutlineWeak\"\n                  size=\"xs\"\n                />\n                {total}\n              </Span>\n              {totalPositive?.map(() => (\n                <StyledIcon\n                  icon=\"CheckCircleIconSolid\"\n                  color=\"FilledSuccess\"\n                  size={\"sm\"}\n                />\n              ))}\n              {totalNegative?.map(() => (\n                <StyledIcon\n                  icon=\"XIconCircleIconsolid\"\n                  color=\"FilledError\"\n                  size={\"sm\"}\n                />\n              ))}\n              {totalNotAssessed?.map(() => (\n                <StyledIcon\n                  icon=\"QuestionMarkCircleSolid\"\n                  color=\"FilledSoft\"\n                  size={\"sm\"}\n                />\n              ))}\n            </Div>\n          </Div>\n        </Popover>\n      ) : (\n        <Div className=\"text-accent-300\">Unknown</Div>\n      )}\n    </>\n  );\n}"
  },
  "renderNestedText": {
    "name": "renderNestedText",
    "slug": "TsFunction",
    "id": "snaviueeerrxfxjvvrbpsbmt",
    "description": "render arrays that only return a string",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  item: TModel,\n  firstKey: keyof TModel,\n  secondKey: any\n) => {\n  return (\n    <Div>\n      <Div className=\"capitalize gap-2 \">{item?.[firstKey]?.[secondKey]}</Div>\n    </Div>\n  );\n}"
  },
  "SearchField": {
    "name": "SearchField",
    "slug": "TsFunction",
    "id": "ihcevsckstvjlsfbxkrfkemw",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  props: SearchFieldType<TModel>\n) => {\n  const { handleChange, searchInput, clearInput } = props;\n  return (\n    <Div className=\"relative\">\n      <Div className=\"\">\n        <TextInput\n          onChange={handleChange}\n          value={searchInput}\n          config={{}}\n          uniqueFieldId={`${Math.floor(Math.random() * 100)}-search`}\n          extra={{\n            theme: \"Outlined\",\n            size: \"md\",\n            // placeholder: `Type to search`,\n          }}\n          fieldName=\"text\"\n        />\n      </Div>\n      {searchInput.length >= 1 ? (\n        <Div\n          onClick={clearInput}\n          className=\"absolute cursor-pointer text-sm text-gray-400 px-2 py-2 fill-black/20 hover:fill-black/50   stroke-transparent top-0 right-0 bottom-0 h-full flex items-center pr-3\"\n        >\n          <StyledIcon icon=\"XIconSolid\" size=\"sm\" color=\"Inherit\" />\n        </Div>\n      ) : (\n        <Div className=\"absolute text-sm text-gray-400 pointer-events-none fill-transparent stroke-black/30 top-0 left-0 bottom-0 h-full flex items-center pl-2\">\n          <StyledIcon icon=\"searchOutline\" size=\"sm\" color=\"Inherit\" />\n          <P>Type to search</P>\n        </Div>\n      )}\n    </Div>\n  );\n}"
  },
  "SideMenu": {
    "name": "SideMenu",
    "slug": "TsFunction",
    "id": "igctmbzjpeeeadobpxybcnee",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " () => {\n  const [authToken, setAuthToken] = useStore(\"api.authToken\");\n  return (\n    //bg-gradient-to-b from-blue-500/5 to-purple-500/5\n    <Div className=\"py-5 overflow-y- border-r border-blueGray-100  bg-gray-50  min-h-screen w-64\">\n      {/* <Logo /> */}\n      <Login />\n      <ProgressLinks />\n      <PlanningLinks />\n      <AdminLinks />\n      <ExternalLinks />      \n      <Div\n        className=\"py-4 absolute bottom-0 max-h-max px-2 min-h-max justify-end flex flex-col\"\n        scroll\n      >\n        <Span\n          onClick={() => {\n            setAuthToken(null);\n          }}\n        >\n          <StyledButton\n            theme=\"Plain\"\n            size=\"Inherit\"\n            extraClassName=\"flex flex-row w-full font-normal gap-x-5 pl-2 pr-2 h-10 items-center text-sm text-accent-600  hover:bg-accent-100 stroke-accent-600 rounded-md  hover:text-accent-700 \"\n          >\n            <StyledIcon color=\"OutlineWeak\" size=\"sm\" icon=\"LoginIcon\" />\n            <P>Logout</P>\n          </StyledButton>\n        </Span>\n      </Div>\n    </Div>\n  );\n}"
  },
  "SocialTab": {
    "name": "SocialTab",
    "slug": "TsFunction",
    "id": "bptduiresweeiamoxetaankn",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " ({ data }: { data?: Company }) => {\n  return <TabContent title=\"Social\" icon=\"socialOutline\" />;\n}"
  },
  "sortedArray": {
    "name": "sortedArray",
    "slug": "TsFunction",
    "id": "mlverbwsudkqhqqvdxtczemt",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  data: TModel | undefined,\n  key: keyof TModel\n) => {\n  return data?.sort((a: TModel, b: TModel) => a[key]?.localeCompare(b[key]));\n}"
  },
  "statusOptions": {
    "name": "statusOptions",
    "slug": "TsVariable",
    "id": "qpehnidfeazdmypvpzsuuukt",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "TabContent": {
    "name": "TabContent",
    "slug": "TsFunction",
    "id": "itmjzuozgqfbbktdqkddrapn",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>(\n  props: TabContentType<TModel>\n) => {\n  return (\n    <Div className=\"flex flex-row gap-2 align-middle \">\n      <StyledIcon icon={props.icon} size=\"sm\" color=\"OutlineWeak\" />\n      <P>{props.title}</P>\n      {props.label}\n      {props.toCount && typeof props.toCount === \"string\" ? (\n        <Counter data={props?.toCount} />\n      ) : null}\n    </Div>\n  );\n}"
  },
  "TooltipGroup": {
    "name": "TooltipGroup",
    "slug": "TsFunction",
    "id": "qrxchykrifhrldvfqmsfnnmx",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " <TModel extends { [key: string]: any }>({\n  item,\n  children,\n}: {\n  item: TModel;\n  children: any;\n}) => {\n  return (\n    <Div className=\" last-of-type:border-none\">\n      {item?.length != 0 ? children : null}\n    </Div>\n  );\n}"
  },
  "ValueChainCard": {
    "name": "ValueChainCard",
    "slug": "TsFunction",
    "id": "yevnwujagurhewmryxevciav",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": " ({\n  icon,\n  contribution,\n  isVisible,\n  openSidePanel,\n  popoverValue,\n  active,\n}: {\n  icon?: any;\n  contribution: Contribution;\n  isVisible: Boolean;\n  openSidePanel?: MouseEventHandler<HTMLDivElement>;\n  popoverValue?: string | JSX.Element;\n  active: boolean;\n}) => {\n  /** generating the rows for this card */\n\n  const cardRows = [\n    // {\n    //   slug: \"activity\",\n    //   group: \"top\",\n    //   icon: \"activityOutline\",\n    //   value: contribution.valueChainPhase?.activity?.name,\n    //   isVisible: isVisible,\n    //   hasPopover: true,\n    //   popoverValue: \"Information about activity\",\n    // },\n    {\n      slug: \"location\",\n      group: \"top\",\n      icon: \"locationOutline\",\n      value: contribution.location?.name,\n      isVisible: true,\n      hasPopover: true,\n      popoverValue: \"Popover\",\n    },\n    {\n      slug: \"ingredient\",\n      group: \"top\",\n      icon: \"ingredientOutline\",\n      value: contribution?.sub_product?.name,\n      isVisible: isVisible,\n      hasPopover: true,\n      popoverValue: \"Popover\",\n    },\n    {\n      slug: \"requirements\",\n      group: \"bottom\",\n      icon: \"DocumentOutline\",\n      value: `${contribution.company?.numberOfOpenRequirementsCalculated} Ongoing goals`,\n\n      isVisible: isVisible,\n      hasPopover: true,\n      popoverValue: \"Popover\",\n    },\n    {\n      slug: \"transparency\",\n      group: \"bottom\",\n      icon: \"transparencyOutline\",\n      value: (\n        <Div className=\"w-2\">\n          <ProgressBarSingle\n            theme=\"light\"\n            color=\"purple\"\n            value={contribution?.company?.transparencyPercentageCalculated}\n            label\n            tooltipEnabled\n            tooltipLabel={\n              <Div>\n                {contribution?.company?.transparencyDetailsCalculated\n                  .notFilledInFormFields.length != 0 ? (\n                  <Div>\n                    <Div className=\"pb-2\">\n                      <P className=\"text-xs uppercase text-gray-400\">\n                        Open company info\n                      </P>\n                    </Div>\n                    {contribution?.company?.transparencyDetailsCalculated.notFilledInFormFields.map(\n                      (formItems: any) => (\n                        <Div>\n                          <Div className=\"flex flex-row gap-1\">\n                            <StyledIcon\n                              icon=\"XIconCircleIconsolid\"\n                              color=\"FilledWeak\"\n                              size=\"xs\"\n                            />\n                            {formItems}\n                          </Div>\n                        </Div>\n                      )\n                    )}\n                  </Div>\n                ) : null}\n\n                {contribution?.company?.transparencyDetailsCalculated\n                  .requirementsTodoNames.length != 0 ? (\n                  <Div>\n                    <Div className=\"py-2\">\n                      <P className=\"text-xs uppercase text-gray-400\">\n                        Open goals:\n                      </P>\n                    </Div>\n                    {contribution?.company?.transparencyDetailsCalculated.requirementsTodoNames.map(\n                      (requirements: any) => (\n                        <Div className=\"flex flex-row gap-1\">\n                          <StyledIcon\n                            icon=\"XIconCircleIconsolid\"\n                            color=\"FilledWeak\"\n                            size=\"xs\"\n                          />\n                          {requirements}\n                        </Div>\n                      )\n                    )}\n                  </Div>\n                ) : null}\n              </Div>\n            }\n          />\n        </Div>\n      ),\n      isVisible: isVisible,\n      hasPopover: true,\n      popoverValue: \"Popover\",\n    },\n    // {\n    //   slug: \"environmental\",\n    //   group: \"bottom\",\n    //   icon: \"environmentalOutline\",\n    //   value: (\n    //     <ProgressBarMultiple\n    //       successful={12}\n    //       unsuccessful={12}\n    //       notAssessed={20}\n    //       label={false}\n    //     />\n    //   ),\n    //   isVisible: isVisible,\n    //   hasPopover: true,\n    //   popoverValue: \"Popover\",\n    // },\n    // {\n    //   slug: \"social\",\n    //   group: \"bottom\",\n    //   icon: \"socialOutline\",\n    //   value: (\n    //     <ProgressBarMultiple\n    //       successful={24}\n    //       unsuccessful={12}\n    //       notAssessed={2}\n    //       label={false}\n    //     />\n    //   ),\n    //   isVisible: isVisible,\n    //   hasPopover: true,\n    //   popoverValue: \"Popover\",\n    // },\n    // {\n    //   slug: \"governance\",\n    //   group: \"bottom\",\n    //   icon: \"governanceOutline\",\n    //   value: (\n    //     <ProgressBarMultiple\n    //       successful={12}\n    //       unsuccessful={12}\n    //       notAssessed={20}\n    //       label={false}\n    //     />\n    //   ),\n    //   isVisible: isVisible,\n    //   hasPopover: true,\n    //   popoverValue: \"Popover\",\n    // },\n    {\n      slug: \"requirements\",\n      group: \"bottom\",\n      icon: \"DocumentOutline\",\n      value: `${contribution.company?.numberOfOpenRequirementsCalculated} Ongoing goals`,\n\n      isVisible: isVisible,\n      hasPopover: true,\n      popoverValue: \"Popover\",\n    },\n  ];\n\n  /** decide if the rows need to be in the top or bottom group of the card */\n  const topRowGroup = cardRows.filter((row) => {\n    return row.group === \"top\";\n  });\n  const bottomRowGroup = cardRows.filter((row) => {\n    return row.group === \"bottom\";\n  });\n\n  //get div height\n  const ref = useRef<\"offsetHeight\" | \"offsetWidth\">(\"offsetHeight\");\n  const [_, setWidth] = useStore(\"valueChainCardWidth\");\n  const [__, setHeight] = useStore(\"valueChainCardHeight\");\n  const [selectedContributionId, ___] = useUrl(\"selectedContributionId\");\n  const [linkedContributionId, showLinkedContributionId] = useStore(\n    \"linkedContributionIdHover\"\n  );\n  const [selectedMonths, ____] = useStore(\"selectedMonths\");\n\n  /** FILTER ON MONTH */\n  //check if a selection is the same as the filter\n  const filterMonths = arrayValuesExist(\n    selectedMonths,\n    contribution.supplyingMonths\n  );\n\n  // check if there are monhts selected\n  selectedMonths.length !== 0 ? (active = !filterMonths) : active;\n  useLayoutEffect(() => {\n    setWidth(ref.current.offsetWidth);\n    setHeight(ref.current.offsetHeight);\n  }, []);\n\n  return (\n    <Div\n      ref={ref}\n      onMouseOver={() => showLinkedContributionId(contribution.id)}\n      onMouseLeave={() => showLinkedContributionId(null)}\n      className=\"cursor-pointer mx-1 \"\n      onClick={openSidePanel}\n    >\n      <Div\n        className={` hover:ring-4 hover:ring-sky-800/80 \n        ${\n          selectedContributionId === contribution.id\n            ? \"ring-4 hover:ring-sky-800\"\n            : linkedContributionId === contribution.id\n            ? \"ring-4 ring-blue/700\"\n            : \"ring-0 hover:ring-sky-800 \"\n        } \n        grid  w-80 grid-row-auto  overflow-hidden ease-out hover:ring-sky-800/80transition duration-100 mx-auto ${\n          active ? `bg-blueGray-200 border` : \"bg-white shadow-lg\"\n        }   rounded-xl items-start `}\n      >\n        <Div className=\"flex flex-col w-80 px-6 pb-6 pt-6 pr-4 gap-y-2\">\n          {contribution?.company?.name ? (\n            <Div className=\" flex flex-row max-w-full fill-transparent items-center gap-x-4\">\n              {/* <CategoryLabelColor\n                category={\n                  contribution.company.companyTypeSlug\n                    ? contribution.company.companyTypeSlug\n                    : \"companyType\"\n                }\n                size=\"sm\"\n              /> */}\n              <CategoryLabelColor\n                category={\n                  contribution.company.companyTypeSlug\n                    ? contribution.company.companyTypeSlug\n                    : \"companyType\"\n                }\n                size=\"sm\"\n              />\n              <P className=\"text-lg max-w-full font-semibold text-gray-800 pr-2 truncate\">\n                {contribution?.company?.name}\n              </P>\n            </Div>\n          ) : (\n            <P className=\"text-lg font-semibold text-gray-300 w-full truncate\">\n              Company unkown\n            </P>\n          )}\n\n          {topRowGroup.map((row) => (\n            <CardRow\n              isVisible={row.isVisible}\n              icon={row.icon}\n              value={row.value}\n              hasPopover={row.hasPopover}\n              popoverValue={row.popoverValue}\n            />\n          ))}\n        </Div>\n        {/* <Div className=\"grid grid-rows-auto px-6 py-4 h-full gap-y-2 bg-accent-50\">\n          {bottomRowGroup.map((row) => (\n            <CardRow\n              isVisible={row.isVisible}\n              icon={row.icon}\n              value={row.value}\n              hasPopover={row.hasPopover}\n              popoverValue={row.popoverValue}\n            />\n          ))}\n        </Div> */}\n      </Div>\n    </Div>\n  );\n}"
  },
  "ValueChainConnectionsForm": {
    "name": "ValueChainConnectionsForm",
    "slug": "TsFunction",
    "id": "yzwfassaicxuzprwmuxnjdee",
    "description": "Now your form can be rendered like this\n\nMake sure to provide the generic based on the inputs type interfaces\n\notherwise your form won't be typesafe!",
    "operationName": "passionfruit-ui",
    "rawText": " (props: {\n  contribution: Contribution | Creation<Contribution> | undefined;\n}) => {\n  const { contribution } = props;\n  const productValueChain = useProductValueChain(\n    contribution?.final_product?.id\n  );\n  const contributionQuery =\n    productValueChain.data?.result?.productValueChain?.contributions;\n\n  const [linkedContributionId, __] = useStore(\"linkedContributionIdHover\");\n  console.log({ product: productValueChain });\n\n  /** Select previous contributions */\n  const contributionOptions: Item<string>[] = contributionQuery\n    ? contributionQuery?.map((contributionOption: Contribution) => {\n        const contributions: Item<string> = {\n          value: contributionOption.id ? contributionOption.id : \"\",\n          label: contributionOption?.name ? contributionOption?.name : \"\",\n        };\n\n        return contributions;\n      })\n    : [];\n\n  const fields = [\n    makeField(\"selectContribution\", {\n      field: \"previousContributionIds\",\n      title: \"Incoming\",\n      initialValue: contributionOptions.filter((x) =>\n        contribution?.previous_contributionIds?.find((i) => x.value === i)\n      ),\n\n      extra: {\n        type: \"upstream\",\n        options: contributionOptions,\n        autoSuggest: true,\n        theme: \"Outlined\",\n        size: \"md\",\n        hover: linkedContributionId || undefined,\n      },\n    }),\n    makeField(\"selectContribution\", {\n      field: \"nextContributionIds\",\n      title: \"Outgoing\",\n      initialValue: contributionOptions.filter((x) =>\n        contribution?.next_contributionsCalculated?.find(\n          (i) => x.value === i.id\n        )\n      ),\n\n      extra: {\n        type: \"downstream\",\n        options: contributionOptions,\n        autoSuggest: true,\n        theme: \"Outlined\",\n        size: \"md\",\n        hover: linkedContributionId || undefined,\n      },\n    }),\n  ];\n\n  return (\n    <Div scroll className=\"py-4 px-8 pb-24 overflow-clip h-auto\">\n      <Form<ContributionForm>\n        fields={fields}\n        renderInputContainer={CustomInputContainer}\n        onSubmit={async (values, resolve, reject) => {\n          //do something with those values\n\n          const updateContribution: Creation<Contribution> = {\n            ...contribution,\n            id: contribution?.id,\n            previousContributionIds: values.previousContributionIds,\n          };\n          const apiResult = await api.upsertDbModel(\n            \"Contribution\",\n            updateContribution as any,\n            true\n          );\n          console.log({ update: updateContribution });\n          productValueChain.refetch();\n\n          if (!apiResult.isSuccessful)\n            reject(apiResult.message || \"Something went wrong\");\n          if (!apiResult.result?.isSuccesful)\n            reject(apiResult.result?.message || \"Something went wrong\");\n\n          resolve(apiResult.result?.message || \"Successfully updated\");\n        }}\n        submitButtonText=\"Save\"\n        noSubmit\n      />\n    </Div>\n  );\n}"
  },
  "createCsvString": {
    "name": "createCsvString",
    "slug": "TsFunction",
    "id": "euxwfpcmfxmzhcixujgyqylw",
    "description": "NB: useful function!",
    "operationName": "parse-address-henrik",
    "rawText": " (array: any[]): string => {\n  const keys = Object.keys(array[0]);\n  const firstLine = keys.join(\",\");\n  const valueLines = array.map((item) => {\n    const valuesArray = Object.values(item);\n    const valuesString = valuesArray.join(\",\");\n    return valuesString;\n  });\n  const valueString = valueLines.join(\"\\n\");\n\n  return `${firstLine}\\n${valueString}`;\n}"
  },
  "oldToNew": {
    "name": "oldToNew",
    "slug": "TsFunction",
    "id": "xccjaypjhjbppivmoldvpczn",
    "description": "",
    "operationName": "parse-address-henrik",
    "rawText": " (oldItem: OldFormat): NewFormat => {\n  const abc = `${oldItem.a}${oldItem.b}${oldItem.c}`;\n\n  const images: string[] = [];\n\n  const newFormatItem: NewFormat = { abc, images };\n\n  return newFormatItem;\n}"
  },
  "parseAddress": {
    "name": "parseAddress",
    "slug": "TsFunction",
    "id": "emantcvkiijvbjzsjmbthvvw",
    "description": "fulladdress is something like \"address, postalcode city\"",
    "operationName": "parse-address-henrik",
    "rawText": " (\n  fullAddress: string\n): { address: string; zip: string | undefined; city: string | undefined } => {\n  const [address, rest] = fullAddress.split(\",\").map((x) => x.trim());\n  const firstLetterInRestIndex = rest\n    ?.split(\"\")\n    .findIndex((char) => charIsLetter(char));\n  const hasNoIndex =\n    firstLetterInRestIndex === -1 || firstLetterInRestIndex === undefined;\n  const beforeLetter = hasNoIndex\n    ? undefined\n    : rest.slice(0, firstLetterInRestIndex).trim();\n  const zip = beforeLetter;\n  const city = hasNoIndex ? undefined : rest.slice(firstLetterInRestIndex);\n\n  return {\n    address,\n    city,\n    zip,\n  };\n}"
  },
  "booleanifyKeys": {
    "name": "booleanifyKeys",
    "slug": "TsFunction",
    "id": "vzcawoeuxaxvcbpdfykfagqr",
    "description": "",
    "operationName": "sprent-migrate",
    "rawText": " <T extends { [key: string]: any }>(\n  item: T,\n  keys: string[]\n) => {\n  const result = keys.reduce((previous, k) => {\n    return {\n      ...previous,\n      [k]: booleanify(item[k] as string),\n    };\n  }, item);\n\n  return result;\n}"
  },
  "booleanify": {
    "name": "booleanify",
    "slug": "TsFunction",
    "id": "jlqexwccqelqlrljjotpppgs",
    "description": "",
    "operationName": "sprent-migrate",
    "rawText": " (text: string): boolean | null => {\n  const lower = text.toLowerCase().trim();\n\n  if ([\"yes\", \"ja\"].includes(lower)) return true;\n\n  if ([\"no\", \"nej\"].includes(lower)) return false;\n\n  return null;\n}"
  },
  "getThisOperationPath": {
    "name": "getThisOperationPath",
    "slug": "TsFunction",
    "id": "dhksrowtwsvcsuvwcaevnobc",
    "description": "",
    "operationName": "sprent-migrate",
    "rawText": " (operationRelativePath: string) => {\n  const operationBasePath = findOperationBasePath(__filename);\n  if (!operationBasePath) return;\n  const absolutePath = path.join(operationBasePath, operationRelativePath);\n  return absolutePath;\n}"
  },
  "makeJson": {
    "name": "makeJson",
    "slug": "TsFunction",
    "id": "gigsgicoyrlfrndwyhnzghin",
    "description": "",
    "operationName": "sprent-migrate",
    "rawText": " async () => {\n  const items = await readCsvFile(getThisOperationPath(\"data/sprent-data.csv\"));\n  await writeJsonToFile(getThisOperationPath(\"data/sprent-data.json\")!, items);\n}"
  },
  "mapJsonItems": {
    "name": "mapJsonItems",
    "slug": "TsFunction",
    "id": "kpinakkvhmtcaedvcnvxkrrw",
    "description": "",
    "operationName": "sprent-migrate",
    "rawText": " async <T, U>(\n  operationRelativePath: string,\n  mapFunction: (item: T) => U\n) => {\n  const absolutePath = getThisOperationPath(operationRelativePath);\n  if (!absolutePath) return;\n  const json = await readJsonFile<T[]>(absolutePath);\n\n  if (!json) return;\n  const newJson = json.map(mapFunction);\n\n  const isSuccessful = await writeJsonToFile(absolutePath, newJson);\n\n  return isSuccessful;\n}"
  },
  "splitDryWash": {
    "name": "splitDryWash",
    "slug": "TsFunction",
    "id": "xgevippotwpasmbyqshoeakq",
    "description": "",
    "operationName": "sprent-migrate",
    "rawText": " ({ dryWash, ...newStuff }: SprentModel) => {\n  const dryWashLowerCase = dryWash.toLowerCase();\n\n  let dry: null | boolean = null;\n  let wash: null | boolean = null;\n  if (dryWashLowerCase.trim() === \"\") {\n    dry = null;\n    wash = null;\n  } else if (dryWashLowerCase === \"ja\") {\n    dry = true;\n    wash = true;\n  } else if (dryWashLowerCase === \"nej\") {\n    dry = false;\n    wash = false;\n  } else {\n    // comma and slash are more prio\n    const parsed = dryWashLowerCase\n      .replaceAll(\",\", \" \")\n      .replaceAll(\"/\", \" \")\n      .split(\" \");\n\n    const booleanified = parsed.map((x) => {\n      if (x.trim() === \"ja\") return true;\n\n      if (x.trim() === \"no\" || x.trim() === \"nej\") {\n        return false;\n      }\n\n      return null;\n    });\n\n    const boolIndex = booleanified.findIndex((x) => x !== null);\n    const firstBool = booleanified.find((x) => x !== null) as\n      | boolean\n      | undefined;\n\n    if (boolIndex === -1) {\n      dry = null;\n      wash = null;\n    } else if (firstBool !== undefined) {\n      dry = firstBool;\n\n      const rest = booleanified.slice(boolIndex + 1);\n\n      const lastBool = rest.find((x) => x !== null) as boolean | undefined;\n\n      if (lastBool !== undefined) {\n        wash = lastBool;\n      }\n    }\n  }\n\n  return {\n    dryWash,\n    ...newStuff,\n    dry,\n    wash,\n  };\n}"
  },
  "toCsv": {
    "name": "toCsv",
    "slug": "TsFunction",
    "id": "qgvzmkirunczrqcnsspuesdt",
    "description": "updateData2();",
    "operationName": "sprent-migrate",
    "rawText": " async () => {\n  const final = getThisOperationPath(\"data/final.csv\");\n  if (!final) return;\n\n  const clients = await readJsonFile<CsvItemType[]>(\n    getThisOperationPath(\"data/sprent-data.json\")\n  );\n  if (!clients) return;\n  const csvString = csvItemArrayToCsvString(clients);\n  fs.writeFileSync(final, csvString, \"utf8\");\n}"
  },
  "updateData2": {
    "name": "updateData2",
    "slug": "TsFunction",
    "id": "xcczjxbvoioiglectcauyakm",
    "description": "",
    "operationName": "sprent-migrate",
    "rawText": " async () => {\n  mapJsonItems<any, SprentModel>(\n    \"data/sprent-data.json\",\n    ({ dryWash, ...old }) => {\n      return { ...old, oldData: { ...old.oldData, dryWash } };\n    }\n  );\n}"
  },
  "updateData": {
    "name": "updateData",
    "slug": "TsFunction",
    "id": "yatwnmyertsgqsvntbrfowxj",
    "description": "",
    "operationName": "sprent-migrate",
    "rawText": " async () => {\n  const clients = await readJsonFile<\n    {\n      objectId: number;\n      results: {\n        url: string;\n        id: string;\n        isSuccessful: boolean;\n        absolutePath: string;\n      }[];\n    }[]\n  >(getThisOperationPath(\"data/clients.json\"));\n  mapJsonItems<SprentModel, any>(\"data/sprent-data.json\", (old) => {\n    const cidNumber = Number(old.cid);\n\n    const imgData =\n      clients\n        ?.find((x) => x.objectId === cidNumber)\n        ?.results?.map(({ id, url }) => ({ id, url })) || [];\n\n    return { ...old, imgData, cid: cidNumber };\n  });\n}"
  },
  "NamedParameters<typeof automatePuppeteer>": {
    "name": "NamedParameters<typeof automatePuppeteer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-automatepuppeteer",
    "description": "",
    "operationName": "ai-browser"
  },
  "NamedParameters<typeof browseInternet>": {
    "name": "NamedParameters<typeof browseInternet>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-browseinternet",
    "description": "",
    "operationName": "ai-browser"
  },
  "NamedParameters<typeof browsingPromptLoop>": {
    "name": "NamedParameters<typeof browsingPromptLoop>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-browsingpromptloop",
    "description": "",
    "operationName": "ai-browser"
  },
  "NamedParameters<typeof fetchUrl>": {
    "name": "NamedParameters<typeof fetchUrl>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fetchurl",
    "description": "",
    "operationName": "ai-browser"
  },
  "NamedParameters<typeof wikipediaGame>": {
    "name": "NamedParameters<typeof wikipediaGame>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-wikipediagame",
    "description": "",
    "operationName": "ai-browser"
  },
  "ContextualPromptResult": {
    "name": "ContextualPromptResult",
    "slug": "TsInterface",
    "id": "contextualpromptresult",
    "description": "A result from a contextual prompt. Doesn't include the full context, for that you can find all results for a certain thread",
    "operationName": "markdown"
  },
  "NamedParameters<typeof anyGetStaticProps>": {
    "name": "NamedParameters<typeof anyGetStaticProps>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-anygetstaticprops",
    "description": "",
    "operationName": "ai-demo-web"
  },
  "NamedParameters<typeof FancyTitle>": {
    "name": "NamedParameters<typeof FancyTitle>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fancytitle",
    "description": "",
    "operationName": "ai-demo-web"
  },
  "NamedParameters<typeof getDefaultApp>": {
    "name": "NamedParameters<typeof getDefaultApp>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdefaultapp",
    "description": "",
    "operationName": "ai-demo-web"
  },
  "NamedParameters<typeof MyLayout>": {
    "name": "NamedParameters<typeof MyLayout>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-mylayout",
    "description": "",
    "operationName": "operation-web"
  },
  "NamedParameters<typeof ResultExample>": {
    "name": "NamedParameters<typeof ResultExample>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-resultexample",
    "description": "",
    "operationName": "ai-demo-web"
  },
  "AuthenticationMethodMethod": {
    "name": "AuthenticationMethodMethod",
    "slug": "TsInterface",
    "id": "authenticationmethodmethod",
    "description": "Username + password should be the default\n\nEmail OTP, phone number OTP (sms or call or whatsapp), should be optional 2FA methods\n\nAll others can also act as authentication methods, but the token shouldn't be stored",
    "operationName": "server-login"
  },
  "CategoryChildObject": {
    "name": "CategoryChildObject",
    "slug": "TsInterface",
    "id": "categorychildobject",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": "\n\nexport type CategoryChildObject = ChildObject<{\n  category: string;\n  count: number;\n}>;"
  },
  "ContextualPrompt": {
    "name": "ContextualPrompt",
    "slug": "TsInterface",
    "id": "contextualprompt",
    "description": "\nModel for prompting information from third party sources",
    "operationName": "markdown"
  },
  "FileType": {
    "name": "FileType",
    "slug": "TsInterface",
    "id": "filetype",
    "description": "",
    "operationName": "filename-conventions",
    "rawText": "\n\nexport type FileType = \"code\" | \"data\" | \"text\";"
  },
  "FunctionContext": {
    "name": "FunctionContext",
    "slug": "TsInterface",
    "id": "functioncontext",
    "description": "Should be attached as first argument of the function, if the name of the function is in the format of:\n\n- `xyzWithContext`: attaches all context\n- `xyzWithContextRaw`: attaches all context, api returns just the result of the function without wrapping it in the `RealApiReturnType`. Needed in case you have a different server.js `server.reply`\n\nFor more info see `apiConvention`",
    "operationName": "server-login"
  },
  "NamedParameters<typeof addStatement>": {
    "name": "NamedParameters<typeof addStatement>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-addstatement",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof addWord>": {
    "name": "NamedParameters<typeof addWord>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-addword",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof biggestFunctionName>": {
    "name": "NamedParameters<typeof biggestFunctionName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-biggestfunctionname",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof checkQueue>": {
    "name": "NamedParameters<typeof checkQueue>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-checkqueue",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof cleanup>": {
    "name": "NamedParameters<typeof cleanup>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-cleanup",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof controlChatGpt>": {
    "name": "NamedParameters<typeof controlChatGpt>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-controlchatgpt",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof controlChatGptCli>": {
    "name": "NamedParameters<typeof controlChatGptCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-controlchatgptcli",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof controlChatGptWrapper>": {
    "name": "NamedParameters<typeof controlChatGptWrapper>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-controlchatgptwrapper",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof convertTo1337speak>": {
    "name": "NamedParameters<typeof convertTo1337speak>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-convertto1337speak",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof deletePromptResult>": {
    "name": "NamedParameters<typeof deletePromptResult>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-deletepromptresult",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof developersQuote>": {
    "name": "NamedParameters<typeof developersQuote>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-developersquote",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof diaryToInstagram>": {
    "name": "NamedParameters<typeof diaryToInstagram>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-diarytoinstagram",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof documentationWriting>": {
    "name": "NamedParameters<typeof documentationWriting>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-documentationwriting",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof emojiAugmentation>": {
    "name": "NamedParameters<typeof emojiAugmentation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-emojiaugmentation",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof explain>": {
    "name": "NamedParameters<typeof explain>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-explain",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof explainInDutch>": {
    "name": "NamedParameters<typeof explainInDutch>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-explainindutch",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof explainInNepali>": {
    "name": "NamedParameters<typeof explainInNepali>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-explaininnepali",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof explainInPortuguese>": {
    "name": "NamedParameters<typeof explainInPortuguese>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-explaininportuguese",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof fixGrammarAndSpellingMistakes>": {
    "name": "NamedParameters<typeof fixGrammarAndSpellingMistakes>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fixgrammarandspellingmistakes",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof getCategoriesTest>": {
    "name": "NamedParameters<typeof getCategoriesTest>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcategoriestest",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof getContextualPrompt>": {
    "name": "NamedParameters<typeof getContextualPrompt>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcontextualprompt",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof getContextualPromptCategories>": {
    "name": "NamedParameters<typeof getContextualPromptCategories>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcontextualpromptcategories",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof getContextualPromptResultJsonFilePath>": {
    "name": "NamedParameters<typeof getContextualPromptResultJsonFilePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcontextualpromptresultjsonfilepath",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof getObjectForkKeyRecursively>": {
    "name": "NamedParameters<typeof getObjectForkKeyRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getobjectforkkeyrecursively",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof gptIdeasRegisterWithContext>": {
    "name": "NamedParameters<typeof gptIdeasRegisterWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gptideasregisterwithcontext",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof haiku>": {
    "name": "NamedParameters<typeof haiku>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-haiku",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof improveCode>": {
    "name": "NamedParameters<typeof improveCode>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-improvecode",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof keywords>": {
    "name": "NamedParameters<typeof keywords>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-keywords",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof marcusAurelius>": {
    "name": "NamedParameters<typeof marcusAurelius>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-marcusaurelius",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof poem>": {
    "name": "NamedParameters<typeof poem>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-poem",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof processChatGptPrompt>": {
    "name": "NamedParameters<typeof processChatGptPrompt>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-processchatgptprompt",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof processPromptOnFile>": {
    "name": "NamedParameters<typeof processPromptOnFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-processpromptonfile",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof processPromptOnFolder>": {
    "name": "NamedParameters<typeof processPromptOnFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-processpromptonfolder",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof removeAllFake>": {
    "name": "NamedParameters<typeof removeAllFake>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removeallfake",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof rickAndMorty>": {
    "name": "NamedParameters<typeof rickAndMorty>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rickandmorty",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof rickAndMortyRick>": {
    "name": "NamedParameters<typeof rickAndMortyRick>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rickandmortyrick",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof setIsFavoritePromptResult>": {
    "name": "NamedParameters<typeof setIsFavoritePromptResult>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-setisfavoritepromptresult",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof socratesAndSnoopDogg>": {
    "name": "NamedParameters<typeof socratesAndSnoopDogg>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-socratesandsnoopdogg",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof storytelling>": {
    "name": "NamedParameters<typeof storytelling>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-storytelling",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof test>": {
    "name": "NamedParameters<typeof test>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-test",
    "description": "",
    "operationName": "slack-controller"
  },
  "NamedParameters<typeof translateEverything>": {
    "name": "NamedParameters<typeof translateEverything>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-translateeverything",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof translateEverythingIntoHindi>": {
    "name": "NamedParameters<typeof translateEverythingIntoHindi>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-translateeverythingintohindi",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof translateEverythingPortuguese>": {
    "name": "NamedParameters<typeof translateEverythingPortuguese>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-translateeverythingportuguese",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof translateToPortuguese>": {
    "name": "NamedParameters<typeof translateToPortuguese>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-translatetoportuguese",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof typescriptExplain>": {
    "name": "NamedParameters<typeof typescriptExplain>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-typescriptexplain",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof williamShakespear>": {
    "name": "NamedParameters<typeof williamShakespear>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-williamshakespear",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof writeContextualPromptSdk>": {
    "name": "NamedParameters<typeof writeContextualPromptSdk>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-writecontextualpromptsdk",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof writeCreatePromptCode>": {
    "name": "NamedParameters<typeof writeCreatePromptCode>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-writecreatepromptcode",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof ye>": {
    "name": "NamedParameters<typeof ye>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-ye",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof yodafy>": {
    "name": "NamedParameters<typeof yodafy>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-yodafy",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "ProcessPromptProps": {
    "name": "ProcessPromptProps",
    "slug": "TsInterface",
    "id": "processpromptprops",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": "\n\nexport type ProcessPromptProps = {\n  contextContent?: string | null;\n  selectionContent?: string | null;\n  contextualPromptSlug?: string;\n  /**\n   * DESCRIPTION: These variables can be used: %context will be replaced by your context, %selection will be replaced by your selection. Provide a good prompt that combines that in a specific format\n   */\n  customPromptContent?: string;\n  saveNewPromptWithName?: string | null;\n  isHeadless?: boolean;\n  prompt_projectRelativePath?: string;\n  thread?: string;\n  /**\n   * If true, it'll just validate if this will be executed, it won't return the actual result but will execute the result in the background\n   */\n  isDeferred?: boolean;\n};"
  },
  "StackCount": {
    "name": "StackCount",
    "slug": "TsInterface",
    "id": "stackcount",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": "\nexport type StackCount = {\n  [stack: string]: number;\n};"
  },
  "AiDemoApp": {
    "name": "AiDemoApp",
    "slug": "TsInterface",
    "id": "aidemoapp",
    "description": "",
    "operationName": "ai-types",
    "rawText": "\n\n/**\n * ---\n * dbStorageMethod: jsonSingle\n * ---\n */\nexport interface AiDemoApp extends SlugModelType {\n  /**\n   * Image should be available at public/demos/[slug].webp\n   *\n   * also, all contextual-prompts in folder `/db/contextual-prompts/[slug]/` are used as prompts for this demo\n   *\n   * If the slug is not present, the category of `ContextualPrompt` will be used\n   */\n  slug: string;\n  /**\n   * if you have, the use-case can launch on its own domain\n   */\n  domain?: string;\n  headerTitle: string;\n  hasImageBoolean?: boolean;\n  headerSubtitle?: string;\n  headerCtaHref?: string;\n  headerCtaText?: string;\n}"
  },
  "BackendAsset": {
    "name": "BackendAsset",
    "slug": "TsInterface",
    "id": "backendasset",
    "description": "Part of the asset that should be sent to the backend. The rest should frontend-only\n\nSome values are stored, some are not",
    "operationName": "foodchain-types"
  },
  "ContextualContent": {
    "name": "ContextualContent",
    "slug": "TsInterface",
    "id": "contextualcontent",
    "description": "",
    "operationName": "ai-types",
    "rawText": "export type ContextualContent = {\n  contextContent: string;\n  contextSelection?: string | null;\n  context_projectRelativeFilePath?: string;\n};"
  },
  "ContextualPromptInfo": {
    "name": "ContextualPromptInfo",
    "slug": "TsInterface",
    "id": "contextualpromptinfo",
    "description": "To be appended to the generated typescript",
    "operationName": "ai-types",
    "rawText": "\n\n/**\n * To be appended to the generated typescript\n */\nexport type ContextualPromptInfo = {\n  // extra flags, to be added to the config of the function.\n\n  /**\n   * If given, will be used to filter the selection of prompts to match the context type\n   */\n  contextType?: FileType[];\n\n  instantExecution?: boolean;\n\n  isFavorite?: boolean;\n\n  categoryStack?: string[];\n\n  pricing?: \"bad\" | \"good\" | \"premium\" | \"enterprise\" | \"private\";\n};"
  },
  "ContextualPromptsObject": {
    "name": "ContextualPromptsObject",
    "slug": "TsInterface",
    "id": "contextualpromptsobject",
    "description": "",
    "operationName": "ai-types",
    "rawText": "\n\nexport type ContextualPromptsObject = {\n  selectionContextualPrompts: ContextualPrompt[];\n  pageContextualPrompts: ContextualPrompt[];\n  folderContextualPrompts: ContextualPrompt[];\n  databaseContextualPromptSlugs: string[];\n};"
  },
  "FolderContent": {
    "name": "FolderContent",
    "slug": "TsInterface",
    "id": "foldercontent",
    "description": "",
    "operationName": "generative-ui"
  },
  "Frontmatter": {
    "name": "Frontmatter",
    "slug": "TsInterface",
    "id": "frontmatter",
    "description": "Our version of frontmatter is a bit simpler than regular frontmatter\n\nNot sure if this is a good idea, but it keeps it simple for our OS\n\nall values parse in a similar way to csv\n\nmake sure that you use quotes if you want to store a string with commas, because commas in a parameter indicate that it is a string array\n\nNB: string arrays are comma separated values, where you can put values with special characters in between quotes",
    "operationName": "markdown"
  },
  "GptIdeasUser": {
    "name": "GptIdeasUser",
    "slug": "TsInterface",
    "id": "gptideasuser",
    "description": "",
    "operationName": "ai-types",
    "rawText": "\n\nexport interface GptIdeasUser extends DefaultModelType {\n  email: string;\n  tier: string;\n  newsletter: string;\n}"
  },
  "LanguageModelEnum": {
    "name": "LanguageModelEnum",
    "slug": "TsInterface",
    "id": "languagemodelenum",
    "description": "",
    "operationName": "ai-types",
    "rawText": "\n\nexport type LanguageModelEnum = typeof languageModels[number];"
  },
  "ProcessPromptFunctionResult": {
    "name": "ProcessPromptFunctionResult",
    "slug": "TsInterface",
    "id": "processpromptfunctionresult",
    "description": "Same result to be expected from executing prompt for any language model",
    "operationName": "ai-types",
    "rawText": "\n/**\n * Same result to be expected from executing prompt for any language model\n */\nexport type ProcessPromptFunctionResult = {\n  isSuccessful: boolean;\n  message: string;\n  result?: { text?: string; assets?: BackendAsset[]; thread: string };\n};"
  },
  "PromptFunction": {
    "name": "PromptFunction",
    "slug": "TsInterface",
    "id": "promptfunction",
    "description": "Special kind of function that executes a prompt with the use of a language model",
    "operationName": "ai-types",
    "rawText": "\n\n/**\n * Special kind of function that executes a prompt with the use of a language model\n */\nexport type PromptFunction = {\n  (...parameters: any[]): Promise<ProcessPromptFunctionResult>;\n  contextualPromptInfo: ContextualPromptInfo;\n};"
  },
  "ReaderProps": {
    "name": "ReaderProps",
    "slug": "TsInterface",
    "id": "readerprops",
    "description": "This is what we need on the page level. There are many subtleties to it, but this is the core",
    "operationName": "generative-ui"
  },
  "SlugModelType": {
    "name": "SlugModelType",
    "slug": "TsInterface",
    "id": "slugmodeltype",
    "description": "use this model for things with a name that have an unique slug that can be used to identify the model",
    "operationName": "foodchain-types"
  },
  "GetStaticPropsContext": {
    "name": "GetStaticPropsContext",
    "slug": "TsInterface",
    "id": "getstaticpropscontext",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof canSeeFile>": {
    "name": "NamedParameters<typeof canSeeFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-canseefile",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof canSeeFileContent>": {
    "name": "NamedParameters<typeof canSeeFileContent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-canseefilecontent",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof expandFrontmatter>": {
    "name": "NamedParameters<typeof expandFrontmatter>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-expandfrontmatter",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof findClosestAbsolutePath>": {
    "name": "NamedParameters<typeof findClosestAbsolutePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findclosestabsolutepath",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof getContextualPromptResults>": {
    "name": "NamedParameters<typeof getContextualPromptResults>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcontextualpromptresults",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof getContextualPrompts>": {
    "name": "NamedParameters<typeof getContextualPrompts>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcontextualprompts",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof getContextualPromptsArray>": {
    "name": "NamedParameters<typeof getContextualPromptsArray>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcontextualpromptsarray",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof getFirstFile>": {
    "name": "NamedParameters<typeof getFirstFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfirstfile",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof getFolderRelativeScopeDbFilePath>": {
    "name": "NamedParameters<typeof getFolderRelativeScopeDbFilePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfolderrelativescopedbfilepath",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof getReaderPageProps>": {
    "name": "NamedParameters<typeof getReaderPageProps>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getreaderpageprops",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof readerPageGetStaticPaths>": {
    "name": "NamedParameters<typeof readerPageGetStaticPaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readerpagegetstaticpaths",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof readerPageGetStaticProps>": {
    "name": "NamedParameters<typeof readerPageGetStaticProps>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readerpagegetstaticprops",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof Dataset>": {
    "name": "NamedParameters<typeof Dataset>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-dataset",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof Menu>": {
    "name": "NamedParameters<typeof Menu>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-menu",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof PromptButton>": {
    "name": "NamedParameters<typeof PromptButton>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-promptbutton",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof ReaderPage>": {
    "name": "NamedParameters<typeof ReaderPage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readerpage",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof ReaderPageNext>": {
    "name": "NamedParameters<typeof ReaderPageNext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readerpagenext",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof setConfig>": {
    "name": "NamedParameters<typeof setConfig>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-setconfig",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof SettingsPage>": {
    "name": "NamedParameters<typeof SettingsPage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-settingspage",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof useAdmin>": {
    "name": "NamedParameters<typeof useAdmin>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-useadmin",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof useQueryPath>": {
    "name": "NamedParameters<typeof useQueryPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usequerypath",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof useVariantResult>": {
    "name": "NamedParameters<typeof useVariantResult>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usevariantresult",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof VariantSelector>": {
    "name": "NamedParameters<typeof VariantSelector>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-variantselector",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof ContextualPromptResultsTab>": {
    "name": "NamedParameters<typeof ContextualPromptResultsTab>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-contextualpromptresultstab",
    "description": "",
    "operationName": "prompt-components"
  },
  "NamedParameters<typeof FilePromptSelect>": {
    "name": "NamedParameters<typeof FilePromptSelect>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-filepromptselect",
    "description": "",
    "operationName": "prompt-components"
  },
  "Queue": {
    "name": "Queue",
    "slug": "TsInterface",
    "id": "queue",
    "description": "Model for a Queue system so you can execute functions when ram is available",
    "operationName": "queue-types",
    "rawText": "\n/**\n\nModel for a Queue system so you can execute functions when ram is available\n\n\n */\n\nexport interface Queue extends DefaultModelType {\n  startedAt?: number;\n  type: \"puppeteer\";\n  functionName: string;\n  parameters: any[];\n}"
  },
  "Asset": {
    "name": "Asset",
    "slug": "TsInterface",
    "id": "asset",
    "description": "Asset you can upload\n\nThis is not a database model, it can exist in properties of any db model or type interface.\n\nOnly `alt` and `relativePath` are stored, the other parameters are optionally required for uploading and user interfaces, and are not always there\n\nNB: don't use this in your model, use `StoredAsset` instead.",
    "operationName": "asset-view"
  },
  "AssetInputType": {
    "name": "AssetInputType",
    "slug": "TsInterface",
    "id": "assetinputtype",
    "description": "",
    "operationName": "name-conventions",
    "rawText": "\n\nexport type AssetInputType = {\n  type: \"image\" | \"video\" | \"audio\" | \"file\" | \"asset\";\n  isMultiple: boolean;\n};"
  },
  "AssetParameter": {
    "name": "AssetParameter",
    "slug": "TsInterface",
    "id": "assetparameter",
    "description": "",
    "operationName": "asset-functions-js",
    "rawText": "\n\nexport type AssetParameter = {\n  assetInputType: AssetInputType;\n  parameterName: string;\n  /**\n   * where the object parameter is located\n   */\n  stack?: string[];\n};"
  },
  "NamedParameters<typeof addToken>": {
    "name": "NamedParameters<typeof addToken>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-addtoken",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "NamedParameters<typeof ensureToken>": {
    "name": "NamedParameters<typeof ensureToken>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-ensuretoken",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "NamedParameters<typeof findAssetParametersRecursively>": {
    "name": "NamedParameters<typeof findAssetParametersRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findassetparametersrecursively",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "NamedParameters<typeof getAssetDirectlyApiUrl>": {
    "name": "NamedParameters<typeof getAssetDirectlyApiUrl>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getassetdirectlyapiurl",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "NamedParameters<typeof getConversionInfoFromType>": {
    "name": "NamedParameters<typeof getConversionInfoFromType>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getconversioninfofromtype",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "NamedParameters<typeof getExtensionFromAsset>": {
    "name": "NamedParameters<typeof getExtensionFromAsset>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getextensionfromasset",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "NamedParameters<typeof getNameFromRelativePath>": {
    "name": "NamedParameters<typeof getNameFromRelativePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getnamefromrelativepath",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "NamedParameters<typeof getNameWithTokenFromRelativePath>": {
    "name": "NamedParameters<typeof getNameWithTokenFromRelativePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getnamewithtokenfromrelativepath",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "NamedParameters<typeof getReferencedAssetApiUrl>": {
    "name": "NamedParameters<typeof getReferencedAssetApiUrl>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getreferencedassetapiurl",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "NamedParameters<typeof getTypeFromUrlOrPath>": {
    "name": "NamedParameters<typeof getTypeFromUrlOrPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettypefromurlorpath",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "NamedParameters<typeof readableSize>": {
    "name": "NamedParameters<typeof readableSize>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readablesize",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "NamedParameters<typeof removeTokenIfPresent>": {
    "name": "NamedParameters<typeof removeTokenIfPresent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removetokenifpresent",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "CompressionConfig": {
    "name": "CompressionConfig",
    "slug": "TsInterface",
    "id": "compressionconfig",
    "description": "",
    "operationName": "asset-type",
    "rawText": "export type CompressionConfig = {\n  /**\n   * used for audio\n   */\n  bitrate?: number;\n  /**\n   * Frames per second. Used for video\n   */\n  fps?: number;\n  /**\n   * Set the resolution. Will not upscale.\n   *\n   * Used for video and images\n   */\n  resolution?: {\n    width: number;\n    height: number;\n  };\n  /**\n   * if true, will overwrite the original file\n   */\n  shouldOverwrite?: boolean;\n};"
  },
  "NamedParameters<typeof compressAsset>": {
    "name": "NamedParameters<typeof compressAsset>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-compressasset",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "NamedParameters<typeof downloadRemoteAsset>": {
    "name": "NamedParameters<typeof downloadRemoteAsset>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-downloadremoteasset",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "NamedParameters<typeof deleteReferencedAsset>": {
    "name": "NamedParameters<typeof deleteReferencedAsset>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-deletereferencedasset",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "NamedParameters<typeof findAbsoluteAssetPathFromReference>": {
    "name": "NamedParameters<typeof findAbsoluteAssetPathFromReference>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findabsoluteassetpathfromreference",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "NamedParameters<typeof findAllProjectMedia>": {
    "name": "NamedParameters<typeof findAllProjectMedia>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findallprojectmedia",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "NamedParameters<typeof getStorageLocationInfo>": {
    "name": "NamedParameters<typeof getStorageLocationInfo>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getstoragelocationinfo",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "NamedParameters<typeof getTemporaryAssetsFolderPath>": {
    "name": "NamedParameters<typeof getTemporaryAssetsFolderPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettemporaryassetsfolderpath",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "NamedParameters<typeof processAsset>": {
    "name": "NamedParameters<typeof processAsset>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-processasset",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "NamedParameters<typeof removeOldTemporaryAssets>": {
    "name": "NamedParameters<typeof removeOldTemporaryAssets>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removeoldtemporaryassets",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "NamedParameters<typeof serverDownloadReply>": {
    "name": "NamedParameters<typeof serverDownloadReply>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-serverdownloadreply",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "NamedParameters<typeof uploadAssetWithContext>": {
    "name": "NamedParameters<typeof uploadAssetWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-uploadassetwithcontext",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "ReceivedFile": {
    "name": "ReceivedFile",
    "slug": "TsInterface",
    "id": "receivedfile",
    "description": "This is the format that I receive for a file with server.js, even though they say it's a formidable.file, which it's not...",
    "operationName": "asset-functions-node",
    "rawText": "\n\n/**\n * This is the format that I receive for a file with server.js, even though they say it's a formidable.file, which it's not...\n */\n\nexport type ReceivedFile = {\n  size: number;\n  path: string;\n  name: string;\n  type: string;\n  hash: any;\n  lastModifiedDate: Date;\n};"
  },
  "MediaSourceEnum": {
    "name": "MediaSourceEnum",
    "slug": "TsInterface",
    "id": "mediasourceenum",
    "description": "google: remote image urls\ngiphy: remote image urls\nunsplashed: remote image urls\nyoutube: remote video urls (selectable as mp3, mp4, or url)",
    "operationName": "asset-input",
    "rawText": "/**\n\nproject: api urls\np2p: api urls with other ip\n---\ngoogle: remote image urls\ngiphy: remote image urls\nunsplashed: remote image urls\nyoutube: remote video urls (selectable as mp3, mp4, or url)\n\n */\nexport type MediaSourceEnum =\n  | \"project\"\n  | \"p2p\"\n  | \"google\"\n  | \"giphy\"\n  | \"unsplashed\"\n  | \"youtube\";"
  },
  "NamedParameters<typeof getTypeFromFileBlob>": {
    "name": "NamedParameters<typeof getTypeFromFileBlob>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettypefromfileblob",
    "description": "",
    "operationName": "asset-input"
  },
  "NamedParameters<typeof makeBackendAsset>": {
    "name": "NamedParameters<typeof makeBackendAsset>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-makebackendasset",
    "description": "",
    "operationName": "asset-input"
  },
  "NamedParameters<typeof SelectMedia>": {
    "name": "NamedParameters<typeof SelectMedia>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-selectmedia",
    "description": "",
    "operationName": "asset-input"
  },
  "AssetType": {
    "name": "AssetType",
    "slug": "TsInterface",
    "id": "assettype",
    "description": "Possible Asset Types\n\nLater, maybe also support: \"markdown\",\"json\",\"typescript\"",
    "operationName": "markdown-types"
  },
  "CompressionOption": {
    "name": "CompressionOption",
    "slug": "TsInterface",
    "id": "compressionoption",
    "description": "CompressionOption should be able to be applied on the model parameter through frontmatter\n\n- default (default option): Default OS wide compression. User can make customize it within a logical limit\n- none: no compression applied by default (user can optionally compress it)\n- high: compressed bigtime by default (user cannot make it be compressed less)\n- low: compressed just a little (user cannot make it be compressed less, but can optionally compress it more)",
    "operationName": "asset-type",
    "rawText": "\n\n/**\n \nCompressionOption should be able to be applied on the model parameter through frontmatter\n\n- default (default option): Default OS wide compression. User can make customize it within a logical limit\n- none: no compression applied by default (user can optionally compress it)\n- high: compressed bigtime by default (user cannot make it be compressed less)\n- low: compressed just a little (user cannot make it be compressed less, but can optionally compress it more)\n\n */\nexport type CompressionOption = \"custom\" | \"none\" | \"default\" | \"tiny\" | \"big\";"
  },
  "NewAssetType": {
    "name": "NewAssetType",
    "slug": "TsInterface",
    "id": "newassettype",
    "description": "Possible types for new asset upload in the frontend",
    "operationName": "react-with-native-form-asset-input"
  },
  "UploadAssetBody": {
    "name": "UploadAssetBody",
    "slug": "TsInterface",
    "id": "uploadassetbody",
    "description": "NB: other things like alt, final destination etc, should not be sent with the upload, but instead with the function",
    "operationName": "asset-type",
    "rawText": "/**\n NB: other things like alt, final destination etc, should not be sent with the upload, but instead with the function\n */\nexport type UploadAssetBody = {\n  authToken?: string;\n};"
  },
  "UploadAssetResult": {
    "name": "UploadAssetResult",
    "slug": "TsInterface",
    "id": "uploadassetresult",
    "description": "",
    "operationName": "asset-type",
    "rawText": "\n\nexport type UploadAssetResult = {\n  isSuccessful: boolean;\n  message?: string;\n  temporaryDestination?: string;\n};"
  },
  "AugmentedAnyModelType": {
    "name": "AugmentedAnyModelType",
    "slug": "TsInterface",
    "id": "augmentedanymodeltype",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof AssetView>": {
    "name": "NamedParameters<typeof AssetView>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-assetview",
    "description": "",
    "operationName": "asset-view"
  },
  "NamedParameters<typeof getSrc>": {
    "name": "NamedParameters<typeof getSrc>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsrc",
    "description": "",
    "operationName": "asset-view"
  },
  "NamedParameters<typeof itemGetBackendAssetUrl>": {
    "name": "NamedParameters<typeof itemGetBackendAssetUrl>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-itemgetbackendasseturl",
    "description": "",
    "operationName": "asset-view"
  },
  "NamedParameters<typeof useAsset>": {
    "name": "NamedParameters<typeof useAsset>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-useasset",
    "description": "",
    "operationName": "asset-view"
  },
  "NamedParameters<typeof useAssetInfo>": {
    "name": "NamedParameters<typeof useAssetInfo>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-useassetinfo",
    "description": "",
    "operationName": "asset-view"
  },
  "EncodingOpts": {
    "name": "EncodingOpts",
    "slug": "TsInterface",
    "id": "encodingopts",
    "description": "",
    "operationName": "text-or-binary",
    "rawText": "\n\nexport interface EncodingOpts {\n  /** Defaults to 24 */\n  chunkLength?: number;\n\n  /** If not provided, will check the start, beginning, and end */\n  chunkBegin?: number;\n}"
  },
  "NamedParameters<typeof getChunkBegin>": {
    "name": "NamedParameters<typeof getChunkBegin>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getchunkbegin",
    "description": "",
    "operationName": "text-or-binary"
  },
  "NamedParameters<typeof getChunkEnd>": {
    "name": "NamedParameters<typeof getChunkEnd>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getchunkend",
    "description": "",
    "operationName": "text-or-binary"
  },
  "NamedParameters<typeof getEncoding>": {
    "name": "NamedParameters<typeof getEncoding>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getencoding",
    "description": "",
    "operationName": "text-or-binary"
  },
  "NamedParameters<typeof isBinary>": {
    "name": "NamedParameters<typeof isBinary>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isbinary",
    "description": "",
    "operationName": "text-or-binary"
  },
  "NamedParameters<typeof isFirstByteOf2ByteChar>": {
    "name": "NamedParameters<typeof isFirstByteOf2ByteChar>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isfirstbyteof2bytechar",
    "description": "",
    "operationName": "text-or-binary"
  },
  "NamedParameters<typeof isFirstByteOf3ByteChar>": {
    "name": "NamedParameters<typeof isFirstByteOf3ByteChar>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isfirstbyteof3bytechar",
    "description": "",
    "operationName": "text-or-binary"
  },
  "NamedParameters<typeof isFirstByteOf4ByteChar>": {
    "name": "NamedParameters<typeof isFirstByteOf4ByteChar>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isfirstbyteof4bytechar",
    "description": "",
    "operationName": "text-or-binary"
  },
  "NamedParameters<typeof isLaterByteOfUtf8>": {
    "name": "NamedParameters<typeof isLaterByteOfUtf8>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-islaterbyteofutf8",
    "description": "",
    "operationName": "text-or-binary"
  },
  "NamedParameters<typeof isText>": {
    "name": "NamedParameters<typeof isText>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-istext",
    "description": "",
    "operationName": "text-or-binary"
  },
  "NamedParameters<typeof folderGetUpdatedAt>": {
    "name": "NamedParameters<typeof folderGetUpdatedAt>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-foldergetupdatedat",
    "description": "",
    "operationName": "folder-get-updated-at"
  },
  "Dir": {
    "name": "Dir",
    "slug": "TsInterface",
    "id": "dir",
    "description": "A class representing a directory stream.\n\nCreated by  {@link  opendir } ,  {@link  opendirSync } , or `fsPromises.opendir()`.\n\n```js import { opendir } from 'fs/promises';\n\ntry {   const dir = await opendir('./');   for await (const dirent of dir)     console.log(dirent.name); } catch (err) {   console.error(err); } ```\n\nWhen using the async iterator, the `fs.Dir` object will be automatically closed after the iterator exits.",
    "operationName": "fs-util"
  },
  "Dirent": {
    "name": "Dirent",
    "slug": "TsInterface",
    "id": "dirent",
    "description": "A representation of a directory entry, which can be a file or a subdirectory within the directory, as returned by reading from an `fs.Dir`. The directory entry is a combination of the file name and file type pairs.\n\nAdditionally, when  {@link  readdir }  or  {@link  readdirSync }  is called with the `withFileTypes` option set to `true`, the resulting array is filled with `fs.Dirent` objects, rather than strings or `Buffer` s.",
    "operationName": "fs-util"
  },
  "FolderPath": {
    "name": "FolderPath",
    "slug": "TsInterface",
    "id": "folderpath",
    "description": "DEPRECATED: just use ParsedPath",
    "operationName": "fs-util",
    "rawText": "\n/**\n * DEPRECATED: just use ParsedPath\n */\nexport type FolderPath = { relativeFolder: string | undefined; path: Path };"
  },
  "Fs": {
    "name": "Fs",
    "slug": "TsInterface",
    "id": "fs",
    "description": "all handy Fs types",
    "operationName": "fs-util",
    "rawText": "\n\n/**\n * all handy Fs types\n */\nexport type Fs = {\n  PathLike: PathLike;\n  Stats: Stats;\n  Dir: Dir;\n  Dirent: Dirent;\n};"
  },
  "Markdown": {
    "name": "Markdown",
    "slug": "TsInterface",
    "id": "markdown",
    "description": "a string that is known to contain markdown.",
    "operationName": "foodchain-types"
  },
  "NamedParameters<typeof findFileNameCaseInsensitive>": {
    "name": "NamedParameters<typeof findFileNameCaseInsensitive>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findfilenamecaseinsensitive",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof getFileName>": {
    "name": "NamedParameters<typeof getFileName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfilename",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof getFolder>": {
    "name": "NamedParameters<typeof getFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfolder",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof getLastFolder>": {
    "name": "NamedParameters<typeof getLastFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getlastfolder",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof getPathCombinations>": {
    "name": "NamedParameters<typeof getPathCombinations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpathcombinations",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof parseMd>": {
    "name": "NamedParameters<typeof parseMd>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parsemd",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof removeAllExcept>": {
    "name": "NamedParameters<typeof removeAllExcept>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removeallexcept",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof copyAllRelativeFiles>": {
    "name": "NamedParameters<typeof copyAllRelativeFiles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-copyallrelativefiles",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof getAllFoldersUntilFolder>": {
    "name": "NamedParameters<typeof getAllFoldersUntilFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getallfoldersuntilfolder",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof getFirstAvailableFilename>": {
    "name": "NamedParameters<typeof getFirstAvailableFilename>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfirstavailablefilename",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof getFolderSize>": {
    "name": "NamedParameters<typeof getFolderSize>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfoldersize",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof getFolderSizeObject>": {
    "name": "NamedParameters<typeof getFolderSizeObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfoldersizeobject",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof getOneFolderUpPath>": {
    "name": "NamedParameters<typeof getOneFolderUpPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getonefolderuppath",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof oneUp>": {
    "name": "NamedParameters<typeof oneUp>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-oneup",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof renameAndCreate>": {
    "name": "NamedParameters<typeof renameAndCreate>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-renameandcreate",
    "description": "",
    "operationName": "fs-util"
  },
  "PathLike": {
    "name": "PathLike",
    "slug": "TsInterface",
    "id": "pathlike",
    "description": "Valid types for path values in \"fs\".",
    "operationName": "fs-util"
  },
  "Path": {
    "name": "Path",
    "slug": "TsInterface",
    "id": "path",
    "description": "unlike PathLike, this is only a string\n\nFor now, we don't have a clear convention whether or not this string should be absolute or anything.",
    "operationName": "read-typescript-file"
  },
  "Stats": {
    "name": "Stats",
    "slug": "TsInterface",
    "id": "stats",
    "description": "A `fs.Stats` object provides information about a file.\n\nObjects returned from  {@link  stat } ,  {@link  lstat }  and  {@link  fstat }  and their synchronous counterparts are of this type. If `bigint` in the `options` passed to those methods is true, the numeric values will be `bigint` instead of `number`, and the object will contain additional nanosecond-precision properties suffixed with `Ns`.\n\n```console Stats {   dev: 2114,   ino: 48064969,   mode: 33188,   nlink: 1,   uid: 85,   gid: 100,   rdev: 0,   size: 527,   blksize: 4096,   blocks: 8,   atimeMs: 1318289051000.1,   mtimeMs: 1318289051000.1,   ctimeMs: 1318289051000.1,   birthtimeMs: 1318289051000.1,   atime: Mon, 10 Oct 2011 23:24:11 GMT,   mtime: Mon, 10 Oct 2011 23:24:11 GMT,   ctime: Mon, 10 Oct 2011 23:24:11 GMT,   birthtime: Mon, 10 Oct 2011 23:24:11 GMT } ```\n\n`bigint` version:\n\n```console BigIntStats {   dev: 2114n,   ino: 48064969n,   mode: 33188n,   nlink: 1n,   uid: 85n,   gid: 100n,   rdev: 0n,   size: 527n,   blksize: 4096n,   blocks: 8n,   atimeMs: 1318289051000n,   mtimeMs: 1318289051000n,   ctimeMs: 1318289051000n,   birthtimeMs: 1318289051000n,   atimeNs: 1318289051000000000n,   mtimeNs: 1318289051000000000n,   ctimeNs: 1318289051000000000n,   birthtimeNs: 1318289051000000000n,   atime: Mon, 10 Oct 2011 23:24:11 GMT,   mtime: Mon, 10 Oct 2011 23:24:11 GMT,   ctime: Mon, 10 Oct 2011 23:24:11 GMT,   birthtime: Mon, 10 Oct 2011 23:24:11 GMT } ```",
    "operationName": "fs-util"
  },
  "UnixTimestamp": {
    "name": "UnixTimestamp",
    "slug": "TsInterface",
    "id": "unixtimestamp",
    "description": "",
    "operationName": "fs-util",
    "rawText": "export type UnixTimestamp = number;"
  },
  "NamedParameters<typeof join>": {
    "name": "NamedParameters<typeof join>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-join",
    "description": "",
    "operationName": "fs-util-js"
  },
  "NamedParameters<typeof makeRelative>": {
    "name": "NamedParameters<typeof makeRelative>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-makerelative",
    "description": "",
    "operationName": "fs-util-js"
  },
  "NamedParameters<typeof getAssociatedMd>": {
    "name": "NamedParameters<typeof getAssociatedMd>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getassociatedmd",
    "description": "",
    "operationName": "get-associated-md"
  },
  "NamedParameters<typeof getAvailableFolderPath>": {
    "name": "NamedParameters<typeof getAvailableFolderPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getavailablefolderpath",
    "description": "",
    "operationName": "get-available-folder-path"
  },
  "NamedParameters<typeof getOperationBins>": {
    "name": "NamedParameters<typeof getOperationBins>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationbins",
    "description": "",
    "operationName": "get-package-json"
  },
  "NamedParameters<typeof getOperationPackageName>": {
    "name": "NamedParameters<typeof getOperationPackageName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationpackagename",
    "description": "",
    "operationName": "get-package-json"
  },
  "NamedParameters<typeof getPackageJson>": {
    "name": "NamedParameters<typeof getPackageJson>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpackagejson",
    "description": "",
    "operationName": "get-package-json"
  },
  "NamedParameters<typeof getPackageSourcePaths>": {
    "name": "NamedParameters<typeof getPackageSourcePaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpackagesourcepaths",
    "description": "",
    "operationName": "get-package-source-paths"
  },
  "NamedParameters<typeof getTsConfig>": {
    "name": "NamedParameters<typeof getTsConfig>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettsconfig",
    "description": "",
    "operationName": "get-ts-config"
  },
  "CategorizedFilePaths": {
    "name": "CategorizedFilePaths",
    "slug": "TsInterface",
    "id": "categorizedfilepaths",
    "description": "filepaths categorized based on the filetype. With king os there are only these filetypes:\n\n- code: ts, tsx\n- data: json\n- text: md, mdx",
    "operationName": "code-types",
    "rawText": "\n\n/**\n * filepaths categorized based on the filetype. With king os there are only these filetypes:\n *\n * - code: ts, tsx\n * - data: json\n * - text: md, mdx\n */\nexport type CategorizedFilePaths = {\n  code: string[];\n  data: string[];\n  text: string[];\n};"
  },
  "NamedParameters<typeof byteCount>": {
    "name": "NamedParameters<typeof byteCount>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-bytecount",
    "description": "",
    "operationName": "path-util"
  },
  "NamedParameters<typeof getFolderSummary>": {
    "name": "NamedParameters<typeof getFolderSummary>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfoldersummary",
    "description": "",
    "operationName": "path-util"
  },
  "NamedParameters<typeof getSizeSummary>": {
    "name": "NamedParameters<typeof getSizeSummary>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsizesummary",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof sumSizeSummary>": {
    "name": "NamedParameters<typeof sumSizeSummary>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-sumsizesummary",
    "description": "",
    "operationName": "path-util"
  },
  "NamedParameters<typeof calculatePathMetaData>": {
    "name": "NamedParameters<typeof calculatePathMetaData>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-calculatepathmetadata",
    "description": "",
    "operationName": "path-util"
  },
  "NamedParameters<typeof categorizeFiles>": {
    "name": "NamedParameters<typeof categorizeFiles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-categorizefiles",
    "description": "",
    "operationName": "path-util"
  },
  "NamedParameters<typeof getPathMainComment>": {
    "name": "NamedParameters<typeof getPathMainComment>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpathmaincomment",
    "description": "",
    "operationName": "path-util"
  },
  "NamedParameters<typeof findTemplates>": {
    "name": "NamedParameters<typeof findTemplates>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findtemplates",
    "description": "",
    "operationName": "rename-template-files"
  },
  "NamedParameters<typeof isEqualArray>": {
    "name": "NamedParameters<typeof isEqualArray>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isequalarray",
    "description": "",
    "operationName": "rename-template-files"
  },
  "NamedParameters<typeof renameTemplateFiles>": {
    "name": "NamedParameters<typeof renameTemplateFiles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-renametemplatefiles",
    "description": "",
    "operationName": "rename-template-files"
  },
  "NamedParameters<typeof renameTemplateToNormalFile>": {
    "name": "NamedParameters<typeof renameTemplateToNormalFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-renametemplatetonormalfile",
    "description": "",
    "operationName": "rename-template-files"
  },
  "NamedParameters<typeof renameToTemplateFile>": {
    "name": "NamedParameters<typeof renameToTemplateFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-renametotemplatefile",
    "description": "",
    "operationName": "rename-template-files"
  },
  "NamedParameters<typeof setJsonKey>": {
    "name": "NamedParameters<typeof setJsonKey>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-setjsonkey",
    "description": "",
    "operationName": "set-json-key"
  },
  "NamedParameters<typeof setKeyAtLocation>": {
    "name": "NamedParameters<typeof setKeyAtLocation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-setkeyatlocation",
    "description": "",
    "operationName": "set-json-key"
  },
  "NamedParameters<typeof pickWatcher>": {
    "name": "NamedParameters<typeof pickWatcher>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-pickwatcher",
    "description": "",
    "operationName": "watch-folders"
  },
  "NamedParameters<typeof writeToAssets>": {
    "name": "NamedParameters<typeof writeToAssets>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-writetoassets",
    "description": "",
    "operationName": "write-to-assets"
  },
  "NamedParameters<typeof allOperationsRemoveJsSrc>": {
    "name": "NamedParameters<typeof allOperationsRemoveJsSrc>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-alloperationsremovejssrc",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof allOperationsToMarkdown>": {
    "name": "NamedParameters<typeof allOperationsToMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-alloperationstomarkdown",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof clearAllTsDatabases>": {
    "name": "NamedParameters<typeof clearAllTsDatabases>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-clearalltsdatabases",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof codeAll>": {
    "name": "NamedParameters<typeof codeAll>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-codeall",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof getAllOperationClassifications>": {
    "name": "NamedParameters<typeof getAllOperationClassifications>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getalloperationclassifications",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof mdAllOperations>": {
    "name": "NamedParameters<typeof mdAllOperations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-mdalloperations",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof minifyAllOperations>": {
    "name": "NamedParameters<typeof minifyAllOperations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-minifyalloperations",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof removeAllFiles>": {
    "name": "NamedParameters<typeof removeAllFiles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removeallfiles",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof removeAllFolders>": {
    "name": "NamedParameters<typeof removeAllFolders>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removeallfolders",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof removeAllFoldersCli>": {
    "name": "NamedParameters<typeof removeAllFoldersCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removeallfolderscli",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof runScriptEverywhere>": {
    "name": "NamedParameters<typeof runScriptEverywhere>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-runscripteverywhere",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof setScriptEverywhere>": {
    "name": "NamedParameters<typeof setScriptEverywhere>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-setscripteverywhere",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof makeFileType>": {
    "name": "NamedParameters<typeof makeFileType>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-makefiletype",
    "description": "",
    "operationName": "make-file-type"
  },
  "NamedParameters<typeof exploreOperation>": {
    "name": "NamedParameters<typeof exploreOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-exploreoperation",
    "description": "",
    "operationName": "explore-project"
  },
  "NamedParameters<typeof exploreProject>": {
    "name": "NamedParameters<typeof exploreProject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-exploreproject",
    "description": "",
    "operationName": "explore-project"
  },
  "NamedParameters<typeof getExplorationType>": {
    "name": "NamedParameters<typeof getExplorationType>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getexplorationtype",
    "description": "",
    "operationName": "explore-project"
  },
  "NamedParameters<typeof getFileWithExtension>": {
    "name": "NamedParameters<typeof getFileWithExtension>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfilewithextension",
    "description": "",
    "operationName": "explore-project"
  },
  "NamedParameters<typeof getFolderExplorationDetails>": {
    "name": "NamedParameters<typeof getFolderExplorationDetails>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfolderexplorationdetails",
    "description": "",
    "operationName": "explore-project"
  },
  "NamedParameters<typeof getFrontmattersMappedObject>": {
    "name": "NamedParameters<typeof getFrontmattersMappedObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfrontmattersmappedobject",
    "description": "",
    "operationName": "explore-project"
  },
  "NamedParameters<typeof getInstanceNames>": {
    "name": "NamedParameters<typeof getInstanceNames>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getinstancenames",
    "description": "",
    "operationName": "explore-project"
  },
  "NamedParameters<typeof getProjectRelativePaths>": {
    "name": "NamedParameters<typeof getProjectRelativePaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getprojectrelativepaths",
    "description": "",
    "operationName": "explore-project"
  },
  "NamedParameters<typeof getTodoPages>": {
    "name": "NamedParameters<typeof getTodoPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettodopages",
    "description": "",
    "operationName": "explore-project"
  },
  "NamedParameters<typeof getTodoPaths>": {
    "name": "NamedParameters<typeof getTodoPaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettodopaths",
    "description": "",
    "operationName": "explore-project"
  },
  "NamedParameters<typeof hasSameProjectPath>": {
    "name": "NamedParameters<typeof hasSameProjectPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-hassameprojectpath",
    "description": "",
    "operationName": "explore-project"
  },
  "NamedParameters<typeof main>": {
    "name": "NamedParameters<typeof main>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-main",
    "description": "",
    "operationName": "parse-images"
  },
  "RelativePathType": {
    "name": "RelativePathType",
    "slug": "TsInterface",
    "id": "relativepathtype",
    "description": "",
    "operationName": "explore-project",
    "rawText": "\n\nexport type RelativePathType = \"todo\";"
  },
  "TodoPagesConfig": {
    "name": "TodoPagesConfig",
    "slug": "TsInterface",
    "id": "todopagesconfig",
    "description": "",
    "operationName": "todo-types",
    "rawText": "\n\nexport type TodoPagesConfig = {\n  recency?: typeof todoPagesConfigRecencysConst[number];\n  /**\n   * All TodoOffer's related to this todo will be searched, as well as all TodoFile's with this personId as it's codeOwner.\n   */\n  personId?: string;\n  categoryStack?: string[];\n  priority?: \"high\";\n  subExtension?: string;\n  sort?: \"recent\";\n};"
  },
  "NamedParameters<typeof getAllOperationSourcePaths>": {
    "name": "NamedParameters<typeof getAllOperationSourcePaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getalloperationsourcepaths",
    "description": "",
    "operationName": "get-all-operation-source-paths"
  },
  "ModuleKind": {
    "name": "ModuleKind",
    "slug": "TsInterface",
    "id": "modulekind",
    "description": "",
    "operationName": "get-path"
  },
  "ModuleResolutionKind": {
    "name": "ModuleResolutionKind",
    "slug": "TsInterface",
    "id": "moduleresolutionkind",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof findOperationBasePath>": {
    "name": "NamedParameters<typeof findOperationBasePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findoperationbasepath",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof findOperationBasePathWithClassification>": {
    "name": "NamedParameters<typeof findOperationBasePathWithClassification>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findoperationbasepathwithclassification",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getAllPackageJsonDependencies>": {
    "name": "NamedParameters<typeof getAllPackageJsonDependencies>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getallpackagejsondependencies",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getCommonAncestor>": {
    "name": "NamedParameters<typeof getCommonAncestor>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcommonancestor",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getOperationClassification>": {
    "name": "NamedParameters<typeof getOperationClassification>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationclassification",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getOperationClassificationObject>": {
    "name": "NamedParameters<typeof getOperationClassificationObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationclassificationobject",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getOperationPath>": {
    "name": "NamedParameters<typeof getOperationPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationpath",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getOperationPathParse>": {
    "name": "NamedParameters<typeof getOperationPathParse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationpathparse",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getOperationRelativePath>": {
    "name": "NamedParameters<typeof getOperationRelativePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationrelativepath",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getPathParse>": {
    "name": "NamedParameters<typeof getPathParse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpathparse",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getPathsWithOperations>": {
    "name": "NamedParameters<typeof getPathsWithOperations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpathswithoperations",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getProjectRoot>": {
    "name": "NamedParameters<typeof getProjectRoot>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getprojectroot",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getRelativeLinkPath>": {
    "name": "NamedParameters<typeof getRelativeLinkPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getrelativelinkpath",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getRelativePath>": {
    "name": "NamedParameters<typeof getRelativePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getrelativepath",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getSrcRelativeFileId>": {
    "name": "NamedParameters<typeof getSrcRelativeFileId>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsrcrelativefileid",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof hasDependency>": {
    "name": "NamedParameters<typeof hasDependency>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-hasdependency",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof hasProjectRootFile>": {
    "name": "NamedParameters<typeof hasProjectRootFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-hasprojectrootfile",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof isBundle>": {
    "name": "NamedParameters<typeof isBundle>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isbundle",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof isOperation>": {
    "name": "NamedParameters<typeof isOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isoperation",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof isUiOperation>": {
    "name": "NamedParameters<typeof isUiOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isuioperation",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof isWorkspaceRoot>": {
    "name": "NamedParameters<typeof isWorkspaceRoot>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isworkspaceroot",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof packageCompilesTs>": {
    "name": "NamedParameters<typeof packageCompilesTs>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-packagecompilests",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof tsconfigCompilesEsm>": {
    "name": "NamedParameters<typeof tsconfigCompilesEsm>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tsconfigcompilesesm",
    "description": "",
    "operationName": "get-path"
  },
  "Operation": {
    "name": "Operation",
    "slug": "TsInterface",
    "id": "operation",
    "description": "\nModel for `typerepo` operations. Stored in `package.json` in every package (compatible with regular npm package.json data structure). An `Operation` is a NPM Package that applies the `typerepo` convention.\n\nTODO: add a validation to package.json files for the whole project, to ensure i can apply `fs-orm` convention",
    "operationName": "get-imports-exports"
  },
  "OperationClassification": {
    "name": "OperationClassification",
    "slug": "TsInterface",
    "id": "operationclassification",
    "description": "`OperationClassification` tells you to what kind of environment the operation can be exposed to. It tells you things about how it will be built. There are three categories: Full stack, frontend only, and backend only. The aim is to do as much as possible in the full stack realm so it can be reused anywhere. If that is not possible, `ui-esm` is preferred for the frontend, or `node-esm` for things that require backend.\n\nTODO: It would be great to learn more about this topic and see if I can make more cross-environment packages. A great use case would be to create a wrapper around the current `fs-orm` to enable using it at the frontend too.\n\n# Possible values\n\nFULL STACK\n\n- `cjs`: only js (no node) (well, ts of course, but it gets built into common js)\n\n- `ts`: non-built typescript code (needs to be transpiled, not recommended)\n\nTODO: `esm`: builds to ESM module resolved Javascript\n\nFRONTEND ONLY (cannot be used within backend-only operations)\n\n- `ui-web`: has next.config.js and thus exposes something on some port when it is ran. next.js + react-based...\n\n- `ui-app`: uses react-native and exposes something on some port when it is ran\n\n- `ui-ts`: uses react (with (native)), which main entry points to typescript es6 files (this ui package cannot be built, should be transpiled. Primarily used for big ui libraries tied to a `ui-web` and `ui-app` for convenience. For other things, it is highly discouraged, please use `ui-cjs` or `ui-esm`)\n\n- `ui-cjs`: ui which main entry points to javascript es5 files (this ui package can be built). don't import ESM packages in here, this may give problems.\n\n- `ui-esm`: ui which builds to ESM module resolved Javascript. All packages that use `ui-esm` packages, need to be `ui-esm`, `ui-es6`, `ui-web`, or `ui-app` in order to work properly. It seems to have difficulties using this in `ui-cjs`\n\nBACKEND ONLY (cannot be used within frontend-only operations)\n\n- `node-cjs`: includes other node packages, operations, core-imports, and globals.\n\nTODO: `node-esm`: Typescript package that is built to ESM Javascript which also includes all node packages, operations, core-imports and globals.\n\nTODO: `node-ts`: transpilable node package\n\n- `server-cjs`: exposes something on some port when it is ran and uses node code\n\n# Indexation\n\nOperations will be classified automatically. It is good to remember that:\n\n- It will be classified as UI if `isUiOperation` resolves to true\n- It will be classified as Node if `Operation` has a (dev)dependency on `@types/node`.\n- Otherwise, it will be classified as base typescript (full stack)\n- It will be classified to an ESM operation if `tsconfigCompilesEsm` resolves to true.\n- It will be classified to a TS operation if `packageCompilesTs` resolves to true",
    "operationName": "migrate-operation-model"
  },
  "OperationClassificationObject": {
    "name": "OperationClassificationObject",
    "slug": "TsInterface",
    "id": "operationclassificationobject",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "TsConfig": {
    "name": "TsConfig",
    "slug": "TsInterface",
    "id": "tsconfig",
    "description": "\nwould be nice if we have a type interface for this, just like package.json\nfor now just type the stuff we need",
    "operationName": "code-types",
    "rawText": "\n\n/**\n *\n * ---\n * dbStorageMethod: jsonSingle\n * operationRelativePath: tsconfig.json\n * ---\n *\n * would be nice if we have a type interface for this, just like package.json\n * for now just type the stuff we need\n */\nexport interface TsConfig extends AnyModelType {\n  include?: string[];\n  exclude?: string[];\n  compilerOptions: CompilerOptions;\n}"
  },
  "NamedParameters<typeof benchmark>": {
    "name": "NamedParameters<typeof benchmark>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-benchmark",
    "description": "",
    "operationName": "k-explore"
  },
  "NamedParameters<typeof exploreOperationFolders>": {
    "name": "NamedParameters<typeof exploreOperationFolders>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-exploreoperationfolders",
    "description": "",
    "operationName": "k-explore"
  },
  "NamedParameters<typeof findAllDocsFolderPaths>": {
    "name": "NamedParameters<typeof findAllDocsFolderPaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findalldocsfolderpaths",
    "description": "",
    "operationName": "k-explore"
  },
  "NamedParameters<typeof findAllFoldersWithName>": {
    "name": "NamedParameters<typeof findAllFoldersWithName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findallfolderswithname",
    "description": "",
    "operationName": "k-explore"
  },
  "NamedParameters<typeof findAllPackages>": {
    "name": "NamedParameters<typeof findAllPackages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findallpackages",
    "description": "",
    "operationName": "k-explore"
  },
  "NamedParameters<typeof findAllTodoFolderPaths>": {
    "name": "NamedParameters<typeof findAllTodoFolderPaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findalltodofolderpaths",
    "description": "",
    "operationName": "k-explore"
  },
  "NamedParameters<typeof getArgument>": {
    "name": "NamedParameters<typeof getArgument>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getargument",
    "description": "",
    "operationName": "k-explore"
  },
  "NamedParameters<typeof pathArrayIsOperation>": {
    "name": "NamedParameters<typeof pathArrayIsOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-patharrayisoperation",
    "description": "",
    "operationName": "k-explore"
  },
  "NamedParameters<typeof getDependenciesSummary>": {
    "name": "NamedParameters<typeof getDependenciesSummary>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdependenciessummary",
    "description": "",
    "operationName": "operation-util"
  },
  "NamedParameters<typeof getOperationMetaData>": {
    "name": "NamedParameters<typeof getOperationMetaData>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationmetadata",
    "description": "",
    "operationName": "operation-util"
  },
  "NamedParameters<typeof recalculateOperationIndexJson>": {
    "name": "NamedParameters<typeof recalculateOperationIndexJson>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-recalculateoperationindexjson",
    "description": "",
    "operationName": "operation-util"
  },
  "OperationMetaData": {
    "name": "OperationMetaData",
    "slug": "TsInterface",
    "id": "operationmetadata",
    "description": "",
    "operationName": "operation-util",
    "rawText": "\n\nexport type OperationMetaData = {\n  operationBasePath: string;\n  operation: Operation | undefined;\n  operationName: string;\n  srcPath: string;\n  operationFolderName: string;\n  /**\n   * where the operation is located relative to the project root\n   */\n  relativeOperationLocationPath: string;\n};"
  },
  "NamedParameters<typeof deleteApp>": {
    "name": "NamedParameters<typeof deleteApp>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-deleteapp",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof deleteAppCli>": {
    "name": "NamedParameters<typeof deleteAppCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-deleteappcli",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof listApps>": {
    "name": "NamedParameters<typeof listApps>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-listapps",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof listAppsCli>": {
    "name": "NamedParameters<typeof listAppsCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-listappscli",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof logApp>": {
    "name": "NamedParameters<typeof logApp>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-logapp",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof logTableObject>": {
    "name": "NamedParameters<typeof logTableObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-logtableobject",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof pm2Connect>": {
    "name": "NamedParameters<typeof pm2Connect>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-pm2connect",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof restartApp>": {
    "name": "NamedParameters<typeof restartApp>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-restartapp",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof restartAppCli>": {
    "name": "NamedParameters<typeof restartAppCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-restartappcli",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof startApp>": {
    "name": "NamedParameters<typeof startApp>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-startapp",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof startAppCli>": {
    "name": "NamedParameters<typeof startAppCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-startappcli",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof stopAllAppsExcept>": {
    "name": "NamedParameters<typeof stopAllAppsExcept>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stopallappsexcept",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof stopAllAppsExceptCli>": {
    "name": "NamedParameters<typeof stopAllAppsExceptCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stopallappsexceptcli",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof stopApps>": {
    "name": "NamedParameters<typeof stopApps>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stopapps",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof stopAppsCli>": {
    "name": "NamedParameters<typeof stopAppsCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stopappscli",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof watchAll>": {
    "name": "NamedParameters<typeof watchAll>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-watchall",
    "description": "",
    "operationName": "watch-all"
  },
  "NamedParameters<typeof watchAllCli>": {
    "name": "NamedParameters<typeof watchAllCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-watchallcli",
    "description": "",
    "operationName": "watch-all"
  },
  "NamedParameters<typeof exitIfOperationsChange>": {
    "name": "NamedParameters<typeof exitIfOperationsChange>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-exitifoperationschange",
    "description": "",
    "operationName": "watch-operations"
  },
  "NamedParameters<typeof gitCommitAllCron>": {
    "name": "NamedParameters<typeof gitCommitAllCron>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gitcommitallcron",
    "description": "",
    "operationName": "watch-operations"
  },
  "NamedParameters<typeof watchOperations>": {
    "name": "NamedParameters<typeof watchOperations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-watchoperations",
    "description": "",
    "operationName": "watch-operations"
  },
  "WatchEventType": {
    "name": "WatchEventType",
    "slug": "TsInterface",
    "id": "watcheventtype",
    "description": "Different event types for the watcher of the file system (chokidar)\n\n- add: a file got created\n- addDir: a folder got created\n- change: a file changed\n- unlink: a file got removed\n- unlinkDir: a folder got removed",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof brigtnessFull>": {
    "name": "NamedParameters<typeof brigtnessFull>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-brigtnessfull",
    "description": "",
    "operationName": "brightness"
  },
  "NamedParameters<typeof brigtnessZero>": {
    "name": "NamedParameters<typeof brigtnessZero>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-brigtnesszero",
    "description": "",
    "operationName": "brightness"
  },
  "NamedParameters<typeof decreaseBrightness>": {
    "name": "NamedParameters<typeof decreaseBrightness>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-decreasebrightness",
    "description": "",
    "operationName": "brightness"
  },
  "NamedParameters<typeof increaseBrightness>": {
    "name": "NamedParameters<typeof increaseBrightness>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-increasebrightness",
    "description": "",
    "operationName": "brightness"
  },
  "NamedParameters<typeof macosSetup>": {
    "name": "NamedParameters<typeof macosSetup>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-macossetup",
    "description": "",
    "operationName": "clean-macos-setup"
  },
  "NamedParameters<typeof fileExplorerOpen>": {
    "name": "NamedParameters<typeof fileExplorerOpen>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fileexploreropen",
    "description": "",
    "operationName": "file-explorer-open"
  },
  "NamedParameters<typeof playMusic>": {
    "name": "NamedParameters<typeof playMusic>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-playmusic",
    "description": "",
    "operationName": "play-music"
  },
  "NamedParameters<typeof generateRecurringReminders>": {
    "name": "NamedParameters<typeof generateRecurringReminders>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generaterecurringreminders",
    "description": "",
    "operationName": "reminders"
  },
  "NamedParameters<typeof remindMeAboutNextMinute>": {
    "name": "NamedParameters<typeof remindMeAboutNextMinute>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-remindmeaboutnextminute",
    "description": "",
    "operationName": "reminders"
  },
  "NamedParameters<typeof setRandomTimezone>": {
    "name": "NamedParameters<typeof setRandomTimezone>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-setrandomtimezone",
    "description": "",
    "operationName": "set-random-timezone"
  },
  "NamedParameters<typeof disableDarkMode>": {
    "name": "NamedParameters<typeof disableDarkMode>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-disabledarkmode",
    "description": "",
    "operationName": "toggle-dark-mode"
  },
  "NamedParameters<typeof enableDarkMode>": {
    "name": "NamedParameters<typeof enableDarkMode>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-enabledarkmode",
    "description": "",
    "operationName": "toggle-dark-mode"
  },
  "NamedParameters<typeof setDarkmodeCommand>": {
    "name": "NamedParameters<typeof setDarkmodeCommand>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-setdarkmodecommand",
    "description": "",
    "operationName": "toggle-dark-mode"
  },
  "NamedParameters<typeof toggleDarkMode>": {
    "name": "NamedParameters<typeof toggleDarkMode>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-toggledarkmode",
    "description": "",
    "operationName": "toggle-dark-mode"
  },
  "NamedParameters<typeof disableScreenSleep>": {
    "name": "NamedParameters<typeof disableScreenSleep>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-disablescreensleep",
    "description": "",
    "operationName": "toggle-screen-sleep"
  },
  "NamedParameters<typeof disableScreenSleep2>": {
    "name": "NamedParameters<typeof disableScreenSleep2>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-disablescreensleep2",
    "description": "",
    "operationName": "toggle-screen-sleep"
  },
  "NamedParameters<typeof enableScreenSleep>": {
    "name": "NamedParameters<typeof enableScreenSleep>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-enablescreensleep",
    "description": "",
    "operationName": "toggle-screen-sleep"
  },
  "NamedParameters<typeof downVolume>": {
    "name": "NamedParameters<typeof downVolume>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-downvolume",
    "description": "",
    "operationName": "volume"
  },
  "NamedParameters<typeof getVolume>": {
    "name": "NamedParameters<typeof getVolume>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getvolume",
    "description": "",
    "operationName": "volume"
  },
  "NamedParameters<typeof setVolume>": {
    "name": "NamedParameters<typeof setVolume>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-setvolume",
    "description": "",
    "operationName": "volume"
  },
  "NamedParameters<typeof upVolume>": {
    "name": "NamedParameters<typeof upVolume>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-upvolume",
    "description": "",
    "operationName": "volume"
  },
  "NamedParameters<typeof getOpenableFilePath>": {
    "name": "NamedParameters<typeof getOpenableFilePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getopenablefilepath",
    "description": "",
    "operationName": "vscode-open"
  },
  "NamedParameters<typeof vscodeOpen>": {
    "name": "NamedParameters<typeof vscodeOpen>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-vscodeopen",
    "description": "",
    "operationName": "vscode-open"
  },
  "OpenableFile": {
    "name": "OpenableFile",
    "slug": "TsInterface",
    "id": "openablefile",
    "description": "",
    "operationName": "vscode-open",
    "rawText": "\n\nexport type OpenableFile = {\n  projectRelativePath?: string;\n  /**\n   *\n   */\n  operationName?: string;\n  operationRelativeFilePath?: string;\n  line?: number;\n};"
  },
  "devtoLoginProps": {
    "name": "devtoLoginProps",
    "slug": "TsInterface",
    "id": "devtologinprops",
    "description": "",
    "operationName": "dev-to-controller",
    "rawText": "\n\nexport interface devtoLoginProps {\n  page: Page;\n  email: string;\n  password: string;\n}"
  },
  "NamedParameters<typeof loginToDevto>": {
    "name": "NamedParameters<typeof loginToDevto>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-logintodevto",
    "description": "",
    "operationName": "dev-to-controller"
  },
  "NamedParameters<typeof publishBlogOnDevTo>": {
    "name": "NamedParameters<typeof publishBlogOnDevTo>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-publishblogondevto",
    "description": "",
    "operationName": "dev-to-controller"
  },
  "NamedParameters<typeof typeIntoTheField>": {
    "name": "NamedParameters<typeof typeIntoTheField>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-typeintothefield",
    "description": "",
    "operationName": "dev-to-controller"
  },
  "ResponseType": {
    "name": "ResponseType",
    "slug": "TsInterface",
    "id": "responsetype",
    "description": "",
    "operationName": "slack-controller",
    "rawText": "\nexport type ResponseType = {\n  success: boolean;\n  message: string;\n  page?: Page;\n};"
  },
  "TypeInTheField": {
    "name": "TypeInTheField",
    "slug": "TsInterface",
    "id": "typeinthefield",
    "description": "",
    "operationName": "dev-to-controller",
    "rawText": "\n\nexport interface TypeInTheField {\n  page: Page;\n  selectorString: string;\n  valueToType: string;\n}"
  },
  "NamedParameters<typeof sendFacebookMessage>": {
    "name": "NamedParameters<typeof sendFacebookMessage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-sendfacebookmessage",
    "description": "",
    "operationName": "facebook-controller"
  },
  "NamedParameters<typeof facebookPost>": {
    "name": "NamedParameters<typeof facebookPost>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-facebookpost",
    "description": "",
    "operationName": "facebook-controller"
  },
  "NamedParameters<typeof facebookTimeLinePost>": {
    "name": "NamedParameters<typeof facebookTimeLinePost>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-facebooktimelinepost",
    "description": "",
    "operationName": "facebook-controller"
  },
  "NamedParameters<typeof getLatestFacebookPostUrl>": {
    "name": "NamedParameters<typeof getLatestFacebookPostUrl>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getlatestfacebookposturl",
    "description": "",
    "operationName": "facebook-controller"
  },
  "NamedParameters<typeof searchAndDownloadGifs>": {
    "name": "NamedParameters<typeof searchAndDownloadGifs>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-searchanddownloadgifs",
    "description": "",
    "operationName": "gif-controller"
  },
  "NamedParameters<typeof buildQuery>": {
    "name": "NamedParameters<typeof buildQuery>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-buildquery",
    "description": "",
    "operationName": "google-translate-controller"
  },
  "NamedParameters<typeof errArrayLenZero>": {
    "name": "NamedParameters<typeof errArrayLenZero>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-errarraylenzero",
    "description": "",
    "operationName": "google-translate-controller"
  },
  "NamedParameters<typeof errFileSize>": {
    "name": "NamedParameters<typeof errFileSize>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-errfilesize",
    "description": "",
    "operationName": "google-translate-controller"
  },
  "NamedParameters<typeof errFileType>": {
    "name": "NamedParameters<typeof errFileType>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-errfiletype",
    "description": "",
    "operationName": "google-translate-controller"
  },
  "NamedParameters<typeof errInvalidType>": {
    "name": "NamedParameters<typeof errInvalidType>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-errinvalidtype",
    "description": "",
    "operationName": "google-translate-controller"
  },
  "NamedParameters<typeof errTextLenZero>": {
    "name": "NamedParameters<typeof errTextLenZero>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-errtextlenzero",
    "description": "",
    "operationName": "google-translate-controller"
  },
  "NamedParameters<typeof errTextOverflow>": {
    "name": "NamedParameters<typeof errTextOverflow>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-errtextoverflow",
    "description": "",
    "operationName": "google-translate-controller"
  },
  "NamedParameters<typeof generateArrayFromJson>": {
    "name": "NamedParameters<typeof generateArrayFromJson>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatearrayfromjson",
    "description": "",
    "operationName": "google-translate-controller"
  },
  "NamedParameters<typeof getStringForTranslation>": {
    "name": "NamedParameters<typeof getStringForTranslation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getstringfortranslation",
    "description": "",
    "operationName": "google-translate-controller"
  },
  "NamedParameters<typeof launch>": {
    "name": "NamedParameters<typeof launch>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-launch",
    "description": "",
    "operationName": "google-translate-controller"
  },
  "NamedParameters<typeof startTranslation>": {
    "name": "NamedParameters<typeof startTranslation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-starttranslation",
    "description": "",
    "operationName": "markdown-translator"
  },
  "NamedParameters<typeof storeResult>": {
    "name": "NamedParameters<typeof storeResult>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-storeresult",
    "description": "",
    "operationName": "google-translate-controller"
  },
  "NamedParameters<typeof translateText>": {
    "name": "NamedParameters<typeof translateText>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-translatetext",
    "description": "",
    "operationName": "google-translate-controller"
  },
  "Options": {
    "name": "Options",
    "slug": "TsInterface",
    "id": "options",
    "description": "",
    "operationName": "google-translate-controller",
    "rawText": "\n\nexport interface Options extends PuppeteerOptions {\n\t/** language you want to translate from. eg: 'en' (english), 'es' (spanish) */\n\tfrom?: lang | 'auto';\n\t/** language you want to translate to.*/\n\tto: lang;\n}"
  },
  "PuppeteerOptions": {
    "name": "PuppeteerOptions",
    "slug": "TsInterface",
    "id": "puppeteeroptions",
    "description": "",
    "operationName": "google-translate-controller",
    "rawText": "export interface PuppeteerOptions {\n\t/** should run a headless browser or not */\n\theadless?: boolean;\n\t/** program should timeout after this amout of milisseconds */\n\ttimeout?: number;\n}"
  },
  "Query": {
    "name": "Query",
    "slug": "TsInterface",
    "id": "query",
    "description": "",
    "operationName": "google-translate-controller",
    "rawText": "\n\nexport interface Query extends Options {\n\t/** set query mode.\n\t * 'translate' is to translate a string or array of strings;\n\t * 'docs' is to translate text files (eg: ['txt.txt', 'docx.docx'])\n\t *  */\n\top: 'translate' | 'docs';\n\t/** the text string to translate (optional) */\n\ttext?: string;\n}"
  },
  "Todo": {
    "name": "Todo",
    "slug": "TsInterface",
    "id": "todo",
    "description": "The `Todo` KVMD model parses a `TodoFile` to find individual todos, their status, category, and more structured metadata.\n\nCan be chosen to be used for a `TodoFile` to create an alternative UI\n\n`TodoFile`s can be parsed to find this datastructure\n\nWill be great for insights.",
    "operationName": "todo-types",
    "rawText": "\n\n/**\n * The `Todo` KVMD model parses a `TodoFile` to find individual todos, their status, category, and more structured metadata.\n *\n * Can be chosen to be used for a `TodoFile` to create an alternative UI\n *\n * `TodoFile`s can be parsed to find this datastructure\n *\n * Will be great for insights.\n */\nexport interface Todo extends SpecialKvmdModelType {\n  /**\n   * If line contains a bolded text at the start, this will be the title\n   */\n  title?: string;\n\n  /**\n   * unix timestamp indicating when this thing needs to be done\n   *\n   * can be inferred from the line like:\n   *\n   * `(< 2023-08-20)`\n   */\n  deadlineAt?: number;\n\n  /**\n   * Inferred from the line\n   */\n  todo: string;\n\n  /**\n   * Can be indicated with\n   *\n   * âœ… = done\n   * âŒ = wontdo\n   * ðŸ”§ = doing (maybe use ðŸŸ ?)\n   *\n   * (none = todo)\n   */\n  status: \"todo\" | \"doing\" | \"wontdo\" | \"done\";\n  /**\n   * can be indicated with 'ðŸš«'\n   */\n  isBlocked: boolean;\n  /**\n   * can be indicated with 'â—ï¸'\n   */\n  isCritical: boolean;\n  /**\n   * can be indicated with 'ðŸŒ'\n   */\n  isInternetRequired: boolean;\n  /**\n   * can be inferred from @[PersonSlug]\n   */\n  assigned_personId?: Id;\n  /**\n   * can be inferred from a time indicator between parenthesises at the end of the sentence\n   *\n   * e.g. `(3h)` or `(20m)` or `(5d)`\n   */\n  duration?: number;\n  durationTimeIndicator: \"hours\" | \"days\" | \"minutes\";\n}"
  },
  "WordType": {
    "name": "WordType",
    "slug": "TsInterface",
    "id": "wordtype",
    "description": "",
    "operationName": "language-types",
    "rawText": "\n\nexport type WordType = \"noun\" | \"adjective\" | \"verb\";"
  },
  "MailDataFromOptional": {
    "name": "MailDataFromOptional",
    "slug": "TsInterface",
    "id": "maildatafromoptional",
    "description": "From is optional for sending an email because it will be filled in by the OsConfig default.",
    "operationName": "mail",
    "rawText": "\n/**\n * From is optional for sending an email because it will be filled in by the OsConfig default.\n */\nexport type MailDataFromOptional = Omit<MailDataRequired, \"from\"> & {\n  /**\n   * If you don't fill this in, the `OsConfig` default will be used.\n   */\n  from?: string;\n};"
  },
  "NamedParameters<typeof sendMail>": {
    "name": "NamedParameters<typeof sendMail>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-sendmail",
    "description": "",
    "operationName": "mail"
  },
  "NamedParameters<typeof publishBlogOnMedium>": {
    "name": "NamedParameters<typeof publishBlogOnMedium>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-publishblogonmedium",
    "description": "",
    "operationName": "medium-controller"
  },
  "NamedParameters<typeof publishBlogOnReddit>": {
    "name": "NamedParameters<typeof publishBlogOnReddit>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-publishblogonreddit",
    "description": "",
    "operationName": "reddit-controller"
  },
  "NamedParameters<typeof sendSms>": {
    "name": "NamedParameters<typeof sendSms>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-sendsms",
    "description": "",
    "operationName": "sms"
  },
  "NamedParameters<typeof postTweetOnTwitter>": {
    "name": "NamedParameters<typeof postTweetOnTwitter>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-posttweetontwitter",
    "description": "",
    "operationName": "twitter-controller"
  },
  "NamedParameters<typeof getTwitterPostUrl>": {
    "name": "NamedParameters<typeof getTwitterPostUrl>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettwitterposturl",
    "description": "",
    "operationName": "twitter-controller"
  },
  "NamedParameters<typeof youtubeSearch>": {
    "name": "NamedParameters<typeof youtubeSearch>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-youtubesearch",
    "description": "",
    "operationName": "youtube-controller"
  },
  "NamedParameters<typeof youtubeSearchAndDownload>": {
    "name": "NamedParameters<typeof youtubeSearchAndDownload>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-youtubesearchanddownload",
    "description": "",
    "operationName": "youtube-controller"
  },
  "NamedParameters<typeof youtubeToMp3>": {
    "name": "NamedParameters<typeof youtubeToMp3>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-youtubetomp3",
    "description": "",
    "operationName": "youtube-controller"
  },
  "NamedParameters<typeof youtubeToMp4>": {
    "name": "NamedParameters<typeof youtubeToMp4>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-youtubetomp4",
    "description": "",
    "operationName": "youtube-controller"
  },
  "ReturnType": {
    "name": "ReturnType",
    "slug": "TsInterface",
    "id": "returntype",
    "description": "",
    "operationName": "youtube-controller",
    "rawText": "\n\nexport interface ReturnType {\n  success: boolean;\n  message: string;\n  data?: VideoMetaType[];\n}"
  },
  "VideoMetaType": {
    "name": "VideoMetaType",
    "slug": "TsInterface",
    "id": "videometatype",
    "description": "",
    "operationName": "youtube-controller",
    "rawText": "\n\nexport type VideoMetaType = {\n  url: string | null;\n  description: string | null;\n};"
  },
  "DropboxExtension": {
    "name": "DropboxExtension",
    "slug": "TsInterface",
    "id": "dropboxextension",
    "description": "these filetypes should never be opened with explore. They should be processed and either indexed or converted. This creates a md or json with the proper metadata, which, in turn, can be explored.",
    "operationName": "filename-conventions",
    "rawText": "\n\n/**\n * these filetypes should never be opened with explore. They should be processed and either indexed or converted. This creates a md or json with the proper metadata, which, in turn, can be explored.\n */\nexport type DropboxExtension =\n  | \"doc\"\n  | \"docx\"\n  | \"csv\"\n  | \"xls\"\n  | \"xlsx\"\n  | \"epub\"\n  | \"pdf\";"
  },
  "JsonExtension": {
    "name": "JsonExtension",
    "slug": "TsInterface",
    "id": "jsonextension",
    "description": "",
    "operationName": "filename-conventions",
    "rawText": "\nexport type JsonExtension = typeof jsonExtensions[number];"
  },
  "MarkdownExtension": {
    "name": "MarkdownExtension",
    "slug": "TsInterface",
    "id": "markdownextension",
    "description": "",
    "operationName": "filename-conventions",
    "rawText": "\nexport type MarkdownExtension = typeof markdownExtensions[number];"
  },
  "NamedParameters<typeof getFileTypeFromPath>": {
    "name": "NamedParameters<typeof getFileTypeFromPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfiletypefrompath",
    "description": "",
    "operationName": "filename-conventions"
  },
  "NamedParameters<typeof getWriterType>": {
    "name": "NamedParameters<typeof getWriterType>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getwritertype",
    "description": "",
    "operationName": "filename-conventions"
  },
  "NamedParameters<typeof hasSubExtension>": {
    "name": "NamedParameters<typeof hasSubExtension>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-hassubextension",
    "description": "",
    "operationName": "social-media-node"
  },
  "NamedParameters<typeof isGeneratedOperation>": {
    "name": "NamedParameters<typeof isGeneratedOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isgeneratedoperation",
    "description": "",
    "operationName": "filename-conventions"
  },
  "NamedParameters<typeof isGeneratedOperationName>": {
    "name": "NamedParameters<typeof isGeneratedOperationName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isgeneratedoperationname",
    "description": "",
    "operationName": "filename-conventions"
  },
  "NamedParameters<typeof isIndexableFileId>": {
    "name": "NamedParameters<typeof isIndexableFileId>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isindexablefileid",
    "description": "",
    "operationName": "filename-conventions"
  },
  "SearchableExtension": {
    "name": "SearchableExtension",
    "slug": "TsInterface",
    "id": "searchableextension",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "SearchLevel": {
    "name": "SearchLevel",
    "slug": "TsInterface",
    "id": "searchlevel",
    "description": "",
    "operationName": "filename-conventions",
    "rawText": "\n\nexport type SearchLevel =\n  | \"folder\"\n  | \"fileName\"\n  | \"filePath\"\n  | \"outline\"\n  | \"full\";"
  },
  "TypescriptExtension": {
    "name": "TypescriptExtension",
    "slug": "TsInterface",
    "id": "typescriptextension",
    "description": "",
    "operationName": "filename-conventions",
    "rawText": "\n\nexport type TypescriptExtension = typeof typescriptExtensions[number];"
  },
  "WriterType": {
    "name": "WriterType",
    "slug": "TsInterface",
    "id": "writertype",
    "description": "Type of content that can be interpreted by the `writer-input`",
    "operationName": "filename-conventions",
    "rawText": "\n\n/**\n * Type of content that can be interpreted by the `writer-input`\n */\nexport type WriterType = \"typescript\" | \"markdown\" | \"other\";"
  },
  "NamedParameters<typeof getPort>": {
    "name": "NamedParameters<typeof getPort>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getport",
    "description": "",
    "operationName": "get-port"
  },
  "NamedParameters<typeof getAssetInputType>": {
    "name": "NamedParameters<typeof getAssetInputType>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getassetinputtype",
    "description": "",
    "operationName": "name-conventions"
  },
  "NamedParameters<typeof getParameterContentType>": {
    "name": "NamedParameters<typeof getParameterContentType>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getparametercontenttype",
    "description": "",
    "operationName": "name-conventions"
  },
  "NamedParameters<typeof isCalculatedParameter>": {
    "name": "NamedParameters<typeof isCalculatedParameter>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-iscalculatedparameter",
    "description": "",
    "operationName": "name-conventions"
  },
  "NamedParameters<typeof isGeneratedParameterName>": {
    "name": "NamedParameters<typeof isGeneratedParameterName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isgeneratedparametername",
    "description": "",
    "operationName": "name-conventions"
  },
  "PatternMatcher": {
    "name": "PatternMatcher",
    "slug": "TsInterface",
    "id": "patternmatcher",
    "description": "",
    "operationName": "name-conventions",
    "rawText": "\n\nexport type PatternMatcher = {\n  pattern: string;\n  matches: string;\n  /**\n   * if true, this indicates that all instances of the matched are single words. This makes it possible to use this patternmatcher directly after another patternmatcher without loosing information.\n   */\n  isSingleWord?: boolean;\n};"
  },
  "SimplifiedSchemaType": {
    "name": "SimplifiedSchemaType",
    "slug": "TsInterface",
    "id": "simplifiedschematype",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport type SimplifiedSchemaType =\n  | \"string\"\n  | \"number\"\n  | \"boolean\"\n  | \"object\"\n  | \"array\"\n  | \"null\";"
  },
  "BundleConfig": {
    "name": "BundleConfig",
    "slug": "TsInterface",
    "id": "bundleconfig",
    "description": "\nConfiguration options for bundles. Used with `generateBundle`\n\nEverything in this model will be copied over to the created bundle, except for `createBundleConfig` and `customisableBundleConfig`.",
    "operationName": "generate-sdk-operations"
  },
  "BundleSummary": {
    "name": "BundleSummary",
    "slug": "TsInterface",
    "id": "bundlesummary",
    "description": "",
    "operationName": "bundle-util",
    "rawText": "\n\nexport type BundleSummary = {\n  slug: string;\n  /**\n   * Haven't found a good usecase for this yet\n   */\n  // filesAndFoldersToInclude: string[];\n  packageNames: string[];\n  moduleNames: string[];\n  appNames: string[];\n};"
  },
  "NamedParameters<typeof getBundleSummary>": {
    "name": "NamedParameters<typeof getBundleSummary>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getbundlesummary",
    "description": "",
    "operationName": "bundle-util"
  },
  "NamedParameters<typeof getDbModelsForBundle>": {
    "name": "NamedParameters<typeof getDbModelsForBundle>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdbmodelsforbundle",
    "description": "",
    "operationName": "bundle-util"
  },
  "NamedParameters<typeof createBackup>": {
    "name": "NamedParameters<typeof createBackup>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-createbackup",
    "description": "",
    "operationName": "create-backup"
  },
  "NamedParameters<typeof createBackupCli>": {
    "name": "NamedParameters<typeof createBackupCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-createbackupcli",
    "description": "",
    "operationName": "create-backup"
  },
  "NamedParameters<typeof getHumanReadableDate>": {
    "name": "NamedParameters<typeof getHumanReadableDate>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gethumanreadabledate",
    "description": "",
    "operationName": "create-backup"
  },
  "NamedParameters<typeof createDistribution>": {
    "name": "NamedParameters<typeof createDistribution>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-createdistribution",
    "description": "",
    "operationName": "create-distribution"
  },
  "NamedParameters<typeof filterInterfacesFromOperationNames>": {
    "name": "NamedParameters<typeof filterInterfacesFromOperationNames>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-filterinterfacesfromoperationnames",
    "description": "",
    "operationName": "db-util"
  },
  "NamedParameters<typeof getDbModelsFromOperations>": {
    "name": "NamedParameters<typeof getDbModelsFromOperations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdbmodelsfromoperations",
    "description": "",
    "operationName": "db-util"
  },
  "TsInterface": {
    "name": "TsInterface",
    "slug": "TsInterface",
    "id": "tsinterface",
    "description": "\nTODO: Just like parameters, this should be linted for. If you define an interface that's not declared here, that should ring a bell.",
    "operationName": "index-typescript"
  },
  "CreateBundleConfig": {
    "name": "CreateBundleConfig",
    "slug": "TsInterface",
    "id": "createbundleconfig",
    "description": "",
    "operationName": "bundle-types",
    "rawText": "\n\nexport type CreateBundleConfig = {\n  /**\n   * You can specify `Slug`s of other `BundleConfig`s here that this bundle should inherit from, recursively.\n   *\n   * Works a little like https://www.typescriptlang.org/tsconfig#extends\n   *\n   * Will only inherit the apps, packages, and modules, nothing else.\n   *\n   * # How it works\n   *\n   * 1) finds all unique `BundleConfig`s that need to be inherited, recursively,\n   * 2) make a `BundleSummary` of every `BundleConfig`\n   * 3) merge the `BundleSummary`s and omit duplicates\n   *\n   * TODO: Implement this\n   */\n  inheritFrom_bundleConfigSlugs?: Slug[];\n  /**\n   * If true, the structure of operation locations is kept the same but still inside packages/apps/modules.\n   */\n  keepStructure?: boolean;\n\n  keepCodestories?: boolean;\n  /**\n   * Default information strategy\n   */\n  informationStrategy?: InformationStrategy;\n\n  /**\n   * Information strategy per model\n   *\n   * For example, this would ensure your diaries are not copied over to the bundle:\n   *\n   * ```json\n   * { \"Diary\": \"ignore\" }\n   * ```\n   *\n   * If you want to be certain something isn't included, instead of putting it into the model specific information strategy, you can also just put it in an operation that isn't required in the bundle.\n   *\n   * This parameter is especially useful if you want to change a information stategy for one model in specific.\n   */\n  modelInformationStrategy?: {\n    [modelName: string]: InformationStrategy;\n  };\n\n  /**\n   * After applying the `informationStrategy`, and `modelInformationStrategy`, these datasets will be added or overwriting the data\n   */\n  additional_datasetSlugs?: Slug[];\n\n  /**\n   * After applying the `informationStrategy`, and `modelInformationStrategy`, these datasets will be found in the then available data in the bundle, and will be filtered out.\n   */\n  filter_datasetSlugs?: Slug[];\n\n  /**\n   * If true, this bundleconfig will be skipped when using `generateAllBundles`\n   */\n  isDraft?: boolean;\n\n  /**\n   * if true, todos are also copied into their original location, which is in `packages` if it's not in an operation, or in the operation in any of the folders if it's an operation.\n   *\n   * The markdown-reader will then add them to a todo menu.\n   *\n   * NB: Only works in conjunction with `keepStructure`\n   */\n  keepTodos?: boolean;\n\n  bundles: FrontBackBundle[];\n  /**\n   * Generated, private by default. If they're already here, uses private/public setting as given.\n   *\n   * When generating, removes the ones that are not dependencies (of dependencies) of your standalone apps\n   */\n  dependencies?: OperationPrivacy[];\n\n  /**\n   * optional. Could also find the main file from here and use that as README.md\n   *\n   * Must be a relative path from project root. Can be multiple!\n   */\n  docsRelativeFolderPath?:\n    | ProjectRelativeFolderPath\n    | ProjectRelativeFolderPath[];\n\n  /**\n   * paths to image folders that should randomly be used as default headers or footers in the generated markdown.\n   */\n  imagesProjectRelativeFolderPaths?: ProjectRelativeFolderPath[];\n  /**\n   * Optional. path to a readme file for the monorepo root.\n   *\n   * If not given, and if you did provide a path for docs, the main docs intro file will be taken\n   *\n   * Must be a relative path from project  root\n   */\n  readmeRelativeFilePath?: ProjectRelativeFilePath;\n\n  /**\n   * if given, it will fetch these folders from the repo and paste them in the bundle whenever the bundle is generated\n   *\n   * can be handy if you're working with someone else...\n   *\n   * Should later be deprecated and p2p operation-sync should be used\n   */\n  foldersFromRepo?: string[];\n};"
  },
  "CustomisableBundleConfig": {
    "name": "CustomisableBundleConfig",
    "slug": "TsInterface",
    "id": "customisablebundleconfig",
    "description": "configuration that can be applied when generating a new bundle\n\nIt can be put in the BundleConfig, but it can also be set manually for an individual Bundle Generation.",
    "operationName": "bundle-types",
    "rawText": "\n\n/**\n * configuration that can be applied when generating a new bundle\n *\n * It can be put in the BundleConfig, but it can also be set manually for an individual Bundle Generation.\n */\nexport type CustomisableBundleConfig = {\n  /**\n   * if true, will not clone/pull/push and deploy. No internet is needed, will also not use any `.git` folder.\n   */\n  isOffline?: boolean;\n  /** skips the step where it gets the new stuff from github */\n  skipPull?: boolean;\n  /** skips the step where it pushes the new bundle to remote */\n  skipPush?: boolean;\n  skipSyncNicheFolder?: boolean;\n  skipRebuildNicheOperations?: boolean;\n  /** skips the step where it saves to the db */\n  skipUpsert?: boolean;\n\n  debug?: boolean;\n  /** descriptioin for git commit, if pushing. Default is \"monorepo update\" */\n  description?: string;\n  /**\n   * optionally, specify a custom branch name to pull from / push to / checkout (default is \"main\")\n   */\n  branchName?: string;\n\n  publicEnvironmentVariables?: EnvironmentVariableObject;\n\n  /**\n   * NB: should not end up in public repos!\n   */\n  privateEnvironmentVariables?: EnvironmentVariableObject;\n\n  /**\n   * Configuration for your commit (needed for vercel deployment)\n   */\n  gitUserEmail?: string;\n  gitUserName?: string;\n};"
  },
  "FinalBundleConfig": {
    "name": "FinalBundleConfig",
    "slug": "TsInterface",
    "id": "finalbundleconfig",
    "description": "",
    "operationName": "bundle-types",
    "rawText": "\n\nexport type FinalBundleConfig = Omit<\n  BundleConfig,\n  \"customisableBundleConfig\" | \"createBundleConfig\"\n> & {\n  customisableBundleConfig: FinalCustomisableBundleConfig;\n  createBundleConfig: FinalCreateBundleConfig;\n};"
  },
  "NamedParameters<typeof calculateBundleDependencies>": {
    "name": "NamedParameters<typeof calculateBundleDependencies>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-calculatebundledependencies",
    "description": "",
    "operationName": "generate-bundle"
  },
  "NamedParameters<typeof calculateToPath>": {
    "name": "NamedParameters<typeof calculateToPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-calculatetopath",
    "description": "",
    "operationName": "generate-bundle"
  },
  "NamedParameters<typeof copyCodestories>": {
    "name": "NamedParameters<typeof copyCodestories>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-copycodestories",
    "description": "",
    "operationName": "generate-bundle"
  },
  "NamedParameters<typeof copyDocsAndReadme>": {
    "name": "NamedParameters<typeof copyDocsAndReadme>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-copydocsandreadme",
    "description": "",
    "operationName": "generate-bundle"
  },
  "NamedParameters<typeof copyFromRepoToNiche>": {
    "name": "NamedParameters<typeof copyFromRepoToNiche>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-copyfromrepotoniche",
    "description": "",
    "operationName": "generate-bundle"
  },
  "NamedParameters<typeof copyOperation>": {
    "name": "NamedParameters<typeof copyOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-copyoperation",
    "description": "",
    "operationName": "generate-bundle"
  },
  "NamedParameters<typeof copyReadmesBeforeFolderToBundle>": {
    "name": "NamedParameters<typeof copyReadmesBeforeFolderToBundle>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-copyreadmesbeforefoldertobundle",
    "description": "",
    "operationName": "generate-bundle"
  },
  "NamedParameters<typeof copyTodosIntoBundle>": {
    "name": "NamedParameters<typeof copyTodosIntoBundle>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-copytodosintobundle",
    "description": "",
    "operationName": "generate-bundle"
  },
  "NamedParameters<typeof findAndCopyOperations>": {
    "name": "NamedParameters<typeof findAndCopyOperations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findandcopyoperations",
    "description": "",
    "operationName": "generate-bundle"
  },
  "NamedParameters<typeof findInherited>": {
    "name": "NamedParameters<typeof findInherited>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findinherited",
    "description": "",
    "operationName": "generate-bundle"
  },
  "NamedParameters<typeof generateAllBundles>": {
    "name": "NamedParameters<typeof generateAllBundles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateallbundles",
    "description": "",
    "operationName": "generate-bundle"
  },
  "NamedParameters<typeof generateBundle>": {
    "name": "NamedParameters<typeof generateBundle>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatebundle",
    "description": "",
    "operationName": "generate-bundle"
  },
  "NamedParameters<typeof generateBundles>": {
    "name": "NamedParameters<typeof generateBundles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatebundles",
    "description": "",
    "operationName": "generate-bundle"
  },
  "NamedParameters<typeof getBundlePaths>": {
    "name": "NamedParameters<typeof getBundlePaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getbundlepaths",
    "description": "",
    "operationName": "generate-bundle"
  },
  "NamedParameters<typeof getIndirectDependencies>": {
    "name": "NamedParameters<typeof getIndirectDependencies>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getindirectdependencies",
    "description": "",
    "operationName": "generate-bundle"
  },
  "NamedParameters<typeof mergeBundleConfigs>": {
    "name": "NamedParameters<typeof mergeBundleConfigs>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-mergebundleconfigs",
    "description": "",
    "operationName": "generate-bundle"
  },
  "NamedParameters<typeof syncNicheFolder>": {
    "name": "NamedParameters<typeof syncNicheFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-syncnichefolder",
    "description": "",
    "operationName": "generate-bundle"
  },
  "NamedParameters<typeof yarnInstall>": {
    "name": "NamedParameters<typeof yarnInstall>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-yarninstall",
    "description": "",
    "operationName": "generate-bundle"
  },
  "OperationPrivacy": {
    "name": "OperationPrivacy",
    "slug": "TsInterface",
    "id": "operationprivacy",
    "description": "",
    "operationName": "bundle-types",
    "rawText": "\n\nexport interface OperationPrivacy {\n  operationName: string;\n  /**\n   * if public, everything will be kept\n   *\n   * if private, src and todo will be removed from bundle, unless it's a ui-es6 operation, because src is needed then. In that case, only \"todo\" will be deleted.\n   */\n  privacy: \"public\" | \"private\";\n}"
  },
  "NamedParameters<typeof installNodeModules>": {
    "name": "NamedParameters<typeof installNodeModules>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-installnodemodules",
    "description": "",
    "operationName": "install-node-modules"
  },
  "NamedParameters<typeof yarnInstallNewDistribution>": {
    "name": "NamedParameters<typeof yarnInstallNewDistribution>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-yarninstallnewdistribution",
    "description": "",
    "operationName": "yarn-install-new-distribution"
  },
  "NamedParameters<typeof detectLanguage>": {
    "name": "NamedParameters<typeof detectLanguage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-detectlanguage",
    "description": "",
    "operationName": "markdown-translator"
  },
  "NamedParameters<typeof generateSimpleSentence>": {
    "name": "NamedParameters<typeof generateSimpleSentence>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatesimplesentence",
    "description": "",
    "operationName": "generate-simple-sentence"
  },
  "NamedParameters<typeof makeAudioCourse>": {
    "name": "NamedParameters<typeof makeAudioCourse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-makeaudiocourse",
    "description": "",
    "operationName": "generate-simple-sentence"
  },
  "NamedParameters<typeof sleep>": {
    "name": "NamedParameters<typeof sleep>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-sleep",
    "description": "",
    "operationName": "generate-simple-sentence"
  },
  "SayLanguageEnum": {
    "name": "SayLanguageEnum",
    "slug": "TsInterface",
    "id": "saylanguageenum",
    "description": "",
    "operationName": "say",
    "rawText": "\n\nexport type SayLanguageEnum = \"np\" | \"nl\" | \"en\";"
  },
  "TokiPonaMatrix": {
    "name": "TokiPonaMatrix",
    "slug": "TsInterface",
    "id": "tokiponamatrix",
    "description": "DEPRECATED: to be migrated to `WordMatrix`",
    "operationName": "language-types",
    "rawText": "\n\n/**\n * DEPRECATED: to be migrated to `WordMatrix`\n */\nexport interface TokiPonaMatrix extends DefaultModelType {\n  category: string;\n  type: string;\n  tok?: string;\n  nl?: string;\n  en?: string;\n  np?: string;\n  \"pt-br\"?: string;\n  em: string;\n}"
  },
  "DefaultResponseType": {
    "name": "DefaultResponseType",
    "slug": "TsInterface",
    "id": "defaultresponsetype",
    "description": "",
    "operationName": "markdown-translator",
    "rawText": "\n\nexport type DefaultResponseType = {\n  isSuccess: boolean;\n  message: string;\n};"
  },
  "FileInfo": {
    "name": "FileInfo",
    "slug": "TsInterface",
    "id": "fileinfo",
    "description": "",
    "operationName": "markdown-translator",
    "rawText": "export type FileInfo = {\n  fileType?: string;\n  fileLocation: string;\n  fileName: string;\n  fullPath: string;\n  folderName?: string;\n};"
  },
  "NamedParameters<typeof createFolder>": {
    "name": "NamedParameters<typeof createFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-createfolder",
    "description": "",
    "operationName": "markdown-translator"
  },
  "NamedParameters<typeof getAllMarkdownFiles>": {
    "name": "NamedParameters<typeof getAllMarkdownFiles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getallmarkdownfiles",
    "description": "",
    "operationName": "markdown-translator"
  },
  "NamedParameters<typeof getFileInfo>": {
    "name": "NamedParameters<typeof getFileInfo>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfileinfo",
    "description": "",
    "operationName": "markdown-translator"
  },
  "NamedParameters<typeof getTranslatedWord>": {
    "name": "NamedParameters<typeof getTranslatedWord>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettranslatedword",
    "description": "",
    "operationName": "markdown-translator"
  },
  "NamedParameters<typeof markdownStoreAndRecord>": {
    "name": "NamedParameters<typeof markdownStoreAndRecord>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownstoreandrecord",
    "description": "",
    "operationName": "markdown-translator"
  },
  "NamedParameters<typeof parseMarkdownWordByWord>": {
    "name": "NamedParameters<typeof parseMarkdownWordByWord>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parsemarkdownwordbyword",
    "description": "",
    "operationName": "markdown-translator"
  },
  "NamedParameters<typeof recordMdFile>": {
    "name": "NamedParameters<typeof recordMdFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-recordmdfile",
    "description": "",
    "operationName": "markdown-translator"
  },
  "NamedParameters<typeof startMarkdownTranslator>": {
    "name": "NamedParameters<typeof startMarkdownTranslator>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-startmarkdowntranslator",
    "description": "",
    "operationName": "markdown-translator"
  },
  "NamedParameters<typeof translatedArrayToKeyValue>": {
    "name": "NamedParameters<typeof translatedArrayToKeyValue>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-translatedarraytokeyvalue",
    "description": "",
    "operationName": "markdown-translator"
  },
  "NamedParameters<typeof watchMdFile>": {
    "name": "NamedParameters<typeof watchMdFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-watchmdfile",
    "description": "",
    "operationName": "markdown-translator"
  },
  "NamedParameters<typeof createWordSimplificationMap>": {
    "name": "NamedParameters<typeof createWordSimplificationMap>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-createwordsimplificationmap",
    "description": "",
    "operationName": "simplify-text"
  },
  "NamedParameters<typeof findBetterWords>": {
    "name": "NamedParameters<typeof findBetterWords>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findbetterwords",
    "description": "",
    "operationName": "simplify-text"
  },
  "NamedParameters<typeof getSynonymFrequencyDataset>": {
    "name": "NamedParameters<typeof getSynonymFrequencyDataset>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsynonymfrequencydataset",
    "description": "",
    "operationName": "simplify-text"
  },
  "NamedParameters<typeof preprocessSynonyms>": {
    "name": "NamedParameters<typeof preprocessSynonyms>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-preprocesssynonyms",
    "description": "",
    "operationName": "simplify-text"
  },
  "NamedParameters<typeof preprocessWordFrequencies>": {
    "name": "NamedParameters<typeof preprocessWordFrequencies>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-preprocesswordfrequencies",
    "description": "",
    "operationName": "simplify-text"
  },
  "NamedParameters<typeof simplifyText>": {
    "name": "NamedParameters<typeof simplifyText>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-simplifytext",
    "description": "",
    "operationName": "simplify-text"
  },
  "NamedParameters<typeof testSimplifiedText>": {
    "name": "NamedParameters<typeof testSimplifiedText>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-testsimplifiedtext",
    "description": "",
    "operationName": "simplify-text"
  },
  "NamedParameters<typeof speakWordsToLearn>": {
    "name": "NamedParameters<typeof speakWordsToLearn>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-speakwordstolearn",
    "description": "",
    "operationName": "speak-words-to-learn"
  },
  "NamedParameters<typeof createPaymentRequestWithContext>": {
    "name": "NamedParameters<typeof createPaymentRequestWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-createpaymentrequestwithcontext",
    "description": "",
    "operationName": "payment-node"
  },
  "NamedParameters<typeof createPaymentTransactionWithContext>": {
    "name": "NamedParameters<typeof createPaymentTransactionWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-createpaymenttransactionwithcontext",
    "description": "",
    "operationName": "payment-node"
  },
  "NamedParameters<typeof getPaymentWebPages>": {
    "name": "NamedParameters<typeof getPaymentWebPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpaymentwebpages",
    "description": "",
    "operationName": "payment-node"
  },
  "Credit": {
    "name": "Credit",
    "slug": "TsInterface",
    "id": "credit",
    "description": "",
    "operationName": "model-types",
    "rawText": "\nexport type Credit = number;"
  },
  "DefaultModelType": {
    "name": "DefaultModelType",
    "slug": "TsInterface",
    "id": "defaultmodeltype",
    "description": "Use this model by default",
    "operationName": "foodchain-types"
  },
  "Id": {
    "name": "Id",
    "slug": "TsInterface",
    "id": "id",
    "description": "Should be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
    "operationName": "foodchain-types"
  },
  "MarkdownModelType": {
    "name": "MarkdownModelType",
    "slug": "TsInterface",
    "id": "markdownmodeltype",
    "description": "Handy model type for storing stuff in a Markdown file.\n\n1 markdown file will represent 1 MarkdownModelType extended instance\n\nanother option could be to parse the markdown file, but to KISS we are going to just return markdown with the full markdown content\n\nTODO: see how this relates to MarkdownFile. Make this very clear!",
    "operationName": "os-types"
  },
  "PaymentConfig": {
    "name": "PaymentConfig",
    "slug": "TsInterface",
    "id": "paymentconfig",
    "description": "project-wide configuration for what is possible with payments",
    "operationName": "payment-types",
    "rawText": "\n\n/**\n * project-wide configuration for what is possible with payments\n */\nexport type PaymentConfig = {\n  creditToEuroRatio: number;\n  creditToEuroConversionCost: number;\n  currencyConversionCost: number;\n  creditToCreditTransactionCost: number;\n  interestAmount: number;\n  interestInterval: RunEveryPeriodEnum;\n  canPersonBuyCredit: boolean;\n  canPersonCashOutCredit: boolean;\n  canPersonRequestCashOut: boolean;\n  // [key: string]: any;\n};"
  },
  "PaymentCoupon": {
    "name": "PaymentCoupon",
    "slug": "TsInterface",
    "id": "paymentcoupon",
    "description": "Model for one-time coupons with invalidation\n\nCan be filled in for any `PaymentPlan` with initial cost.\n\nWill not pay for the subscription cost.\n\nLater, this can be extended",
    "operationName": "payment-types",
    "rawText": "\n\n/**\n * Model for one-time coupons with invalidation\n *\n * Can be filled in for any `PaymentPlan` with initial cost.\n *\n * Will not pay for the subscription cost.\n *\n * Later, this can be extended\n */\nexport interface PaymentCoupon extends DefaultModelType {\n  /**\n   * Unique code that is sent to a `Person`\n   */\n  couponCode: string;\n  /**\n   * Maximum price for the credit\n   *\n   * If filled in at a paymentPlan with a higher price, this will be the maximum discount.\n   *\n   * If filled in at a paymentPlan with a lower price, the whole coupon will still be removed\n   */\n  maximumPrice: Price;\n\n  /**\n   * After this date the coupon will not be valid anymore and should be removed\n   */\n  validUntilAt: number;\n}"
  },
  "PaymentEvent": {
    "name": "PaymentEvent",
    "slug": "TsInterface",
    "id": "paymentevent",
    "description": "An actual stripe payment that is being initiated, processed or happened\n\nCan be a one-time payment or based on a `PaymentSubscription`",
    "operationName": "payment-types",
    "rawText": "\n\n/**\n * An actual stripe payment that is being initiated, processed or happened\n *\n * Can be a one-time payment or based on a `PaymentSubscription`\n */\nexport interface PaymentEvent extends DefaultModelType {\n  personId?: Id;\n  price: Price;\n  stripePaymentStatus?: unknown;\n  cryptoPaymentStatus?: unknown;\n}"
  },
  "PaymentPlan": {
    "name": "PaymentPlan",
    "slug": "TsInterface",
    "id": "paymentplan",
    "description": "PaymentPlans are plans that provide certain features, perks, statuses, access, or roles on different platforms.",
    "operationName": "payment-types",
    "rawText": "\n\n/**\n * PaymentPlans are plans that provide certain features, perks, statuses, access, or roles on different platforms.\n */\nexport interface PaymentPlan extends MarkdownModelType {\n  /**\n   * If given, PaymentPlan will be active for these bundle(s)\n   */\n  bundleConfigSlugs?: Slug[];\n  /**\n   * If there's a one-time price, it should be filled in here.\n   */\n  oneTimePrice?: Price;\n  intervalPrice?: Price;\n  /**\n   * When does the payment occur?\n   *\n   * Leave undefined for one-time payments\n   */\n  paymentInterval?: RunEveryPeriodEnum;\n\n  /**\n   * How many credit are received?\n   */\n  credit?: Credit;\n\n  /**\n   * Description of the plan\n   */\n  markdown: string;\n}"
  },
  "PaymentRequest": {
    "name": "PaymentRequest",
    "slug": "TsInterface",
    "id": "paymentrequest",
    "description": "A request for a `PaymentTransaction` to be made to receiver from one or multiple payers",
    "operationName": "payment-types",
    "rawText": "\n\n/**\n * A request for a `PaymentTransaction` to be made to receiver from one or multiple payers\n */\nexport interface PaymentRequest extends DefaultModelType {\n  receiver_personId: Id;\n  /**\n   * optional, you can also make it public\n   */\n  payer_personIds?: Id[];\n  /**\n   * required token in order to make the payment. Can be part of a link for example\n   *\n   * We don't want to use the ID because the payment request may become visible in a interface without being able to pay\n   */\n  token: string;\n  /**\n   * If true, anyone can pay this if they have the token\n   */\n  isPublic?: boolean;\n  credit?: Credit;\n}"
  },
  "PaymentSubscription": {
    "name": "PaymentSubscription",
    "slug": "TsInterface",
    "id": "paymentsubscription",
    "description": "A person can subscribe to a paymentplan to receive something. Must be a `PaymentPlan` with a `.intervalPrice`, this is for the recurring payment that should be initiated and done.",
    "operationName": "payment-types",
    "rawText": "\n\n/**\n * A person can subscribe to a paymentplan to receive something. Must be a `PaymentPlan` with a `.intervalPrice`, this is for the recurring payment that should be initiated and done.\n */\nexport interface PaymentSubscription extends DefaultModelType {\n  personId?: Id;\n  paymentPlanSlug: Slug;\n  paymentPlan?: PaymentPlan;\n}"
  },
  "PaymentTransaction": {
    "name": "PaymentTransaction",
    "slug": "TsInterface",
    "id": "paymenttransaction",
    "description": "A credit transaction between person A and person B.",
    "operationName": "payment-types",
    "rawText": "\n\n/**\n * A credit transaction between person A and person B.\n */\nexport interface PaymentTransaction extends DefaultModelType {\n  payer_personId: Id;\n  receiver_personId: Id;\n  credit: Credit;\n}"
  },
  "Price": {
    "name": "Price",
    "slug": "TsInterface",
    "id": "price",
    "description": "model to indicate pricing of something\n\nNB: can be free (for borrowing, for example, sometimes)",
    "operationName": "os-types",
    "rawText": "\n\n/**\n * model to indicate pricing of something\n *\n * NB: can be free (for borrowing, for example, sometimes)\n */\nexport interface Price {\n  /**\n   * you may not want money, but something in exchange instead. Like some beers!\n   */\n  description?: Markdown;\n  price?: number;\n  priceRangeLow?: number;\n  priceRangeHigh?: number;\n  currency?: CurrencyString;\n  /**\n   * Optional: unit like\n   * - \"per m2\" for land\n   * - \"per month\" for house rental\n   * - \"per night\" for airbnb\n   */\n  unit?: string;\n  /**\n   * if true, this will be inactive\n   */\n  inactive: boolean;\n}"
  },
  "RunEveryPeriodEnum": {
    "name": "RunEveryPeriodEnum",
    "slug": "TsInterface",
    "id": "runeveryperiodenum",
    "description": "Used to specify functions that need to run every time with a specific interval\n\nAll times are at at the server timezone time\n\n- `minute`: every minute at 0 seconds\n- `5-mintues`: every 5 minutes, starting at the first minute of the hour\n- `quarter-hour`: every 15 minutes, starting at the first minute of the hour\n- `hour`: every hour, starting at the first minute of the hour\n- `6-hours`: every 6 hours, starting at midnight\n- `midnight`: every midnight (00:00:00)\n- `week`: every week at sundaynight (sunday, 1 second after 23:59:59 PM)\n- `month`: at the first second of the first day of the month (0:00:00)\n- `3-months`: every start of the quarter: january 1st (0:00:00), april 1st, july 1st, october 1st\n- `year`: every new year at january 1st at 0:00:00",
    "operationName": "function-server"
  },
  "Slug": {
    "name": "Slug",
    "slug": "TsInterface",
    "id": "slug",
    "description": "use this for any identifier that's not an Id-type. Usually this is a kebab-case version of a written text, but it can also be a file path, for example.",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof videoToMp3>": {
    "name": "NamedParameters<typeof videoToMp3>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-videotomp3",
    "description": "",
    "operationName": "video-to-mp3"
  },
  "NamedParameters<typeof unzip>": {
    "name": "NamedParameters<typeof unzip>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-unzip",
    "description": "",
    "operationName": "unzip"
  },
  "NamedParameters<typeof zip>": {
    "name": "NamedParameters<typeof zip>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-zip",
    "description": "",
    "operationName": "zip"
  },
  "CsvItemType": {
    "name": "CsvItemType",
    "slug": "TsInterface",
    "id": "csvitemtype",
    "description": "",
    "operationName": "csv-util",
    "rawText": "\nexport type CsvItemType = {\n  [key: string]: string | number | boolean | null | undefined;\n};"
  },
  "NamedParameters<typeof tryParseCsv>": {
    "name": "NamedParameters<typeof tryParseCsv>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tryparsecsv",
    "description": "",
    "operationName": "csv-util"
  },
  "NamedParameters<typeof convertCsvToJson>": {
    "name": "NamedParameters<typeof convertCsvToJson>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-convertcsvtojson",
    "description": "",
    "operationName": "xls-to-csv-json"
  },
  "NamedParameters<typeof convertXlsToJson>": {
    "name": "NamedParameters<typeof convertXlsToJson>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-convertxlstojson",
    "description": "",
    "operationName": "xls-to-csv-json"
  },
  "NamedParameters<typeof compressImage>": {
    "name": "NamedParameters<typeof compressImage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-compressimage",
    "description": "",
    "operationName": "ffmpeg-util"
  },
  "NamedParameters<typeof compressImages>": {
    "name": "NamedParameters<typeof compressImages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-compressimages",
    "description": "",
    "operationName": "ffmpeg-util"
  },
  "NamedParameters<typeof compressImagesCli>": {
    "name": "NamedParameters<typeof compressImagesCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-compressimagescli",
    "description": "",
    "operationName": "ffmpeg-util"
  },
  "NamedParameters<typeof compressMp4>": {
    "name": "NamedParameters<typeof compressMp4>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-compressmp4",
    "description": "",
    "operationName": "ffmpeg-util"
  },
  "NamedParameters<typeof compressMp4sCli>": {
    "name": "NamedParameters<typeof compressMp4sCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-compressmp4scli",
    "description": "",
    "operationName": "ffmpeg-util"
  },
  "NamedParameters<typeof convertToMp3>": {
    "name": "NamedParameters<typeof convertToMp3>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-converttomp3",
    "description": "",
    "operationName": "ffmpeg-util"
  },
  "NamedParameters<typeof convertToMp4>": {
    "name": "NamedParameters<typeof convertToMp4>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-converttomp4",
    "description": "",
    "operationName": "ffmpeg-util"
  },
  "Json": {
    "name": "Json",
    "slug": "TsInterface",
    "id": "json",
    "description": "",
    "operationName": "model-types",
    "rawText": "export type Json =\n  | string\n  | number\n  | boolean\n  | null\n  | { [key: string]: Json }\n  | Json[];"
  },
  "NamedParameters<typeof jsonToMdString>": {
    "name": "NamedParameters<typeof jsonToMdString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-jsontomdstring",
    "description": "",
    "operationName": "json-to-md"
  },
  "NamedParameters<typeof printObject>": {
    "name": "NamedParameters<typeof printObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-printobject",
    "description": "",
    "operationName": "json-to-md"
  },
  "NamedParameters<typeof jsonToSayString>": {
    "name": "NamedParameters<typeof jsonToSayString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-jsontosaystring",
    "description": "",
    "operationName": "json-to-say-string"
  },
  "NamedParameters<typeof getSimpleJsonString>": {
    "name": "NamedParameters<typeof getSimpleJsonString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsimplejsonstring",
    "description": "",
    "operationName": "json-util"
  },
  "CopyPair": {
    "name": "CopyPair",
    "slug": "TsInterface",
    "id": "copypair",
    "description": "",
    "operationName": "collect-static-assets",
    "rawText": "\n\nexport type CopyPair = {\n  absoluteSourcePath: string;\n  absoluteDestinationPath: string;\n};"
  },
  "NamedParameters<typeof copyCopyPairs>": {
    "name": "NamedParameters<typeof copyCopyPairs>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-copycopypairs",
    "description": "",
    "operationName": "collect-static-assets"
  },
  "NamedParameters<typeof copyReaderStaticAssets>": {
    "name": "NamedParameters<typeof copyReaderStaticAssets>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-copyreaderstaticassets",
    "description": "",
    "operationName": "collect-static-assets"
  },
  "NamedParameters<typeof findReaderStaticAssets>": {
    "name": "NamedParameters<typeof findReaderStaticAssets>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findreaderstaticassets",
    "description": "",
    "operationName": "collect-static-assets"
  },
  "NamedParameters<typeof findStaticAssets>": {
    "name": "NamedParameters<typeof findStaticAssets>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findstaticassets",
    "description": "",
    "operationName": "collect-static-assets"
  },
  "ReaderWebPage": {
    "name": "ReaderWebPage",
    "slug": "TsInterface",
    "id": "readerwebpage",
    "description": "specifically always a markdown page",
    "operationName": "webpage-types",
    "rawText": "\n/**\n * specifically always a markdown page\n */\nexport type ReaderWebPage = FileWebPage;"
  },
  "NamedParameters<typeof docToMd>": {
    "name": "NamedParameters<typeof docToMd>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-doctomd",
    "description": "",
    "operationName": "doc-to-md"
  },
  "NamedParameters<typeof docxToMd>": {
    "name": "NamedParameters<typeof docxToMd>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-docxtomd",
    "description": "",
    "operationName": "doc-to-md"
  },
  "NamedParameters<typeof runTests>": {
    "name": "NamedParameters<typeof runTests>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-runtests",
    "description": "",
    "operationName": "doc-to-md"
  },
  "NamedParameters<typeof waitMilliseconds>": {
    "name": "NamedParameters<typeof waitMilliseconds>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-waitmilliseconds",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "CategoryStack": {
    "name": "CategoryStack",
    "slug": "TsInterface",
    "id": "categorystack",
    "description": "Taken from the location in the folder of the db-model.\n\nNB: Changing this value when updating/upserting, changes where the item is located!",
    "operationName": "simplified-schema-form"
  },
  "DbFileLocation": {
    "name": "DbFileLocation",
    "slug": "TsInterface",
    "id": "dbfilelocation",
    "description": "Object used to hand over all information about the location of a db-file in a structured way",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * Object used to hand over all information about the location of a db-file in a structured way\n */\nexport type DbFileLocation = ModelLocation & {\n  absolutePath: string;\n  modelName: string;\n};"
  },
  "KeyValueMarkdownModelType": {
    "name": "KeyValueMarkdownModelType",
    "slug": "TsInterface",
    "id": "keyvaluemarkdownmodeltype",
    "description": "handy model type for storing stuff in a KeyValue Markdown file. empty lines are omitted\n\nall you need to specify in the kvmd is the key and the value, separated by \":\"\n\nNB: there can be a `parent_modelNameSlug` key exposed that should refer to the parent slug",
    "operationName": "foodchain-types"
  },
  "KeyValueMarkdownParse": {
    "name": "KeyValueMarkdownParse",
    "slug": "TsInterface",
    "id": "keyvaluemarkdownparse",
    "description": "",
    "operationName": "model-types",
    "rawText": "\n\nexport type KeyValueMarkdownParse = {\n  parameters: Frontmatter;\n  data: KeyValueMarkdownModelType[];\n};"
  },
  "MarkdownChunk": {
    "name": "MarkdownChunk",
    "slug": "TsInterface",
    "id": "markdownchunk",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof flattenMarkdownChunks>": {
    "name": "NamedParameters<typeof flattenMarkdownChunks>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-flattenmarkdownchunks",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "NamedParameters<typeof getKvmdItemsRecursively>": {
    "name": "NamedParameters<typeof getKvmdItemsRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getkvmditemsrecursively",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "NamedParameters<typeof getParagraphsRecursively>": {
    "name": "NamedParameters<typeof getParagraphsRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getparagraphsrecursively",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "NamedParameters<typeof kvmdDataMap>": {
    "name": "NamedParameters<typeof kvmdDataMap>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-kvmddatamap",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "NamedParameters<typeof kvmdDataToString>": {
    "name": "NamedParameters<typeof kvmdDataToString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-kvmddatatostring",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "NamedParameters<typeof kvmdParseToMarkdownString>": {
    "name": "NamedParameters<typeof kvmdParseToMarkdownString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-kvmdparsetomarkdownstring",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "NamedParameters<typeof markdownStringToKvmdParse>": {
    "name": "NamedParameters<typeof markdownStringToKvmdParse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownstringtokvmdparse",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "NamedParameters<typeof parseKvmdLine>": {
    "name": "NamedParameters<typeof parseKvmdLine>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parsekvmdline",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "CodespanItemInfo": {
    "name": "CodespanItemInfo",
    "slug": "TsInterface",
    "id": "codespaniteminfo",
    "description": "",
    "operationName": "make-codestory",
    "rawText": "export type CodespanItemInfo = {\n  name: string;\n  /**\n   * This is the type in this case\n   */\n  slug: string;\n  id: string;\n  description?: string;\n  rawText?: string;\n  gitRepoUrl?: string;\n};"
  },
  "NamedParameters<typeof addCodestoryToSection>": {
    "name": "NamedParameters<typeof addCodestoryToSection>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-addcodestorytosection",
    "description": "",
    "operationName": "make-codestory"
  },
  "NamedParameters<typeof findCodestories>": {
    "name": "NamedParameters<typeof findCodestories>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findcodestories",
    "description": "",
    "operationName": "make-codestory"
  },
  "NamedParameters<typeof makeCodespanMappedObject>": {
    "name": "NamedParameters<typeof makeCodespanMappedObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-makecodespanmappedobject",
    "description": "",
    "operationName": "make-codestory"
  },
  "NamedParameters<typeof makeCodestory>": {
    "name": "NamedParameters<typeof makeCodestory>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-makecodestory",
    "description": "",
    "operationName": "make-codestory"
  },
  "NamedParameters<typeof writeAllCodestories>": {
    "name": "NamedParameters<typeof writeAllCodestories>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-writeallcodestories",
    "description": "",
    "operationName": "make-codestory"
  },
  "NamedParameters<typeof writeAllCodestoriesCli>": {
    "name": "NamedParameters<typeof writeAllCodestoriesCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-writeallcodestoriescli",
    "description": "",
    "operationName": "make-codestory"
  },
  "NamedParameters<typeof writeCodespanDetails>": {
    "name": "NamedParameters<typeof writeCodespanDetails>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-writecodespandetails",
    "description": "",
    "operationName": "make-codestory"
  },
  "MarkdownParagraphChunk": {
    "name": "MarkdownParagraphChunk",
    "slug": "TsInterface",
    "id": "markdownparagraphchunk",
    "description": "",
    "operationName": "markdown-parse-js",
    "rawText": "\n\nexport type MarkdownParagraphChunk = {\n  isNewline?: boolean;\n  codeblock?: MarkdownCodeblock;\n  text?: string;\n  isBolded?: boolean;\n  isItalic?: boolean;\n  isBackticked?: boolean;\n  reference?: MarkdownReference;\n};"
  },
  "MarkdownParse": {
    "name": "MarkdownParse",
    "slug": "TsInterface",
    "id": "markdownparse",
    "description": "",
    "operationName": "markdown"
  },
  "MarkdownParseConfig": {
    "name": "MarkdownParseConfig",
    "slug": "TsInterface",
    "id": "markdownparseconfig",
    "description": "",
    "operationName": "markdown-parse-js",
    "rawText": "\n\nexport type MarkdownParseConfig = {\n  /**\n  \n  setting this to true will \n  \n  - not trim strings in frontmatter\n  \n     */\n  noFinal?: boolean;\n  /**\n  if you want frontmatter to be parsed in correct shape, add frontmatterSchema\n     */\n  frontmatterSchema?: SimplifiedSchema;\n};"
  },
  "MarkdownReference": {
    "name": "MarkdownReference",
    "slug": "TsInterface",
    "id": "markdownreference",
    "description": "",
    "operationName": "markdown-parse-js",
    "rawText": "export type MarkdownReference = {\n  /**\n   * Alternate text inside of the reference, if available\n   */\n  alt?: string;\n  /**\n   * Absolute path to the refered object\n   */\n  path: string;\n  /**\n   * if true, it's an asset (with !)\n   *\n   * otherwise, it's a link\n   */\n  isAsset?: boolean;\n};"
  },
  "NamedParameters<typeof chunkToStringRecursively>": {
    "name": "NamedParameters<typeof chunkToStringRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-chunktostringrecursively",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof getChunkParagraphsRecursively>": {
    "name": "NamedParameters<typeof getChunkParagraphsRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getchunkparagraphsrecursively",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof getImplicitId>": {
    "name": "NamedParameters<typeof getImplicitId>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getimplicitid",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof getMarkdownIntro>": {
    "name": "NamedParameters<typeof getMarkdownIntro>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmarkdownintro",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof getMarkdownParseParagraphs>": {
    "name": "NamedParameters<typeof getMarkdownParseParagraphs>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmarkdownparseparagraphs",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof getMarkdownReferencePaths>": {
    "name": "NamedParameters<typeof getMarkdownReferencePaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmarkdownreferencepaths",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof getMarkdownReferencesFromParagraph>": {
    "name": "NamedParameters<typeof getMarkdownReferencesFromParagraph>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmarkdownreferencesfromparagraph",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof markdownParseToMarkdownString>": {
    "name": "NamedParameters<typeof markdownParseToMarkdownString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownparsetomarkdownstring",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof markdownParseToMarkdownStringFromContent>": {
    "name": "NamedParameters<typeof markdownParseToMarkdownStringFromContent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownparsetomarkdownstringfromcontent",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof mdContentParseRecursively>": {
    "name": "NamedParameters<typeof mdContentParseRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-mdcontentparserecursively",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof mdToJsonParse>": {
    "name": "NamedParameters<typeof mdToJsonParse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-mdtojsonparse",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof parseFrontmatterMarkdownString>": {
    "name": "NamedParameters<typeof parseFrontmatterMarkdownString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parsefrontmattermarkdownstring",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof parseMarkdownParagraph>": {
    "name": "NamedParameters<typeof parseMarkdownParagraph>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parsemarkdownparagraph",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof parseMdToChunks>": {
    "name": "NamedParameters<typeof parseMdToChunks>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parsemdtochunks",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof removeHeaderPrefix>": {
    "name": "NamedParameters<typeof removeHeaderPrefix>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removeheaderprefix",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "SimplifiedSchema": {
    "name": "SimplifiedSchema",
    "slug": "TsInterface",
    "id": "simplifiedschema",
    "description": "JSONSchema7 derivative that has the following capabilities and and characteristics...\n\n- does not include objects in objects that are also referenced to using xxxSlug or xxxId\n- recursively finds the references and expands them, unless the references are circular\n- easier to read\n- has all the information we need\n- is able to generate an object with values in the exact format the function needs it\n- is able to easily generate a form",
    "operationName": "simplified-schema-form"
  },
  "DependantCountObject": {
    "name": "DependantCountObject",
    "slug": "TsInterface",
    "id": "dependantcountobject",
    "description": "interface that lets us count the amount of dependant files in different item types",
    "operationName": "markdown-parsings",
    "rawText": "\n\n/**\n * interface that lets us count the amount of dependant files in different item types\n */\nexport type DependantCountObject = {\n  externalDependantFiles: string[];\n} & StatementItem;"
  },
  "FolderSummary": {
    "name": "FolderSummary",
    "slug": "TsInterface",
    "id": "foldersummary",
    "description": "objective size measurements of all files in a folder\n\nsummary for a folder should contain file-summaries for different filetypes and an overal file summary",
    "operationName": "migrate-operation-model"
  },
  "JsonPart": {
    "name": "JsonPart",
    "slug": "TsInterface",
    "id": "jsonpart",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": "\n\nexport type JsonPart = { identifier?: string; json: Json };"
  },
  "JSONSchema7": {
    "name": "JSONSchema7",
    "slug": "TsInterface",
    "id": "jsonschema7",
    "description": "",
    "operationName": "schema-util"
  },
  "MergedMarkdownOutlineUrl": {
    "name": "MergedMarkdownOutlineUrl",
    "slug": "TsInterface",
    "id": "mergedmarkdownoutlineurl",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": "\n\nexport type MergedMarkdownOutlineUrl = { title: string; hashtagPath: string };"
  },
  "NamedParameters<typeof addDependantCount>": {
    "name": "NamedParameters<typeof addDependantCount>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-adddependantcount",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof bundleFolderWithMarkdown>": {
    "name": "NamedParameters<typeof bundleFolderWithMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-bundlefolderwithmarkdown",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof bundleToBookMarkdown>": {
    "name": "NamedParameters<typeof bundleToBookMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-bundletobookmarkdown",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof bundleToMarkdown>": {
    "name": "NamedParameters<typeof bundleToMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-bundletomarkdown",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof concatMarkdownFiles>": {
    "name": "NamedParameters<typeof concatMarkdownFiles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-concatmarkdownfiles",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof createMinimizedSection>": {
    "name": "NamedParameters<typeof createMinimizedSection>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-createminimizedsection",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof createMinimizedSectionMarkdown>": {
    "name": "NamedParameters<typeof createMinimizedSectionMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-createminimizedsectionmarkdown",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof deployToVercel>": {
    "name": "NamedParameters<typeof deployToVercel>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-deploytovercel",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof emailMarkdownParse>": {
    "name": "NamedParameters<typeof emailMarkdownParse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-emailmarkdownparse",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof generateStaticSite>": {
    "name": "NamedParameters<typeof generateStaticSite>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatestaticsite",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof getJsonSchemaSummary>": {
    "name": "NamedParameters<typeof getJsonSchemaSummary>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getjsonschemasummary",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof getMarkdownContents>": {
    "name": "NamedParameters<typeof getMarkdownContents>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmarkdowncontents",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof getMergedMarkdownOutlineUrl>": {
    "name": "NamedParameters<typeof getMergedMarkdownOutlineUrl>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmergedmarkdownoutlineurl",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof getOperationSummary>": {
    "name": "NamedParameters<typeof getOperationSummary>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationsummary",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof getOutline>": {
    "name": "NamedParameters<typeof getOutline>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoutline",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof getPublicMarkdownNestedPathObject>": {
    "name": "NamedParameters<typeof getPublicMarkdownNestedPathObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpublicmarkdownnestedpathobject",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof getTitlesRecursively>": {
    "name": "NamedParameters<typeof getTitlesRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettitlesrecursively",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof getTypeDescriptorRecursive>": {
    "name": "NamedParameters<typeof getTypeDescriptorRecursive>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettypedescriptorrecursive",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof isConventionFileStatement>": {
    "name": "NamedParameters<typeof isConventionFileStatement>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isconventionfilestatement",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof isUpperCase>": {
    "name": "NamedParameters<typeof isUpperCase>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isuppercase",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof makeOutlineMarkdownString>": {
    "name": "NamedParameters<typeof makeOutlineMarkdownString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-makeoutlinemarkdownstring",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof makePropertiesTable>": {
    "name": "NamedParameters<typeof makePropertiesTable>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-makepropertiestable",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof markdownChunksToMarkdownStringRecursive>": {
    "name": "NamedParameters<typeof markdownChunksToMarkdownStringRecursive>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownchunkstomarkdownstringrecursive",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof markdownChunkToMarkdownStringRecursive>": {
    "name": "NamedParameters<typeof markdownChunkToMarkdownStringRecursive>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownchunktomarkdownstringrecursive",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof markdownToSayable>": {
    "name": "NamedParameters<typeof markdownToSayable>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdowntosayable",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof mdToPdf>": {
    "name": "NamedParameters<typeof mdToPdf>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-mdtopdf",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof mergeMarkdownParse>": {
    "name": "NamedParameters<typeof mergeMarkdownParse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-mergemarkdownparse",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof noNewlines>": {
    "name": "NamedParameters<typeof noNewlines>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-nonewlines",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof operationRadio>": {
    "name": "NamedParameters<typeof operationRadio>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-operationradio",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof operationToMarkdown>": {
    "name": "NamedParameters<typeof operationToMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-operationtomarkdown",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof print>": {
    "name": "NamedParameters<typeof print>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-print",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof printNestedTitles>": {
    "name": "NamedParameters<typeof printNestedTitles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-printnestedtitles",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof projectToMarkdown>": {
    "name": "NamedParameters<typeof projectToMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-projecttomarkdown",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof propertyToTableRow>": {
    "name": "NamedParameters<typeof propertyToTableRow>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-propertytotablerow",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof sayablesToMp3>": {
    "name": "NamedParameters<typeof sayablesToMp3>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-sayablestomp3",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof selectRandomOperation>": {
    "name": "NamedParameters<typeof selectRandomOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-selectrandomoperation",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof simplifiedSchemaToMarkdownString>": {
    "name": "NamedParameters<typeof simplifiedSchemaToMarkdownString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-simplifiedschematomarkdownstring",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof statementItemToMarkdown>": {
    "name": "NamedParameters<typeof statementItemToMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-statementitemtomarkdown",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof tsFunctionToMarkdownString>": {
    "name": "NamedParameters<typeof tsFunctionToMarkdownString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tsfunctiontomarkdownstring",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof tsInterfaceToMarkdownString>": {
    "name": "NamedParameters<typeof tsInterfaceToMarkdownString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tsinterfacetomarkdownstring",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof tsVariableToMarkdownString>": {
    "name": "NamedParameters<typeof tsVariableToMarkdownString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tsvariabletomarkdownstring",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof upMarkdownChunkLevelRecursively>": {
    "name": "NamedParameters<typeof upMarkdownChunkLevelRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-upmarkdownchunklevelrecursively",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NestedTitle": {
    "name": "NestedTitle",
    "slug": "TsInterface",
    "id": "nestedtitle",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": "\n\nexport type NestedTitle = string | NestedTitle[];"
  },
  "OperationSummary": {
    "name": "OperationSummary",
    "slug": "TsInterface",
    "id": "operationsummary",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": "\n\nexport type OperationSummary = {\n  operationFolderPath: string;\n  operationName: string;\n  classification: OperationClassification | undefined;\n  description: string | undefined;\n  size: FolderSummary | undefined;\n  coreDependenciesString: string;\n  operationDependenciesString: string;\n  packageDependenciesString: string;\n  cliItems: StatementItem[];\n  testItems: StatementItem[];\n  internalItems: StatementItem[];\n  externalItems: StatementItem[];\n  docs: { relativePath: string; content: string }[] | undefined;\n};"
  },
  "Sayable": {
    "name": "Sayable",
    "slug": "TsInterface",
    "id": "sayable",
    "description": "GOAL:\n- distribute read only (and audio only) material of my codebase\n- it is also a fundament for other applications in the future",
    "operationName": "markdown-parsings",
    "rawText": "/**\nGOAL:\n- distribute read only (and audio only) material of my codebase\n- it is also a fundament for other applications in the future\n */\n\nexport type Sayable = {\n  sayableText?: string;\n  voiceFileRelativePath?: string;\n};"
  },
  "SimplifiedSchemaProperty": {
    "name": "SimplifiedSchemaProperty",
    "slug": "TsInterface",
    "id": "simplifiedschemaproperty",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport type SimplifiedSchemaProperty = {\n  name: string;\n  schema: SimplifiedSchema;\n  /** NB: can't we put this in the SimplifiedSchema itself? */\n  required: boolean;\n};"
  },
  "StatementItem": {
    "name": "StatementItem",
    "slug": "TsInterface",
    "id": "statementitem",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": "\n\nexport type StatementItem = {\n  tsFunction?: TsFunction;\n  tsInterface?: TsInterface;\n  tsVariable?: TsVariable;\n};"
  },
  "TsFunction": {
    "name": "TsFunction",
    "slug": "TsInterface",
    "id": "tsfunction",
    "description": "\nInterface for arrow functions and normal functions",
    "operationName": "function-util"
  },
  "TsImport": {
    "name": "TsImport",
    "slug": "TsInterface",
    "id": "tsimport",
    "description": "",
    "operationName": "cleanup-typescript-database"
  },
  "TsVariable": {
    "name": "TsVariable",
    "slug": "TsInterface",
    "id": "tsvariable",
    "description": "",
    "operationName": "generate-index"
  },
  "NamedParameters<typeof findCodespans>": {
    "name": "NamedParameters<typeof findCodespans>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findcodespans",
    "description": "",
    "operationName": "marked-util"
  },
  "NamedParameters<typeof findEmbeds>": {
    "name": "NamedParameters<typeof findEmbeds>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findembeds",
    "description": "",
    "operationName": "marked-util"
  },
  "NamedParameters<typeof findEmbedsTest>": {
    "name": "NamedParameters<typeof findEmbedsTest>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findembedstest",
    "description": "",
    "operationName": "marked-util"
  },
  "NamedParameters<typeof findLinks>": {
    "name": "NamedParameters<typeof findLinks>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findlinks",
    "description": "",
    "operationName": "marked-util"
  },
  "NamedParameters<typeof findAudioWithViewsArray>": {
    "name": "NamedParameters<typeof findAudioWithViewsArray>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findaudiowithviewsarray",
    "description": "",
    "operationName": "short-markdown-parser-js"
  },
  "NamedParameters<typeof markdownParseToShortMarkdown>": {
    "name": "NamedParameters<typeof markdownParseToShortMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownparsetoshortmarkdown",
    "description": "",
    "operationName": "short-markdown-parser-js"
  },
  "NamedParameters<typeof shortMarkdownToMarkdownParse>": {
    "name": "NamedParameters<typeof shortMarkdownToMarkdownParse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-shortmarkdowntomarkdownparse",
    "description": "",
    "operationName": "short-markdown-parser-js"
  },
  "AudioWithViews": {
    "name": "AudioWithViews",
    "slug": "TsInterface",
    "id": "audiowithviews",
    "description": "",
    "operationName": "short-markdown-types",
    "rawText": "export type AudioWithViews = {\n  audioPath: string | null;\n  /**\n   * Unique key for the audio\n   */\n  audioKey?: string;\n  audioDurationMs?: number;\n  viewEmbeds: ViewEmbed[];\n};"
  },
  "DialogueSentence": {
    "name": "DialogueSentence",
    "slug": "TsInterface",
    "id": "dialoguesentence",
    "description": "",
    "operationName": "short-markdown-parser-node",
    "rawText": "export type DialogueSentence = {\n  remotePath?: string;\n  uuid?: string;\n  voice?: string;\n  sentence: string;\n};"
  },
  "NamedParameters<typeof augmentShortMarkdown>": {
    "name": "NamedParameters<typeof augmentShortMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-augmentshortmarkdown",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "NamedParameters<typeof fetchVoices>": {
    "name": "NamedParameters<typeof fetchVoices>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fetchvoices",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "NamedParameters<typeof fetchVoicesTest>": {
    "name": "NamedParameters<typeof fetchVoicesTest>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fetchvoicestest",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "NamedParameters<typeof generateAugmentedShortMarkdown>": {
    "name": "NamedParameters<typeof generateAugmentedShortMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateaugmentedshortmarkdown",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "NamedParameters<typeof generateAugmentedShortMarkdownTest>": {
    "name": "NamedParameters<typeof generateAugmentedShortMarkdownTest>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateaugmentedshortmarkdowntest",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "NamedParameters<typeof getOrGenerateShortMarkdown>": {
    "name": "NamedParameters<typeof getOrGenerateShortMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getorgenerateshortmarkdown",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "NamedParameters<typeof parseDialogue>": {
    "name": "NamedParameters<typeof parseDialogue>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parsedialogue",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "NamedParameters<typeof uberduckGetPath>": {
    "name": "NamedParameters<typeof uberduckGetPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-uberduckgetpath",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "NamedParameters<typeof uberduckSpeak>": {
    "name": "NamedParameters<typeof uberduckSpeak>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-uberduckspeak",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "NamedParameters<typeof voiceCloneDialogue>": {
    "name": "NamedParameters<typeof voiceCloneDialogue>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-voiceclonedialogue",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "ShortMarkdown": {
    "name": "ShortMarkdown",
    "slug": "TsInterface",
    "id": "shortmarkdown",
    "description": "",
    "operationName": "short-markdown-writer-input"
  },
  "AudioTrackItem": {
    "name": "AudioTrackItem",
    "slug": "TsInterface",
    "id": "audiotrackitem",
    "description": "",
    "operationName": "short-markdown-types",
    "rawText": "\n\n/**\n *\n */\nexport type AudioTrackItem = {\n  relativeAudioFilePath: string;\n  durationMs?: number;\n  startMs?: number;\n};"
  },
  "ViewEmbed": {
    "name": "ViewEmbed",
    "slug": "TsInterface",
    "id": "viewembed",
    "description": "",
    "operationName": "short-markdown-types",
    "rawText": "\n\nexport type ViewEmbed = {\n  /**\n   * Unique key for the belonging audio, used to find the desired audio\n   */\n  audioKey?: string;\n  /**\n   * Either viewPath or title is required\n   */\n  title?: string;\n  /**\n   * Either viewPath or title is required\n   */\n  viewPath?: string;\n\n  /**\n   * Text in the alt of the image or video, but only if the alt is wrapped in quotes (e.g. \"your spoken text\"). Can be parsed into an audio and subtitles, and also a duration.\n   */\n  spokenText?: string;\n  /**\n   * Added afterwards\n   */\n  durationMs?: number;\n};"
  },
  "NamedParameters<typeof parsePrimitive>": {
    "name": "NamedParameters<typeof parsePrimitive>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parseprimitive",
    "description": "",
    "operationName": "parse-primitive"
  },
  "NamedParameters<typeof parsePrimitiveArray>": {
    "name": "NamedParameters<typeof parsePrimitiveArray>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parseprimitivearray",
    "description": "",
    "operationName": "parse-primitive"
  },
  "NamedParameters<typeof parsePrimitiveBoolean>": {
    "name": "NamedParameters<typeof parsePrimitiveBoolean>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parseprimitiveboolean",
    "description": "",
    "operationName": "parse-primitive"
  },
  "NamedParameters<typeof parsePrimitiveString>": {
    "name": "NamedParameters<typeof parsePrimitiveString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parseprimitivestring",
    "description": "",
    "operationName": "parse-primitive"
  },
  "PrimitiveResult": {
    "name": "PrimitiveResult",
    "slug": "TsInterface",
    "id": "primitiveresult",
    "description": "",
    "operationName": "parse-primitive",
    "rawText": "\n\nexport type PrimitiveResult =\n  | boolean\n  | null\n  | undefined\n  | number\n  | string\n  | string[];"
  },
  "NamedParameters<typeof readCsvFile>": {
    "name": "NamedParameters<typeof readCsvFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readcsvfile",
    "description": "",
    "operationName": "read-csv-file"
  },
  "NamedParameters<typeof readCsvFileSync>": {
    "name": "NamedParameters<typeof readCsvFileSync>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readcsvfilesync",
    "description": "",
    "operationName": "read-csv-file"
  },
  "NamedParameters<typeof readJsonFile>": {
    "name": "NamedParameters<typeof readJsonFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readjsonfile",
    "description": "",
    "operationName": "read-json-file"
  },
  "NamedParameters<typeof readJsonFileSync>": {
    "name": "NamedParameters<typeof readJsonFileSync>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readjsonfilesync",
    "description": "",
    "operationName": "read-json-file"
  },
  "NamedParameters<typeof readProjectRelativeJsonFile>": {
    "name": "NamedParameters<typeof readProjectRelativeJsonFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readprojectrelativejsonfile",
    "description": "",
    "operationName": "read-json-file"
  },
  "NamedParameters<typeof readKvmdFile>": {
    "name": "NamedParameters<typeof readKvmdFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readkvmdfile",
    "description": "",
    "operationName": "read-kvmd-file"
  },
  "NamedParameters<typeof test2>": {
    "name": "NamedParameters<typeof test2>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-test2",
    "description": "",
    "operationName": "find-all-dependency-operations"
  },
  "MarkdownCallToAction": {
    "name": "MarkdownCallToAction",
    "slug": "TsInterface",
    "id": "markdowncalltoaction",
    "description": "",
    "operationName": "markdown-types",
    "rawText": "\n\nexport interface MarkdownCallToAction extends SlugModelType {\n  /**\n   * DESCRIPTION: Absolute queryPath to the CTA. Leave empty for going to the homepage. Empty paths will be omitted on the domains where you are already on that domain... If there's a path, will be omitted on other domains (`MarkdownCallToAction`s with a different hostname)\n   */\n  path?: string;\n  /**\n   * DESCRIPTION: Hostname as described in `https://www.w3schools.com/js/js_window_location.asp`.\n   */\n  hostname: string;\n\n  title?: string;\n\n  /**\n   * Will be shown in markdown\n   */\n  description?: string;\n\n  /**\n   * Can have a default if not provided\n   */\n  ctaButtonText?: string;\n  /**\n   * if true, CTA will only be placed in footer\n   */\n  onlyFooter?: boolean;\n  onlyHeader?: boolean;\n  /**\n   * If true, will be rendered in a <details>, if possible.\n   */\n  isMinimised?: boolean;\n  bannerImage?: BackendAsset;\n}"
  },
  "NamedParameters<typeof readMarkdownFile>": {
    "name": "NamedParameters<typeof readMarkdownFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readmarkdownfile",
    "description": "",
    "operationName": "read-markdown-file"
  },
  "NamedParameters<typeof readMarkdownFileToModel>": {
    "name": "NamedParameters<typeof readMarkdownFileToModel>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readmarkdownfiletomodel",
    "description": "",
    "operationName": "read-markdown-file"
  },
  "CommentType": {
    "name": "CommentType",
    "slug": "TsInterface",
    "id": "commenttype",
    "description": "special line prefixes:\n\n**Developer related comments**\n\n- TODO: for developer to know what to do\n- DISCUSSION: for developer to state that discussion is needed\n- IDEA: for developer to state ideas\n- LATER: for developer to mark as thing that needs to be done later\n- NB: for developer to add a note\n\n**Form related comments**\n\n- TITLE: if available, will be used as title of form input (overwrites humanCase version of the property-name itself in that case)\n- SECTION: start a new section in the form from this point, the value behind here can be the title\n- DESCRIPTION: if available, will be used as description of the form input",
    "operationName": "code-types",
    "rawText": "\n\n/**\n * special line prefixes:\n *\n * **Developer related comments**\n *\n * - TODO: for developer to know what to do\n * - DISCUSSION: for developer to state that discussion is needed\n * - IDEA: for developer to state ideas\n * - LATER: for developer to mark as thing that needs to be done later\n * - NB: for developer to add a note\n *\n * **Form related comments**\n *\n * - TITLE: if available, will be used as title of form input (overwrites humanCase version of the property-name itself in that case)\n * - SECTION: start a new section in the form from this point, the value behind here can be the title\n * - DESCRIPTION: if available, will be used as description of the form input\n *\n */\nexport type CommentType = typeof commentTypesConst[number];"
  },
  "IndexFilter": {
    "name": "IndexFilter",
    "slug": "TsInterface",
    "id": "indexfilter",
    "description": "",
    "operationName": "read-typescript-file",
    "rawText": "\n\nexport type IndexFilter = {\n  /**\n   * if set, only returns comments containing specific types\n   */\n  hasCommentTypes?: CommentType[];\n  /**\n   * if true, only returns interfaces which are db models\n   */\n  interfaceIsDbModel?: boolean;\n};"
  },
  "NamedParameters<typeof getFolderTypescriptIndex>": {
    "name": "NamedParameters<typeof getFolderTypescriptIndex>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfoldertypescriptindex",
    "description": "",
    "operationName": "read-typescript-file"
  },
  "NamedParameters<typeof getOperationIndexModel>": {
    "name": "NamedParameters<typeof getOperationIndexModel>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationindexmodel",
    "description": "",
    "operationName": "read-typescript-file"
  },
  "NamedParameters<typeof readTypescriptFile>": {
    "name": "NamedParameters<typeof readTypescriptFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readtypescriptfile",
    "description": "",
    "operationName": "read-typescript-file"
  },
  "NamedParameters<typeof uniqueNames>": {
    "name": "NamedParameters<typeof uniqueNames>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-uniquenames",
    "description": "",
    "operationName": "read-typescript-file"
  },
  "NamedParameters<typeof tryParseJson>": {
    "name": "NamedParameters<typeof tryParseJson>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tryparsejson",
    "description": "",
    "operationName": "try-parse-json"
  },
  "NamedParameters<typeof bodyFromQueryString>": {
    "name": "NamedParameters<typeof bodyFromQueryString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-bodyfromquerystring",
    "description": "",
    "operationName": "rest-util"
  },
  "NamedParameters<typeof getFirstQueryStrings>": {
    "name": "NamedParameters<typeof getFirstQueryStrings>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfirstquerystrings",
    "description": "",
    "operationName": "rest-util"
  },
  "NamedParameters<typeof getQueryPart>": {
    "name": "NamedParameters<typeof getQueryPart>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getquerypart",
    "description": "",
    "operationName": "rest-util"
  },
  "NamedParameters<typeof isValidEntry>": {
    "name": "NamedParameters<typeof isValidEntry>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isvalidentry",
    "description": "",
    "operationName": "rest-util"
  },
  "NamedParameters<typeof toQueryString>": {
    "name": "NamedParameters<typeof toQueryString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-toquerystring",
    "description": "",
    "operationName": "rest-util"
  },
  "QueryableObject": {
    "name": "QueryableObject",
    "slug": "TsInterface",
    "id": "queryableobject",
    "description": "",
    "operationName": "rest-util",
    "rawText": "export type QueryableObject = { [key: string]: string | string[] | undefined };"
  },
  "CsvModelType": {
    "name": "CsvModelType",
    "slug": "TsInterface",
    "id": "csvmodeltype",
    "description": "Use this model for things you want to store in CSV format\n\nTODO: add support for numbers, booleans, null, undefined",
    "operationName": "os-types"
  },
  "CsvTestModel": {
    "name": "CsvTestModel",
    "slug": "TsInterface",
    "id": "csvtestmodel",
    "description": "",
    "operationName": "database",
    "rawText": "\n\nexport interface CsvTestModel extends CsvModelType {\n  name: string;\n  description: string;\n  age: number;\n}"
  },
  "DefaultTestModel": {
    "name": "DefaultTestModel",
    "slug": "TsInterface",
    "id": "defaulttestmodel",
    "description": "",
    "operationName": "database",
    "rawText": "\n\nexport interface DefaultTestModel extends DefaultModelType {\n  id: string;\n  name: string;\n  description: string;\n  markdown: string;\n  special: boolean;\n}"
  },
  "KvmdTestModel": {
    "name": "KvmdTestModel",
    "slug": "TsInterface",
    "id": "kvmdtestmodel",
    "description": "",
    "operationName": "database",
    "rawText": "\n\nexport interface KvmdTestModel extends KeyValueMarkdownModelType {}"
  },
  "MarkdownTestModel": {
    "name": "MarkdownTestModel",
    "slug": "TsInterface",
    "id": "markdowntestmodel",
    "description": "",
    "operationName": "database",
    "rawText": "\n\nexport interface MarkdownTestModel extends MarkdownModelType {\n  stringA: string;\n  stringB: string;\n  stringC: string;\n  age: number;\n  yes: boolean;\n  canBeNull: string | null;\n  canBeUndefined?: string;\n}"
  },
  "NamedParameters<typeof generateCsvInstance>": {
    "name": "NamedParameters<typeof generateCsvInstance>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatecsvinstance",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof generateJsonSingleInstance>": {
    "name": "NamedParameters<typeof generateJsonSingleInstance>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatejsonsingleinstance",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof generateKvmdInstance>": {
    "name": "NamedParameters<typeof generateKvmdInstance>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatekvmdinstance",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof generateMarkdownInstance>": {
    "name": "NamedParameters<typeof generateMarkdownInstance>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatemarkdowninstance",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof generateSlugTestModel>": {
    "name": "NamedParameters<typeof generateSlugTestModel>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateslugtestmodel",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof get>": {
    "name": "NamedParameters<typeof get>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-get",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof getCli>": {
    "name": "NamedParameters<typeof getCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcli",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof getRanomAge>": {
    "name": "NamedParameters<typeof getRanomAge>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getranomage",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof migration>": {
    "name": "NamedParameters<typeof migration>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-migration",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof randomName>": {
    "name": "NamedParameters<typeof randomName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-randomname",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof removeCli>": {
    "name": "NamedParameters<typeof removeCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removecli",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof set>": {
    "name": "NamedParameters<typeof set>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-set",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof testOperationModels>": {
    "name": "NamedParameters<typeof testOperationModels>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-testoperationmodels",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof testPerformance>": {
    "name": "NamedParameters<typeof testPerformance>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-testperformance",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof updateCli>": {
    "name": "NamedParameters<typeof updateCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-updatecli",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof upsert>": {
    "name": "NamedParameters<typeof upsert>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-upsert",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof upsertCli>": {
    "name": "NamedParameters<typeof upsertCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-upsertcli",
    "description": "",
    "operationName": "database"
  },
  "SlugTestModel": {
    "name": "SlugTestModel",
    "slug": "TsInterface",
    "id": "slugtestmodel",
    "description": "",
    "operationName": "database",
    "rawText": "\n\nexport interface SlugTestModel extends SlugModelType {\n  id: string;\n  name: string;\n  slug: string;\n  description: string;\n  markdown: string;\n  special: boolean;\n}"
  },
  "TestModels": {
    "name": "TestModels",
    "slug": "TsInterface",
    "id": "testmodels",
    "description": "",
    "operationName": "database",
    "rawText": "\n\nexport type TestModels = {\n  CsvTestModel: CsvTestModel;\n  KeyValueMarkdownTestModel: KvmdTestModel;\n  MarkdownTestModel: MarkdownTestModel;\n  JsonMultipleTestModel: SlugTestModel;\n  DefaultTestModel: DefaultTestModel;\n  // real models\n  TsConfig: TsConfig;\n};"
  },
  "CacheLookupResult": {
    "name": "CacheLookupResult",
    "slug": "TsInterface",
    "id": "cachelookupresult",
    "description": "",
    "operationName": "db-recipes",
    "rawText": "export type CacheLookupResult = {\n  hasValidCache: boolean;\n  result?: any;\n};"
  },
  "NamedParameters<typeof cacheLookup>": {
    "name": "NamedParameters<typeof cacheLookup>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-cachelookup",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof calculateOperatingSystemBundle>": {
    "name": "NamedParameters<typeof calculateOperatingSystemBundle>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-calculateoperatingsystembundle",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof getCachedFunctions>": {
    "name": "NamedParameters<typeof getCachedFunctions>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcachedfunctions",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof getDatabaseMenu>": {
    "name": "NamedParameters<typeof getDatabaseMenu>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdatabasemenu",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof getDbModelMetadata>": {
    "name": "NamedParameters<typeof getDbModelMetadata>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdbmodelmetadata",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof getDbModelNames>": {
    "name": "NamedParameters<typeof getDbModelNames>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdbmodelnames",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof getFunctionIndex>": {
    "name": "NamedParameters<typeof getFunctionIndex>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfunctionindex",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof getNestedDatabaseMenu>": {
    "name": "NamedParameters<typeof getNestedDatabaseMenu>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getnesteddatabasemenu",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof hasDbRecipes>": {
    "name": "NamedParameters<typeof hasDbRecipes>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-hasdbrecipes",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof makeSrcRelativeFolder>": {
    "name": "NamedParameters<typeof makeSrcRelativeFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-makesrcrelativefolder",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof tsInterfaceToDbMenu>": {
    "name": "NamedParameters<typeof tsInterfaceToDbMenu>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tsinterfacetodbmenu",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof DbLayout>": {
    "name": "NamedParameters<typeof DbLayout>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-dblayout",
    "description": "",
    "operationName": "db-web"
  },
  "AnyModelObject": {
    "name": "AnyModelObject",
    "slug": "TsInterface",
    "id": "anymodelobject",
    "description": "",
    "operationName": "fs-orm",
    "rawText": "\n\nexport type AnyModelObject = {\n  [modelName: string]: AugmentedAnyModelType;\n};"
  },
  "AnyModelType": {
    "name": "AnyModelType",
    "slug": "TsInterface",
    "id": "anymodeltype",
    "description": "Parameters that every model will always have.\n\nNB: TimeTypes (createdAt, updatedAt, etc.) are not always included because the kvmd-model doesn't have them.\n\nNB: RelationTypes are also not always included for the same reason",
    "operationName": "migrate-operation-model"
  },
  "CustomQueryConfig": {
    "name": "CustomQueryConfig",
    "slug": "TsInterface",
    "id": "customqueryconfig",
    "description": "NB: the dbStorageMethod cannot be specified here because this is a static configuration per db-model and cannot be specified on a per-query basis.\n\nAlso you can't specify projectRelativePath and operationRelativePath. It should not be needed, you should specify the db storage locations in the createDb config.",
    "operationName": "fs-orm",
    "rawText": "\n\n/**\n * NB: the dbStorageMethod cannot be specified here because this is a static configuration per db-model and cannot be specified on a per-query basis.\n *\n * Also you can't specify projectRelativePath and operationRelativePath. It should not be needed, you should specify the db storage locations in the createDb config.\n */\nexport type CustomQueryConfig = {\n  /**\n   * if specified, this will be used as the root path to find your data in\n   *\n   * if not specified, uses the db folder in your project root and in any operation\n   *\n   * NB: If you set this, the model interfaces of your current project are applied on another project! Make sure they are the same there before you run such queries.\n   */\n  manualProjectRoot?: string;\n\n  /*\n   - if not specified or specified as `undefined` or `null`, only the root db folder will be searched\n   - if an operation is specified, only that operation will be searched\n   - if `*` is specified, all operations will be searched as well as the root db. This is discouraged, as it's quite slow\n   */\n  operationName?: string | null;\n};"
  },
  "DbQueryResult": {
    "name": "DbQueryResult",
    "slug": "TsInterface",
    "id": "dbqueryresult",
    "description": "TODO: return the inserted id or other reference\n\nResult of any query except `get`. Will not always provide all parameters (depends on the type of query you do)",
    "operationName": "fs-orm",
    "rawText": "\n\n/**\n * TODO: return the inserted id or other reference\n *\n * Result of any query except `get`. Will not always provide all parameters (depends on the type of query you do)\n */\nexport type DbQueryResult = {\n  isSuccesful?: boolean;\n  message?: string;\n  isNewFile?: boolean;\n  amountInserted?: number;\n  amountUpdated?: number;\n  amountRemoved?: number;\n  /**\n   * If true, all items in the model were removed\n   */\n  allRemoved?: boolean;\n};"
  },
  "DbStorageMethod": {
    "name": "DbStorageMethod",
    "slug": "TsInterface",
    "id": "dbstoragemethod",
    "description": "The following strategies are available to store the data.\n\n- **jsonMultiple *(default)***: stores the data in a json file which is an array of this data structure. This file will be located in `db/[pluralized-kebab-case-model-name].json`\n\n- **jsonSingle**: stores the data in a json file which is of this data structure (single object) These files will be located in `db/[pluralized-kebab-case-model-name]/[instance-slug-or-id].json`\n\n- **markdown**: stores the data in a markdown file. Takes \"markdown\" parameter as the main markdown. The other parameters are stored as front-matter. This these files will be located in `db/[pluralized-kebab-case-model-name]/[instance-slug-or-id].md`\n\n- **keyValueMarkdown**: stores the data in key value markdown format. This file will be located in `db/[pluralized-kebab-case-model-name].md`\n\n- **csv**: stores the data in a csv file (only possible for flat object datastructures). This file will be located in `db/[pluralized-kebab-case-model-name].csv`\n\n## Definitions:\n\n- [pluralized-kebab-case-model-name]: e.g. `StudentUser` becomes `student-users`\n- [instance-slug-or-id]: For all models with a slug parameter, the filename will be that slug of that instance. Otherwise, `id` will be used",
    "operationName": "code-types",
    "rawText": "\n\n/** \n \n The following strategies are available to store the data.\n\n - **jsonMultiple *(default)***: stores the data in a json file which is an array of this data structure. This file will be located in `db/[pluralized-kebab-case-model-name].json`\n\n - **jsonSingle**: stores the data in a json file which is of this data structure (single object) These files will be located in `db/[pluralized-kebab-case-model-name]/[instance-slug-or-id].json`\n\n - **markdown**: stores the data in a markdown file. Takes \"markdown\" parameter as the main markdown. The other parameters are stored as front-matter. This these files will be located in `db/[pluralized-kebab-case-model-name]/[instance-slug-or-id].md`\n\n - **keyValueMarkdown**: stores the data in key value markdown format. This file will be located in `db/[pluralized-kebab-case-model-name].md`\n\n - **csv**: stores the data in a csv file (only possible for flat object datastructures). This file will be located in `db/[pluralized-kebab-case-model-name].csv`\n\n ## Definitions:\n\n- [pluralized-kebab-case-model-name]: e.g. `StudentUser` becomes `student-users`\n- [instance-slug-or-id]: For all models with a slug parameter, the filename will be that slug of that instance. Otherwise, `id` will be used\n */\nexport type DbStorageMethod = typeof dbStorageMethodsConst[number];"
  },
  "IncludeConfig": {
    "name": "IncludeConfig",
    "slug": "TsInterface",
    "id": "includeconfig",
    "description": "All possible ways to include items from references into a get query",
    "operationName": "fs-orm",
    "rawText": "\n\n/**\n * All possible ways to include items from references into a get query\n */\nexport type IncludeConfig =\n  | (Include & {\n      /**\n       * NOT SUPPORTED YET\n       *\n       * If this is set to true, regular include will be ignored. More depth is not possible.\n       *\n       * You can simply specify `auto: true`. This is the easiest way to include. This will fetch all references in the model for every item in an as efficient way as possible, but only with a depth of 1.\n       *\n       * Assumptions:\n       *\n       * 1) The first item in the db contains all reference-keys that need to be filled. Keys not present in the first item will not be filled\n       *\n       */\n      auto?: boolean;\n    })\n  | Include[];"
  },
  "IncludeDataObject": {
    "name": "IncludeDataObject",
    "slug": "TsInterface",
    "id": "includedataobject",
    "description": "",
    "operationName": "fs-orm",
    "rawText": "\n\nexport type IncludeDataObject = {\n  [modelName: string]: AugmentedAnyModelType[];\n};"
  },
  "Include": {
    "name": "Include",
    "slug": "TsInterface",
    "id": "include",
    "description": "",
    "operationName": "fs-orm",
    "rawText": "\n\nexport type Include = {\n  /**\n   * The key that contains a reference. The name of this key should follow the convention, e.g. `xxxSlug`. If this is given, `xxx` will be filled with the item of the referenced model.\n   */\n  referenceKey?: string;\n  /**\n   * If provided, the items will be filled from this array. If not provided, the required model will first be fetched using get. It is often more efficient to provide it yourself if you have already fetched it anyway. Nonetheless, `fs-orm` will try and reuse the fetched data to minimize amount of reads to the file system.\n   */\n  items?: AugmentedAnyModelType[];\n  /**\n   * Optionally, you can provide another include config for this model\n   */\n  include?: Include | Include[];\n};"
  },
  "MergedQueryConfig": {
    "name": "MergedQueryConfig",
    "slug": "TsInterface",
    "id": "mergedqueryconfig",
    "description": "",
    "operationName": "fs-orm",
    "rawText": "\n\nexport type MergedQueryConfig = QueryConfig & {\n  dbStorageMethod: DbStorageMethod;\n  /**\n   * manual projectroot, should only be set if it's different from the projectRoot.\n   */\n  manualProjectRoot: string;\n  /**\n   * Hardcoded projectroot. Motivation for this is to be able to see if the projectroot is really manual.\n   */\n  projectRoot: string;\n};"
  },
  "ModelLocation": {
    "name": "ModelLocation",
    "slug": "TsInterface",
    "id": "modellocation",
    "description": "Parameters that tell you about the location an instance of a model.\nModels can be tied to an operation. They always have a `projectRelativePath`, and if they are tied to an operation, also an `operationRelativePath`.",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * Parameters that tell you about the location an instance of a model.\n * Models can be tied to an operation. They always have a `projectRelativePath`, and if they are tied to an operation, also an `operationRelativePath`.\n */\nexport interface ModelLocation {\n  /**\n   * name of operation the model belongs to\n   *\n   * - calculated value (not stored in database)\n   * - can be `null` or an actual operationName that it was saved at\n   * - can be `undefined` when you are creating an item, because then it can be set for you\n   */\n  operationName: null | string;\n  /**\n   * path to dbfile\n   *\n   * - calculated value (not stored in database)\n   * - relatively from the project (without slash at start)\n   * - can be `undefined` when you are creating an item, because then it can be set for you\n   */\n  projectRelativePath: string;\n  /**\n   * path to db file\n   *\n   * - relatively from the operation root folder (without slash at start)\n   * - calculated value (not stored in database)\n   * - can be `undefined` if the db file does not belong to an operation\n   * - can be `undefined` when you are creating an item, because then it can be set for you\n   */\n  operationRelativePath?: string;\n}"
  },
  "NamedParameters<typeof augmentItemWithReferencedDataRecursively>": {
    "name": "NamedParameters<typeof augmentItemWithReferencedDataRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-augmentitemwithreferenceddatarecursively",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof findParent>": {
    "name": "NamedParameters<typeof findParent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findparent",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getAugmentedData>": {
    "name": "NamedParameters<typeof getAugmentedData>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getaugmenteddata",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getDatabaseFiles>": {
    "name": "NamedParameters<typeof getDatabaseFiles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdatabasefiles",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getDatabaseRootFolder>": {
    "name": "NamedParameters<typeof getDatabaseRootFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdatabaserootfolder",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getDbFileLocation>": {
    "name": "NamedParameters<typeof getDbFileLocation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdbfilelocation",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getDbStorageMethodExtension>": {
    "name": "NamedParameters<typeof getDbStorageMethodExtension>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdbstoragemethodextension",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getLocationPattern>": {
    "name": "NamedParameters<typeof getLocationPattern>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getlocationpattern",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getParentSlug>": {
    "name": "NamedParameters<typeof getParentSlug>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getparentslug",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getWildcardDbFileLocations__OLD>": {
    "name": "NamedParameters<typeof getWildcardDbFileLocations__OLD>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getwildcarddbfilelocations-old",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getWildcardDbFileLocations>": {
    "name": "NamedParameters<typeof getWildcardDbFileLocations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getwildcarddbfilelocations",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof removeKeyValueMarkdown>": {
    "name": "NamedParameters<typeof removeKeyValueMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removekeyvaluemarkdown",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof upsertKeyValueMarkdown>": {
    "name": "NamedParameters<typeof upsertKeyValueMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-upsertkeyvaluemarkdown",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof addDefaultValues>": {
    "name": "NamedParameters<typeof addDefaultValues>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-adddefaultvalues",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof calculateOperationsObject>": {
    "name": "NamedParameters<typeof calculateOperationsObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-calculateoperationsobject",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof createDb>": {
    "name": "NamedParameters<typeof createDb>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-createdb",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getDefaultLocationPattern>": {
    "name": "NamedParameters<typeof getDefaultLocationPattern>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdefaultlocationpattern",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getMergedConfigOperationPath>": {
    "name": "NamedParameters<typeof getMergedConfigOperationPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmergedconfigoperationpath",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getRootFolders>": {
    "name": "NamedParameters<typeof getRootFolders>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getrootfolders",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof waitForLockfile>": {
    "name": "NamedParameters<typeof waitForLockfile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-waitforlockfile",
    "description": "",
    "operationName": "fs-orm"
  },
  "QueryConfig": {
    "name": "QueryConfig",
    "slug": "TsInterface",
    "id": "queryconfig",
    "description": "QueryConfig is set on 4 levels, which have increasing priority\n\n- hardcoded in `fs-orm`\n- when calling `createDb`, setting `defaultQueryConfig`\n- when calling `createDb`, setting `modelQueryConfig`\n- when running a query\n\nNot all options are available when running a query.",
    "operationName": "fs-orm",
    "rawText": "\n/**\n * QueryConfig is set on 4 levels, which have increasing priority\n *\n * - hardcoded in `fs-orm`\n * - when calling `createDb`, setting `defaultQueryConfig`\n * - when calling `createDb`, setting `modelQueryConfig`\n * - when running a query\n *\n * Not all options are available when running a query.\n */\nexport interface QueryConfig extends CustomQueryConfig {\n  /**\n   * When setting this, make sure your models are able to use this storage method, this is not always possible!\n   *\n   * defaults to jsonMultiple\n   */\n  dbStorageMethod?: DbStorageMethod;\n\n  /**\n   * if specified, only this location will be used (also need an `operationName`)\n   */\n  operationRelativePath?: string;\n  /**\n   * if specified, only this location will be used\n   */\n  projectRelativePath?: string;\n}"
  },
  "RootDbFolder": {
    "name": "RootDbFolder",
    "slug": "TsInterface",
    "id": "rootdbfolder",
    "description": "",
    "operationName": "fs-orm",
    "rawText": "\n\nexport type RootDbFolder = {\n  /** is an operation Base path in case of operationName is not null */\n  basePath: string;\n  operationName: string | null;\n};"
  },
  "UpsertKeyValueMarkdownItem": {
    "name": "UpsertKeyValueMarkdownItem",
    "slug": "TsInterface",
    "id": "upsertkeyvaluemarkdownitem",
    "description": "",
    "operationName": "fs-orm",
    "rawText": "\n\nexport type UpsertKeyValueMarkdownItem = {\n  parameters: Frontmatter | null;\n  item: KeyValueMarkdownModelType;\n};"
  },
  "UpsertQueryConfig": {
    "name": "UpsertQueryConfig",
    "slug": "TsInterface",
    "id": "upsertqueryconfig",
    "description": "",
    "operationName": "fs-orm",
    "rawText": "\n\nexport type UpsertQueryConfig = CustomQueryConfig & {\n  /**\n   * Special config for upsert. If you set this to true, all items in the databasefiles that were altered that you didn't specify in the items, will be removed.\n   */\n  removeUntouched?: boolean;\n  /**\n   * If true, the query will fail if the slug or id already exists (normally this means upsert will update that value)\n   *\n   * NB: not supported for keyValueMarkdown\n   */\n  onlyInsert?: boolean;\n};"
  },
  "NamedParameters<typeof validate>": {
    "name": "NamedParameters<typeof validate>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-validate",
    "description": "",
    "operationName": "validate-model"
  },
  "NamedParameters<typeof validateModel>": {
    "name": "NamedParameters<typeof validateModel>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-validatemodel",
    "description": "",
    "operationName": "validate-model"
  },
  "NamedParameters<typeof getFunctionExecutions>": {
    "name": "NamedParameters<typeof getFunctionExecutions>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfunctionexecutions",
    "description": "",
    "operationName": "function-functions-node"
  },
  "NamedParameters<typeof getFunctionQueryPaths>": {
    "name": "NamedParameters<typeof getFunctionQueryPaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfunctionquerypaths",
    "description": "",
    "operationName": "function-functions-node"
  },
  "NamedParameters<typeof getPublicBundleConfig>": {
    "name": "NamedParameters<typeof getPublicBundleConfig>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpublicbundleconfig",
    "description": "",
    "operationName": "function-functions-node"
  },
  "NamedParameters<typeof getSrcRelativeFolderPath>": {
    "name": "NamedParameters<typeof getSrcRelativeFolderPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsrcrelativefolderpath",
    "description": "",
    "operationName": "function-functions-node"
  },
  "NamedParameters<typeof getTsFunction>": {
    "name": "NamedParameters<typeof getTsFunction>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettsfunction",
    "description": "",
    "operationName": "function-server-endpoints"
  },
  "FunctionData": {
    "name": "FunctionData",
    "slug": "TsInterface",
    "id": "functiondata",
    "description": "",
    "operationName": "function-types",
    "rawText": "\nexport type FunctionData = {\n  tsFunction: TsFunction;\n};"
  },
  "PublicBundleConfig": {
    "name": "PublicBundleConfig",
    "slug": "TsInterface",
    "id": "publicbundleconfig",
    "description": "",
    "operationName": "reader-ui"
  },
  "FunctionExecution": {
    "name": "FunctionExecution",
    "slug": "TsInterface",
    "id": "functionexecution",
    "description": "Model for tests, examples, cache, and recent executions of any function\n\nRequirement for **tifo-stitching**\n\nExample:\n\nconst someFunction = (inputA: string, inputB:string):string => {\n\nreturn `${inputA} != ${inputB}`\n}\n\n\nfind this in the database after executing the function\n\nconst functionExecution1 = {\n....\nfunctionName: \"someFunction\",\ninputParameters: [\"hello\", \"world\"],\noutput: \"hello != world\",\nisTest: false,\nisExample: false,\nisResultFromCache: false,\nperformance: [....],\n}",
    "operationName": "code-types",
    "rawText": "\n\n/**\n * Model for tests, examples, cache, and recent executions of any function\n *\n * Requirement for **tifo-stitching**\n\nExample: \n\nconst someFunction = (inputA: string, inputB:string):string => {\n\n  return `${inputA} != ${inputB}`\n}\n\n\n// find this in the database after executing the function\n\nconst functionExecution1 = {\n  ....\n  functionName: \"someFunction\",\n  inputParameters: [\"hello\", \"world\"],\n  output: \"hello != world\",\n  isTest: false,\n  isExample: false,\n  isResultFromCache: false,\n  performance: [....],\n}\n\n*/\n\nexport interface FunctionExecution extends DefaultModelType {\n  functionName: string;\n  tsFunctionId: Id;\n  tsFunction?: TsFunction;\n  inputParameters: any[] | undefined;\n  output: any;\n  isTest: boolean;\n  isExample: boolean;\n  /**\n   * test description or example description or anything\n   */\n  description?: Markdown;\n  isResultFromCache: boolean;\n  /**\n   * if true, the api of the function (input/output interface) has changed in bewteen, so the re-execution would probably fail or return a different result\n   */\n  hasApiChanged?: boolean;\n  performance: PerformanceItem[];\n}"
  },
  "NamedParameters<typeof FormTab>": {
    "name": "NamedParameters<typeof FormTab>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-formtab",
    "description": "",
    "operationName": "function-web"
  },
  "NamedParameters<typeof FunctionExecutionTable>": {
    "name": "NamedParameters<typeof FunctionExecutionTable>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-functionexecutiontable",
    "description": "",
    "operationName": "function-web"
  },
  "NamedParameters<typeof FunctionPage>": {
    "name": "NamedParameters<typeof FunctionPage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-functionpage",
    "description": "",
    "operationName": "function-web"
  },
  "NamedParameters<typeof getAugmentedWordObject>": {
    "name": "NamedParameters<typeof getAugmentedWordObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getaugmentedwordobject",
    "description": "",
    "operationName": "augmented-word-node"
  },
  "NamedParameters<typeof getAugmentedWords>": {
    "name": "NamedParameters<typeof getAugmentedWords>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getaugmentedwords",
    "description": "",
    "operationName": "augmented-word-node"
  },
  "NamedParameters<typeof getBundleAugmentedWords>": {
    "name": "NamedParameters<typeof getBundleAugmentedWords>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getbundleaugmentedwords",
    "description": "",
    "operationName": "augmented-word-node"
  },
  "AugmentedWord": {
    "name": "AugmentedWord",
    "slug": "TsInterface",
    "id": "augmentedword",
    "description": "AugmentedWords should have a small footprint since there can be many of them\n\nWords with a specific affix (backticks, bolded, italic) will match against these.\n\nUsed to link automatically to functionNames, InterfaceNames, operation-names, words, and more..\n\nTODO: This is a much more general purpose thing than just `markdown-reader-types`. Move to it's own package",
    "operationName": "reader-ui"
  },
  "AugmentedWordObject": {
    "name": "AugmentedWordObject",
    "slug": "TsInterface",
    "id": "augmentedwordobject",
    "description": "This datastructure is probably needed to make it more efficient.\n\nShould be a lookup table for the querypath for every word",
    "operationName": "augmented-word-types",
    "rawText": "\n\n/**\n * This datastructure is probably needed to make it more efficient.\n *\n * Should be a lookup table for the querypath for every word\n */\nexport type AugmentedWordObject = {\n  [augmentedWord: string]: AugmentedWord;\n};"
  },
  "AugmentedWordTypeEnum": {
    "name": "AugmentedWordTypeEnum",
    "slug": "TsInterface",
    "id": "augmentedwordtypeenum",
    "description": "NB: can later be replaced with a string enum type: person, definition, variable, function, type interface, operation, bundle (but there may be much more)",
    "operationName": "augmented-word-types",
    "rawText": "// NB: can later be replaced with a string enum type: person, definition, variable, function, type interface, operation, bundle (but there may be much more)\nexport type AugmentedWordTypeEnum = string;"
  },
  "GetStaticPathsContext": {
    "name": "GetStaticPathsContext",
    "slug": "TsInterface",
    "id": "getstaticpathscontext",
    "description": "",
    "operationName": "next-types",
    "rawText": "\n\nexport type GetStaticPathsContext = {\n  locales?: string[];\n  defaultLocale?: string;\n};"
  },
  "NamedParameters<typeof codestoriesGetPages>": {
    "name": "NamedParameters<typeof codestoriesGetPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-codestoriesgetpages",
    "description": "",
    "operationName": "codestorys-node"
  },
  "NamedParameters<typeof codestoriesGetStaticPaths>": {
    "name": "NamedParameters<typeof codestoriesGetStaticPaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-codestoriesgetstaticpaths",
    "description": "",
    "operationName": "codestorys-node"
  },
  "NamedParameters<typeof codestoriesGetStaticProps>": {
    "name": "NamedParameters<typeof codestoriesGetStaticProps>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-codestoriesgetstaticprops",
    "description": "",
    "operationName": "codestorys-node"
  },
  "MarkdownReaderPageProps": {
    "name": "MarkdownReaderPageProps",
    "slug": "TsInterface",
    "id": "markdownreaderpageprops",
    "description": "",
    "operationName": "reader-ui"
  },
  "NamedParameters<typeof HomePage>": {
    "name": "NamedParameters<typeof HomePage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-homepage",
    "description": "",
    "operationName": "search-web"
  },
  "BundleMarkdownReaderConfig": {
    "name": "BundleMarkdownReaderConfig",
    "slug": "TsInterface",
    "id": "bundlemarkdownreaderconfig",
    "description": "",
    "operationName": "bundle-types",
    "rawText": "\n\nexport type BundleMarkdownReaderConfig = {\n  /**\n   * When set to `true`, docs are not shown in docs folder but in the root menu of the site\n   */\n  docsInRoot?: boolean;\n  /**\n   * Show todo menu\n   */\n  showTodos?: boolean;\n  /**\n   * `modules` will be hidden from markdown reader menu\n   */\n  omitModulesMenu?: boolean;\n  /**\n   * `apps` will be hidden from markdown reader menui\n   */\n  omitAppsMenu?: boolean;\n  /**\n   * if true, dictionary is omitted from menu\n   */\n  omitDictionaryMenu?: boolean;\n\n  /**\n   * `packages` will be hidden from markdown reader menu\n   */\n  omitPackagesMenu?: boolean;\n\n  /**\n   * if given, the operations menu will show with these operations\n   */\n  customOperationNames?: string[];\n};"
  },
  "NamedParameters<typeof copyStaticAssets>": {
    "name": "NamedParameters<typeof copyStaticAssets>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-copystaticassets",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof copyStaticAssetsCli>": {
    "name": "NamedParameters<typeof copyStaticAssetsCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-copystaticassetscli",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof docsGetPages>": {
    "name": "NamedParameters<typeof docsGetPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-docsgetpages",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof docsGetStaticPaths>": {
    "name": "NamedParameters<typeof docsGetStaticPaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-docsgetstaticpaths",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof docsGetStaticProps>": {
    "name": "NamedParameters<typeof docsGetStaticProps>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-docsgetstaticprops",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof getAllMarkdownReaderPages>": {
    "name": "NamedParameters<typeof getAllMarkdownReaderPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getallmarkdownreaderpages",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof getChildren>": {
    "name": "NamedParameters<typeof getChildren>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getchildren",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof getFolderExplorationInfo>": {
    "name": "NamedParameters<typeof getFolderExplorationInfo>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfolderexplorationinfo",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof getMarkdownModelPages>": {
    "name": "NamedParameters<typeof getMarkdownModelPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmarkdownmodelpages",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof getMarkdownPageInfo>": {
    "name": "NamedParameters<typeof getMarkdownPageInfo>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmarkdownpageinfo",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof getMarkdownReaderQueryPaths>": {
    "name": "NamedParameters<typeof getMarkdownReaderQueryPaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmarkdownreaderquerypaths",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof getOperationPages>": {
    "name": "NamedParameters<typeof getOperationPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationpages",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof getPublicMarkdownFilePaths>": {
    "name": "NamedParameters<typeof getPublicMarkdownFilePaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpublicmarkdownfilepaths",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof getReaderTodoPages>": {
    "name": "NamedParameters<typeof getReaderTodoPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getreadertodopages",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof markdownReaderGetStaticPaths>": {
    "name": "NamedParameters<typeof markdownReaderGetStaticPaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownreadergetstaticpaths",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof markdownReaderGetStaticProps>": {
    "name": "NamedParameters<typeof markdownReaderGetStaticProps>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownreadergetstaticprops",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof markdownReaderGetStaticPropsFromPages>": {
    "name": "NamedParameters<typeof markdownReaderGetStaticPropsFromPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownreadergetstaticpropsfrompages",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof removeExtensionsFromPath>": {
    "name": "NamedParameters<typeof removeExtensionsFromPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removeextensionsfrompath",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof removeNumberPrefix>": {
    "name": "NamedParameters<typeof removeNumberPrefix>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removenumberprefix",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof shouldExposeMarkdownFile>": {
    "name": "NamedParameters<typeof shouldExposeMarkdownFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-shouldexposemarkdownfile",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof stripReadmeFromFolder>": {
    "name": "NamedParameters<typeof stripReadmeFromFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stripreadmefromfolder",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof getQueryPath>": {
    "name": "NamedParameters<typeof getQueryPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getquerypath",
    "description": "",
    "operationName": "himalayajeep-ui"
  },
  "ParsedUrlQuery": {
    "name": "ParsedUrlQuery",
    "slug": "TsInterface",
    "id": "parsedurlquery",
    "description": "",
    "operationName": "himalayajeep-ui"
  },
  "NestedWebPage": {
    "name": "NestedWebPage",
    "slug": "TsInterface",
    "id": "nestedwebpage",
    "description": "Only used for menu, so can be undefined because it shouldn't be available",
    "operationName": "webpage-types",
    "rawText": "\n\n/**\n * Only used for menu, so can be undefined because it shouldn't be available\n */\nexport type NestedWebPage = ChildObject<WebPage<null>>;"
  },
  "ReaderPageContentProps": {
    "name": "ReaderPageContentProps",
    "slug": "TsInterface",
    "id": "readerpagecontentprops",
    "description": "",
    "operationName": "reader-ui"
  },
  "PreviewData": {
    "name": "PreviewData",
    "slug": "TsInterface",
    "id": "previewdata",
    "description": "",
    "operationName": "next-types",
    "rawText": "\n\nexport type PreviewData = string | false | object | undefined;"
  },
  "ReviewSummary": {
    "name": "ReviewSummary",
    "slug": "TsInterface",
    "id": "reviewsummary",
    "description": "",
    "operationName": "todo-types",
    "rawText": "\n\nexport type ReviewSummary = {\n  scoreYourselfSlider: number;\n  scoreYourselfDescription: string;\n  coderOfTheWeekVote_personId: string;\n  coderOfTheWeekVoteDescription: string;\n};"
  },
  "SelfSprintReview": {
    "name": "SelfSprintReview",
    "slug": "TsInterface",
    "id": "selfsprintreview",
    "description": "\n\nGOAL:\n\n- provide a good way for freelancers and students to self-assess\n- structure the data to provide tools for self-analysis\n\nTODO: PREREQUISITE:\n\n- auth layer\n- p2p\n- create a **model-agnostic-ui** that renders this type of models nicely (many checkmarks, some sliders, some descriptions). can simply be converted into text for the most part\n- make the DB crud component\n- which also allows extra columns\n- which also has an option to use the **model-agnostic-ui**\n- add `Dataset`s support to DB crud\n- make sure the form shows nicely\n- slider component and convention\n- show description by ensuring that, if the trimmed description is an empty string, it shows everything on all lines after, until the next variable\n- monetisation\n\nTHOUGHTS:\n\n- this was just one hour of work, and it kind of is a product (given I make all the general purpose prerequisites). I can make it a bundle that devs can install and BOOM! you got a SaaS... just charge 1$ per entry xD\n- think about other things that can be assessed, can/should they be automated too? not only for teams, also for intimate groups of people to assess private things, also for yourself completely\n- if I have more things like this, which are basically scoring sheets, I can easily reuse the statistics part of the UI that I make for this\n\nTODO: CUSTOM:\n\n- make a `ui-web` operation that has just this crud (or add to the Todo UI)\n- add nice flow for showing the \"coder of the week\"\n- add a column to share an item on social media if it's your own (may be super reusable too)\n- later add things like summaries, history, comparisons, insights (but do it as generic as possible)\n- later provide more auto-filled datapoints (xyzIndexed) for different things\n- later let user auto-share things with the marketstack xD",
    "operationName": "todo-types",
    "rawText": "\n\n/**\n---\ndbStorageMethod: jsonSingle\n---\n\n\nGOAL:\n\n- provide a good way for freelancers and students to self-assess\n- structure the data to provide tools for self-analysis\n\nTODO: PREREQUISITE:\n\n- auth layer\n- p2p\n- create a **model-agnostic-ui** that renders this type of models nicely (many checkmarks, some sliders, some descriptions). can simply be converted into text for the most part\n- make the DB crud component\n  - which also allows extra columns\n  - which also has an option to use the **model-agnostic-ui**\n- add `Dataset`s support to DB crud\n- make sure the form shows nicely\n  - slider component and convention\n  - show description by ensuring that, if the trimmed description is an empty string, it shows everything on all lines after, until the next variable\n- monetisation\n\nTHOUGHTS:\n\n- this was just one hour of work, and it kind of is a product (given I make all the general purpose prerequisites). I can make it a bundle that devs can install and BOOM! you got a SaaS... just charge 1$ per entry xD\n- think about other things that can be assessed, can/should they be automated too? not only for teams, also for intimate groups of people to assess private things, also for yourself completely\n- if I have more things like this, which are basically scoring sheets, I can easily reuse the statistics part of the UI that I make for this\n\nTODO: CUSTOM:\n\n- make a `ui-web` operation that has just this crud (or add to the Todo UI) \n- add nice flow for showing the \"coder of the week\"\n- add a column to share an item on social media if it's your own (may be super reusable too)\n- later add things like summaries, history, comparisons, insights (but do it as generic as possible)\n- later provide more auto-filled datapoints (xyzIndexed) for different things\n- later let user auto-share things with the marketstack xD\n\n*/\nexport type SelfSprintReview = ReviewSummary & {\n  personId: string;\n  person?: Person;\n  /**\n  DESCRIPTION:\n\n  - ensure code gets reviewed\n  - document well\n  - clear naming and simple, elegant code\n  - apply all conventions\n  - use all king OS libraries\n  */\n  codeQuality: ReviewSummary & {\n    lastWeeksCodeGotReviewedThisWeek: boolean;\n    allCodeDocumented: boolean;\n  };\n\n  /**\n  DESCRIPTION:\n\n  - full time?\n  - at least 50% coding editor time?\n  - provide screen time statistics\n\n  */\n  timeManagement: ReviewSummary & {\n    screenTimeHours: number;\n    vscodeHours: number;\n    distractedHours: number;\n    projectBrowserHours: number;\n    englishLearningHours: number;\n    screenshotImages: BackendAsset[];\n  };\n  /**\n  \n  DESCRIPTION:\n\n  - daily networking session on linkedin (and maybe others) (<30m)\n  - attract an audience by creating valueable content for your niche\n  - have conversations and (video) calls with recruiters and companies, record and share them\n\n */\n  networking: ReviewSummary & {\n    dailyNetworkingSession: boolean;\n    contentCreatedThisWeek: boolean;\n    recruiterOrCompanyMeetingThisWeek: boolean;\n  };\n\n  /**\n\n  DESCRIPTION:\n\n  - Build some project of your own on the side (or as main thing)\n  - Progress on this every week, keep us updated\n  - Learn how to find a good idea, validate it, form a product, market it, get interested users, get feedback, monetise it.\n\n  */\n  entrepreneurship: ReviewSummary & {\n    workedOnPassionProject: boolean;\n    progressUpdateDescription: string;\n  };\n\n  /**\nDESCRIPTION:\n\n- daily todo list\n- daily done list\n- good sprint planning statement\n- good sprint review statement\n- ask sharp questions\n- never be stuck, ensure you're never blocked\n- share code (changes) and demos frequently\n- if you can't uphold agreement, communicate this asap (better beforehand and as early as possible) and honestly\n- be present and on time (sharp) at all meetings\n- share payment request once per month, on time\n- share hours worked (with proof: wakatime, screentime) at least every week\n- share accomplishments\n- present bigger topics, be proactive about this\n\n    */\n  clientCommunication: ReviewSummary & {\n    dailyTodoList: boolean;\n    dailyDoneList: boolean;\n    goodSprintPlanningStatement: boolean;\n    goodSprintReviewStatement: boolean;\n    iAskSharpQuestions: boolean;\n    iAmNeverBlocked: boolean;\n    iShareCodeChangesDaily: boolean;\n    upheldAgreement: boolean;\n    presentAndOnTimeAtMeetings: boolean;\n    sharePaymentRequest: boolean;\n    shareHoursWorked: boolean;\n  };\n\n  problemsDescription: string;\n  solutionsDescription: string;\n  proudOfDescription: string;\n} & DefaultModelType;"
  },
  "SpecialKvmdModelType": {
    "name": "SpecialKvmdModelType",
    "slug": "TsInterface",
    "id": "specialkvmdmodeltype",
    "description": "Should be a model that can be taken from the database like kvmd, but for parsing, it needs its own parse methods (from and to json)\n\nThese methods can be given in the configuration of `createDb`.\n\nThese methods can be found.",
    "operationName": "todo-types",
    "rawText": "\n\n/**\n * Should be a model that can be taken from the database like kvmd, but for parsing, it needs its own parse methods (from and to json)\n *\n * These methods can be given in the configuration of `createDb`.\n *\n * These methods can be found.\n */\nexport type SpecialKvmdModelType = KeyValueMarkdownModelType;"
  },
  "TodoFile": {
    "name": "TodoFile",
    "slug": "TsInterface",
    "id": "todofile",
    "description": "Any markdown file in the todo folder should become this model",
    "operationName": "social-media-wrapper"
  },
  "TodoFileProperties": {
    "name": "TodoFileProperties",
    "slug": "TsInterface",
    "id": "todofileproperties",
    "description": "",
    "operationName": "todo-types",
    "rawText": "\n\nexport interface TodoFileProperties {\n  priority?: TodoPriority;\n\n  // `TodoOffer` config. Must be flat because it's a `MarkdownModelType`\n\n  /**\n   * overwrites visibility for freelancer\n   *\n   * by default a todo is visible, unless specifically hiding it\n   *\n   * by default a todo with `isDraft: true` is hidden, unless specifically making it visible\n   */\n  isHiddenForFreelancer?: boolean;\n\n  /**\n   * make todo claimable by a freelancer\n   */\n  isClaimable?: boolean;\n\n  /**\n   * Price to be paid, that, if offered by a freelancer, will be accepted.\n   */\n  doNowPrice?: Price;\n\n  /**\n   * admin can specify when this needs to be finished\n   */\n  deadlineAt?: number;\n\n  /**\n   * Source needed from these operations, can be made accessible after accepting the offer\n   */\n  codeRequired_operationSlugs: Id[];\n  todoOffersCalculated?: TodoOffer[];\n\n  owner_personId?: Slug;\n\n  /**\n   * special categories that augment todo-ui functionality:\n   *\n   * - `ideas` can have altered visibility, according to config\n   * - `done` can have altered visibility, according to config\n   * - `backlog` can have altered visibility, according to config\n   * - `codestories` should be turned into codestories\n   *\n   * Not sure if this should really be fixed, but a convention is always good.\n   */\n  categoryStack: CategoryStack;\n}"
  },
  "TodoOffer": {
    "name": "TodoOffer",
    "slug": "TsInterface",
    "id": "todooffer",
    "description": "Freelancers can offer their services for a todofile",
    "operationName": "todo-types",
    "rawText": "\n\n/**\n * Freelancers can offer their services for a todofile\n */\nexport interface TodoOffer extends DefaultModelType {\n  /**\n   * price the freelancer offers to do this todo\n   *\n   * NB: once offer is accepted, freelancer nor admin can edit the `offerPrice`\n   */\n  offerPrice: Price;\n  personId: Id;\n  todoFileId: Id;\n  /**\n   * mark offer as paid\n   */\n  isPaid?: boolean;\n\n  status: TodoOfferStatus;\n\n  /**\n   * Any assets that are related to this offer can be placed and removed both by freelancer and admin\n   */\n  assets: BackendAsset[];\n\n  /**\n   * markdown of the `TodoFile` when the offer was placed or offerPrice edited\n   *\n   * after offer was accepted, should not be edited\n   */\n  offeredTodoFileMarkdown: Markdown;\n\n  /**\n   * freelancer and admin can both edit the `offeredMarkdown` freely after accepting\n   *\n   * since there's also still a link to the `TodoFile`, admin can also opt to edit that one because it may be applied to all offers. freelancer can't edit the original todo.\n   */\n  editableTodoFileMarkdown: Markdown;\n}"
  },
  "TodoOfferStatus": {
    "name": "TodoOfferStatus",
    "slug": "TsInterface",
    "id": "todoofferstatus",
    "description": "Status of an offer to do some todolist\n\n- `offered`: offer placed, has not been accepted yet. freelancer can still edit offer or remove it\n- `rejected`: offer can be rejected by admin (before accepting)\n- `canceled`: freelancer and admin can cancel an previously accepted offer\n- `accepted`: offer is accepted by admin\n- `todo`: freelancer has said it still needs to be done\n- `doing` freelancer has said it's in progress\n- `done` freelancer said it's done\n- `approved` approved by admin, offer should become archived",
    "operationName": "todo-types",
    "rawText": "/**\n * Status of an offer to do some todolist\n *\n * - `offered`: offer placed, has not been accepted yet. freelancer can still edit offer or remove it\n * - `rejected`: offer can be rejected by admin (before accepting)\n * - `canceled`: freelancer and admin can cancel an previously accepted offer\n * - `accepted`: offer is accepted by admin\n * - `todo`: freelancer has said it still needs to be done\n * - `doing` freelancer has said it's in progress\n * - `done` freelancer said it's done\n * - `approved` approved by admin, offer should become archived\n */\nexport type TodoOfferStatus =\n  | \"offered\"\n  | \"rejected\"\n  | \"accepted\"\n  | \"todo\"\n  | \"doing\"\n  | \"done\"\n  | \"approved\";"
  },
  "TodoPriority": {
    "name": "TodoPriority",
    "slug": "TsInterface",
    "id": "todopriority",
    "description": "",
    "operationName": "todo-types",
    "rawText": "export type TodoPriority = \"low\" | \"medium\" | \"high\";"
  },
  "NamedParameters<typeof TodoMenuHeader>": {
    "name": "NamedParameters<typeof TodoMenuHeader>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-todomenuheader",
    "description": "",
    "operationName": "social-media-web"
  },
  "Authorization": {
    "name": "Authorization",
    "slug": "TsInterface",
    "id": "authorization",
    "description": "`Authorization` helps you provide certain access to files, data, functionality, and code. Authorization can be provided custom, or by indexation. The indexation of the codebase and text-files overwrites the custom authorization in the `Group`-model.\n\n## Different authorizations\n\nFor files (ts, md, json, etc...):\n\n- canWriteCreate\n- canWriteUpdate\n- canWriteDelete\n- canRead\n- canSearch (only search index)\n\nFor db model data subsets:\n\n- canWriteUpdate\n- canWriteCreate\n- canWriteDelete\n- canRead\n- canSearch (only search index)\n\nFor functions:\n\n- canExecute\n\nFor functions, interfaces, variables:\n\n- canRead (reading docs only. for source, you need to provide the file auth)\n- canSearch (only search index)",
    "operationName": "server-login"
  },
  "AuthorizationModel": {
    "name": "AuthorizationModel",
    "slug": "TsInterface",
    "id": "authorizationmodel",
    "description": "Authorization model for indexed authorizations\n\nDon't edit this! If you wish to add authorizations to a group, either edit the code or text-files, or provide custom authorizations to the `Group`.",
    "operationName": "peer-types"
  },
  "Device": {
    "name": "Device",
    "slug": "TsInterface",
    "id": "device",
    "description": "A Device that accesses any King OS api.\n\nA device can be connected to a person. A person can have multiple `Device`s.\n\nA Device does not necissarily have King OS installed themselves, they can also be a visitor to another King OS app of someone else.",
    "operationName": "authentication"
  },
  "NamedParameters<typeof addPeer>": {
    "name": "NamedParameters<typeof addPeer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-addpeer",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof addPeerMessage>": {
    "name": "NamedParameters<typeof addPeerMessage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-addpeermessage",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof augmentDevice>": {
    "name": "NamedParameters<typeof augmentDevice>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-augmentdevice",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof deviceGetAppsCalculated>": {
    "name": "NamedParameters<typeof deviceGetAppsCalculated>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-devicegetappscalculated",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof getAllAppOperations>": {
    "name": "NamedParameters<typeof getAllAppOperations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getallappoperations",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof getAugmentedPersons>": {
    "name": "NamedParameters<typeof getAugmentedPersons>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getaugmentedpersons",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof getFirstEmoji>": {
    "name": "NamedParameters<typeof getFirstEmoji>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfirstemoji",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof getNestedPathObject>": {
    "name": "NamedParameters<typeof getNestedPathObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getnestedpathobject",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof getPeerMessages>": {
    "name": "NamedParameters<typeof getPeerMessages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpeermessages",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof getPeerPeople>": {
    "name": "NamedParameters<typeof getPeerPeople>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpeerpeople",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof getPeersFromPeersRecursively>": {
    "name": "NamedParameters<typeof getPeersFromPeersRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpeersfrompeersrecursively",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof getPublicFolderNestedPathObject>": {
    "name": "NamedParameters<typeof getPublicFolderNestedPathObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpublicfoldernestedpathobject",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof getPublicFolderNestedPathObjectFromPeer>": {
    "name": "NamedParameters<typeof getPublicFolderNestedPathObjectFromPeer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpublicfoldernestedpathobjectfrompeer",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof getPublicPeers>": {
    "name": "NamedParameters<typeof getPublicPeers>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpublicpeers",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof isPortUsed>": {
    "name": "NamedParameters<typeof isPortUsed>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isportused",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof lateFetchPeerMessageSync>": {
    "name": "NamedParameters<typeof lateFetchPeerMessageSync>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-latefetchpeermessagesync",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof ping>": {
    "name": "NamedParameters<typeof ping>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-ping",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof proactivePushAddPeerMessage>": {
    "name": "NamedParameters<typeof proactivePushAddPeerMessage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-proactivepushaddpeermessage",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof removePeer>": {
    "name": "NamedParameters<typeof removePeer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removepeer",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof sortDevices>": {
    "name": "NamedParameters<typeof sortDevices>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-sortdevices",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof updatePeer>": {
    "name": "NamedParameters<typeof updatePeer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-updatepeer",
    "description": "",
    "operationName": "peer-functions"
  },
  "Achievement": {
    "name": "Achievement",
    "slug": "TsInterface",
    "id": "achievement",
    "description": "",
    "operationName": "peer-types",
    "rawText": "\n\nexport interface Achievement {\n  emoji: string;\n  name: string;\n  description: string;\n  /**\n   * in case the developer attained the achievement, this will be set to his level\n   */\n  level?: number;\n  /**\n   * if it's quantifyable, you can add the levels here\n   */\n  levels?: number[];\n}"
  },
  "AppOperation": {
    "name": "AppOperation",
    "slug": "TsInterface",
    "id": "appoperation",
    "description": "",
    "operationName": "peer-types",
    "rawText": "export type AppOperation = {\n  name: string;\n  port: number;\n  description: string | undefined;\n  isOnline?: boolean;\n  /**\n   * Emoji that should be used as the app icon. Can be calculated from the `OPERATION.md`\n   */\n  emoji?: string;\n};"
  },
  "AuthenticationMethod": {
    "name": "AuthenticationMethod",
    "slug": "TsInterface",
    "id": "authenticationmethod",
    "description": "",
    "operationName": "server-login"
  },
  "Developer": {
    "name": "Developer",
    "slug": "TsInterface",
    "id": "developer",
    "description": "",
    "operationName": "peer-types",
    "rawText": "\n\nexport interface Developer extends Person {\n  achievements: Achievement[];\n}"
  },
  "Group": {
    "name": "Group",
    "slug": "TsInterface",
    "id": "group",
    "description": "",
    "operationName": "server-login"
  },
  "HandleObject": {
    "name": "HandleObject",
    "slug": "TsInterface",
    "id": "handleobject",
    "description": "can be used on multiple models.",
    "operationName": "peer-types",
    "rawText": "\n\n/**\n * can be used on multiple models.\n */\nexport type HandleObject = {\n  [platform: Platform[\"slug\"]]: string;\n};"
  },
  "IBrowser": {
    "name": "IBrowser",
    "slug": "TsInterface",
    "id": "ibrowser",
    "description": "NB: copied from ua-parser-js ^1.0.32 because they weren't indexed",
    "operationName": "peer-types",
    "rawText": "/**\n * NB: copied from ua-parser-js ^1.0.32 because they weren't indexed\n */\n\nexport interface IBrowser {\n  /**\n   * Possible values :\n   * Amaya, Android Browser, Arora, Avant, Baidu, Blazer, Bolt, Camino, Chimera, Chrome,\n   * Chromium, Comodo Dragon, Conkeror, Dillo, Dolphin, Doris, Edge, Epiphany, Fennec,\n   * Firebird, Firefox, Flock, GoBrowser, iCab, ICE Browser, IceApe, IceCat, IceDragon,\n   * Iceweasel, IE [Mobile], Iron, Jasmine, K-Meleon, Konqueror, Kindle, Links,\n   * Lunascape, Lynx, Maemo, Maxthon, Midori, Minimo, MIUI Browser, [Mobile] Safari,\n   * Mosaic, Mozilla, Netfront, Netscape, NetSurf, Nokia, OmniWeb, Opera [Mini/Mobi/Tablet],\n   * Phoenix, Polaris, QQBrowser, RockMelt, Silk, Skyfire, SeaMonkey, SlimBrowser, Swiftfox,\n   * Tizen, UCBrowser, Vivaldi, w3m, Yandex\n   *\n   */\n  name: string | undefined;\n\n  /**\n   * Determined dynamically\n   */\n  version: string | undefined;\n\n  /**\n   * Determined dynamically\n   * @deprecated\n   */\n  major: string | undefined;\n}"
  },
  "ICPU": {
    "name": "ICPU",
    "slug": "TsInterface",
    "id": "icpu",
    "description": "",
    "operationName": "peer-types",
    "rawText": "\n\nexport interface ICPU {\n  /**\n   * Possible architecture:\n   *  68k, amd64, arm, arm64, avr, ia32, ia64, irix, irix64, mips, mips64, pa-risc,\n   *  ppc, sparc, sparc64\n   */\n  architecture: string | undefined;\n}"
  },
  "IDevice": {
    "name": "IDevice",
    "slug": "TsInterface",
    "id": "idevice",
    "description": "",
    "operationName": "peer-types",
    "rawText": "\n\nexport interface IDevice {\n  /**\n   * Determined dynamically\n   */\n  model: string | undefined;\n\n  /**\n   * Possible type:\n   * console, mobile, tablet, smarttv, wearable, embedded\n   */\n  type: string | undefined;\n\n  /**\n   * Possible vendor:\n   * Acer, Alcatel, Amazon, Apple, Archos, Asus, BenQ, BlackBerry, Dell, GeeksPhone,\n   * Google, HP, HTC, Huawei, Jolla, Lenovo, LG, Meizu, Microsoft, Motorola, Nexian,\n   * Nintendo, Nokia, Nvidia, Ouya, Palm, Panasonic, Polytron, RIM, Samsung, Sharp,\n   * Siemens, Sony-Ericsson, Sprint, Xbox, ZTE\n   */\n  vendor: string | undefined;\n}"
  },
  "IEngine": {
    "name": "IEngine",
    "slug": "TsInterface",
    "id": "iengine",
    "description": "",
    "operationName": "peer-types",
    "rawText": "\n\nexport interface IEngine {\n  /**\n   * Possible name:\n   * Amaya, EdgeHTML, Gecko, iCab, KHTML, Links, Lynx, NetFront, NetSurf, Presto,\n   * Tasman, Trident, w3m, WebKit\n   */\n  name: string | undefined;\n  /**\n   * Determined dynamically\n   */\n  version: string | undefined;\n}"
  },
  "Interest": {
    "name": "Interest",
    "slug": "TsInterface",
    "id": "interest",
    "description": "",
    "operationName": "social-media-types",
    "rawText": "\n\nexport interface Interest extends KeyValueMarkdownModelType {\n  parent_interestSlug: Slug;\n  parent_interest: Interest;\n}"
  },
  "IOS": {
    "name": "IOS",
    "slug": "TsInterface",
    "id": "ios",
    "description": "",
    "operationName": "peer-types",
    "rawText": "\n\nexport interface IOS {\n  /**\n   * Possible 'os.name'\n   * AIX, Amiga OS, Android, Arch, Bada, BeOS, BlackBerry, CentOS, Chromium OS, Contiki,\n   * Fedora, Firefox OS, FreeBSD, Debian, DragonFly, Gentoo, GNU, Haiku, Hurd, iOS,\n   * Joli, Linpus, Linux, Mac OS, Mageia, Mandriva, MeeGo, Minix, Mint, Morph OS, NetBSD,\n   * Nintendo, OpenBSD, OpenVMS, OS/2, Palm, PCLinuxOS, Plan9, Playstation, QNX, RedHat,\n   * RIM Tablet OS, RISC OS, Sailfish, Series40, Slackware, Solaris, SUSE, Symbian, Tizen,\n   * Ubuntu, UNIX, VectorLinux, WebOS, Windows [Phone/Mobile], Zenwalk\n   */\n  name: string | undefined;\n  /**\n   * Determined dynamically\n   */\n  version: string | undefined;\n}"
  },
  "IPInfo": {
    "name": "IPInfo",
    "slug": "TsInterface",
    "id": "ipinfo",
    "description": "Information that is inferred from an IP",
    "operationName": "function-server-endpoints"
  },
  "IResult": {
    "name": "IResult",
    "slug": "TsInterface",
    "id": "iresult",
    "description": "",
    "operationName": "function-server-endpoints"
  },
  "Language": {
    "name": "Language",
    "slug": "TsInterface",
    "id": "language",
    "description": "all currently supported languages",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * all currently supported languages\n */\nexport type Language = keyof typeof languages;"
  },
  "Location": {
    "name": "Location",
    "slug": "TsInterface",
    "id": "location",
    "description": "locations are hierarchically categorized pieces of information.\n\na city can refer to the area, the area can refer the the country, the country to the continent, etc.\n\nthere are multiple ways to categorize it, but this depends on the application.",
    "operationName": "foodchain-types"
  },
  "MediaCredential": {
    "name": "MediaCredential",
    "slug": "TsInterface",
    "id": "mediacredential",
    "description": "",
    "operationName": "social-media-wrapper"
  },
  "PageVisit": {
    "name": "PageVisit",
    "slug": "TsInterface",
    "id": "pagevisit",
    "description": "Any visit tracked based on a server request\n\nNB: TODO: it might occur that a page fetches multiple api endpoints, which will create duplicate data here. How do I fix that?",
    "operationName": "peer-types",
    "rawText": "\n\n/**\n * Any visit tracked based on a server request\n *\n * NB: TODO: it might occur that a page fetches multiple api endpoints, which will create duplicate data here. How do I fix that?\n */\nexport interface PageVisit extends DefaultModelType {\n  deviceId: string;\n  /**\n   * complete url of the page that was visited\n   */\n  path: string;\n  /**\n   * When was the page visited\n   */\n  createdAt: number;\n  ipInfo: IPInfo;\n}"
  },
  "PeerMessage": {
    "name": "PeerMessage",
    "slug": "TsInterface",
    "id": "peermessage",
    "description": "DEPRECTATED: should be replaced by `MediaPost`. MediaPost can  have many channels, and this is just one of them",
    "operationName": "peer-web"
  },
  "Persona": {
    "name": "Persona",
    "slug": "TsInterface",
    "id": "persona",
    "description": "Highly private model.\n\nConfiguration for a person identity that you say that is you.\n\nAs a OS user you can have multiple personas between which you can easily switch.\n\nThe difference from `Person` is that `Person` stores other people, whereas `Persona` stores different identities you give to yourself.\n\nNB: brands should also be able to be personas, and since some brands are shared between people, you should be able to share Persona's with other `Person`s into their OS...\n\n> Persona: A persona, depending on the context, is the public image of one's personality, the social role that one adopts, or simply a fictional character. The word derives from Latin, where it originally referred to a theatrical mask. On the social web, users develop virtual personas as online identities. (Wikipedia)",
    "operationName": "peer-types",
    "rawText": "\n/**\n * Highly private model.\n *\n * Configuration for a person identity that you say that is you.\n *\n * As a OS user you can have multiple personas between which you can easily switch.\n *\n * The difference from `Person` is that `Person` stores other people, whereas `Persona` stores different identities you give to yourself.\n *\n * NB: brands should also be able to be personas, and since some brands are shared between people, you should be able to share Persona's with other `Person`s into their OS...\n *\n * > Persona: A persona, depending on the context, is the public image of one's personality, the social role that one adopts, or simply a fictional character. The word derives from Latin, where it originally referred to a theatrical mask. On the social web, users develop virtual personas as online identities. (Wikipedia)\n */\nexport interface Persona extends SlugModelType {\n  /**\n   * If this is set to true, this persona instance will be selected when searching for a persona. Ensure that there is just one default persona!\n   *\n   * If none are `isPrimary`, the first persona instance can be selected\n   */\n  isPrimary?: boolean;\n  /**\n   * If true, this will pop up in persona selection\n   *\n   * If not, you can still find it using auto-complete, though\n   */\n  isFavorite?: boolean;\n\n  /**\n   * Some pictures that can be used that show this person\n   */\n  pictureImages?: BackendAsset[];\n\n  /**\n   * You can give different characteristics to your personas if you wish\n   */\n  dataEntries: PersonInformationValue[];\n\n  /** Interests this persona has\n   *\n   * Can be matched against a channel to be the recommended persona\n   */\n  interestSlugs?: Slug[];\n  interests?: Interest[];\n\n  /**\n   * Where does this persona reside? can be multiple locations\n   *\n   * Can be matched against a channel to be the recommended persona\n   */\n  locationSlugs?: Slug[];\n  locations?: Location[];\n\n  /**\n   * Languages that this persona can speak\n   *\n   * Can be matched against a channel to be the recommended persona\n   */\n  spokenLanguages: Language[];\n\n  /**\n   * NB: should have a custom input in the `SimplifiedSchemaForm`\n   */\n  stripeSecret?: string;\n\n  twilioAccountSid?: string;\n  twilioAuthToken?: string;\n  /**\n   * Provide the phone number you are using by default for sending SMS messages\n   */\n  twilioFromPhoneNumber?: string;\n\n  sendgridApiKey?: string;\n  sendgridFromEmail?: string;\n\n  /**\n   * Github stuff\n   */\n  githubEmail?: string;\n  /**\n   * Personal access token\n   */\n  githubAccessToken?: string;\n  githubOrganisation?: string;\n  useGithubOrganisation?: boolean;\n\n  mediaCredentialIds?: Id[];\n  mediaCredentials?: MediaCredential[];\n\n  apiKey2Captcha?: string;\n  openAiPassword?: string;\n  openAiEmail?: string;\n}"
  },
  "PersonInformation": {
    "name": "PersonInformation",
    "slug": "TsInterface",
    "id": "personinformation",
    "description": "categorisation model for informormation about a person\n\n- the keys are the things you want to store\n- the values are the descriptions of the thing to be stored\n- the categories can organise the things you want to store better",
    "operationName": "peer-types",
    "rawText": "\n\n/**\n * categorisation model for informormation about a person\n *\n * - the keys are the things you want to store\n * - the values are the descriptions of the thing to be stored\n * - the categories can organise the things you want to store better\n */\nexport interface PersonInformation extends KeyValueMarkdownModelType {\n  parent_personInformationSlug?: Slug;\n  parent_personInformation?: PersonInformation;\n}"
  },
  "PersonInformationValue": {
    "name": "PersonInformationValue",
    "slug": "TsInterface",
    "id": "personinformationvalue",
    "description": "key value data storage model for information about a person\n\n- the filename must identify the person this is about (`personSlug`)\n- the categories are the different people and the person information categories\n- the keys are the person information datapoints\n- the values are the values of the datapoints that you stored about this user\n\nExample:\n\nthe file `person-information-values/abraham-lincoln.md` could contain something like this:\n\n```md\n# life\nborn: 11-01-1777\ndied: 20-12-1812\n\n# identification\nfirstName: Abraham\nlastName: Lincoln\n```\n\nNB: It's not going to be easy to keep this model in sync with the model it relies on!\n\nTODO: figure out if this kan be a `KeyValueMarkdownModelType` or `MarkdownModelType`",
    "operationName": "peer-types",
    "rawText": "\n\n/** key value data storage model for information about a person\n *\n * - the filename must identify the person this is about (`personSlug`)\n * - the categories are the different people and the person information categories\n * - the keys are the person information datapoints\n * - the values are the values of the datapoints that you stored about this user\n *\n * Example:\n *\n * the file `person-information-values/abraham-lincoln.md` could contain something like this:\n *\n * ```md\n * # life\n * born: 11-01-1777\n * died: 20-12-1812\n *\n * # identification\n * firstName: Abraham\n * lastName: Lincoln\n * ```\n *\n * NB: It's not going to be easy to keep this model in sync with the model it relies on!\n *\n * TODO: figure out if this kan be a `KeyValueMarkdownModelType` or `MarkdownModelType`\n */\nexport interface PersonInformationValue extends DefaultModelType {\n  personId: Id;\n  personInformationSlug: Slug;\n  value: string;\n}"
  },
  "PersonPlatformConnection": {
    "name": "PersonPlatformConnection",
    "slug": "TsInterface",
    "id": "personplatformconnection",
    "description": "Forgive the long name, but this model connects the user with the people they have a connection with on specific platforms\n\ne.g. John Doe is connected with me on LinkedIn with the handle `johndoe123`\n\nNot sure if this is the best way to do this, there may be limitations... For example, both I and the other person can have multiple social media accounts on a single platform",
    "operationName": "peer-types",
    "rawText": "\n\n/**\n * Forgive the long name, but this model connects the user with the people they have a connection with on specific platforms\n *\n * e.g. John Doe is connected with me on LinkedIn with the handle `johndoe123`\n *\n * Not sure if this is the best way to do this, there may be limitations... For example, both I and the other person can have multiple social media accounts on a single platform\n */\nexport interface PersonPlatformConnection extends DefaultModelType {\n  /** which person */\n  personId: Id;\n  person: Person;\n  /** is it a follow, or a connection? */\n  isFollow: boolean;\n  /** when did we last verify and update the connection? */\n  scrapeSucceededAt: number | null;\n  /** when did we last try to scrape but failed? */\n  scrapedFailedAt: number | null;\n  /** on which platform */\n  platformSlug: Slug;\n  /** how can the connection be identified on that platform? */\n  platformConnectionId: string;\n}"
  },
  "PersonProfileDetails": {
    "name": "PersonProfileDetails",
    "slug": "TsInterface",
    "id": "personprofiledetails",
    "description": "Things the user can fill in about themselves on their profile",
    "operationName": "authentication"
  },
  "PersonSocialMedia": {
    "name": "PersonSocialMedia",
    "slug": "TsInterface",
    "id": "personsocialmedia",
    "description": "media (mediums) that a person uses, e.g. linkedin, twitter, whatsapp, sms, calling, and irl",
    "operationName": "peer-types",
    "rawText": "\n\n/**\n * media (mediums) that a person uses, e.g. linkedin, twitter, whatsapp, sms, calling, and irl\n */\nexport type PersonSocialMedia = {\n  /** medium where the person is a user */\n  platformSlug: Slug;\n  /** used to find the user on the platform */\n  path: string;\n  //  probably not needed\n  // /** if needed an additional, platform specific ID for the User can be stored here, e.g. a message channel ID on LinkedIn */\n  // additionalId?: string;\n  /** (if available) whether or not the user has a premium account */\n  isPremium: boolean;\n  /** (if available) a tagline for the user of the platform */\n  tagline?: string;\n  /** (if available) a bio for the user of the platform */\n  bio?: string;\n};"
  },
  "Platform": {
    "name": "Platform",
    "slug": "TsInterface",
    "id": "platform",
    "description": "Channels can be posts, or persons, or channels\nChannels neeeds have platform Like, slack, facebook,\n\n\ntype should be return and create a package and return statement should be the same for all the packages",
    "operationName": "slack-controller",
    "rawText": "\n\n/**\n * Channels can be posts, or persons, or channels\n * Channels neeeds have platform Like, slack, facebook,\n */\n// type should be return and create a package and return statement should be the same for all the packages\n\nexport type Platform =\n  | \"slack\"\n  | \"facebook\"\n  | \"whatsapp\"\n  | \"linkedin\"\n  | \"discord\"\n  | \"twitter\"\n  | \"sms\"\n  | \"reddit\";"
  },
  "Position": {
    "name": "Position",
    "slug": "TsInterface",
    "id": "position",
    "description": "",
    "operationName": "himalayajeep-functions"
  },
  "PublicPerson": {
    "name": "PublicPerson",
    "slug": "TsInterface",
    "id": "publicperson",
    "description": "",
    "operationName": "authentication"
  },
  "PublicPersonKeys": {
    "name": "PublicPersonKeys",
    "slug": "TsInterface",
    "id": "publicpersonkeys",
    "description": "",
    "operationName": "peer-types",
    "rawText": "\n\nexport type PublicPersonKeys = typeof publicPersonKeys[number];"
  },
  "NamedParameters<typeof AddPeer>": {
    "name": "NamedParameters<typeof AddPeer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-addpeer",
    "description": "",
    "operationName": "peer-web"
  },
  "NamedParameters<typeof Home>": {
    "name": "NamedParameters<typeof Home>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-home",
    "description": "",
    "operationName": "peer-web"
  },
  "NamedParameters<typeof Page>": {
    "name": "NamedParameters<typeof Page>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-page",
    "description": "",
    "operationName": "peer-web"
  },
  "NamedParameters<typeof Peer>": {
    "name": "NamedParameters<typeof Peer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-peer",
    "description": "",
    "operationName": "peer-web"
  },
  "NamedParameters<typeof PeerChat>": {
    "name": "NamedParameters<typeof PeerChat>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-peerchat",
    "description": "",
    "operationName": "peer-web"
  },
  "NamedParameters<typeof PeerMessageComponent>": {
    "name": "NamedParameters<typeof PeerMessageComponent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-peermessagecomponent",
    "description": "",
    "operationName": "peer-web"
  },
  "NamedParameters<typeof PublicMenu>": {
    "name": "NamedParameters<typeof PublicMenu>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-publicmenu",
    "description": "",
    "operationName": "peer-web"
  },
  "NamedParameters<typeof getPrimaryPersona>": {
    "name": "NamedParameters<typeof getPrimaryPersona>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getprimarypersona",
    "description": "",
    "operationName": "persona-functions-node"
  },
  "NamedParameters<typeof youtubeToPlayItem>": {
    "name": "NamedParameters<typeof youtubeToPlayItem>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-youtubetoplayitem",
    "description": "",
    "operationName": "play-import-node"
  },
  "Artist_Person_Relation": {
    "name": "Artist_Person_Relation",
    "slug": "TsInterface",
    "id": "artist-person-relation",
    "description": "Model to attach some information about a music-related interface to a specific person\n\nIt's interesting to note that, if an app is completely peer to peer, or completely 1 user, this is probably not even needed.\n\nHowever, this seems to be a quite common use-case. It may even be an idea to make a convention out of this, where you can specify the [model] and the [model]_[model]_Relation. If this were convention, we're probably",
    "operationName": "play-media-types",
    "rawText": "\n/**\n * Model to attach some information about a music-related interface to a specific person\n *\n * It's interesting to note that, if an app is completely peer to peer, or completely 1 user, this is probably not even needed.\n *\n * However, this seems to be a quite common use-case. It may even be an idea to make a convention out of this, where you can specify the [model] and the [model]_[model]_Relation. If this were convention, we're probably\n */\nexport interface Artist_Person_Relation extends RelationModelType, MusicNotes {}"
  },
  "Artist": {
    "name": "Artist",
    "slug": "TsInterface",
    "id": "artist",
    "description": "Not sure if this is a good idea, but I'm pretty sure if it would work it's going to be a pretty common usecase.",
    "operationName": "play-media-types",
    "rawText": "\n\n/**\n * Not sure if this is a good idea, but I'm pretty sure if it would work it's going to be a pretty common usecase.\n */\nexport interface Artist extends Person, DefaultModelType {\n  playCategorySlugs?: Slug[];\n  playItemsCalculated?: PlayItem[];\n}"
  },
  "MusicNotes": {
    "name": "MusicNotes",
    "slug": "TsInterface",
    "id": "musicnotes",
    "description": "Information a person can save, personally, to an Artist, Genre, PlayList, or Song.",
    "operationName": "play-media-types",
    "rawText": "\n\n/**\n * Information a person can save, personally, to an Artist, Genre, PlayList, or Song.\n */\nexport interface MusicNotes {\n  isFavorite?: boolean;\n  tags?: string[];\n  noteDescription?: string;\n  lastListenAt: number;\n}"
  },
  "PlayCategory_Person_Relation": {
    "name": "PlayCategory_Person_Relation",
    "slug": "TsInterface",
    "id": "playcategory-person-relation",
    "description": "",
    "operationName": "play-media-types",
    "rawText": "\n\nexport interface PlayCategory_Person_Relation\n  extends RelationModelType,\n    MusicNotes {}"
  },
  "PlayCategory": {
    "name": "PlayCategory",
    "slug": "TsInterface",
    "id": "playcategory",
    "description": "",
    "operationName": "play-media-types",
    "rawText": "\n\nexport interface PlayCategory extends DefaultModelType {\n  name: string;\n  slug: string;\n  image?: BackendAsset;\n  description?: Markdown;\n  parent_playCategoryId?: Id;\n}"
  },
  "PlayItem_Person_Relation": {
    "name": "PlayItem_Person_Relation",
    "slug": "TsInterface",
    "id": "playitem-person-relation",
    "description": "",
    "operationName": "play-media-types",
    "rawText": "\n\nexport interface PlayItem_Person_Relation\n  extends RelationModelType,\n    MusicNotes {}"
  },
  "PlayItem": {
    "name": "PlayItem",
    "slug": "TsInterface",
    "id": "playitem",
    "description": "Two file formats are supported by this model: mp3 and mp4 (audio & video)",
    "operationName": "play-media-types",
    "rawText": "\n\n/**\n * Two file formats are supported by this model: mp3 and mp4 (audio & video)\n */\nexport interface PlayItem extends DefaultModelType {\n  artistId?: Id;\n  artist?: Artist;\n  playAsset?: BackendAsset;\n  /**\n   * Can be the actual content in text-form of the item.\n   *\n   * Oftentimes this should probably be indexed, but would be nice to be able to edit it too sometimes\n   *\n   * For music, this could be the lyrics. For audiobooks or podcasts, this could be the things said\n   *\n   * For videos this could be the subtitles... etc.\n   *\n   * UPDATE: for markdown files, this can be the original content, where the playAsset is the indexed stuff. This would allow me to integrate this with a markdown-player. The important thing though is that indexation may take long, so it might be better to then generate the playItem's on the fly for this one... Let's think about it a bit more first.\n   */\n  playContentMarkdown?: Markdown;\n  description?: Markdown;\n  playListsCalculated?: PlayList[];\n  playCategoryIds?: Id[];\n  playCategorys?: PlayCategory[];\n  interestIds?: Id[];\n  interests?: Interest[];\n  /**\n   * Should be indexed most of the time, but I can imagine this also to work for things like images\n   */\n  durationSecondsIndexed?: number;\n  isRoyaltyFree?: boolean;\n}"
  },
  "PlayItemImport": {
    "name": "PlayItemImport",
    "slug": "TsInterface",
    "id": "playitemimport",
    "description": "This is a good interface for importing a folder into the database",
    "operationName": "play-media-types",
    "rawText": "\n\n/**\n * This is a good interface for importing a folder into the database\n */\nexport interface PlayItemImport {\n  playListIds?: Id[];\n  genreIds?: Id[];\n  artistId?: Id;\n  isRoyaltyFree?: boolean;\n  playItemsAbsoluteFolderPath?: boolean;\n}"
  },
  "PlayList_Person_Relation": {
    "name": "PlayList_Person_Relation",
    "slug": "TsInterface",
    "id": "playlist-person-relation",
    "description": "",
    "operationName": "play-media-types",
    "rawText": "\n\nexport interface PlayList_Person_Relation\n  extends RelationModelType,\n    MusicNotes {}"
  },
  "PlayList": {
    "name": "PlayList",
    "slug": "TsInterface",
    "id": "playlist",
    "description": "`PlayList` works `Song`, but could potentially also work for audio, video, podcast, audiobook, movie, documentary,",
    "operationName": "play-media-types",
    "rawText": "\n\n/**\n * `PlayList` works `Song`, but could potentially also work for audio, video, podcast, audiobook, movie, documentary,\n */\nexport interface PlayList extends DefaultModelType {\n  creator_personId?: Id;\n  creator_person?: Person;\n  playItemIds?: Id[];\n  playItems?: PlayItem[];\n  playCategoryIds?: Id[];\n  playCategorys?: PlayCategory[];\n  image?: BackendAsset;\n  description?: Markdown;\n  totalDurationIndexed?: number;\n  attached_playListIds?: Id[];\n  attached_playLists?: PlayList[];\n  isRoyaltyFree?: boolean;\n}"
  },
  "PlaySchedule": {
    "name": "PlaySchedule",
    "slug": "TsInterface",
    "id": "playschedule",
    "description": "Schedule that describes how a playlist will be played",
    "operationName": "play-media-types",
    "rawText": "\n/**\n * Schedule that describes how a playlist will be played\n */\nexport interface PlaySchedule extends DefaultModelType {\n  playListId?: Id;\n  playList?: PlayList;\n  isShuffle?: boolean;\n  /** In the order of the playSchedule */\n  playItemsIndexed?: (PlayItem & { startTimeAt?: number })[];\n  startTimeAt?: number;\n  endTimeAt?: number;\n  isMuted?: boolean;\n}"
  },
  "RelationModelType": {
    "name": "RelationModelType",
    "slug": "TsInterface",
    "id": "relationmodeltype",
    "description": "Proposed new model convention for models that provide properties that relate to the intersection of two models\n\nThe convention can be that a model that extends this model must have a name in the shape of `[model1]_[model2]_Relation`\n\nTheoretically it may also work for intersection of more than just 2 models, but this is probably not needed at first.\n\nMotivation: to create model agnostic features that include intersections with other models. The main thing I'm thinking about now, is to add all related models into the CRUD of a model, prefilling one of the models. This would make it possible to just add it to the form like it were part of the model. This would save lots of coding!",
    "operationName": "play-media-types",
    "rawText": "\n\n/**\n * Proposed new model convention for models that provide properties that relate to the intersection of two models\n *\n * The convention can be that a model that extends this model must have a name in the shape of `[model1]_[model2]_Relation`\n *\n * Theoretically it may also work for intersection of more than just 2 models, but this is probably not needed at first.\n *\n * Motivation: to create model agnostic features that include intersections with other models. The main thing I'm thinking about now, is to add all related models into the CRUD of a model, prefilling one of the models. This would make it possible to just add it to the form like it were part of the model. This would save lots of coding!\n */\nexport interface RelationModelType extends DefaultModelType {\n  firstModelId: Id;\n  secondModelId: Id;\n}"
  },
  "Day": {
    "name": "Day",
    "slug": "TsInterface",
    "id": "day",
    "description": "",
    "operationName": "reminder-types",
    "rawText": "\n\nexport type Day =\n  | \"monday\"\n  | \"tuesday\"\n  | \"wednesday\"\n  | \"thursday\"\n  | \"friday\"\n  | \"saturday\"\n  | \"sunday\";"
  },
  "NamedParameters<typeof getDayNumber>": {
    "name": "NamedParameters<typeof getDayNumber>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdaynumber",
    "description": "",
    "operationName": "reminder-node"
  },
  "NamedParameters<typeof remindMe>": {
    "name": "NamedParameters<typeof remindMe>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-remindme",
    "description": "",
    "operationName": "reminder-node"
  },
  "DateNumber": {
    "name": "DateNumber",
    "slug": "TsInterface",
    "id": "datenumber",
    "description": "1-31",
    "operationName": "reminder-types",
    "rawText": "\n/**\n * 1-31\n */\nexport type DateNumber = number;"
  },
  "HourNumber": {
    "name": "HourNumber",
    "slug": "TsInterface",
    "id": "hournumber",
    "description": "0-23",
    "operationName": "reminder-types",
    "rawText": "\n/**\n * 0-23\n */\nexport type HourNumber = number;"
  },
  "RecurringReminder": {
    "name": "RecurringReminder",
    "slug": "TsInterface",
    "id": "recurringreminder",
    "description": "model for reminders or recurring reminders",
    "operationName": "reminder-types",
    "rawText": "\n\n/**\n * model for reminders or recurring reminders\n */\n\nexport interface RecurringReminder extends SlugModelType {\n  name: string;\n  description?: string;\n  /**\n   * Recurring reminder: which days of the week is it active?\n   */\n  days?: Day[];\n  /**\n   * Recurring reminder: which dates of the month is it active?\n   */\n  dates?: DateNumber[];\n\n  /**\n   * Recurring reminder: which hours do you want to be reminded? Reminders occur on the exact hour.\n   */\n  hours?: HourNumber[];\n\n  /**\n   * instead you can also provide a single date to remind\n   */\n  singleDatetimeAt?: number;\n}"
  },
  "NamedParameters<typeof MatchingText>": {
    "name": "NamedParameters<typeof MatchingText>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-matchingtext",
    "description": "",
    "operationName": "file-search"
  },
  "NamedParameters<typeof PathSearchResults>": {
    "name": "NamedParameters<typeof PathSearchResults>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-pathsearchresults",
    "description": "",
    "operationName": "file-search"
  },
  "NamedParameters<typeof getAllSearchResults>": {
    "name": "NamedParameters<typeof getAllSearchResults>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getallsearchresults",
    "description": "",
    "operationName": "search-web"
  },
  "NamedParameters<typeof SearchBar>": {
    "name": "NamedParameters<typeof SearchBar>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-searchbar",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof SearchResultComponent>": {
    "name": "NamedParameters<typeof SearchResultComponent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-searchresultcomponent",
    "description": "",
    "operationName": "search-web"
  },
  "NamedParameters<typeof SearchResultPage>": {
    "name": "NamedParameters<typeof SearchResultPage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-searchresultpage",
    "description": "",
    "operationName": "search-web"
  },
  "QueryPageProps": {
    "name": "QueryPageProps",
    "slug": "TsInterface",
    "id": "querypageprops",
    "description": "",
    "operationName": "search-web",
    "rawText": "export type QueryPageProps = {\n  query: string | null;\n  searchResults: SearchResult[] | null;\n  imagePaths: string[];\n  timelineItems: {\n    comment: string;\n    filePath?: string;\n    line: number;\n  }[];\n};"
  },
  "SearchResult": {
    "name": "SearchResult",
    "slug": "TsInterface",
    "id": "searchresult",
    "description": "",
    "operationName": "search-web",
    "rawText": "\n\nexport type SearchResult = {};"
  },
  "NamedParameters<typeof getPostableFrontmatterSchema>": {
    "name": "NamedParameters<typeof getPostableFrontmatterSchema>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpostablefrontmatterschema",
    "description": "",
    "operationName": "social-media-functions"
  },
  "MediaChannel": {
    "name": "MediaChannel",
    "slug": "TsInterface",
    "id": "mediachannel",
    "description": "channel where messages can be posted to\n\nexamples:\n- facebook group\n- slack channel\n- whatsapp pm\n- facebook pm",
    "operationName": "social-media-types",
    "rawText": "\n/** channel where messages can be posted to\n *\n * examples:\n * - facebook group\n * - slack channel\n * - whatsapp pm\n * - facebook pm\n */\nexport interface MediaChannel extends DefaultModelType {\n  platformSlug: Slug;\n  /** way to identify the channel on the platform\n   *\n   * e.g. on slack we can say `xyz/meet` for the `#meet` channel on the `xyz` slack\n   */\n  platformChannelId: string;\n  url?: string;\n  name: string;\n  slug: string;\n  description?: string;\n\n  /**\n   * Person this channel is connected to\n   *\n   * Can be indexed once the `MediaChannel` is found, and it seems to be a person. Then the person neds to be created as well and the `.personId` needs to be attached to the `MediaChannel`\n   */\n  personId?: Id;\n\n  // person?:Person;\n\n  /** if true, this channel is a group */\n  isGroup?: boolean;\n\n  /**\n   * Ids that each identify a `Person` that is part of this channel. Isn't always available\n   */\n  member_personIds?: Id[];\n\n  /**\n   * The below parameters should ONLY be used if the instance is a channel for a group.\n   * if this is a channel for a person, the interests should be stored on the person instead.\n   */\n\n  /** group-only: interests this group has */\n  interestSlugs?: Slug[];\n  interests?: Interest[];\n\n  /** group-only: most specific location of the people in this channel (if any) */\n  locationSlug?: Slug;\n  location?: Location;\n\n  /** group-only: preferred spoken language in this channel. `Postable` should be translated into this language */\n  language: Language;\n\n  /**\n   * Which account do you want to use to post something in this channel?\n   *\n   * TODO: maybe refactor this to use `Persona` and match the persona automatically based on interests, location, and language, then get the mediaCredential for the platform from the `Persona` that matches this channel the most...\n   */\n  mediaCredentialId?: Id;\n  mediaCredential?: MediaCredential;\n\n  /** when did you make your last post? */\n  myLastPostAt: number;\n}"
  },
  "MediaPlatformEnum": {
    "name": "MediaPlatformEnum",
    "slug": "TsInterface",
    "id": "mediaplatformenum",
    "description": "",
    "operationName": "social-media-wrapper"
  },
  "MediaPost": {
    "name": "MediaPost",
    "slug": "TsInterface",
    "id": "mediapost",
    "description": "Post/message on any medium.",
    "operationName": "social-media-wrapper"
  },
  "SocialMediaPostTypeReturnType": {
    "name": "SocialMediaPostTypeReturnType",
    "slug": "TsInterface",
    "id": "socialmediaposttypereturntype",
    "description": "",
    "operationName": "social-media-types",
    "rawText": "export interface SocialMediaPostTypeReturnType {\n  isSuccess: boolean;\n  message: string;\n  postUrl?: string;\n}"
  },
  "FrontmatterParse": {
    "name": "FrontmatterParse",
    "slug": "TsInterface",
    "id": "frontmatterparse",
    "description": "",
    "operationName": "matter-types",
    "rawText": "export type FrontmatterParse = {\n  [frontmatterKey: string]: any;\n};"
  },
  "FrontmatterValue": {
    "name": "FrontmatterValue",
    "slug": "TsInterface",
    "id": "frontmattervalue",
    "description": "",
    "operationName": "frontmatter-util",
    "rawText": "export type FrontmatterValue =\n  | string\n  | number\n  | boolean\n  | string[]\n  | null\n  | undefined;"
  },
  "NamedParameters<typeof frontmatterParseToString>": {
    "name": "NamedParameters<typeof frontmatterParseToString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-frontmatterparsetostring",
    "description": "",
    "operationName": "frontmatter-util"
  },
  "NamedParameters<typeof frontmatterToObject>": {
    "name": "NamedParameters<typeof frontmatterToObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-frontmattertoobject",
    "description": "",
    "operationName": "frontmatter-util"
  },
  "NamedParameters<typeof getFrontmatterValueString>": {
    "name": "NamedParameters<typeof getFrontmatterValueString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfrontmattervaluestring",
    "description": "",
    "operationName": "frontmatter-util"
  },
  "NamedParameters<typeof objectToFrontmatter>": {
    "name": "NamedParameters<typeof objectToFrontmatter>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-objecttofrontmatter",
    "description": "",
    "operationName": "frontmatter-util"
  },
  "NamedParameters<typeof parseFrontmatterString>": {
    "name": "NamedParameters<typeof parseFrontmatterString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parsefrontmatterstring",
    "description": "",
    "operationName": "frontmatter-util"
  },
  "NamedParameters<typeof quotedOrNot>": {
    "name": "NamedParameters<typeof quotedOrNot>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-quotedornot",
    "description": "",
    "operationName": "frontmatter-util"
  },
  "NamedParameters<typeof stringifyNewlines>": {
    "name": "NamedParameters<typeof stringifyNewlines>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stringifynewlines",
    "description": "",
    "operationName": "frontmatter-util"
  },
  "NamedParameters<typeof ShortMarkdownPlayer>": {
    "name": "NamedParameters<typeof ShortMarkdownPlayer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-shortmarkdownplayer",
    "description": "",
    "operationName": "short-markdown-writer-input"
  },
  "NamedParameters<typeof useMultiAudio>": {
    "name": "NamedParameters<typeof useMultiAudio>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usemultiaudio",
    "description": "",
    "operationName": "short-markdown-writer-input"
  },
  "NamedParameters<typeof copyPath>": {
    "name": "NamedParameters<typeof copyPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-copypath",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof deleteFileOrFolder>": {
    "name": "NamedParameters<typeof deleteFileOrFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-deletefileorfolder",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof getFileContents>": {
    "name": "NamedParameters<typeof getFileContents>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfilecontents",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof getWriterWebPages>": {
    "name": "NamedParameters<typeof getWriterWebPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getwriterwebpages",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof getWriterWebPagesMenu>": {
    "name": "NamedParameters<typeof getWriterWebPagesMenu>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getwriterwebpagesmenu",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof movePath>": {
    "name": "NamedParameters<typeof movePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-movepath",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof newFile>": {
    "name": "NamedParameters<typeof newFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-newfile",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof newFolder>": {
    "name": "NamedParameters<typeof newFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-newfolder",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof processAssetUpload>": {
    "name": "NamedParameters<typeof processAssetUpload>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-processassetupload",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof renameFileOrFolder>": {
    "name": "NamedParameters<typeof renameFileOrFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-renamefileorfolder",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof saveFileContents>": {
    "name": "NamedParameters<typeof saveFileContents>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-savefilecontents",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof trashFileOrFolder>": {
    "name": "NamedParameters<typeof trashFileOrFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-trashfileorfolder",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof updateFrontmatter>": {
    "name": "NamedParameters<typeof updateFrontmatter>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-updatefrontmatter",
    "description": "",
    "operationName": "writer-functions"
  },
  "MarkdownParseRenderConfig": {
    "name": "MarkdownParseRenderConfig",
    "slug": "TsInterface",
    "id": "markdownparserenderconfig",
    "description": "",
    "operationName": "markdown",
    "rawText": "\nexport type MarkdownParseRenderConfig = {\n  disableSelectionContextMenu?: boolean;\n\n  /**\n   * Folder path where the markdown is supposed to be located.\n   *\n   * This is used for knowing where relative links or assets can be found\n   *\n   * If you don't provide this, assets can't be shown, because we wouldn't know where to get them from.\n   */\n  projectRelativeBaseFolderPath?: string;\n\n  /**\n   * project relative path of the markdown file.\n   *\n   * This is used for knowing where relative links or assets can be found\n   *\n   * If you don't provide this, assets can't be shown, because we wouldn't know where to get them from.\n   */\n  projectRelativeMarkdownFilePath?: string;\n\n  /**\n   * Mapped object of `AugmentedWord`s. Used to augment the rendered markdown with tooltips and links showing more information about the augmented words.\n   *\n   * TODO: this value should probably be precalculated and indexed, because the dev experience becomes very slow with this\n   */\n  augmentedWordObject?: MappedObject<AugmentedWord>;\n\n  /**\n   * Used to render a context menu\n   */\n  selectionPrompts?: ContextualPrompt[];\n  /**\n   * Used to render in between the lines in different ways\n   */\n  selectionContextualPromptResults?: ContextualPromptResult[];\n  /**\n   * Used to render on the file in different ways\n   */\n  fileContextualPromptResults?: ContextualPromptResult[];\n\n  /**\n   * If true, the files should come from a static folder. This means the relative references should now become projectRelative. Also see `copyAllRelativeFiles`.\n   *\n   * If not true, we will use the api.\n   */\n  isStatic?: boolean;\n  /**\n   * If true, we assume not all files are present in the static folder yet. This means we need to use the api.\n   */\n  isDev?: boolean;\n  /**\n   *\n   */\n  big?: boolean;\n};"
  },
  "NamedParameters<typeof Completion>": {
    "name": "NamedParameters<typeof Completion>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-completion",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof editSubtextSubwordConfig>": {
    "name": "NamedParameters<typeof editSubtextSubwordConfig>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-editsubtextsubwordconfig",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof getContext>": {
    "name": "NamedParameters<typeof getContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcontext",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof getSubtext>": {
    "name": "NamedParameters<typeof getSubtext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsubtext",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof getWriterTypeFromContent>": {
    "name": "NamedParameters<typeof getWriterTypeFromContent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getwritertypefromcontent",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof isAugmentedWordMatch>": {
    "name": "NamedParameters<typeof isAugmentedWordMatch>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isaugmentedwordmatch",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof isTypescript>": {
    "name": "NamedParameters<typeof isTypescript>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-istypescript",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof MarkdownCompletions>": {
    "name": "NamedParameters<typeof MarkdownCompletions>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdowncompletions",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof MarkdownParsePresentation>": {
    "name": "NamedParameters<typeof MarkdownParsePresentation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownparsepresentation",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof MarkdownView>": {
    "name": "NamedParameters<typeof MarkdownView>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownview",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof MarkedToken>": {
    "name": "NamedParameters<typeof MarkedToken>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markedtoken",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof omitSpecialCharactersFromStart>": {
    "name": "NamedParameters<typeof omitSpecialCharactersFromStart>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-omitspecialcharactersfromstart",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof SpannedSentence>": {
    "name": "NamedParameters<typeof SpannedSentence>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-spannedsentence",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof SubtextContainer>": {
    "name": "NamedParameters<typeof SubtextContainer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-subtextcontainer",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof testAllContentEditableRenderComponents>": {
    "name": "NamedParameters<typeof testAllContentEditableRenderComponents>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-testallcontenteditablerendercomponents",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof trimAround>": {
    "name": "NamedParameters<typeof trimAround>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-trimaround",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof trimLeft>": {
    "name": "NamedParameters<typeof trimLeft>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-trimleft",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof TypescriptCompletions>": {
    "name": "NamedParameters<typeof TypescriptCompletions>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-typescriptcompletions",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof WriterConfigForm>": {
    "name": "NamedParameters<typeof WriterConfigForm>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-writerconfigform",
    "description": "",
    "operationName": "writer-input"
  },
  "SubtextConfig": {
    "name": "SubtextConfig",
    "slug": "TsInterface",
    "id": "subtextconfig",
    "description": "Configuration of what should be shown in the subtext",
    "operationName": "writer-types",
    "rawText": "\n\n/**\n * Configuration of what should be shown in the subtext\n */\nexport type SubtextConfig = {\n  /**\n   * TITLE: Enable\n   */\n  isEnabled?: boolean;\n\n  /**\n   * You can show multiple translations in the subtext\n   */\n  translations?: {\n    language: Language;\n    showAlternative?: boolean;\n    showPhonetic?: boolean;\n    showLatin?: boolean;\n    showTokiPona?: boolean;\n    showCommon?: boolean;\n  }[];\n\n  showEmojiTranslation?: boolean;\n\n  /**\n   * show definitions of words occuring in this paragraph\n   */\n  showDefinitionsWithPriority?: WordPriority[];\n\n  /**\n   * Related stuff related to this paragraph, e.g. other articles/markdown\n   */\n  showRelated?: SubtextRelatedThing[];\n};"
  },
  "SubwordConfig": {
    "name": "SubwordConfig",
    "slug": "TsInterface",
    "id": "subwordconfig",
    "description": "Configurate what should be shown about words",
    "operationName": "writer-types",
    "rawText": "\n\n/**\n * Configurate what should be shown about words\n */\nexport type SubwordConfig = {\n  /**\n   * TITLE: Enable\n   */\n  isEnabled?: boolean;\n  /**\n   * Optionally, make the subwords smaller for a better overview\n   */\n  subwordSize?: \"normal\" | \"mini\" | \"micro\";\n  /**\n   * show subwords for one or multiple languages\n   */\n  translations?: Language[];\n  translationsViewMode?: SubwordViewMode;\n  /**\n   * Show definition (always in tooltip)\n   */\n  showDefinition?: boolean;\n  /**\n   * Show occurrence amount\n   */\n  occurenceAmountViewMode?: SubwordViewMode;\n\n  /**\n   * Blur the word unless it's special for one reason or another. Might be useful for skimming (or maybe more)\n   */\n  blurMode?: \"disabled\" | \"special\";\n\n  /**\n   * Audio for `WordMatrix` word can be played\n   */\n  audioMode?: SubwordViewMode;\n\n  /**\n   * if \"translate\" is selected, first language from `translations` will be used\n   *\n   * `alternative` picks the alternative writing using the `WordMatrix` if available\n   *\n   * `phonetic` picks the phonetic writing using the `WordMatrix` if available\n   */\n  replaceWordMode?:\n    | \"disabled\"\n    | \"translate\"\n    | \"alternative\"\n    | \"phonetic\"\n    | \"tokiPona\"\n    | \"emoji\";\n\n  /**\n   * colour words with heat having different meanings\n   */\n  heatmapMode?: \"disabled\" | \"projectFrequency\" | \"englishFrequency\";\n};"
  },
  "TextEditingContext": {
    "name": "TextEditingContext",
    "slug": "TsInterface",
    "id": "texteditingcontext",
    "description": "",
    "operationName": "writer-input",
    "rawText": "export type TextEditingContext = {\n  wordAtPosition: string;\n  positionIndex: number;\n};"
  },
  "WriterConfigFormValue": {
    "name": "WriterConfigFormValue",
    "slug": "TsInterface",
    "id": "writerconfigformvalue",
    "description": "",
    "operationName": "writer-input",
    "rawText": "\n\nexport type WriterConfigFormValue = [\n  subtextConfig: SubtextConfig,\n  subwordConfig: SubwordConfig\n];"
  },
  "SubtextRelatedThing": {
    "name": "SubtextRelatedThing",
    "slug": "TsInterface",
    "id": "subtextrelatedthing",
    "description": "",
    "operationName": "writer-types",
    "rawText": "\n\nexport type SubtextRelatedThing = {\n  type: \"image\" | \"asset\" | \"pages\" | \"data\" | \"code\";\n  quantity: \"single\" | \"short\" | \"all\";\n};"
  },
  "SubwordViewMode": {
    "name": "SubwordViewMode",
    "slug": "TsInterface",
    "id": "subwordviewmode",
    "description": "",
    "operationName": "writer-types",
    "rawText": "\n\nexport type SubwordViewMode = \"disabled\" | \"tooltip\" | \"context\" | \"subword\";"
  },
  "WordPriority": {
    "name": "WordPriority",
    "slug": "TsInterface",
    "id": "wordpriority",
    "description": "",
    "operationName": "language-types",
    "rawText": "\n\n/**\n *\n */\nexport type WordPriority = \"critical\" | \"high\" | \"medium\" | \"low\";"
  },
  "WriterViewEnum": {
    "name": "WriterViewEnum",
    "slug": "TsInterface",
    "id": "writerviewenum",
    "description": "",
    "operationName": "writer-types",
    "rawText": "\n\nexport type WriterViewEnum =\n  | \"config\"\n  | \"view\"\n  | \"edit\"\n  | \"presentation\"\n  | \"frontmatter\"\n  | \"todoOffers\"\n  | \"postable\"\n  | \"shortStudio\"\n  | \"prompts\"\n  | \"prompt-results\";"
  },
  "NamedParameters<typeof getLight>": {
    "name": "NamedParameters<typeof getLight>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getlight",
    "description": "",
    "operationName": "get-light"
  },
  "NamedParameters<typeof getLocation>": {
    "name": "NamedParameters<typeof getLocation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getlocation",
    "description": "",
    "operationName": "get-location"
  },
  "NamedParameters<typeof fetchWithTimeout>": {
    "name": "NamedParameters<typeof fetchWithTimeout>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fetchwithtimeout",
    "description": "",
    "operationName": "is-online"
  },
  "NamedParameters<typeof isOnline>": {
    "name": "NamedParameters<typeof isOnline>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isonline",
    "description": "",
    "operationName": "is-online"
  },
  "NamedParameters<typeof calculateBbqAbility>": {
    "name": "NamedParameters<typeof calculateBbqAbility>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-calculatebbqability",
    "description": "",
    "operationName": "weather-sensor"
  },
  "NamedParameters<typeof calculateCloudyness>": {
    "name": "NamedParameters<typeof calculateCloudyness>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-calculatecloudyness",
    "description": "",
    "operationName": "weather-sensor"
  },
  "NamedParameters<typeof calculateCodeFromNatureAbility>": {
    "name": "NamedParameters<typeof calculateCodeFromNatureAbility>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-calculatecodefromnatureability",
    "description": "",
    "operationName": "weather-sensor"
  },
  "NamedParameters<typeof calculateDresscode>": {
    "name": "NamedParameters<typeof calculateDresscode>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-calculatedresscode",
    "description": "",
    "operationName": "weather-sensor"
  },
  "NamedParameters<typeof calculateKiteability>": {
    "name": "NamedParameters<typeof calculateKiteability>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-calculatekiteability",
    "description": "",
    "operationName": "weather-sensor"
  },
  "NamedParameters<typeof calculateRainyness>": {
    "name": "NamedParameters<typeof calculateRainyness>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-calculaterainyness",
    "description": "",
    "operationName": "weather-sensor"
  },
  "NamedParameters<typeof calculateSunnyness>": {
    "name": "NamedParameters<typeof calculateSunnyness>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-calculatesunnyness",
    "description": "",
    "operationName": "weather-sensor"
  },
  "NamedParameters<typeof calculateWindyness>": {
    "name": "NamedParameters<typeof calculateWindyness>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-calculatewindyness",
    "description": "",
    "operationName": "weather-sensor"
  },
  "NamedParameters<typeof fetchWeatherStormGlass>": {
    "name": "NamedParameters<typeof fetchWeatherStormGlass>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fetchweatherstormglass",
    "description": "",
    "operationName": "weather-sensor"
  },
  "NamedParameters<typeof fetchWeatherTommorowIOApi>": {
    "name": "NamedParameters<typeof fetchWeatherTommorowIOApi>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fetchweathertommorowioapi",
    "description": "",
    "operationName": "weather-sensor"
  },
  "NamedParameters<typeof getCustomWeatherData>": {
    "name": "NamedParameters<typeof getCustomWeatherData>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcustomweatherdata",
    "description": "",
    "operationName": "weather-sensor"
  },
  "AppShell": {
    "name": "AppShell",
    "slug": "TsInterface",
    "id": "appshell",
    "description": "",
    "operationName": "bundle-types",
    "rawText": "\n\nexport type AppShell =\n  | \"web\"\n  | \"app\"\n  | \"computer\"\n  | \"vscode\"\n  | \"browser\"\n  | \"docusaurus\";"
  },
  "EnvironmentVariableObject": {
    "name": "EnvironmentVariableObject",
    "slug": "TsInterface",
    "id": "environmentvariableobject",
    "description": "",
    "operationName": "bundle-types",
    "rawText": "\n\nexport interface EnvironmentVariableObject {\n  [key: string]: Json;\n}"
  },
  "FinalCreateBundleConfig": {
    "name": "FinalCreateBundleConfig",
    "slug": "TsInterface",
    "id": "finalcreatebundleconfig",
    "description": "CreateBundleConfig after applying the defaults",
    "operationName": "bundle-types",
    "rawText": "\n\n/**\n * CreateBundleConfig after applying the defaults\n */\nexport type FinalCreateBundleConfig = CreateBundleConfig &\n  Required<Pick<CreateBundleConfig, \"informationStrategy\" | \"foldersFromRepo\">>;"
  },
  "FinalCustomisableBundleConfig": {
    "name": "FinalCustomisableBundleConfig",
    "slug": "TsInterface",
    "id": "finalcustomisablebundleconfig",
    "description": "",
    "operationName": "bundle-types",
    "rawText": "\n\nexport type FinalCustomisableBundleConfig = CustomisableBundleConfig &\n  Required<\n    Pick<CustomisableBundleConfig, \"description\" | \"debug\" | \"branchName\">\n  >;"
  },
  "FrontBackBundle": {
    "name": "FrontBackBundle",
    "slug": "TsInterface",
    "id": "frontbackbundle",
    "description": "This type can specify a frontend and backend that belong to each other. it doesn't include all operations that the ui or server are dependent on, they are calculated separately",
    "operationName": "bundle-types",
    "rawText": "\n\n/**\n * This type can specify a frontend and backend that belong to each other. it doesn't include all operations that the ui or server are dependent on, they are calculated separately\n */\nexport interface FrontBackBundle extends SlugModelType {\n  /**\n   * any operation names that are not necesarily dependencies of the named front-back bundle but still need to be available.\n   */\n  operations?: OperationPrivacy[];\n  /**\n   * (optional) main shared ui package of the frontend\n   */\n  uiOperationName?: string;\n  /**\n   * which app shell(s) or app operations are there for the frontend?\n   */\n  appShellOperationNames?: string[];\n\n  /** operation name for server, if this UI is connected to one */\n  serverOperationName?: string;\n\n  /**\n   * if there is a ui and it has a web-shell, and it is deployed somewhere into production, add the deployed domain here.\n   */\n  productionWebUrl?: string;\n\n  /**\n   * if there is one, it should be specified here (without trailing slash)\n   */\n  productionApiUrl?: string;\n\n  /**\n   * if this is provided, all endpoints require this auth token to be provided, or the endpoints do not work\n   *\n   * if you wish to have a more extensive authentication method for your endpoints, make sure to create your own auth layer\n   */\n  endpointsAuthToken?: string;\n}"
  },
  "InformationStrategy": {
    "name": "InformationStrategy",
    "slug": "TsInterface",
    "id": "informationstrategy",
    "description": "push (default): take needed information from project and push to bundle (removing the existing info)\n\npullReplace: pull bundle and keep its information intact, not taking anything new from the OS, replacing all the information we had from these models in the OS\n\npullMerge: pull bundle and use its information in conjunction with the information we had in the OS. This option will merge both information sources, removing duplicate IDs\n\nignore: don't put any data in the bundle!",
    "operationName": "bundle-types",
    "rawText": "/**\n * push (default): take needed information from project and push to bundle (removing the existing info)\n *\n * pullReplace: pull bundle and keep its information intact, not taking anything new from the OS, replacing all the information we had from these models in the OS\n *\n * pullMerge: pull bundle and use its information in conjunction with the information we had in the OS. This option will merge both information sources, removing duplicate IDs\n *\n * ignore: don't put any data in the bundle!\n *\n */\nexport type InformationStrategy =\n  | \"ignore\"\n  | \"push\"\n  | \"pullReplace\"\n  | \"pullMerge\";"
  },
  "OperationName": {
    "name": "OperationName",
    "slug": "TsInterface",
    "id": "operationname",
    "description": "later we can make this an enum! it can be auto-generated along with enums for the operation paths, and more things alike.\n\nif it's an enum it will automatically be possible to select a value from it in the simplified schema form :D\n\nbesides simply having OperationName, we can have specific operation classification operation names:\n\n- JsOperationName (js)\n- NodeOperationName (node)\n- ServerOperationName (server)\n- AppShellOperationName (web, app, etc.)\n- UiOperationName (ui-es6 and ui-es5)",
    "operationName": "bundle-types",
    "rawText": "/**\n * later we can make this an enum! it can be auto-generated along with enums for the operation paths, and more things alike.\n *\n * if it's an enum it will automatically be possible to select a value from it in the simplified schema form :D\n *\n * besides simply having OperationName, we can have specific operation classification operation names:\n *\n * - JsOperationName (js)\n * - NodeOperationName (node)\n * - ServerOperationName (server)\n * - AppShellOperationName (web, app, etc.)\n * - UiOperationName (ui-es6 and ui-es5)\n */\nexport type OperationName = string;"
  },
  "ProjectRelativeFilePath": {
    "name": "ProjectRelativeFilePath",
    "slug": "TsInterface",
    "id": "projectrelativefilepath",
    "description": "",
    "operationName": "bundle-types",
    "rawText": "\nexport type ProjectRelativeFilePath = string;"
  },
  "ProjectRelativeFolderPath": {
    "name": "ProjectRelativeFolderPath",
    "slug": "TsInterface",
    "id": "projectrelativefolderpath",
    "description": "later this could be known by the frontend so it will render a ui to select a folder\n\nWe need to figure out how we can know all type types in between when getting the type definition schema, not only the final type. If I'm lucky there is a way to find it as a #ref in a consistent way.",
    "operationName": "bundle-types",
    "rawText": "\n\n/**\n * later this could be known by the frontend so it will render a ui to select a folder\n *\n * We need to figure out how we can know all type types in between when getting the type definition schema, not only the final type. If I'm lucky there is a way to find it as a #ref in a consistent way.\n */\nexport type ProjectRelativeFolderPath = string;"
  },
  "ServerOperationName": {
    "name": "ServerOperationName",
    "slug": "TsInterface",
    "id": "serveroperationname",
    "description": "",
    "operationName": "bundle-types",
    "rawText": "\nexport type ServerOperationName = string;"
  },
  "CommentTypeObject": {
    "name": "CommentTypeObject",
    "slug": "TsInterface",
    "id": "commenttypeobject",
    "description": "Every `CommentType` can be a key in the `SimplifiedSchema`, if available.",
    "operationName": "code-types",
    "rawText": "\n\n/**\n * Every `CommentType` can be a key in the `SimplifiedSchema`, if available.\n */\nexport type CommentTypeObject = {\n  [commentType in CommentType]?: string;\n};"
  },
  "CommitInfo": {
    "name": "CommitInfo",
    "slug": "TsInterface",
    "id": "commitinfo",
    "description": "",
    "operationName": "code-types",
    "rawText": "export type CommitInfo = {\n  /**\n   * unique commit sha\n   */\n  commitSha: string;\n  committedAt?: number;\n  commitMessage: string;\n};"
  },
  "CompilerOptions": {
    "name": "CompilerOptions",
    "slug": "TsInterface",
    "id": "compileroptions",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport interface CompilerOptions {\n  allowJs?: boolean;\n  allowSyntheticDefaultImports?: boolean;\n  allowUmdGlobalAccess?: boolean;\n  allowUnreachableCode?: boolean;\n  allowUnusedLabels?: boolean;\n  alwaysStrict?: boolean;\n  baseUrl?: string;\n  charset?: string;\n  checkJs?: boolean;\n  declaration?: boolean;\n  declarationMap?: boolean;\n  emitDeclarationOnly?: boolean;\n  declarationDir?: string;\n  disableSizeLimit?: boolean;\n  disableSourceOfProjectReferenceRedirect?: boolean;\n  disableSolutionSearching?: boolean;\n  disableReferencedProjectLoad?: boolean;\n  downlevelIteration?: boolean;\n  emitBOM?: boolean;\n  emitDecoratorMetadata?: boolean;\n  exactOptionalPropertyTypes?: boolean;\n  experimentalDecorators?: boolean;\n  forceConsistentCasingInFileNames?: boolean;\n  importHelpers?: boolean;\n  importsNotUsedAsValues?: ImportsNotUsedAsValues;\n  inlineSourceMap?: boolean;\n  inlineSources?: boolean;\n  isolatedModules?: boolean;\n  jsx?: JsxEmit;\n  keyofStringsOnly?: boolean;\n  lib?: string[];\n  locale?: string;\n  mapRoot?: string;\n  maxNodeModuleJsDepth?: number;\n  module?: ModuleKind;\n  moduleResolution?: ModuleResolutionKind;\n  moduleSuffixes?: string[];\n  moduleDetection?: ModuleDetectionKind;\n  newLine?: NewLineKind;\n  noEmit?: boolean;\n  noEmitHelpers?: boolean;\n  noEmitOnError?: boolean;\n  noErrorTruncation?: boolean;\n  noFallthroughCasesInSwitch?: boolean;\n  noImplicitAny?: boolean;\n  noImplicitReturns?: boolean;\n  noImplicitThis?: boolean;\n  noStrictGenericChecks?: boolean;\n  noUnusedLocals?: boolean;\n  noUnusedParameters?: boolean;\n  noImplicitUseStrict?: boolean;\n  noPropertyAccessFromIndexSignature?: boolean;\n  assumeChangesOnlyAffectDirectDependencies?: boolean;\n  noLib?: boolean;\n  noResolve?: boolean;\n  noUncheckedIndexedAccess?: boolean;\n  out?: string;\n  outDir?: string;\n  outFile?: string;\n  paths?: MapLike<string[]>;\n  preserveConstEnums?: boolean;\n  noImplicitOverride?: boolean;\n  preserveSymlinks?: boolean;\n  preserveValueImports?: boolean;\n  project?: string;\n  reactNamespace?: string;\n  jsxFactory?: string;\n  jsxFragmentFactory?: string;\n  jsxImportSource?: string;\n  composite?: boolean;\n  incremental?: boolean;\n  tsBuildInfoFile?: string;\n  removeComments?: boolean;\n  rootDir?: string;\n  rootDirs?: string[];\n  skipLibCheck?: boolean;\n  skipDefaultLibCheck?: boolean;\n  sourceMap?: boolean;\n  sourceRoot?: string;\n  strict?: boolean;\n  strictFunctionTypes?: boolean;\n  strictBindCallApply?: boolean;\n  strictNullChecks?: boolean;\n  strictPropertyInitialization?: boolean;\n  stripInternal?: boolean;\n  suppressExcessPropertyErrors?: boolean;\n  suppressImplicitAnyIndexErrors?: boolean;\n  target?: ScriptTarget;\n  traceResolution?: boolean;\n  useUnknownInCatchVariables?: boolean;\n  resolveJsonModule?: boolean;\n  types?: string[];\n  /** Paths used to compute primary types search locations */\n  typeRoots?: string[];\n  esModuleInterop?: boolean;\n  useDefineForClassFields?: boolean;\n  [option: string]: any | undefined;\n}"
  },
  "ContributorPersonInfo": {
    "name": "ContributorPersonInfo",
    "slug": "TsInterface",
    "id": "contributorpersoninfo",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport type ContributorPersonInfo = {\n  /**\n   * NPM convention, name of the contributor\n   */\n  name: string;\n  /**\n   * NPM convention, url with more info of the contributor\n   */\n  url?: string;\n  /**\n   * NPM convention, email of the contributor\n   */\n  email?: string;\n\n  /**\n   * Relative amount of estimated contribution to this operation, should be a number between 0 and 1\n   */\n  contributionAmount?: number;\n};"
  },
  "DatasetConfig": {
    "name": "DatasetConfig",
    "slug": "TsInterface",
    "id": "datasetconfig",
    "description": "The part of dataset that can be used in certain functions",
    "operationName": "code-types",
    "rawText": "\n\n/**\n * The part of dataset that can be used in certain functions\n */\nexport interface DatasetConfig extends DatasetConfigShape {\n  /**\n   * Filters are applied after each other\n   */\n  filter?: DatasetFilter[];\n\n  /**\n   *\n   */\n  sort?: DatasetSort[];\n\n  /**\n   * Specify a max amount of items n\n   */\n  maxRows?: number;\n\n  /**\n   * If specified, slices the sorted array to omit the first n items;\n   */\n  startFromIndex?: number;\n\n  /**\n   * If specified, will only include these parameter keys of the model object. Otherwise all keys will be taken\n   */\n  objectParameterKeys?: string[];\n\n  /**\n   * If specified, will omit these keys when creating the dataset\n   */\n  ignoreObjectParameterKeys?: string[];\n}"
  },
  "DatasetConfigKey": {
    "name": "DatasetConfigKey",
    "slug": "TsInterface",
    "id": "datasetconfigkey",
    "description": "",
    "operationName": "code-types",
    "rawText": "\nexport type DatasetConfigKey = typeof datasetConfigKeys[number];"
  },
  "DatasetConfigShape": {
    "name": "DatasetConfigShape",
    "slug": "TsInterface",
    "id": "datasetconfigshape",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport type DatasetConfigShape = { [key in DatasetConfigKey]?: any };"
  },
  "DatasetFilter": {
    "name": "DatasetFilter",
    "slug": "TsInterface",
    "id": "datasetfilter",
    "description": "Can be better, see https://www.w3schools.com/js/js_comparisons.asp",
    "operationName": "code-types",
    "rawText": "\n/**\n * Can be better, see https://www.w3schools.com/js/js_comparisons.asp\n */\nexport type DatasetFilter = {\n  objectParameterKey: string;\n  /**\n   * This will sometines need to be casted\n   */\n  value: string;\n  /**\n   * Uses type equality\n   */\n  operator: DatasetFilterOperator;\n  /**\n   * TODO: Maybe add possibility to use a sort function from the SDK\n   */\n  filterFunctionName?: string;\n};"
  },
  "DatasetFilterOperator": {
    "name": "DatasetFilterOperator",
    "slug": "TsInterface",
    "id": "datasetfilteroperator",
    "description": "",
    "operationName": "code-types",
    "rawText": "\nexport type DatasetFilterOperator = typeof datasetFilterOperatorConst[number];"
  },
  "DatasetSort": {
    "name": "DatasetSort",
    "slug": "TsInterface",
    "id": "datasetsort",
    "description": "Sort by comparing the two values using the `Array.sort` method and Greater than and Less than operators.",
    "operationName": "db-crud"
  },
  "ExplorationDetails": {
    "name": "ExplorationDetails",
    "slug": "TsInterface",
    "id": "explorationdetails",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport type ExplorationDetails = {\n  success?: boolean;\n  response?: string;\n  //\n  markdown?: any; //MarkdownParse;\n  pathMetaData?: PathMetaData;\n  operations?: Operation[];\n  index: TsInterface[];\n} & Partial<TypescriptIndex>;"
  },
  "FileContentInfo": {
    "name": "FileContentInfo",
    "slug": "TsInterface",
    "id": "filecontentinfo",
    "description": "Stuff you can find by reading the file",
    "operationName": "markdown-types"
  },
  "FolderExploration": {
    "name": "FolderExploration",
    "slug": "TsInterface",
    "id": "folderexploration",
    "description": "suggested type for menu is FolderExploration[]\n\nNB: recursive!",
    "operationName": "code-types",
    "rawText": "\n/**\n * suggested type for menu is FolderExploration[]\n *\n * NB: recursive!\n */\nexport type FolderExploration = {\n  /**\n   * folder is a regular folder outside of operations\n   *\n   * operation is a folder that is the root of an operation\n   *\n   * operationFolder is a folder inside of an operation\n   *\n   * other things are self-explanatory\n   */\n  type:\n    | \"folder\"\n    | \"operation\"\n    | \"operationFolder\"\n    | \"markdown\"\n    | \"typescript\"\n    | \"function\"\n    | \"interface\"\n    | \"variable\";\n  name: string;\n  /** path to the folder, operation, operationFolder, or file. functions, interfaces or variables direct to the file they are defined in */\n  relativeProjectPath: string;\n  /**\n   * Every FolderExploration has children, which are simply the files/folders that can be found in there. The children of files are functions, interfaces and variables for typescript files. Markdownfiles don't get any children (although we could childify the outline of the file, maybe, later...)\n   */\n  children?: FolderExploration[];\n};"
  },
  "FunctionClassification": {
    "name": "FunctionClassification",
    "slug": "TsInterface",
    "id": "functionclassification",
    "description": "- `react`: The core library that should always be used that wraps react and react native.\n\n- `dumb`: Presentational components that only care about how things look, and have no idea about the type of information that they will contain (**data-agnostic**), nor their context they're used in.\n\n- `smart`: Presentational components that may contain getters and setters for global state. This means they're still easy enough to set up, but\n\n- `wise`: stateful components that use the backend as well to do things. for example, `simplified-schema-form`\n\n- `genius`: blocks of components that have certain functionality. Example: `file-writer` or `crud`",
    "operationName": "code-types",
    "rawText": "/**\n- `react`: The core library that should always be used that wraps react and react native.\n\n- `dumb`: Presentational components that only care about how things look, and have no idea about the type of information that they will contain (**data-agnostic**), nor their context they're used in.\n\n- `smart`: Presentational components that may contain getters and setters for global state. This means they're still easy enough to set up, but\n\n- `wise`: stateful components that use the backend as well to do things. for example, `simplified-schema-form`\n\n- `genius`: blocks of components that have certain functionality. Example: `file-writer` or `crud`\n*/\nexport type FunctionClassification =\n  | \"wise\"\n  | \"dumb\"\n  | \"smart\"\n  | \"genius\"\n  | \"react-with-native\"\n  | \"cli\"\n  | \"test\";"
  },
  "FunctionParameter": {
    "name": "FunctionParameter",
    "slug": "TsInterface",
    "id": "functionparameter",
    "description": "",
    "operationName": "db-crud"
  },
  "ImportClassification": {
    "name": "ImportClassification",
    "slug": "TsInterface",
    "id": "importclassification",
    "description": "node: node core packages like fs and path\n\nreact: react standard packages like react, react-native, expo, react-dom, etc.\n\npackage: packages from npm that are not classified as operations\n\noperation: operations from our monorepo\n\ninternal: imports from other places in the same operation\n\nNB: don't confuse this with OperationClassification",
    "operationName": "code-types",
    "rawText": "\n\n/**\n * node: node core packages like fs and path\n *\n * react: react standard packages like react, react-native, expo, react-dom, etc.\n *\n * package: packages from npm that are not classified as operations\n *\n * operation: operations from our monorepo\n *\n * internal: imports from other places in the same operation\n *\n * NB: don't confuse this with OperationClassification\n */\nexport type ImportClassification =\n  | \"node\"\n  | \"react\"\n  | \"package\"\n  | \"operation\"\n  | \"internal\";"
  },
  "IndexModels": {
    "name": "IndexModels",
    "slug": "TsInterface",
    "id": "indexmodels",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport type IndexModels = {\n  TsBuildError: TsBuildError;\n  TsLintWarning: TsLintWarning;\n  TsFunction: TsFunction;\n  TsVariable: TsVariable;\n  TsInterface: TsInterface;\n  TsComment: TsComment;\n  TsImport: TsImport;\n  TsExport: TsExport;\n};"
  },
  "JSONSchema7Type": {
    "name": "JSONSchema7Type",
    "slug": "TsInterface",
    "id": "jsonschema7type",
    "description": "Primitive type",
    "operationName": "code-types"
  },
  "MaybeInteface": {
    "name": "MaybeInteface",
    "slug": "TsInterface",
    "id": "maybeinteface",
    "description": "at some point in processing we need this interface where definition can also be null",
    "operationName": "index-typescript"
  },
  "ModelInfo": {
    "name": "ModelInfo",
    "slug": "TsInterface",
    "id": "modelinfo",
    "description": "used to show a list of models available in a menu structure",
    "operationName": "code-types",
    "rawText": "/**\n * used to show a list of models available in a menu structure\n */\nexport type ModelInfo = {\n  name: string;\n  slug: string;\n  rows: number;\n};"
  },
  "ModelView": {
    "name": "ModelView",
    "slug": "TsInterface",
    "id": "modelview",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport type ModelView = typeof modelViews[number];"
  },
  "ModelViewEnum": {
    "name": "ModelViewEnum",
    "slug": "TsInterface",
    "id": "modelviewenum",
    "description": "Models should be able to be shown in multiple different views:\n\n- Table: useful to show models with much details\n- Grid: useful to show models with a visual aspect and less details\n- Timeline: useful to show text-related models\n- Tree: useful to show a hierarchy",
    "operationName": "code-types",
    "rawText": "\n/**\n * Models should be able to be shown in multiple different views:\n *\n * - Table: useful to show models with much details\n * - Grid: useful to show models with a visual aspect and less details\n * - Timeline: useful to show text-related models\n * - Tree: useful to show a hierarchy\n */\nexport type ModelViewEnum = typeof modelViews[number][\"view\"];"
  },
  "NamedParameters<typeof abc>": {
    "name": "NamedParameters<typeof abc>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-abc",
    "description": "",
    "operationName": "code-types"
  },
  "NamedParameters<typeof getExamples>": {
    "name": "NamedParameters<typeof getExamples>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getexamples",
    "description": "",
    "operationName": "code-types"
  },
  "NamedParameters<typeof getFunctionExersize>": {
    "name": "NamedParameters<typeof getFunctionExersize>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfunctionexersize",
    "description": "",
    "operationName": "code-types"
  },
  "OperationPathParse": {
    "name": "OperationPathParse",
    "slug": "TsInterface",
    "id": "operationpathparse",
    "description": "",
    "operationName": "index-typescript"
  },
  "OperationRepositoryInfo": {
    "name": "OperationRepositoryInfo",
    "slug": "TsInterface",
    "id": "operationrepositoryinfo",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport type OperationRepositoryInfo = {\n  //default NPM stuff\n  type?: string;\n  url: string;\n  directory?: string;\n\n  // Indexed Operation-stuff that we added\n  lastPullTimeAt?: number;\n  lastCommitInfo?: CommitInfo;\n  htmlUrl?: string;\n  collaborators?: string[];\n  forksCount?: number;\n  stargazersCount?: number;\n  watchersCount?: number;\n  openIssuesCount?: number;\n  size?: number;\n  visibility?: string;\n  defaultBranch?: string;\n};"
  },
  "PackageInfoObject": {
    "name": "PackageInfoObject",
    "slug": "TsInterface",
    "id": "packageinfoobject",
    "description": "",
    "operationName": "migrate-operation-model",
    "rawText": "\n\nexport type PackageInfoObject = {\n  [key: string]: string;\n};"
  },
  "ParameterName": {
    "name": "ParameterName",
    "slug": "TsInterface",
    "id": "parametername",
    "description": "",
    "operationName": "language-types"
  },
  "PathMetaData": {
    "name": "PathMetaData",
    "slug": "TsInterface",
    "id": "pathmetadata",
    "description": "All interesting metadata about any path (files and folders)",
    "operationName": "code-types",
    "rawText": "\n\n/**\n * All interesting metadata about any path (files and folders)\n */\nexport type PathMetaData = FileContentInfo & PathParse & PathStats;"
  },
  "PathParse": {
    "name": "PathParse",
    "slug": "TsInterface",
    "id": "pathparse",
    "description": "object to represent a folder or file path in different ways\n\nNB: doesn't include the absolute path so the indexes can be exported easily witout creating incorrect paths",
    "operationName": "code-types",
    "rawText": "\n/**\n * object to represent a folder or file path in different ways\n *\n * NB: doesn't include the absolute path so the indexes can be exported easily witout creating incorrect paths\n */\nexport type PathParse = {\n  /**\n   * relative file or folder path from the project root\n   */\n  relativePathFromProjectRoot: string;\n};"
  },
  "PathStats": {
    "name": "PathStats",
    "slug": "TsInterface",
    "id": "pathstats",
    "description": "Information which can be found by fs.stat",
    "operationName": "markdown-types"
  },
  "PerformanceItem": {
    "name": "PerformanceItem",
    "slug": "TsInterface",
    "id": "performanceitem",
    "description": "",
    "operationName": "measure-performance",
    "rawText": "export type PerformanceItem = {\n  label: string;\n  durationMs: number;\n};"
  },
  "Schema": {
    "name": "Schema",
    "slug": "TsInterface",
    "id": "schema",
    "description": "schema type interface we use in TsInterface\n\nNB: don't export because this would make this type exist twice.",
    "operationName": "schema-util",
    "rawText": "\n\n/**\n * schema type interface we use in TsInterface\n *\n * NB: don't export because this would make this type exist twice.\n */\ntype Schema = TsInterface[\"type\"][\"typeDefinition\"];"
  },
  "SimplifiedSchemaItem": {
    "name": "SimplifiedSchemaItem",
    "slug": "TsInterface",
    "id": "simplifiedschemaitem",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport type SimplifiedSchemaItem = {\n  /**\n   * name in case of it being a reference, otherwise null\n   */\n  name: string | null;\n  schema: SimplifiedSchema;\n};"
  },
  "SizeSummary": {
    "name": "SizeSummary",
    "slug": "TsInterface",
    "id": "sizesummary",
    "description": "type interface that can be used to summarize multiple files",
    "operationName": "code-types",
    "rawText": "/**\n * type interface that can be used to summarize multiple files\n */\nexport type SizeSummary = {\n  /**\n   * if this is about multiple files, the number of files is specified here\n   */\n  numberOfFiles?: number;\n  /**\n   * amount of characters\n   */\n  characters: number;\n  /**\n   * amount of lines\n   */\n  lines: number;\n  /**\n   * amount of bytes\n   */\n  bytes: number;\n  /**\n   * rounded, amount of lines per file (averaged)\n   */\n  linesPerFile: number;\n  /**\n   * rounded, amount of characters per line (averaged)\n   */\n  charactersPerLine: number;\n  /**\n   * rounded, amount of bytes per character\n   */\n  bytesPerCharacter: number;\n};"
  },
  "TsBuildError": {
    "name": "TsBuildError",
    "slug": "TsInterface",
    "id": "tsbuilderror",
    "description": "",
    "operationName": "cleanup-typescript-database"
  },
  "TsComment": {
    "name": "TsComment",
    "slug": "TsInterface",
    "id": "tscomment",
    "description": "comments are basically one-or-multi-line human content inside of typescript files, so it's a very important to do something useful with them.\n\n\nThe convention should be that single-line comments should start with that. This then becomes the type of the comment. You can also put multiple prefixes at the start.\n\nExample:\n\n`// TODO: NB: this is a todo but its also important`\n\nMultiline comments can also have one or multiple types in their text, but they should not be split into multiple comments as the context could be needed some times.\n\n\n\nThere are also some other things comments can say about statements, but these should be inside the frontmatter, and are much more flexible.\n- classified[0-10] indicating level of classification. This way I can share subsets of the codebase, maybe...\n- privacy\n- ...?\n\nNB: with the current setup we can also parse `.md` files as being a TsComment, keep it that way!\n\nNB: comments are part of the code, so they should always be in English!",
    "operationName": "cleanup-typescript-database"
  },
  "TsExport": {
    "name": "TsExport",
    "slug": "TsInterface",
    "id": "tsexport",
    "description": "",
    "operationName": "cleanup-typescript-database"
  },
  "TsFunctionFrontmatterConfig": {
    "name": "TsFunctionFrontmatterConfig",
    "slug": "TsInterface",
    "id": "tsfunctionfrontmatterconfig",
    "description": "Everything you can do with frontmatter on a TsFunction",
    "operationName": "code-types",
    "rawText": "\n\n/**\n * Everything you can do with frontmatter on a TsFunction\n */\nexport type TsFunctionFrontmatterConfig = {\n  /**\n   * Other keys in frontmatter that are group names, can be added here\n   */\n  groupAuthorization: { [groupName: string]: string };\n  /**\n   * for all exported functions in node operations, true by default\n   * false for others\n   *\n   * can be overwritten using frontmatter\n   */\n  isApiExposed: boolean;\n  /**\n   * whether or not the function can be cached (relies on cache invalidation)\n   */\n  canCache?: boolean;\n\n  /**\n   You can specify `runEveryPeriod` in your frontmatter of a function. This will set `runEveryPeriod` for the TsFunction. This is used by `function-server`: it will execute CRON-jobs that run these things on those periods.\n\n   Will only work if the function takes no arguments.\n   */\n  runEveryPeriod?: RunEveryPeriodEnum;\n\n  /**\n   * Indexed from frontmatter `price`\n   */\n  price?: Price;\n\n  classification?: FunctionClassification;\n};"
  },
  "TsFunctionIndex": {
    "name": "TsFunctionIndex",
    "slug": "TsInterface",
    "id": "tsfunctionindex",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport type TsFunctionIndex = {\n  /**\n   * If you give a function a type explicitly on its declaration, this type will be set here.\n   */\n  explicitTypeName?: string;\n  /**\n   * The function is immediately exported upon creation. If the os dev tools are being used, this means it is also exported from the operation\n   */\n  isExported: boolean;\n\n  /**\n   * parsed comment from doc-comment\n   */\n  description?: Markdown;\n\n  /**\n   * raw text of the function\n   */\n  rawText?: string;\n\n  /**\n   * all comments found in a function and the node that they belong to\n   */\n  commentsInside: TsComment[];\n\n  /**\n   * return type JSON Schema definition\n   */\n  returnType: TypeInfo;\n\n  /**\n   * parameters the function takes as its arguments, if any\n   */\n  parameters?: FunctionParameter[];\n\n  /**\n   * size of this function (comments + code)\n   */\n  size: SizeSummary;\n\n  /**\n   * size of the comments of this function (including surrounding comments)\n   */\n  commentSize?: SizeSummary;\n  /**\n   * size of the code inside the function (without comments)\n   */\n  codeSize?: SizeSummary;\n\n  /**\n   * tells you the size of itself and all its dependencies that are used that are also part of an operation, recursively\n   */\n  cumulativeSize?: SizeSummary;\n  cumulativeCommentSize?: SizeSummary;\n  cumulativeCodeSize?: SizeSummary;\n\n  // Code quality indexes\n\n  /**\n   * maximum amount of times indedented in this function\n   *\n   * good for determining the complexity and finding code that can be simplified/destructured into smaller pieces\n   */\n  maxIndentationDepth: number;\n\n  /**\n   * finds all files that import this function\n   *\n   * NB: this is not indexed because this information has nothing to do with the operation itself, but the exposure to the broader monorepo. This is calculated on the fly.\n   */\n  dependantFiles?: string[];\n};"
  },
  "TsIndexModelType": {
    "name": "TsIndexModelType",
    "slug": "TsInterface",
    "id": "tsindexmodeltype",
    "description": "identifier of any index type interface",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * identifier of any index type interface\n */\nexport interface TsIndexModelType extends AnyModelType {\n  /**\n   * unique id of the model\n   */\n  id: string;\n  /**\n   * name (identifier) of the model\n   */\n  name: string;\n  /**\n   * kebab-case variant of the name\n   */\n  slug: string;\n  /**\n   * relative file path from the operation that this indexed instance is referencing to\n   *\n   * e.g. src/general.ts\n   *\n   * (no preceding slash)\n   */\n  operationRelativeTypescriptFilePath: string;\n}"
  },
  "TsLintWarning": {
    "name": "TsLintWarning",
    "slug": "TsInterface",
    "id": "tslintwarning",
    "description": "",
    "operationName": "cleanup-typescript-database"
  },
  "TypeCoverage": {
    "name": "TypeCoverage",
    "slug": "TsInterface",
    "id": "typecoverage",
    "description": "quantification of coverage of the specified type or subtypes in our database.",
    "operationName": "code-types",
    "rawText": "\n/**\n * quantification of coverage of the specified type or subtypes in our database.\n */\nexport type TypeCoverage = number;"
  },
  "TypeInfo": {
    "name": "TypeInfo",
    "slug": "TsInterface",
    "id": "typeinfo",
    "description": "all info that should always be collected when indexing any type interface",
    "operationName": "code-types",
    "rawText": "\n\n/**\n * all info that should always be collected when indexing any type interface\n */\nexport type TypeInfo = {\n  /** JSON schema definition of a type interface\n   *\n   *\n   * Some info about the Schema:\n   *\n   * - if the type is an object, there should be properties\n   * - if the type is an array, there should be items\n   */\n  typeDefinition: Schema | undefined;\n  simplifiedSchema?: SimplifiedSchema;\n  /** if the type is an object, this is true. false if it's an array */\n  isObject: boolean;\n  /** if the type is an array, this is true */\n  isArray: boolean;\n  /** if it's a primitive type like \"string\", \"number\", \"boolean\", \"null\" | \"undefined\" */\n  isPrimitive: boolean;\n  /** will be true for any primitive conjunction types */\n  isEnum: boolean;\n  /** will be true for string conjunction types */\n  isEnumLiteral: boolean;\n  typeCoverage: TypeCoverage;\n  /** raw type string */\n  rawType: string;\n};"
  },
  "TypescriptFile": {
    "name": "TypescriptFile",
    "slug": "TsInterface",
    "id": "typescriptfile",
    "description": "IDEA: What if we could make a custom db storage method for a typescript file, so you can read and write typescript with the database?\n\nThe first thing I can do, is to generate all typescript stuff using a model like this:\n\nLater, I can read a typescript file with a rust parser to get it into this model again.\n\nThis is actually super useful for metacoding and coding GUI's\n\nAlso a great start for making my own programming language ;)\n\n\nThere are multiple ways of describing a typescript file I guess. This is one of them. Another one could be a definition where you put the required context in the statements and types themselves.",
    "operationName": "code-types",
    "rawText": "\n\n/**\n * IDEA: What if we could make a custom db storage method for a typescript file, so you can read and write typescript with the database?\n *\n * The first thing I can do, is to generate all typescript stuff using a model like this:\n *\n * Later, I can read a typescript file with a rust parser to get it into this model again.\n *\n * This is actually super useful for metacoding and coding GUI's\n *\n * Also a great start for making my own programming language ;)\n *\n *\n * There are multiple ways of describing a typescript file I guess. This is one of them. Another one could be a definition where you put the required context in the statements and types themselves.\n */\nexport interface TypescriptFile\n  extends DefaultModelType,\n    TypescriptScopeContext,\n    TypescriptScopeContent {}"
  },
  "TypescriptIndex": {
    "name": "TypescriptIndex",
    "slug": "TsInterface",
    "id": "typescriptindex",
    "description": "\nTypescript file metadata (all indexes from typescript files, together)",
    "operationName": "code-types",
    "rawText": "\n/**\n * TODO:\n *\n * Any interface/type\n * - should be able to have default values\n * - should be able to have validation functions\n * - should be able to have casting functions\n * - some parameters should be hidden upon creation\n * - some should be hidden on updating\n * - some should even be hidden when listing\n *\n * This is mainly for the admin panel, but it could be integrated on the db level as well.\n * The problem is that this behavior may be app-specific, so this becomes rather opinionated if we do it on the OS level\n * Come up with an exact requirement and implementation plan.\n *\n * There are many more functionalities possible here to speed up development, not only for admin use-case.\n */\n\n/**\n * ---\n * isDbModel: false\n * ---\n *\n * Typescript file metadata (all indexes from typescript files, together)\n *\n */\nexport type TypescriptIndex = {\n  tsImports: TsImport[];\n  tsFunctions: TsFunction[];\n  tsInterfaces: TsInterface[];\n  tsVariables: TsVariable[];\n  tsBuildErrors: TsBuildError[];\n  tsLintWarnings: TsLintWarning[];\n  tsComments: TsComment[];\n  tsExports: TsExport[];\n};"
  },
  "TypescriptScopeContent": {
    "name": "TypescriptScopeContent",
    "slug": "TsInterface",
    "id": "typescriptscopecontent",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport interface TypescriptScopeContent {\n  statements: {\n    name: string;\n    /**\n     * can not be done in functions\n     */\n    isExported: boolean;\n    comment?: string;\n    isFunction?: boolean;\n    variableJsonValue?: any;\n    functionDefinition?: TypescriptScopeContext & {\n      /**\n       * Inside of the function (recursion on itself)\n       */\n      content: TypescriptScopeContent;\n    };\n  }[];\n\n  interfaces: {\n    name: string;\n    isExported: boolean;\n    comment?: string;\n    simplifiedSchema: SimplifiedSchema;\n  }[];\n\n  /**\n   * Only in functions\n   */\n  returnStatementRaw?: string;\n}"
  },
  "TypescriptScopeContext": {
    "name": "TypescriptScopeContext",
    "slug": "TsInterface",
    "id": "typescriptscopecontext",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport interface TypescriptScopeContext {\n  /**\n   * Parameters\n   */\n  statementContext?: TypescriptScopeStatementContext[];\n  /**\n   * Generics\n   */\n  typeContext?: TypescriptScopeTypeContext[];\n}"
  },
  "TypescriptScopeStatementContext": {
    "name": "TypescriptScopeStatementContext",
    "slug": "TsInterface",
    "id": "typescriptscopestatementcontext",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport interface TypescriptScopeStatementContext {\n  name: string;\n  /**\n   * Only for functions\n   */\n  isRequired?: boolean;\n  simplifiedSchema: SimplifiedSchema;\n  comment: string;\n  isRest?: boolean;\n}"
  },
  "TypescriptScopeTypeContext": {
    "name": "TypescriptScopeTypeContext",
    "slug": "TsInterface",
    "id": "typescriptscopetypecontext",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport interface TypescriptScopeTypeContext {\n  name: string;\n  comment?: string;\n  simplifiedSchema: SimplifiedSchema;\n}"
  },
  "Address": {
    "name": "Address",
    "slug": "TsInterface",
    "id": "address",
    "description": "The old location interface I made up had multiple references, but I don't think this is needed. We can simply use the category interface\n\n\nexport interface Location extends SlugModelType {\ncontinent_locationSlug: Slug;\ncountry_locationSlug?: Slug;\nregionProvinceState_locationSlug?: Slug;\ncity_locationSlug?: Slug;\n}",
    "operationName": "geo-types",
    "rawText": "\n\n/* \n\nThe old location interface I made up had multiple references, but I don't think this is needed. We can simply use the category interface\n\n\nexport interface Location extends SlugModelType {\n  continent_locationSlug: Slug;\n  country_locationSlug?: Slug;\n  regionProvinceState_locationSlug?: Slug;\n  city_locationSlug?: Slug;\n}\n\n*/\n\nexport interface Address extends SlugModelType {\n  locationSlug: Slug;\n  location?: Location;\n  postalCode: string;\n  street: string;\n  houseNumber: string;\n  area?: Area;\n  description?: Markdown;\n}"
  },
  "Area": {
    "name": "Area",
    "slug": "TsInterface",
    "id": "area",
    "description": "in the UI this should be a special input type, where you can draw a polygon or circles on the map and the center will be calculated",
    "operationName": "geo-types",
    "rawText": "\n\n/**\n * in the UI this should be a special input type, where you can draw a polygon or circles on the map and the center will be calculated\n */\nexport interface Area extends SlugModelType {\n  polygon?: Position[];\n  circles?: Circle[];\n  center?: {\n    latitude: number;\n    longitude: number;\n  };\n}"
  },
  "Circle": {
    "name": "Circle",
    "slug": "TsInterface",
    "id": "circle",
    "description": "",
    "operationName": "geo-types",
    "rawText": "\n\nexport interface Circle {\n  diameterMeters: number;\n  position: Position;\n}"
  },
  "City": {
    "name": "City",
    "slug": "TsInterface",
    "id": "city",
    "description": "",
    "operationName": "geo-types",
    "rawText": "\n\nexport interface City extends SlugModelType {\n  name: string;\n  latitude: number;\n  longitude: number;\n  population: number;\n  countrySlug: Slug;\n  country?: Country;\n}"
  },
  "Country": {
    "name": "Country",
    "slug": "TsInterface",
    "id": "country",
    "description": "",
    "operationName": "geo-types",
    "rawText": "\n\nexport interface Country extends SlugModelType {\n  name: string;\n  continent: string;\n  subContinent: string;\n  latitude: number;\n  longitude: number;\n  polygons: Polygon[];\n}"
  },
  "DistantObject": {
    "name": "DistantObject",
    "slug": "TsInterface",
    "id": "distantobject",
    "description": "",
    "operationName": "geo-types",
    "rawText": "export type DistantObject = {\n  type: \"moon\" | \"planet\" | \"star\" | \"blackHole\" | \"asteroid\" | \"galaxy\";\n  position: SpacePosition;\n};"
  },
  "Polygon": {
    "name": "Polygon",
    "slug": "TsInterface",
    "id": "polygon",
    "description": "",
    "operationName": "geo-types",
    "rawText": "\n\nexport type Polygon = Position[];"
  },
  "SpacePosition": {
    "name": "SpacePosition",
    "slug": "TsInterface",
    "id": "spaceposition",
    "description": "IDK HOW TO DO DIS :(",
    "operationName": "geo-types",
    "rawText": "\n\n/**\n * IDK HOW TO DO DIS :(\n */\nexport type SpacePosition = unknown;"
  },
  "CoreWordMatrixWord": {
    "name": "CoreWordMatrixWord",
    "slug": "TsInterface",
    "id": "corewordmatrixword",
    "description": "",
    "operationName": "language-types",
    "rawText": "\n\nexport type CoreWordMatrixWord = {\n  /**\n   * Priority level is how important this word is to communicate...\n   *\n   *\n   * TITLE: Priority level (defaults to low)\n   *\n   * critical: toki pona word (top 150)\n   * high: top 500\n   * medium: top 2500\n   * low (default): less occurence\n   */\n  priorityLevel?: WordPriority;\n\n  /**\n   * TITLE: Rank (How common this word is in the english language?)\n   */\n  rank?: number;\n\n  /**\n   * amount used across the whole monorepo\n   */\n  usageCountCalculated?: number;\n\n  /**\n   * All ways the word is conjucated from the root word\n   */\n  conjucations?: WordConjucation[];\n\n  /**\n   * SECTION: Relations to other words...\n   *\n   * TITLE: Root word\n   *\n   * DESCRIPTION: If the word is a certain conjugation of a root word, this should be a reference to the root word\n   */\n  root_wordMatrixSlug?: Slug;\n  root_word?: WordMatrix;\n\n  /**\n   * TITLE: Opposite word\n   *\n   * DESCRIPTION: If there's another word that's the complete opposite of this one, you can declare it here\n   */\n  opposite_wordMatrixSlug?: Slug;\n  opposite_wordMatrix?: WordMatrix;\n\n  /**\n   * TITLE: Common Synonym\n   *\n   * DESCRIPTION: f the word is a synonym to a more common word, this should be a reference to the more common synonym. This is a 1:1 synonym only\n   */\n  common_wordMatrixSlug?: Slug;\n  common_wordMatrix?: WordMatrix;\n\n  /**\n   * TITLE: Toki-Pona words\n   *\n   * DESCRIPTION: The closest way to express this word in toki pona terms.\n   *\n   * NB: should be an array (order is important here) of slugs of words containing the \"tk\" property. This needs to be a reference so we can also give information about the individual toki pona words\n   */\n  tokiPona_wordMatrixSlugs?: Slug[];\n  tokiPona_wordMatrixs?: WordMatrix[];\n\n  /**\n   * TITLE: Emoji Words\n   *\n   * The closest way to express this word in emoji terms should be an array (order is important here) of slugs of words containing \"emoji\" property\n   *\n   * This needs to be a reference so we can also give information about the individual emojis\n   */\n  emoji_wordMatrixSlugs?: Slug[];\n  emoji_wordMatrixs?: WordMatrix[];\n\n  /**\n   * SECTION: Translations\n   *\n   * DESCRIPTION: Single emoji describing this word 1:1 (if it are more emojis of multiple words, please use the reference instead)\n   */\n  emoji?: string;\n};"
  },
  "KvmdWord": {
    "name": "KvmdWord",
    "slug": "TsInterface",
    "id": "kvmdword",
    "description": "Should later be migrated to `WordMatrix`",
    "operationName": "language-types",
    "rawText": "\n\n/**\n * Should later be migrated to `WordMatrix`\n */\nexport interface KvmdWord extends KeyValueMarkdownModelType {}"
  },
  "MappedWordMatrix": {
    "name": "MappedWordMatrix",
    "slug": "TsInterface",
    "id": "mappedwordmatrix",
    "description": "Mapped Object for performance reasons",
    "operationName": "language-types",
    "rawText": "\n\n/** Mapped Object for performance reasons */\nexport interface MappedWordMatrix extends MappedObject<WordMatrix> {\n  [baseLanguageWord: string]: WordMatrix;\n}"
  },
  "MarkdownWord": {
    "name": "MarkdownWord",
    "slug": "TsInterface",
    "id": "markdownword",
    "description": "Should later be migrated to `WordMatrix`",
    "operationName": "language-types",
    "rawText": "\n\n/**\n * Should later be migrated to `WordMatrix`\n */\nexport interface MarkdownWord extends MarkdownModelType {}"
  },
  "NepaliEnglishTranslationMatrix": {
    "name": "NepaliEnglishTranslationMatrix",
    "slug": "TsInterface",
    "id": "nepalienglishtranslationmatrix",
    "description": "",
    "operationName": "language-types",
    "rawText": "\n\nexport interface NepaliEnglishTranslationMatrix extends DefaultModelType {\n  en: string;\n  index: number;\n  ne: string;\n}"
  },
  "Statement": {
    "name": "Statement",
    "slug": "TsInterface",
    "id": "statement",
    "description": "\nStatement model:\n\nMotivation:\n\n- create a database of the belief system of one or multiple entities (Person, Algorithm, species, etc.)\n- use this belief system for fact-checking, differentiative checking, value checking, and more.",
    "operationName": "language-types",
    "rawText": "\n\n/**\n---\ndbStorageMethod: jsonSingle\n---\n\nStatement model:\n\nMotivation:\n\n- create a database of the belief system of one or multiple entities (Person, Algorithm, species, etc.)\n- use this belief system for fact-checking, differentiative checking, value checking, and more.\n\n */\nexport interface Statement extends DefaultModelType {\n  /**\n   * your statement: definition, fact, question, quote\n   */\n  description: string;\n\n  /**\n   * source of the statement, if the statement was a non-original one found online somewhere\n   */\n  url?: string;\n\n  author_personId?: Id;\n\n  /**\n   * Number [0-1] representing agreement of admin\n   *\n   * - 1 meaning 100% agreement\n   * - 0 means 0% agreement or complete disagreement\n   */\n  agreement?: number;\n\n  /**\n   * Number [0,1] representing agreement of readers\n   *\n   * 1 reader can vote once\n   */\n  readersAgreement?: number;\n  readersAgreementVotedCount?: number;\n\n  /**\n   * defaults to 0.5 meaning average importancy\n   * this could be either a calculated or set property.\n   * could it be calculated on your value hierarchy?\n   * not sure if this is practical (yet) but still a very interesting property to have, or somehow calculate.\n   */\n  importancy?: number;\n  /**\n   * by default, importancy is calculated by one or multiple systems. As the admin you can change it\n   *\n   * TODO: once this is all working, possibly add reader-importancy and readersImportancyVotedCount\n   */\n  isImportancySet?: boolean;\n\n  /**\n   * A statement can connect to one or more words. This can be calculated automatically I guess, by looking at all WordMatrix words and WordCombinations that are inside of the statement. However, we may not want to put all of them in there.\n   *\n   * For now, let's skip this, since it's probably better to calculate it on the fly, not index it.\n   */\n  wordMatrixSlugs?: Slug[];\n  wordMatrixs?: WordMatrix[];\n}"
  },
  "Translation": {
    "name": "Translation",
    "slug": "TsInterface",
    "id": "translation",
    "description": "We could have a Translation model that collects any translation for any key for any model for any language.\nThe original source text is still stored in the models itself, and every model has just one language.\n\nIf you want a markdown or text key to be translated, add `{parameter}_TranslationId` to the model. The translation can then be generated on-demand and improved afterwards.",
    "operationName": "language-types",
    "rawText": "\n\n/**\n * We could have a Translation model that collects any translation for any key for any model for any language.\n * The original source text is still stored in the models itself, and every model has just one language.\n *\n * If you want a markdown or text key to be translated, add `{parameter}_TranslationId` to the model. The translation can then be generated on-demand and improved afterwards.\n */\nexport interface Translation extends DefaultModelType {\n  /**\n   * Not sure if this is needed. Do we need to know where any given translation comes from? It would be a lot of searching otherwise, maybe. Maybe this should even be an array if we want to avoid duplication, but this seems to make everything more complex. Maybe just skip sourcePath for the POC.\n   */\n  sourcePath: string;\n  language: Language;\n  markdown: Markdown;\n  text: Text;\n}"
  },
  "Word": {
    "name": "Word",
    "slug": "TsInterface",
    "id": "word",
    "description": "The goal of the words model is to provide a definition for every word we use, in any language.\n\nDEPRECATED: Should be replaced with `WordMatrix`",
    "operationName": "language-types",
    "rawText": "\n\n/**\n * The goal of the words model is to provide a definition for every word we use, in any language.\n *\n * DEPRECATED: Should be replaced with `WordMatrix`\n */\nexport interface Word extends SlugModelType {\n  /**\n   * The word\n   */\n  name: string;\n\n  /**\n   * How common this word is in the english language\n   */\n  rank?: number;\n\n  /**\n   * amount used across the whole monorepo\n   */\n  usageCountCalculated?: number;\n\n  /**\n   * if the word isn't in english already, this can be a reference to the english word that represents this word the most\n   */\n  english_wordSlug?: Slug;\n  english_word?: Word;\n\n  /**\n   * if the word is a certain conjugation of a root word, this should be a reference to the root word\n   */\n  root_wordSlug?: Slug;\n  root_word?: Word;\n\n  /**\n   * if the word is a synonym to a more common word, this should be a reference to the more common synonym. This is a 1:1 synonym only\n   */\n  common_wordSlug?: Slug;\n  common_word?: Word;\n\n  /**\n   * The closest way to express this word in toki pona terms should be an array (order is important here) of slugs of toki pona words\n   */\n  tokiPona_wordSlugs?: Slug[];\n  tokiPona_words?: Word[];\n\n  /**\n   * If the word is defined, this reference should lead to its definition statement\n   *\n   * unlike the word, definition statements are always in english.\n   *\n   * The definitions should only be made of the words that are\n   * - english\n   * - most common\n   * - root\n   */\n  definition_statementId?: Id;\n  definition_statement?: Statement;\n\n  /**\n   * if the word is also used as a ParameterName, this will refer to the ParameterName.\n   */\n  parameterNameSlug?: Slug;\n  parameterName?: ParameterName;\n}"
  },
  "WordCategory": {
    "name": "WordCategory",
    "slug": "TsInterface",
    "id": "wordcategory",
    "description": "Different ways to categorise a word semantically",
    "operationName": "language-types",
    "rawText": "\n\n/**\n * Different ways to categorise a word semantically\n */\nexport interface WordCategory extends SlugModelType {\n  description: Markdown;\n}"
  },
  "WordCombination": {
    "name": "WordCombination",
    "slug": "TsInterface",
    "id": "wordcombination",
    "description": "Best way to combine words if you don't want to specify all language specific info for a new word. You can refer to words from the WordMatrix instead!",
    "operationName": "language-types",
    "rawText": "\n\n/**\n * Best way to combine words if you don't want to specify all language specific info for a new word. You can refer to words from the WordMatrix instead!\n */\nexport interface WordCombination extends SlugModelType, WordInfo {\n  /**\n   * Should be autofilled based on the combination of the base words\n   */\n  name: string;\n  /**\n   * Should be auto filled in based on the combination of the base words\n   */\n  slug: string;\n  /**\n   * Which words is this a combination of?\n   */\n  wordMatrixSlugs?: Slug[];\n}"
  },
  "WordConjucation": {
    "name": "WordConjucation",
    "slug": "TsInterface",
    "id": "wordconjucation",
    "description": "In linguistics, conjugation is the creation of derived forms of a verb from its principal parts by inflection\n\nBesides this, there are also other ways to alter a word to add/change meaning, this should be summed up using this enum.",
    "operationName": "language-types",
    "rawText": "\n/**\n * In linguistics, conjugation is the creation of derived forms of a verb from its principal parts by inflection\n *\n * Besides this, there are also other ways to alter a word to add/change meaning, this should be summed up using this enum.\n */\nexport type WordConjucation = \"plural\" | \"female\" | \"male\" | \"past\" | \"future\";"
  },
  "WordInfo": {
    "name": "WordInfo",
    "slug": "TsInterface",
    "id": "wordinfo",
    "description": "",
    "operationName": "language-types",
    "rawText": "\n\nexport type WordInfo = {\n  /**\n   * Unique name of the word in English. Can usually be the word itself...\n   */\n  name: string;\n  slug: Slug;\n  /**\n   * Definition of the word (in english)\n   */\n  description?: Markdown;\n  descriptionAudio?: BackendAsset;\n\n  image?: BackendAsset;\n\n  wordCategorySlugs?: Slug[];\n  wordCategorys?: WordCategory[];\n\n  type?: WordType;\n};"
  },
  "WordLanguageInfo": {
    "name": "WordLanguageInfo",
    "slug": "TsInterface",
    "id": "wordlanguageinfo",
    "description": "Language specific word information",
    "operationName": "language-types",
    "rawText": "\n\n/**\n * Language specific word information\n */\nexport type WordLanguageInfo = {\n  /**\n   * TITLE: Latin writing (if common)\n   * DESCRIPTION: the latin standard written representation for this word\n   */\n  latin?: LanguageLatin;\n  /**\n   * TITLE: Alternative writing (if common)\n   *\n   * DESCRIPTION: the alternative written representation for this word, if any (if the language commonly uses a different script, this can be noted here)\n   */\n  alternative?: LanguageAlternative;\n  /**\n   * TITLE: Phonetic writing\n   *\n   * DESCRIPTION: Phonetic writing is used to describe how the word is pronounced\n   */\n  phonetic?: LanguagePhonetic;\n  /**\n   * TITLE: Spoken word\n   *\n   * DESCRIPTION: Audio fragment containing the spoken word.\n   */\n  audio?: LanguageAudio;\n  /**\n   * DESCRIPTION: A list of examples of usage of this word (can contain both a text and audio)\n   */\n  examples?: LanguageExample[];\n};"
  },
  "WordLanguageInfoObject": {
    "name": "WordLanguageInfoObject",
    "slug": "TsInterface",
    "id": "wordlanguageinfoobject",
    "description": "",
    "operationName": "language-types",
    "rawText": "\n\nexport type WordLanguageInfoObject = {\n  [languageKey in Language]?: WordLanguageInfo;\n};"
  },
  "CreatorMarkdownFile": {
    "name": "CreatorMarkdownFile",
    "slug": "TsInterface",
    "id": "creatormarkdownfile",
    "description": "",
    "operationName": "markdown-types",
    "rawText": "\n\nexport interface CreatorMarkdownFile\n  extends MarkdownModelType,\n    CreatorMarkdownProperties {}"
  },
  "CreatorMarkdownProperties": {
    "name": "CreatorMarkdownProperties",
    "slug": "TsInterface",
    "id": "creatormarkdownproperties",
    "description": "",
    "operationName": "markdown-types",
    "rawText": "export type CreatorMarkdownProperties = {\n  /**\n  DESCRIPTION: Only accessible to admin\n   */\n  isPrivate?: boolean;\n\n  /**\n   * DESCRIPTION: Don't show in the file explorer if you don't have access to this file. NB: only works in combination with pricing or `.isPrivate: true`\n   */\n  isSecret?: boolean;\n\n  /**\n   * DESCRIPTION: If authorizedGroup is set, file content will not be available for people that aren't part of this group.\n   */\n  authorizedGroup?: \"\" | \"premium\" | \"enterprise\";\n\n  /**\n   * DESCRIPTION:If true, will not show up in reader ui's\n   */\n  isDraft?: boolean;\n\n  /**\n   * DESCRIPTION: If this is a date in the future, the file won't be available until that date\n   */\n  isAvailableFromDateAt?: number;\n};"
  },
  "ExtendedMarkdownProperties": {
    "name": "ExtendedMarkdownProperties",
    "slug": "TsInterface",
    "id": "extendedmarkdownproperties",
    "description": "Some properties for on any `MarkdownModelType` model that are quite general purpose and yet aren't included into the `MarkdownModel` because we may not always want them.",
    "operationName": "markdown-types",
    "rawText": "\n/**\n * Some properties for on any `MarkdownModelType` model that are quite general purpose and yet aren't included into the `MarkdownModel` because we may not always want them.\n */\nexport interface ExtendedMarkdownProperties {\n  /**\n   * Should be stored as textual date like `YYYY-MM-DD`\n   */\n  updatedAt: number;\n\n  /**\n   * Should be stored as textual date like `YYYY-MM-DD`\n   */\n  createdAt: number;\n\n  /**\n   * Either filled in or detected\n   */\n  language?: Language;\n\n  /**\n   * If true, will not auto-detect the language\n   */\n  isLanguageCustom?: boolean;\n}"
  },
  "MarkdownContentLevel": {
    "name": "MarkdownContentLevel",
    "slug": "TsInterface",
    "id": "markdowncontentlevel",
    "description": "0 is a paragraph\n1-6 is h1 until h6",
    "operationName": "markdown-types",
    "rawText": "\n\n/**\n * 0 is a paragraph\n * 1-6 is h1 until h6\n */\nexport type MarkdownContentLevel = number;"
  },
  "MarkdownEmbed": {
    "name": "MarkdownEmbed",
    "slug": "TsInterface",
    "id": "markdownembed",
    "description": "Anything in the format `![alt](src)`\n\nNB: I need to be very clear how this one works",
    "operationName": "markdown-types",
    "rawText": "\n\n/**\n * Anything in the format `![alt](src)`\n *\n * NB: I need to be very clear how this one works\n */\nexport type MarkdownEmbed = {\n  alt: string;\n  src: string;\n  type: AssetType;\n};"
  },
  "MarkdownHeader": {
    "name": "MarkdownHeader",
    "slug": "TsInterface",
    "id": "markdownheader",
    "description": "",
    "operationName": "markdown-types",
    "rawText": "\n\nexport type MarkdownHeader = {\n  level: MarkdownContentLevel;\n  title: string;\n};"
  },
  "MarkdownLink": {
    "name": "MarkdownLink",
    "slug": "TsInterface",
    "id": "markdownlink",
    "description": "Anything in the format `[alt](href)`\n\nIt needs to be clear how this works. There is a convention for this, and I should implement that as good as possible, and document it here",
    "operationName": "markdown-types",
    "rawText": "\n\n/**\n * Anything in the format `[alt](href)`\n *\n * It needs to be clear how this works. There is a convention for this, and I should implement that as good as possible, and document it here\n */\nexport type MarkdownLink = {\n  alt: string;\n  href: string;\n  /**\n   * Can be inferred from href\n   */\n  type: AssetType;\n};"
  },
  "MarkdownParagraph": {
    "name": "MarkdownParagraph",
    "slug": "TsInterface",
    "id": "markdownparagraph",
    "description": "",
    "operationName": "markdown-types",
    "rawText": "\n\nexport type MarkdownParagraph = {\n  /** the raw text of this paragraph */\n  paragraph: string;\n  /**\n   * the parent stack\n   */\n  categoryStack: CategoryStack;\n  /**\n   * if the paragraph is\n   * NB: not always used!\n   */\n  level?: MarkdownContentLevel;\n};"
  },
  "NamedParameters<typeof markdownParseToMarkdownModelType>": {
    "name": "NamedParameters<typeof markdownParseToMarkdownModelType>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownparsetomarkdownmodeltype",
    "description": "",
    "operationName": "markdown-types"
  },
  "NamedParameters<typeof parseMarkdownModelTimestamp>": {
    "name": "NamedParameters<typeof parseMarkdownModelTimestamp>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parsemarkdownmodeltimestamp",
    "description": "",
    "operationName": "markdown-types"
  },
  "NamedParameters<typeof tryParseDate>": {
    "name": "NamedParameters<typeof tryParseDate>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tryparsedate",
    "description": "",
    "operationName": "markdown-types"
  },
  "PostableProperties": {
    "name": "PostableProperties",
    "slug": "TsInterface",
    "id": "postableproperties",
    "description": "`Postable` is not extending a modeltype anymore, it can be attached to any `MarkdownModelType` model",
    "operationName": "markdown-types",
    "rawText": "\n\n/**\n * `Postable` is not extending a modeltype anymore, it can be attached to any `MarkdownModelType` model\n */\nexport interface PostableProperties {\n  /**\n   * A way to store messagepresets in markdown. the headers are the different categories. If the first alinea is bolded, it will be parsed to be the title, and will be removed from the message.\n   */\n  isPreset?: boolean;\n  /**\n   * if `.isPlanned` is set to true, this will be converted into `MediaPost`\n   */\n  isPostable?: boolean;\n  /**\n   * If true, this thing should be parsed into a codestory, after which the `.isPostable: true` will be added.\n   */\n  isCodestory?: boolean;\n  // NB: optionally, connect the post to keep it in the system nearby a certain model instance....\n\n  tsInterfaceIds?: Id[];\n  tsInterfaces?: TsInterface[];\n  tsFunctionIds?: Id[];\n  tsFunctions?: TsFunction[];\n  bundleConfigSlugs?: Slug[];\n  bundleConfigs?: BundleConfig[];\n  operationIds?: Id[];\n  operations?: Operation[];\n  reference_assets?: BackendAsset[];\n}"
  },
  "TextJson": {
    "name": "TextJson",
    "slug": "TsInterface",
    "id": "textjson",
    "description": "TODO: Rename",
    "operationName": "markdown-types",
    "rawText": "\n/**\n * TODO: Rename\n */\nexport interface TextJson {\n  /**\n   * only available if it's a json file\n   */\n  json?: any;\n  /**\n   * only available if it's a typescript file\n   */\n  typescriptJson?: unknown;\n  /**\n   * only available if it's a markdown file\n   */\n  markdownJson?: MarkdownParse;\n  /**\n   * full absolute path to the file or folder\n   */\n  path: string;\n  isFolder: boolean;\n  /**\n   * only returned if `includeStats` is true\n   */\n  stats?: PathStats;\n  /**\n   * only returned if `includeMetaData` is set to true\n   */\n  metaData?: FileContentInfo;\n  /** if true, this means this path is given back because it was the last opened base path that searching was canceled on because of the cancelRecursionOn prop */\n  isCancelRecursionResult?: boolean;\n}"
  },
  "WebMarkdownFile": {
    "name": "WebMarkdownFile",
    "slug": "TsInterface",
    "id": "webmarkdownfile",
    "description": "Every markdown file meant for the web, should have these optional parameters that can be declared as its frontmatter\n\nNB: This is not part of MarkdownModelType, because MarkdownModelType is very barebones general purpose, not only for the web!",
    "operationName": "social-media-wrapper"
  },
  "WebMarkdownProperties": {
    "name": "WebMarkdownProperties",
    "slug": "TsInterface",
    "id": "webmarkdownproperties",
    "description": "",
    "operationName": "markdown-types",
    "rawText": "\n\nexport interface WebMarkdownProperties\n  /**\n   * NB: it extends WebsiteHeader here because the MarkdownModelType needs to be flat, and cannot have objects\n   *\n   * We won't make the websiteHeader into an object, although, that would also be a possibility.\n   */\n  extends WebsiteHeaderProperties {\n  /**\n   * Domainname for this file (or folder if it's applied on a readme).\n   *\n   * On top of this, we can build automation that:\n   *\n   * - Infers social media channel names for the domain and creates them\n   * - Buys the domain and sets the DNS if you don't own it yet\n   * - Connects the domain to a Vercel project with the right environment variables if it's not already\n   *\n   * Furthermore we can:\n   *\n   * - create a feature where domains are suggested for subsets of your content and you can easily choose one of the suggested domains to buy it automatically and set it in the file\n   * - cleans up your domains if it seems you don't use them anymore (or at least detects unused domains, so you can also potentially sell them)\n   * - show domain authority for your domains and possible ways to improve it (this can, again, have a whole lot of automations built on top of it)\n   */\n  domain?: string;\n\n  markdownCallToActionSlugs?: Slug[];\n  markdownCallToActions?: MarkdownCallToAction[];\n  /**\n   * Refers to an `Item` from the shop\n   */\n  shop_itemIds?: Id[];\n  //shop_items:Item[];\n\n  /**\n   * Author, reference to persons\n   */\n  author_personSlugs?: Slug[];\n  //author_persons: Person[];\n\n  /**\n   * Labels referring to interests\n   */\n  interestSlugs?: Slug[];\n  //interests: Interest[];\n\n  /**\n   * Price for this file\n   *\n   * NB: in case the file is a README file, the price applies to all files in this folder, recursively, PER FILE.\n   */\n  price?: Price;\n}"
  },
  "WebsiteHeader": {
    "name": "WebsiteHeader",
    "slug": "TsInterface",
    "id": "websiteheader",
    "description": "",
    "operationName": "markdown-types",
    "rawText": "\n\nexport interface WebsiteHeader extends SlugModelType, WebsiteHeaderProperties {}"
  },
  "WebsiteHeaderProperties": {
    "name": "WebsiteHeaderProperties",
    "slug": "TsInterface",
    "id": "websiteheaderproperties",
    "description": "",
    "operationName": "markdown-types",
    "rawText": "\n\nexport type WebsiteHeaderProperties = {\n  headerImage?: BackendAsset;\n  headerTitle?: string;\n  headerBig?: boolean;\n  headerSubTitle?: string;\n  header_markdownCallToActionSlugs?: Slug[];\n  header_markdownCallToActions?: MarkdownCallToAction[];\n};"
  },
  "CategoryModelType": {
    "name": "CategoryModelType",
    "slug": "TsInterface",
    "id": "categorymodeltype",
    "description": "\nTODO: make this be able to hold more than just the KV. If that's not really needed just throw this away...\n\nSimple recursive data structure for hierarchical categories. Should be used to make any category model\n\nMake sure, when extending this, to provide a reference `xxxSlug` and its content `xxx` as optional parameters to its parent categories.\n\nE.g. for a `CountryCategory`, you should provide `countryCategorySlug` and `countryCategory`",
    "operationName": "os-types"
  },
  "CreatedAt": {
    "name": "CreatedAt",
    "slug": "TsInterface",
    "id": "createdat",
    "description": "",
    "operationName": "model-types",
    "rawText": "\nexport type CreatedAt = Time;"
  },
  "CreatedFirstAt": {
    "name": "CreatedFirstAt",
    "slug": "TsInterface",
    "id": "createdfirstat",
    "description": "in some cases, data can be created before it was created in our system. In this case, use CreatedFirstAt if this information is important.",
    "operationName": "model-types",
    "rawText": "\n/**\n * in some cases, data can be created before it was created in our system. In this case, use CreatedFirstAt if this information is important.\n */\nexport type CreatedFirstAt = Time;"
  },
  "DeletedAt": {
    "name": "DeletedAt",
    "slug": "TsInterface",
    "id": "deletedat",
    "description": "",
    "operationName": "model-types",
    "rawText": "\nexport type DeletedAt = Time;"
  },
  "Email": {
    "name": "Email",
    "slug": "TsInterface",
    "id": "email",
    "description": "",
    "operationName": "model-types",
    "rawText": "\n\nexport type Email = string;"
  },
  "Euro": {
    "name": "Euro",
    "slug": "TsInterface",
    "id": "euro",
    "description": "",
    "operationName": "model-types",
    "rawText": "export type Euro = number;"
  },
  "Index": {
    "name": "Index",
    "slug": "TsInterface",
    "id": "index",
    "description": "used for md files. index is the line",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * used for md files. index is the line\n */\nexport type Index = number;"
  },
  "KvmdLine": {
    "name": "KvmdLine",
    "slug": "TsInterface",
    "id": "kvmdline",
    "description": "all things that can be parsed from a single line",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * all things that can be parsed from a single line\n */\nexport type KvmdLine = {\n  /**\n   * same as slug, used for model compatibility\n   */\n  id: string;\n  /**\n   * key\n   *\n   * should be english because it's kind of part of the codebase!\n   */\n  name: string;\n  /**\n   * calculated: slug for this key (kebab case form of the name)\n   */\n  slug: string;\n\n  /**\n   * value behind the semicolom (:). If not given, will be undefined.\n   *\n   * If possible, will be parsed to a number, boolean, null or undefined... otherwise it's a string\n   *\n   * can be any language that we can detect\n   */\n  value: string | number | boolean | null | undefined;\n\n  /** comment in html syntax. if not given, will be null */\n  comment: string | null;\n};"
  },
  "NamedParameters<typeof generateId>": {
    "name": "NamedParameters<typeof generateId>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateid",
    "description": "",
    "operationName": "model-types"
  },
  "NamedParameters<typeof generatePassword>": {
    "name": "NamedParameters<typeof generatePassword>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatepassword",
    "description": "",
    "operationName": "model-types"
  },
  "NamedParameters<typeof generateRandomString>": {
    "name": "NamedParameters<typeof generateRandomString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generaterandomstring",
    "description": "",
    "operationName": "model-types"
  },
  "NamedParameters<typeof generateTime>": {
    "name": "NamedParameters<typeof generateTime>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatetime",
    "description": "",
    "operationName": "model-types"
  },
  "NamedParameters<typeof isEmail>": {
    "name": "NamedParameters<typeof isEmail>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isemail",
    "description": "",
    "operationName": "model-types"
  },
  "PhoneNumber": {
    "name": "PhoneNumber",
    "slug": "TsInterface",
    "id": "phonenumber",
    "description": "country code without +",
    "operationName": "foodchain-types"
  },
  "RelationType": {
    "name": "RelationType",
    "slug": "TsInterface",
    "id": "relationtype",
    "description": "This probably doesn't work, but it would be great if it would. This way I'd like to say that any model can have keys that end with \"Id\". These keys should always refer to Ids from other models.\nAlso, if a model has a key like this, it is inferred that there is also a key without the Id suffix which does or doesn't cointain the actual model specified by the id.\n\nIf this cannot be done in typescript, it can be convention, and we can create a linter for this.\n\nWooh!\n\n```\nconst relations: RelationType = {\nhelloId: \"hoi\",\nbyeId: \"bye\",\n};\n```\n\nThe above seems to be working fine, so it IS possible!\n\nTODO: think about it... should the name of the parameter be dependent on the strategy of how the model is stored? Maybe just call it all id, right? We can also make the index a string by just prepending a string to it.",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * This probably doesn't work, but it would be great if it would. This way I'd like to say that any model can have keys that end with \"Id\". These keys should always refer to Ids from other models.\n * Also, if a model has a key like this, it is inferred that there is also a key without the Id suffix which does or doesn't cointain the actual model specified by the id.\n *\n * If this cannot be done in typescript, it can be convention, and we can create a linter for this.\n *\n * Wooh!\n *\n * ```\nconst relations: RelationType = {\n  helloId: \"hoi\",\n  byeId: \"bye\",\n};\n```\n\nThe above seems to be working fine, so it IS possible!\n\nTODO: think about it... should the name of the parameter be dependent on the strategy of how the model is stored? Maybe just call it all id, right? We can also make the index a string by just prepending a string to it.\n */\nexport type RelationType = {\n  [key: `${string}Id`]: Id | undefined;\n  [key: `${string}Slug`]: Slug | undefined;\n};"
  },
  "ShouldNotBeStored": {
    "name": "ShouldNotBeStored",
    "slug": "TsInterface",
    "id": "shouldnotbestored",
    "description": "Parameters that should not be stored into the database",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * Parameters that should not be stored into the database\n */\nexport type ShouldNotBeStored =\n  | \"operationName\"\n  | \"projectRelativePath\"\n  | \"operationRelativePath\";"
  },
  "SlugModelProperties": {
    "name": "SlugModelProperties",
    "slug": "TsInterface",
    "id": "slugmodelproperties",
    "description": "",
    "operationName": "model-types",
    "rawText": "\n\nexport type SlugModelProperties = {\n  /**\n   * kebab-case of the name, should be unique\n   */\n  slug: Slug;\n  name: string;\n  /**\n   * @default en\n   */\n  language: Language;\n};"
  },
  "Time": {
    "name": "Time",
    "slug": "TsInterface",
    "id": "time",
    "description": "Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time.\nI can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
    "operationName": "model-types",
    "rawText": "/**Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time.\nI can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()\n*/\nexport type Time = number;"
  },
  "TimeTypes": {
    "name": "TimeTypes",
    "slug": "TsInterface",
    "id": "timetypes",
    "description": "TimeTypes is often extended with modelTypes.",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * TimeTypes is often extended with modelTypes.\n */\nexport type TimeTypes = {\n  createdAt: CreatedAt;\n  updatedAt: UpdatedAt;\n  deletedAt: DeletedAt;\n  createdFirstAt: CreatedFirstAt;\n};"
  },
  "UpdatedAt": {
    "name": "UpdatedAt",
    "slug": "TsInterface",
    "id": "updatedat",
    "description": "",
    "operationName": "model-types",
    "rawText": "\n\nexport type UpdatedAt = Time;"
  },
  "Url": {
    "name": "Url",
    "slug": "TsInterface",
    "id": "url",
    "description": "valid url, can be validated",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * valid url, can be validated\n */\nexport type Url = string;"
  },
  "Answer": {
    "name": "Answer",
    "slug": "TsInterface",
    "id": "answer",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport type Answer = {\n  answer: string;\n  isCorrect?: boolean;\n};"
  },
  "AppDeveloper": {
    "name": "AppDeveloper",
    "slug": "TsInterface",
    "id": "appdeveloper",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport interface AppDeveloper extends SlugModelType {\n  type: string;\n  communication: string;\n  price: number;\n  speed: number;\n  //...etc\n}"
  },
  "Assignment": {
    "name": "Assignment",
    "slug": "TsInterface",
    "id": "assignment",
    "description": "This should be attachable to a markdown file so it can be rendered in the course website,\n\nInitially it can simply be a full list in a pdf with numbers that we can manually refer to",
    "operationName": "os-types",
    "rawText": "\n\n/**\n * This should be attachable to a markdown file so it can be rendered in the course website,\n *\n * Initially it can simply be a full list in a pdf with numbers that we can manually refer to\n */\nexport interface Assignment extends SlugModelType {\n  webMarkdownFileId: string;\n  webMarkdownFile?: WebMarkdownFile;\n  description: string;\n  checklist: string[];\n}"
  },
  "Bag": {
    "name": "Bag",
    "slug": "TsInterface",
    "id": "bag",
    "description": "let's try to define a physical object using a type interface\nthe idea of this is to define it as clearly as possible and describe all information we know about this bag in the real world\n\nthis is very good for type coverage of the whole dictionary as there are many words of physical objects\n\nthere are many ways to do this type interface of a physical object, so I don't think we have found the best way yet.",
    "operationName": "os-types",
    "rawText": "\n\n/**\n * let's try to define a physical object using a type interface\n * the idea of this is to define it as clearly as possible and describe all information we know about this bag in the real world\n *\n * this is very good for type coverage of the whole dictionary as there are many words of physical objects\n *\n * there are many ways to do this type interface of a physical object, so I don't think we have found the best way yet.\n */\nexport interface Bag extends PhysicalObject, PhysicalInstance, SlugModelType {\n  color: Color;\n  appearance: Markdown;\n  materials: Material[];\n  compartments: Compartment[];\n}"
  },
  "Batch": {
    "name": "Batch",
    "slug": "TsInterface",
    "id": "batch",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport type Batch = {\n  items: { item: string; quantity: number; quantitySpecification: string }[];\n  /**\n   * based on timerange and items, deliveryplatform may vary\n   */\n  platform: DeliveryPlatform;\n  /**\n   * timerange\n   */\n  afterTime: number;\n  beforeTime: number;\n  /**\n   date since picked up by operator\n  */\n  processingAt: number;\n  /**\n   * datetime since it was planned (fulfilled and paid by operator, delivery planned)\n   */\n  plannedAt: number;\n  /**\n   * exact expected delivery (to be filled in by operator after fulfillment)\n   */\n  deliveryAt: number;\n\n  /**\n   * total budget of all items\n   */\n  totalBudget?: number;\n  /**\n   * total cost (to be filled in by operator)\n   */\n  totalCost?: number;\n};"
  },
  "Calendar": {
    "name": "Calendar",
    "slug": "TsInterface",
    "id": "calendar",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport interface Calendar extends SlugModelType {}"
  },
  "CarbonFootprintRemedy": {
    "name": "CarbonFootprintRemedy",
    "slug": "TsInterface",
    "id": "carbonfootprintremedy",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport type CarbonFootprintRemedy = {\n  name: string;\n  kiloCarbonPerYear?: number;\n  kiloCarbonOneTime?: number;\n};"
  },
  "CarbonFootprintSource": {
    "name": "CarbonFootprintSource",
    "slug": "TsInterface",
    "id": "carbonfootprintsource",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport type CarbonFootprintSource = {\n  name: string;\n  kiloCarbonPerYear?: number;\n  kiloCarbonOneTime?: number;\n};"
  },
  "CurrencyString": {
    "name": "CurrencyString",
    "slug": "TsInterface",
    "id": "currencystring",
    "description": "3 letter currency ISO code",
    "operationName": "os-types",
    "rawText": "\n/**\n * 3 letter currency ISO code\n */\nexport type CurrencyString = string;"
  },
  "Deadline": {
    "name": "Deadline",
    "slug": "TsInterface",
    "id": "deadline",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport type Deadline =\n  | \"now\"\n  | \"asap\"\n  | \"before\"\n  | \"today\"\n  | \"tomorrow\"\n  | \"this week\"\n  | \"next week\"\n  | \"this month\"\n  | \"next month\"\n  | \"withinHours\"\n  | \"withinDays\"\n  | \"roughly\"\n  | \"exact\";"
  },
  "Deliverable": {
    "name": "Deliverable",
    "slug": "TsInterface",
    "id": "deliverable",
    "description": "holy shit, this is the coolest! instead of having an api for everything, in the beginning this can just be done by someone from a lower-paid country. obviously, in the end it will be easy to create api's for all of this, but it will already be very valuable without any api.\n========\ndeliverables for every person are handled by an operator. the operator can be anywhere in the world. deliverables per person are ordered by their deadline. createdAt + recurring will calculate further planned deadlines. this can generate a list of deliverables within timeranges. this can generate the optimal batching (if we know which platform is preferred). the operator then just needs to pick up these batch orders, fulfill them, pay for them, and you'll get everything when you want it\n========\neven when you are your own operator, this is still useful. it will create shopping lists for you. but of course, this is not needed. a fairly unskilled operator doesn't cost more than a cent per minute, the time required per batch is anywhere between 1 to 10 minutes. the utility is much more than the time saved by your operator, it's also the batching that's very useful and not being distracted from the stuff you are doing!",
    "operationName": "os-types",
    "rawText": "\n\n/**\n * holy shit, this is the coolest! instead of having an api for everything, in the beginning this can just be done by someone from a lower-paid country. obviously, in the end it will be easy to create api's for all of this, but it will already be very valuable without any api.\n * ========\n * deliverables for every person are handled by an operator. the operator can be anywhere in the world. deliverables per person are ordered by their deadline. createdAt + recurring will calculate further planned deadlines. this can generate a list of deliverables within timeranges. this can generate the optimal batching (if we know which platform is preferred). the operator then just needs to pick up these batch orders, fulfill them, pay for them, and you'll get everything when you want it\n * ========\n * even when you are your own operator, this is still useful. it will create shopping lists for you. but of course, this is not needed. a fairly unskilled operator doesn't cost more than a cent per minute, the time required per batch is anywhere between 1 to 10 minutes. the utility is much more than the time saved by your operator, it's also the batching that's very useful and not being distracted from the stuff you are doing!\n */\n\nexport interface Deliverable extends SlugModelType {\n  /**\n   * specify specifically what you want\n   */\n  item: Item;\n\n  /**\n   * amount of units (depends per item)\n   */\n  quantity: number;\n  quantitySpecification?: string;\n\n  /**\n   * when the item needs to be delivered\n   */\n  deadline: Deadline;\n\n  /**\n   * some time indications need to be specified\n   */\n  deadlineSpecification?: number;\n\n  /**\n   * if given, the delivery can be repeated\n   */\n  repeat?:\n    | \"weekly\"\n    | \"monthly\"\n    | \"daily\"\n    | \"everyDays\"\n    | \"everyWeeks\"\n    | \"everyHours\";\n\n  /**\n   * some repeats need specificaction of # of times\n   */\n  repeatSpecification?: number;\n\n  /**\n   * max amount of credits (euros for now) it can cost\n   */\n  budget?: number;\n\n  /**\n   * sometimes you may want to cancel recurring deliverables if certain conditions aren't met\n   */\n  condition?: (\"onlyIfHome\" | \"onlyIfAwake\")[];\n\n  /**\n   * sometimes a comment may be sufficient to indicate something important\n   */\n  comment?: string;\n}"
  },
  "Delivery": {
    "name": "Delivery",
    "slug": "TsInterface",
    "id": "delivery",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport interface Delivery {\n  area: string;\n  speed: string;\n  cost: string;\n}"
  },
  "DeliveryPlatform": {
    "name": "DeliveryPlatform",
    "slug": "TsInterface",
    "id": "deliveryplatform",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport type DeliveryPlatform =\n  | \"flink\"\n  | \"ah\"\n  | \"thuisbezorgd\"\n  | \"bol\"\n  | \"coolblue\"\n  | \"amazon\"\n  | \"specific\";"
  },
  "Diary": {
    "name": "Diary",
    "slug": "TsInterface",
    "id": "diary",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport interface Diary extends MarkdownModelType {}"
  },
  "DigitalAsset": {
    "name": "DigitalAsset",
    "slug": "TsInterface",
    "id": "digitalasset",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport interface DigitalAsset {\n  relativePath: string;\n}"
  },
  "DIY": {
    "name": "DIY",
    "slug": "TsInterface",
    "id": "diy",
    "description": "a way to describe a way to get an item by making it yourself, or finding it yourself, or getting it in another way that is not via a (external or internal) webshop",
    "operationName": "os-types",
    "rawText": "\n/**\n * a way to describe a way to get an item by making it yourself, or finding it yourself, or getting it in another way that is not via a (external or internal) webshop\n */\nexport interface DIY {\n  name: string;\n  description: Markdown;\n}"
  },
  "Feeling": {
    "name": "Feeling",
    "slug": "TsInterface",
    "id": "feeling",
    "description": "which feelings exist?",
    "operationName": "os-types",
    "rawText": "\n/**\n * which feelings exist?\n */\nexport interface Feeling extends SlugModelType {\n  markdown: Markdown;\n}"
  },
  "FeelingLog": {
    "name": "FeelingLog",
    "slug": "TsInterface",
    "id": "feelinglog",
    "description": "create entries of how you feel, when. these things can be requested for in your daily standup/roundup, etc, but you can also just fill them in. It's just a very interesting thing to log your daily life and see how things relate to each other using some analysis",
    "operationName": "os-types",
    "rawText": "\n\n/**\n * create entries of how you feel, when. these things can be requested for in your daily standup/roundup, etc, but you can also just fill them in. It's just a very interesting thing to log your daily life and see how things relate to each other using some analysis\n */\nexport interface FeelingLog extends DefaultModelType {\n  feelingSlug: Slug;\n  comment?: string;\n}"
  },
  "Flight": {
    "name": "Flight",
    "slug": "TsInterface",
    "id": "flight",
    "description": "",
    "operationName": "os-types",
    "rawText": "export interface Flight {\n  from: \"groningen\" | \"amsterdam\";\n  to: string;\n  /**\n   * D-M\n   */\n  periodStart?: string;\n  /**\n   * D-M\n   */\n  periodEnd?: string;\n  /**\n   * if undefined, direct (0 layovers). can be string array with a slug for every layover location\n   */\n  layovers?: string[];\n  /**\n   * undefined means every day\n   * number[] where 0 means sunday, 6 is saturday\n   */\n  days?: number[];\n}"
  },
  "Folder": {
    "name": "Folder",
    "slug": "TsInterface",
    "id": "folder",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport interface Folder extends SlugModelType {\n  /**\n   * Description of the folder contents\n   */\n  markdown: Markdown;\n}"
  },
  "Host": {
    "name": "Host",
    "slug": "TsInterface",
    "id": "host",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport interface Host extends DefaultModelType {\n  userId: Id;\n  listingIds: Id[];\n}"
  },
  "Ikigai": {
    "name": "Ikigai",
    "slug": "TsInterface",
    "id": "ikigai",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport interface Ikigai {\n  youLove: string;\n  worldNeed: string;\n  goodAt: string;\n  paidFor: string;\n}"
  },
  "IndexedJsonValue": {
    "name": "IndexedJsonValue",
    "slug": "TsInterface",
    "id": "indexedjsonvalue",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport type IndexedJsonValue =\n  | { [key: string]: Indexation<IndexedJsonValue> }\n  | string\n  | number\n  | boolean\n  | null\n  | IndexedJsonValue[];"
  },
  "Inventory": {
    "name": "Inventory",
    "slug": "TsInterface",
    "id": "inventory",
    "description": "your stuff that you own and want to showcase to people, in case you can help others with it",
    "operationName": "os-types",
    "rawText": "\n/**\n * your stuff that you own and want to showcase to people, in case you can help others with it\n */\nexport interface Inventory extends SlugModelType {\n  image?: Image;\n  description?: Markdown;\n  isSecondHand: boolean;\n  acceptBidding: boolean;\n  /**\n   * you can optionally specify a location of this item\n   */\n  location?: Location;\n  /**\n   * 1 by default\n   */\n  amountAvailable: number;\n\n  /**\n   * lending, hiring, borrowing, etc.\n   */\n  forBorrowPrice?: Price;\n  forSalePrice?: Price;\n  delivery?: Delivery;\n  physicalObject?: PhysicalObject;\n  digitalAsset?: DigitalAsset;\n}"
  },
  "Item": {
    "name": "Item",
    "slug": "TsInterface",
    "id": "item",
    "description": "very general purpose item. the idea is that every item should have many different ways to get it and many different variants.",
    "operationName": "os-types",
    "rawText": "\n/**\n * very general purpose item. the idea is that every item should have many different ways to get it and many different variants.\n */\nexport interface Item extends SlugModelType {\n  itemCategorySlug?: Slug;\n  itemCategory?: ItemCategory;\n  description?: Markdown;\n  image?: Image;\n  /** internal webshop */\n  inventory?: Inventory[];\n  /** external webshops */\n  webshop?: Webshop[];\n  /** other way */\n  diy?: DIY[];\n}"
  },
  "ItemCategory": {
    "name": "ItemCategory",
    "slug": "TsInterface",
    "id": "itemcategory",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport interface ItemCategory extends CategoryModelType {}"
  },
  "KvmdShortcut": {
    "name": "KvmdShortcut",
    "slug": "TsInterface",
    "id": "kvmdshortcut",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport interface KvmdShortcut extends KeyValueMarkdownModelType {}"
  },
  "Light": {
    "name": "Light",
    "slug": "TsInterface",
    "id": "light",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport interface Light extends DefaultModelType {\n  light: number;\n}"
  },
  "Listing": {
    "name": "Listing",
    "slug": "TsInterface",
    "id": "listing",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport interface Listing extends DefaultModelType {\n  hostId: Id;\n\n  location: Location;\n  pictures: string[];\n  title: string;\n  description: string;\n  pricePerNight: number;\n  currency: CurrencyString;\n  type: ListingType;\n}"
  },
  "ListingType": {
    "name": "ListingType",
    "slug": "TsInterface",
    "id": "listingtype",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport type ListingType = \"private\" | \"shared\" | \"single-bed\" | \"double-bed\";"
  },
  "LoginCredential": {
    "name": "LoginCredential",
    "slug": "TsInterface",
    "id": "logincredential",
    "description": "in the name, the name of the website or thing the credential is for is specified\n\nin the value, the username and password and more information can be specified.\n\nTODO: since this thing extends KeyValueMarkdownModelType, it should read the description of that thing and apply the frontmatter params to this model as well... Hopefully this is doable.",
    "operationName": "os-types",
    "rawText": "\n\n/**\n *\n * in the name, the name of the website or thing the credential is for is specified\n *\n * in the value, the username and password and more information can be specified.\n *\n * TODO: since this thing extends KeyValueMarkdownModelType, it should read the description of that thing and apply the frontmatter params to this model as well... Hopefully this is doable.\n */\nexport interface LoginCredential extends KeyValueMarkdownModelType {\n  /**\n   * if the value contains anything between backticks (\\`example\\`) it will be provided through the password parameter as well\n   */\n  password?: string;\n}"
  },
  "Material": {
    "name": "Material",
    "slug": "TsInterface",
    "id": "material",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport interface Material extends SlugModelType {\n  source: string;\n  /**\n   * description of material\n   */\n  markdown: Markdown;\n}"
  },
  "MessagePreset": {
    "name": "MessagePreset",
    "slug": "TsInterface",
    "id": "messagepreset",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport interface MessagePreset extends MarkdownModelType {}"
  },
  "NamedParameters<typeof createUser>": {
    "name": "NamedParameters<typeof createUser>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-createuser",
    "description": "",
    "operationName": "os-types"
  },
  "NamedParameters<typeof encryptPassword>": {
    "name": "NamedParameters<typeof encryptPassword>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-encryptpassword",
    "description": "",
    "operationName": "encrypt-password"
  },
  "NamedParameters<typeof getBacktickContents>": {
    "name": "NamedParameters<typeof getBacktickContents>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getbacktickcontents",
    "description": "",
    "operationName": "os-types"
  },
  "NamedParameters<typeof isInPeriod>": {
    "name": "NamedParameters<typeof isInPeriod>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isinperiod",
    "description": "",
    "operationName": "os-types"
  },
  "NamedParameters<typeof isOutOfStock>": {
    "name": "NamedParameters<typeof isOutOfStock>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isoutofstock",
    "description": "",
    "operationName": "os-types"
  },
  "NamedParameters<typeof kvmdToCredential>": {
    "name": "NamedParameters<typeof kvmdToCredential>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-kvmdtocredential",
    "description": "",
    "operationName": "os-types"
  },
  "NamedParameters<typeof upcomingOutgoingFlights>": {
    "name": "NamedParameters<typeof upcomingOutgoingFlights>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-upcomingoutgoingflights",
    "description": "",
    "operationName": "os-types"
  },
  "NamedParameters<typeof whereShouldIgo>": {
    "name": "NamedParameters<typeof whereShouldIgo>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-whereshouldigo",
    "description": "",
    "operationName": "os-types"
  },
  "OperatingSystemEnum": {
    "name": "OperatingSystemEnum",
    "slug": "TsInterface",
    "id": "operatingsystemenum",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport type OperatingSystemEnum = \"macos\" | \"windows\" | \"linux\";"
  },
  "PersonalCarbonFootprintProfile": {
    "name": "PersonalCarbonFootprintProfile",
    "slug": "TsInterface",
    "id": "personalcarbonfootprintprofile",
    "description": "https://www.epa.gov/ghgemissions/global-greenhouse-gas-emissions-data\n\nhttps://www.epa.gov/sites/default/files/2016-05/global_emissions_sector_2015.png\n\nIt would be great to have a way to easily estimate how carbon you personally generate.\n\nBesides, it would be even cooler if you can easily show how to remedy/counter it\n\nprereqs:\n\n1) banking api integrations\n2) expenditure model\n3) ui to link the expenses to carbon usage",
    "operationName": "os-types",
    "rawText": "\n\n/**\n https://www.epa.gov/ghgemissions/global-greenhouse-gas-emissions-data\n\n https://www.epa.gov/sites/default/files/2016-05/global_emissions_sector_2015.png\n\n It would be great to have a way to easily estimate how carbon you personally generate.\n\n Besides, it would be even cooler if you can easily show how to remedy/counter it\n\n prereqs:\n\n 1) banking api integrations\n 2) expenditure model\n 3) ui to link the expenses to carbon usage\n\n */\nexport interface PersonalCarbonFootprintProfile extends SlugModelType {\n  sources: CarbonFootprintSource[];\n  remedies: {\n    investmentEurosOneTime: number;\n    investmentEurosPerYear: number;\n    remedy: CarbonFootprintRemedy;\n  }[];\n}"
  },
  "PhysicalInstance": {
    "name": "PhysicalInstance",
    "slug": "TsInterface",
    "id": "physicalinstance",
    "description": "an instance of an object",
    "operationName": "os-types",
    "rawText": "\n\n/**\n * an instance of an object\n */\nexport interface PhysicalInstance {\n  location: Location;\n}"
  },
  "PhysicalObject": {
    "name": "PhysicalObject",
    "slug": "TsInterface",
    "id": "physicalobject",
    "description": "any physical object has this",
    "operationName": "os-types",
    "rawText": "/**\n * any physical object has this\n */\nexport type PhysicalObject = {\n  weightKg: number;\n  lengthMeter: number;\n  widthMeter: number;\n  heightMeter: number;\n  ean?: number;\n};"
  },
  "PlannedFlight": {
    "name": "PlannedFlight",
    "slug": "TsInterface",
    "id": "plannedflight",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport type PlannedFlight = Flight & { date: string };"
  },
  "ProgramEnum": {
    "name": "ProgramEnum",
    "slug": "TsInterface",
    "id": "programenum",
    "description": "",
    "operationName": "os-types",
    "rawText": "\nexport type ProgramEnum = \"vscode\" | \"safari\" | \"os\";"
  },
  "ProgressReport": {
    "name": "ProgressReport",
    "slug": "TsInterface",
    "id": "progressreport",
    "description": "Let students fill this in as often as they want, kind of a diary with an optional structured format\n\nlater this can become a feed where people are sharing not only their progress but also their lifestyle",
    "operationName": "os-types",
    "rawText": "\n\n/**\n * Let students fill this in as often as they want, kind of a diary with an optional structured format\n *\n * later this can become a feed where people are sharing not only their progress but also their lifestyle\n */\nexport interface ProgressReport extends SlugModelType {\n  userId: string;\n  /**\n   - what did you get stuck with?\n   - what did you learn?\n   - what are your next steps?\n   */\n  description: string;\n}"
  },
  "Question": {
    "name": "Question",
    "slug": "TsInterface",
    "id": "question",
    "description": "It would be nice to be able to ask question about a topic related to a certain file. People can do a quiz after learning something\n\nNB: in-markdown-object-parsing (see idea file) would be super handy for this because it would let you position the question somewhere in the file",
    "operationName": "os-types",
    "rawText": "\n/**\n * It would be nice to be able to ask question about a topic related to a certain file. People can do a quiz after learning something\n *\n * NB: in-markdown-object-parsing (see idea file) would be super handy for this because it would let you position the question somewhere in the file\n *\n */\nexport interface Question extends SlugModelType {\n  webMarkdownFileId: string;\n  webMarkdownFile?: WebMarkdownFile;\n  description: string;\n  answers?: Answer[];\n}"
  },
  "Reservation": {
    "name": "Reservation",
    "slug": "TsInterface",
    "id": "reservation",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport interface Reservation extends DefaultModelType {\n  userId: Id;\n  /** unix timestamp */\n  checkinAt: number;\n  checkoutAt: number;\n  listingId: Id;\n  paid: number;\n  toPay: number;\n  totalPrice: number;\n  currency: CurrencyString;\n}"
  },
  "Resource": {
    "name": "Resource",
    "slug": "TsInterface",
    "id": "resource",
    "description": "I can attach resources to md-files so its easy to fill in the gaps",
    "operationName": "os-types",
    "rawText": "\n\n/**\n * I can attach resources to md-files so its easy to fill in the gaps\n */\nexport interface Resource extends SlugModelType {\n  webMarkdownFileId: string;\n  webMarkdownFile?: WebMarkdownFile;\n  url: string;\n  description: string;\n}"
  },
  "Shit": {
    "name": "Shit",
    "slug": "TsInterface",
    "id": "shit",
    "description": "which shit types exist?",
    "operationName": "os-types",
    "rawText": "\n\n/**\n * which shit types exist?\n */\nexport interface Shit extends SlugModelType {\n  markdown: Markdown;\n}"
  },
  "ShitLog": {
    "name": "ShitLog",
    "slug": "TsInterface",
    "id": "shitlog",
    "description": "create entries of how you shit, when.\nI believe your shit is strongly related to what you eat but it may also be related to many more things, especially mental things.\nIf we start tracking, we may be able to start seeing patterns",
    "operationName": "os-types",
    "rawText": "\n\n/**\n * create entries of how you shit, when.\n * I believe your shit is strongly related to what you eat but it may also be related to many more things, especially mental things.\n * If we start tracking, we may be able to start seeing patterns\n */\nexport interface ShitLog extends DefaultModelType {\n  shitSlug: Slug;\n  comment?: string;\n}"
  },
  "ShoppingList": {
    "name": "ShoppingList",
    "slug": "TsInterface",
    "id": "shoppinglist",
    "description": "a simple md file with just another string on every line will be enough as a database xD",
    "operationName": "os-types",
    "rawText": "\n\n/**\n * a simple md file with just another string on every line will be enough as a database xD\n */\nexport interface ShoppingList extends KeyValueMarkdownModelType {}"
  },
  "Shortcut": {
    "name": "Shortcut",
    "slug": "TsInterface",
    "id": "shortcut",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport interface Shortcut extends DefaultModelType {\n  name: string;\n  program: ProgramEnum[];\n  operatingSystems: OperatingSystemEnum[];\n  shortcut: string;\n  description?: string;\n}"
  },
  "SkillEnum": {
    "name": "SkillEnum",
    "slug": "TsInterface",
    "id": "skillenum",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport type SkillEnum =\n  | \"react\"\n  | \"react-native\"\n  | \"react-with-native\"\n  | \"typerepo\"\n  | \"node-js\"\n  | \"html\"\n  | \"css\"\n  | \"tailwind\"\n  | \"bash\"\n  | \"git\";"
  },
  "Student": {
    "name": "Student",
    "slug": "TsInterface",
    "id": "student",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport interface Student extends SlugModelType {\n  name: string;\n  age?: number;\n  skills?: string[];\n  country: \"nepal\" | \"brazil\" | \"netherlands\" | \"madagascar\" | \"usa\";\n}"
  },
  "Student2": {
    "name": "Student2",
    "slug": "TsInterface",
    "id": "student2",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport interface Student2 extends SlugModelType {\n  /**\n   * let everyone make a nice profile in markdown\n   */\n  profile: string;\n  githubProfile: string;\n  projectUrls: string[];\n  wakatimeProfileUrl: string;\n  skills: { skill: SkillEnum; level: number }[];\n  ikigai: Ikigai;\n  goal: string;\n  todo: string;\n}"
  },
  "TaskError": {
    "name": "TaskError",
    "slug": "TsInterface",
    "id": "taskerror",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport interface TaskError extends DefaultModelType {\n  task: string;\n  error: string;\n  stackTrace: string;\n}"
  },
  "Trackable": {
    "name": "Trackable",
    "slug": "TsInterface",
    "id": "trackable",
    "description": "maybe this is a possible way to log many things so you don't need to add different models every time",
    "operationName": "os-types",
    "rawText": "\n\n/**\n * maybe this is a possible way to log many things so you don't need to add different models every time\n */\nexport interface Trackable extends DefaultModelType {\n  belongsTo: \"feeling\" | \"slug\";\n  belongsToSlug: Slug;\n  comment: string;\n}"
  },
  "User": {
    "name": "User",
    "slug": "TsInterface",
    "id": "user",
    "description": "",
    "operationName": "os-types",
    "rawText": "\n\nexport interface User extends DefaultModelType {\n  username: string;\n  email?: string;\n  phone?: string;\n  encryptedPassword: string;\n  hostId?: Id;\n}"
  },
  "UserCredential": {
    "name": "UserCredential",
    "slug": "TsInterface",
    "id": "usercredential",
    "description": "Stores which \"users\" YOU are. Only contains your own passwords, not passwords of other people.\n\nUsed for authentication",
    "operationName": "os-types",
    "rawText": "\n\n/**\n * Stores which \"users\" YOU are. Only contains your own passwords, not passwords of other people.\n *\n * Used for authentication\n */\nexport interface UserCredential extends CsvModelType {\n  /**\n   * slug that identifies the platform\n   */\n  platform: string;\n  /**\n   * For some platforms there may be SSO sign in methods\n   */\n  ssoMethod_userCredentialId: Id;\n\n  /**\n   * username, email, phone number\n   *\n   * NB: finding a global decentralised standard for usernames may be difficult, because it differs strongly per website what is allowed. Therefore, just let it be string. it is the widest allowing set of usernames so all values from other data can be stored here.\n   */\n  handle: string;\n  /**\n   * Raw password\n   */\n  rawPassword: string;\n}"
  },
  "Webshop": {
    "name": "Webshop",
    "slug": "TsInterface",
    "id": "webshop",
    "description": "TODO: webshop icons should be taken from a platform -> icon map",
    "operationName": "os-types",
    "rawText": "\n\n/**\n * TODO: webshop icons should be taken from a platform -> icon map\n */\nexport interface Webshop {\n  /**\n   * can be an url to a search page or to a specific item\n   */\n  url: string;\n  /**\n   * if true, this indicates that the url is leading to a search page\n   */\n  isSearchPage: boolean;\n  platform: string;\n}"
  },
  "CrudPage": {
    "name": "CrudPage",
    "slug": "TsInterface",
    "id": "crudpage",
    "description": "Data needed to make a `WebPage`<CrudPage>",
    "operationName": "webpage-types",
    "rawText": "\n/**\n * Data needed to make a `WebPage`<CrudPage>\n */\nexport type CrudPage = {\n  modelName: string;\n  datasetSlugs?: string[];\n  canCreate?: boolean;\n  canRead?: boolean;\n  canUpdate?: boolean;\n  canDelete?: boolean;\n  itemActionFunctionNames?: string[];\n  pageActionFunctionNames?: string[];\n};"
  },
  "CustomWebPage": {
    "name": "CustomWebPage",
    "slug": "TsInterface",
    "id": "customwebpage",
    "description": "different kinds of WebPages",
    "operationName": "webpage-types",
    "rawText": "\n\n//different kinds of WebPages\nexport type CustomWebPage = WebPage<null>;"
  },
  "FilePage": {
    "name": "FilePage",
    "slug": "TsInterface",
    "id": "filepage",
    "description": "",
    "operationName": "reader-ui"
  },
  "FileWebPage": {
    "name": "FileWebPage",
    "slug": "TsInterface",
    "id": "filewebpage",
    "description": "",
    "operationName": "webpage-types",
    "rawText": "\nexport type FileWebPage = WebPage<FilePage>;"
  },
  "FunctionFormPage": {
    "name": "FunctionFormPage",
    "slug": "TsInterface",
    "id": "functionformpage",
    "description": "Data needed to make a `WebPage`<FunctionFormPage>",
    "operationName": "webpage-types",
    "rawText": "\n\n/**\n * Data needed to make a `WebPage`<FunctionFormPage>\n */\nexport type FunctionFormPage = {\n  functionName: string;\n  actionWithResult?: string;\n  routeOnIsSuccessful?: string;\n  customTitle?: string;\n  isMenuHidden?: boolean;\n};"
  },
  "NamedParameters<typeof crudPageToWebPages>": {
    "name": "NamedParameters<typeof crudPageToWebPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-crudpagetowebpages",
    "description": "",
    "operationName": "webpage-types"
  },
  "NamedParameters<typeof functionFormPageToWebPage>": {
    "name": "NamedParameters<typeof functionFormPageToWebPage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-functionformpagetowebpage",
    "description": "",
    "operationName": "webpage-types"
  },
  "WriterWebPage": {
    "name": "WriterWebPage",
    "slug": "TsInterface",
    "id": "writerwebpage",
    "description": "",
    "operationName": "webpage-types",
    "rawText": "\nexport type WriterWebPage = FileWebPage;"
  },
  "NamedParameters<typeof cleanupTsDatabase>": {
    "name": "NamedParameters<typeof cleanupTsDatabase>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-cleanuptsdatabase",
    "description": "",
    "operationName": "cleanup-typescript-database"
  },
  "NamedParameters<typeof shouldDeleteTsModel>": {
    "name": "NamedParameters<typeof shouldDeleteTsModel>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-shoulddeletetsmodel",
    "description": "",
    "operationName": "cleanup-typescript-database"
  },
  "NamedParameters<typeof stripComment>": {
    "name": "NamedParameters<typeof stripComment>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stripcomment",
    "description": "",
    "operationName": "comment-util"
  },
  "NamedParameters<typeof stripCommentEnd>": {
    "name": "NamedParameters<typeof stripCommentEnd>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stripcommentend",
    "description": "",
    "operationName": "comment-util"
  },
  "NamedParameters<typeof stripCommentStart>": {
    "name": "NamedParameters<typeof stripCommentStart>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stripcommentstart",
    "description": "",
    "operationName": "comment-util"
  },
  "NamedParameters<typeof stripSlashes>": {
    "name": "NamedParameters<typeof stripSlashes>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stripslashes",
    "description": "",
    "operationName": "comment-util"
  },
  "NamedParameters<typeof stripStar>": {
    "name": "NamedParameters<typeof stripStar>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stripstar",
    "description": "",
    "operationName": "comment-util"
  },
  "NamedParameters<typeof trim>": {
    "name": "NamedParameters<typeof trim>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-trim",
    "description": "",
    "operationName": "comment-util"
  },
  "NamedParameters<typeof trimSurroundingNewlines>": {
    "name": "NamedParameters<typeof trimSurroundingNewlines>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-trimsurroundingnewlines",
    "description": "",
    "operationName": "comment-util"
  },
  "NamedParameters<typeof getCompileErrors>": {
    "name": "NamedParameters<typeof getCompileErrors>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcompileerrors",
    "description": "",
    "operationName": "compile-typescript"
  },
  "NamedParameters<typeof getTypescriptErrorsFromFiles>": {
    "name": "NamedParameters<typeof getTypescriptErrorsFromFiles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettypescripterrorsfromfiles",
    "description": "",
    "operationName": "compile-typescript"
  },
  "NamedParameters<typeof writeBuildErrors>": {
    "name": "NamedParameters<typeof writeBuildErrors>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-writebuilderrors",
    "description": "",
    "operationName": "compile-typescript"
  },
  "PackageJson": {
    "name": "PackageJson",
    "slug": "TsInterface",
    "id": "packagejson",
    "description": "",
    "operationName": "migrate-operation-model",
    "rawText": "\n\n/**\n * ---\n * dbStorageMethod: jsonSingle\n * operationRelativePath: package.json\n * ---\n */\nexport interface PackageJson extends AnyModelType {\n  // Default keys\n  path?: string;\n  name?: string;\n  main?: string;\n  source?: string;\n  description?: string;\n  version?: string;\n  private?: boolean;\n  author?: string | { [key: string]: string };\n  repository?: string | { type?: string; url: string; directory?: string };\n  homepage?: string;\n  dependencies?: PackageInfoObject;\n  devDependencies?: PackageInfoObject;\n  peerDependencies?: PackageInfoObject;\n  bin?: { [key: string]: string };\n  workspaces?: string[];\n  scripts?: { [commandName: string]: string };\n  // My own keys\n  type?: OperationClassification;\n  sensible?: SensibleConfig;\n  operation?: OperationConfig;\n}"
  },
  "NamedParameters<typeof findDependantsRecursivelyTest>": {
    "name": "NamedParameters<typeof findDependantsRecursivelyTest>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-finddependantsrecursivelytest",
    "description": "",
    "operationName": "find-all-dependency-operations"
  },
  "NamedParameters<typeof generateBunMonopackage>": {
    "name": "NamedParameters<typeof generateBunMonopackage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatebunmonopackage",
    "description": "",
    "operationName": "generate-bun-monopackage"
  },
  "NamedParameters<typeof getItemNewPath>": {
    "name": "NamedParameters<typeof getItemNewPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getitemnewpath",
    "description": "",
    "operationName": "generate-bun-monopackage"
  },
  "ImportStatement": {
    "name": "ImportStatement",
    "slug": "TsInterface",
    "id": "importstatement",
    "description": "",
    "operationName": "generate-index",
    "rawText": "\n\nexport type ImportStatement = {\n  type: \"variable\" | \"function\" | \"interface\";\n  name: string;\n  srcRelativeFileId: string;\n};"
  },
  "NamedParameters<typeof generateNamedIndex>": {
    "name": "NamedParameters<typeof generateNamedIndex>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatenamedindex",
    "description": "",
    "operationName": "generate-index"
  },
  "NamedParameters<typeof generateSimpleIndex>": {
    "name": "NamedParameters<typeof generateSimpleIndex>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatesimpleindex",
    "description": "",
    "operationName": "generate-index"
  },
  "NamedParameters<typeof isTestFn>": {
    "name": "NamedParameters<typeof isTestFn>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-istestfn",
    "description": "",
    "operationName": "generate-index"
  },
  "NamedParameters<typeof mapToImportStatement>": {
    "name": "NamedParameters<typeof mapToImportStatement>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-maptoimportstatement",
    "description": "",
    "operationName": "generate-index"
  },
  "FunctionsPerClassification": {
    "name": "FunctionsPerClassification",
    "slug": "TsInterface",
    "id": "functionsperclassification",
    "description": "relative",
    "operationName": "generate-sdk-operations",
    "rawText": "\n// relative\n\nexport type FunctionsPerClassification = {\n  [operationClassification in OperationClassification]: TsFunction[];\n};"
  },
  "NamedParameters<typeof generateDbSdk>": {
    "name": "NamedParameters<typeof generateDbSdk>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatedbsdk",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateDbSdkCli>": {
    "name": "NamedParameters<typeof generateDbSdkCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatedbsdkcli",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateEnvSdks>": {
    "name": "NamedParameters<typeof generateEnvSdks>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateenvsdks",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateEnvSdksCli>": {
    "name": "NamedParameters<typeof generateEnvSdksCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateenvsdkscli",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateFunctionPathsSdk>": {
    "name": "NamedParameters<typeof generateFunctionPathsSdk>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatefunctionpathssdk",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateFunctionSdks>": {
    "name": "NamedParameters<typeof generateFunctionSdks>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatefunctionsdks",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateFunctionSdksCli>": {
    "name": "NamedParameters<typeof generateFunctionSdksCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatefunctionsdkscli",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateInterfacePathsSdk>": {
    "name": "NamedParameters<typeof generateInterfacePathsSdk>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateinterfacepathssdk",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateInterfacePathsSdkCli>": {
    "name": "NamedParameters<typeof generateInterfacePathsSdkCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateinterfacepathssdkcli",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateOperationsSdk>": {
    "name": "NamedParameters<typeof generateOperationsSdk>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateoperationssdk",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateOperationsSdkCli>": {
    "name": "NamedParameters<typeof generateOperationsSdkCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateoperationssdkcli",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateSdkApi>": {
    "name": "NamedParameters<typeof generateSdkApi>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatesdkapi",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateSdkApiCli>": {
    "name": "NamedParameters<typeof generateSdkApiCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatesdkapicli",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateSdkApiWatcher>": {
    "name": "NamedParameters<typeof generateSdkApiWatcher>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatesdkapiwatcher",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateSdkOperations>": {
    "name": "NamedParameters<typeof generateSdkOperations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatesdkoperations",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateSdkOperationsCli>": {
    "name": "NamedParameters<typeof generateSdkOperationsCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatesdkoperationscli",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof getFunctionSdksContent>": {
    "name": "NamedParameters<typeof getFunctionSdksContent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfunctionsdkscontent",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof getSdkDescription>": {
    "name": "NamedParameters<typeof getSdkDescription>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsdkdescription",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof getSdkFunctionsPerClassification>": {
    "name": "NamedParameters<typeof getSdkFunctionsPerClassification>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsdkfunctionsperclassification",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof isNonUiOperationBuild>": {
    "name": "NamedParameters<typeof isNonUiOperationBuild>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isnonuioperationbuild",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof newEnvSdk>": {
    "name": "NamedParameters<typeof newEnvSdk>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-newenvsdk",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof newFunctionKeysSdkOperation>": {
    "name": "NamedParameters<typeof newFunctionKeysSdkOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-newfunctionkeyssdkoperation",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof newFunctionSdkOperation>": {
    "name": "NamedParameters<typeof newFunctionSdkOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-newfunctionsdkoperation",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof tsFunctionIsIndexable>": {
    "name": "NamedParameters<typeof tsFunctionIsIndexable>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tsfunctionisindexable",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof tsFunctionIsSdkable>": {
    "name": "NamedParameters<typeof tsFunctionIsSdkable>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tsfunctionissdkable",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof updateClassifications>": {
    "name": "NamedParameters<typeof updateClassifications>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-updateclassifications",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof getImportedDependencies>": {
    "name": "NamedParameters<typeof getImportedDependencies>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getimporteddependencies",
    "description": "",
    "operationName": "get-imported-dependencies"
  },
  "NamedParameters<typeof getPackage>": {
    "name": "NamedParameters<typeof getPackage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpackage",
    "description": "",
    "operationName": "get-imported-dependencies"
  },
  "NamedParameters<typeof isAbsoluteImport>": {
    "name": "NamedParameters<typeof isAbsoluteImport>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isabsoluteimport",
    "description": "",
    "operationName": "get-imported-dependencies"
  },
  "NamedParameters<typeof calculatePackageJsonDependencies>": {
    "name": "NamedParameters<typeof calculatePackageJsonDependencies>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-calculatepackagejsondependencies",
    "description": "",
    "operationName": "get-imports-exports"
  },
  "NamedParameters<typeof findAndWriteImportsExports>": {
    "name": "NamedParameters<typeof findAndWriteImportsExports>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findandwriteimportsexports",
    "description": "",
    "operationName": "get-imports-exports"
  },
  "NamedParameters<typeof getImportsExportsTest>": {
    "name": "NamedParameters<typeof getImportsExportsTest>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getimportsexportstest",
    "description": "",
    "operationName": "get-imports-exports"
  },
  "NamedParameters<typeof getPackageNameFromAbsoluteImport>": {
    "name": "NamedParameters<typeof getPackageNameFromAbsoluteImport>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpackagenamefromabsoluteimport",
    "description": "",
    "operationName": "get-imports-exports"
  },
  "NamedParameters<typeof isAbsoluteImportBuiltin>": {
    "name": "NamedParameters<typeof isAbsoluteImportBuiltin>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isabsoluteimportbuiltin",
    "description": "",
    "operationName": "get-imports-exports"
  },
  "NamedParameters<typeof isImportFromOptionalFile>": {
    "name": "NamedParameters<typeof isImportFromOptionalFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isimportfromoptionalfile",
    "description": "",
    "operationName": "get-imports-exports"
  },
  "NamedParameters<typeof isImportGenerated>": {
    "name": "NamedParameters<typeof isImportGenerated>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isimportgenerated",
    "description": "",
    "operationName": "get-imports-exports"
  },
  "NamedParameters<typeof writeResult>": {
    "name": "NamedParameters<typeof writeResult>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-writeresult",
    "description": "",
    "operationName": "get-imports-exports"
  },
  "NamedParameters<typeof getMissingDependencies>": {
    "name": "NamedParameters<typeof getMissingDependencies>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmissingdependencies",
    "description": "",
    "operationName": "get-missing-dependencies"
  },
  "CommentRange": {
    "name": "CommentRange",
    "slug": "TsInterface",
    "id": "commentrange",
    "description": "",
    "operationName": "index-typescript"
  },
  "CompleteOperationPathParse": {
    "name": "CompleteOperationPathParse",
    "slug": "TsInterface",
    "id": "completeoperationpathparse",
    "description": "",
    "operationName": "index-typescript",
    "rawText": "\n\nexport type CompleteOperationPathParse = OperationPathParse & {\n  filePath: string;\n};"
  },
  "Config": {
    "name": "Config",
    "slug": "TsInterface",
    "id": "config",
    "description": "",
    "operationName": "index-typescript"
  },
  "MorphInterfaceInfo": {
    "name": "MorphInterfaceInfo",
    "slug": "TsInterface",
    "id": "morphinterfaceinfo",
    "description": "",
    "operationName": "index-typescript",
    "rawText": "export type MorphInterfaceInfo = {\n  raw: string;\n  name: string;\n  description?: string;\n  extensions: string[];\n  isExported: boolean;\n  hasGeneric: boolean;\n};"
  },
  "NamedParameters<typeof cli>": {
    "name": "NamedParameters<typeof cli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-cli",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof findCommentTypes>": {
    "name": "NamedParameters<typeof findCommentTypes>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findcommenttypes",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof generateSchema>": {
    "name": "NamedParameters<typeof generateSchema>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateschema",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof getDbStorageMethod>": {
    "name": "NamedParameters<typeof getDbStorageMethod>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdbstoragemethod",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof getFrontmatterDbStorageMethod>": {
    "name": "NamedParameters<typeof getFrontmatterDbStorageMethod>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfrontmatterdbstoragemethod",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof getIndexId>": {
    "name": "NamedParameters<typeof getIndexId>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getindexid",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof getMaxIndentationDepth>": {
    "name": "NamedParameters<typeof getMaxIndentationDepth>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmaxindentationdepth",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof getNumberOfLines>": {
    "name": "NamedParameters<typeof getNumberOfLines>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getnumberoflines",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof getParametersFromInterfaces>": {
    "name": "NamedParameters<typeof getParametersFromInterfaces>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getparametersfrominterfaces",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof getPossibleRefs>": {
    "name": "NamedParameters<typeof getPossibleRefs>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpossiblerefs",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof getSpecialExtensionDbStorageMethod>": {
    "name": "NamedParameters<typeof getSpecialExtensionDbStorageMethod>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getspecialextensiondbstoragemethod",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof getValidatedOperationPathParse>": {
    "name": "NamedParameters<typeof getValidatedOperationPathParse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getvalidatedoperationpathparse",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof hasDefinition>": {
    "name": "NamedParameters<typeof hasDefinition>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-hasdefinition",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof hasTypescriptFileChanged>": {
    "name": "NamedParameters<typeof hasTypescriptFileChanged>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-hastypescriptfilechanged",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof indexTypescript>": {
    "name": "NamedParameters<typeof indexTypescript>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-indextypescript",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof indexTypescriptFile>": {
    "name": "NamedParameters<typeof indexTypescriptFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-indextypescriptfile",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof makeTsComment>": {
    "name": "NamedParameters<typeof makeTsComment>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-maketscomment",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof schemaToTsInterface>": {
    "name": "NamedParameters<typeof schemaToTsInterface>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-schematotsinterface",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof tryCreateSchema>": {
    "name": "NamedParameters<typeof tryCreateSchema>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-trycreateschema",
    "description": "",
    "operationName": "index-typescript"
  },
  "Project": {
    "name": "Project",
    "slug": "TsInterface",
    "id": "project",
    "description": "Project that holds source files.",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof preIndexLint>": {
    "name": "NamedParameters<typeof preIndexLint>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-preindexlint",
    "description": "",
    "operationName": "lint"
  },
  "NamedParameters<typeof minifyBuild>": {
    "name": "NamedParameters<typeof minifyBuild>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-minifybuild",
    "description": "",
    "operationName": "minify-build"
  },
  "NamedParameters<typeof getAvailableOperationName>": {
    "name": "NamedParameters<typeof getAvailableOperationName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getavailableoperationname",
    "description": "",
    "operationName": "new-template"
  },
  "NamedParameters<typeof newOperation>": {
    "name": "NamedParameters<typeof newOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-newoperation",
    "description": "",
    "operationName": "new-template"
  },
  "NamedParameters<typeof newOperationCli>": {
    "name": "NamedParameters<typeof newOperationCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-newoperationcli",
    "description": "",
    "operationName": "new-template"
  },
  "NamedParameters<typeof newOperationWithFiles>": {
    "name": "NamedParameters<typeof newOperationWithFiles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-newoperationwithfiles",
    "description": "",
    "operationName": "new-template"
  },
  "NamedParameters<typeof newTemplate>": {
    "name": "NamedParameters<typeof newTemplate>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-newtemplate",
    "description": "",
    "operationName": "new-template"
  },
  "NamedParameters<typeof newTemplateCli>": {
    "name": "NamedParameters<typeof newTemplateCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-newtemplatecli",
    "description": "",
    "operationName": "new-template"
  },
  "NamedParameters<typeof buildPackage>": {
    "name": "NamedParameters<typeof buildPackage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-buildpackage",
    "description": "",
    "operationName": "package-scripts"
  },
  "NamedParameters<typeof installMissingMonorepoDependencies>": {
    "name": "NamedParameters<typeof installMissingMonorepoDependencies>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-installmissingmonorepodependencies",
    "description": "",
    "operationName": "package-scripts"
  },
  "NamedParameters<typeof obfucsate>": {
    "name": "NamedParameters<typeof obfucsate>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-obfucsate",
    "description": "",
    "operationName": "package-scripts"
  },
  "NamedParameters<typeof testPackage>": {
    "name": "NamedParameters<typeof testPackage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-testpackage",
    "description": "",
    "operationName": "package-scripts"
  },
  "NamedParameters<typeof prettierOperation>": {
    "name": "NamedParameters<typeof prettierOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-prettieroperation",
    "description": "",
    "operationName": "prettier-operation"
  },
  "NamedParameters<typeof clearTsDatabase>": {
    "name": "NamedParameters<typeof clearTsDatabase>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-cleartsdatabase",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof executeCommandQuietUnlessFail>": {
    "name": "NamedParameters<typeof executeCommandQuietUnlessFail>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-executecommandquietunlessfail",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof exitIfProcessDependenciesChanged>": {
    "name": "NamedParameters<typeof exitIfProcessDependenciesChanged>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-exitifprocessdependencieschanged",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof generateJsonSchemas>": {
    "name": "NamedParameters<typeof generateJsonSchemas>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatejsonschemas",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof getAllDbModels>": {
    "name": "NamedParameters<typeof getAllDbModels>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getalldbmodels",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof getFileIds>": {
    "name": "NamedParameters<typeof getFileIds>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfileids",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof getIndexFileIds>": {
    "name": "NamedParameters<typeof getIndexFileIds>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getindexfileids",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof getSrcIds>": {
    "name": "NamedParameters<typeof getSrcIds>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsrcids",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof isOperationBuildNeeded>": {
    "name": "NamedParameters<typeof isOperationBuildNeeded>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isoperationbuildneeded",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof isSdkOperation>": {
    "name": "NamedParameters<typeof isSdkOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-issdkoperation",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof rebuildAllOperations>": {
    "name": "NamedParameters<typeof rebuildAllOperations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rebuildalloperations",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof rebuildOperation>": {
    "name": "NamedParameters<typeof rebuildOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rebuildoperation",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof rebuildOperationCli>": {
    "name": "NamedParameters<typeof rebuildOperationCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rebuildoperationcli",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof shouldSkip>": {
    "name": "NamedParameters<typeof shouldSkip>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-shouldskip",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof yarnBuild>": {
    "name": "NamedParameters<typeof yarnBuild>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-yarnbuild",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof renameOperation>": {
    "name": "NamedParameters<typeof renameOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-renameoperation",
    "description": "",
    "operationName": "rename-operation"
  },
  "JSONSchema7Definition": {
    "name": "JSONSchema7Definition",
    "slug": "TsInterface",
    "id": "jsonschema7definition",
    "description": "JSON Schema v7",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof findFirstCommentTypes>": {
    "name": "NamedParameters<typeof findFirstCommentTypes>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findfirstcommenttypes",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof getDataParameterNames>": {
    "name": "NamedParameters<typeof getDataParameterNames>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdataparameternames",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof getPossibleReferenceParameterNames>": {
    "name": "NamedParameters<typeof getPossibleReferenceParameterNames>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpossiblereferenceparameternames",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof getProperties>": {
    "name": "NamedParameters<typeof getProperties>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getproperties",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof getReferencableModels>": {
    "name": "NamedParameters<typeof getReferencableModels>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getreferencablemodels",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof getReferenceParameterInfo>": {
    "name": "NamedParameters<typeof getReferenceParameterInfo>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getreferenceparameterinfo",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof getRefLink>": {
    "name": "NamedParameters<typeof getRefLink>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getreflink",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof getSchema>": {
    "name": "NamedParameters<typeof getSchema>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getschema",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof getSchemaItems>": {
    "name": "NamedParameters<typeof getSchemaItems>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getschemaitems",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof simplifiedSchemaToTypeDefinitionString>": {
    "name": "NamedParameters<typeof simplifiedSchemaToTypeDefinitionString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-simplifiedschematotypedefinitionstring",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof simplifySchema>": {
    "name": "NamedParameters<typeof simplifySchema>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-simplifyschema",
    "description": "",
    "operationName": "schema-util"
  },
  "ReferenceParameterInfo": {
    "name": "ReferenceParameterInfo",
    "slug": "TsInterface",
    "id": "referenceparameterinfo",
    "description": "",
    "operationName": "simplified-schema-form"
  },
  "SchemaItem": {
    "name": "SchemaItem",
    "slug": "TsInterface",
    "id": "schemaitem",
    "description": "",
    "operationName": "schema-util",
    "rawText": "\n\nexport type SchemaItem = {\n  /**\n   * name in case of it being a reference, otherwise null\n   */\n  name: string | null;\n  schema: Schema;\n};"
  },
  "SchemaProperty": {
    "name": "SchemaProperty",
    "slug": "TsInterface",
    "id": "schemaproperty",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof createOperationsSdkCli>": {
    "name": "NamedParameters<typeof createOperationsSdkCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-createoperationssdkcli",
    "description": "",
    "operationName": "simple-typescript-node"
  },
  "NamedParameters<typeof createSimpleTypescriptFile>": {
    "name": "NamedParameters<typeof createSimpleTypescriptFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-createsimpletypescriptfile",
    "description": "",
    "operationName": "simple-typescript-node"
  },
  "SimpleTypescriptFile": {
    "name": "SimpleTypescriptFile",
    "slug": "TsInterface",
    "id": "simpletypescriptfile",
    "description": "Generate simple typescript files",
    "operationName": "simple-typescript-node"
  },
  "NamedParameters<typeof runTestsForOperation>": {
    "name": "NamedParameters<typeof runTestsForOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-runtestsforoperation",
    "description": "",
    "operationName": "k-test"
  },
  "NamedParameters<typeof sum>": {
    "name": "NamedParameters<typeof sum>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-sum",
    "description": "",
    "operationName": "k-test"
  },
  "NamedParameters<typeof getAllTsMorphSourceFiles>": {
    "name": "NamedParameters<typeof getAllTsMorphSourceFiles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getalltsmorphsourcefiles",
    "description": "",
    "operationName": "ts-morph-util"
  },
  "NamedParameters<typeof getTsMorphProject>": {
    "name": "NamedParameters<typeof getTsMorphProject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettsmorphproject",
    "description": "",
    "operationName": "ts-morph-util"
  },
  "ApiConfig": {
    "name": "ApiConfig",
    "slug": "TsInterface",
    "id": "apiconfig",
    "description": "",
    "operationName": "api"
  },
  "NamedParameters<typeof fn1>": {
    "name": "NamedParameters<typeof fn1>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fn1",
    "description": "",
    "operationName": "api"
  },
  "NamedParameters<typeof fn2>": {
    "name": "NamedParameters<typeof fn2>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fn2",
    "description": "",
    "operationName": "api"
  },
  "NamedParameters<typeof fn3>": {
    "name": "NamedParameters<typeof fn3>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fn3",
    "description": "",
    "operationName": "api"
  },
  "NamedParameters<typeof getGetApiUrl>": {
    "name": "NamedParameters<typeof getGetApiUrl>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getgetapiurl",
    "description": "",
    "operationName": "api"
  },
  "NamedParameters<typeof untypedApiFunction>": {
    "name": "NamedParameters<typeof untypedApiFunction>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-untypedapifunction",
    "description": "",
    "operationName": "api"
  },
  "ApiStoreType": {
    "name": "ApiStoreType",
    "slug": "TsInterface",
    "id": "apistoretype",
    "description": "",
    "operationName": "api-store",
    "rawText": "\n\nexport type ApiStoreType = {\n  /**\n   * authToken coupled to device, set by browser automatically on first pageload\n   *\n   * can also be changed by logging in\n   */\n  \"api.authToken\": string;\n  /**\n   * Can set this up in config to connect with different api\n   */\n  \"api.customUrl\": string | null;\n  /**\n   * If the api doesn't response, this will be set to last date.\n   * If the api responds, this will be reset\n   */\n  \"api.timeoutAt\": null | number;\n};"
  },
  "NamedParameters<typeof comparePassword>": {
    "name": "NamedParameters<typeof comparePassword>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-comparepassword",
    "description": "",
    "operationName": "encrypt-password"
  },
  "NamedParameters<typeof executeCronFunction>": {
    "name": "NamedParameters<typeof executeCronFunction>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-executecronfunction",
    "description": "",
    "operationName": "function-server"
  },
  "NamedParameters<typeof runFunctionServer>": {
    "name": "NamedParameters<typeof runFunctionServer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-runfunctionserver",
    "description": "",
    "operationName": "function-server"
  },
  "NamedParameters<typeof runFunctionServerCli>": {
    "name": "NamedParameters<typeof runFunctionServerCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-runfunctionservercli",
    "description": "",
    "operationName": "function-server"
  },
  "NamedParameters<typeof runFunctionServerDev>": {
    "name": "NamedParameters<typeof runFunctionServerDev>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-runfunctionserverdev",
    "description": "",
    "operationName": "function-server"
  },
  "NamedParameters<typeof runFunctionServerDevCli>": {
    "name": "NamedParameters<typeof runFunctionServerDevCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-runfunctionserverdevcli",
    "description": "",
    "operationName": "function-server"
  },
  "NamedParameters<typeof scheduleCronJobs>": {
    "name": "NamedParameters<typeof scheduleCronJobs>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-schedulecronjobs",
    "description": "",
    "operationName": "function-server"
  },
  "NamedParameters<typeof startSearchWebIfAvailable>": {
    "name": "NamedParameters<typeof startSearchWebIfAvailable>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-startsearchwebifavailable",
    "description": "",
    "operationName": "function-server"
  },
  "AuthorizationInfo": {
    "name": "AuthorizationInfo",
    "slug": "TsInterface",
    "id": "authorizationinfo",
    "description": "",
    "operationName": "function-server-endpoints",
    "rawText": "\n\nexport type AuthorizationInfo = {\n  /**\n   * Whether or not the device is authorized to execute this function\n   */\n  hasAuthorization: boolean;\n  /**\n   * All authorizations for this device that may apply to this function.\n   *\n   * It comprises:\n   *\n   * - the `publicAuthorization` for this function\n   * - the custom authorizations for all `Person`s for the `Device`\n   * - the authorizations of all groups found for all `Person`s for the `Device`\n   */\n  authorizations: Authorization[];\n  /**\n   * Unique `Group`s for all `Person`s for this `Device`\n   */\n  groups: Group[];\n};"
  },
  "NamedParameters<typeof calculateDeviceName>": {
    "name": "NamedParameters<typeof calculateDeviceName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-calculatedevicename",
    "description": "",
    "operationName": "function-server-endpoints"
  },
  "NamedParameters<typeof getAuthorizationInfo>": {
    "name": "NamedParameters<typeof getAuthorizationInfo>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getauthorizationinfo",
    "description": "",
    "operationName": "function-server-endpoints"
  },
  "NamedParameters<typeof isGetEndpoint>": {
    "name": "NamedParameters<typeof isGetEndpoint>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isgetendpoint",
    "description": "",
    "operationName": "function-server-endpoints"
  },
  "NamedParameters<typeof savePageVisit>": {
    "name": "NamedParameters<typeof savePageVisit>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-savepagevisit",
    "description": "",
    "operationName": "function-server-endpoints"
  },
  "NamedParameters<typeof storeFunctionExecution>": {
    "name": "NamedParameters<typeof storeFunctionExecution>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-storefunctionexecution",
    "description": "",
    "operationName": "function-server-endpoints"
  },
  "ApiFunction": {
    "name": "ApiFunction",
    "slug": "TsInterface",
    "id": "apifunction",
    "description": "",
    "operationName": "function-server-types",
    "rawText": "export type ApiFunction = {\n  (...parameters: any[]): any;\n  isPublic?: boolean;\n  /**\n   * - If true, usage will be counted in UsageReport\n   * - If \"isSuccessful\", usage will be counted only if this function returns `.isSuccessful: true`\n   *\n   * NB: not sure if the latter is needed\n   *\n   */\n  isPaid?: true | \"isSuccessful\";\n  /**\n   * Cost per execution in EUROCENT\n   *\n   * e.g. 0.05 means that 2000 executions cost 1 euro.\n   */\n  price?: number;\n  allowedRoles?: string[];\n};"
  },
  "NamedParameters<typeof addAuthenticationMethod>": {
    "name": "NamedParameters<typeof addAuthenticationMethod>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-addauthenticationmethod",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof addDeviceAuthenticationMethodConfirm>": {
    "name": "NamedParameters<typeof addDeviceAuthenticationMethodConfirm>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-adddeviceauthenticationmethodconfirm",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof addDeviceAuthenticationMethodWithContext>": {
    "name": "NamedParameters<typeof addDeviceAuthenticationMethodWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-adddeviceauthenticationmethodwithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof addPersonAuthenticationMethodWithContext>": {
    "name": "NamedParameters<typeof addPersonAuthenticationMethodWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-addpersonauthenticationmethodwithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof findAuthenticatedPersonWithHandle>": {
    "name": "NamedParameters<typeof findAuthenticatedPersonWithHandle>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findauthenticatedpersonwithhandle",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof findLoggedinPersonsWithContext>": {
    "name": "NamedParameters<typeof findLoggedinPersonsWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findloggedinpersonswithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof getMeWithContext>": {
    "name": "NamedParameters<typeof getMeWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmewithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof getPublicPerson>": {
    "name": "NamedParameters<typeof getPublicPerson>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpublicperson",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof getPublicPersons>": {
    "name": "NamedParameters<typeof getPublicPersons>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpublicpersons",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof isPhoneNumber>": {
    "name": "NamedParameters<typeof isPhoneNumber>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isphonenumber",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof isValidPassword>": {
    "name": "NamedParameters<typeof isValidPassword>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isvalidpassword",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof loginWithContext>": {
    "name": "NamedParameters<typeof loginWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-loginwithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof loginWithPasswordWithContext>": {
    "name": "NamedParameters<typeof loginWithPasswordWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-loginwithpasswordwithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof logoutWithContext>": {
    "name": "NamedParameters<typeof logoutWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-logoutwithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof removeDeviceAuthenticationMethodWithContext>": {
    "name": "NamedParameters<typeof removeDeviceAuthenticationMethodWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removedeviceauthenticationmethodwithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof removePersonAuthenticationMethodWithContext>": {
    "name": "NamedParameters<typeof removePersonAuthenticationMethodWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removepersonauthenticationmethodwithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof signupWithContext>": {
    "name": "NamedParameters<typeof signupWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-signupwithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof signupWithPasswordWithContext>": {
    "name": "NamedParameters<typeof signupWithPasswordWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-signupwithpasswordwithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof switchCurrentPersonWithContext>": {
    "name": "NamedParameters<typeof switchCurrentPersonWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-switchcurrentpersonwithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof updateMeWithContext>": {
    "name": "NamedParameters<typeof updateMeWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-updatemewithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "SignupPersonData": {
    "name": "SignupPersonData",
    "slug": "TsInterface",
    "id": "signuppersondata",
    "description": "",
    "operationName": "server-login",
    "rawText": "\n\nexport type SignupPersonData = Pick<\n  Person,\n  | \"authorizations\"\n  | \"credit\"\n  | \"dataEntries\"\n  | \"interestSlugs\"\n  | \"media\"\n  | \"name\"\n  | \"slug\"\n  | \"pictureImage\"\n  | \"groupSlugs\"\n  | \"requiredAuthenticationMethods\"\n  | \"amountAuthenticationMethodsRequired\"\n>;"
  },
  "NamedParameters<typeof sayDutch>": {
    "name": "NamedParameters<typeof sayDutch>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-saydutch",
    "description": "",
    "operationName": "say"
  },
  "NamedParameters<typeof sayLanguage>": {
    "name": "NamedParameters<typeof sayLanguage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-saylanguage",
    "description": "",
    "operationName": "say"
  },
  "NamedParameters<typeof sayNepali>": {
    "name": "NamedParameters<typeof sayNepali>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-saynepali",
    "description": "",
    "operationName": "say"
  },
  "NamedParameters<typeof saySomething>": {
    "name": "NamedParameters<typeof saySomething>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-saysomething",
    "description": "",
    "operationName": "say"
  },
  "NamedParameters<typeof textToMp3>": {
    "name": "NamedParameters<typeof textToMp3>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-texttomp3",
    "description": "",
    "operationName": "say"
  },
  "SayOptions": {
    "name": "SayOptions",
    "slug": "TsInterface",
    "id": "sayoptions",
    "description": "",
    "operationName": "say",
    "rawText": "\nexport type SayOptions = {\n  /**\n   * Specify an absolute path to a file with some text\n   */\n  filePath?: string;\n  /**\n   * message string to be said\n   */\n  message?: string;\n  speechRate?: number;\n  voice?: string;\n  outputFilePath?: string;\n  audioDevice?: string;\n  showProgress?: boolean;\n  interactive?: string;\n  fileFormat?: string;\n  dataFormat?: string;\n  bitRate?: number;\n  quality?: number;\n};"
  },
  "NamedParameters<typeof ask>": {
    "name": "NamedParameters<typeof ask>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-ask",
    "description": "",
    "operationName": "ask"
  },
  "NamedParameters<typeof askOk>": {
    "name": "NamedParameters<typeof askOk>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-askok",
    "description": "",
    "operationName": "ask"
  },
  "NamedParameters<typeof getArgumentOrAsk>": {
    "name": "NamedParameters<typeof getArgumentOrAsk>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getargumentorask",
    "description": "",
    "operationName": "ask"
  },
  "NamedParameters<typeof cliVersionUpdates>": {
    "name": "NamedParameters<typeof cliVersionUpdates>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-cliversionupdates",
    "description": "",
    "operationName": "cli-version-updates"
  },
  "NamedParameters<typeof getPackageVersions>": {
    "name": "NamedParameters<typeof getPackageVersions>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpackageversions",
    "description": "",
    "operationName": "cli-version-updates"
  },
  "NamedParameters<typeof getUpdateSeverity>": {
    "name": "NamedParameters<typeof getUpdateSeverity>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getupdateseverity",
    "description": "",
    "operationName": "cli-version-updates"
  },
  "NamedParameters<typeof getVersionParts>": {
    "name": "NamedParameters<typeof getVersionParts>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getversionparts",
    "description": "",
    "operationName": "cli-version-updates"
  },
  "NamedParameters<typeof handleVersionUpdates>": {
    "name": "NamedParameters<typeof handleVersionUpdates>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-handleversionupdates",
    "description": "",
    "operationName": "cli-version-updates"
  },
  "FnMatch": {
    "name": "FnMatch",
    "slug": "TsInterface",
    "id": "fnmatch",
    "description": "",
    "operationName": "function-util",
    "rawText": "\n\nexport type FnMatch = {\n  matcher: string;\n  relativeOperationPath: string;\n} & TsFunction;"
  },
  "NamedParameters<typeof chat>": {
    "name": "NamedParameters<typeof chat>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-chat",
    "description": "",
    "operationName": "function-util"
  },
  "NamedParameters<typeof converse>": {
    "name": "NamedParameters<typeof converse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-converse",
    "description": "",
    "operationName": "function-util"
  },
  "NamedParameters<typeof doCli>": {
    "name": "NamedParameters<typeof doCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-docli",
    "description": "",
    "operationName": "function-util"
  },
  "NamedParameters<typeof executeSdkFunction>": {
    "name": "NamedParameters<typeof executeSdkFunction>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-executesdkfunction",
    "description": "",
    "operationName": "function-util"
  },
  "NamedParameters<typeof getCachedExportedFunctions>": {
    "name": "NamedParameters<typeof getCachedExportedFunctions>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcachedexportedfunctions",
    "description": "",
    "operationName": "function-util"
  },
  "NamedParameters<typeof getMenu>": {
    "name": "NamedParameters<typeof getMenu>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmenu",
    "description": "",
    "operationName": "function-util"
  },
  "NamedParameters<typeof getParameters>": {
    "name": "NamedParameters<typeof getParameters>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getparameters",
    "description": "",
    "operationName": "function-util"
  },
  "NamedParameters<typeof getParametersAndExecute>": {
    "name": "NamedParameters<typeof getParametersAndExecute>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getparametersandexecute",
    "description": "",
    "operationName": "function-util"
  },
  "NamedParameters<typeof getSdkFunctionPaths>": {
    "name": "NamedParameters<typeof getSdkFunctionPaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsdkfunctionpaths",
    "description": "",
    "operationName": "function-util"
  },
  "NamedParameters<typeof listen>": {
    "name": "NamedParameters<typeof listen>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-listen",
    "description": "",
    "operationName": "function-util"
  },
  "JSONValue": {
    "name": "JSONValue",
    "slug": "TsInterface",
    "id": "jsonvalue",
    "description": "",
    "operationName": "string-to-json",
    "rawText": "export type JSONValue =\n  | null\n  | undefined\n  | boolean\n  | number\n  | string\n  | { [key: string]: JSONValue }\n  | JSONValue[];"
  },
  "NamedParameters<typeof objectStringToJson>": {
    "name": "NamedParameters<typeof objectStringToJson>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-objectstringtojson",
    "description": "",
    "operationName": "string-to-json"
  },
  "NamedParameters<typeof parseIfJson>": {
    "name": "NamedParameters<typeof parseIfJson>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parseifjson",
    "description": "",
    "operationName": "string-to-json"
  },
  "NamedParameters<typeof parsePrimitiveJson>": {
    "name": "NamedParameters<typeof parsePrimitiveJson>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parseprimitivejson",
    "description": "",
    "operationName": "string-to-json"
  },
  "NamedParameters<typeof stringToJson>": {
    "name": "NamedParameters<typeof stringToJson>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stringtojson",
    "description": "",
    "operationName": "string-to-json"
  },
  "NamedParameters<typeof BreadCrumbs>": {
    "name": "NamedParameters<typeof BreadCrumbs>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-breadcrumbs",
    "description": "",
    "operationName": "breadcrumbs"
  },
  "NamedParameters<typeof renderBreadCrumbs>": {
    "name": "NamedParameters<typeof renderBreadCrumbs>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-renderbreadcrumbs",
    "description": "",
    "operationName": "breadcrumbs"
  },
  "NamedParameters<typeof errorToast>": {
    "name": "NamedParameters<typeof errorToast>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-errortoast",
    "description": "",
    "operationName": "cool-toast"
  },
  "NamedParameters<typeof infoToast>": {
    "name": "NamedParameters<typeof infoToast>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-infotoast",
    "description": "",
    "operationName": "cool-toast"
  },
  "NamedParameters<typeof showStandardResponse>": {
    "name": "NamedParameters<typeof showStandardResponse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-showstandardresponse",
    "description": "",
    "operationName": "cool-toast"
  },
  "NamedParameters<typeof successToast>": {
    "name": "NamedParameters<typeof successToast>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-successtoast",
    "description": "",
    "operationName": "cool-toast"
  },
  "NamedParameters<typeof warningToast>": {
    "name": "NamedParameters<typeof warningToast>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-warningtoast",
    "description": "",
    "operationName": "cool-toast"
  },
  "StandardizedApiReturnType": {
    "name": "StandardizedApiReturnType",
    "slug": "TsInterface",
    "id": "standardizedapireturntype",
    "description": "Handy type interface for rendering response",
    "operationName": "cool-toast"
  },
  "NamedParameters<typeof FancyLoader>": {
    "name": "NamedParameters<typeof FancyLoader>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fancyloader",
    "description": "",
    "operationName": "fancy-loader"
  },
  "NamedParameters<typeof getFileType>": {
    "name": "NamedParameters<typeof getFileType>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfiletype",
    "description": "",
    "operationName": "file-icons"
  },
  "TypeIconEnum": {
    "name": "TypeIconEnum",
    "slug": "TsInterface",
    "id": "typeiconenum",
    "description": "",
    "operationName": "file-icons",
    "rawText": "\n\nexport type TypeIconEnum = keyof typeof typeIcons;"
  },
  "NamedParameters<typeof getFullPath>": {
    "name": "NamedParameters<typeof getFullPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfullpath",
    "description": "",
    "operationName": "next-paths"
  },
  "NamedParameters<typeof getLastPathsChunk>": {
    "name": "NamedParameters<typeof getLastPathsChunk>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getlastpathschunk",
    "description": "",
    "operationName": "next-paths"
  },
  "NamedParameters<typeof usePath>": {
    "name": "NamedParameters<typeof usePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usepath",
    "description": "",
    "operationName": "next-paths"
  },
  "NamedParameters<typeof getItem>": {
    "name": "NamedParameters<typeof getItem>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getitem",
    "description": "",
    "operationName": "react-with-native-store"
  },
  "NamedParameters<typeof getItemSync>": {
    "name": "NamedParameters<typeof getItemSync>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getitemsync",
    "description": "",
    "operationName": "react-with-native-store"
  },
  "NamedParameters<typeof setItem>": {
    "name": "NamedParameters<typeof setItem>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-setitem",
    "description": "",
    "operationName": "react-with-native-store"
  },
  "NamedParameters<typeof SwipeHomepage>": {
    "name": "NamedParameters<typeof SwipeHomepage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-swipehomepage",
    "description": "",
    "operationName": "swipe-homepage"
  },
  "SwipeItem": {
    "name": "SwipeItem",
    "slug": "TsInterface",
    "id": "swipeitem",
    "description": "",
    "operationName": "swipe-homepage",
    "rawText": "\n\nexport type SwipeItem = {\n  imagePath?: string | null;\n  description?: string;\n  markdown?: string;\n  isMarkdownNoLimit?: boolean;\n\n  markdownSourcePath?: string;\n  title: string;\n  /**\n   * if given,href for the title and description (when clicking on one of those)\n   */\n  href?: string;\n};"
  },
  "NamedParameters<typeof createCodeblockMarkdown>": {
    "name": "NamedParameters<typeof createCodeblockMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-createcodeblockmarkdown",
    "description": "",
    "operationName": "ui-util"
  },
  "CustomUrlStoreConfig": {
    "name": "CustomUrlStoreConfig",
    "slug": "TsInterface",
    "id": "customurlstoreconfig",
    "description": "",
    "operationName": "use-url-store",
    "rawText": "\n\nexport type CustomUrlStoreConfig = {\n  type: \"string\" | \"number\" | \"boolean\";\n  isArray?: boolean;\n  allowUndefined?: boolean;\n};"
  },
  "NamedParameters<typeof useCustomUrlStore>": {
    "name": "NamedParameters<typeof useCustomUrlStore>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usecustomurlstore",
    "description": "",
    "operationName": "use-url-store"
  },
  "NamedParameters<typeof getTailwindModules>": {
    "name": "NamedParameters<typeof getTailwindModules>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettailwindmodules",
    "description": "",
    "operationName": "react-with-native"
  },
  "NamedParameters<typeof joinClassNames>": {
    "name": "NamedParameters<typeof joinClassNames>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-joinclassnames",
    "description": "",
    "operationName": "react-with-native"
  },
  "NamedParameters<typeof Svg>": {
    "name": "NamedParameters<typeof Svg>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-svg",
    "description": "",
    "operationName": "react-with-native"
  },
  "NamedParameters<typeof trimClassName>": {
    "name": "NamedParameters<typeof trimClassName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-trimclassname",
    "description": "",
    "operationName": "react-with-native"
  },
  "NamedParameters<typeof wrapInTextIfNeeded>": {
    "name": "NamedParameters<typeof wrapInTextIfNeeded>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-wrapintextifneeded",
    "description": "",
    "operationName": "react-with-native"
  },
  "SvgType": {
    "name": "SvgType",
    "slug": "TsInterface",
    "id": "svgtype",
    "description": "",
    "operationName": "react-with-native",
    "rawText": "export type SvgType = {\n  src: any;\n  width?: number;\n  height?: number;\n  className?: string;\n  style?: any;\n};"
  },
  "NamedParameters<typeof AlertProvider>": {
    "name": "NamedParameters<typeof AlertProvider>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-alertprovider",
    "description": "",
    "operationName": "react-with-native-alert"
  },
  "NamedParameters<typeof useAlert>": {
    "name": "NamedParameters<typeof useAlert>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usealert",
    "description": "",
    "operationName": "react-with-native-alert"
  },
  "MapLocation": {
    "name": "MapLocation",
    "slug": "TsInterface",
    "id": "maplocation",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": "\n\nexport type MapLocation = {\n  latitude: number;\n  longitude: number;\n  zoom: number;\n};"
  },
  "PluginInputType": {
    "name": "PluginInputType",
    "slug": "TsInterface",
    "id": "plugininputtype",
    "description": "",
    "operationName": "react-with-native-form-inputs"
  },
  "Suggestion": {
    "name": "Suggestion",
    "slug": "TsInterface",
    "id": "suggestion",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": "\n\nexport type Suggestion = {\n  bbox: number[];\n  center: [number, number];\n  id: string;\n  place_name: string;\n  place_type: string[];\n  text: string;\n};"
  },
  "ViewPort": {
    "name": "ViewPort",
    "slug": "TsInterface",
    "id": "viewport",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": "\n\nexport type ViewPort = MapLocation & {\n  width: string | number;\n  height: string | number;\n};"
  },
  "NamedParameters<typeof Modal>": {
    "name": "NamedParameters<typeof Modal>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-modal",
    "description": "",
    "operationName": "react-with-native-modal"
  },
  "NamedParameters<typeof ModalProvider>": {
    "name": "NamedParameters<typeof ModalProvider>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-modalprovider",
    "description": "",
    "operationName": "react-with-native-modal"
  },
  "NamedParameters<typeof useModal>": {
    "name": "NamedParameters<typeof useModal>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usemodal",
    "description": "",
    "operationName": "react-with-native-modal"
  },
  "NamedParameters<typeof useModalState>": {
    "name": "NamedParameters<typeof useModalState>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usemodalstate",
    "description": "",
    "operationName": "react-with-native-modal"
  },
  "NamedParameters<typeof useNavigation>": {
    "name": "NamedParameters<typeof useNavigation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usenavigation",
    "description": "",
    "operationName": "react-with-native-router"
  },
  "NamedParameters<typeof useRouter>": {
    "name": "NamedParameters<typeof useRouter>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-userouter",
    "description": "",
    "operationName": "react-with-native-router"
  },
  "ID": {
    "name": "ID",
    "slug": "TsInterface",
    "id": "id",
    "description": "",
    "operationName": "react-with-native-select",
    "rawText": "\n\nexport type ID = string | number | undefined;"
  },
  "FileTabsStoreType": {
    "name": "FileTabsStoreType",
    "slug": "TsInterface",
    "id": "filetabsstoretype",
    "description": "",
    "operationName": "file-tabs",
    "rawText": "\n\nexport type FileTabsStoreType = {\n  unsavedFiles: {\n    [projectRelativePath: string]: string | undefined;\n  };\n  openPages: OpenPage<string>[];\n};"
  },
  "CodeblockMode": {
    "name": "CodeblockMode",
    "slug": "TsInterface",
    "id": "codeblockmode",
    "description": "",
    "operationName": "markdown",
    "rawText": "\nexport type CodeblockMode = \"preview\" | \"scroll\" | \"full\";"
  },
  "NamedParameters<typeof getRealSrc>": {
    "name": "NamedParameters<typeof getRealSrc>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getrealsrc",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof getUrlFromRelativeUrl>": {
    "name": "NamedParameters<typeof getUrlFromRelativeUrl>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-geturlfromrelativeurl",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof getYoutubeId>": {
    "name": "NamedParameters<typeof getYoutubeId>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getyoutubeid",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof MarkdownCodeblock>": {
    "name": "NamedParameters<typeof MarkdownCodeblock>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdowncodeblock",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof MarkdownContent>": {
    "name": "NamedParameters<typeof MarkdownContent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdowncontent",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof MarkdownContentRender>": {
    "name": "NamedParameters<typeof MarkdownContentRender>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdowncontentrender",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof Parameter>": {
    "name": "NamedParameters<typeof Parameter>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parameter",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof renderFrontmatter>": {
    "name": "NamedParameters<typeof renderFrontmatter>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-renderfrontmatter",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof renderMarkdownChunk>": {
    "name": "NamedParameters<typeof renderMarkdownChunk>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rendermarkdownchunk",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof renderMarkdownContent>": {
    "name": "NamedParameters<typeof renderMarkdownContent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rendermarkdowncontent",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof renderMarkdownParse>": {
    "name": "NamedParameters<typeof renderMarkdownParse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rendermarkdownparse",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof renderMarkdownTitle>": {
    "name": "NamedParameters<typeof renderMarkdownTitle>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rendermarkdowntitle",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof useOpenHashDetails>": {
    "name": "NamedParameters<typeof useOpenHashDetails>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-useopenhashdetails",
    "description": "",
    "operationName": "markdown"
  },
  "ExpandedObject": {
    "name": "ExpandedObject",
    "slug": "TsInterface",
    "id": "expandedobject",
    "description": "",
    "operationName": "nested-menu",
    "rawText": "\n\nexport type ExpandedObject = {\n  [queryPath: string]: boolean;\n};"
  },
  "NamedParameters<typeof useExpanded>": {
    "name": "NamedParameters<typeof useExpanded>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-useexpanded",
    "description": "",
    "operationName": "nested-menu"
  },
  "NamedParameters<typeof getMenuPagesObject>": {
    "name": "NamedParameters<typeof getMenuPagesObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmenupagesobject",
    "description": "",
    "operationName": "recursive-util"
  },
  "NamedParameters<typeof queryPathsArrayToNestedPathObject>": {
    "name": "NamedParameters<typeof queryPathsArrayToNestedPathObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-querypathsarraytonestedpathobject",
    "description": "",
    "operationName": "recursive-util"
  },
  "NamedParameters<typeof reduceQueryPathsRecursively>": {
    "name": "NamedParameters<typeof reduceQueryPathsRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-reducequerypathsrecursively",
    "description": "",
    "operationName": "recursive-util"
  },
  "NestedPathObject": {
    "name": "NestedPathObject",
    "slug": "TsInterface",
    "id": "nestedpathobject",
    "description": "A different way to represent a path array in a nested object of folders\n\n{  \"folderName\": {    \"file1\": null,    \"file2\": null  },  \"folderName2\": {    \"file1\": null,    \"file2\": null  } }",
    "operationName": "recursive-util"
  },
  "NamedParameters<typeof AppsMenu>": {
    "name": "NamedParameters<typeof AppsMenu>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-appsmenu",
    "description": "",
    "operationName": "apps-menu"
  },
  "NamedParameters<typeof AuthenticationMethodsCrud>": {
    "name": "NamedParameters<typeof AuthenticationMethodsCrud>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-authenticationmethodscrud",
    "description": "",
    "operationName": "authentication"
  },
  "NamedParameters<typeof LoginForm>": {
    "name": "NamedParameters<typeof LoginForm>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-loginform",
    "description": "",
    "operationName": "authentication"
  },
  "NamedParameters<typeof LoginWrapper>": {
    "name": "NamedParameters<typeof LoginWrapper>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-loginwrapper",
    "description": "",
    "operationName": "authentication"
  },
  "NamedParameters<typeof MeAuthenticationInfo>": {
    "name": "NamedParameters<typeof MeAuthenticationInfo>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-meauthenticationinfo",
    "description": "",
    "operationName": "authentication"
  },
  "NamedParameters<typeof PersonProfileDetailsForm>": {
    "name": "NamedParameters<typeof PersonProfileDetailsForm>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-personprofiledetailsform",
    "description": "",
    "operationName": "authentication"
  },
  "NamedParameters<typeof PublicPersonComponent>": {
    "name": "NamedParameters<typeof PublicPersonComponent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-publicpersoncomponent",
    "description": "",
    "operationName": "authentication"
  },
  "NamedParameters<typeof PublicProfile>": {
    "name": "NamedParameters<typeof PublicProfile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-publicprofile",
    "description": "",
    "operationName": "authentication"
  },
  "NamedParameters<typeof SignupForm>": {
    "name": "NamedParameters<typeof SignupForm>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-signupform",
    "description": "",
    "operationName": "authentication"
  },
  "NamedParameters<typeof UpdateMeForm>": {
    "name": "NamedParameters<typeof UpdateMeForm>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-updatemeform",
    "description": "",
    "operationName": "authentication"
  },
  "PersonInfo": {
    "name": "PersonInfo",
    "slug": "TsInterface",
    "id": "personinfo",
    "description": "",
    "operationName": "authentication",
    "rawText": "\n\nexport type PersonInfo = Partial<\n  Pick<Device, \"persons\" | \"currentPersonCalculated\" | \"currentPersonId\">\n>;"
  },
  "DbCrudStore": {
    "name": "DbCrudStore",
    "slug": "TsInterface",
    "id": "dbcrudstore",
    "description": "",
    "operationName": "db-crud",
    "rawText": "\n\nexport type DbCrudStore = {\n  \"db-crud.datasetConfig\":\n    | (DatasetConfig & {\n        /**\n         * If you selected a dataset, this will be set, so you can also delete it after selecting it\n         */\n        id?: string;\n        /**\n         * Used to determine if it's a new form or not\n         */\n        key?: string;\n      })\n    | null;\n  \"db-crud.search\": string;\n};"
  },
  "NamedParameters<typeof DatasetForm>": {
    "name": "NamedParameters<typeof DatasetForm>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-datasetform",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof getPropertiesDataParameterNames>": {
    "name": "NamedParameters<typeof getPropertiesDataParameterNames>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpropertiesdataparameternames",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof ModelComponent>": {
    "name": "NamedParameters<typeof ModelComponent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-modelcomponent",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof openWhatsapp>": {
    "name": "NamedParameters<typeof openWhatsapp>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-openwhatsapp",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof shimmer>": {
    "name": "NamedParameters<typeof shimmer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-shimmer",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof SimplifiedSchemaFormDebug>": {
    "name": "NamedParameters<typeof SimplifiedSchemaFormDebug>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-simplifiedschemaformdebug",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof sortToItem>": {
    "name": "NamedParameters<typeof sortToItem>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-sorttoitem",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof toBase64>": {
    "name": "NamedParameters<typeof toBase64>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tobase64",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof UpsertForm>": {
    "name": "NamedParameters<typeof UpsertForm>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-upsertform",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof UpsertPage>": {
    "name": "NamedParameters<typeof UpsertPage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-upsertpage",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof useInfiniteGetDbModel>": {
    "name": "NamedParameters<typeof useInfiniteGetDbModel>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-useinfinitegetdbmodel",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof useModelFromUrl>": {
    "name": "NamedParameters<typeof useModelFromUrl>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usemodelfromurl",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof OpenFileWriterPages>": {
    "name": "NamedParameters<typeof OpenFileWriterPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-openfilewriterpages",
    "description": "",
    "operationName": "file-writer"
  },
  "PagesObjectShape": {
    "name": "PagesObjectShape",
    "slug": "TsInterface",
    "id": "pagesobjectshape",
    "description": "",
    "operationName": "file-writer"
  },
  "NamedParameters<typeof Header>": {
    "name": "NamedParameters<typeof Header>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-header",
    "description": "",
    "operationName": "reader-ui"
  },
  "NamedParameters<typeof PingApi>": {
    "name": "NamedParameters<typeof PingApi>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-pingapi",
    "description": "",
    "operationName": "layout"
  },
  "NamedParameters<typeof AugmentedWordComponent>": {
    "name": "NamedParameters<typeof AugmentedWordComponent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-augmentedwordcomponent",
    "description": "",
    "operationName": "reader-ui"
  },
  "NamedParameters<typeof Dictionary>": {
    "name": "NamedParameters<typeof Dictionary>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-dictionary",
    "description": "",
    "operationName": "reader-ui"
  },
  "NamedParameters<typeof DocsReaderLayout>": {
    "name": "NamedParameters<typeof DocsReaderLayout>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-docsreaderlayout",
    "description": "",
    "operationName": "reader-ui"
  },
  "NamedParameters<typeof Layout>": {
    "name": "NamedParameters<typeof Layout>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-layout",
    "description": "",
    "operationName": "himalayajeep-ui"
  },
  "NamedParameters<typeof ReaderPageContent>": {
    "name": "NamedParameters<typeof ReaderPageContent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readerpagecontent",
    "description": "",
    "operationName": "reader-ui"
  },
  "NamedParameters<typeof ReaderPageHeader>": {
    "name": "NamedParameters<typeof ReaderPageHeader>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readerpageheader",
    "description": "",
    "operationName": "reader-ui"
  },
  "NamedParameters<typeof Share>": {
    "name": "NamedParameters<typeof Share>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-share",
    "description": "",
    "operationName": "share"
  },
  "NamedParameters<typeof useAllText>": {
    "name": "NamedParameters<typeof useAllText>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usealltext",
    "description": "",
    "operationName": "share"
  },
  "NamedParameters<typeof useLastSelection>": {
    "name": "NamedParameters<typeof useLastSelection>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-uselastselection",
    "description": "",
    "operationName": "share"
  },
  "NamedParameters<typeof useProjectRelativeScreenshot>": {
    "name": "NamedParameters<typeof useProjectRelativeScreenshot>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-useprojectrelativescreenshot",
    "description": "",
    "operationName": "share"
  },
  "NamedParameters<typeof getReferencedModelDataItem>": {
    "name": "NamedParameters<typeof getReferencedModelDataItem>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getreferencedmodeldataitem",
    "description": "",
    "operationName": "simplified-schema-form"
  },
  "NamedParameters<typeof useReferencableModelData>": {
    "name": "NamedParameters<typeof useReferencableModelData>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usereferencablemodeldata",
    "description": "",
    "operationName": "simplified-schema-form"
  },
  "ReferencedModelDataItem": {
    "name": "ReferencedModelDataItem",
    "slug": "TsInterface",
    "id": "referencedmodeldataitem",
    "description": "",
    "operationName": "simplified-schema-form",
    "rawText": "\nexport type ReferencedModelDataItem = ReferenceParameterInfo &\n  ReferenceItemsObject;"
  },
  "ReferenceItem": {
    "name": "ReferenceItem",
    "slug": "TsInterface",
    "id": "referenceitem",
    "description": "",
    "operationName": "simplified-schema-form",
    "rawText": "\n\nexport type ReferenceItem = {\n  id: string;\n  slug?: string;\n  name?: string;\n  categoryStack?: CategoryStack;\n};"
  },
  "ReferenceItemsObject": {
    "name": "ReferenceItemsObject",
    "slug": "TsInterface",
    "id": "referenceitemsobject",
    "description": "",
    "operationName": "simplified-schema-form",
    "rawText": "\n\nexport type ReferenceItemsObject = {\n  data?: ReferenceItem[];\n  isLoading?: boolean;\n};"
  },
  "NamedParameters<typeof execAsync>": {
    "name": "NamedParameters<typeof execAsync>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-execasync",
    "description": "",
    "operationName": "child-process-helper"
  },
  "NamedParameters<typeof spawnAsync>": {
    "name": "NamedParameters<typeof spawnAsync>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-spawnasync",
    "description": "",
    "operationName": "child-process-helper"
  },
  "SpawnOptionsWithoutStdio": {
    "name": "SpawnOptionsWithoutStdio",
    "slug": "TsInterface",
    "id": "spawnoptionswithoutstdio",
    "description": "",
    "operationName": "child-process-helper"
  },
  "NamedParameters<typeof cloc>": {
    "name": "NamedParameters<typeof cloc>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-cloc",
    "description": "",
    "operationName": "cloc"
  },
  "Casing": {
    "name": "Casing",
    "slug": "TsInterface",
    "id": "casing",
    "description": "",
    "operationName": "convert-case",
    "rawText": "\nexport type Casing =\n  //camelCase\n  | \"camel\"\n  //PascalCase\n  | \"pascal\"\n  //snake_case\n  | \"snake\"\n  //kebab-case\n  | \"kebab\"\n  //CAPITAL_CASE\n  | \"capital\"\n  //Human case\n  | \"human\";"
  },
  "NamedParameters<typeof camelCase>": {
    "name": "NamedParameters<typeof camelCase>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-camelcase",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof capitalCase>": {
    "name": "NamedParameters<typeof capitalCase>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-capitalcase",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof capitaliseFirstLetter>": {
    "name": "NamedParameters<typeof capitaliseFirstLetter>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-capitalisefirstletter",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof convertCase>": {
    "name": "NamedParameters<typeof convertCase>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-convertcase",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof convertToTargetCasing>": {
    "name": "NamedParameters<typeof convertToTargetCasing>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-converttotargetcasing",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof getDelimiter>": {
    "name": "NamedParameters<typeof getDelimiter>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdelimiter",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof humanCase>": {
    "name": "NamedParameters<typeof humanCase>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-humancase",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof kebabCase>": {
    "name": "NamedParameters<typeof kebabCase>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-kebabcase",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof lowerCaseArray>": {
    "name": "NamedParameters<typeof lowerCaseArray>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-lowercasearray",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof pascalCase>": {
    "name": "NamedParameters<typeof pascalCase>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-pascalcase",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof slugify>": {
    "name": "NamedParameters<typeof slugify>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-slugify",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof snakeCase>": {
    "name": "NamedParameters<typeof snakeCase>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-snakecase",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof splitCasingDelimiters>": {
    "name": "NamedParameters<typeof splitCasingDelimiters>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-splitcasingdelimiters",
    "description": "",
    "operationName": "convert-case"
  },
  "Command": {
    "name": "Command",
    "slug": "TsInterface",
    "id": "command",
    "description": "",
    "operationName": "execute-command",
    "rawText": "\n\nexport type Command = {\n  command?: CommandPerOs | string;\n  description: string;\n  isDisabled?: boolean;\n};"
  },
  "CommandPerOs": {
    "name": "CommandPerOs",
    "slug": "TsInterface",
    "id": "commandperos",
    "description": "",
    "operationName": "execute-command",
    "rawText": "\n\nexport type CommandPerOs = {\n  [key in OSOrDefault]?: string;\n};"
  },
  "NamedParameters<typeof executeCommand>": {
    "name": "NamedParameters<typeof executeCommand>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-executecommand",
    "description": "",
    "operationName": "execute-command"
  },
  "NamedParameters<typeof getCommand>": {
    "name": "NamedParameters<typeof getCommand>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcommand",
    "description": "",
    "operationName": "execute-command"
  },
  "NamedParameters<typeof isCommandPerOs>": {
    "name": "NamedParameters<typeof isCommandPerOs>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-iscommandperos",
    "description": "",
    "operationName": "execute-command"
  },
  "OSOrDefault": {
    "name": "OSOrDefault",
    "slug": "TsInterface",
    "id": "osordefault",
    "description": "",
    "operationName": "execute-command",
    "rawText": "\n\nexport type OSOrDefault = NodeJS.Platform | \"default\";"
  },
  "NamedParameters<typeof getDbPath>": {
    "name": "NamedParameters<typeof getDbPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdbpath",
    "description": "",
    "operationName": "geo-parse"
  },
  "NamedParameters<typeof makeKvmdLocationsFile>": {
    "name": "NamedParameters<typeof makeKvmdLocationsFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-makekvmdlocationsfile",
    "description": "",
    "operationName": "geo-parse"
  },
  "NamedParameters<typeof parse>": {
    "name": "NamedParameters<typeof parse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parse",
    "description": "",
    "operationName": "parse-address-henrik"
  },
  "NamedParameters<typeof parseCountries>": {
    "name": "NamedParameters<typeof parseCountries>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parsecountries",
    "description": "",
    "operationName": "geo-parse"
  },
  "NamedParameters<typeof parseToMarkdown>": {
    "name": "NamedParameters<typeof parseToMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parsetomarkdown",
    "description": "",
    "operationName": "geo-parse"
  },
  "NamedParameters<typeof rawPolygonToPolygon>": {
    "name": "NamedParameters<typeof rawPolygonToPolygon>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rawpolygontopolygon",
    "description": "",
    "operationName": "geo-parse"
  },
  "NamedParameters<typeof concatenate>": {
    "name": "NamedParameters<typeof concatenate>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-concatenate",
    "description": "",
    "operationName": "js-util"
  },
  "NamedParameters<typeof getParameterAtLocation>": {
    "name": "NamedParameters<typeof getParameterAtLocation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getparameteratlocation",
    "description": "",
    "operationName": "js-util"
  },
  "NamedParameters<typeof hasAllLetters>": {
    "name": "NamedParameters<typeof hasAllLetters>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-hasallletters",
    "description": "",
    "operationName": "js-util"
  },
  "NamedParameters<typeof mergeNestedObjectTest>": {
    "name": "NamedParameters<typeof mergeNestedObjectTest>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-mergenestedobjecttest",
    "description": "",
    "operationName": "js-util"
  },
  "NamedParameters<typeof replaceLastOccurence>": {
    "name": "NamedParameters<typeof replaceLastOccurence>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-replacelastoccurence",
    "description": "",
    "operationName": "js-util"
  },
  "NamedParameters<typeof reverseString>": {
    "name": "NamedParameters<typeof reverseString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-reversestring",
    "description": "",
    "operationName": "js-util"
  },
  "NamedParameters<typeof trimSlashes>": {
    "name": "NamedParameters<typeof trimSlashes>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-trimslashes",
    "description": "",
    "operationName": "js-util"
  },
  "O": {
    "name": "O",
    "slug": "TsInterface",
    "id": "o",
    "description": "",
    "operationName": "js-util",
    "rawText": "export type O = { [key: string]: any };"
  },
  "NamedParameters<typeof dev>": {
    "name": "NamedParameters<typeof dev>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-dev",
    "description": "",
    "operationName": "k-dev"
  },
  "NamedParameters<typeof devCli>": {
    "name": "NamedParameters<typeof devCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-devcli",
    "description": "",
    "operationName": "k-dev"
  },
  "GlobalLogConfig": {
    "name": "GlobalLogConfig",
    "slug": "TsInterface",
    "id": "globallogconfig",
    "description": "a logging configuration object that you can set using a file in the root of your operation or project.",
    "operationName": "log",
    "rawText": "\n/**\n * a logging configuration object that you can set using a file in the root of your operation or project.\n */\nexport type GlobalLogConfig = {\n  showDebug?: boolean;\n  showDefault?: boolean;\n  sayTitles?: boolean;\n  /**\n   * Folder where logs can be stored. If i can access the caller location this can be the operation db.\n   */\n  logFolder?: string;\n};"
  },
  "LogConfig": {
    "name": "LogConfig",
    "slug": "TsInterface",
    "id": "logconfig",
    "description": "",
    "operationName": "log",
    "rawText": "\n\nexport type LogConfig = {\n  /**\n   * The title of this log. If not given, a title will still be parsed from your message by taking the first sentence.\n   */\n  title?: string;\n  /**\n   * how it should look and feel for the user\n   */\n  type?: LogType;\n  /**\n   * Overwrite the global log config\n   */\n  customConfig?: GlobalLogConfig;\n};"
  },
  "LogType": {
    "name": "LogType",
    "slug": "TsInterface",
    "id": "logtype",
    "description": "how should it look and feel?",
    "operationName": "log",
    "rawText": "\n\n/**\nhow should it look and feel?\n */\nexport type LogType =\n  | \"debug\"\n  | \"error\"\n  | \"warning\"\n  | \"success\"\n  | \"important\"\n  | \"default\";"
  },
  "NamedParameters<typeof getCallerFileName>": {
    "name": "NamedParameters<typeof getCallerFileName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcallerfilename",
    "description": "",
    "operationName": "log"
  },
  "NamedParameters<typeof log>": {
    "name": "NamedParameters<typeof log>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-log",
    "description": "",
    "operationName": "log"
  },
  "NamedParameters<typeof parseTitle>": {
    "name": "NamedParameters<typeof parseTitle>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parsetitle",
    "description": "",
    "operationName": "log"
  },
  "OperationLogConfig": {
    "name": "OperationLogConfig",
    "slug": "TsInterface",
    "id": "operationlogconfig",
    "description": "",
    "operationName": "log",
    "rawText": "\n\nexport type OperationLogConfig = {\n  config: GlobalLogConfig;\n  fileConfig?: { [srcRelativeFilePath: string]: GlobalLogConfig };\n  functionConfig?: { [functionName: string]: GlobalLogConfig };\n};"
  },
  "ProjectLogConfig": {
    "name": "ProjectLogConfig",
    "slug": "TsInterface",
    "id": "projectlogconfig",
    "description": "",
    "operationName": "log",
    "rawText": "\n\nexport type ProjectLogConfig = {\n  config: GlobalLogConfig;\n  operationConfig: {\n    [key: string]: OperationLogConfig;\n  };\n};"
  },
  "NamedParameters<typeof cleanupTimer>": {
    "name": "NamedParameters<typeof cleanupTimer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-cleanuptimer",
    "description": "",
    "operationName": "measure-performance"
  },
  "NamedParameters<typeof generateUniqueId>": {
    "name": "NamedParameters<typeof generateUniqueId>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateuniqueid",
    "description": "",
    "operationName": "measure-performance"
  },
  "NamedParameters<typeof getNewPerformance>": {
    "name": "NamedParameters<typeof getNewPerformance>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getnewperformance",
    "description": "",
    "operationName": "measure-performance"
  },
  "NamedParameters<typeof nodemon>": {
    "name": "NamedParameters<typeof nodemon>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-nodemon",
    "description": "",
    "operationName": "nodemon"
  },
  "NamedParameters<typeof isPlural>": {
    "name": "NamedParameters<typeof isPlural>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isplural",
    "description": "",
    "operationName": "pluralize"
  },
  "NamedParameters<typeof isSingular>": {
    "name": "NamedParameters<typeof isSingular>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-issingular",
    "description": "",
    "operationName": "pluralize"
  },
  "NamedParameters<typeof pluralize>": {
    "name": "NamedParameters<typeof pluralize>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-pluralize",
    "description": "",
    "operationName": "pluralize"
  },
  "NamedParameters<typeof singularize>": {
    "name": "NamedParameters<typeof singularize>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-singularize",
    "description": "",
    "operationName": "pluralize"
  },
  "NamedParameters<typeof runChildProcess>": {
    "name": "NamedParameters<typeof runChildProcess>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-runchildprocess",
    "description": "",
    "operationName": "run-child-process"
  },
  "BrowserPage": {
    "name": "BrowserPage",
    "slug": "TsInterface",
    "id": "browserpage",
    "description": "",
    "operationName": "browser-types",
    "rawText": "\n\nexport interface BrowserPage extends DefaultModelType {\n  // Store actual page or tabId of browser tab\n  pageId: string;\n  // Store the status of the tab either its active or idle\n  isIdle: boolean;\n}"
  },
  "BrowserSession": {
    "name": "BrowserSession",
    "slug": "TsInterface",
    "id": "browsersession",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "LoginResponse": {
    "name": "LoginResponse",
    "slug": "TsInterface",
    "id": "loginresponse",
    "description": "",
    "operationName": "chatgpt-controller",
    "rawText": "\n\nexport type LoginResponse = {\n  isSuccessfull: boolean;\n  message?: string;\n};"
  },
  "NamedParameters<typeof chatGPTAuth>": {
    "name": "NamedParameters<typeof chatGPTAuth>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-chatgptauth",
    "description": "",
    "operationName": "chatgpt-controller"
  },
  "NamedParameters<typeof detectChatGptPage>": {
    "name": "NamedParameters<typeof detectChatGptPage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-detectchatgptpage",
    "description": "",
    "operationName": "chatgpt-controller"
  },
  "NamedParameters<typeof openAIChat>": {
    "name": "NamedParameters<typeof openAIChat>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-openaichat",
    "description": "",
    "operationName": "chatgpt-controller"
  },
  "OpenAIChatProps": {
    "name": "OpenAIChatProps",
    "slug": "TsInterface",
    "id": "openaichatprops",
    "description": "",
    "operationName": "chatgpt-controller",
    "rawText": "\n\nexport type OpenAIChatProps = {\n  prompt: string;\n  thread?: string;\n  isHeadless?: boolean;\n};"
  },
  "OpenAIChatResponseType": {
    "name": "OpenAIChatResponseType",
    "slug": "TsInterface",
    "id": "openaichatresponsetype",
    "description": "",
    "operationName": "chatgpt-controller",
    "rawText": "\n\nexport type OpenAIChatResponseType = {\n  result?: string;\n  thread?: string;\n  isSuccess: boolean;\n};"
  },
  "Browser": {
    "name": "Browser",
    "slug": "TsInterface",
    "id": "browser",
    "description": "A Browser is created when Puppeteer connects to a Chromium instance, either through\n{@link  PuppeteerNode.launch }  or  {@link  Puppeteer.connect } .",
    "operationName": "puppeteer-utils"
  },
  "FacebookLoginPropsType": {
    "name": "FacebookLoginPropsType",
    "slug": "TsInterface",
    "id": "facebookloginpropstype",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": "\n\nexport type FacebookLoginPropsType = {\n  email: string;\n  password: string;\n  page: Page;\n};"
  },
  "GmailLoginPropsType": {
    "name": "GmailLoginPropsType",
    "slug": "TsInterface",
    "id": "gmailloginpropstype",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": "\n\nexport type GmailLoginPropsType = {\n  email: string;\n  password: string;\n  page: Page;\n};"
  },
  "NamedParameters<typeof getChromeExecutablePath>": {
    "name": "NamedParameters<typeof getChromeExecutablePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getchromeexecutablepath",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof clickOnSpanTag>": {
    "name": "NamedParameters<typeof clickOnSpanTag>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-clickonspantag",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof delay>": {
    "name": "NamedParameters<typeof delay>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-delay",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof facebookLogin>": {
    "name": "NamedParameters<typeof facebookLogin>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-facebooklogin",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof foundOrNot>": {
    "name": "NamedParameters<typeof foundOrNot>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-foundornot",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof foundOrNotXpath>": {
    "name": "NamedParameters<typeof foundOrNotXpath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-foundornotxpath",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof getBrowserPageById>": {
    "name": "NamedParameters<typeof getBrowserPageById>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getbrowserpagebyid",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof getBrowserTabs>": {
    "name": "NamedParameters<typeof getBrowserTabs>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getbrowsertabs",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof getConnectedBrowsers>": {
    "name": "NamedParameters<typeof getConnectedBrowsers>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getconnectedbrowsers",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof getIdlePage>": {
    "name": "NamedParameters<typeof getIdlePage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getidlepage",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof getNewPage>": {
    "name": "NamedParameters<typeof getNewPage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getnewpage",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof gmailLogin>": {
    "name": "NamedParameters<typeof gmailLogin>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gmaillogin",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof isCaptchaExist>": {
    "name": "NamedParameters<typeof isCaptchaExist>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-iscaptchaexist",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof logConsoleIfDebug>": {
    "name": "NamedParameters<typeof logConsoleIfDebug>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-logconsoleifdebug",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof openMultiTabs>": {
    "name": "NamedParameters<typeof openMultiTabs>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-openmultitabs",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof openNewBrowser>": {
    "name": "NamedParameters<typeof openNewBrowser>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-opennewbrowser",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof openNewBrowserOnChildProcess>": {
    "name": "NamedParameters<typeof openNewBrowserOnChildProcess>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-opennewbrowseronchildprocess",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof openPage>": {
    "name": "NamedParameters<typeof openPage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-openpage",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof racePromises>": {
    "name": "NamedParameters<typeof racePromises>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-racepromises",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof retryClickAndWaitSelector>": {
    "name": "NamedParameters<typeof retryClickAndWaitSelector>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-retryclickandwaitselector",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof retryWaitSelector>": {
    "name": "NamedParameters<typeof retryWaitSelector>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-retrywaitselector",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof runBrowser>": {
    "name": "NamedParameters<typeof runBrowser>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-runbrowser",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof setBrowserPageIdle>": {
    "name": "NamedParameters<typeof setBrowserPageIdle>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-setbrowserpageidle",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof setInnerHtml>": {
    "name": "NamedParameters<typeof setInnerHtml>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-setinnerhtml",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof solveReptcha>": {
    "name": "NamedParameters<typeof solveReptcha>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-solvereptcha",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof trueClick>": {
    "name": "NamedParameters<typeof trueClick>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-trueclick",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof twitterLogin>": {
    "name": "NamedParameters<typeof twitterLogin>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-twitterlogin",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof typeInTheInputField>": {
    "name": "NamedParameters<typeof typeInTheInputField>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-typeintheinputfield",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof typeOnTheTargetWithXpathSelector>": {
    "name": "NamedParameters<typeof typeOnTheTargetWithXpathSelector>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-typeonthetargetwithxpathselector",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NewPageProps": {
    "name": "NewPageProps",
    "slug": "TsInterface",
    "id": "newpageprops",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": "\n\nexport type NewPageProps = {\n  pageId?: string;\n};"
  },
  "OpenMultiTabProps": {
    "name": "OpenMultiTabProps",
    "slug": "TsInterface",
    "id": "openmultitabprops",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": "\n\nexport type OpenMultiTabProps = {\n  noOfTabs: number;\n  tabUrl: string;\n  browser: Browser;\n};"
  },
  "ChannelType": {
    "name": "ChannelType",
    "slug": "TsInterface",
    "id": "channeltype",
    "description": "",
    "operationName": "slack-controller",
    "rawText": "\n\nexport type ChannelType = {\n  platform: Platform;\n  name: string;\n  createdAt?: number;\n  updatedAt?: number;\n  latestMessageAt?: number;\n  url?: string;\n};"
  },
  "GetSlackChannelMemberParamsType": {
    "name": "GetSlackChannelMemberParamsType",
    "slug": "TsInterface",
    "id": "getslackchannelmemberparamstype",
    "description": "",
    "operationName": "slack-controller",
    "rawText": "\n\nexport type GetSlackChannelMemberParamsType = {\n  workspace: string;\n  channelName: string;\n  email: string;\n  password: string;\n};"
  },
  "GetSlackWorkSpaceParamsTypes": {
    "name": "GetSlackWorkSpaceParamsTypes",
    "slug": "TsInterface",
    "id": "getslackworkspaceparamstypes",
    "description": "Gets all of your slack workspaces.",
    "operationName": "slack-controller",
    "rawText": "\n\n/**\n * Gets all of your slack workspaces.\n */\n\nexport type GetSlackWorkSpaceParamsTypes = {\n  email: string;\n  password: string;\n};"
  },
  "MessageType": {
    "name": "MessageType",
    "slug": "TsInterface",
    "id": "messagetype",
    "description": "",
    "operationName": "slack-controller",
    "rawText": "\n\nexport type MessageType = {\n  sender?: string;\n  messages: string[];\n  // time and channels -> from monorepo //same format for response for messages : talk to bhagya and Guil\n};"
  },
  "NamedParameters<typeof elementExists>": {
    "name": "NamedParameters<typeof elementExists>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-elementexists",
    "description": "",
    "operationName": "slack-controller"
  },
  "NamedParameters<typeof getAllMessages>": {
    "name": "NamedParameters<typeof getAllMessages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getallmessages",
    "description": "",
    "operationName": "slack-controller"
  },
  "NamedParameters<typeof getLatestMessages>": {
    "name": "NamedParameters<typeof getLatestMessages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getlatestmessages",
    "description": "",
    "operationName": "slack-controller"
  },
  "NamedParameters<typeof getSlackChannelMemberList>": {
    "name": "NamedParameters<typeof getSlackChannelMemberList>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getslackchannelmemberlist",
    "description": "",
    "operationName": "slack-controller"
  },
  "NamedParameters<typeof getSlackChannels>": {
    "name": "NamedParameters<typeof getSlackChannels>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getslackchannels",
    "description": "",
    "operationName": "slack-controller"
  },
  "NamedParameters<typeof getSlackMessageFrom>": {
    "name": "NamedParameters<typeof getSlackMessageFrom>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getslackmessagefrom",
    "description": "",
    "operationName": "slack-controller"
  },
  "NamedParameters<typeof getSlackWorkspaces>": {
    "name": "NamedParameters<typeof getSlackWorkspaces>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getslackworkspaces",
    "description": "",
    "operationName": "slack-controller"
  },
  "NamedParameters<typeof scrapeSlackMessage>": {
    "name": "NamedParameters<typeof scrapeSlackMessage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-scrapeslackmessage",
    "description": "",
    "operationName": "slack-controller"
  },
  "NamedParameters<typeof scrollToTop>": {
    "name": "NamedParameters<typeof scrollToTop>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-scrolltotop",
    "description": "",
    "operationName": "slack-controller"
  },
  "NamedParameters<typeof selectSlackChannel>": {
    "name": "NamedParameters<typeof selectSlackChannel>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-selectslackchannel",
    "description": "",
    "operationName": "slack-controller"
  },
  "NamedParameters<typeof selectSlackWorkspace>": {
    "name": "NamedParameters<typeof selectSlackWorkspace>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-selectslackworkspace",
    "description": "",
    "operationName": "slack-controller"
  },
  "NamedParameters<typeof sendSlackMessage>": {
    "name": "NamedParameters<typeof sendSlackMessage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-sendslackmessage",
    "description": "",
    "operationName": "slack-controller"
  },
  "NamedParameters<typeof slackLogin>": {
    "name": "NamedParameters<typeof slackLogin>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-slacklogin",
    "description": "",
    "operationName": "slack-controller"
  },
  "NamedParameters<typeof storeAllSlackChannel>": {
    "name": "NamedParameters<typeof storeAllSlackChannel>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-storeallslackchannel",
    "description": "",
    "operationName": "slack-controller"
  },
  "NamedParameters<typeof storeSlackChannelMember>": {
    "name": "NamedParameters<typeof storeSlackChannelMember>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-storeslackchannelmember",
    "description": "",
    "operationName": "slack-controller"
  },
  "SlackLoginArguments": {
    "name": "SlackLoginArguments",
    "slug": "TsInterface",
    "id": "slackloginarguments",
    "description": "",
    "operationName": "slack-controller",
    "rawText": "\n\nexport type SlackLoginArguments = {\n  mode: \"gmail\" | \"email\";\n  credentials: {\n    email: string;\n    password?: string;\n  };\n};"
  },
  "slackSendMessagePropTypes": {
    "name": "slackSendMessagePropTypes",
    "slug": "TsInterface",
    "id": "slacksendmessageproptypes",
    "description": "",
    "operationName": "slack-controller",
    "rawText": "\n\nexport interface slackSendMessagePropTypes {\n  workspace: string;\n  channel: string;\n  message: string;\n  email: string;\n  password: string;\n}"
  },
  "StoreChannelReturnType": {
    "name": "StoreChannelReturnType",
    "slug": "TsInterface",
    "id": "storechannelreturntype",
    "description": "",
    "operationName": "slack-controller",
    "rawText": "\n\nexport type StoreChannelReturnType = {\n  success: boolean;\n  message: string;\n};"
  },
  "NamedParameters<typeof getAbsolutePathMdFileName>": {
    "name": "NamedParameters<typeof getAbsolutePathMdFileName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getabsolutepathmdfilename",
    "description": "",
    "operationName": "social-media-node"
  },
  "NamedParameters<typeof getAllPostables>": {
    "name": "NamedParameters<typeof getAllPostables>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getallpostables",
    "description": "",
    "operationName": "social-media-node"
  },
  "NamedParameters<typeof getPersonDetails>": {
    "name": "NamedParameters<typeof getPersonDetails>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpersondetails",
    "description": "",
    "operationName": "social-media-node"
  },
  "NamedParameters<typeof getPersonsMenu>": {
    "name": "NamedParameters<typeof getPersonsMenu>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpersonsmenu",
    "description": "",
    "operationName": "social-media-node"
  },
  "NamedParameters<typeof getSocialMediaChannelsMenu>": {
    "name": "NamedParameters<typeof getSocialMediaChannelsMenu>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsocialmediachannelsmenu",
    "description": "",
    "operationName": "social-media-node"
  },
  "NamedParameters<typeof getSocialMediaMenu>": {
    "name": "NamedParameters<typeof getSocialMediaMenu>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsocialmediamenu",
    "description": "",
    "operationName": "social-media-node"
  },
  "NamedParameters<typeof getSubExtensions>": {
    "name": "NamedParameters<typeof getSubExtensions>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsubextensions",
    "description": "",
    "operationName": "social-media-node"
  },
  "NamedParameters<typeof Chat>": {
    "name": "NamedParameters<typeof Chat>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-chat",
    "description": "",
    "operationName": "social-media-web"
  },
  "NamedParameters<typeof FileWriterPage>": {
    "name": "NamedParameters<typeof FileWriterPage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-filewriterpage",
    "description": "",
    "operationName": "social-media-web"
  },
  "NamedParameters<typeof Person>": {
    "name": "NamedParameters<typeof Person>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-person",
    "description": "",
    "operationName": "social-media-web"
  },
  "NamedParameters<typeof PersonSetting>": {
    "name": "NamedParameters<typeof PersonSetting>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-personsetting",
    "description": "",
    "operationName": "social-media-web"
  },
  "NamedParameters<typeof Test>": {
    "name": "NamedParameters<typeof Test>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-test",
    "description": "",
    "operationName": "social-media-web"
  },
  "CredentialType": {
    "name": "CredentialType",
    "slug": "TsInterface",
    "id": "credentialtype",
    "description": "",
    "operationName": "social-media-wrapper",
    "rawText": "\n\nexport interface CredentialType {\n  email?: string;\n  password: string;\n  username?: string;\n  phoneNumber?: string;\n}"
  },
  "NamedParameters<typeof addSocialMediaCredential>": {
    "name": "NamedParameters<typeof addSocialMediaCredential>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-addsocialmediacredential",
    "description": "",
    "operationName": "social-media-wrapper"
  },
  "NamedParameters<typeof canBePosted>": {
    "name": "NamedParameters<typeof canBePosted>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-canbeposted",
    "description": "",
    "operationName": "social-media-wrapper"
  },
  "NamedParameters<typeof createAllSocialMediaPost>": {
    "name": "NamedParameters<typeof createAllSocialMediaPost>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-createallsocialmediapost",
    "description": "",
    "operationName": "social-media-wrapper"
  },
  "NamedParameters<typeof createSocialMediaPost>": {
    "name": "NamedParameters<typeof createSocialMediaPost>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-createsocialmediapost",
    "description": "",
    "operationName": "social-media-wrapper"
  },
  "NamedParameters<typeof devtoCotentAnalyzer>": {
    "name": "NamedParameters<typeof devtoCotentAnalyzer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-devtocotentanalyzer",
    "description": "",
    "operationName": "social-media-wrapper"
  },
  "NamedParameters<typeof facebookContentAnalyzer>": {
    "name": "NamedParameters<typeof facebookContentAnalyzer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-facebookcontentanalyzer",
    "description": "",
    "operationName": "social-media-wrapper"
  },
  "NamedParameters<typeof getBrowser>": {
    "name": "NamedParameters<typeof getBrowser>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getbrowser",
    "description": "",
    "operationName": "social-media-wrapper"
  },
  "NamedParameters<typeof getSocialMediaCredentials>": {
    "name": "NamedParameters<typeof getSocialMediaCredentials>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsocialmediacredentials",
    "description": "",
    "operationName": "social-media-wrapper"
  },
  "NamedParameters<typeof mediumCotentAnalyzer>": {
    "name": "NamedParameters<typeof mediumCotentAnalyzer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-mediumcotentanalyzer",
    "description": "",
    "operationName": "social-media-wrapper"
  },
  "NamedParameters<typeof postSocialMediaPostToDevto>": {
    "name": "NamedParameters<typeof postSocialMediaPostToDevto>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-postsocialmediaposttodevto",
    "description": "",
    "operationName": "social-media-wrapper"
  },
  "NamedParameters<typeof postSocialMediaPostToFacebook>": {
    "name": "NamedParameters<typeof postSocialMediaPostToFacebook>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-postsocialmediaposttofacebook",
    "description": "",
    "operationName": "social-media-wrapper"
  },
  "NamedParameters<typeof postSocialMediaPostToMedium>": {
    "name": "NamedParameters<typeof postSocialMediaPostToMedium>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-postsocialmediaposttomedium",
    "description": "",
    "operationName": "social-media-wrapper"
  },
  "NamedParameters<typeof postSocialMediaPostToReddit>": {
    "name": "NamedParameters<typeof postSocialMediaPostToReddit>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-postsocialmediaposttoreddit",
    "description": "",
    "operationName": "social-media-wrapper"
  },
  "NamedParameters<typeof postSocialMediaPostToTwitter>": {
    "name": "NamedParameters<typeof postSocialMediaPostToTwitter>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-postsocialmediaposttotwitter",
    "description": "",
    "operationName": "social-media-wrapper"
  },
  "NamedParameters<typeof redditContentAnalyzer>": {
    "name": "NamedParameters<typeof redditContentAnalyzer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-redditcontentanalyzer",
    "description": "",
    "operationName": "social-media-wrapper"
  },
  "NamedParameters<typeof socialMediaPostPlanner>": {
    "name": "NamedParameters<typeof socialMediaPostPlanner>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-socialmediapostplanner",
    "description": "",
    "operationName": "social-media-wrapper"
  },
  "NamedParameters<typeof startSocialMediaController>": {
    "name": "NamedParameters<typeof startSocialMediaController>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-startsocialmediacontroller",
    "description": "",
    "operationName": "social-media-wrapper"
  },
  "NamedParameters<typeof twitterContentAnalyzer>": {
    "name": "NamedParameters<typeof twitterContentAnalyzer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-twittercontentanalyzer",
    "description": "",
    "operationName": "social-media-wrapper"
  },
  "NamedParameters<typeof updateSocialMediaPost>": {
    "name": "NamedParameters<typeof updateSocialMediaPost>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-updatesocialmediapost",
    "description": "",
    "operationName": "social-media-wrapper"
  },
  "SocialMediaCrentialType": {
    "name": "SocialMediaCrentialType",
    "slug": "TsInterface",
    "id": "socialmediacrentialtype",
    "description": "",
    "operationName": "social-media-wrapper",
    "rawText": "\n\nexport interface SocialMediaCrentialType extends CredentialType {\n  mediaType: MediaPlatformEnum;\n}"
  },
  "NamedParameters<typeof alterArrayTest>": {
    "name": "NamedParameters<typeof alterArrayTest>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-alterarraytest",
    "description": "",
    "operationName": "course-basics"
  },
  "NamedParameters<typeof alterObjectTest>": {
    "name": "NamedParameters<typeof alterObjectTest>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-alterobjecttest",
    "description": "",
    "operationName": "course-basics"
  },
  "NamedParameters<typeof divideNumber>": {
    "name": "NamedParameters<typeof divideNumber>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-dividenumber",
    "description": "",
    "operationName": "course-basics"
  },
  "NamedParameters<typeof divideNumbers>": {
    "name": "NamedParameters<typeof divideNumbers>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-dividenumbers",
    "description": "",
    "operationName": "course-basics"
  },
  "NamedParameters<typeof doubleNumber>": {
    "name": "NamedParameters<typeof doubleNumber>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-doublenumber",
    "description": "",
    "operationName": "course-basics"
  },
  "NamedParameters<typeof doubleNumbers>": {
    "name": "NamedParameters<typeof doubleNumbers>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-doublenumbers",
    "description": "",
    "operationName": "course-basics"
  },
  "NamedParameters<typeof getHighNumbers>": {
    "name": "NamedParameters<typeof getHighNumbers>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gethighnumbers",
    "description": "",
    "operationName": "course-basics"
  },
  "NamedParameters<typeof makeExercises>": {
    "name": "NamedParameters<typeof makeExercises>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-makeexercises",
    "description": "",
    "operationName": "course-basics"
  },
  "NamedParameters<typeof sumNumbers>": {
    "name": "NamedParameters<typeof sumNumbers>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-sumnumbers",
    "description": "",
    "operationName": "course-basics"
  },
  "NamedParameters<typeof writeExercises>": {
    "name": "NamedParameters<typeof writeExercises>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-writeexercises",
    "description": "",
    "operationName": "course-basics"
  },
  "NamedParameters<typeof driverLogin>": {
    "name": "NamedParameters<typeof driverLogin>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-driverlogin",
    "description": "",
    "operationName": "himalayajeep-functions"
  },
  "NamedParameters<typeof driverSignup>": {
    "name": "NamedParameters<typeof driverSignup>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-driversignup",
    "description": "",
    "operationName": "himalayajeep-functions"
  },
  "NamedParameters<typeof earthDistance>": {
    "name": "NamedParameters<typeof earthDistance>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-earthdistance",
    "description": "",
    "operationName": "himalayajeep-functions"
  },
  "NamedParameters<typeof getMyJeep>": {
    "name": "NamedParameters<typeof getMyJeep>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmyjeep",
    "description": "",
    "operationName": "himalayajeep-functions"
  },
  "NamedParameters<typeof getPublicJeeps>": {
    "name": "NamedParameters<typeof getPublicJeeps>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpublicjeeps",
    "description": "",
    "operationName": "himalayajeep-functions"
  },
  "NamedParameters<typeof updateMyProfile>": {
    "name": "NamedParameters<typeof updateMyProfile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-updatemyprofile",
    "description": "",
    "operationName": "himalayajeep-functions"
  },
  "SignupJeepType": {
    "name": "SignupJeepType",
    "slug": "TsInterface",
    "id": "signupjeeptype",
    "description": "Jeep driver signup FORM (not part of the model)",
    "operationName": "himalayajeep-types",
    "rawText": "\n\n/**\n * Jeep driver signup FORM (not part of the model)\n */\nexport interface SignupJeepType {\n  name: string;\n  email?: string;\n  /**\n   * mobile phone number\n   */\n  phone?: string;\n  password: string;\n  repeatPassword: string;\n  test: string;\n}"
  },
  "JeepType": {
    "name": "JeepType",
    "slug": "TsInterface",
    "id": "jeeptype",
    "description": "Everyting about the jeep, in the model...",
    "operationName": "himalayajeep-types",
    "rawText": "\n\n/**\n * Everyting about the jeep, in the model...\n */\nexport interface JeepType extends MyJeepType, PublicJeepType, DefaultModelType {\n  loginToken: string;\n  encrypedPassword: string;\n}"
  },
  "LocationType": {
    "name": "LocationType",
    "slug": "TsInterface",
    "id": "locationtype",
    "description": "Jeep location",
    "operationName": "himalayajeep-types",
    "rawText": "\n/**\n * Jeep location\n */\nexport interface LocationType extends DefaultModelType {\n  jeepId: string;\n\n  latitude: number;\n  longitude: number;\n  /**\n   * calculate the most nearby village based on the hardcoded village location data we have for all villages in nepal.\n   *\n   */\n  nearbyVillage: string;\n}"
  },
  "MyJeepAdminTypes": {
    "name": "MyJeepAdminTypes",
    "slug": "TsInterface",
    "id": "myjeepadmintypes",
    "description": "",
    "operationName": "himalayajeep-types",
    "rawText": "\n\nexport type MyJeepAdminTypes = {\n  /**\n   * inputted by admin\n   */\n  numberPlate?: string;\n\n  /**\n   * inputted by admin\n   * \n   (verify that the jeep is real)\n   */\n  licenseNumber?: string;\n  /**\n   * inputted by admin\n   */\n  citizenshipNumber?: string;\n  /**\n   * inputted by admin\n   */\n  isVerified: boolean;\n};"
  },
  "MyJeepType": {
    "name": "MyJeepType",
    "slug": "TsInterface",
    "id": "myjeeptype",
    "description": "Driver login jeep info\n\nwill be returned when you request your own information (when logged in)",
    "operationName": "himalayajeep-types",
    "rawText": "\n\n/**\n * Driver login jeep info\n *\n * will be returned when you request your own information (when logged in)\n */\nexport interface MyJeepType extends PublicJeepType, MyJeepAdminTypes {\n  citizenshipImage?: BackendAsset;\n  driverLicenseImage?: BackendAsset;\n}"
  },
  "PublicJeepType": {
    "name": "PublicJeepType",
    "slug": "TsInterface",
    "id": "publicjeeptype",
    "description": "Passenger public jeep overview",
    "operationName": "himalayajeep-ui"
  },
  "NamedParameters<typeof EditProfile>": {
    "name": "NamedParameters<typeof EditProfile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-editprofile",
    "description": "",
    "operationName": "himalayajeep-ui"
  },
  "NamedParameters<typeof JeepList>": {
    "name": "NamedParameters<typeof JeepList>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-jeeplist",
    "description": "",
    "operationName": "himalayajeep-ui"
  },
  "NamedParameters<typeof JeepLogin>": {
    "name": "NamedParameters<typeof JeepLogin>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-jeeplogin",
    "description": "",
    "operationName": "himalayajeep-ui"
  },
  "NamedParameters<typeof JeepView>": {
    "name": "NamedParameters<typeof JeepView>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-jeepview",
    "description": "",
    "operationName": "himalayajeep-ui"
  },
  "NamedParameters<typeof PublicJeep>": {
    "name": "NamedParameters<typeof PublicJeep>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-publicjeep",
    "description": "",
    "operationName": "himalayajeep-ui"
  },
  "NamedParameters<typeof getAllOperations>": {
    "name": "NamedParameters<typeof getAllOperations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getalloperations",
    "description": "",
    "operationName": "github-operation-sync"
  },
  "NamedParameters<typeof getAllPackagesNames>": {
    "name": "NamedParameters<typeof getAllPackagesNames>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getallpackagesnames",
    "description": "",
    "operationName": "github-operation-sync"
  },
  "NamedParameters<typeof getGithubPersonalAccessToken>": {
    "name": "NamedParameters<typeof getGithubPersonalAccessToken>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getgithubpersonalaccesstoken",
    "description": "",
    "operationName": "github-operation-sync"
  },
  "NamedParameters<typeof getGithubRepoLastCommitInfo>": {
    "name": "NamedParameters<typeof getGithubRepoLastCommitInfo>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getgithubrepolastcommitinfo",
    "description": "",
    "operationName": "github-operation-sync"
  },
  "NamedParameters<typeof getRepoNameFromRepositoryUrl>": {
    "name": "NamedParameters<typeof getRepoNameFromRepositoryUrl>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getreponamefromrepositoryurl",
    "description": "",
    "operationName": "github-operation-sync"
  },
  "NamedParameters<typeof initializeGitOrUseExistingAndPull>": {
    "name": "NamedParameters<typeof initializeGitOrUseExistingAndPull>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-initializegitoruseexistingandpull",
    "description": "",
    "operationName": "github-operation-sync"
  },
  "NamedParameters<typeof initializeGitOrUseExistingAndPush>": {
    "name": "NamedParameters<typeof initializeGitOrUseExistingAndPush>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-initializegitoruseexistingandpush",
    "description": "",
    "operationName": "github-operation-sync"
  },
  "NamedParameters<typeof operationGithubPull>": {
    "name": "NamedParameters<typeof operationGithubPull>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-operationgithubpull",
    "description": "",
    "operationName": "github-operation-sync"
  },
  "NamedParameters<typeof operationGithubPush>": {
    "name": "NamedParameters<typeof operationGithubPush>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-operationgithubpush",
    "description": "",
    "operationName": "github-operation-sync"
  },
  "NamedParameters<typeof pullMultipleOperations>": {
    "name": "NamedParameters<typeof pullMultipleOperations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-pullmultipleoperations",
    "description": "",
    "operationName": "github-operation-sync"
  },
  "NamedParameters<typeof pushMultipleOperations>": {
    "name": "NamedParameters<typeof pushMultipleOperations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-pushmultipleoperations",
    "description": "",
    "operationName": "github-operation-sync"
  },
  "NamedParameters<typeof readAndWriteToPackageJsonExample>": {
    "name": "NamedParameters<typeof readAndWriteToPackageJsonExample>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readandwritetopackagejsonexample",
    "description": "",
    "operationName": "github-operation-sync"
  },
  "NamedParameters<typeof updateAllOperationStatus>": {
    "name": "NamedParameters<typeof updateAllOperationStatus>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-updatealloperationstatus",
    "description": "",
    "operationName": "github-operation-sync"
  },
  "NamedParameters<typeof updateAllOperationStatusTest>": {
    "name": "NamedParameters<typeof updateAllOperationStatusTest>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-updatealloperationstatustest",
    "description": "",
    "operationName": "github-operation-sync"
  },
  "PushOperationResult": {
    "name": "PushOperationResult",
    "slug": "TsInterface",
    "id": "pushoperationresult",
    "description": "",
    "operationName": "github-operation-sync",
    "rawText": "\n\nexport declare type PushOperationResult = {\n  success: boolean;\n  message: string;\n  data: {\n    operationName: string;\n    createdRepoUrl?: string;\n  };\n};"
  },
  "GeneralOperationIndex": {
    "name": "GeneralOperationIndex",
    "slug": "TsInterface",
    "id": "generaloperationindex",
    "description": "",
    "operationName": "migrate-operation-model",
    "rawText": "\n\nexport type GeneralOperationIndex = {\n  updatedAt: number;\n  name: string;\n  slug: string;\n  /**\n   * name of the package in package.json\n   */\n  packageName: string;\n  /**\n   * name of the operation folder\n   */\n  folderName: string;\n  /**\n   * relative path to the operation (does not include operation folder itself)\n   *\n   * relative from project root\n   */\n  relativeOperationLocationPath: string;\n\n  classification: OperationClassification;\n\n  /**\n   * package dependency names (non-operation)\n   */\n  packageDependencies: string[];\n  /**\n   * operation dependency names\n   */\n  operationDependencies: string[];\n  /**\n   * core dependencies (e.g. `path` and `fs`)\n   */\n  coreDependencies: string[];\n};"
  },
  "NamedParameters<typeof migratePackageJsonToOperation>": {
    "name": "NamedParameters<typeof migratePackageJsonToOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-migratepackagejsontooperation",
    "description": "",
    "operationName": "migrate-operation-model"
  },
  "OperationConfig": {
    "name": "OperationConfig",
    "slug": "TsInterface",
    "id": "operationconfig",
    "description": "\nanything configurable about the operation.\n\nOf course we could make this live in operation.json or as a prop in package.json, but it would be better to make it work with a markdown file.\n\nLet's try to use OPERATION.md\n\nTODO: Make this work and make sure the operationconfig is parsed from this file using `db.get(\"OperationConfig\")` as per convention.",
    "operationName": "migrate-operation-model",
    "rawText": "\n\n/**\n * ---\n * operationRelativePath: OPERATION.md\n * isOperationIndex: true\n * ---\n *\n * anything configurable about the operation.\n *\n * Of course we could make this live in operation.json or as a prop in package.json, but it would be better to make it work with a markdown file.\n *\n * Let's try to use OPERATION.md\n *\n * TODO: Make this work and make sure the operationconfig is parsed from this file using `db.get(\"OperationConfig\")` as per convention.\n *\n */\nexport interface OperationConfig extends MarkdownModelType {\n  /**\n   *\n   * Sometimes you are using function in a UI, which cannot be inferred with imports because they are used indirectly via an api. Here you can specify which operations on the backend are needed for an operation (ui mostly)\n   *\n   * This array is simply a list of operation names needed for this operation that are not imported.\n   *\n   * NB: no need to specify things here that you also import in this operation, because these are already automatically detected.\n   *\n   */\n  indirectDependencies?: string[];\n\n  /**\n   * A list of authors\n   *\n   * Should be used to create bundle AUTHORS.md\n   */\n  authors?: string[];\n\n  /**\n   * A list of contributors\n   *\n   * Can be used to create bundle CONTRIBUTORS.md\n   */\n  contributors?: string[];\n\n  /**\n   * one-line explanation of what the operation does (no markdown)\n   */\n  shortDescriptionText?: string;\n\n  /**\n   * Any descriptions in markdown format\n   *\n   * - Markdown description of what the operation does.\n   * - Installation instructions, if it is possible\n   * - Usage instructions (with example), if available\n   *\n   * This is the main content of the markdown file\n   */\n  markdown: string;\n}"
  },
  "OperationIndex": {
    "name": "OperationIndex",
    "slug": "TsInterface",
    "id": "operationindex",
    "description": "\ncontains all calculated info about an operation that needs to be retreived often:\nsome package-only things, but also a collection of all indexes of all files\n\nshould be able to be found in operaiton folder in /db/operation-index.json",
    "operationName": "migrate-operation-model",
    "rawText": "\n\n/**\n * ---\n * dbStorageMethod: jsonSingle\n * operationRelativePath: db/operation-index.json\n * ---\n *\n * contains all calculated info about an operation that needs to be retreived often:\n * some package-only things, but also a collection of all indexes of all files\n *\n * should be able to be found in operaiton folder in /db/operation-index.json\n */\nexport interface OperationIndex extends GeneralOperationIndex, SlugModelType {\n  /**\n   * here for compatibility, should implement...\n   */\n  id: string;\n  createdAt: number;\n  buildSucceeded: boolean;\n  dependenciesBuildsFailed: boolean;\n  indexImportExportError: string;\n  lintProblems: string[];\n  indexInteracesErrors: string[];\n  indexErrors: string[];\n  size: FolderSummary;\n}"
  },
  "SensibleConfig": {
    "name": "SensibleConfig",
    "slug": "TsInterface",
    "id": "sensibleconfig",
    "description": "Sensible-global configurations\n\nTODO: rename to `typerepo`",
    "operationName": "migrate-operation-model",
    "rawText": "\n\n/**\n * Sensible-global configurations\n *\n * TODO: rename to `typerepo`\n */\nexport type SensibleConfig = {\n  /**\n   * put on to true if minify doesn't work, so it will be skipped by `rebuildOperation`\n   */\n  skipMinify?: boolean;\n  /**\n   * If true, this is the root of a typerepo\n   *\n   * TODO: check if we can deprecate this\n   */\n  isSensibleProject?: boolean;\n  /**\n   * If true, it means that this operation has dependency on one or more operations that have been generated. We need to know this because it can easily cause circular imports if we don't filter them out sometimes\n   */\n  hasGeneratedDependencies?: boolean;\n  /**\n   * If the operation exposes an app on a port (can be both a server or frontend), we can specify the port it should run on.\n   *\n   * This is especially useful to connect the port to something that's running.\n   *\n   * By convention, for the OS, these ports should be unique and on the 420xx range\n   */\n  appPort?: number;\n  /**\n   * If set to true, this operation will not be included into the SDKs\n   */\n  isNotSdkable?: boolean;\n};"
  },
  "Company": {
    "name": "Company",
    "slug": "TsInterface",
    "id": "company",
    "description": "(Contributor) e.g. factory, farmer, headoffice",
    "operationName": "passionfruit-ui"
  },
  "CompanyRequirement": {
    "name": "CompanyRequirement",
    "slug": "TsInterface",
    "id": "companyrequirement",
    "description": "examples:\n- all farmers in spain need to provide a water report",
    "operationName": "passionfruit-ui"
  },
  "Contribution": {
    "name": "Contribution",
    "slug": "TsInterface",
    "id": "contribution",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "EsgMetric": {
    "name": "EsgMetric",
    "slug": "TsInterface",
    "id": "esgmetric",
    "description": "environmental social governance",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof calculateFullCompany>": {
    "name": "NamedParameters<typeof calculateFullCompany>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-calculatefullcompany",
    "description": "",
    "operationName": "foodchain-recipes"
  },
  "NamedParameters<typeof companyAttachContributionInformation>": {
    "name": "NamedParameters<typeof companyAttachContributionInformation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-companyattachcontributioninformation",
    "description": "",
    "operationName": "foodchain-recipes"
  },
  "NamedParameters<typeof companyAttachEsgMetricProofStates>": {
    "name": "NamedParameters<typeof companyAttachEsgMetricProofStates>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-companyattachesgmetricproofstates",
    "description": "",
    "operationName": "foodchain-recipes"
  },
  "NamedParameters<typeof companyAttachRequirements>": {
    "name": "NamedParameters<typeof companyAttachRequirements>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-companyattachrequirements",
    "description": "",
    "operationName": "foodchain-recipes"
  },
  "NamedParameters<typeof companyAttachTransparency>": {
    "name": "NamedParameters<typeof companyAttachTransparency>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-companyattachtransparency",
    "description": "",
    "operationName": "foodchain-recipes"
  },
  "NamedParameters<typeof contributionAddNextContributions>": {
    "name": "NamedParameters<typeof contributionAddNextContributions>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-contributionaddnextcontributions",
    "description": "",
    "operationName": "foodchain-recipes"
  },
  "NamedParameters<typeof getActivities>": {
    "name": "NamedParameters<typeof getActivities>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getactivities",
    "description": "",
    "operationName": "foodchain-recipes"
  },
  "NamedParameters<typeof getAverage>": {
    "name": "NamedParameters<typeof getAverage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getaverage",
    "description": "",
    "operationName": "foodchain-recipes"
  },
  "NamedParameters<typeof getCompanies>": {
    "name": "NamedParameters<typeof getCompanies>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcompanies",
    "description": "",
    "operationName": "foodchain-recipes"
  },
  "NamedParameters<typeof getFinalProducts>": {
    "name": "NamedParameters<typeof getFinalProducts>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfinalproducts",
    "description": "",
    "operationName": "foodchain-recipes"
  },
  "NamedParameters<typeof getFullCompanyData>": {
    "name": "NamedParameters<typeof getFullCompanyData>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfullcompanydata",
    "description": "",
    "operationName": "foodchain-recipes"
  },
  "NamedParameters<typeof getIngredientProducts>": {
    "name": "NamedParameters<typeof getIngredientProducts>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getingredientproducts",
    "description": "",
    "operationName": "foodchain-recipes"
  },
  "NamedParameters<typeof getProductValueChain>": {
    "name": "NamedParameters<typeof getProductValueChain>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getproductvaluechain",
    "description": "",
    "operationName": "foodchain-recipes"
  },
  "NamedParameters<typeof getProductValueChainForProduct>": {
    "name": "NamedParameters<typeof getProductValueChainForProduct>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getproductvaluechainforproduct",
    "description": "",
    "operationName": "foodchain-recipes"
  },
  "NamedParameters<typeof getRequiredValueChainData>": {
    "name": "NamedParameters<typeof getRequiredValueChainData>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getrequiredvaluechaindata",
    "description": "",
    "operationName": "foodchain-recipes"
  },
  "NamedParameters<typeof getSustainabilityPlan>": {
    "name": "NamedParameters<typeof getSustainabilityPlan>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsustainabilityplan",
    "description": "",
    "operationName": "foodchain-recipes"
  },
  "NamedParameters<typeof requirementAttachProofStates>": {
    "name": "NamedParameters<typeof requirementAttachProofStates>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-requirementattachproofstates",
    "description": "",
    "operationName": "foodchain-recipes"
  },
  "NamedParameters<typeof sumEsgMetricProofStates>": {
    "name": "NamedParameters<typeof sumEsgMetricProofStates>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-sumesgmetricproofstates",
    "description": "",
    "operationName": "foodchain-recipes"
  },
  "Product": {
    "name": "Product",
    "slug": "TsInterface",
    "id": "product",
    "description": "",
    "operationName": "foodchain-types",
    "rawText": "\n\nexport interface Product extends SlugModelType {\n  description?: Markdown;\n  productCategorySlug?: Slug;\n  productCategory?: ProductCategory;\n  productType: ProductType;\n  /**\n   * The weight in KG\n   */\n  weightKg?: number;\n  /**\n   * The length in meters\n   */\n  lengthMeter?: number;\n  /**\n   * The width in meters\n   */\n  widthMeter?: number;\n  /**\n   * The height in meters\n   */\n  heightMeter?: number;\n  /**\n   * EAN for this product. Not every product/ingredient has this\n   */\n  ean?: number;\n  /**\n   * Intern\n   *\n   * TODO: Ask for a description\n   */\n  consumerUnit: string;\n  /**\n   * extern\n   *\n   * TODO: Ask for a description\n   */\n  tradingUnit: string;\n\n  /**\n   * all contributions of this product of this sustainabilityplan\n   *\n   * Also needs the location name (include Location here)\n   * Also needs the Company.transparencyCalculated (include Company)\n   *\n   * With those things, we can calculate other calculated values as well (see below)\n   */\n  contributionsCalculated?: Contribution[];\n  numberOfOpenRequirementsCalculated: number;\n  socialPerformanceCalculated: ProgressBarMultiple;\n  environmentalPerformanceCalculated: ProgressBarMultiple;\n}"
  },
  "ProofState": {
    "name": "ProofState",
    "slug": "TsInterface",
    "id": "proofstate",
    "description": "This model holds the status for one proof for one company\n\nCompanies need to prove that they are adhering to certain proofs that belong to certain requirements that apply to them.\n\n\nNB: For now we have 3 types of assets",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof getCompanyRequirementDescription>": {
    "name": "NamedParameters<typeof getCompanyRequirementDescription>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcompanyrequirementdescription",
    "description": "",
    "operationName": "foodchain-recipes-js"
  },
  "NamedParameters<typeof requirementAppliesToCompany>": {
    "name": "NamedParameters<typeof requirementAppliesToCompany>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-requirementappliestocompany",
    "description": "",
    "operationName": "foodchain-recipes-js"
  },
  "Activity": {
    "name": "Activity",
    "slug": "TsInterface",
    "id": "activity",
    "description": "here we describe what the exact activities are of a specific company in a value chain",
    "operationName": "foodchain-types",
    "rawText": "\n\n/**\n * here we describe what the exact activities are of a specific company in a value chain\n */\nexport interface Activity extends KeyValueMarkdownModelType {\n  parent_activitySlug?: Slug;\n  parent_activity?: Activity;\n  /**\n   * company's with this activity\n   */\n  companysCalculated: Company[];\n\n  /**\n   * ESG Metrics with for every esg metrics the proof states per status\n   */\n  esgMetricProofStatesCalculated?: EsgMetric[];\n  /** \n  average over all companies\n\n  for details, check the individual companies under `companiesCalculated`\n  */\n  averageTransparencyPercentageCalculated?: number;\n}"
  },
  "CompanySize": {
    "name": "CompanySize",
    "slug": "TsInterface",
    "id": "companysize",
    "description": "the size of a company in terms of employees, expected values will be (micro, small, medium, large)",
    "operationName": "foodchain-types",
    "rawText": "\n\n/**\n * the size of a company in terms of employees, expected values will be (micro, small, medium, large)\n */\nexport interface CompanySize extends SlugModelType {\n  description: string;\n}"
  },
  "CompanyType": {
    "name": "CompanyType",
    "slug": "TsInterface",
    "id": "companytype",
    "description": "How is this company organized. We include this information so we know who we are talking to and what the expected outcomes could be\ne.g. an corporations or group speaks for mulitple smaller companies, while a self-oganized company speaks for itself (expected options are: self-organized, corporation, group)",
    "operationName": "foodchain-types",
    "rawText": "\n\n/** How is this company organized. We include this information so we know who we are talking to and what the expected outcomes could be\n * e.g. an corporations or group speaks for mulitple smaller companies, while a self-oganized company speaks for itself (expected options are: self-organized, corporation, group) */\n\nexport interface CompanyType extends SlugModelType {\n  description: string;\n}"
  },
  "ContactInformation": {
    "name": "ContactInformation",
    "slug": "TsInterface",
    "id": "contactinformation",
    "description": "",
    "operationName": "foodchain-types",
    "rawText": "\n\nexport interface ContactInformation extends SlugModelType {\n  locationSlug: Slug;\n  location?: Location;\n  phone: PhoneNumber;\n}"
  },
  "EsgMetricStatus": {
    "name": "EsgMetricStatus",
    "slug": "TsInterface",
    "id": "esgmetricstatus",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "ProductCategory": {
    "name": "ProductCategory",
    "slug": "TsInterface",
    "id": "productcategory",
    "description": "",
    "operationName": "foodchain-types",
    "rawText": "\n\nexport interface ProductCategory extends KeyValueMarkdownModelType {\n  parent_productCategorySlug?: Slug;\n  parent_productCategory?: ProductCategory;\n}"
  },
  "ProductType": {
    "name": "ProductType",
    "slug": "TsInterface",
    "id": "producttype",
    "description": "This are the type of products we can have. Expected values are: \"final product\", \"ingredient\", \"material?\", \"packaging, \"waste\"",
    "operationName": "foodchain-types",
    "rawText": "\n\n/**\n * This are the type of products we can have. Expected values are: \"final product\", \"ingredient\", \"material?\", \"packaging, \"waste\"\n */\n\nexport type ProductType =\n  | \"finalProduct\"\n  | \"ingredient\"\n  | \"material\"\n  | \"packaging\"\n  | \"waste\";"
  },
  "ProductValueChain": {
    "name": "ProductValueChain",
    "slug": "TsInterface",
    "id": "productvaluechain",
    "description": "\nmain info we need for a product value chain it is also probably what we are returning when we are viewing a specific part of the clients data",
    "operationName": "passionfruit-ui"
  },
  "ProgressBarMultiple": {
    "name": "ProgressBarMultiple",
    "slug": "TsInterface",
    "id": "progressbarmultiple",
    "description": "",
    "operationName": "foodchain-types",
    "rawText": "\n\nexport type ProgressBarMultiple = {\n  successful: number;\n  unsuccessful: number;\n  notAssessed: number;\n  label: string;\n};"
  },
  "Proof": {
    "name": "Proof",
    "slug": "TsInterface",
    "id": "proof",
    "description": "sustainabilityplan companyRequirements\n\ne.g. planet proof, fair trade original\n\nProof:\n\n1. upload document certificate or audit report\n2. exact data (like Co2) that proofs a companies performance on a specific topic. ! This is out of scope for PoC !",
    "operationName": "foodchain-types",
    "rawText": "\n\n/**\n\nsustainabilityplan companyRequirements\n  \ne.g. planet proof, fair trade original\n  \nProof:\n  \n1. upload document certificate or audit report\n2. exact data (like Co2) that proofs a companies performance on a specific topic. ! This is out of scope for PoC !\n  \n   */\nexport interface Proof extends KeyValueMarkdownModelType {\n  parent_proofSlug?: Slug;\n  parent_proof?: Proof;\n}"
  },
  "ProofStateStatus": {
    "name": "ProofStateStatus",
    "slug": "TsInterface",
    "id": "proofstatestatus",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "SustainabilityPlan": {
    "name": "SustainabilityPlan",
    "slug": "TsInterface",
    "id": "sustainabilityplan",
    "description": "STEP 2: Sustainability plan\n\n\nA sustainabilityPlan is a collection of companyRequirements\n\nIn fact, there is probably just 1 sustainability plan, so maybe we don't need this as a model, which would be nice\n\nTODO: Ask about the above",
    "operationName": "foodchain-types",
    "rawText": "\n\n// STEP 2: Sustainability plan\n\n/**\n * A sustainabilityPlan is a collection of companyRequirements\n *\n * In fact, there is probably just 1 sustainability plan, so maybe we don't need this as a model, which would be nice\n *\n * TODO: Ask about the above\n */\nexport interface SustainabilityPlan extends SlugModelType {\n  description: Markdown;\n  /**\n  \n  returns CompanyRequirements array including their referenced models and including `totalCompanysCalculated`. Only done at `getSustainabilityPlan` endpoint\n\n\n  THOUGHT: figure out how I can later make a sustainabilityplans endpoint that includes the companyRequirements per sustainabilityplan. For this, I need to have the companyRequirements here, but they are not to be stored in the database. How? Maybe add a new convention named \"Ref\"? If a parameter ends with xxxRef, it is not a value in the db, but it comes from references made to this model. UPDATE: I think this is the same as simply calling it xxxCalculated, there is no point to differentiate (at the moment). Alternatively we can call it \"xxxxFromReference\" to be more precise.\n  \n   */\n  companyRequirementsCalculated?: CompanyRequirement[];\n}"
  },
  "TransparencyDetailsCalculated": {
    "name": "TransparencyDetailsCalculated",
    "slug": "TsInterface",
    "id": "transparencydetailscalculated",
    "description": "",
    "operationName": "foodchain-types",
    "rawText": "\n\nexport type TransparencyDetailsCalculated = {\n  notFilledInFormFields: string[]; //(keyof Company)[]; NB: the keyof Company doesn't work with indexation\n  formScore: number;\n  requirementScore: number;\n  requirementsTodoNames: string[];\n};"
  },
  "ValueChainPhase": {
    "name": "ValueChainPhase",
    "slug": "TsInterface",
    "id": "valuechainphase",
    "description": "step: model to chronologically categorise the contributors\n\nTODO: thinking about dynamically generating value chain phases based on chronological contributions\n\nUPDATE:\n\nwhy not automatically generate phases? The reason is that we have no information about the chronological order of the activities. We could generate phases, but there will be multiple contributions without a link to a previous contribution. Those contributions could have multiple different activities. We don't know then which activity should be the first one. Then we still end up having to manually sort the phases.\n\nUltimately, it may be better to still generate phases and have them be sorted manually, but it's a lot of extra work.",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof AdminLinks>": {
    "name": "NamedParameters<typeof AdminLinks>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-adminlinks",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof AverageMetricDougnut>": {
    "name": "NamedParameters<typeof AverageMetricDougnut>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-averagemetricdougnut",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof AverageTransparencyDougnut>": {
    "name": "NamedParameters<typeof AverageTransparencyDougnut>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-averagetransparencydougnut",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof CompanyInfo>": {
    "name": "NamedParameters<typeof CompanyInfo>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-companyinfo",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof CompanyInfoTab>": {
    "name": "NamedParameters<typeof CompanyInfoTab>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-companyinfotab",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof CountriesHorizontalBar>": {
    "name": "NamedParameters<typeof CountriesHorizontalBar>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-countrieshorizontalbar",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof EnvironmentTab>": {
    "name": "NamedParameters<typeof EnvironmentTab>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-environmenttab",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof getAverageCompanies>": {
    "name": "NamedParameters<typeof getAverageCompanies>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getaveragecompanies",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof getAverageTransparency>": {
    "name": "NamedParameters<typeof getAverageTransparency>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getaveragetransparency",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof getCompanyToDos>": {
    "name": "NamedParameters<typeof getCompanyToDos>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcompanytodos",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof getCompanyTransparency>": {
    "name": "NamedParameters<typeof getCompanyTransparency>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcompanytransparency",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof getMappedProducts>": {
    "name": "NamedParameters<typeof getMappedProducts>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmappedproducts",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof getValueChainlength>": {
    "name": "NamedParameters<typeof getValueChainlength>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getvaluechainlength",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof GoalsOverview>": {
    "name": "NamedParameters<typeof GoalsOverview>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-goalsoverview",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof GoalsTab>": {
    "name": "NamedParameters<typeof GoalsTab>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-goalstab",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof PriorityChip>": {
    "name": "NamedParameters<typeof PriorityChip>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-prioritychip",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof ProofStateForm>": {
    "name": "NamedParameters<typeof ProofStateForm>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-proofstateform",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof ProofStatusChip>": {
    "name": "NamedParameters<typeof ProofStatusChip>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-proofstatuschip",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof RenderCompanyEsgPolarArea>": {
    "name": "NamedParameters<typeof RenderCompanyEsgPolarArea>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rendercompanyesgpolararea",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof renderEsgMetrics>": {
    "name": "NamedParameters<typeof renderEsgMetrics>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-renderesgmetrics",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof RenderGetEnvPerformance>": {
    "name": "NamedParameters<typeof RenderGetEnvPerformance>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rendergetenvperformance",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof renderGetProgressBarSingle>": {
    "name": "NamedParameters<typeof renderGetProgressBarSingle>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rendergetprogressbarsingle",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof SideMenu>": {
    "name": "NamedParameters<typeof SideMenu>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-sidemenu",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof SocialTab>": {
    "name": "NamedParameters<typeof SocialTab>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-socialtab",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof ValueChainConnectionsForm>": {
    "name": "NamedParameters<typeof ValueChainConnectionsForm>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-valuechainconnectionsform",
    "description": "",
    "operationName": "passionfruit-ui"
  },
  "NamedParameters<typeof charIsLetter>": {
    "name": "NamedParameters<typeof charIsLetter>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-charisletter",
    "description": "",
    "operationName": "parse-address-henrik"
  },
  "NamedParameters<typeof createCsvString>": {
    "name": "NamedParameters<typeof createCsvString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-createcsvstring",
    "description": "",
    "operationName": "parse-address-henrik"
  },
  "NamedParameters<typeof oldToNew>": {
    "name": "NamedParameters<typeof oldToNew>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-oldtonew",
    "description": "",
    "operationName": "parse-address-henrik"
  },
  "NamedParameters<typeof parseAddress>": {
    "name": "NamedParameters<typeof parseAddress>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parseaddress",
    "description": "",
    "operationName": "parse-address-henrik"
  },
  "MyApp": {
    "name": "MyApp",
    "slug": "TsFunction",
    "id": "eqlzdzmhgigtizgzgtkumtvz",
    "description": "",
    "operationName": "passionfruit-web",
    "rawText": "\n\nfunction MyApp({ Component, pageProps }: AppProps) {\n  const router = useRouter();\n  const path = router.route.slice(1);\n  const pageKey = (path === \"\" ? \"index\" : path) as keyof typeof pagesObject;\n  const page = pages.find((x) => x.key === pageKey);\n  const title = page ? `${getPageTitle(page)} - PassionFruit` : \"PassionFruit\";\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Head>\n        <title>{title}</title>\n      </Head>\n      <ToastContainer />\n      <AlertProvider>\n        <ModalProvider>\n          <StoreProvider>\n            <Component {...pageProps} />\n          </StoreProvider>\n        </ModalProvider>\n      </AlertProvider>\n    </QueryClientProvider>\n  );\n}"
  },
  "useReactMediaRecorder": {
    "name": "useReactMediaRecorder",
    "slug": "TsFunction",
    "id": "adzjcgehieogjcqnogbghdai",
    "description": "",
    "operationName": "asset-input",
    "rawText": "\n\nexport function useReactMediaRecorder({\n  audio = true,\n  video = false,\n  onStop = () => null,\n  onStart = () => null,\n  blobPropertyBag,\n  screen = false,\n  mediaRecorderOptions = undefined,\n  customMediaStream = null,\n  stopStreamsOnStop = true,\n  askPermissionOnMount = false,\n}: ReactMediaRecorderHookProps): ReactMediaRecorderRenderProps {\n  const mediaRecorder = useRef<IMediaRecorder | null>(null);\n  const mediaChunks = useRef<Blob[]>([]);\n  const mediaStream = useRef<MediaStream | null>(null);\n  const [status, setStatus] = useState<StatusMessages>(\"idle\");\n  const [isAudioMuted, setIsAudioMuted] = useState<boolean>(false);\n  const [mediaBlobUrl, setMediaBlobUrl] = useState<string | undefined>(\n    undefined\n  );\n  const [error, setError] = useState<keyof typeof RecorderErrors>(\"NONE\");\n\n  useEffect(() => {\n    let messagePort: MessagePort | undefined = undefined;\n    const setup = async () => {\n      try {\n        // NB: try to connect, if it fails, don't crash, just assume it already is there\n        messagePort = await connect();\n        await register(messagePort);\n      } catch (e) {\n        console.log(\"errrie\", e);\n      }\n    };\n    setup();\n\n    // NB: need to clean it up!\n    return () => {\n      if (messagePort) {\n        disconnect(messagePort);\n      }\n    };\n  }, []);\n\n  const getMediaStream = useCallback(async () => {\n    setStatus(\"acquiring_media\");\n    const requiredMedia: MediaStreamConstraints = {\n      audio: typeof audio === \"boolean\" ? !!audio : audio,\n      video: typeof video === \"boolean\" ? !!video : video,\n    };\n    try {\n      if (customMediaStream) {\n        mediaStream.current = customMediaStream;\n      } else if (screen) {\n        const stream = (await window.navigator.mediaDevices.getDisplayMedia({\n          video: video || true,\n        })) as MediaStream;\n        stream.getVideoTracks()[0].addEventListener(\"ended\", () => {\n          stopRecording();\n        });\n        if (audio) {\n          const audioStream = await window.navigator.mediaDevices.getUserMedia({\n            audio,\n          });\n\n          audioStream\n            .getAudioTracks()\n            .forEach((audioTrack) => stream.addTrack(audioTrack));\n        }\n        mediaStream.current = stream;\n      } else {\n        const stream = await window.navigator.mediaDevices.getUserMedia(\n          requiredMedia\n        );\n        mediaStream.current = stream;\n      }\n      setStatus(\"idle\");\n    } catch (error: any) {\n      setError(error.name);\n      setStatus(\"idle\");\n    }\n  }, [audio, video, screen]);\n\n  useEffect(() => {\n    if (!window.MediaRecorder) {\n      throw new Error(\"Unsupported Browser\");\n    }\n\n    if (screen) {\n      if (!window.navigator.mediaDevices.getDisplayMedia) {\n        throw new Error(\"This browser doesn't support screen capturing\");\n      }\n    }\n\n    const checkConstraints = (mediaType: MediaTrackConstraints) => {\n      const supportedMediaConstraints =\n        navigator.mediaDevices.getSupportedConstraints();\n      const unSupportedConstraints = Object.keys(mediaType).filter(\n        (constraint) =>\n          !(supportedMediaConstraints as { [key: string]: any })[constraint]\n      );\n\n      if (unSupportedConstraints.length > 0) {\n        console.error(\n          `The constraints ${unSupportedConstraints.join(\n            \",\"\n          )} doesn't support on this browser. Please check your ReactMediaRecorder component.`\n        );\n      }\n    };\n\n    if (typeof audio === \"object\") {\n      checkConstraints(audio);\n    }\n    if (typeof video === \"object\") {\n      checkConstraints(video);\n    }\n\n    if (mediaRecorderOptions && mediaRecorderOptions.mimeType) {\n      if (!MediaRecorder.isTypeSupported(mediaRecorderOptions.mimeType)) {\n        console.error(\n          `The specified MIME type you supplied for MediaRecorder doesn't support this browser`\n        );\n      }\n    }\n\n    if (!mediaStream.current && askPermissionOnMount) {\n      getMediaStream();\n    }\n\n    return () => {\n      if (mediaStream.current) {\n        const tracks = mediaStream.current.getTracks();\n        tracks.forEach((track) => track.clone().stop());\n      }\n    };\n  }, [\n    audio,\n    screen,\n    video,\n    getMediaStream,\n    mediaRecorderOptions,\n    askPermissionOnMount,\n  ]);\n\n  // Media Recorder Handlers\n\n  const startRecording = async () => {\n    setError(\"NONE\");\n    if (!mediaStream.current) {\n      await getMediaStream();\n    }\n    if (mediaStream.current) {\n      const isStreamEnded = mediaStream.current\n        .getTracks()\n        .some((track) => track.readyState === \"ended\");\n      if (isStreamEnded) {\n        await getMediaStream();\n      }\n\n      // User blocked the permissions (getMediaStream errored out)\n      if (!mediaStream.current.active) {\n        return;\n      }\n      mediaRecorder.current = new ExtendableMediaRecorder(\n        mediaStream.current,\n        mediaRecorderOptions || undefined\n      );\n      mediaRecorder.current.ondataavailable = onRecordingActive;\n      mediaRecorder.current.onstop = onRecordingStop;\n      mediaRecorder.current.onstart = onRecordingStart;\n      mediaRecorder.current.onerror = () => {\n        setError(\"NO_RECORDER\");\n        setStatus(\"idle\");\n      };\n      mediaRecorder.current.start();\n      setStatus(\"recording\");\n    }\n  };\n\n  const onRecordingActive = ({ data }: BlobEvent) => {\n    mediaChunks.current.push(data);\n  };\n\n  const onRecordingStart = () => {\n    onStart();\n  };\n\n  const onRecordingStop = () => {\n    const [chunk] = mediaChunks.current;\n    const blobProperty: BlobPropertyBag = Object.assign(\n      { type: chunk.type },\n      blobPropertyBag || (video ? { type: \"video/mp4\" } : { type: \"audio/wav\" })\n    );\n    const blob = new Blob(mediaChunks.current, blobProperty);\n    const url = URL.createObjectURL(blob);\n    setStatus(\"stopped\");\n    setMediaBlobUrl(url);\n    onStop(url, blob);\n  };\n\n  const muteAudio = (mute: boolean) => {\n    setIsAudioMuted(mute);\n    if (mediaStream.current) {\n      mediaStream.current\n        .getAudioTracks()\n        .forEach((audioTrack) => (audioTrack.enabled = !mute));\n    }\n  };\n\n  const pauseRecording = () => {\n    if (mediaRecorder.current && mediaRecorder.current.state === \"recording\") {\n      setStatus(\"paused\");\n      mediaRecorder.current.pause();\n    }\n  };\n  const resumeRecording = () => {\n    if (mediaRecorder.current && mediaRecorder.current.state === \"paused\") {\n      setStatus(\"recording\");\n      mediaRecorder.current.resume();\n    }\n  };\n\n  const stopRecording = () => {\n    if (mediaRecorder.current) {\n      if (mediaRecorder.current.state !== \"inactive\") {\n        setStatus(\"stopping\");\n        mediaRecorder.current.stop();\n        if (stopStreamsOnStop) {\n          mediaStream.current &&\n            mediaStream.current.getTracks().forEach((track) => track.stop());\n        }\n        mediaChunks.current = [];\n      }\n    }\n  };\n\n  return {\n    error: RecorderErrors[error],\n    muteAudio: () => muteAudio(true),\n    unMuteAudio: () => muteAudio(false),\n    startRecording,\n    pauseRecording,\n    resumeRecording,\n    stopRecording,\n    mediaBlobUrl,\n    status,\n    isAudioMuted,\n    previewStream: mediaStream.current\n      ? new MediaStream(mediaStream.current.getVideoTracks())\n      : null,\n    previewAudioStream: mediaStream.current\n      ? new MediaStream(mediaStream.current.getAudioTracks())\n      : null,\n    clearBlobUrl: () => {\n      if (mediaBlobUrl) {\n        URL.revokeObjectURL(mediaBlobUrl);\n      }\n      setMediaBlobUrl(undefined);\n      setStatus(\"idle\");\n    },\n  };\n}"
  },
  "getChunkBegin": {
    "name": "getChunkBegin",
    "slug": "TsFunction",
    "id": "dpqqbtzpcjosgsgqqhcekrup",
    "description": "",
    "operationName": "text-or-binary",
    "rawText": "\n\n// ====================================\n// The functions below are created to handle multibyte utf8 characters.\n// To understand how the encoding works, check this article: https://en.wikipedia.org/wiki/UTF-8#Encoding\n// @todo add documentation for these\n\nfunction getChunkBegin(buf: Buffer, chunkBegin: number) {\n  // If it's the beginning, just return.\n  if (chunkBegin === 0) {\n    return 0;\n  }\n\n  if (!isLaterByteOfUtf8(buf[chunkBegin])) {\n    return chunkBegin;\n  }\n\n  let begin = chunkBegin - 3;\n\n  if (begin >= 0) {\n    if (isFirstByteOf4ByteChar(buf[begin])) {\n      return begin;\n    }\n  }\n\n  begin = chunkBegin - 2;\n\n  if (begin >= 0) {\n    if (\n      isFirstByteOf4ByteChar(buf[begin]) ||\n      isFirstByteOf3ByteChar(buf[begin])\n    ) {\n      return begin;\n    }\n  }\n\n  begin = chunkBegin - 1;\n\n  if (begin >= 0) {\n    // Is it a 4-byte, 3-byte utf8 character?\n    if (\n      isFirstByteOf4ByteChar(buf[begin]) ||\n      isFirstByteOf3ByteChar(buf[begin]) ||\n      isFirstByteOf2ByteChar(buf[begin])\n    ) {\n      return begin;\n    }\n  }\n\n  return -1;\n}"
  },
  "getChunkEnd": {
    "name": "getChunkEnd",
    "slug": "TsFunction",
    "id": "nymqhubidznczyjsslhujzcx",
    "description": "",
    "operationName": "text-or-binary",
    "rawText": "\n\nfunction getChunkEnd(buf: Buffer, chunkEnd: number) {\n  // If it's the end, just return.\n  if (chunkEnd === buf.length) {\n    return chunkEnd;\n  }\n\n  let index = chunkEnd - 3;\n\n  if (index >= 0) {\n    if (isFirstByteOf4ByteChar(buf[index])) {\n      return chunkEnd + 1;\n    }\n  }\n\n  index = chunkEnd - 2;\n\n  if (index >= 0) {\n    if (isFirstByteOf4ByteChar(buf[index])) {\n      return chunkEnd + 2;\n    }\n\n    if (isFirstByteOf3ByteChar(buf[index])) {\n      return chunkEnd + 1;\n    }\n  }\n\n  index = chunkEnd - 1;\n\n  if (index >= 0) {\n    if (isFirstByteOf4ByteChar(buf[index])) {\n      return chunkEnd + 3;\n    }\n\n    if (isFirstByteOf3ByteChar(buf[index])) {\n      return chunkEnd + 2;\n    }\n\n    if (isFirstByteOf2ByteChar(buf[index])) {\n      return chunkEnd + 1;\n    }\n  }\n\n  return chunkEnd;\n}"
  },
  "getEncoding": {
    "name": "getEncoding",
    "slug": "TsFunction",
    "id": "epjrqljlchloshvaootvgigu",
    "description": "/**\n * Get the encoding of a buffer.\n * Checks the start, middle, and end of the buffer for characters that are unrecognized within UTF8 encoding.\n * History has shown that inspection at all three locations is necessary.\n * @returns Will be `null` if `buffer` was not provided. Otherwise will be either `'utf8'` or `'binary'`\n */",
    "operationName": "text-or-binary",
    "rawText": "\n\n/**\n * Get the encoding of a buffer.\n * Checks the start, middle, and end of the buffer for characters that are unrecognized within UTF8 encoding.\n * History has shown that inspection at all three locations is necessary.\n * @returns Will be `null` if `buffer` was not provided. Otherwise will be either `'utf8'` or `'binary'`\n */\nexport function getEncoding(\n  buffer: Buffer | null,\n  opts?: EncodingOpts\n): \"utf8\" | \"binary\" | null {\n  // Check\n  if (!buffer) return null;\n\n  // Prepare\n  const textEncoding = \"utf8\";\n  const binaryEncoding = \"binary\";\n  const chunkLength = opts?.chunkLength ?? 24;\n  let chunkBegin = opts?.chunkBegin ?? 0;\n\n  // Discover\n  if (opts?.chunkBegin == null) {\n    // Start\n    let encoding = getEncoding(buffer, { chunkLength, chunkBegin });\n    if (encoding === textEncoding) {\n      // Middle\n      chunkBegin = Math.max(0, Math.floor(buffer.length / 2) - chunkLength);\n      encoding = getEncoding(buffer, {\n        chunkLength,\n        chunkBegin,\n      });\n      if (encoding === textEncoding) {\n        // End\n        chunkBegin = Math.max(0, buffer.length - chunkLength);\n        encoding = getEncoding(buffer, {\n          chunkLength,\n          chunkBegin,\n        });\n      }\n    }\n\n    // Return\n    return encoding;\n  } else {\n    // Extract\n    chunkBegin = getChunkBegin(buffer, chunkBegin);\n    if (chunkBegin === -1) {\n      return binaryEncoding;\n    }\n\n    const chunkEnd = getChunkEnd(\n      buffer,\n      Math.min(buffer.length, chunkBegin + chunkLength)\n    );\n\n    if (chunkEnd > buffer.length) {\n      return binaryEncoding;\n    }\n\n    const contentChunkUTF8 = buffer.toString(\n      textEncoding,\n      chunkBegin,\n      chunkEnd\n    );\n\n    // Detect encoding\n    for (let i = 0; i < contentChunkUTF8.length; ++i) {\n      const charCode = contentChunkUTF8.charCodeAt(i);\n      if (charCode === 65533 || charCode <= 8) {\n        // 8 and below are control characters (e.g. backspace, null, eof, etc.)\n        // 65533 is the unknown character\n        // console.log(charCode, contentChunkUTF8[i])\n        return binaryEncoding;\n      }\n    }\n\n    // Return\n    return textEncoding;\n  }\n}"
  },
  "isBinary": {
    "name": "isBinary",
    "slug": "TsFunction",
    "id": "omispmttzeaebwomjooqdpho",
    "description": "/**\n * Determine if the filename and/or buffer is binary.\n * Determined by extension checks first (if filename is available), otherwise if unknown extension or no filename, will perform a slower buffer encoding detection.\n * This order is done, as extension checks are quicker, and also because encoding checks cannot guarantee accuracy for chars between utf8 and utf16.\n * The extension checks are performed using the resources https://github.com/bevry/textextensions and https://github.com/bevry/binaryextensions\n * @param filename The filename for the file/buffer if available\n * @param buffer The buffer for the file if available\n * @returns Will be `null` if neither `filename` nor `buffer` were provided. Otherwise will be a boolean value with the detection result.\n */",
    "operationName": "text-or-binary",
    "rawText": "\n\n/**\n * Determine if the filename and/or buffer is binary.\n * Determined by extension checks first (if filename is available), otherwise if unknown extension or no filename, will perform a slower buffer encoding detection.\n * This order is done, as extension checks are quicker, and also because encoding checks cannot guarantee accuracy for chars between utf8 and utf16.\n * The extension checks are performed using the resources https://github.com/bevry/textextensions and https://github.com/bevry/binaryextensions\n * @param filename The filename for the file/buffer if available\n * @param buffer The buffer for the file if available\n * @returns Will be `null` if neither `filename` nor `buffer` were provided. Otherwise will be a boolean value with the detection result.\n */\nexport function isBinary(filename?: string | null, buffer?: Buffer | null) {\n  const text = isText(filename, buffer);\n  if (text == null) return null;\n  return !text;\n}"
  },
  "isFirstByteOf2ByteChar": {
    "name": "isFirstByteOf2ByteChar",
    "slug": "TsFunction",
    "id": "wimwuapiyqrarypchvvjupfb",
    "description": "",
    "operationName": "text-or-binary",
    "rawText": "\n\nfunction isFirstByteOf2ByteChar(byte: number) {\n  // eslint-disable-next-line no-bitwise\n  return byte >> 5 === 6; // 110xxxxx?\n}"
  },
  "isFirstByteOf3ByteChar": {
    "name": "isFirstByteOf3ByteChar",
    "slug": "TsFunction",
    "id": "mwsubapdtyinkdohghkyizll",
    "description": "",
    "operationName": "text-or-binary",
    "rawText": "\n\nfunction isFirstByteOf3ByteChar(byte: number) {\n  // eslint-disable-next-line no-bitwise\n  return byte >> 4 === 14; // 1110xxxx?\n}"
  },
  "isFirstByteOf4ByteChar": {
    "name": "isFirstByteOf4ByteChar",
    "slug": "TsFunction",
    "id": "qlviaziftpfbzvnieugpixac",
    "description": "",
    "operationName": "text-or-binary",
    "rawText": "\n\nfunction isFirstByteOf4ByteChar(byte: number) {\n  // eslint-disable-next-line no-bitwise\n  return byte >> 3 === 30; // 11110xxx?\n}"
  },
  "isLaterByteOfUtf8": {
    "name": "isLaterByteOfUtf8",
    "slug": "TsFunction",
    "id": "gwibaodbvgypyeqtbrfmtrmb",
    "description": "",
    "operationName": "text-or-binary",
    "rawText": "\n\nfunction isLaterByteOfUtf8(byte: number) {\n  // eslint-disable-next-line no-bitwise\n  return byte >> 6 === 2; // 10xxxxxx?\n}"
  },
  "isText": {
    "name": "isText",
    "slug": "TsFunction",
    "id": "xxahekicfxlpjdndjwcdsyyu",
    "description": "/**\n * Determine if the filename and/or buffer is text.\n * Determined by extension checks first (if filename is available), otherwise if unknown extension or no filename, will perform a slower buffer encoding detection.\n * This order is done, as extension checks are quicker, and also because encoding checks cannot guarantee accuracy for chars between utf8 and utf16.\n * The extension checks are performed using the resources https://github.com/bevry/textextensions and https://github.com/bevry/binaryextensions\n * @param filename The filename for the file/buffer if available\n * @param buffer The buffer for the file if available\n * @returns Will be `null` if neither `filename` nor `buffer` were provided. Otherwise will be a boolean value with the detection result.\n */",
    "operationName": "text-or-binary",
    "rawText": "\n\n/**\n * Determine if the filename and/or buffer is text.\n * Determined by extension checks first (if filename is available), otherwise if unknown extension or no filename, will perform a slower buffer encoding detection.\n * This order is done, as extension checks are quicker, and also because encoding checks cannot guarantee accuracy for chars between utf8 and utf16.\n * The extension checks are performed using the resources https://github.com/bevry/textextensions and https://github.com/bevry/binaryextensions\n * @param filename The filename for the file/buffer if available\n * @param buffer The buffer for the file if available\n * @returns Will be `null` if neither `filename` nor `buffer` were provided. Otherwise will be a boolean value with the detection result.\n */\nexport function isText(\n  filename?: string | null,\n  buffer?: Buffer | null\n): boolean | null {\n  // Test extensions\n  if (filename) {\n    // Extract filename\n    const parts = pathUtil.basename(filename).split(\".\").reverse();\n\n    // Cycle extensions\n    for (const extension of parts) {\n      if (textExtensions.indexOf(extension) !== -1) {\n        return true;\n      }\n      if (binaryExtensions.indexOf(extension) !== -1) {\n        return false;\n      }\n    }\n  }\n\n  // Fallback to encoding if extension check was not enough\n  if (buffer) {\n    return getEncoding(buffer) === \"utf8\";\n  }\n\n  // No buffer was provided\n  return null;\n}"
  },
  "byteCount": {
    "name": "byteCount",
    "slug": "TsFunction",
    "id": "xfedlzbwsebxxuimeozoxyjy",
    "description": "/**\n * This function will return the byte size of any UTF-8 string you pass to it.\n */",
    "operationName": "path-util",
    "rawText": "\n\n/**\n * This function will return the byte size of any UTF-8 string you pass to it.\n */\nexport function byteCount(s: string) {\n  return encodeURI(s).split(/%..|./).length - 1;\n}"
  },
  "setKeyAtLocation": {
    "name": "setKeyAtLocation",
    "slug": "TsFunction",
    "id": "fhokdhwjugwhlawqsmbyquur",
    "description": "",
    "operationName": "set-json-key",
    "rawText": "\nexport function setKeyAtLocation(path: string, value: any, object: any) {\n  var schema = object; // a moving reference to internal objects within obj\n  var pList = path.split(\".\");\n  var len = pList.length;\n  for (var i = 0; i < len - 1; i++) {\n    var elem = pList[i];\n    if (!schema[elem]) schema[elem] = {};\n    schema = schema[elem];\n  }\n\n  schema[pList[len - 1]] = value;\n}"
  },
  "makeSubscription": {
    "name": "makeSubscription",
    "slug": "TsFunction",
    "id": "pyvickbisxyossytsgysxiad",
    "description": "",
    "operationName": "watch-folders",
    "rawText": "\n\n// `watch` is obtained from `resp.watch` in the `watch-project` response.\n// `relative_path` is obtained from `resp.relative_path` in the\n// `watch-project` response.\nexport function makeSubscription(\n  client: watchman.Client,\n  watchBaseFolder: string,\n  watchRelativePath: string,\n  debug: boolean\n) {\n  /**\n   * this can probably be optimised\n   */\n  const sub = {\n    // Match any `.js` file in the dir_of_interest\n    expression: [\"allof\", [\"match\", \"*.*\"]],\n    // Which fields we're interested in\n    fields: [\"name\", \"size\", \"mtime_ms\", \"exists\", \"type\"],\n    relative_root: undefined as undefined | string,\n    // add our time constraint\n  };\n\n  if (watchRelativePath) {\n    sub.relative_root = watchRelativePath;\n  }\n\n  const subName = getSubName(watchBaseFolder, watchRelativePath);\n\n  client.command(\n    [\"subscribe\", watchBaseFolder, subName, sub],\n    function (error, resp) {\n      if (error) {\n        // Probably an error in the subscription criteria\n        console.error(\"Failed to subscribe: \", error);\n        return;\n      }\n      if (debug) {\n        console.log(\n          \"New subscription:\",\n          \"subscription \" + resp.subscribe + \" established\"\n        );\n      }\n    }\n  );\n\n  return subName;\n}"
  },
  "videoToMp3": {
    "name": "videoToMp3",
    "slug": "TsFunction",
    "id": "fhztfszsumlhvdgpbdvxsitq",
    "description": "",
    "operationName": "video-to-mp3",
    "rawText": "\n\nasync function videoToMp3({ filePath }: { filePath: string }) {\n  try {\n    // creating promises to download video\n    const res = await new Promise((resolve, reject) => {\n      // creating youtube video stream\n      let totalTime = 1;\n      // passing that stream to ffmpeg for mp3 conversion\n      var process = ffmpeg({ source: filePath });\n      process\n        .toFormat(\"mp3\") // setting file format\n        .saveToFile(`data/sample.mp3`) // setting path and file name of output\n        .on(\"codecData\", (data) => {\n          // HERE YOU GET THE TOTAL TIME\n          totalTime = parseInt(data.duration.replace(/:/g, \"\"));\n          console.log(\"Conversion Start...\");\n        })\n        .on(\"progress\", (progress) => {\n          // HERE IS THE CURRENT TIME\n          const time = parseInt(progress.timemark.replace(/:/g, \"\"));\n          // AND HERE IS THE CALCULATION\n          const percent = Math.floor((time / totalTime) * 100);\n          console.log(`${percent}%`);\n        })\n        .on(\"end\", () => {\n          console.log(\"file conversion done\");\n          resolve({\n            success: true,\n            message: \"File conversion successfull\",\n          });\n        })\n        .on(\"error\", (e: Error) => {\n          resolve({ success: false, message: e.message });\n        });\n    });\n    return res;\n  } catch (e: any) {\n    return { success: false, message: e };\n  }\n}"
  },
  "convertCsvToJson": {
    "name": "convertCsvToJson",
    "slug": "TsFunction",
    "id": "xjhvougeerxajgfsrehclmlu",
    "description": "",
    "operationName": "xls-to-csv-json",
    "rawText": "\n\nexport async function convertCsvToJson(): Promise<{\n  success: boolean;\n  response?: string;\n  data?: any;\n}> {\n  return new Promise((resolve, reject) => {\n    csv(\"../sample.csv\", function (error: any, result: any) {\n      resolve({\n        success: true,\n        data: result,\n      });\n    });\n  });\n}"
  },
  "convertXlsToJson": {
    "name": "convertXlsToJson",
    "slug": "TsFunction",
    "id": "thtuznepnnwedxsayxmxwtdn",
    "description": "",
    "operationName": "xls-to-csv-json",
    "rawText": "\n\nexport async function convertXlsToJson(): Promise<{\n  success: boolean;\n  response?: string;\n  data?: any;\n}> {\n  return new Promise((resolve, reject) => {\n    xls(\"../sample.xls\", function (error: any, result: any) {\n      resolve({\n        success: true,\n        data: result,\n      });\n    });\n  });\n}"
  },
  "docToMd": {
    "name": "docToMd",
    "slug": "TsFunction",
    "id": "ztbgtpvtxvjrghfdglqewbqh",
    "description": "",
    "operationName": "doc-to-md",
    "rawText": "\n\nexport async function docToMd(filepath: string): Promise<{\n  success: boolean;\n  response?: string;\n  text?: any;\n}> {\n  return new Promise(async (resolve, reject) => {\n    //Some code to open rar here\n    // Read the archive file into a typedArray\n\n    textract.fromFileWithPath(filepath, function (error: any, text: any) {\n      if (error) {\n        resolve({ success: false });\n      }\n      var opath = \"output.md\";\n      var ostring = text;\n      fs.writeFileSync(opath, ostring, \"utf8\");\n      resolve({\n        success: true,\n        text,\n      });\n    });\n  });\n}"
  },
  "docxToMd": {
    "name": "docxToMd",
    "slug": "TsFunction",
    "id": "ocpooyjmndvfampfxgstxotj",
    "description": "",
    "operationName": "doc-to-md",
    "rawText": "\nexport async function docxToMd(filepath: string): Promise<{\n  success: boolean;\n  response?: string;\n  text?: any;\n}> {\n  return new Promise(async (resolve, reject) => {\n    // mammoth\n    // \t.convertToHtml({ path: sample2 })\n    // \t.then(function (result) {\n    // \t\tvar html = result.value; // The generated HTML\n    // \t\tconsole.log('this is the html: ' + JSON.stringify(html, null, 2));\n    // \t\tvar messages = result.messages; // Any messages, such as warnings during conversion\n    // \t})\n    // \t.done();\n    mammoth\n      .extractRawText({ path: filepath })\n      .then(function (result: any) {\n        var text = result.value; // The raw text\n        var messages = result.messages;\n        var opath = \"output.md\";\n        var ostring = text;\n        fs.writeFileSync(opath, ostring, \"utf8\");\n        resolve({\n          success: true,\n          text,\n        });\n      })\n      .done();\n  });\n}"
  },
  "fetchWeatherStormGlass": {
    "name": "fetchWeatherStormGlass",
    "slug": "TsFunction",
    "id": "xcxxjrkenqmtgokcmkycpxiu",
    "description": "/** \n    Storm glass offers:\n        - 10 requests per day\n        - All weather parameters\n*/",
    "operationName": "weather-sensor",
    "rawText": "\n/** \n    Storm glass offers:\n        - 10 requests per day\n        - All weather parameters\n*/\n\nexport async function fetchWeatherStormGlass(): Promise<{\n  success: boolean;\n  response?: string;\n  data?: any;\n}> {\n  const stormGlassApiKey =\n    \"6ed20e3c-085a-11ed-b697-0242ac130002-6ed20e96-085a-11ed-b697-0242ac130002\";\n  try {\n    const lat = 58.7984;\n    const lng = 17.8081;\n    const params = \"windSpeed\";\n    const res = await fetch(\n      `https://api.stormglass.io/v2/weather/point?lat=${lat}&lng=${lng}&params=${params}`,\n      {\n        headers: {\n          Authorization: stormGlassApiKey,\n        },\n      }\n    );\n    if (!res.ok) {\n      const data = await res.json();\n      return {\n        success: false,\n        response: \"Failed. Details: \" + JSON.stringify(data),\n      };\n    } else {\n      const data = await res.json();\n      return {\n        success: true,\n        response: data,\n      };\n    }\n  } catch (err) {\n    return {\n      success: false,\n      response:\n        \"Error fetching weather data2. Details: \" + (err as any).message,\n    };\n  }\n\n  //let response = await fetch(...);\n}"
  },
  "fetchWeatherTommorowIOApi": {
    "name": "fetchWeatherTommorowIOApi",
    "slug": "TsFunction",
    "id": "gelsiqcshulycwtdryyiupmp",
    "description": "/** \n    Tomorrow IO offers:\n        - 500 calls / per day\n        - 25 calls / per hour\n        - 3 calls / per second\n\n\t\t- Time frame available for data with a free account is usually from \n\t\t- 6 hours in the past to 15 days in the future\n        \n*/",
    "operationName": "weather-sensor",
    "rawText": "\n/** \n    Tomorrow IO offers:\n        - 500 calls / per day\n        - 25 calls / per hour\n        - 3 calls / per second\n\n\t\t- Time frame available for data with a free account is usually from \n\t\t- 6 hours in the past to 15 days in the future\n        \n*/\nexport async function fetchWeatherTommorowIOApi(): Promise<{\n  success: boolean;\n  response?: string;\n  data?: any;\n}> {\n  try {\n    const getTimelineURL = \"https://api.tomorrow.io/v4/timelines\";\n\n    // get your key from app.tomorrow.io/development/keys\n    const apikey = \"qjsw09GnUPuP1Ychu13ISEyaTcdA9PO5\";\n\n    // pick the location, as a latlong pair\n    let location = [-10.34194, -39.15943];\n\n    // list the fields\n    const fields = [\n      \"precipitationIntensity\",\n      \"precipitationType\",\n      \"precipitationProbability\",\n      \"windSpeed\",\n      \"windGust\",\n      \"windDirection\",\n      \"temperature\",\n      \"temperatureApparent\",\n      \"cloudCover\",\n      \"cloudBase\",\n      \"cloudCeiling\",\n      \"dewPoint\",\n      \"humidity\",\n      \"pressureSurfaceLevel\",\n      \"pressureSeaLevel\",\n      \"rainIntensity\",\n      \"rainAccumulation\",\n      \"freezingRainIntensity\",\n      \"snowIntensity\",\n      \"snowAccumulation\",\n      \"snowAccumulationLwe\",\n      \"sleetIntensity\",\n      \"sleetAccumulation\",\n      \"sleetAccumulationLwe\",\n      \"iceAccumulation\",\n      \"iceAccumulationLwe\",\n      \"sunriseTime\",\n      \"sunsetTime\",\n      \"visibility\",\n      \"moonPhase\",\n      \"uvIndex\",\n      \"uvHealthConcern\",\n      \"weatherCode\",\n    ];\n\n    // choose the unit system, either metric or imperial\n    const units = \"imperial\";\n\n    // set the timesteps, like \"current\", \"1h\" and \"1d\"\n    const timesteps = [\"current\", \"1h\", \"1d\"];\n\n    // configure the time frame up to 6 hours back and 15 days out\n    const now = moment.utc();\n    const startTime = moment.utc(now).add(0, \"minutes\").toISOString();\n    const endTime = moment.utc(now).add(1, \"days\").toISOString();\n\n    // specify the timezone, using standard IANA timezone format\n    const timezone = \"America/New_York\";\n\n    // request the timelines with all the query string parameters as options\n    const getTimelineParameters = queryString.stringify(\n      {\n        apikey,\n        location,\n        fields,\n        units,\n        timesteps,\n        startTime,\n        endTime,\n        timezone,\n      },\n      { arrayFormat: \"comma\" }\n    );\n    const url = getTimelineURL + \"?\" + getTimelineParameters;\n    console.log(\"this is the full request url: \" + url);\n    const res = await fetch(url);\n    if (!res.ok) {\n      const data = await res.json();\n      return {\n        success: false,\n        response: \"Failed. Details: \" + JSON.stringify(data),\n      };\n    } else {\n      const data = await res.json();\n      return {\n        success: true,\n        response: JSON.stringify(data, null, 2),\n      };\n    }\n  } catch (err) {\n    return {\n      success: false,\n      response:\n        \"Error fetching weather data2. Details: \" + (err as any).message,\n    };\n  }\n\n  //let response = await fetch(...);\n}"
  },
  "getCustomWeatherData": {
    "name": "getCustomWeatherData",
    "slug": "TsFunction",
    "id": "uzrmwziczgusbouwcvivpztv",
    "description": "",
    "operationName": "weather-sensor",
    "rawText": "\n\nexport async function getCustomWeatherData(): Promise<{\n  success: boolean;\n  response?: string;\n  data?: any;\n}> {\n  const { success: successTomorrowApi, response: responseTomorrowApi } =\n    await fetchWeatherTommorowIOApi();\n  console.log(\"fetch tomorrow api success or not: \" + successTomorrowApi);\n  if (successTomorrowApi && responseTomorrowApi) {\n    const parsed = JSON.parse(responseTomorrowApi);\n\n    const timelines = parsed.data.timelines;\n\n    const intervals = timelines.find(\n      (timeline: any) => timeline.timestep === \"1h\"\n    ).intervals;\n\n    if (intervals) {\n      const {\n        cloudBase,\n        cloudCeiling,\n        cloudCover,\n        dewPoint,\n        freezingRainIntensity,\n        humidity,\n        iceAccumulation,\n        iceAccumulationLwe,\n        moonPhase,\n        precipitationIntensity,\n        precipitationProbability,\n        precipitationType,\n        pressureSeaLevel,\n        pressureSurfaceLevel,\n        rainAccumulation,\n        rainIntensity,\n        sleetAccumulation,\n        sleetAccumulationLwe,\n        sleetIntensity,\n        snowAccumulation,\n        snowAccumulationLwe,\n        snowIntensity,\n        sunriseTime,\n        sunsetTime,\n        temperature,\n        temperatureApparent,\n        uvHealthConcern,\n        uvIndex,\n        visibility,\n        weatherCode,\n        windDirection,\n        windGust,\n        windSpeed,\n      } = intervals[intervals.length - 1].values;\n\n      //starting time the measurement was made\n      const startTime = intervals[intervals.length - 1].startTime;\n      const windyness = calculateWindyness(windSpeed);\n      const rainyness = calculateRainyness(precipitationIntensity);\n      const cloudyness = calculateCloudyness(cloudCover);\n      const sunnyness = calculateSunnyness(\n        cloudCover,\n        startTime,\n        sunsetTime,\n        sunriseTime\n      );\n      const feelingTemperature = temperatureApparent;\n      const kiteability = calculateKiteability(\n        windSpeed,\n        precipitationIntensity\n      );\n      const dresscode = calculateDresscode(temperatureApparent);\n      const codeFromNatureAbility = calculateCodeFromNatureAbility(\n        cloudCover,\n        precipitationIntensity\n      );\n      const bbqAbility = calculateBbqAbility(\n        temperatureApparent,\n        precipitationIntensity,\n        windSpeed\n      );\n\n      return {\n        success: true,\n        response: \"fetch successful.\",\n        data: {\n          windyness,\n          rainyness,\n          cloudyness,\n          sunnyness,\n          feelingTemperature,\n          kiteability,\n          dresscode,\n          codeFromNatureAbility,\n          bbqAbility,\n        },\n      };\n    }\n    return {\n      success: false,\n      response: \"Did not find intervals\",\n    };\n  } else {\n    return {\n      success: false,\n      response: \"Failed fetching\",\n    };\n  }\n}"
  },
  "generatePassword": {
    "name": "generatePassword",
    "slug": "TsFunction",
    "id": "teisreouhbzxlvlcurvyerpp",
    "description": "/**\n * generates a password. By default, uses a length of 14\n */",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * generates a password. By default, uses a length of 14\n */\nexport function generatePassword(passwordLength: number = 14) {\n  return generateRandomString(passwordLength);\n}"
  },
  "isEmail": {
    "name": "isEmail",
    "slug": "TsFunction",
    "id": "wlxutvdxbwsdbnfhycqlarno",
    "description": "",
    "operationName": "model-types",
    "rawText": "\n\nexport function isEmail(email: string) {\n  var re =\n    /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n  return re.test(String(email).toLowerCase());\n}"
  },
  "getTypescriptErrorsFromFiles": {
    "name": "getTypescriptErrorsFromFiles",
    "slug": "TsFunction",
    "id": "larmjwdmppkfcwkrqnzgebij",
    "description": "/**\n * uses official typescript compiler to check all given files for compilation errors\n */",
    "operationName": "compile-typescript",
    "rawText": "\n\n/**\n * uses official typescript compiler to check all given files for compilation errors\n */\nexport function getTypescriptErrorsFromFiles({\n  filePaths,\n  debug,\n}: {\n  basePath: string;\n  filePaths: string[];\n  compilerOptions: TsConfig[\"compilerOptions\"];\n  packageJson: PackageJson;\n  debug?: boolean;\n}): Creation<TsBuildError>[] {\n  try {\n    const program = typescript.createProgram(filePaths, {});\n    const emitResult = program.emit(undefined, (fileName) => {\n      if (debug) console.log(`emitted ${fileName}, not writing.`);\n    });\n\n    const allDiagnostics = typescript\n      .getPreEmitDiagnostics(program)\n      .concat(emitResult.diagnostics);\n\n    const buildErrors = allDiagnostics\n      .map((diagnostic) => {\n        let buildError: null | Creation<TsBuildError> = null;\n\n        // TODO: Fix this! Obviously this isn't correct\n        const filePath = filePaths[0];\n\n        const operationBasePath = findOperationBasePath(filePath);\n        if (!operationBasePath) return;\n\n        const operationPathParse = getOperationPathParse(filePath);\n        if (!operationPathParse) return;\n\n        const operationName = getLastFolder(operationBasePath);\n        const operationRelativeTypescriptFilePath =\n          operationPathParse.operationRelativeTypescriptFilePath;\n\n        if (diagnostic.file && diagnostic.start) {\n          const { line, character } = typescript.getLineAndCharacterOfPosition(\n            diagnostic.file,\n            diagnostic.start\n          );\n          const message = typescript.flattenDiagnosticMessageText(\n            diagnostic.messageText,\n            \"\\n\"\n          );\n\n          buildError = {\n            message,\n            operationName,\n            operationRelativeTypescriptFilePath,\n            line: line + 1,\n            character: character + 1,\n            id: generateId(),\n            // TODO: later I can give this the name of the error maybe\n            name: \"TsBuildError\",\n            slug: \"ts-build-error\",\n          };\n          // console.log(\n          //   `${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`\n          // );\n        } else {\n          const message = typescript.flattenDiagnosticMessageText(\n            diagnostic.messageText,\n            \"\\n\"\n          );\n          buildError = {\n            id: generateId(),\n            message,\n            // TODO: later I can give this the name of the error maybe\n            name: \"TsBuildError\",\n            slug: \"ts-build-error\",\n            operationRelativeTypescriptFilePath:\n              operationPathParse.operationRelativeTypescriptFilePath,\n          };\n        }\n\n        return buildError;\n      })\n      .filter(notEmpty);\n\n    return buildErrors;\n  } catch (e) {\n    log(`WTF raar ${e}`, { type: \"error\" });\n    return [];\n  }\n}"
  },
  "handleExplicitValidation": {
    "name": "handleExplicitValidation",
    "slug": "TsFunction",
    "id": "uzbqyviqpbyfauyzbuxnaekc",
    "description": "",
    "operationName": "index-typescript",
    "rawText": "\n\nfunction handleExplicitValidation(\n  type: string,\n  schema: any,\n  decorators: Decorator[] = []\n): SimpleJsonSchema {\n  decorators.forEach((d) => {\n    const dName = d.getName();\n    switch (dName) {\n      case \"min\":\n      case \"max\": {\n        const firstArgumentTextNumber = +d.getArguments()[0].getText();\n        schema = merge(\n          schema,\n          getMinMaxValidation(dName, type, firstArgumentTextNumber)\n        );\n        break;\n      }\n      case \"time\":\n      case \"date\":\n      case \"dateTime\":\n      case \"duration\":\n      case \"uri\":\n      case \"uriReference\":\n      case \"uriTemplate\":\n      case \"email\":\n      case \"hostname\":\n      case \"ipv4\":\n      case \"ipv6\":\n      case \"uuid\":\n      case \"jsonPointer\":\n      case \"relativeJsonPointer\": {\n        schema = merge(schema, { format: toSnack(dName) });\n        break;\n      }\n    }\n  });\n  return schema;\n}"
  },
  "hasDefinition": {
    "name": "hasDefinition",
    "slug": "TsFunction",
    "id": "vbvbzadupfoxrqzgbdrukxhf",
    "description": "",
    "operationName": "index-typescript",
    "rawText": "\n\nexport function hasDefinition(\n  maybeInterface: MaybeInteface\n): maybeInterface is TsInterface {\n  return maybeInterface.type.typeDefinition !== null;\n}"
  },
  "useOnScreen": {
    "name": "useOnScreen",
    "slug": "TsFunction",
    "id": "kztgthtfkhtxmlphfssxugor",
    "description": "/**\n * checks wheter or not a certain element is in the browsers screen view, or not.\n */",
    "operationName": "use-on-screen",
    "rawText": "\n\n/**\n * checks wheter or not a certain element is in the browsers screen view, or not.\n */\nexport function useOnScreen(ref: RefObject<HTMLDivElement>) {\n  const [isIntersecting, setIntersecting] = useState(false);\n\n  const observer =\n    typeof window === \"undefined\"\n      ? null\n      : new IntersectionObserver(([entry]) =>\n          setIntersecting(entry.isIntersecting)\n        );\n\n  useEffect(() => {\n    if (observer) {\n      if (ref.current) {\n        observer?.observe(ref.current);\n      }\n      // Remove the observer as soon as the component is unmounted\n      return () => {\n        observer?.disconnect();\n      };\n    }\n  }, [observer]);\n\n  return isIntersecting;\n}"
  },
  "isObject": {
    "name": "isObject",
    "slug": "TsFunction",
    "id": "iqieemkdxutcmpdnvhvxrdxf",
    "description": "",
    "operationName": "react-with-native-form",
    "rawText": "\n\nexport function isObject(object: any): object is object {\n  return object != null && typeof object === \"object\";\n}"
  },
  "notEmpty": {
    "name": "notEmpty",
    "slug": "TsFunction",
    "id": "cjghvlrunmabcboogcssiyic",
    "description": "/**\n * Removes empty values (null or undefined) from your arrays in a type-safe way\n */",
    "operationName": "js-util",
    "rawText": "\n\n/**\n * Removes empty values (null or undefined) from your arrays in a type-safe way\n */\nexport function notEmpty<TValue>(\n  value: TValue | null | undefined\n): value is TValue {\n  return value !== null && value !== undefined;\n}"
  },
  "Modal": {
    "name": "Modal",
    "slug": "TsFunction",
    "id": "jzcggvxkjsxpdlwipygaiibg",
    "description": "",
    "operationName": "react-with-native-modal",
    "rawText": "\n\nexport function Modal() {\n  const [inside, setInside] = useState(false);\n  let { modalContent, title, handleModal, showModal } =\n    useContext(ModalContext);\n\n  if (showModal) {\n    return (\n      <>\n        <Div\n          onClick={() => !inside && handleModal(null)}\n          className=\"fixed inset-0 z-50 flex items-center justify-center overflow-x-hidden overflow-y-auto outline-none focus:outline-none\"\n        >\n          <Div\n            onMouseEnter={() => setInside(true)}\n            onMouseLeave={() => setInside(false)}\n            className=\"relative w-auto max-w-3xl mx-auto my-6 lg:w-10/12 lg:h-10/12\"\n          >\n            {/*content*/}\n            <Div className=\"relative flex flex-col w-full bg-white border-0 rounded-lg shadow-lg outline-none focus:outline-none\">\n              {/*header*/}\n              <Div className=\"flex items-start justify-between p-5 border-b border-gray-200 border-solid rounded-t\">\n                <h3 className=\"text-3xl font-semibold\">{title}</h3>\n                <Button\n                  className=\"float-right p-1 ml-auto text-3xl font-semibold leading-none text-black bg-transparent border-0 outline-none opacity-5 focus:outline-none\"\n                  onClick={() => handleModal(null)}\n                >\n                  <span className=\"block w-6 h-6 text-2xl text-black bg-transparent outline-none opacity-5 focus:outline-none\">\n                    x\n                  </span>\n                </Button>\n              </Div>\n              {/*body*/}\n              <Div className=\"relative flex-auto p-6\">\n                <p className=\"my-4 text-lg leading-relaxed text-gray-500\">\n                  {modalContent}\n                </p>\n              </Div>\n              {/*footer*/}\n              <Div className=\"flex items-center justify-end p-6 border-t border-gray-200 border-solid\">\n                <Button\n                  className=\"px-6 py-2 mb-1 mr-1 text-sm font-bold text-red-500 uppercase transition-all duration-150 ease-linear outline-none background-transparent focus:outline-none\"\n                  onClick={() => handleModal(null)}\n                >\n                  Close...\n                </Button>\n              </Div>\n            </Div>\n          </Div>\n        </Div>\n        <Div className=\"fixed inset-0 z-40 bg-black opacity-50\"></Div>\n      </>\n    );\n  } else return null;\n}"
  },
  "useNavigation": {
    "name": "useNavigation",
    "slug": "TsFunction",
    "id": "bbiexasrpyjlznzepbxnpbka",
    "description": "",
    "operationName": "react-with-native-router",
    "rawText": "\n\nexport function useNavigation() {\n  const router = useRouter();\n\n  return {\n    addListener: () => {},\n    canGoBack: () => true,\n    dispatch: () => {},\n    getParent: () => {},\n    getState: () => {},\n    goBack: () => {\n      router.back();\n    },\n    isFocused: () => {},\n    removeListener: () => {},\n    reset: () => {},\n    setOptions: () => {},\n    setParams: () => {},\n\n    navigate: (screen: string, params?: { [key: string]: any }) => {\n      router.push(screen, { query: params });\n    },\n  };\n}"
  },
  "useIsInViewport": {
    "name": "useIsInViewport",
    "slug": "TsFunction",
    "id": "ygsrgobijsqkwcgdhugpaoqy",
    "description": "",
    "operationName": "react-with-native-table",
    "rawText": "\n\nexport function useIsInViewport(ref: React.MutableRefObject<Element | null>) {\n  const [isIntersecting, setIsIntersecting] = useState(false);\n\n  const observer = useMemo(\n    () =>\n      new IntersectionObserver(([entry]) =>\n        setIsIntersecting(entry.isIntersecting)\n      ),\n    []\n  );\n\n  useEffect(() => {\n    if (!ref.current) return;\n\n    observer.observe(ref.current);\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [ref, observer]);\n\n  return isIntersecting;\n}"
  },
  "slugify": {
    "name": "slugify",
    "slug": "TsFunction",
    "id": "kbwsujsyploqhlvyzrnwakqt",
    "description": "/**\n * this function does the same as kebabCase but it also does some more transformation on top\n *\n * useful for making simple URLs and filenames. Kebacase is not enough\n *\n * NB: this is no two way transformation. When slugifying something, information is lost and it cannot be converted back in the original name.\n *\n * TODO: make the tranformations that are done here into smaller util functions and make a clean function that can be ran before running every casing conversion (maybe in a config)\n */",
    "operationName": "convert-case",
    "rawText": "/**\n * this function does the same as kebabCase but it also does some more transformation on top\n *\n * useful for making simple URLs and filenames. Kebacase is not enough\n *\n * NB: this is no two way transformation. When slugifying something, information is lost and it cannot be converted back in the original name.\n *\n * TODO: make the tranformations that are done here into smaller util functions and make a clean function that can be ran before running every casing conversion (maybe in a config)\n */\nexport function slugify(string: string) {\n  const a =\n    \"Ã Ã¡Ã¢Ã¤Ã¦Ã£Ã¥ÄÄƒÄ…Ã§Ä‡ÄÄ‘ÄÃ¨Ã©ÃªÃ«Ä“Ä—Ä™Ä›ÄŸÇµá¸§Ã®Ã¯Ã­Ä«Ä¯Ã¬Ä±Ä°Å‚á¸¿Ã±Å„Ç¹ÅˆÃ´Ã¶Ã²Ã³Å“Ã¸ÅÃµÅ‘á¹•Å•Å™ÃŸÅ›Å¡ÅŸÈ™Å¥È›Ã»Ã¼Ã¹ÃºÅ«Ç˜Å¯Å±Å³áºƒáºÃ¿Ã½Å¾ÅºÅ¼Â·/_,:;\";\n  const b =\n    \"aaaaaaaaaacccddeeeeeeeegghiiiiiiiilmnnnnoooooooooprrsssssttuuuuuuuuuwxyyzzz------\";\n  const p = new RegExp(a.split(\"\").join(\"|\"), \"g\");\n\n  return string\n    .toString()\n    .toLowerCase()\n    .replace(/\\s+/g, \"-\") // Replace spaces with -\n    .replace(p, (c) => b.charAt(a.indexOf(c))) // Replace special characters\n    .replace(/&/g, \"-and-\") // Replace & with 'and'\n    .replace(/[^\\w\\-]+/g, \"\") // Remove all non-word characters\n    .replace(/\\-\\-+/g, \"-\") // Replace multiple - with single -\n    .replace(/^-+/, \"\") // Trim - from start of text\n    .replace(/-+$/, \"\"); // Trim - from end of text\n}"
  },
  "arrayGenerator": {
    "name": "arrayGenerator",
    "slug": "TsFunction",
    "id": "zfellhzkzpaawktiitrjjpqf",
    "description": "/**\n * NB: Do I really need this? Would be nice not to use generators.\n */",
    "operationName": "js-util",
    "rawText": "\n\n/**\n * NB: Do I really need this? Would be nice not to use generators.\n */\nfunction* arrayGenerator(array: any[]): ArrayGenerator {\n  for (let index = 0; index < array.length; index++) {\n    const currentValue = array[index];\n    const generatorTuple: [any, number, any[]] = [currentValue, index, array];\n    yield generatorTuple;\n  }\n}"
  },
  "onlyUnique": {
    "name": "onlyUnique",
    "slug": "TsFunction",
    "id": "ylyzvtzgnktnflgyujnrbsya",
    "description": "/**\n * DEPRECATED: should refactor everything to use onlyUnique2 and call it onlyUnique again\n *\n * to be used as a filter. removes duplicates\n */",
    "operationName": "js-util",
    "rawText": "\n\n/**\n * DEPRECATED: should refactor everything to use onlyUnique2 and call it onlyUnique again\n *\n * to be used as a filter. removes duplicates\n */\nexport function onlyUnique<T extends unknown>(\n  value: T,\n  index: number,\n  self: T[]\n) {\n  return self.findIndex((v) => v === value) === index;\n}"
  },
  "worker": {
    "name": "worker",
    "slug": "TsFunction",
    "id": "ktpjoxkpdbviytmbjjfbbbxj",
    "description": "",
    "operationName": "js-util",
    "rawText": "\n\nasync function worker(\n  id: number,\n  generator: ArrayGenerator,\n  mapFn: MapFn<any, any>,\n  result: any[]\n) {\n  //console.time(`Worker ${id}`);\n  for (let [currentValue, index, array] of generator) {\n    //console.time(`Worker ${id} --- index ${index} item ${currentValue}`);\n\n    const mappedResult = await mapItem(mapFn, currentValue, index, array);\n\n    // NB: if mappedResult gets rejected, change nothing!\n    if (mappedResult.status === \"fulfilled\") {\n      result[index] = mappedResult.value;\n    }\n\n    //console.timeEnd(`Worker ${id} --- index ${index} item ${currentValue}`);\n  }\n  //console.timeEnd(`Worker ${id}`);\n}"
  },
  "earthDistance": {
    "name": "earthDistance",
    "slug": "TsFunction",
    "id": "nakuvqaawznxtrfcikivuemk",
    "description": "/**\n * returns the distance between two places (not very precise but it's very efficient)\n */",
    "operationName": "himalayajeep-functions",
    "rawText": "/**\n * returns the distance between two places (not very precise but it's very efficient)\n */\nexport function earthDistance(\n  lat1: number,\n  long1: number,\n  lat2: number,\n  long2: number,\n  response?: \"m\" | \"km\"\n) {\n  const m = Math.PI / 180;\n\n  lat1 = lat1 * m;\n  long1 = long1 * m;\n  lat2 = lat2 * m;\n  long2 = long2 * m;\n\n  var R = 6371e3; // metres of earth radius\n\n  var x = (long2 - long1) * Math.cos((lat1 + lat2) / 2);\n  var y = lat2 - lat1;\n\n  var d = Math.sqrt(x * x + y * y) * R;\n\n  return response === \"m\" ? Math.round(d / 10) * 10 : Math.round(d / 1000);\n}"
  },
  "getAverageCompanies": {
    "name": "getAverageCompanies",
    "slug": "TsFunction",
    "id": "imurmkihswxqemenlhtjgnrx",
    "description": "/** Calcualte the average contributions per product */",
    "operationName": "passionfruit-ui",
    "rawText": "\n\n/** Calcualte the average contributions per product */\nexport function getAverageCompanies(products: ProductValueChain[] | undefined) {\n  return products\n    ? products.reduce(\n        (prev: number, product: ProductValueChain) =>\n          prev +\n          (products\n            ? product?.companys.length\n              ? product?.companys.length\n              : 0\n            : 0),\n        0\n      ) / products.length\n    : 0;\n}"
  },
  "getAverageTransparency": {
    "name": "getAverageTransparency",
    "slug": "TsFunction",
    "id": "hcbqzmmingcusjtnglmakwyv",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": "\n\nexport function getAverageTransparency(companies: Company[] | undefined) {\n  return companies\n    ? companies.reduce(\n        (prev: number, company: Company) =>\n          prev +\n          (company.transparencyPercentageCalculated\n            ? company?.transparencyPercentageCalculated\n            : 0),\n        0\n      ) / companies.length\n    : null;\n}"
  },
  "getCompanyToDos": {
    "name": "getCompanyToDos",
    "slug": "TsFunction",
    "id": "sllbhtfcrefxcpkohwsokefb",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": "\n\nexport function getCompanyToDos(companies: Company[] | undefined) {\n  return companies\n    ? companies.reduce(\n        (prev: number, company: Company) =>\n          prev +\n          (company.transparencyDetailsCalculated.requirementScore\n            ? company?.transparencyDetailsCalculated.requirementScore\n            : 0) *\n            100,\n        0\n      ) / companies.length\n    : null;\n}"
  },
  "getCompanyTransparency": {
    "name": "getCompanyTransparency",
    "slug": "TsFunction",
    "id": "qbwjhxaipimjeirpxgnreiej",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": "\n\nexport function getCompanyTransparency(companies: Company[] | undefined) {\n  return companies\n    ? companies.reduce(\n        (prev: number, company: Company) =>\n          prev +\n          (company.transparencyDetailsCalculated.formScore\n            ? company?.transparencyDetailsCalculated.formScore\n            : 0) *\n            100,\n        0\n      ) / companies.length\n    : null;\n}"
  },
  "getMappedProducts": {
    "name": "getMappedProducts",
    "slug": "TsFunction",
    "id": "xwxvirmedsewyzphbffshfcw",
    "description": "/** Count the amount of products that have more than 4 value chains steps */",
    "operationName": "passionfruit-ui",
    "rawText": "\n\n/** Count the amount of products that have more than 4 value chains steps */\nexport function getMappedProducts(products: ProductValueChain[] | undefined) {\n  return products\n    ? products?.reduce(\n        (prev: number, product: ProductValueChain) =>\n          prev + (product.valueChainPhases.length >= 4 || 0 ? 1 : 0),\n        0\n      )\n    : 0;\n}"
  },
  "getValueChainlength": {
    "name": "getValueChainlength",
    "slug": "TsFunction",
    "id": "wikggrgwbgvrtguacvkkylie",
    "description": "/** Count the average value chain length per product */",
    "operationName": "passionfruit-ui",
    "rawText": "\n\n/** Count the average value chain length per product */\nexport function getValueChainlength(products: ProductValueChain[] | undefined) {\n  return products\n    ? products.reduce(\n        (prev: number, product: ProductValueChain) =>\n          prev + (products ? product.valueChainPhases.length : 0),\n        0\n      ) / products.length\n    : 0;\n}"
  },
  "renderEsgMetrics": {
    "name": "renderEsgMetrics",
    "slug": "TsFunction",
    "id": "crczetrdzxgasmyjbsjlxssf",
    "description": "",
    "operationName": "passionfruit-ui",
    "rawText": "\nexport function renderEsgMetrics(props: ESGMetricType) {\n  const { data, type } = props;\n  const metrics = data?.map((x) =>\n    x.companyEsgMetricProofStatesCalculated?.filter(\n      (x) => x.categoryStack[0] === type\n    )\n  );\n\n  const totalNotAssessed =\n    metrics\n      ?.map(\n        (esgMetric) =>\n          esgMetric?.flatMap((x) => x.notAssessedProofsCalculated)?.length || 0\n      )\n      .reduce((previous, current) => previous + current, 0) || 0;\n\n  const totalPositive =\n    metrics\n      ?.map(\n        (esgMetric) =>\n          esgMetric?.flatMap((x) => x.positiveProofsCalculated)?.length || 0\n      )\n      .reduce((previous, current) => previous + current, 0) || 0;\n\n  const totalNegative =\n    metrics\n      ?.map(\n        (esgMetric) =>\n          esgMetric?.flatMap((x) => x.positiveProofsCalculated).length || 0\n      )\n      .reduce((previous, current) => previous + current, 0) || 0;\n\n  return { totalNotAssessed, totalPositive, totalNegative };\n}"
  },
  "charIsLetter": {
    "name": "charIsLetter",
    "slug": "TsFunction",
    "id": "ngcdidbntcxlkwqarwffxdwe",
    "description": "",
    "operationName": "parse-address-henrik",
    "rawText": "\n\nfunction charIsLetter(char: string) {\n  if (typeof char !== \"string\") {\n    return false;\n  }\n\n  return char.toLowerCase() !== char.toUpperCase();\n}"
  },
  "ai-browser": {
    "name": "ai-browser",
    "slug": "Operation",
    "operationName": "ai-browser"
  },
  "ai-demo-web": {
    "name": "ai-demo-web",
    "slug": "Operation",
    "id": "mjqcvwezujatdjrogfyryqac",
    "operationName": "ai-demo-web"
  },
  "ai-functions-node": {
    "name": "ai-functions-node",
    "slug": "Operation",
    "id": "rwvbjpqgulkhwdsourbfwwye",
    "operationName": "ai-functions-node"
  },
  "ai-types": {
    "name": "ai-types",
    "slug": "Operation",
    "id": "rzgsitofuukkatcuriaoazvg",
    "operationName": "ai-types"
  },
  "generative-functions-node": {
    "name": "generative-functions-node",
    "slug": "Operation",
    "id": "eatosihbotjdxslswtdiybvq",
    "operationName": "generative-functions-node"
  },
  "generative-ui": {
    "name": "generative-ui",
    "slug": "Operation",
    "id": "kfsjdkljfklsjklfdsjkflsdj",
    "operationName": "generative-ui"
  },
  "generative-web": {
    "name": "generative-web",
    "slug": "Operation",
    "id": "moysshxfxsmwyftybcshjufe",
    "operationName": "generative-web"
  },
  "gptideas-web": {
    "name": "gptideas-web",
    "slug": "Operation",
    "id": "moysshxfxsmwyftybcshjufe",
    "operationName": "gptideas-web"
  },
  "prompt-components": {
    "name": "prompt-components",
    "slug": "Operation",
    "id": "vqykiaraonhamykiyozkjhsx",
    "operationName": "prompt-components"
  },
  "queue-types": {
    "name": "queue-types",
    "slug": "Operation",
    "operationName": "queue-types"
  },
  "asset-demo-web": {
    "name": "asset-demo-web",
    "slug": "Operation",
    "id": "okvozztcuhbljcbovfsjvnav",
    "operationName": "asset-demo-web"
  },
  "asset-functions-js": {
    "name": "asset-functions-js",
    "slug": "Operation",
    "id": "pytnclcnhwrwajqwucxoadrl",
    "operationName": "asset-functions-js"
  },
  "asset-functions-node": {
    "name": "asset-functions-node",
    "slug": "Operation",
    "id": "HEMfUzpVNjsHgvYv",
    "operationName": "asset-functions-node"
  },
  "asset-input": {
    "name": "asset-input",
    "slug": "Operation",
    "id": "oMLGSgwZucEahFtW",
    "operationName": "asset-input"
  },
  "asset-type": {
    "name": "asset-type",
    "slug": "Operation",
    "id": "oLDXQDgzLzmvRLWs",
    "description": "",
    "operationName": "asset-type"
  },
  "asset-view": {
    "name": "asset-view",
    "slug": "Operation",
    "id": "yiqycykmfrkrufuhrdysvyzu",
    "operationName": "asset-view"
  },
  "text-or-binary": {
    "name": "text-or-binary",
    "slug": "Operation",
    "id": "hoxluuxxijqxnzlkiabobody",
    "operationName": "text-or-binary"
  },
  "folder-get-updated-at": {
    "name": "folder-get-updated-at",
    "slug": "Operation",
    "id": "kREgIzDSkHtqybGG",
    "operationName": "folder-get-updated-at"
  },
  "fs-util": {
    "name": "fs-util",
    "slug": "Operation",
    "id": "IPFeFRXDRUiclwih",
    "description": "",
    "operationName": "fs-util"
  },
  "fs-util-js": {
    "name": "fs-util-js",
    "slug": "Operation",
    "id": "wtywoiemkrpenkgcxyzophmp",
    "operationName": "fs-util-js"
  },
  "get-associated-md": {
    "name": "get-associated-md",
    "slug": "Operation",
    "id": "mbPMpnRAFqutElrg",
    "operationName": "get-associated-md"
  },
  "get-available-folder-path": {
    "name": "get-available-folder-path",
    "slug": "Operation",
    "id": "mHNmHKCDaJvwzhlA",
    "operationName": "get-available-folder-path"
  },
  "get-package-json": {
    "name": "get-package-json",
    "slug": "Operation",
    "id": "pbuegxIIACKiiLjl",
    "operationName": "get-package-json"
  },
  "get-package-source-paths": {
    "name": "get-package-source-paths",
    "slug": "Operation",
    "id": "nkRNpxpdpuOQaEui",
    "operationName": "get-package-source-paths"
  },
  "get-ts-config": {
    "name": "get-ts-config",
    "slug": "Operation",
    "id": "KDQDhuKmgVOmWJmD",
    "operationName": "get-ts-config"
  },
  "path-util": {
    "name": "path-util",
    "slug": "Operation",
    "id": "QeSbBbHgeEbynPXh",
    "operationName": "path-util"
  },
  "rename-template-files": {
    "name": "rename-template-files",
    "slug": "Operation",
    "id": "FZFoOSVaQSECmexN",
    "operationName": "rename-template-files"
  },
  "set-json-key": {
    "name": "set-json-key",
    "slug": "Operation",
    "id": "FoMhQoDjGoMeIfOD",
    "description": "Update a JSON using the CLI",
    "operationName": "set-json-key"
  },
  "watch-folders": {
    "name": "watch-folders",
    "slug": "Operation",
    "id": "RGfqpcRRDJboWKFJ",
    "operationName": "watch-folders"
  },
  "write-to-assets": {
    "name": "write-to-assets",
    "slug": "Operation",
    "id": "znfCBjyUQumbKlRe",
    "operationName": "write-to-assets"
  },
  "all": {
    "name": "all",
    "slug": "Operation",
    "id": "iKazVukMuqrUgIBQ",
    "operationName": "all"
  },
  "make-file-type": {
    "name": "make-file-type",
    "slug": "Operation",
    "id": "xiEEhmhKrjFXlAPd",
    "operationName": "make-file-type"
  },
  "explore-project": {
    "name": "explore-project",
    "slug": "Operation",
    "id": "XjzbnkYOuSNFZWzl",
    "operationName": "explore-project"
  },
  "get-all-operation-source-paths": {
    "name": "get-all-operation-source-paths",
    "slug": "Operation",
    "id": "WSDeMsLYIktDGsCu",
    "operationName": "get-all-operation-source-paths"
  },
  "get-path": {
    "name": "get-path",
    "slug": "Operation",
    "id": "dryPyPWnCUmLjarA",
    "operationName": "get-path"
  },
  "k-explore": {
    "name": "k-explore",
    "slug": "Operation",
    "id": "CjtxcuPobvSETpNJ",
    "description": "",
    "operationName": "k-explore"
  },
  "operation-util": {
    "name": "operation-util",
    "slug": "Operation",
    "id": "ijohgpnKYOINMKGK",
    "operationName": "operation-util"
  },
  "pm2-util": {
    "name": "pm2-util",
    "slug": "Operation",
    "id": "zxFlNEXoXXPZaswv",
    "operationName": "pm2-util"
  },
  "testtest": {
    "name": "testtest",
    "slug": "Operation",
    "id": "xowhycesiveytlrckmuqovmq",
    "operationName": "testtest"
  },
  "watch-all": {
    "name": "watch-all",
    "slug": "Operation",
    "id": "wdrlkzjoriemaynaejxldjgd",
    "operationName": "watch-all"
  },
  "watch-operations": {
    "name": "watch-operations",
    "slug": "Operation",
    "id": "WXrwkTFdfBDyGtaH",
    "operationName": "watch-operations"
  },
  "watch-types": {
    "name": "watch-types",
    "slug": "Operation",
    "id": "fqainblkfoklcbftrwkdgvtm",
    "operationName": "watch-types"
  },
  "brightness": {
    "name": "brightness",
    "slug": "Operation",
    "id": "SLGnGDgOlDkwNbKj",
    "operationName": "brightness"
  },
  "clean-macos-setup": {
    "name": "clean-macos-setup",
    "slug": "Operation",
    "id": "mZucCCxCzOBqBSwZ",
    "operationName": "clean-macos-setup"
  },
  "file-explorer-open": {
    "name": "file-explorer-open",
    "slug": "Operation",
    "id": "hotfxksjiugdbklpfenmlcyq",
    "operationName": "file-explorer-open"
  },
  "play-music": {
    "name": "play-music",
    "slug": "Operation",
    "id": "ToYmAfJJvRPrDFWt",
    "operationName": "play-music"
  },
  "reminders": {
    "name": "reminders",
    "slug": "Operation",
    "id": "SmmUjMssrxRfvhcf",
    "operationName": "reminders"
  },
  "set-random-timezone": {
    "name": "set-random-timezone",
    "slug": "Operation",
    "id": "FTlejYPcXZYGYwpZ",
    "operationName": "set-random-timezone"
  },
  "toggle-dark-mode": {
    "name": "toggle-dark-mode",
    "slug": "Operation",
    "id": "aRQBCYvILtLLKkHA",
    "operationName": "toggle-dark-mode"
  },
  "toggle-screen-sleep": {
    "name": "toggle-screen-sleep",
    "slug": "Operation",
    "id": "tUjIQdSCiJoDNKtu",
    "operationName": "toggle-screen-sleep"
  },
  "volume": {
    "name": "volume",
    "slug": "Operation",
    "id": "GLpPIPYtyAHTocaK",
    "operationName": "volume"
  },
  "vscode-open": {
    "name": "vscode-open",
    "slug": "Operation",
    "id": "kMJHiijRTzoVZkmu",
    "operationName": "vscode-open"
  },
  "dev-to-controller": {
    "name": "dev-to-controller",
    "slug": "Operation",
    "id": "ppDumFqqXINCZYIQ",
    "operationName": "dev-to-controller"
  },
  "facebook-controller": {
    "name": "facebook-controller",
    "slug": "Operation",
    "id": "ewxgAfpdBjhJZACQ",
    "operationName": "facebook-controller"
  },
  "gif-controller": {
    "name": "gif-controller",
    "slug": "Operation",
    "id": "cmcczzXHPQwOcMXb",
    "operationName": "gif-controller"
  },
  "google-translate-controller": {
    "name": "google-translate-controller",
    "slug": "Operation",
    "id": "zAljPtcoJEfgIqVd",
    "description": "Translate texts or documents with Google Translate using Puppeteer",
    "operationName": "google-translate-controller"
  },
  "mail": {
    "name": "mail",
    "slug": "Operation",
    "id": "soofejieszawuyozxhlnvxae",
    "operationName": "mail"
  },
  "medium-controller": {
    "name": "medium-controller",
    "slug": "Operation",
    "id": "SFGqXMrMsztHJLpa",
    "operationName": "medium-controller"
  },
  "reddit-controller": {
    "name": "reddit-controller",
    "slug": "Operation",
    "id": "dwxasYtXyISsnKte",
    "operationName": "reddit-controller"
  },
  "sms": {
    "name": "sms",
    "slug": "Operation",
    "id": "ffbdkbtmgfrxvlldvgddegzq",
    "operationName": "sms"
  },
  "twitter-controller": {
    "name": "twitter-controller",
    "slug": "Operation",
    "id": "lGdXaVcfdDkJlGYv",
    "operationName": "twitter-controller"
  },
  "youtube-controller": {
    "name": "youtube-controller",
    "slug": "Operation",
    "id": "KWulkGNpJGIROEfe",
    "operationName": "youtube-controller"
  },
  "filename-conventions": {
    "name": "filename-conventions",
    "slug": "Operation",
    "id": "tqWQClwFnPpjYMtz",
    "operationName": "filename-conventions"
  },
  "get-port": {
    "name": "get-port",
    "slug": "Operation",
    "id": "junmqpwsxtgcermyhfxpmuyb",
    "operationName": "get-port"
  },
  "name-conventions": {
    "name": "name-conventions",
    "slug": "Operation",
    "id": "KYgjCfCEZaJqxGAZ",
    "operationName": "name-conventions"
  },
  "port-conventions": {
    "name": "port-conventions",
    "slug": "Operation",
    "id": "ibUKZMpiVNxJrzhg",
    "operationName": "port-conventions"
  },
  "bundle-util": {
    "name": "bundle-util",
    "slug": "Operation",
    "id": "sDuCZxdPfWnSMouU",
    "operationName": "bundle-util"
  },
  "create-backup": {
    "name": "create-backup",
    "slug": "Operation",
    "id": "dMmyVEOGmgjSaDst",
    "operationName": "create-backup"
  },
  "create-distribution": {
    "name": "create-distribution",
    "slug": "Operation",
    "id": "pDtZqqGpEPnYfixf",
    "operationName": "create-distribution"
  },
  "db-util": {
    "name": "db-util",
    "slug": "Operation",
    "id": "kIgLAmFgWErGaDrQ",
    "operationName": "db-util"
  },
  "generate-bundle": {
    "name": "generate-bundle",
    "slug": "Operation",
    "id": "XRKFCTTEUDnBhnje",
    "operationName": "generate-bundle"
  },
  "install-node-modules": {
    "name": "install-node-modules",
    "slug": "Operation",
    "id": "THIbueOzxztMKFxM",
    "operationName": "install-node-modules"
  },
  "yarn-install-new-distribution": {
    "name": "yarn-install-new-distribution",
    "slug": "Operation",
    "id": "OmTwlTopCLpzRDPg",
    "operationName": "yarn-install-new-distribution"
  },
  "deploy-project": {
    "name": "deploy-project",
    "slug": "Operation",
    "id": "kuxhhfgsbnkhzkmxhcqybutc",
    "operationName": "deploy-project"
  },
  "deployment-types": {
    "name": "deployment-types",
    "slug": "Operation",
    "id": "zbufobvhchhysmdgjkmvwhfw",
    "operationName": "deployment-types"
  },
  "linode-api-recipes": {
    "name": "linode-api-recipes",
    "slug": "Operation",
    "id": "rhuqwuxlziwkidguckgbqzvb",
    "operationName": "linode-api-recipes"
  },
  "namecheap-api-recipes": {
    "name": "namecheap-api-recipes",
    "slug": "Operation",
    "id": "cycxpdlvgmpxivpxxxbvcqpn",
    "operationName": "namecheap-api-recipes"
  },
  "server-deployment-recipes": {
    "name": "server-deployment-recipes",
    "slug": "Operation",
    "id": "mdvzvagmfspysnrqrpmwspdq",
    "operationName": "server-deployment-recipes"
  },
  "vercel-api-recipes": {
    "name": "vercel-api-recipes",
    "slug": "Operation",
    "id": "zuxnnhhukwjqbmeahmabpyry",
    "operationName": "vercel-api-recipes"
  },
  "sdk": {
    "name": "sdk",
    "slug": "Operation",
    "id": "bcspapggvaifsytrsczpxxew",
    "operationName": "sdk"
  },
  "sdk-api": {
    "name": "sdk-api",
    "slug": "Operation",
    "operationName": "sdk-api"
  },
  "sdk-api-keys": {
    "name": "sdk-api-keys",
    "slug": "Operation",
    "operationName": "sdk-api-keys"
  },
  "sdk-db": {
    "name": "sdk-db",
    "slug": "Operation",
    "description": "This operation is used to collect all typebase database models in the entire project, and export them, wrapped in a `DbModels` interface. This is needed for creating a function that can access the entire database (see `database` operation)\n",
    "operationName": "sdk-db"
  },
  "sdk-env-private": {
    "name": "sdk-env-private",
    "slug": "Operation",
    "id": "pzZOQajqnaYQAaHU",
    "description": "Any private environment variables of your full-stack app go here.",
    "operationName": "sdk-env-private"
  },
  "sdk-env-public": {
    "name": "sdk-env-public",
    "slug": "Operation",
    "id": "kzTMnVKpOOIOtApe",
    "description": "Any public environment variables of your full-stack app go here.",
    "operationName": "sdk-env-public"
  },
  "sdk-function-paths": {
    "name": "sdk-function-paths",
    "slug": "Operation",
    "operationName": "sdk-function-paths"
  },
  "sdk-interface-paths": {
    "name": "sdk-interface-paths",
    "slug": "Operation",
    "operationName": "sdk-interface-paths"
  },
  "sdk-js": {
    "name": "sdk-js",
    "slug": "Operation",
    "description": "operation that imports all `js` functions and variables in the entire project (OS or bundle) and exports an object that has all of them.\n\ncan be generated\n",
    "operationName": "sdk-js"
  },
  "sdk-operations": {
    "name": "sdk-operations",
    "slug": "Operation",
    "description": "Generated operation that exports an object that contains all names of all operations as keys, and all project relative paths to those operations as values.\n\nNeeded to find files more quickly in a more performant way.\n\nWhen moving operations around, ensure to regenerate this to avoid conflicts.\n",
    "operationName": "sdk-operations"
  },
  "sdk-ui": {
    "name": "sdk-ui",
    "slug": "Operation",
    "operationName": "sdk-ui"
  },
  "sdk-ui1": {
    "name": "sdk-ui1",
    "slug": "Operation",
    "operationName": "sdk-ui1"
  },
  "detect-language": {
    "name": "detect-language",
    "slug": "Operation",
    "id": "ebYfsGPcccnstOyQ",
    "operationName": "detect-language"
  },
  "generate-simple-sentence": {
    "name": "generate-simple-sentence",
    "slug": "Operation",
    "id": "kpanJrWmGAdUxYWE",
    "operationName": "generate-simple-sentence"
  },
  "learn-toki-web": {
    "name": "learn-toki-web",
    "slug": "Operation",
    "id": "aqxoyvvshinvvtyqqbikzsjm",
    "operationName": "learn-toki-web"
  },
  "markdown-translator": {
    "name": "markdown-translator",
    "slug": "Operation",
    "id": "tscybatxsdiijbswqbfwxuwx",
    "operationName": "markdown-translator"
  },
  "simplify-text": {
    "name": "simplify-text",
    "slug": "Operation",
    "id": "inoADsNuxZqIEJvE",
    "operationName": "simplify-text"
  },
  "speak-words-to-learn": {
    "name": "speak-words-to-learn",
    "slug": "Operation",
    "id": "TRtflaTfTyyeXzOn",
    "operationName": "speak-words-to-learn"
  },
  "payment-node": {
    "name": "payment-node",
    "slug": "Operation",
    "id": "dzshkqlcrnjcyondzxfwdynf",
    "operationName": "payment-node"
  },
  "payment-types": {
    "name": "payment-types",
    "slug": "Operation",
    "id": "ufzfnqnekmocuojvqheleods",
    "operationName": "payment-types"
  },
  "payment-web": {
    "name": "payment-web",
    "slug": "Operation",
    "id": "xxrwryadegfwvmzwekkrmajc",
    "operationName": "payment-web"
  },
  "edit-json-file": {
    "name": "edit-json-file",
    "slug": "Operation",
    "id": "uuclgmywjvtmhcfgjlbgmgix",
    "operationName": "edit-json-file"
  },
  "video-to-mp3": {
    "name": "video-to-mp3",
    "slug": "Operation",
    "id": "xvikdshuyhejyzjmvwxogeqh",
    "operationName": "video-to-mp3"
  },
  "csv-util": {
    "name": "csv-util",
    "slug": "Operation",
    "id": "iISehUGBHgtHVUce",
    "operationName": "csv-util"
  },
  "xls-to-csv-json": {
    "name": "xls-to-csv-json",
    "slug": "Operation",
    "id": "vpakcmugjtidmhndhdjswoqg",
    "operationName": "xls-to-csv-json"
  },
  "ffmpeg-util": {
    "name": "ffmpeg-util",
    "slug": "Operation",
    "id": "ahawlqtlqdfmfhkvnfcgmbph",
    "operationName": "ffmpeg-util"
  },
  "json-to-md": {
    "name": "json-to-md",
    "slug": "Operation",
    "id": "tFnXWBOmtYPlFcFD",
    "operationName": "json-to-md"
  },
  "json-to-say-string": {
    "name": "json-to-say-string",
    "slug": "Operation",
    "id": "hXcnFeZVYvVjDOFm",
    "operationName": "json-to-say-string"
  },
  "json-util": {
    "name": "json-util",
    "slug": "Operation",
    "id": "luPEMFyMIRGcjCYW",
    "operationName": "json-util"
  },
  "collect-static-assets": {
    "name": "collect-static-assets",
    "slug": "Operation",
    "id": "edprvcqxqoapkijitcbmgrpn",
    "operationName": "collect-static-assets"
  },
  "doc-to-md": {
    "name": "doc-to-md",
    "slug": "Operation",
    "id": "ixjiebnusmhbgcmhileonngk",
    "operationName": "doc-to-md"
  },
  "key-value-markdown-js": {
    "name": "key-value-markdown-js",
    "slug": "Operation",
    "id": "GKqeDzGAZNiBMdhR",
    "operationName": "key-value-markdown-js"
  },
  "make-codestory": {
    "name": "make-codestory",
    "slug": "Operation",
    "id": "fwszeynoqsiqirywndizvimt",
    "operationName": "make-codestory"
  },
  "markdown-parse-js": {
    "name": "markdown-parse-js",
    "slug": "Operation",
    "id": "MAgsnxSMgHQFmLwQ",
    "operationName": "markdown-parse-js"
  },
  "markdown-parsings": {
    "name": "markdown-parsings",
    "slug": "Operation",
    "id": "vMOVaTybLMZCbMxF",
    "operationName": "markdown-parsings"
  },
  "marked-util": {
    "name": "marked-util",
    "slug": "Operation",
    "id": "nwuyvleykklklazutgnonxys",
    "operationName": "marked-util"
  },
  "pdf-to-md": {
    "name": "pdf-to-md",
    "slug": "Operation",
    "id": "lltbtysvxgphvmjyrkwisgyz",
    "description": "",
    "operationName": "pdf-to-md"
  },
  "short-markdown-parser-js": {
    "name": "short-markdown-parser-js",
    "slug": "Operation",
    "id": "gzmufipbybdblxzlufntghdz",
    "operationName": "short-markdown-parser-js"
  },
  "short-markdown-parser-node": {
    "name": "short-markdown-parser-node",
    "slug": "Operation",
    "id": "yltrnbpxfsatfgydzudjkzxf",
    "operationName": "short-markdown-parser-node"
  },
  "short-markdown-studio-web": {
    "name": "short-markdown-studio-web",
    "slug": "Operation",
    "id": "xbqtwcmaqbhsmgwvexitjqes",
    "operationName": "short-markdown-studio-web"
  },
  "short-markdown-types": {
    "name": "short-markdown-types",
    "slug": "Operation",
    "id": "ehgqnctflsdulfxhffvfembg",
    "operationName": "short-markdown-types"
  },
  "parse-primitive": {
    "name": "parse-primitive",
    "slug": "Operation",
    "id": "WwNnCKBujPifBhZN",
    "operationName": "parse-primitive"
  },
  "read-csv-file": {
    "name": "read-csv-file",
    "slug": "Operation",
    "id": "ygAZcXXNqmgqODiC",
    "operationName": "read-csv-file"
  },
  "read-json-file": {
    "name": "read-json-file",
    "slug": "Operation",
    "id": "IGzRtGgKipiDNcid",
    "operationName": "read-json-file"
  },
  "read-kvmd-file": {
    "name": "read-kvmd-file",
    "slug": "Operation",
    "id": "DXHsjiFjXFmNVcPy",
    "operationName": "read-kvmd-file"
  },
  "read-markdown-file": {
    "name": "read-markdown-file",
    "slug": "Operation",
    "id": "tXARCsgZzVfslPOp",
    "operationName": "read-markdown-file"
  },
  "read-typescript-file": {
    "name": "read-typescript-file",
    "slug": "Operation",
    "id": "OyQKHnjNlITPxIpQ",
    "operationName": "read-typescript-file"
  },
  "try-parse-json": {
    "name": "try-parse-json",
    "slug": "Operation",
    "id": "hxwsvvtpdhydoltzegqiutdf",
    "operationName": "try-parse-json"
  },
  "rest-util": {
    "name": "rest-util",
    "slug": "Operation",
    "id": "cOeSLUvQqLDlgLLO",
    "operationName": "rest-util"
  },
  "database": {
    "name": "database",
    "slug": "Operation",
    "id": "zppfFLZGjSFDZIPj",
    "operationName": "database"
  },
  "db-recipes": {
    "name": "db-recipes",
    "slug": "Operation",
    "id": "dbWxqZljJGXXfdTi",
    "operationName": "db-recipes"
  },
  "db-web": {
    "name": "db-web",
    "slug": "Operation",
    "id": "vLetZlCpQpRtGyqz",
    "operationName": "db-web"
  },
  "fs-orm": {
    "name": "fs-orm",
    "slug": "Operation",
    "id": "KyZBnDkelitkjOpb",
    "description": "ORM that works with JSON and FS",
    "operationName": "fs-orm"
  },
  "validate-model": {
    "name": "validate-model",
    "slug": "Operation",
    "id": "jzzfwfsXWcJroHiM",
    "operationName": "validate-model"
  },
  "function-functions-node": {
    "name": "function-functions-node",
    "slug": "Operation",
    "id": "nwxdvcemhjxnshvyimslpusa",
    "operationName": "function-functions-node"
  },
  "function-types": {
    "name": "function-types",
    "slug": "Operation",
    "id": "ozvpmyyzqlomnozlvceebulr",
    "operationName": "function-types"
  },
  "function-web": {
    "name": "function-web",
    "slug": "Operation",
    "id": "dluazijjobvwhnkjzguldooi",
    "operationName": "function-web"
  },
  "project-size-web": {
    "name": "project-size-web",
    "slug": "Operation",
    "id": "lzvuhbvwfvjwutsceyuojorg",
    "operationName": "project-size-web"
  },
  "augmented-word-node": {
    "name": "augmented-word-node",
    "slug": "Operation",
    "id": "dcohqfmxjbbcsffijbgovdau",
    "operationName": "augmented-word-node"
  },
  "augmented-word-types": {
    "name": "augmented-word-types",
    "slug": "Operation",
    "id": "ndsyirxazfqtanmjjvedeohx",
    "operationName": "augmented-word-types"
  },
  "codestorys-node": {
    "name": "codestorys-node",
    "slug": "Operation",
    "id": "csdmeiggslgvtqzybrxcxaqy",
    "operationName": "codestorys-node"
  },
  "codestorys-web": {
    "name": "codestorys-web",
    "slug": "Operation",
    "id": "ulxdvwhgearuudloknysrfiz",
    "operationName": "codestorys-web"
  },
  "markdown-reader-functions": {
    "name": "markdown-reader-functions",
    "slug": "Operation",
    "id": "bollpwzntnlfggwaozdgzouh",
    "operationName": "markdown-reader-functions"
  },
  "markdown-reader-functions-js": {
    "name": "markdown-reader-functions-js",
    "slug": "Operation",
    "id": "jjtsjmhpxodqfzancabgcdwb",
    "operationName": "markdown-reader-functions-js"
  },
  "markdown-reader-types": {
    "name": "markdown-reader-types",
    "slug": "Operation",
    "id": "mmhddgzrootleqtfakivowbg",
    "operationName": "markdown-reader-types"
  },
  "markdown-reader-web": {
    "name": "markdown-reader-web",
    "slug": "Operation",
    "id": "oqRhxGziXSELxSxM",
    "operationName": "markdown-reader-web"
  },
  "next-types": {
    "name": "next-types",
    "slug": "Operation",
    "id": "mcvrsqtxyouxgtsvczlovvss",
    "operationName": "next-types"
  },
  "todo-types": {
    "name": "todo-types",
    "slug": "Operation",
    "id": "hcnakrerkamuzptdswbxscwz",
    "operationName": "todo-types"
  },
  "todo-web": {
    "name": "todo-web",
    "slug": "Operation",
    "id": "mykoqlebootgziemsvfbewtu",
    "operationName": "todo-web"
  },
  "auth-types": {
    "name": "auth-types",
    "slug": "Operation",
    "id": "fpjrnpgbsnvwcxtvlhacwfli",
    "operationName": "auth-types"
  },
  "peer-functions": {
    "name": "peer-functions",
    "slug": "Operation",
    "id": "STZJGyqPOGISGkCo",
    "operationName": "peer-functions"
  },
  "peer-types": {
    "name": "peer-types",
    "slug": "Operation",
    "id": "hvMDXibXiSQYwWSD",
    "operationName": "peer-types"
  },
  "peer-web": {
    "name": "peer-web",
    "slug": "Operation",
    "id": "fcLZdcmoeRQHsGGH",
    "operationName": "peer-web"
  },
  "persona-functions-node": {
    "name": "persona-functions-node",
    "slug": "Operation",
    "id": "uvlsdhymohxzavizeimkaalt",
    "operationName": "persona-functions-node"
  },
  "play-import-node": {
    "name": "play-import-node",
    "slug": "Operation",
    "id": "qjaetqklcluchgfjgtfxlrfd",
    "operationName": "play-import-node"
  },
  "play-import-web": {
    "name": "play-import-web",
    "slug": "Operation",
    "id": "qclwibknzmxciffgwtsyswey",
    "operationName": "play-import-web"
  },
  "play-media-types": {
    "name": "play-media-types",
    "slug": "Operation",
    "id": "uafwxrekaormvyuvixsheibi",
    "operationName": "play-media-types"
  },
  "reminder-node": {
    "name": "reminder-node",
    "slug": "Operation",
    "id": "scioqschdwfqpgdgobykzqdw",
    "operationName": "reminder-node"
  },
  "reminder-types": {
    "name": "reminder-types",
    "slug": "Operation",
    "id": "kmdibyfhwnmkidcrkabccsar",
    "operationName": "reminder-types"
  },
  "file-search": {
    "name": "file-search",
    "slug": "Operation",
    "id": "rbnagrbhytcltontdhdjzhul",
    "operationName": "file-search"
  },
  "search": {
    "name": "search",
    "slug": "Operation",
    "id": "enaZdzaIcJtxsuCc",
    "operationName": "search"
  },
  "search-web": {
    "name": "search-web",
    "slug": "Operation",
    "id": "txlcixkjcqlbnmtxydskvjzp",
    "operationName": "search-web"
  },
  "timeline": {
    "name": "timeline",
    "slug": "Operation",
    "id": "bswaoubjnbnemdsmavjukrzk",
    "operationName": "timeline"
  },
  "social-media-functions": {
    "name": "social-media-functions",
    "slug": "Operation",
    "id": "itciphykkjkmlrqpafmlianh",
    "operationName": "social-media-functions"
  },
  "social-media-types": {
    "name": "social-media-types",
    "slug": "Operation",
    "id": "SZLSdBVDzaXWYAEI",
    "description": "I want a type interface collection that is able to collect all data from all social networks and put them together.",
    "operationName": "social-media-types"
  },
  "frontmatter-util": {
    "name": "frontmatter-util",
    "slug": "Operation",
    "id": "zwaaklbewcghwrndndsxvnum",
    "operationName": "frontmatter-util"
  },
  "short-markdown-writer-input": {
    "name": "short-markdown-writer-input",
    "slug": "Operation",
    "id": "xhjznnhvilrykjrgpzyhnaqs",
    "operationName": "short-markdown-writer-input"
  },
  "writer-demo-web": {
    "name": "writer-demo-web",
    "slug": "Operation",
    "id": "kpgjlpzmvkyryfnydlfoxbwp",
    "operationName": "writer-demo-web"
  },
  "writer-functions": {
    "name": "writer-functions",
    "slug": "Operation",
    "id": "xkhhpdbucaopovxzzfodmtvo",
    "operationName": "writer-functions"
  },
  "writer-input": {
    "name": "writer-input",
    "slug": "Operation",
    "id": "cogvbrxlirmddlfvbnrhrdha",
    "operationName": "writer-input"
  },
  "writer-types": {
    "name": "writer-types",
    "slug": "Operation",
    "id": "bewcxueuynedlzvljjsciqab",
    "operationName": "writer-types"
  },
  "writer-web": {
    "name": "writer-web",
    "slug": "Operation",
    "id": "tntfebpigyuqzszbxuglslsa",
    "operationName": "writer-web"
  },
  "get-light": {
    "name": "get-light",
    "slug": "Operation",
    "id": "afIiAGobrCUmPWXC",
    "operationName": "get-light"
  },
  "get-location": {
    "name": "get-location",
    "slug": "Operation",
    "id": "yEnDGsPPEWfyFReP",
    "operationName": "get-location"
  },
  "is-online": {
    "name": "is-online",
    "slug": "Operation",
    "id": "bvvjvydchfuzsfhbfqzktksk",
    "operationName": "is-online"
  },
  "weather-sensor": {
    "name": "weather-sensor",
    "slug": "Operation",
    "id": "bupgrtatyoypvazdwzgtcpur",
    "operationName": "weather-sensor"
  },
  "bundle-types": {
    "name": "bundle-types",
    "slug": "Operation",
    "id": "ooSLOVvBfJIKPyNI",
    "operationName": "bundle-types"
  },
  "code-types": {
    "name": "code-types",
    "slug": "Operation",
    "id": "OPfmHygUKpSTTntc",
    "operationName": "code-types"
  },
  "geo-types": {
    "name": "geo-types",
    "slug": "Operation",
    "id": "zmZNhwbpZoNRTrBq",
    "operationName": "geo-types"
  },
  "invoice-types": {
    "name": "invoice-types",
    "slug": "Operation",
    "id": "efjlewzDoiWrkNbh",
    "operationName": "invoice-types"
  },
  "language-types": {
    "name": "language-types",
    "slug": "Operation",
    "id": "MDGCBVVEJDNAZFnc",
    "operationName": "language-types"
  },
  "markdown-types": {
    "name": "markdown-types",
    "slug": "Operation",
    "id": "lfjxdzqmyqzatibtsvmvwnlu",
    "operationName": "markdown-types"
  },
  "matter-types": {
    "name": "matter-types",
    "slug": "Operation",
    "id": "zmHiKRECDSMTZFZJ",
    "operationName": "matter-types"
  },
  "model-types": {
    "name": "model-types",
    "slug": "Operation",
    "id": "IXDTUWkcNmDrRNZr",
    "operationName": "model-types"
  },
  "os-types": {
    "name": "os-types",
    "slug": "Operation",
    "id": "vaiAIfPoMcIBinHe",
    "description": "In this section of my documents, I will define all big model type interfaces.",
    "operationName": "os-types"
  },
  "recursive-types": {
    "name": "recursive-types",
    "slug": "Operation",
    "id": "btbhbxywtoukushkbfwtbpmu",
    "operationName": "recursive-types"
  },
  "webpage-types": {
    "name": "webpage-types",
    "slug": "Operation",
    "id": "lnwhnaoqskdjejvofpnoecrv",
    "operationName": "webpage-types"
  },
  "cleanup-typescript-database": {
    "name": "cleanup-typescript-database",
    "slug": "Operation",
    "id": "MQXgyYPDztaTqZDK",
    "operationName": "cleanup-typescript-database"
  },
  "comment-util": {
    "name": "comment-util",
    "slug": "Operation",
    "id": "geHTGIqdrUnTUVLt",
    "operationName": "comment-util"
  },
  "compile-typescript": {
    "name": "compile-typescript",
    "slug": "Operation",
    "id": "AvWuSXOnPmDqTnlH",
    "operationName": "compile-typescript"
  },
  "find-all-dependency-operations": {
    "name": "find-all-dependency-operations",
    "slug": "Operation",
    "id": "HdAdnbXfJAgtncKi",
    "operationName": "find-all-dependency-operations"
  },
  "generate-bun-monopackage": {
    "name": "generate-bun-monopackage",
    "slug": "Operation",
    "id": "bzutezztfbvgcdbzvvvdphlg",
    "operationName": "generate-bun-monopackage"
  },
  "generate-index": {
    "name": "generate-index",
    "slug": "Operation",
    "id": "mIFyRAZdIyMVeaNT",
    "operationName": "generate-index"
  },
  "generate-sdk-operations": {
    "name": "generate-sdk-operations",
    "slug": "Operation",
    "id": "xLOocRnSwCufGLeV",
    "operationName": "generate-sdk-operations"
  },
  "get-imported-dependencies": {
    "name": "get-imported-dependencies",
    "slug": "Operation",
    "id": "AUtLmurLbrNUzJTU",
    "operationName": "get-imported-dependencies"
  },
  "get-imports-exports": {
    "name": "get-imports-exports",
    "slug": "Operation",
    "id": "lRCCIhkcZmIEUuFr",
    "operationName": "get-imports-exports"
  },
  "get-missing-dependencies": {
    "name": "get-missing-dependencies",
    "slug": "Operation",
    "id": "ovNjzdGQsfXVfIIT",
    "operationName": "get-missing-dependencies"
  },
  "index-typescript": {
    "name": "index-typescript",
    "slug": "Operation",
    "id": "IcOyBmsRzHfoLRuh",
    "description": "This repo is used to generate the typescript index.\n\nSome important conventions I'm applying:\n\n1. The generated index doesn't know the absolute location, which makes it possible to move around the Project in the OS\n\n2. The generated index only tells you information about this very operation. All links with other operations should be done in postprocessing\n\n3. Every generated index has an `IndexId`",
    "operationName": "index-typescript"
  },
  "lint": {
    "name": "lint",
    "slug": "Operation",
    "id": "FbqlLZAgfQkcdjcs",
    "operationName": "lint"
  },
  "minify-build": {
    "name": "minify-build",
    "slug": "Operation",
    "id": "BxtliSGWFpCDLiTF",
    "operationName": "minify-build"
  },
  "new-template": {
    "name": "new-template",
    "slug": "Operation",
    "id": "WmtmpZUgcnRixKhs",
    "description": "Package to create a new King OS template (template or some other boilerplate)",
    "operationName": "new-template"
  },
  "package-scripts": {
    "name": "package-scripts",
    "slug": "Operation",
    "id": "riNHASZYWsLKtIRu",
    "operationName": "package-scripts"
  },
  "prettier-operation": {
    "name": "prettier-operation",
    "slug": "Operation",
    "id": "zUkxKJEnRthSVwmX",
    "operationName": "prettier-operation"
  },
  "rebuild-operation": {
    "name": "rebuild-operation",
    "slug": "Operation",
    "id": "BejGVIBFtLzwZoTB",
    "operationName": "rebuild-operation"
  },
  "rename-operation": {
    "name": "rename-operation",
    "slug": "Operation",
    "id": "vzpbNVfOICARGCKZ",
    "operationName": "rename-operation"
  },
  "schema-util": {
    "name": "schema-util",
    "slug": "Operation",
    "id": "vqDgdVlYDPjQItuA",
    "description": "It's hard to work with them if you don't know what means what. In this operation I'll summarize everything and give examples.",
    "operationName": "schema-util"
  },
  "simple-typescript-js": {
    "name": "simple-typescript-js",
    "slug": "Operation",
    "id": "wbivucbijwsmvdbkezxbkgph",
    "operationName": "simple-typescript-js"
  },
  "simple-typescript-node": {
    "name": "simple-typescript-node",
    "slug": "Operation",
    "id": "nbmvaqunvfyagysgubldgcnb",
    "operationName": "simple-typescript-node"
  },
  "simple-typescript-types": {
    "name": "simple-typescript-types",
    "slug": "Operation",
    "id": "dlnazujsikvbsrkzdcisqyru",
    "operationName": "simple-typescript-types"
  },
  "k-test": {
    "name": "k-test",
    "slug": "Operation",
    "id": "uzdtgVTjvwNzUtBE",
    "operationName": "k-test"
  },
  "make-test": {
    "name": "make-test",
    "slug": "Operation",
    "id": "BedsrLKBmpfyubBq",
    "operationName": "make-test"
  },
  "ts-morph-util": {
    "name": "ts-morph-util",
    "slug": "Operation",
    "id": "buvDfxDAGVPQBAzK",
    "operationName": "ts-morph-util"
  },
  "api-store": {
    "name": "api-store",
    "slug": "Operation",
    "id": "pplunkcemarwirhhsvkbszuv",
    "operationName": "api-store"
  },
  "api-types": {
    "name": "api-types",
    "slug": "Operation",
    "id": "YROAWZykJeSsJSKv",
    "operationName": "api-types"
  },
  "endpoint-util": {
    "name": "endpoint-util",
    "slug": "Operation",
    "id": "kQCYRiTiRcXefYYp",
    "operationName": "endpoint-util"
  },
  "encrypt-password": {
    "name": "encrypt-password",
    "slug": "Operation",
    "id": "abmvwsdhfxtqpkialrsakdut",
    "operationName": "encrypt-password"
  },
  "function-context-type": {
    "name": "function-context-type",
    "slug": "Operation",
    "id": "gxhwkphayiynopvlstqqefdb",
    "operationName": "function-context-type"
  },
  "function-recipes": {
    "name": "function-recipes",
    "slug": "Operation",
    "id": "vcMiJgIGKwSEBtKA",
    "operationName": "function-recipes"
  },
  "function-server": {
    "name": "function-server",
    "slug": "Operation",
    "id": "mWmyXwGmxjHGDraW",
    "operationName": "function-server"
  },
  "function-server-endpoints": {
    "name": "function-server-endpoints",
    "slug": "Operation",
    "id": "ngYzqrtHoOBkeAuZ",
    "description": "This operation wraps the sdk and creates a server-endpoint for every sdk function form the sdk package. It also adds raw context functions (both get and post) It can be included into any server so the endpoints can be exposed that way.",
    "operationName": "function-server-endpoints"
  },
  "function-server-types": {
    "name": "function-server-types",
    "slug": "Operation",
    "id": "vxwrtlwslpjunuppazpgswkq",
    "operationName": "function-server-types"
  },
  "server-api-url": {
    "name": "server-api-url",
    "slug": "Operation",
    "id": "YIaKrUxDlcIGSKGv",
    "operationName": "server-api-url"
  },
  "server-login": {
    "name": "server-login",
    "slug": "Operation",
    "id": "figgjjgfvhincexqpsqtbnsl",
    "operationName": "server-login"
  },
  "say": {
    "name": "say",
    "slug": "Operation",
    "id": "ilXwGuLYVpwmgrhQ",
    "operationName": "say"
  },
  "cli-version-updates": {
    "name": "cli-version-updates",
    "slug": "Operation",
    "id": "RzEujubmUOMhbOoH",
    "operationName": "cli-version-updates"
  },
  "function-util": {
    "name": "function-util",
    "slug": "Operation",
    "id": "HejhllnaKbSgGFZu",
    "operationName": "function-util"
  },
  "string-to-json": {
    "name": "string-to-json",
    "slug": "Operation",
    "id": "rwXIwlmtTtNkEuCI",
    "operationName": "string-to-json"
  },
  "big-button": {
    "name": "big-button",
    "slug": "Operation",
    "id": "mRyOhwUgEveAAJrO",
    "operationName": "big-button"
  },
  "breadcrumbs": {
    "name": "breadcrumbs",
    "slug": "Operation",
    "id": "kxoxrxhnzsqioawgipytghha",
    "operationName": "breadcrumbs"
  },
  "clickable-icon": {
    "name": "clickable-icon",
    "slug": "Operation",
    "id": "UEpOSpVemdWqtXEI",
    "operationName": "clickable-icon"
  },
  "context-menu": {
    "name": "context-menu",
    "slug": "Operation",
    "id": "enhounuvwosisfhtmpvpvuoc",
    "operationName": "context-menu"
  },
  "cool-toast": {
    "name": "cool-toast",
    "slug": "Operation",
    "id": "zutfzbjcvazexarsypjwzekh",
    "operationName": "cool-toast"
  },
  "fancy-loader": {
    "name": "fancy-loader",
    "slug": "Operation",
    "id": "pJcfNyjiMXrbMeeW",
    "operationName": "fancy-loader"
  },
  "file-icons": {
    "name": "file-icons",
    "slug": "Operation",
    "id": "omjkuceilskauoedaqurtwyw",
    "operationName": "file-icons"
  },
  "hotkeys": {
    "name": "hotkeys",
    "slug": "Operation",
    "id": "mhtiahtbjrotfleivmecjpmd",
    "operationName": "hotkeys"
  },
  "labeled-button": {
    "name": "labeled-button",
    "slug": "Operation",
    "id": "yhBwbsOSNWakshDe",
    "operationName": "labeled-button"
  },
  "next-paths": {
    "name": "next-paths",
    "slug": "Operation",
    "id": "slentyitwfkamdqsbtvmlfva",
    "operationName": "next-paths"
  },
  "react-with-native-store": {
    "name": "react-with-native-store",
    "slug": "Operation",
    "id": "eXOcmzdxLiHCsOky",
    "description": "Simple localStorage/asyncStorage-based and fully typed redux replacement with global persisted storage by default for react and react-native apps.",
    "operationName": "react-with-native-store"
  },
  "swipe-homepage": {
    "name": "swipe-homepage",
    "slug": "Operation",
    "id": "rmeomqfyhekatjqcdpuwodxf",
    "operationName": "swipe-homepage"
  },
  "tabs": {
    "name": "tabs",
    "slug": "Operation",
    "id": "igcpkjecedylbmppjpdavgzk",
    "operationName": "tabs"
  },
  "tooltip": {
    "name": "tooltip",
    "slug": "Operation",
    "id": "ehhnbkdyoqiebbhkkolyvzgu",
    "operationName": "tooltip"
  },
  "ui-util": {
    "name": "ui-util",
    "slug": "Operation",
    "id": "JSSQvyMnmCHPaPMF",
    "operationName": "ui-util"
  },
  "use-on-screen": {
    "name": "use-on-screen",
    "slug": "Operation",
    "id": "jtaapwhmogwjvgbcvnoxjlzv",
    "operationName": "use-on-screen"
  },
  "use-url-store": {
    "name": "use-url-store",
    "slug": "Operation",
    "id": "gUYkfVUCnjCcqSUE",
    "operationName": "use-url-store"
  },
  "next-a-link": {
    "name": "next-a-link",
    "slug": "Operation",
    "id": "eYjXWFLCrqXdeneP",
    "operationName": "next-a-link"
  },
  "react-with-native": {
    "name": "react-with-native",
    "slug": "Operation",
    "id": "LrYgJCZCgKRrjsKj",
    "description": "HTML elements with React Native capabilities.",
    "operationName": "react-with-native"
  },
  "react-with-native-alert": {
    "name": "react-with-native-alert",
    "slug": "Operation",
    "id": "HRCvBKzhcQmtavKi",
    "description": "Alert for web and native",
    "operationName": "react-with-native-alert"
  },
  "react-with-native-form": {
    "name": "react-with-native-form",
    "slug": "Operation",
    "id": "QDSihJHrNrMynEee",
    "description": "Create forms, fast",
    "operationName": "react-with-native-form"
  },
  "react-with-native-form-asset-input": {
    "name": "react-with-native-form-asset-input",
    "slug": "Operation",
    "id": "xstmiipzrabkocwcfctmjjyg",
    "operationName": "react-with-native-form-asset-input"
  },
  "react-with-native-form-inputs": {
    "name": "react-with-native-form-inputs",
    "slug": "Operation",
    "id": "nioyXlkpzdsdbrGZ",
    "operationName": "react-with-native-form-inputs"
  },
  "react-with-native-modal": {
    "name": "react-with-native-modal",
    "slug": "Operation",
    "id": "HtONHJUCgYpeRlAf",
    "description": "",
    "operationName": "react-with-native-modal"
  },
  "react-with-native-notification": {
    "name": "react-with-native-notification",
    "slug": "Operation",
    "id": "BpXbOAxWSlAaCPPy",
    "description": "",
    "operationName": "react-with-native-notification"
  },
  "react-with-native-router": {
    "name": "react-with-native-router",
    "slug": "Operation",
    "id": "RZVwdhmfmdetZNej",
    "description": "",
    "operationName": "react-with-native-router"
  },
  "react-with-native-select": {
    "name": "react-with-native-select",
    "slug": "Operation",
    "id": "ikNZbbUMqkXxVJPs",
    "description": "",
    "operationName": "react-with-native-select"
  },
  "react-with-native-table": {
    "name": "react-with-native-table",
    "slug": "Operation",
    "id": "SdhvsYtyLKPmzDWq",
    "operationName": "react-with-native-table"
  },
  "react-with-native-ui": {
    "name": "react-with-native-ui",
    "slug": "Operation",
    "id": "JYbdtPKKzYgRSNIQ",
    "description": "Simple basic Tailwind class strings for sensible UI components",
    "operationName": "react-with-native-ui"
  },
  "file-tabs": {
    "name": "file-tabs",
    "slug": "Operation",
    "id": "yxjrqsojvivmtfykswhaezlh",
    "operationName": "file-tabs"
  },
  "markdown": {
    "name": "markdown",
    "slug": "Operation",
    "id": "kizrquhyzzljipgcekjjtedi",
    "operationName": "markdown"
  },
  "nested-menu": {
    "name": "nested-menu",
    "slug": "Operation",
    "id": "UTkxpBtFXEwRtTqK",
    "operationName": "nested-menu"
  },
  "nested-menu-types": {
    "name": "nested-menu-types",
    "slug": "Operation",
    "id": "zcgsduhmgvbryrkojblugamd",
    "operationName": "nested-menu-types"
  },
  "recursive-util": {
    "name": "recursive-util",
    "slug": "Operation",
    "id": "mrbcdmxycfnpcesizugqjcio",
    "operationName": "recursive-util"
  },
  "apps-menu": {
    "name": "apps-menu",
    "slug": "Operation",
    "id": "kptmrhirsvgbkwunrnkyuxxx",
    "operationName": "apps-menu"
  },
  "authentication": {
    "name": "authentication",
    "slug": "Operation",
    "id": "hdvslqxxvwqpttxpqpdouyxc",
    "operationName": "authentication"
  },
  "db-crud": {
    "name": "db-crud",
    "slug": "Operation",
    "id": "lirieiteddugaafnaaeyjbds",
    "operationName": "db-crud"
  },
  "file-writer": {
    "name": "file-writer",
    "slug": "Operation",
    "id": "eeoxcjsmleyuvdgfpizfdxlb",
    "operationName": "file-writer"
  },
  "function-form": {
    "name": "function-form",
    "slug": "Operation",
    "id": "cJEZBYPBhcdnfoHB",
    "operationName": "function-form"
  },
  "layout": {
    "name": "layout",
    "slug": "Operation",
    "id": "wawdrsmykhqbtpmblsexbxiq",
    "operationName": "layout"
  },
  "menu": {
    "name": "menu",
    "slug": "Operation",
    "id": "ccxtwtiwzwtgjheoikeqhrxs",
    "operationName": "menu"
  },
  "reader-ui": {
    "name": "reader-ui",
    "slug": "Operation",
    "id": "dmrxxyobafgmvgnfcrwzhoqw",
    "operationName": "reader-ui"
  },
  "share": {
    "name": "share",
    "slug": "Operation",
    "id": "xuznentfkkennkrlzrcqilwx",
    "operationName": "share"
  },
  "simplified-schema-form": {
    "name": "simplified-schema-form",
    "slug": "Operation",
    "id": "DwZyUDgyJrucAuwy",
    "operationName": "simplified-schema-form"
  },
  "ui-generation": {
    "name": "ui-generation",
    "slug": "Operation",
    "id": "luadjqaudvjfenjihirjcoxp",
    "operationName": "ui-generation"
  },
  "child-process-helper": {
    "name": "child-process-helper",
    "slug": "Operation",
    "id": "TANPFBYnjjeOJmwd",
    "operationName": "child-process-helper"
  },
  "convert-case": {
    "name": "convert-case",
    "slug": "Operation",
    "id": "jZgNJgiTtJkeAhry",
    "operationName": "convert-case"
  },
  "execute-command": {
    "name": "execute-command",
    "slug": "Operation",
    "id": "eyAIFsAakWXeqECQ",
    "operationName": "execute-command"
  },
  "geo-parse": {
    "name": "geo-parse",
    "slug": "Operation",
    "id": "FmNNehRLEqXFHAxk",
    "operationName": "geo-parse"
  },
  "js-util": {
    "name": "js-util",
    "slug": "Operation",
    "id": "LZEMcPKjXKrmGtyo",
    "operationName": "js-util"
  },
  "k-dev": {
    "name": "k-dev",
    "slug": "Operation",
    "id": "UWnbXcZjuZVykeJY",
    "operationName": "k-dev"
  },
  "measure-performance": {
    "name": "measure-performance",
    "slug": "Operation",
    "id": "kgowshxmokprmggbdvxcmgbv",
    "operationName": "measure-performance"
  },
  "one-by-one": {
    "name": "one-by-one",
    "slug": "Operation",
    "id": "rYEcHzTwPVdXNgDV",
    "operationName": "one-by-one"
  },
  "run-child-process": {
    "name": "run-child-process",
    "slug": "Operation",
    "id": "jErGyuybqueevsjw",
    "operationName": "run-child-process"
  },
  "browser-types": {
    "name": "browser-types",
    "slug": "Operation",
    "id": "pgxybusbmtajhxcyzrccvxiq",
    "operationName": "browser-types"
  },
  "chatgpt-controller": {
    "name": "chatgpt-controller",
    "slug": "Operation",
    "id": "xwgqotrxkqssqbtgmmwsaxzq",
    "operationName": "chatgpt-controller"
  },
  "puppeteer-utils": {
    "name": "puppeteer-utils",
    "slug": "Operation",
    "id": "jOxKunDQGygYBOWr",
    "operationName": "puppeteer-utils"
  },
  "slack-controller": {
    "name": "slack-controller",
    "slug": "Operation",
    "id": "lpitwqvgqfuhhegtxrpvutfo",
    "operationName": "slack-controller"
  },
  "social-media-node": {
    "name": "social-media-node",
    "slug": "Operation",
    "id": "mqhjanazrfsdlcazchxkbzys",
    "operationName": "social-media-node"
  },
  "social-media-web": {
    "name": "social-media-web",
    "slug": "Operation",
    "id": "fdjiiwwgoxohxldljdtlrhtw",
    "operationName": "social-media-web"
  },
  "social-media-wrapper": {
    "name": "social-media-wrapper",
    "slug": "Operation",
    "id": "EcSzUojZlwANelzs",
    "operationName": "social-media-wrapper"
  },
  "code-from-anywhere-web": {
    "name": "code-from-anywhere-web",
    "slug": "Operation",
    "id": "mhbnwivmfumltbogbyaebjpa",
    "operationName": "code-from-anywhere-web"
  },
  "code-from-bali-web": {
    "name": "code-from-bali-web",
    "slug": "Operation",
    "id": "ulxdvwhgearuudloknysrfiz",
    "operationName": "code-from-bali-web"
  },
  "code-from-brazil-web": {
    "name": "code-from-brazil-web",
    "slug": "Operation",
    "id": "ulxdvwhgearuudloknysrfiz",
    "operationName": "code-from-brazil-web"
  },
  "code-from-nepal-web": {
    "name": "code-from-nepal-web",
    "slug": "Operation",
    "id": "ulxdvwhgearuudloknysrfiz",
    "operationName": "code-from-nepal-web"
  },
  "course-basics": {
    "name": "course-basics",
    "slug": "Operation",
    "id": "cszccxrZNZylucWZ",
    "operationName": "course-basics"
  },
  "himalayajeep-functions": {
    "name": "himalayajeep-functions",
    "slug": "Operation",
    "id": "fYjPUhJLjJssnZTc",
    "operationName": "himalayajeep-functions"
  },
  "himalayajeep-types": {
    "name": "himalayajeep-types",
    "slug": "Operation",
    "id": "gPsGJdhoTTUasjES",
    "operationName": "himalayajeep-types"
  },
  "himalayajeep-ui": {
    "name": "himalayajeep-ui",
    "slug": "Operation",
    "id": "YStcNiLkDIJEUVTA",
    "description": "All frontend components can go here",
    "operationName": "himalayajeep-ui"
  },
  "himalayajeep-web": {
    "name": "himalayajeep-web",
    "slug": "Operation",
    "id": "CvdPhPTJVAxNOZee",
    "operationName": "himalayajeep-web"
  },
  "github-operation-sync": {
    "name": "github-operation-sync",
    "slug": "Operation",
    "id": "szzumimxdmdrzerrkustawaf",
    "operationName": "github-operation-sync"
  },
  "operation-web": {
    "name": "operation-web",
    "slug": "Operation",
    "id": "lnpxlptmppivsdzdylreltux",
    "operationName": "operation-web"
  },
  "migrate-operation-model": {
    "name": "migrate-operation-model",
    "slug": "Operation",
    "id": "lfnmqkahinhghogimwnzrunn",
    "operationName": "migrate-operation-model"
  },
  "passionfruit-web": {
    "name": "passionfruit-web",
    "slug": "Operation",
    "id": "hFaAxnKSCHOuKIYF",
    "operationName": "passionfruit-web"
  },
  "foodchain-recipes": {
    "name": "foodchain-recipes",
    "slug": "Operation",
    "id": "HWVWeFsKpvjHkDdU",
    "operationName": "foodchain-recipes"
  },
  "foodchain-recipes-js": {
    "name": "foodchain-recipes-js",
    "slug": "Operation",
    "id": "mvwxurmoglmoqsifdascaygb",
    "operationName": "foodchain-recipes-js"
  },
  "foodchain-types": {
    "name": "foodchain-types",
    "slug": "Operation",
    "id": "zQQNusEveQVgvAVD",
    "operationName": "foodchain-types"
  },
  "passionfruit-ui": {
    "name": "passionfruit-ui",
    "slug": "Operation",
    "id": "rzQOhrLodPwZyXWl",
    "description": "All frontend components can go here",
    "operationName": "passionfruit-ui"
  },
  "parse-address-henrik": {
    "name": "parse-address-henrik",
    "slug": "Operation",
    "id": "qHGBmnzelFfwTDBO",
    "operationName": "parse-address-henrik"
  },
  "parse-images": {
    "name": "parse-images",
    "slug": "Operation",
    "id": "axfmexufbjgzcnqheqkmmgaq",
    "operationName": "parse-images"
  },
  "sprent-migrate": {
    "name": "sprent-migrate",
    "slug": "Operation",
    "id": "wyfrapfzkcffyaisydmqtmhu",
    "operationName": "sprent-migrate"
  },
  "ai": {
    "name": "ai",
    "slug": "BundleConfig",
    "id": "rngurgfumxxbfxszkojftgdg",
    "description": "ChatGPT API with amazing tooling",
    "operationName": null,
    "gitRepoUrl": "https://github.com/CodeFromAnywhere/chatgpt-api-pro"
  },
  "asset": {
    "name": "asset",
    "slug": "BundleConfig",
    "id": "jlkfdsjfkldsjflskdjflkdsj",
    "operationName": null,
    "gitRepoUrl": "https://github.com/CodeFromAnywhere/asset"
  },
  "browse-puppy": {
    "name": "browse-puppy",
    "slug": "BundleConfig",
    "id": "browsepuppy1234kakkalfkdj",
    "operationName": null,
    "gitRepoUrl": "https://github.com/CodeFromAnywhere/browse-puppy"
  },
  "cfbali": {
    "name": "cfbali",
    "slug": "BundleConfig",
    "id": "dquczkdolqtzzgadianneqyo",
    "description": "The ultimate Typescript bootcamp",
    "operationName": null,
    "gitRepoUrl": "https://github.com/CodeFromAnywhere/code-from-bali"
  },
  "cfbr": {
    "name": "cfbr",
    "slug": "BundleConfig",
    "id": "tvwzrdgnjghltgksbwmyaejs",
    "description": "Let's get real",
    "operationName": null,
    "gitRepoUrl": "https://github.com/CodeFromAnywhere/code-from-brazil"
  },
  "cfnp": {
    "name": "cfnp",
    "slug": "BundleConfig",
    "id": "ksebqoohbunjedihupbmkevr",
    "description": "Freedom for all",
    "operationName": null,
    "gitRepoUrl": "https://github.com/CodeFromAnywhere/code-from-nepal"
  },
  "codestorys": {
    "name": "codestorys",
    "slug": "BundleConfig",
    "id": "oWGkXGdFXXXwwcCTJ",
    "description": "The advantures of a brave coder!",
    "operationName": null,
    "gitRepoUrl": "https://github.com/CodeFromAnywhere/codestorys"
  },
  "gptide": {
    "name": "gptide",
    "slug": "BundleConfig",
    "id": "kfsjlkjdkljfslkjsfo",
    "description": "GPT IDE",
    "operationName": null,
    "gitRepoUrl": "https://github.com/CodeFromAnywhere/gptide"
  },
  "gptideas": {
    "name": "gptideas",
    "slug": "BundleConfig",
    "id": "jskldjfklsdjfskldjwowo",
    "description": "GhatGPT ideas",
    "operationName": null,
    "gitRepoUrl": "https://github.com/CodeFromAnywhere/gptideas"
  },
  "himalayajeep": {
    "name": "himalayajeep",
    "slug": "BundleConfig",
    "id": "kjkdjsklfjdlksjfsdlksjlkdjk",
    "description": "Jeeps in the Himal",
    "operationName": null,
    "gitRepoUrl": "https://github.com/CodeFromAnywhere/himalayajeep"
  },
  "king-os": {
    "name": "king-os",
    "slug": "BundleConfig",
    "id": "oWGqpldFXXXwwcCTJ",
    "description": "King OS is a new operating system aiming to centralise your data around you!",
    "operationName": null,
    "gitRepoUrl": "https://github.com/CodeFromAnywhere/king-os"
  },
  "passionfruit": {
    "name": "passionfruit",
    "slug": "BundleConfig",
    "id": "skksskskkskdjroewirwiwiw",
    "operationName": null,
    "gitRepoUrl": "https://github.com/LarsKuijpers2/passionfruit"
  },
  "rwn": {
    "name": "rwn",
    "slug": "BundleConfig",
    "id": "wzoqpldFXXXwwcCTkk",
    "description": "Bringing together React and React Native",
    "operationName": null,
    "gitRepoUrl": "https://github.com/CodeFromAnywhere/react-with-native"
  },
  "tokipona": {
    "name": "tokipona",
    "slug": "BundleConfig",
    "id": "xfmqlrvbrafedkozhwpersjz",
    "description": "The new way to dev",
    "operationName": null,
    "gitRepoUrl": "https://github.com/CodeFromAnywhere/tokipona"
  },
  "typebase": {
    "name": "typebase",
    "slug": "BundleConfig",
    "id": "oWGkXGdFXGhXcCT2",
    "description": "The most transparent database in the world",
    "operationName": null,
    "gitRepoUrl": "https://github.com/CodeFromAnywhere/typebase"
  },
  "typenet": {
    "name": "typenet",
    "slug": "BundleConfig",
    "id": "typenetkdfjlksadjkla",
    "description": "Type conventions for Web3",
    "operationName": null,
    "gitRepoUrl": "https://github.com/CodeFromAnywhere/typenet"
  },
  "typerepo": {
    "name": "typerepo",
    "slug": "BundleConfig",
    "id": "kskoqvkjdmei8vusdkwovopwksjs",
    "description": "The new way to dev",
    "operationName": null,
    "gitRepoUrl": "https://github.com/CodeFromAnywhere/typerepo"
  }
}