{
  "getStaticPaths": {
    "name": "getStaticPaths",
    "slug": "TsFunction",
    "id": "dfptvlyxryuzeobpiujgzcch",
    "description": "",
    "operationName": "search-web",
    "rawText": " () => {\n  return { fallback: \"blocking\", paths: [] };\n}"
  },
  "getStaticProps": {
    "name": "getStaticProps",
    "slug": "TsVariable",
    "id": "iarvtpmcmeegwmppnoeuznfh",
    "description": "",
    "operationName": "search-web"
  },
  "HomePage": {
    "name": "HomePage",
    "slug": "TsFunction",
    "id": "ltxecbzqrbgeqfzgevwbvhgx",
    "description": "",
    "operationName": "search-web",
    "rawText": " (props: QueryPageProps) => {\n  const { imagePaths } = props;\n\n  const hour = new Date(Date.now()).getHours();\n  const quote = quotes[hour % quotes.length];\n  const imagePath = imagePaths[hour % imagePaths.length];\n  const [mindspace, setMindspace] = useState(mindspaces[0]);\n  const [mouseDown, setMouseDown] = useState(false);\n  const [mouseDownTimeout, setMouseDownTimeout] =\n    useState<NodeJS.Timeout | null>(null);\n\n  return (\n    <Div className=\"\">\n      <Timeline\n        items={[\n          {\n            imageUrl: `headers/${imagePath}`,\n            component: () => {\n              return (\n                <Div\n                  className=\"flex flex-1 min-h-screen items-center flex-col justify-around\"\n                  // style={{ background: `url(${imagePath})` }}\n                >\n                  <a\n                    href=\"https://twitter.com/wkarsens\"\n                    target=\"_blank\"\n                    className=\"absolute top-0 right-0 p-4 z-50 rounded-bl-full bg-blue-400\"\n                  >\n                    🦚 Twit\n                  </a>\n                  <Div\n                    className=\"text-3xl text-white drop-shadow cursor-grab\"\n                    onMouseDown={(e) => {\n                      const timeout = setTimeout(() => {\n                        setMouseDown(true);\n                      }, 200);\n                      setMouseDownTimeout(timeout);\n                    }}\n                    onMouseUp={(e) => {\n                      if (mouseDownTimeout) {\n                        clearTimeout(mouseDownTimeout);\n                      }\n                      setMouseDown(false);\n                    }}\n                    onClick={(e) => {\n                      e.preventDefault();\n                      setMindspace(pickRandomArrayItem(mindspaces));\n                    }}\n                  >\n                    Clarity AI\n                  </Div>\n\n                  <Div className=\"italic text-white\">{quote}</Div>\n                  <SearchBar\n                    changePlaceholder={() =>\n                      setMindspace(pickRandomArrayItem(mindspaces))\n                    }\n                    placeholder={mindspace}\n                  />\n                  <Div className=\"max-w-xl\">\n                    <A href=\"/db/Person\">DB</A>\n                    <A href=\"/files/README.md\">Files</A>\n                    <A href=\"/functions/explore\">Functions</A>\n                    <AppsMenu />\n                  </Div>\n                </Div>\n              );\n            },\n          },\n          // {\n          //   markdown: `I see dead people`,\n          // },\n          ...props.timelineItems?.map((x) => {\n            return {\n              markdown: x.comment,\n              projectRelativeFilePath: x.filePath,\n              line: x.line,\n            };\n          }),\n        ]}\n      />\n    </Div>\n  );\n}"
  },
  "Layout": {
    "name": "Layout",
    "slug": "TsFunction",
    "id": "orrybilsatisxwywwaqmuopt",
    "description": "",
    "operationName": "reader-ui",
    "rawText": " (props: {\n  publicBundleConfig: MarkdownReaderPageProps[\"publicBundleConfig\"];\n  children: any;\n  augmentedWordObject?: MappedObject<AugmentedWord>;\n  menu: MenuObjectType<FilePage>;\n}) => {\n  const { children, augmentedWordObject, publicBundleConfig, menu } = props;\n\n  return (\n    <LayoutGrid\n      menu={{\n        augmentedWords: Object.values(augmentedWordObject || {}),\n        webPagesFlat: menu.flat,\n        webPagesNested: menu.nested,\n        isLoading: false,\n      }}\n      header={<Header publicBundleConfig={publicBundleConfig} />}\n    >\n      {children}\n    </LayoutGrid>\n  );\n}"
  },
  "progress": {
    "name": "progress",
    "slug": "TsVariable",
    "id": "xtenqlcvzcoqopvuqzhigrwt",
    "description": "",
    "operationName": "writer-web"
  },
  "queryClient": {
    "name": "queryClient",
    "slug": "TsVariable",
    "id": "mxleaxgdqalvvcfsfzehnfqh",
    "description": "",
    "operationName": "writer-web"
  },
  "executeCronFunction": {
    "name": "executeCronFunction",
    "slug": "TsFunction",
    "id": "vpovdiewbzjqvoxdvtmwgfeg",
    "description": "NB: cron functions cannot have parameters",
    "operationName": "function-server",
    "rawText": " async (tsFunction: TsFunction) => {\n  if (\n    tsFunction.parameters &&\n    tsFunction.parameters.length > 0 &&\n    tsFunction.parameters.find((x) => x.required)\n  ) {\n    log(\"CRON Functions cannot have required parameters\", { type: \"error\" });\n    process.exit();\n  }\n\n  //@ts-ignore\n  sdk[tsFunction.name]?.();\n}"
  },
  "runFunctionServerCli": {
    "name": "runFunctionServerCli",
    "slug": "TsFunction",
    "id": "bwlhfpmblcqhdqgrzshbosdl",
    "description": "Argument:\n- pass true if you want the server to be watching\n- pass true true if you want the server to be watching and this is a restart (so don't launch things like browser)\n- if you pass nothing, there will be no browser start and no watcher",
    "operationName": "function-server",
    "rawText": " () => {\n  const [isWatchingString, isRestartString] = process.argv.slice(2);\n\n  runFunctionServer(\n    isWatchingString === \"true\" ? true : false,\n    isRestartString === \"true\" ? true : false\n  );\n}"
  },
  "runFunctionServerDevCli": {
    "name": "runFunctionServerDevCli",
    "slug": "TsFunction",
    "id": "bsrpfytarxqumlmhheqqmbnf",
    "description": "",
    "operationName": "function-server",
    "rawText": " () => {\n  runFunctionServerDev();\n}"
  },
  "runFunctionServerDev": {
    "name": "runFunctionServerDev",
    "slug": "TsFunction",
    "id": "hacrrfcrpcoxhupknbrcpvle",
    "description": "",
    "operationName": "function-server",
    "rawText": " () => {\n  nodemon({\n    operationName: \"function-server\",\n    cliFunctionName: \"runFunctionServer\",\n    vars: [\"true\", \"false\"],\n    restartVars: [\"true\", \"true\"],\n  });\n}"
  },
  "runFunctionServer": {
    "name": "runFunctionServer",
    "slug": "TsFunction",
    "id": "fqmaymvxqywlychndbydkgml",
    "description": "runs sdk api server using \"server\" package.\n\nserver will be exposed on port 42000",
    "operationName": "function-server",
    "rawText": " (\n  isWatching?: boolean,\n  isRestart?: boolean\n) => {\n  const { header } = server.reply;\n\n  startSearchWebIfAvailable(isWatching, isRestart);\n  const cors = [\n    /* \n     see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin\n    see https://stackoverflow.com/questions/18642828/origin-origin-is-not-allowed-by-access-control-allow-origin\n    NB: cannot set \"*\" i.c.m. cookies\n\n    a better way to allow multiple origins is probably something like this:\n\n      const allowedOrigins = ['http://127.0.0.1:8020', 'http://localhost:8020', 'http://127.0.0.1:9000', 'http://localhost:9000'];\n  const origin = req.headers.origin;\n  if (allowedOrigins.includes(origin)) {\n       res.setHeader('Access-Control-Allow-Origin', origin);\n  }\n  */\n\n    () => header(\"Access-Control-Allow-Origin\", \"*\"),\n    () =>\n      header(\n        \"Access-Control-Allow-Headers\",\n        \"Origin, X-Requested-With, Content-Type, Accept, Authorization, Set-Cookie\" // not sure if * can be put here after the others...\n      ),\n    () =>\n      header(\n        \"Access-Control-Allow-Methods\",\n        \"GET, PUT, PATCH, POST, DELETE, HEAD\"\n      ),\n\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials\n    // NB: important for cookies!\n    () => header(\"Access-Control-Allow-Credentials\", \"true\"),\n    (ctx: Context) => (ctx.method.toLowerCase() === \"options\" ? 200 : false),\n  ];\n\n  const port: number = process.env?.port\n    ? Number(process.env.port)\n    : ports[\"function-server\"];\n\n  const projectRoot = getProjectRoot();\n  const projectPublicFolder = projectRoot\n    ? path.join(projectRoot, \"public\")\n    : path.join(__dirname, \"..\", \"public\");\n\n  const serverOptions: Options = {\n    port,\n    public: projectPublicFolder,\n    security: { csrf: false },\n    parser: {\n      // NB: seems the server.js types are not 100% correct\n      data: { maxFileSize: 1024 * 1024 * 1024 * 32 } as any,\n      cookie: { maxAge: 900000, httpOnly: false },\n    },\n  };\n  // @ts-ignore\n  server(\n    serverOptions,\n    cors,\n    functionPostEndpoints,\n    functionGetEndpoints,\n\n    server.router.get(\"/\", () => \"Hello world, your Typerepo is running!\"),\n    server.router.get(\"*\", async (ctx) => {\n      return {\n        success: false,\n        message: \"Endpoint does not exist, are you sure it's a GET endpoint?\",\n      };\n    })\n  ).then(async (context) => {\n    if (\n      process.env.NODE_APP_INSTANCE === undefined ||\n      process.env.NODE_APP_INSTANCE === \"0\"\n    ) {\n      // only on the first core, schedule crons and initiate watchers\n      scheduleCronJobs();\n\n      if (isWatching) {\n        watchAll();\n      }\n    }\n\n    console.log(\n      `Typerepo is now running on port ${port}. Your node functions are now available through the \"api\" object!`\n    );\n  });\n}"
  },
  "scheduleCronJobs": {
    "name": "scheduleCronJobs",
    "slug": "TsFunction",
    "id": "zuxmvowueyuibaullsnvglya",
    "description": "",
    "operationName": "function-server",
    "rawText": " async () => {\n  const tsFunctions = await db.get(\"TsFunction\");\n\n  log(\"Scheduling CRON jobs\", { type: \"important\" });\n\n  getObjectKeysArray(scheduleObject).map((interval) => {\n    const cronExpression = scheduleObject[interval];\n    const functionsToExecute = tsFunctions.filter(\n      //@ts-ignore should later be replaced with the thing you find on the actual function\n      (x) => x.runEveryPeriod === interval\n    );\n    if (functionsToExecute.length > 0) {\n      console.log(\n        `- ${functionsToExecute.length} functions for ${interval} cron`\n      );\n      schedule(\n        cronExpression,\n        () => {\n          oneByOne(functionsToExecute, executeCronFunction);\n        },\n        { name: interval }\n      );\n    }\n  });\n}"
  },
  "scheduleObject": {
    "name": "scheduleObject",
    "slug": "TsVariable",
    "id": "qyeqjlsebbadzjwgkcacquxj",
    "description": "For every `RunEveryPeriodEnum`, this object provides the interval `cronExpression` string for `node-cron`",
    "operationName": "function-server"
  },
  "startSearchWebIfAvailable": {
    "name": "startSearchWebIfAvailable",
    "slug": "TsFunction",
    "id": "xrintxxkqwfcammpretqbaqs",
    "description": "",
    "operationName": "function-server",
    "rawText": " async (\n  isWatching?: boolean,\n  isRestart?: boolean\n) => {\n  const hasSearchWeb = !!operations[\"search-web\"];\n  if (!hasSearchWeb) {\n    return;\n  }\n\n  if (os.platform() === \"win32\") {\n    console.log(\"Not starting search-web on windows\");\n    return;\n  }\n\n  startApp(\"search-web\", true).then((result) => {\n    if (!result?.isSuccessful) {\n      console.log({ result });\n      log(\n        `Something went wrong starting \"search-web\". Maybe you don't have it?`,\n        { type: \"error\" }\n      );\n      return;\n    }\n\n    if (!isRestart && isWatching) {\n      // Open in browser\n      setTimeout(() => {\n        execSync(`open http://localhost:42001`);\n        log(`Opened the homepage in your browser`, { type: \"success\" });\n      }, 1000);\n    }\n  });\n}"
  },
  "DbAndUpsert": {
    "name": "DbAndUpsert",
    "slug": "TsFunction",
    "id": "egjhtsrtmlbuvvexsnplepup",
    "description": "This should catch all dbQueryPaths because those aren't default ones",
    "operationName": "search-web",
    "rawText": " () => {\n  const router = useRouter();\n  const paths = router.asPath.slice(1);\n  const modelNameWithQuery = paths.split(\"/\").pop()!;\n  const modelName = modelNameWithQuery.split(\"?\")[0];\n  const modelNames = [...dbModelKeys] as string[];\n\n  if (!modelNames.includes(modelName) || !modelName || modelName === \"\") {\n    return \"Please select a model on the right\";\n  }\n\n  if (paths.startsWith(\"db/upsert/\")) {\n    return <UpsertPage />;\n  }\n\n  return <DbPage />;\n}"
  },
  "DbLayout": {
    "name": "DbLayout",
    "slug": "TsFunction",
    "id": "wyjlbefjqpijzhahhuncomzu",
    "description": "",
    "operationName": "search-web",
    "rawText": " () => {\n  const items = [\n    { label: \"🪺 Nested\", value: \"nested\" },\n    { label: \"⚡️ Operaton-based\", value: \"operation\" },\n    { label: \"👩‍🌾 Flat\", value: \"flat\" },\n  ];\n  const [SelectMenu, menuType] = useSelect(items, items[0]);\n\n  const dbMenuQuery = queries.useGetNestedDatabaseMenu({\n    noOperationName: menuType?.value === \"flat\",\n    noOperationPath: menuType?.value !== \"nested\",\n    noSrcRelativeFolder: menuType?.value !== \"nested\",\n    noPrefix: true,\n  });\n\n  const { flat, nested } = destructureOptionalObject(dbMenuQuery.data?.result);\n\n  return (\n    <AuthenticationLayout\n      // menu props\n      menu={{\n        // NB: passionfruit wants this xD just make a layoutconfig in the PublicBundleConfig, or make it editable per user (later)\n        // menuPosition: \"left\",\n        menuHeader: () => {\n          return <SelectMenu />;\n        },\n        isLoading: dbMenuQuery.isLoading,\n        webPagesFlat: flat,\n        webPagesNested: nested,\n      }}\n      // other\n      nextPage={DbAndUpsert}\n      pageProps={{}}\n    />\n  );\n}"
  },
  "fitViewOptions": {
    "name": "fitViewOptions",
    "slug": "TsVariable",
    "id": "rzywcihmjgleywhqfzwfdlbo",
    "description": "",
    "operationName": "search-web"
  },
  "Flow": {
    "name": "Flow",
    "slug": "TsFunction",
    "id": "daupxoczmqspdegvsiuogtsr",
    "description": "",
    "operationName": "search-web",
    "rawText": " <T extends { [key: string]: any }>(props: {\n  renderNode: (item: T) => JSX.Element;\n  childObject: ChildObject<T>;\n}) => {\n  const { childObject, renderNode } = props;\n\n  //\n\n  // const [nodes, setNodes] = useNodesState<Node[]>(initialNodes);\n  // const [edges, setEdges] = useEdgesState<Edge[]>(initialEdges);\n\n  // const onNodesChange = useCallback(\n  //   (changes: NodeChange[]) =>\n  //     setNodes((nds) => applyNodeChanges(changes, nds)),\n  //   [setNodes]\n  // );\n  // const onEdgesChange = useCallback(\n  //   (changes: EdgeChange[]) =>\n  //     setEdges((eds) => applyEdgeChanges(changes, eds)),\n  //   [setEdges]\n  // );\n  // const onConnect = useCallback(\n  //   (connection: Connection) => setEdges((eds) => addEdge(connection, eds)),\n  //   [setEdges]\n  // );\n\n  const [nodes, setNodes] = useState(initialNodes);\n  const [edges, setEdges] = useState<Edge<any>[]>([]);\n\n  const onNodesChange = useCallback(\n    (changes) => setNodes((nds) => applyNodeChanges(changes, nds)),\n    [setNodes]\n  );\n  const onEdgesChange = useCallback(\n    (changes) => setEdges((eds) => applyEdgeChanges(changes, eds)),\n    [setEdges]\n  );\n  const onConnect = useCallback(\n    (connection) => setEdges((eds) => addEdge(connection, eds)),\n    [setEdges]\n  );\n\n  return (\n    <ReactFlow\n      nodes={nodes}\n      edges={edges}\n      onNodesChange={onNodesChange}\n      onEdgesChange={onEdgesChange}\n      onConnect={onConnect}\n      fitView\n      fitViewOptions={fitViewOptions}\n    />\n  );\n}"
  },
  "FormTab": {
    "name": "FormTab",
    "slug": "TsFunction",
    "id": "wijsonnahnjsiyzeenopnfhw",
    "description": "### Tab 1: Function Form\n\nUses `<FunctionForm>` component\n\nExecutes the function directly or through API (depending on whether or not it is a node-only-function or bare JS)\n\nDon't show this tab for JSX components",
    "operationName": "search-web",
    "rawText": " (props: { tsFunction: TsFunction }) => {\n  const { tsFunction } = props;\n  const [executionId] = useStore(\"executionId\");\n  const [initialValues] = useStore(\"initialValues\");\n  const [resultJson, setResultJson] = useState<{\n    [key: string]: RealApiReturnType<any> | undefined | string;\n  }>({});\n\n  const jsonCodeblock =\n    resultJson[executionId] === undefined\n      ? null\n      : renderMarkdownContent(\n          createCodeblockMarkdown(JSON.stringify(resultJson, null, 2), \"json\"),\n          // NB: since there won't be any assets in here, it doesn't matter where the md is made\n          {\n            projectRelativeBaseFolderPath: \"\",\n            projectRelativeMarkdownFilePath: \"\",\n          }\n        );\n\n  return (\n    <Div>\n      <FunctionForm\n        key={executionId}\n        tsFunction={tsFunction}\n        initialValues={initialValues}\n        submitFunction={\n          undefined\n          // provide this later, for js functions\n        }\n        projectRelativeStorageFilePath=\"\"\n        withApiResult={(result: RealApiReturnType<any> | undefined) => {\n          setResultJson({ ...resultJson, [executionId]: result });\n          if (\n            !result ||\n            typeof result !== \"object\" ||\n            Array.isArray(result) ||\n            result.isSuccessful === undefined\n          ) {\n            infoToast(\"We got no satisfactory result to show you anything\");\n            return;\n          }\n\n          if (result.isSuccessful === false || result.isUnauthorized === true) {\n            errorToast(result.message);\n            return;\n          }\n\n          if (!result.result) {\n            successToast(\n              \"Seems to have gone well, but we don't know how it went\"\n            );\n            return;\n          }\n\n          if (\n            result.result &&\n            typeof result.result === \"object\" &&\n            !Array.isArray(result.result)\n          ) {\n            const maybeSuccessIndicator = result.result.isSuccessful;\n\n            if (maybeSuccessIndicator !== undefined) {\n              const rightToast =\n                maybeSuccessIndicator === true ? successToast : errorToast;\n\n              rightToast(result.result.message);\n\n              return;\n            }\n          }\n\n          return successToast(\"We got a response\");\n        }}\n      />\n      {jsonCodeblock}\n    </Div>\n  );\n}"
  },
  "FunctionExecutionTable": {
    "name": "FunctionExecutionTable",
    "slug": "TsFunction",
    "id": "seantrojdumzmasnobaejfci",
    "description": "",
    "operationName": "search-web",
    "rawText": " (props: {\n  tsFunction?: TsFunction;\n  functionExecutions: FunctionExecution[];\n  type: \"example\" | \"test\" | \"recent\";\n}) => {\n  const { functionExecutions, type, tsFunction } = props;\n\n  const [executionId, setExecutionId] = useStore(\"executionId\");\n  const [initialValues, setInitialValues] = useStore(\"initialValues\");\n\n  const [currentTab, setCurrentTab] = useStore(\"tabs.currentTab\");\n  const [loading, setLoading] = useState<{ [id: string]: number | undefined }>(\n    {}\n  );\n\n  const functionExecutionsQuery = queries.useGetFunctionExecutions(\n    tsFunction?.name\n  );\n\n  if (!tsFunction) {\n    return <Div>Hmmm vremd</Div>;\n  }\n\n  const withLoading = async (\n    callback: () => Promise<void>,\n    id: string,\n    actionNumber: number\n  ) => {\n    setLoading((loading) => ({ ...loading, [id]: actionNumber }));\n\n    await callback();\n\n    setLoading((loading) => ({\n      ...loading,\n      [id]: undefined,\n    }));\n  };\n\n  const finalFunctionExecutions =\n    type === \"example\"\n      ? functionExecutions.filter((item: FunctionExecution) => item.isExample)\n      : type === \"test\"\n      ? functionExecutions.filter((item: FunctionExecution) => item.isTest)\n      : functionExecutions\n          .sort((a, b) => (a.createdAt < b.createdAt ? -1 : 1))\n          .slice(0, 100);\n\n  const isDataLoading =\n    functionExecutionsQuery.isRefetching ||\n    functionExecutionsQuery.isFetching ||\n    functionExecutionsQuery.isLoading;\n  return (\n    <>\n      {isDataLoading ? <FancyLoader big /> : null}\n      <Table\n        data={finalFunctionExecutions}\n        columns={[\n          {\n            name: \"Input\",\n            objectParameterKey: \"inputParameters\",\n            customPresentation: (item) => {\n              return (\n                <td>\n                  {item.inputParameters\n                    ? item.inputParameters.map((inputParameter) => {\n                        return (\n                          <Div className=\"border border-black p-2\">\n                            <MarkdownCodeblock\n                              text={\n                                inputParameter\n                                  ? JSON.stringify(inputParameter, undefined, 2)\n                                  : \"undefined\"\n                              }\n                              extension=\"json\"\n                              minimalMode=\"preview\"\n                              expandedMode=\"scroll\"\n                              isInitiallyExpanded={false}\n                            />\n                          </Div>\n                        );\n                      })\n                    : \"No input\"}\n                </td>\n              );\n            },\n          },\n          {\n            name: \"Output\",\n            objectParameterKey: \"output\",\n            customPresentation: (item) => {\n              return (\n                <td>\n                  <MarkdownCodeblock\n                    text={\n                      item.output\n                        ? JSON.stringify(item.output, undefined, 2)\n                        : \"undefined\"\n                    }\n                    extension=\"json\"\n                    minimalMode=\"preview\"\n                    expandedMode=\"scroll\"\n                    isInitiallyExpanded={false}\n                  />\n                </td>\n              );\n            },\n          },\n          {\n            objectParameterKey: \"description\",\n            name: \"Info\",\n            customPresentation: (item) => {\n              return (\n                <td>\n                  {item.description ? (\n                    <MarkdownView\n                      markdownParse={mdToJsonParse(item.description)}\n                      markdownParseRenderConfig={{\n                        projectRelativeBaseFolderPath: \"\",\n                        projectRelativeMarkdownFilePath: \"\",\n                      }}\n                      view=\"view\"\n                    />\n                  ) : (\n                    <Div />\n                  )}\n                </td>\n              );\n            },\n          },\n          {\n            objectParameterKey: \"id\",\n            name: \"Actions\",\n            customPresentation: (item) => {\n              const actions: ActionItem[] = [\n                // make example\n\n                type !== \"example\"\n                  ? {\n                      id: 1,\n                      title: \"Make example\",\n                      emoji: \"👻\",\n                      onClick: async () => {\n                        withLoading(\n                          async () => {\n                            const apiResult = await api.upsertDbModel(\n                              \"FunctionExecution\",\n                              { ...item, isExample: true }\n                            );\n\n                            functionExecutionsQuery.refetch();\n\n                            // console.log({ apiResult });\n                          },\n                          item.id,\n                          1\n                        );\n                      },\n                    }\n                  : undefined,\n\n                // make test\n\n                type !== \"test\"\n                  ? {\n                      id: 2,\n                      title: \"Make test\",\n                      emoji: \"🔧\",\n                      onClick: async () => {\n                        withLoading(\n                          async () => {\n                            const apiResult = await api.upsertDbModel(\n                              \"FunctionExecution\",\n                              { ...item, isTest: true }\n                            );\n\n                            functionExecutionsQuery.refetch();\n\n                            // console.log({ apiResult });\n                          },\n                          item.id,\n                          2\n                        );\n                      },\n                    }\n                  : undefined,\n\n                // delete (tests and examples)\n                type !== \"recent\"\n                  ? {\n                      id: 3,\n                      title: \"Remove\",\n                      emoji: \"❌\",\n                      onClick: async () => {\n                        withLoading(\n                          async () => {\n                            const apiResult = await api.upsertDbModel(\n                              \"FunctionExecution\",\n                              {\n                                ...item,\n                                isExample:\n                                  type === \"example\" ? false : item.isExample,\n                                isTest: type === \"test\" ? false : item.isTest,\n                              }\n                            );\n\n                            functionExecutionsQuery.refetch();\n\n                            // console.log({ apiResult });\n                          },\n                          item.id,\n                          3\n                        );\n                      },\n                    }\n                  : undefined,\n\n                // fill in in form in tab 1\n                {\n                  id: 4,\n                  title: \"Use in form\",\n                  emoji: \"📝\",\n                  onClick: () => {\n                    // Go to tab\n                    setCurrentTab(1);\n                    setExecutionId(item.id);\n                    setInitialValues(item.inputParameters);\n                  },\n                },\n                // execute directly\n                {\n                  id: 5,\n                  emoji: \"⚡️\",\n                  title: \"Execute\",\n                  onClick: async () => {\n                    withLoading(\n                      async () => {\n                        const apiFunction = api[\n                          tsFunction.name as keyof typeof api\n                        ] as undefined | ((...parameters: any[]) => any);\n\n                        const apiResult = await apiFunction?.(\n                          ...(item.inputParameters || [])\n                        );\n\n                        functionExecutionsQuery.refetch();\n\n                        // console.log({ apiResult });\n                      },\n                      item.id,\n                      5\n                    );\n                  },\n                },\n              ].filter(notEmpty);\n              return (\n                <td>\n                  {actions.map((action) => {\n                    const isLoading = loading[item.id] === action.id;\n                    return (\n                      <Button\n                        type=\"button\"\n                        onClick={action.onClick}\n                        className=\"hover:bg-blue-500  mr-2 rounded-md p-1\"\n                        textClassName=\"text-xs hover:text-white flex flex-row\"\n                      >\n                        {isLoading ? <FancyLoader /> : \"\"}\n                        <P>\n                          {action.emoji} {action.title}\n                        </P>\n                      </Button>\n                    );\n                  })}\n                </td>\n              );\n            },\n          },\n        ]}\n      />\n    </>\n  );\n}"
  },
  "FunctionLayout": {
    "name": "FunctionLayout",
    "slug": "TsFunction",
    "id": "ayjllglnjfftuxqieyykpyly",
    "description": "",
    "operationName": "search-web",
    "rawText": " () => {\n  const queryPathsQuery = queries.useGetFunctionQueryPaths();\n  const menu = queryPathsQuery.data?.result;\n  return (\n    <AuthenticationLayout\n      // menu props\n      menu={{\n        isLoading: queryPathsQuery.isLoading,\n        webPagesFlat: menu?.flat,\n        webPagesNested: menu?.nested,\n      }}\n      // other\n      nextPage={FunctionPage}\n      pageProps={{}}\n    />\n  );\n}"
  },
  "FunctionPage": {
    "name": "FunctionPage",
    "slug": "TsFunction",
    "id": "ccgvgwqgpvohktcpipkzlhkk",
    "description": "",
    "operationName": "search-web",
    "rawText": " () => {\n  const router = useRouter();\n\n  const fullPath = router.query.paths ? makeArray(router.query.paths) : [];\n\n  const functionName = fullPath.pop();\n  const queryPath = getQueryPath(router.query);\n\n  const tsFunctionQuery = queries.useGetTsFunction(functionName);\n  // todo : add query to tsFunction\n  const { tsFunction } = destructureOptionalObject(\n    tsFunctionQuery.data?.result\n  );\n\n  const functionExecutions =\n    queries.useGetFunctionExecutions(functionName).data?.result || [];\n\n  const renderNavigation = () => {\n    return (\n      <Div className=\"flex flex-row justify-between\">\n        {queryPath.length > 1 ? (\n          <ClickableIcon\n            emoji=\"⬅\"\n            onClick={() => {\n              const parts = queryPath.split(\"/\");\n              parts.pop();\n              const oneFolderUp = parts.join(\"/\");\n              router.push(oneFolderUp.length === 0 ? \"/\" : oneFolderUp);\n            }}\n          />\n        ) : null}\n        <P className=\"text-3xl\">{functionName}</P>\n        <Div />\n      </Div>\n    );\n  };\n\n  const renderPage = () => {\n    if (!tsFunction) {\n      return tsFunctionQuery.isLoading ? (\n        <FancyLoader big />\n      ) : (\n        <P>Select a function to get to work</P>\n      );\n    }\n\n    /**\n  ### Tab 7: Recent executions tab\n  \n  `FunctionExecution[].sort(createdAt).slice(0,100)`\n  \n  Actions for every item:\n  \n  - set `isTest` to true\n  - set `isExample` to true\n  - fill in in form in tab 1\n  - execute directly\n  \n     */\n    const recentTab = {\n      title: \"Recent\",\n      emoji: \"🕰️\",\n      renderTab: () => {\n        return (\n          <FunctionExecutionTable\n            tsFunction={tsFunction}\n            type={\"recent\"}\n            functionExecutions={functionExecutions}\n          />\n        );\n      },\n    };\n\n    const formTab = {\n      title: \"Form\",\n      emoji: \"📝\",\n      renderTab: () => <FormTab tsFunction={tsFunction} />,\n    };\n\n    /** \n  ### Tab 2: Function Docs\n\n  Generate on the fly based on the `TsFunction` (extrahere from docs generation lib)\n\n  */\n    const docsTab = {\n      title: \"Docs\",\n      emoji: \"ℹ️\",\n      renderTab: () => {\n        return (\n          <>\n            <P className=\"text-xl lg:text-4xl w-full\">\n              &nbsp;&nbsp;{tsFunction?.name}\n            </P>\n\n            {tsFunction?.description ? (\n              // TODO: use `props.functionData.tsFunction.operationRelativeTypescriptFilePath` to deterimne markdown file path and folder\n\n              <Div>\n                <MarkdownView\n                  markdownParse={mdToJsonParse(tsFunction.description)}\n                  markdownParseRenderConfig={{\n                    projectRelativeMarkdownFilePath: \"\",\n                    projectRelativeBaseFolderPath: \"\",\n                  }}\n                  view=\"view\"\n                />\n              </Div>\n            ) : null}\n          </>\n        );\n      },\n    };\n\n    /**\n     * TAB 3: Code\n     *\n     * TODO: Can later be replaced with the writer-input for the file of the function, so you can immediately see your coding result in the other tabs...\n     */\n    const codeTab = {\n      title: \"Code\",\n      emoji: \"💻\",\n      renderTab: () => {\n        return tsFunction?.rawText ? (\n          <Div className=\"flex flex-col items-center\">\n            <MarkdownCodeblock\n              text={`const ${tsFunction.name} =${tsFunction.rawText}`}\n              extension=\"ts\"\n              isModeStatic\n              minimalMode=\"full\"\n            />\n\n            <Div className=\"flex flex-col items-center pt-8 gap gap-6\">\n              <P>Wanna start?</P>\n\n              <BigButton\n                title=\"Open in VSCode\"\n                onClick={async () => {\n                  if (!tsFunction.operationName) {\n                    errorToast(\n                      \"Couldn't find which operation this function belongs to, can't open the file\"\n                    );\n                    return;\n                  }\n\n                  const result = await api.vscodeOpen({\n                    files: [\n                      {\n                        operationName: tsFunction.operationName,\n                        operationRelativeFilePath:\n                          tsFunction.operationRelativeTypescriptFilePath,\n                      },\n                    ],\n                  });\n\n                  return;\n                }}\n                emoji=\"👨‍💻\"\n              />\n            </Div>\n          </Div>\n        ) : (\n          \"Code not found\"\n        );\n      },\n    };\n\n    /**\n            ### Tab 4: Exersize tab\n\n            Get all examples of this function, write exersize in markdown (ask Wijnand for more details)\n            */\n\n    const exersizeTab = {\n      title: \"Exersizes\",\n      emoji: \"👶\",\n      renderTab: () => {\n        return \"ex\";\n      },\n    };\n\n    /**\n### Tab 5: Examples Tab\n\n`FunctionExecution[].filter(x.isExample)`\n\nShow `x.exampleDescription` too (markdown)\n\nActions for every item:\n\n- set `isExample` to false\n- set `isTest` to true\n- fill in in form in tab 1\n- execute directly\n\n*/\n\n    const examplesTab = {\n      title: \"Examples\",\n      emoji: \"👻\",\n      renderTab: () => {\n        return (\n          <FunctionExecutionTable\n            tsFunction={tsFunction}\n            type={\"example\"}\n            functionExecutions={functionExecutions}\n          />\n        );\n      },\n    };\n\n    /**\n### Tab 6: Tests Tab\n\n`FunctionExecution[].filter(x.isTest))`\n\nActions for every item:\n\n- set `isTest` to false\n- set `isExample` to true\n- fill in in form in tab 1\n- execute directly\n*/\n\n    const testsTab = {\n      title: \"Tests\",\n      emoji: \"🔧\",\n      renderTab: () => {\n        return (\n          <FunctionExecutionTable\n            tsFunction={tsFunction}\n            type={\"test\"}\n            functionExecutions={functionExecutions}\n          />\n        );\n      },\n    };\n\n    const dataTab = {\n      title: \"Data\",\n      emoji: \"💿\",\n      renderTab: () => {\n        return \"This tab can later show the models that are put under in the doc-comment as being relevant. E.g. if you put 'DATA: JeepType, LocationType' in your function's doc-comment, it would show the CRUD-UI for those models in this tab. Possibly, one tab for every model, or simply one tab for all models and visually make it disabled if there is no data connected to the function...\";\n      },\n    };\n\n    const mediaTab = {\n      title: \"Media\",\n      emoji: \"👥\",\n      renderTab: () => {\n        return (\n          <Div>\n            <Ul>\n              <Li>Show related postables & media-posts</Li>\n              <Li>Create new postable</Li>\n              <Li>\n                Basically, the social-media-ui but just focussed on this\n                function\n              </Li>\n            </Ul>\n          </Div>\n        );\n      },\n    };\n\n    const treeTab = {\n      title: \"Trees\",\n      emoji: \"🌳\",\n      renderTab: () => {\n        return (\n          <Div className=\"w-max h-80\">\n            <Ul>\n              <Li>\n                Show graph with the function in the middle, below all functions\n                that are required for the function (dependencies), above all the\n                functions that require this function (dependents)\n              </Li>\n              <Li>\n                Being able to see this multiple multiple layers deep would be\n                great (configurable).\n              </Li>\n              <Li>\n                Dependencies must be brown (root like) while dependents (up)\n                must be green (leave like)\n              </Li>\n              <Li>\n                Other tree: find other functions that take the output type of\n                this function as its input. Use the output of your\n                FunctionExecutions on \"related\" functions.\n              </Li>\n            </Ul>\n\n            <Test />\n          </Div>\n        );\n      },\n    };\n    return (\n      <Div>\n        {renderNavigation()}\n\n        <Tabs\n          tabs={[\n            codeTab,\n            formTab,\n            //dataTab,\n            recentTab,\n            testsTab,\n            examplesTab,\n            docsTab,\n            //treeTab,\n            //exersizeTab,\n            //mediaTab,\n          ]}\n        />\n      </Div>\n    );\n  };\n\n  return (\n    <Div className=\"pb-4 px-4 w-full\" scroll>\n      {renderPage()}\n    </Div>\n  );\n}"
  },
  "functionWebInitialValues": {
    "name": "functionWebInitialValues",
    "slug": "TsVariable",
    "id": "kukeqilpdkwunasiivdwjqva",
    "description": "",
    "operationName": "search-web"
  },
  "getAllSearchResults": {
    "name": "getAllSearchResults",
    "slug": "TsFunction",
    "id": "kddmrzsxccnxfxvxwheuagxw",
    "description": "Searches filepaths, then links to any `ui-web` that has this file available as a page, or VSCode.\n\nFor this we need to get the `MarkdownReaderPage` and other pages that are available in ui's and see the files they are linked to.\n\nI want to be able to:\n\n- search functions, interfaces, variables\n- search operations\n- search markdown files, anywhere\n- search db-ui models\n\nBut there's more. To make a good serach...\n\nTODO:\n- gather everything i've made before about search",
    "operationName": "search-web",
    "rawText": " async (\n  query: string | null\n): Promise<SearchResult[]> => {\n  const projectRoot = getProjectRoot();\n\n  if (!query || !projectRoot) return [];\n  //  Alter search function to return all results from functions, files and db, and links to there.\n  const functions = Object.keys(sdkFunctionPaths)\n    .map((name) => {\n      const path = sdkFunctionPaths[name as keyof typeof sdkFunctionPaths];\n\n      return { name, path };\n    })\n    .filter((x) => {\n      const names = `${x.name.toLowerCase()} ${humanCase(\n        x.name\n      ).toLowerCase()}`;\n      return names.includes(query.toLowerCase());\n    })\n    .map((x) => {\n      const result: SearchResult = {\n        title: `⚡️ ${x.name}`,\n        description: x.path,\n        url: `/function/${x.name}`,\n      };\n\n      return result;\n    });\n  const files = (\n    await explore({\n      basePath: projectRoot,\n      ignore: [\n        ...generatedFolders,\n        \"db\",\n        \"cloned\",\n        \"backups\",\n        \"bundled\",\n        \"buntest\",\n      ],\n      readmeOnTop: true,\n      search: query || undefined,\n      extension: [\"md\", \"ts\", \"tsx\"],\n    })\n  ).map((x) => {\n    const relativePath = makeRelative(x.path, projectRoot);\n    const result: SearchResult = {\n      title: `${x.isFolder ? \"📁\" : \"📄\"} ${relativePath}`,\n      url: `/files/${relativePath}`,\n    };\n\n    return result;\n  });\n\n  const dbModels = dbModelKeys\n    .filter((x) =>\n      `${x.toLowerCase()} ${humanCase(x).toLowerCase()}`.includes(\n        query.toLowerCase()\n      )\n    )\n    .map((x) => {\n      const result: SearchResult = {\n        title: `🗄 ${x}`,\n        url: `/db/${x}`,\n      };\n      return result;\n    });\n\n  return [...dbModels, ...functions, ...files];\n}"
  },
  "getTimelineItems": {
    "name": "getTimelineItems",
    "slug": "TsFunction",
    "id": "zaeyaxuhrboxxlysogczqott",
    "description": "",
    "operationName": "search-web",
    "rawText": " async () => {\n  const comments = await db.get(\"TsComment\");\n\n  const items = comments\n    .filter((x) => x.types.includes(\"todo\"))\n    .map((x) => {\n      const isMultiLine = x.firstLine !== x.lastLine;\n\n      const operationPath =\n        operations[x.operationName as keyof typeof operations];\n\n      const comment = isMultiLine\n        ? `/**\\n${x.comment}\\n*/\\n\\n${x.rawStatement}`\n        : `// ${x.comment} \\n ${x.rawStatement}`;\n\n      const filePath = operationPath\n        ? path.join(operationPath, x.operationRelativeTypescriptFilePath)\n        : undefined;\n      return {\n        comment,\n        filePath,\n        line: x.firstLine,\n      };\n    });\n\n  return items;\n}"
  },
  "initialEdges": {
    "name": "initialEdges",
    "slug": "TsVariable",
    "id": "blhbgvodggoumbwpmpmravmt",
    "description": "",
    "operationName": "search-web"
  },
  "initialNodes": {
    "name": "initialNodes",
    "slug": "TsVariable",
    "id": "dhoijdfknuruacbzezooyusi",
    "description": "",
    "operationName": "search-web"
  },
  "initialValues": {
    "name": "initialValues",
    "slug": "TsVariable",
    "id": "ndguybmtqpikuyaxlurlhftd",
    "description": "",
    "operationName": "todo-web"
  },
  "mindspaces": {
    "name": "mindspaces",
    "slug": "TsVariable",
    "id": "nfxdthknzbndpxznzriphcii",
    "description": "",
    "operationName": "search-web"
  },
  "quotes": {
    "name": "quotes",
    "slug": "TsVariable",
    "id": "bqtmnxcheckvvrtqabbkqpsv",
    "description": "",
    "operationName": "search-web"
  },
  "ReaderPageLayout": {
    "name": "ReaderPageLayout",
    "slug": "TsFunction",
    "id": "cbdhnxzpquqspwwkduvmjmub",
    "description": "",
    "operationName": "search-web",
    "rawText": " (props: ReaderProps) => {\n  return (\n    <AuthenticationLayout\n      overwriteDefaultPages={[\"signup\"]}\n      nextPage={() => <Div>READERPAGE</Div>}\n      pageProps={props}\n    />\n  );\n}"
  },
  "SearchBar": {
    "name": "SearchBar",
    "slug": "TsFunction",
    "id": "yzbvnkuwwnznkmbkmzehvmbm",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (props: {\n  initialValue?: string;\n  placeholder?: string;\n}) => {\n  const { initialValue, placeholder } = props;\n  const [tempSearch, setTempSearch] = useState(initialValue || \"\");\n\n  const [search, setSearch] = useStore(\"db-crud.search\");\n\n  const go = () => {\n    setSearch(tempSearch);\n  };\n\n  const clearSearch = () => setSearch(\"\");\n\n  return (\n    <Div className=\"rounded-full border border-zinc-700 dark:border-zinc-300 p-1 px-3 text-lg hover:bg-zinc-200 dark:hover:bg-zinc-800 bg-zinc-100 dark:bg-zinc-600 dark flex flex-row max-w-xl mx-4\">\n      {search.length > 0 ? (\n        <Div\n          className={`cursor-pointer pr-2`}\n          onClick={() => {\n            setSearch(\"\");\n            setTempSearch(\"\");\n          }}\n        >\n          🗑\n        </Div>\n      ) : null}\n      <Form\n        onSubmit={(e) => {\n          e.preventDefault();\n          go();\n        }}\n      >\n        <Input\n          placeholder={placeholder || \"Search\"}\n          className=\"flex flex-1 bg-transparent focus:outline-none\"\n          value={tempSearch}\n          onChange={(e) => setTempSearch(e.target.value)}\n        />\n      </Form>\n      <Div\n        className={\n          tempSearch.length === 0 ? \"cursor-default\" : \"cursor-pointer\"\n        }\n        onClick={go}\n      >\n        🔎\n      </Div>\n    </Div>\n  );\n}"
  },
  "searchGetStaticProps": {
    "name": "searchGetStaticProps",
    "slug": "TsFunction",
    "id": "kunxczyyonpkdzxvqldcwess",
    "description": "",
    "operationName": "search-web",
    "rawText": " async (\n  context\n) => {\n  const query = takeFirst(context.params?.query) || null;\n\n  const imagePaths = await fs.readdir(\n    path.join(__dirname, \"../../..\", \"public/headers\")\n  );\n  const searchResults = await getAllSearchResults(query);\n\n  const timelineItems: {\n    comment: string;\n    filePath: string | undefined;\n    line: number;\n  }[] = []; // = await getTimelineItems();\n\n  const props: QueryPageProps = {\n    query,\n    searchResults,\n    imagePaths,\n    timelineItems,\n  };\n\n  return {\n    props,\n  };\n}"
  },
  "SearchResultComponent": {
    "name": "SearchResultComponent",
    "slug": "TsFunction",
    "id": "gpmkybbpqrsttucytrmqrjpe",
    "description": "If you click on a site that up and running, it should startup via pm2 before being redirected there",
    "operationName": "search-web",
    "rawText": " (props: {\n  searchResult: SearchResult;\n  index: number;\n}) => {\n  const { index, searchResult } = props;\n  return (\n    <Div key={`index${index}`}>\n      <ALink href={searchResult.url}>{searchResult.title}</ALink>\n\n      {searchResult.description ? (\n        <Div>{renderMarkdownContent(searchResult.description, {})}</Div>\n      ) : null}\n    </Div>\n  );\n}"
  },
  "SearchResultPage": {
    "name": "SearchResultPage",
    "slug": "TsFunction",
    "id": "wwqyfilgtyjvpjvoqehpmqsh",
    "description": "",
    "operationName": "search-web",
    "rawText": " (props: QueryPageProps) => {\n  const { searchResults } = props;\n  const router = useRouter();\n\n  const query = router.query?.query\n    ? makeArray(router.query.query).join(\"/\")\n    : undefined;\n  return (\n    <Div>\n      <Div className=\"flex w-full justify-between\">\n        <Div\n          className=\"text-3xl p-2 cursor-pointer\"\n          onClick={() => router.push(\"/\")}\n        >\n          🏠\n        </Div>\n        <SearchBar initialValue={query || undefined} />\n        <Div />\n      </Div>\n      {/* \n      <p>\n        <MarkdownContent\n          content={`\nSearch not implemented yet. Soon though! Until then, check out these cool tools:\n\n- **[copy.ai](https://copy.ai)**: writes articles and social media posts for you\n\n- **[perplexity.ai](https://perplexity.ai)**: explains exactly what you want to know by coupling bing search with AI\n\n- **[presentations.ai](https://presentations.ai)**: make slides about any topic without making slides\n\n- **[otter.ai](https://otter.ai)**: record your meeting, transcribe it, and automatically summarise it\n\n- **[clipsai.com](https://clipsai.com)**: long-form content to social media posts\n\n- **[podly.ai](https://podly.ai)**: perfect podcast annotation\n\n- **[ChatGPT](https://chat.openai.com/)**: answers any question\n\nSign up for [our workshop](https://workshop.gptideas.com/) to learn how to automate your job asap!\n`}\n          config={{}}\n        />\n      </p> */}\n      {searchResults?.map((searchResult, index) => {\n        return (\n          <SearchResultComponent\n            key={`s${index}`}\n            index={index}\n            searchResult={searchResult}\n          />\n        );\n      })}\n      <h1>Or try these:</h1>\n      <div className=\"flex flex-row w-full h-40\">\n        <a\n          className=\"bg-orange-700 hover flex flex-1 justify-center items-center hover:bg-orange-500\"\n          href={`https://search.brave.com/search?q=${query}`}\n        >\n          🦁 Brave\n        </a>\n        <a\n          className=\"bg-gray-700 hover flex flex-1 justify-center items-center hover:bg-gray-500\"\n          href={`https://www.google.com/search?igu=1&q=${query}`}\n        >\n          🤖 Google\n        </a>\n      </div>\n    </Div>\n  );\n}"
  },
  "{ StoreProvider, useStore }": {
    "name": "{ StoreProvider, useStore }",
    "slug": "TsVariable",
    "id": "qumdhnvkijeueuwynuxorzhy",
    "description": "",
    "operationName": "tabs"
  },
  "Test": {
    "name": "Test",
    "slug": "TsFunction",
    "id": "zpnjzrcreqexjvwoyrixfsij",
    "description": "",
    "operationName": "search-web",
    "rawText": " () => {\n  return (\n    <Flow\n      renderNode={(item: { todo: string; status: string }) => {\n        return <div />;\n      }}\n      childObject={{\n        status: \"lala\",\n        todo: \"sss\",\n        children: [{ status: \"\", todo: \"\", children: [] }],\n      }}\n    />\n  );\n}"
  },
  "FileWriterPage": {
    "name": "FileWriterPage",
    "slug": "TsFunction",
    "id": "cpkjzyszftfxgqbpeoamgbyi",
    "description": "",
    "operationName": "todo-web",
    "rawText": " () => {\n  const router = useRouter();\n  const paths = router.asPath.slice(1).split(\"?\")[0];\n  const [todoPagesConfig] = useStore(\"todoPagesConfig\");\n  const todoPagesQuery = queries.useGetTodoPages(todoPagesConfig);\n  const webPages = todoPagesQuery.data?.result?.flat;\n  const filePage = webPages?.find((x) => x.queryPath === paths);\n  const folderPages = webPages?.filter((x) => x.queryPath.startsWith(paths));\n\n  const projectRelativeFilePath = filePage?.pageData?.projectRelativeFilePath;\n  if (!projectRelativeFilePath) {\n    if (folderPages?.length) {\n      return (\n        <Div className=\"p-4\">\n          {folderPages.map((item) => {\n            return (\n              <P className=\"my-2\">\n                -{\" \"}\n                <ALink key={item.queryPath} href={item.queryPath}>\n                  {item.menuTitle}\n                </ALink>\n              </P>\n            );\n          })}\n        </Div>\n      );\n    }\n    return <Div>Couldn't find that page</Div>;\n  }\n  return (\n    <WriterLayout>\n      <FileWriter\n        markdownModelName=\"TodoFile\"\n        projectRelativeFilePath={projectRelativeFilePath}\n      />\n    </WriterLayout>\n  );\n}"
  },
  "MyLayout": {
    "name": "MyLayout",
    "slug": "TsFunction",
    "id": "fasvwxxcsuelfuijvksnvery",
    "description": "",
    "operationName": "generative-ui",
    "rawText": " (props: { pageProps: any; nextPage: any }) => {\n  const { nextPage, pageProps } = props;\n  const router = useRouter();\n  // in index, we need this\n  if (router.isReady && router.pathname === \"/\") {\n    const Index = nextPage;\n    return <Index {...pageProps} />;\n  }\n  return (\n    <AuthenticationLayout\n      overwriteDefaultPages={[\"signup\"]}\n      nextPage={nextPage}\n      pageProps={pageProps}\n    />\n  );\n}"
  },
  "TodoMenuHeader": {
    "name": "TodoMenuHeader",
    "slug": "TsFunction",
    "id": "zmirvvzpxsthxppkgianbaoj",
    "description": "",
    "operationName": "todo-web",
    "rawText": " () => {\n  const persons =\n    queries.useGetPublicPersons().data?.result?.map((x) => {\n      return { value: x.id, label: humanCase(x.name) };\n    }) || [];\n\n  const [todoPagesConfig, setTodoPagesConfig] = useStore(\"todoPagesConfig\");\n\n  const recencyOptions = [{ label: \"⏰\", value: \"\" }].concat(\n    todoPagesConfigRecencys.map((x) => {\n      return { value: x, label: humanCase(x) };\n    })\n  );\n  const recencyValue: Item<string> =\n    recencyOptions.find((x) => x.value === todoPagesConfig.recency) ||\n    recencyOptions[0];\n\n  const categoryStackOptions = [\n    { label: \"🧩\", value: \"\" },\n    { label: \"Without category\", value: \"__NO_CATEGORY__\" },\n  ].concat(\n    [\"ideas\", \"backlog\", \"done\", \"codestories\", \"postables\", \"wontdo\"].map(\n      (x) => {\n        return { value: x, label: humanCase(x) };\n      }\n    )\n  );\n\n  const defaultSelectClass =\n    \"text-xs border-gray-300 border rounded-md focus:outline-none bg-transparent h-9\";\n\n  const noCategoryValue =\n    todoPagesConfig.categoryStack?.length === 0\n      ? categoryStackOptions.find((x) => x.value === \"__NO_CATEGORY__\")\n      : undefined;\n\n  const cateogryValue = categoryStackOptions.find(\n    (x) => x.value === todoPagesConfig.categoryStack?.[0]\n  );\n  const categoryStackValue: Item<string> =\n    noCategoryValue || cateogryValue || categoryStackOptions[0];\n\n  const personOptions = [{ label: \"🙋‍♂️\", value: \"\" }].concat(persons);\n\n  const personValue: Item<string> =\n    personOptions.find((x) => x.value === todoPagesConfig.personId) ||\n    personOptions[0];\n\n  return (\n    <Div className=\"flex flex-row flex-wrap gap gap-1 mb-2\">\n      {/* Person filter: assigned to a person of your choice (owner_personSlug) */}\n      <SelectInput\n        className={`${defaultSelectClass} ${\n          todoPagesConfig.personId ? \"\" : \"w-10\"\n        }`}\n        fieldName=\"personId\"\n        config={{}}\n        uniqueFieldId=\"personId\"\n        extra={{ options: personOptions }}\n        value={personValue}\n        onChange={(v) =>\n          setTodoPagesConfig({\n            ...todoPagesConfig,\n            personId:\n              v?.value === \"\" || v?.value === undefined ? undefined : v?.value,\n          })\n        }\n      />\n\n      {/* are in a certain categoryStack: SelectInput with preset (done, ideas, backlog, codestories, postables, etc*/}\n      <SelectInput\n        fieldName=\"categoryStack\"\n        config={{}}\n        className={`${defaultSelectClass} ${\n          todoPagesConfig.categoryStack ? \"\" : \"w-10\"\n        }`}\n        uniqueFieldId=\"categoryStack\"\n        extra={{ options: categoryStackOptions }}\n        value={categoryStackValue}\n        onChange={(v) =>\n          setTodoPagesConfig({\n            ...todoPagesConfig,\n            categoryStack:\n              v?.value === \"\" || v?.value === undefined\n                ? undefined\n                : v?.value === \"__NO_CATEGORY__\"\n                ? []\n                : [v?.value],\n          })\n        }\n      />\n      {/* has a certain recency of updated time:SelectInput */}\n      <SelectInput\n        fieldName=\"recency\"\n        config={{}}\n        className={`${defaultSelectClass} ${\n          todoPagesConfig.recency ? \"\" : \"w-10\"\n        }`}\n        uniqueFieldId=\"recency\"\n        extra={{ options: recencyOptions }}\n        value={recencyValue}\n        onChange={(v) =>\n          setTodoPagesConfig({\n            ...todoPagesConfig,\n            recency:\n              v?.value === \"\"\n                ? undefined\n                : (v?.value as TodoPagesConfig[\"recency\"]),\n          })\n        }\n      />\n      {/* has high priority:ToggleInput */}\n      <ToggleInput\n        config={{}}\n        fieldName=\"highPrio\"\n        uniqueFieldId=\"highPrio\"\n        extra={{ label: todoPagesConfig.priority ? \"High priority\" : \"❗️\" }}\n        className={`${defaultSelectClass} px-1 ${\n          todoPagesConfig.priority ? \"\" : \"\"\n        }`}\n        onChange={(value) => {\n          setTodoPagesConfig({\n            ...todoPagesConfig,\n            priority: value === true ? \"high\" : undefined,\n          });\n        }}\n        value={todoPagesConfig.priority === \"high\" ? true : false}\n      />\n\n      {todoPagesConfig.categoryStack ||\n      todoPagesConfig.personId ||\n      todoPagesConfig.priority ||\n      todoPagesConfig.recency ? (\n        <Div\n          onClick={() => setTodoPagesConfig({})}\n          className={`${defaultSelectClass} px-1 flex items-center justify-center py-1 cursor-pointer w-20`}\n        >\n          🧹 Clear\n        </Div>\n      ) : null}\n    </Div>\n  );\n}"
  },
  "codestoriesGetPages": {
    "name": "codestoriesGetPages",
    "slug": "TsFunction",
    "id": "ommdlyphfswtyakpeiylkpgg",
    "description": "",
    "operationName": "codestorys-node",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n}): Promise<undefined | ReaderWebPage[]> => {\n  const projectRoot = config?.manualProjectRoot || getProjectRoot();\n  if (!projectRoot) return;\n\n  const projectRelativePaths = await getProjectRelativePaths();\n\n  const codestoriesPaths =\n    projectRelativePaths?.filter((x) => x.endsWith(\".codestory.md\")) || [];\n\n  const pages: ReaderWebPage[] = (\n    await Promise.all(\n      codestoriesPaths.map(async (projectRelativeFilePath) => {\n        const absolutePath = path.join(projectRoot, projectRelativeFilePath);\n        const markdownCallToActions: any[] = [];\n        const webMarkdownFile: WebMarkdownFile | null = fs.existsSync(\n          absolutePath\n        )\n          ? await readMarkdownFileToModel(\n              absolutePath,\n              \"codestorys-web\",\n              markdownCallToActions\n            )\n          : null;\n        if (!webMarkdownFile) return;\n\n        const readerWebPage: ReaderWebPage = {\n          pageData: {\n            projectRelativeFilePath,\n            imagePath:\n              webMarkdownFile.headerImage?.absoluteUrl ||\n              webMarkdownFile.headerImage?.relativePath ||\n              null,\n            shortDescription: webMarkdownFile?.headerSubTitle || null,\n            introDescription: webMarkdownFile?.markdown,\n          },\n          queryPath: projectRelativeFilePath.replaceAll(\"/\", \"-\"),\n          isMenuHidden: false,\n          menuTitle:\n            webMarkdownFile?.headerTitle ||\n            webMarkdownFile?.name ||\n            path.parse(projectRelativeFilePath).name,\n        };\n        return readerWebPage;\n      })\n    )\n  ).filter(notEmpty);\n\n  const filteredPages = pages.filter(\n    onlyUnique2<ReaderWebPage>((a, b) => a.queryPath === b.queryPath)\n  );\n\n  return filteredPages;\n}"
  },
  "codestoriesGetStaticPaths": {
    "name": "codestoriesGetStaticPaths",
    "slug": "TsFunction",
    "id": "tkxaeealkcuudcvqmmunorzz",
    "description": "Function that tells Next.js what the pages are that need to be statically generated",
    "operationName": "codestorys-node",
    "rawText": " async (\n  context: GetStaticPathsContext\n) => {\n  const queryPaths = ((await codestoriesGetPages()) || []).map(\n    (x) => x.queryPath\n  );\n\n  // console.log({ paths });\n  if (!queryPaths) {\n    return { paths: [], fallback: \"blocking\" };\n  }\n\n  const staticPaths = queryPaths\n    .filter((x) => x !== \"\")\n    .map((p) => ({ params: { paths: p.split(\"/\") } }));\n\n  return {\n    paths: staticPaths,\n    fallback: \"blocking\",\n  };\n}"
  },
  "codestoriesGetStaticProps": {
    "name": "codestoriesGetStaticProps",
    "slug": "TsFunction",
    "id": "letdadkbcknhobkikiciddbh",
    "description": "",
    "operationName": "codestorys-node",
    "rawText": " async (\n  context: GetStaticPropsContext\n): Promise<{\n  props: MarkdownReaderPageProps;\n}> => {\n  const flat = (await codestoriesGetPages()) || [];\n  return markdownReaderGetStaticPropsFromPages(context, flat, \"codestorys-web\");\n}"
  },
  "copyCopyPairs": {
    "name": "copyCopyPairs",
    "slug": "TsFunction",
    "id": "cnlnuesneobzqvymjoglernw",
    "description": "",
    "operationName": "collect-static-assets",
    "rawText": " (copyPairs: CopyPair[]) => {\n  const copyPromises = copyPairs.map(async (copyPair) => {\n    const absoluteDestinationFolderPath = path.parse(\n      copyPair.absoluteDestinationPath\n    ).dir;\n\n    // first make the folder if not already there\n    if (!fs.existsSync(absoluteDestinationFolderPath)) {\n      await fs.mkdir(absoluteDestinationFolderPath, { recursive: true });\n    }\n\n    await fs.cpAsync(\n      copyPair.absoluteSourcePath,\n      copyPair.absoluteDestinationPath,\n      {\n        preserveTimestamps: true,\n      }\n    );\n  });\n\n  return Promise.all(copyPromises);\n}"
  },
  "copyReaderStaticAssets": {
    "name": "copyReaderStaticAssets",
    "slug": "TsFunction",
    "id": "uazexmyxbimogpxtajgiuzkp",
    "description": "",
    "operationName": "collect-static-assets",
    "rawText": " async (\n  operationBasePath: string,\n  /**\n   * non-reader webPages will be filtered out by checking if the projectRelativeFilePath exists on pageData and has the extension .md\n   */\n  allWebPages: WebPage<unknown>[]\n) => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n\n  const baseDestinationPath = path.join(\n    operationBasePath,\n    \"public\",\n    \"markdown-assets\"\n  );\n\n  if (fs.existsSync(baseDestinationPath)) {\n    //first clean up if it was generated before\n    await fs.rm(baseDestinationPath, { recursive: true });\n  }\n\n  const readerWebPages = allWebPages\n    .map((x) => ({\n      ...x,\n      pageData: x.pageData as null | { [key: string]: any },\n    }))\n    // filter out the WebPages that don't have a filePath ending on .md\n    .filter((x) => x.pageData?.projectRelativeFilePath?.endsWith(\".md\"))\n    .filter((x) =>\n      fs.existsSync(path.join(projectRoot, x.pageData?.projectRelativeFilePath))\n    )\n    .map((x) => x as ReaderWebPage);\n\n  console.log({ readerPagesThatExist: readerWebPages.length });\n  const absoluteAssetPaths =\n    (await findReaderStaticAssets(readerWebPages)) || [];\n\n  console.log({ foundAssetsThatExist: absoluteAssetPaths.length });\n  const copyPairs = absoluteAssetPaths.map((absoluteAssetPath) => {\n    const projectRelativeAssetPath = makeRelative(\n      absoluteAssetPath,\n      projectRoot\n    );\n\n    const absoluteDestinationPath = path.join(\n      baseDestinationPath,\n      projectRelativeAssetPath\n    );\n\n    return { absoluteSourcePath: absoluteAssetPath, absoluteDestinationPath };\n  });\n\n  await copyCopyPairs(copyPairs);\n\n  console.log(`Copied ${copyPairs.length} files into your public folder`);\n\n  // console.log({ copyPairs });\n}"
  },
  "findReaderStaticAssets": {
    "name": "findReaderStaticAssets",
    "slug": "TsFunction",
    "id": "iwghkksiplylsfskerrumyey",
    "description": "markdown-renderer turns a relative link into this: ?mdpath=x&relativePath=y\n\nfor static, we need to turn it into something similar, but we need to guarantee no file collisions. simple!\n\nwe can just take the project-relative file path of the asset, and put it in /public/images in next.js. the final url of the asset in public next.js then becomes `images/[path/to/asset.jpg]`",
    "operationName": "collect-static-assets",
    "rawText": " async (\n  /**\n   * Your markdown pages\n   */\n  readerWebPages: ReaderWebPage[]\n) => {\n  const projectRoot = getProjectRoot();\n\n  if (!projectRoot) return;\n\n  const absoluteAssetPaths = (\n    await Promise.all(\n      readerWebPages.map(async (page) => {\n        const absoluteMarkdownFilePath = path.join(\n          projectRoot,\n          page.pageData.projectRelativeFilePath\n        );\n\n        const assetPaths = await findStaticAssets(absoluteMarkdownFilePath);\n\n        return assetPaths;\n      })\n    )\n  )\n    .flat()\n    .filter(onlyUnique2())\n    .filter(fs.existsSync);\n\n  return absoluteAssetPaths;\n}"
  },
  "findStaticAssets": {
    "name": "findStaticAssets",
    "slug": "TsFunction",
    "id": "umumbyjswoizkfaaltopqecr",
    "description": "Returns the absolute paths of all static assets (embeds and links) in a markdown file of which the path is provided.",
    "operationName": "collect-static-assets",
    "rawText": " async (\n  absoluteMarkdownFilePath: string\n): Promise<string[]> => {\n  if (!fs.existsSync(absoluteMarkdownFilePath)) return [];\n  const content: string = await fs.readFile(absoluteMarkdownFilePath, \"utf8\");\n\n  const relativeEmbeds = findEmbeds(content)\n    .filter((x) => isPathRelative(x.src))\n    .map((x) => x.src);\n\n  const relativeLinks = findLinks(content)\n    .filter(\n      (x) => isPathRelative(x.href)\n      // NB: bit shitty that we can't link to typescript files or pdfs this way, but it's ok, we can embed them. Once needed, this must be improved, not now.\n    )\n    .filter((x) => x.type !== \"text\" && x.type !== \"other\")\n    .map((x) => x.href);\n\n  const absoluteMarkdownFolderPath = getFolderJs(absoluteMarkdownFilePath);\n  const absoluteAssetPaths = [relativeLinks, relativeEmbeds]\n    .flat()\n    .map((relativePath) => path.join(absoluteMarkdownFolderPath, relativePath));\n\n  return absoluteAssetPaths;\n}"
  },
  "addCodestoryToSection": {
    "name": "addCodestoryToSection",
    "slug": "TsFunction",
    "id": "scoirgabjjoxcggwfsxteyqw",
    "description": "",
    "operationName": "make-codestory",
    "rawText": " (\n  sectionContent: string | undefined,\n  mappedObject: { [key: string]: CodespanItemInfo },\n  isDebug?: boolean\n): string | undefined => {\n  if (!sectionContent) return;\n  // For every piece of content find the codespans\n  const codespans = findCodespans(sectionContent);\n\n  const info = codespans\n    .map((word) => {\n      const details = (\n        mappedObject as unknown as {\n          [key: string]: CodespanItemInfo;\n        }\n      )[word];\n\n      if (!details) return;\n\n      // Augment every section with one <details> section for every referred piece of code.\n      return writeCodespanDetails(details);\n    })\n    .filter(notEmpty);\n  if (isDebug) {\n    console.log({ codespans: codespans.length, infos: info.length });\n  }\n\n  return `${sectionContent}${\n    info.length > 0 ? `\\n\\n${info.join(\"\\n\\n\")}\\n` : \"\"\n  }`;\n}"
  },
  "addModelName": {
    "name": "addModelName",
    "slug": "TsFunction",
    "id": "nrzdkbzacelwlcbjrfeofwzq",
    "description": "",
    "operationName": "make-codestory",
    "rawText": " <T extends O>(\n  item: T,\n  modelName: string\n): T & { author?: string } => {\n  return { ...item, slug: modelName, modelName: \"lol\" };\n}"
  },
  "findCodestories": {
    "name": "findCodestories",
    "slug": "TsFunction",
    "id": "opygfaboqcappjwxhuuosyyb",
    "description": "Finds all mdfiles (absolute paths) in /text or /operations that have a frontmatterprop `.isCodestory: true`",
    "operationName": "make-codestory",
    "rawText": " async (): Promise<string[]> => {\n  // open the file\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return [];\n\n  const allMarkdownPaths = await getProjectRelativePaths();\n\n  const frontmatterObject = await getFrontmattersMappedObject(\n    projectRoot,\n    allMarkdownPaths\n  );\n\n  const stories =\n    allMarkdownPaths?.filter((x) => {\n      const frontmatter = frontmatterObject[x];\n      if (!frontmatter) return false;\n\n      const isCodestory = frontmatter.isCodestory === \"true\";\n      return isCodestory;\n    }) || [];\n\n  const files = stories\n    .filter((x) => !x.endsWith(\".codestory.md\"))\n    .map((x) => x);\n\n  return files.map((x) => path.join(projectRoot, x));\n}"
  },
  "makeCodespanMappedObject": {
    "name": "makeCodespanMappedObject",
    "slug": "TsFunction",
    "id": "ivzmwhtgwqlqcrqacbsdifhx",
    "description": "",
    "operationName": "make-codestory",
    "rawText": " async () => {\n  // a mapped object of all TsFunctions, TsInterfaces, Operations\n  const tsVariables = await db.get(\"TsVariable\"); // name -> description\n  const tsInterfaces = await db.get(\"TsInterface\"); // name -> description + rawText\n  const tsFunctions = await db.get(\"TsFunction\"); // name -> description + rawText\n  const operations = await db.get(\"Operation\"); // name -> description\n  const bundleConfigs = await db.get(\"BundleConfig\"); // slugify(name) -> description / gitRepoUrl\n\n  const modelItemsArrays = [\n    tsVariables.map((x) => addModelName(x, \"TsVariable\")),\n    tsInterfaces.map((x) => addModelName(x, \"TsInterface\")),\n    tsFunctions.map((x) => addModelName(x, \"TsFunction\")),\n    operations.map((x) => addModelName(x, \"Operation\")),\n    bundleConfigs.map((x) => addModelName(x, \"BundleConfig\")),\n  ];\n\n  // duplicates will overwrite each other, so let's do the most important ones last\n  const mappedObject = mergeObjectsArray(\n    modelItemsArrays.flat().map((item) => {\n      return {\n        [item.name]: getSubsetFromObject(item as AugmentedAnyModelType, [\n          \"name\",\n          \"slug\",\n          \"id\",\n          \"description\",\n          \"operationName\",\n          \"rawText\",\n          \"gitRepoUrl\",\n        ]),\n      };\n    })\n  );\n\n  const result = await writeToAssets(\n    __filename,\n    mappedObject,\n    \"codespan-mapped-object-small.json\",\n    true\n  );\n}"
  },
  "makeCodestory": {
    "name": "makeCodestory",
    "slug": "TsFunction",
    "id": "lyqqphiqiydyqfknkgkqegtf",
    "description": "no real reason to do this from text to text, let's do path to path here",
    "operationName": "make-codestory",
    "rawText": " async (\n  absolutePath: string,\n  mappedObject: { [key: string]: CodespanItemInfo },\n  isDebug?: boolean\n): Promise<undefined | string> => {\n  //   Use MarkdownParse to split up the markdown into different headers with their content\n  const markdownParse = await readMarkdownFile(absolutePath);\n  if (!markdownParse) return;\n\n  const newMarkdownParse = mapMarkdownParseSections(markdownParse, (content) =>\n    addCodestoryToSection(content, mappedObject, isDebug)\n  );\n\n  const newString = markdownParseToMarkdownStringFromContent(newMarkdownParse);\n\n  const parse = path.parse(absolutePath);\n\n  const newPath = path.join(parse.dir, `${parse.name}.codestory${parse.ext}`);\n\n  await fs.writeFile(newPath, newString || \"\", \"utf8\");\n  return newPath;\n}"
  },
  "mapChunkRecursively": {
    "name": "mapChunkRecursively",
    "slug": "TsFunction",
    "id": "bxwydjbicnbugengheyflagd",
    "description": "",
    "operationName": "make-codestory",
    "rawText": " (\n  chunk: MarkdownChunk,\n  mapFunction: (content?: string) => string | undefined\n) => {\n  const content = mapFunction(chunk.content);\n  const children = chunk.children?.map((chunk) =>\n    mapChunkRecursively(chunk, mapFunction)\n  );\n\n  const newChunk: MarkdownChunk = {\n    ...chunk,\n    content,\n    children,\n  };\n\n  return newChunk;\n}"
  },
  "mapMarkdownParseSections": {
    "name": "mapMarkdownParseSections",
    "slug": "TsFunction",
    "id": "muovfnyjyjysjeniewadzeze",
    "description": "",
    "operationName": "make-codestory",
    "rawText": " (\n  markdownParse: MarkdownParse,\n  mapFunction: (content?: string) => string | undefined\n): MarkdownParse => {\n  const content = markdownParse.content?.map((chunk) =>\n    mapChunkRecursively(chunk, mapFunction)\n  );\n\n  const newMarkdownParse: MarkdownParse = { ...markdownParse, content };\n  return newMarkdownParse;\n}"
  },
  "test": {
    "name": "test",
    "slug": "TsFunction",
    "id": "dbiyglmfxjrooiyuyodifyhi",
    "description": "",
    "operationName": "rebuild-operation",
    "rawText": " async () => {}"
  },
  "writeAllCodestoriesCli": {
    "name": "writeAllCodestoriesCli",
    "slug": "TsFunction",
    "id": "oudfyipgecgexwhgfwjlpofe",
    "description": "Arguments:none",
    "operationName": "make-codestory",
    "rawText": " async () => {\n  writeAllCodestories(true);\n}"
  },
  "writeAllCodestories": {
    "name": "writeAllCodestories",
    "slug": "TsFunction",
    "id": "varjerzuinoiowxxzijgmxxj",
    "description": "---\nrunEveryPeriod: 5-minutes\n---",
    "operationName": "make-codestory",
    "rawText": " async (isDebug?: boolean) => {\n  const files = await findCodestories();\n\n  await makeCodespanMappedObject();\n\n  const mappedObject = await readJsonFile<{ [key: string]: CodespanItemInfo }>(\n    path.join(__dirname, \"..\", \"assets\", \"codespan-mapped-object-small.json\")\n  );\n\n  if (!mappedObject) {\n    console.log(\"Couldn't find mapped obj\");\n    return;\n  }\n\n  const codestoryPaths = await oneByOne(files, (absolutePath) =>\n    makeCodestory(absolutePath, mappedObject, isDebug)\n  );\n  if (isDebug) {\n    console.log({ codestoryPaths });\n  }\n}"
  },
  "writeCodespanDetails": {
    "name": "writeCodespanDetails",
    "slug": "TsFunction",
    "id": "gptignolsrlpytvbiphkkmgi",
    "description": "",
    "operationName": "make-codestory",
    "rawText": " (\n  codespanItemInfo: CodespanItemInfo\n): string => {\n  // Ensure this section contains not only the description, but also the code of the referred interface/function/variable, and a link to a website where you find the real-time docs.\n\n  const description = codespanItemInfo.description;\n  const githubRepo = codespanItemInfo.gitRepoUrl\n    ? `[Find more on GitHub](${codespanItemInfo.gitRepoUrl})`\n    : undefined;\n\n  const rawText = codespanItemInfo.rawText\n    ? `\\`\\`\\`tsx\\n${codespanItemInfo.rawText}\\n\\`\\`\\``\n    : undefined;\n\n  const sections = [description, githubRepo, rawText]\n    .filter(notEmpty)\n    .join(\"\\n\\n\\n\\n\");\n\n  const hasContent = sections.trim().length > 0;\n\n  return `<details>\n  \n  <summary>${codespanItemInfo.name}</summary>\n  \n  ${\n    hasContent\n      ? sections\n      : \"I didn't write a good description for this yet. Please let me know if you want to know more\"\n  }\n  \n  </details>\n  `;\n}"
  },
  "addEmojiToEveryWord": {
    "name": "addEmojiToEveryWord",
    "slug": "TsFunction",
    "id": "zixysqyijzoomrhcbcdhsivf",
    "description": "Emojify++",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, prompt_projectRelativePath: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"add-emoji-to-every-word\",\n      contextContent,\nprompt_projectRelativePath\n    });\n\n    return result;\n\n  }"
  },
  "addStatement": {
    "name": "addStatement",
    "slug": "TsFunction",
    "id": "vusagyixnvdqkzjlhoxbfhud",
    "description": "Adds `Statement`",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  /**\n   * MUST be an english statement\n   */\n  statement: string,\n  /**\n   * defaults to 0.5\n   */\n  importancy?: number,\n  /**\n   * defaults to 1\n   */\n  agreement?: number\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  if (importancy !== undefined && (importancy < 0 || importancy > 1)) {\n    return {\n      isSuccessful: false,\n      message: \"Importancy, when filled in, must be between [0,1]\",\n    };\n  }\n  if (agreement !== undefined && (agreement < 0 || agreement > 1)) {\n    return {\n      isSuccessful: false,\n      message: \"Agreement, when filled in, must be between [0,1]\",\n    };\n  }\n\n  const newStatement: Creation<Statement> = {\n    description: statement,\n    importancy: importancy === undefined ? 0.5 : importancy,\n    agreement: agreement === undefined ? 1 : agreement,\n  };\n\n  const upsertResult = await db.upsert(\"Statement\", newStatement, {\n    onlyInsert: true,\n  });\n\n  return {\n    isSuccessful: upsertResult?.isSuccesful || false,\n    message: upsertResult?.isSuccesful\n      ? \"Statement added\"\n      : upsertResult?.message,\n  };\n}"
  },
  "addWord": {
    "name": "addWord",
    "slug": "TsFunction",
    "id": "ukvllvognayvzyzgligcfyhe",
    "description": "Adds word either to the WordMatrix or to the WordCombination database model",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  /**\n   * MUST be an english word or word combination written in the latin alphabet\n   */\n  word: string,\n  description?: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  // if the word is a combination of multiple words (e.g. large-language-model is large +language + model), it should be added as a word combination with a description\n  // const wordMatrixs = await db.get(\"WordMatrix\");\n  // potentially we should check here if the word already exists or if the word combination already exists, but this is not required as long as we use `.onlyInsert: true`\n  const parts = lowerCaseArray(word);\n\n  if (parts.length > 1) {\n    const newWordCombination: Creation<WordCombination> = {\n      name: kebabCase(word),\n      description: description || \"\",\n      wordMatrixSlugs: parts,\n    };\n\n    const upsertResult = await db.upsert(\n      \"WordCombination\",\n      newWordCombination,\n      { onlyInsert: true }\n    );\n\n    return {\n      isSuccessful: upsertResult?.isSuccesful || false,\n      message: upsertResult?.isSuccesful\n        ? \"Added word combination\"\n        : upsertResult?.message,\n    };\n  }\n\n  const name = parts[0];\n\n  const newWord: Creation<WordMatrix> = {\n    name,\n    description,\n    english: { latin: name },\n  };\n\n  const upsertResult = await db.upsert(\"WordMatrix\", newWord, {\n    onlyInsert: true,\n  });\n\n  return {\n    isSuccessful: upsertResult?.isSuccesful || false,\n    message: upsertResult?.isSuccesful ? \"Added word\" : upsertResult?.message,\n  };\n}"
  },
  "biggestFunctionName": {
    "name": "biggestFunctionName",
    "slug": "TsFunction",
    "id": "jofqnqnnuyhvknycnjrjaskv",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"biggest-function-name\",\n      contextContent\n    });\n\n    return result;\n\n  }"
  },
  "checkQueue": {
    "name": "checkQueue",
    "slug": "TsFunction",
    "id": "gprhughmjlaemgomnnlniesc",
    "description": "---\nrunEveryPeriod: minute\n---\n\n\nCron that runs every minute for executing queue items.\n\nRegular items: It will execute max `MAX_REGULAR_ITEMS_AMOUNT`\n\nBrowser items: You can set the amount of tabs it should have as a limit, and it will keep the tabs open afterwards, but after the thing is done it will just remove the item from the `Queue`.\n\nHeavy items: functions with `.isHeavy: true` inside. Will execute max 1 every minute if the system isn't busy already.\n\n- sort on priority high first\n- filter out internet items if we are offline\n- find single heavy item if it's there and if we're not busy\n- find up to N (amount tabs available) queue items that require browser",
    "operationName": "ai-functions-node",
    "rawText": " async () => {\n  const isOffline = !(await isOnline());\n  const isBusy = await isSystemBusy();\n\n  const startTime = Date.now();\n\n  const allQueueItems = (await db.get(\"Queue\")).sort((a, b) =>\n    a.priority === \"high\" ? 1 : -1\n  );\n\n  /**\n   * Light queue items we can do asap\n   */\n  const regularQueueItems = allQueueItems\n    .filter((x) => {\n      const fn = sdk[x.functionName as keyof typeof sdk] as\n        | ProjectWatcher\n        | undefined;\n\n      if (isOffline && fn?.config?.isInternetRequired) {\n        return false;\n      }\n      if (fn?.config?.isHeavy || fn?.config?.isBrowserRequired) {\n        return false;\n      }\n      return true;\n    })\n    .slice(0, MAX_REGULAR_ITEMS_AMOUNT);\n\n  /**\n   * Only get heavy items if system isn't busy\n   */\n  const heavyItems = isBusy\n    ? []\n    : allQueueItems.filter((x) => {\n        const fn = sdk[x.functionName as keyof typeof sdk] as\n          | ProjectWatcher\n          | undefined;\n\n        return (\n          fn?.config?.isHeavy && (!isOffline || !fn?.config?.isBrowserRequired)\n        );\n      });\n\n  const idlePages = (await db.get(\"BrowserPage\")).filter((p) => p.isIdle);\n  const browserQueueItems = allQueueItems.filter((x) => {\n    const fn = sdk[x.functionName as keyof typeof sdk] as\n      | ProjectWatcher\n      | undefined;\n\n    return (\n      fn?.config?.isBrowserRequired &&\n      (!isOffline || !fn?.config?.isBrowserRequired)\n    );\n  });\n  const browserRunnableNowAmount = 1; //idlePages.length\n  const browserItemsToExecute = browserQueueItems.slice(\n    0,\n    browserRunnableNowAmount\n  );\n\n  const queueItemsToExecute = [\n    ...heavyItems,\n    ...browserItemsToExecute,\n    ...regularQueueItems,\n  ].filter(notEmpty);\n\n  if (queueItemsToExecute.length === 0) {\n    console.log(\"Checking queue: No queue\", {\n      isBusy,\n      isOffline,\n      allQueueItems: allQueueItems.length,\n    });\n    return;\n  }\n\n  const lateQueueItemsToNotify = allQueueItems.filter(\n    (x) =>\n      x.notifyLateAfterSeconds &&\n      Date.now() - x.createdAt > x.notifyLateAfterSeconds * 1000 &&\n      !x.hasNotifiedLate\n  );\n\n  // 1. check how many chrome tabs are available (according to OS settings / memory limit)\n\n  if (browserRunnableNowAmount < lateQueueItemsToNotify.length) {\n    //email the ones that won't be executed\n    console.log(\n      {\n        browserRunnableNowAmount,\n        lateQueueItemsToNotify: lateQueueItemsToNotify.length,\n      },\n      \"SHOULD EMAIL SOME THAT CAN'T BE EXECUTED AND PUT THEM ON NOTIFIED WITH ETA\"\n    );\n  }\n\n  // 2. check how many queue items can be executed now, and sort by importancy\n  // NB: limit to 1 for now to test if that works\n\n  console.log(`Executing ${queueItemsToExecute.length} from queue, one by one`);\n\n  // 3. take the ones that are most important and execute those, only for a minute!\n\n  await oneByOne(queueItemsToExecute, async (queue) => {\n    const fn = sdk[queue.functionName as keyof typeof sdk] as\n      | ((...parameters: any[]) => any)\n      | undefined;\n\n    if (!fn) return;\n\n    if (Date.now() > startTime + 60000) {\n      // time's up! skip the rest, because this function starts again.\n      return;\n    }\n\n    await fn(...queue.parameters);\n\n    // after it's done, remove from queue\n    const removeResult = await db.remove(\n      \"Queue\",\n      (item) => queue.id === item.id\n    );\n  });\n}"
  },
  "cleanup": {
    "name": "cleanup",
    "slug": "TsFunction",
    "id": "httgidcypjtrkvhfbkuudalf",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"cleanup\",\n      contextContent\n    });\n\n    return result;\n\n  }"
  },
  "controlChatGptCli": {
    "name": "controlChatGptCli",
    "slug": "TsFunction",
    "id": "cvfupncympwopgvykibicwde",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async () => {\n  const promptArray = process.argv.slice(2);\n  const noHeadless = promptArray[0] === \"show\";\n  const prompt = noHeadless\n    ? promptArray.slice(1).join(\" \")\n    : promptArray.join(\" \");\n  console.log({ noHeadless, prompt });\n  const result = await controlChatGpt(prompt, noHeadless);\n  console.log({ result });\n  return;\n}"
  },
  "controlChatGptWrapper": {
    "name": "controlChatGptWrapper",
    "slug": "TsFunction",
    "id": "azxnuhiqyiozrrsmwheobhaa",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  prompt: string,\n  isHeadless: boolean | undefined,\n  thread: string | undefined,\n  controller: \"playwright\" | \"puppeteer\" | \"faker\"\n): Promise<ProcessPromptFunctionResult> => {\n  const result: ProcessPromptFunctionResult =\n    controller === \"playwright\"\n      ? await controlChatGpt(prompt, isHeadless)\n      : controller === \"puppeteer\"\n      ? await openAIChat({ prompt, isHeadless, thread })\n      : {\n          isSuccessful: true,\n          message: \"Done test\",\n          result: {\n            text: \"Lorum ipsum lorum ipsum lorum ipsum lorum ipsum lorum ipsum lorum ipsum lorum ipsum\",\n            thread: \"\",\n          },\n        };\n\n  return result;\n}"
  },
  "controlChatGpt": {
    "name": "controlChatGpt",
    "slug": "TsFunction",
    "id": "zreugibtzkygynrpocaunufc",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  prompt: string,\n  headless?: boolean\n): Promise<ProcessPromptFunctionResult> => {\n  const api = new ChatGPTAPI({ headless });\n  // open chromium and wait until you've logged in\n  await api.init({ auth: \"blocking\" });\n  // send a message and wait for the response\n  const response = await api.sendMessage(prompt);\n  api.close();\n  return {\n    isSuccessful: true,\n    message: \"Done\",\n    result: { thread: \"\", text: response },\n  };\n}"
  },
  "deletePromptResult": {
    "name": "deletePromptResult",
    "slug": "TsFunction",
    "id": "nlgssomncnbuxiedfqfdwwgb",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  projectRelativePath: string,\n  id: string\n) => {\n  const resultPath = await getContextualPromptResultJsonFilePath(\n    projectRelativePath\n  );\n\n  if (!resultPath) return { isSuccessful: false };\n\n  const result = await alterJsonMultiple(\n    {\n      absolutePath: resultPath,\n      modelName: \"ContextualPromptResult\",\n      projectRelativePath: resultPath,\n      operationName: \"\",\n    },\n    (old) => {\n      return {\n        newStoredData: old.filter((item) => (item.id === id ? false : true)),\n        amountRemoved: 1,\n      };\n    }\n  );\n\n  return { isSuccessful: result.amountRemoved === 1 };\n}"
  },
  "developersQuote": {
    "name": "developersQuote",
    "slug": "TsFunction",
    "id": "ztihrkruptvjtndqkgbadhij",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (selectionContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"developers-quote\",\n      selectionContent\n    });\n\n    return result;\n\n  }"
  },
  "diaryToInstagram": {
    "name": "diaryToInstagram",
    "slug": "TsFunction",
    "id": "ylbdivgpdhugzicdgpbqjozt",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (selectionContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"diary-to-instagram\",\n      selectionContent\n    });\n\n    return result;\n\n  }"
  },
  "documentationWriting": {
    "name": "documentationWriting",
    "slug": "TsFunction",
    "id": "xhbvwmmyoflqyjjnxfmspfsn",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"documentation-writing\",\n      contextContent\n    });\n\n    return result;\n\n  }"
  },
  "emojiAugmentation": {
    "name": "emojiAugmentation",
    "slug": "TsFunction",
    "id": "xivsetbwbxmdjyjwbqivdngh",
    "description": "Emojify",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, prompt_projectRelativePath: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"emoji-augmentation\",\n      contextContent,\nprompt_projectRelativePath\n    });\n\n    return result;\n\n  }"
  },
  "explainInDutch": {
    "name": "explainInDutch",
    "slug": "TsFunction",
    "id": "dzmwngcjzqormhhfcnwupfvs",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"explain-in-dutch\",\n      contextContent\n    });\n\n    return result;\n\n  }"
  },
  "explainInNepali": {
    "name": "explainInNepali",
    "slug": "TsFunction",
    "id": "sckaazfuwutotyurfzmqsxzn",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"explain-in-nepali\",\n      contextContent\n    });\n\n    return result;\n\n  }"
  },
  "explainInPortuguese": {
    "name": "explainInPortuguese",
    "slug": "TsFunction",
    "id": "peudnlrycbafbsfrdlysancf",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"explain-in-portuguese\",\n      contextContent\n    });\n\n    return result;\n\n  }"
  },
  "explainLineByLine": {
    "name": "explainLineByLine",
    "slug": "TsFunction",
    "id": "rgwjntzofucyqxsersxhpykx",
    "description": "Explain line-by-line",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"explain-line-by-line\",\n      contextContent\n    });\n\n    return result;\n\n  }"
  },
  "explain": {
    "name": "explain",
    "slug": "TsFunction",
    "id": "mofqxfcbqltygewldckuitca",
    "description": "🤔 Explain",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, selectionContent: string, prompt_projectRelativePath: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"explain\",\n      contextContent,\nselectionContent,\nprompt_projectRelativePath\n    });\n\n    return result;\n\n  }"
  },
  "fixGrammarAndSpellingMistakes": {
    "name": "fixGrammarAndSpellingMistakes",
    "slug": "TsFunction",
    "id": "ahjtidxemvuuayicotgkcfqr",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"fix-grammar-and-spelling-mistakes\",\n      contextContent\n    });\n\n    return result;\n\n  }"
  },
  "followUpQuestions": {
    "name": "followUpQuestions",
    "slug": "TsFunction",
    "id": "mgysnelwhgdpiwbruvdvvcaq",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"follow-up-questions\",\n      \n    });\n\n    return result;\n\n  }"
  },
  "getCategoriesTest": {
    "name": "getCategoriesTest",
    "slug": "TsFunction",
    "id": "ifzbwntkwjwichmmtojljtol",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async () => {\n  const result = await getContextualPromptCategories();\n\n  writeToAssets(__filename, result, \"contextual-prompt-categories.json\");\n}"
  },
  "getContextualPromptCategories": {
    "name": "getContextualPromptCategories",
    "slug": "TsFunction",
    "id": "xroqjypxrcvqbhaatgeoifbj",
    "description": "Pretty cool stuff!\n\nI've shown a way to count all nested categories and make a child object based on that\n\nTODO:\n\n- Currently, only supports unique category names due to not checking the full stack\n- needs to be formalised, generalised\n\nAnother, possibly more direct way, would be to traverse the filesystem, in the case of `fs-orm`, because we have files for every item in json-single.",
    "operationName": "ai-functions-node",
    "rawText": " async () => {\n  const contextualPrompts = await db.get(\"ContextualPrompt\");\n\n  const stackCount = contextualPrompts.reduce((stackCount, current) => {\n    // get the stack for this contextualPrompt\n    const stack: string[] | undefined = current.categoryStack;\n\n    if (!stack || stack.length === 0) {\n      const already = stackCount.__root;\n      return {\n        ...stackCount,\n        __root: already ? already + 1 : 1,\n      };\n    }\n\n    const everyStackPart: string[] = stack.map((_, index, array) => {\n      const stackUntilHere = array.slice(0, index + 1).join(\".\");\n      return stackUntilHere;\n    });\n\n    const newStackCount = everyStackPart.reduce((stackCount, stackPart) => {\n      const already = stackCount[stackPart];\n      return {\n        ...stackCount,\n        [stackPart]: already ? already + 1 : 1,\n      };\n    }, stackCount);\n\n    return newStackCount;\n  }, {} as StackCount);\n\n  // now, let's make a childObject out of that\n\n  const { __root, ...stackCountWithoutRoot } = stackCount;\n\n  const categories = Object.keys(stackCountWithoutRoot)\n    .map((key) =>\n      getObjectForkKeyRecursively(stackCount, key, key, contextualPrompts)\n    )\n    .filter(notEmpty);\n\n  const rootCategoryChildObject: CategoryChildObject = {\n    category: \"root\",\n    categoryStack: [],\n    count: __root + sum(categories.map((x) => x.count)),\n    children: categories,\n  };\n\n  return rootCategoryChildObject;\n}"
  },
  "getContextualPromptResultJsonFilePath": {
    "name": "getContextualPromptResultJsonFilePath",
    "slug": "TsFunction",
    "id": "dnyghhcufpwgcjaytwadvtje",
    "description": "Calculates path where the result json index is supposed to be",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  projectRelativePath?: string\n) => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n  const prompt_absolutePath = projectRelativePath\n    ? path.join(projectRoot, projectRelativePath)\n    : undefined;\n\n  const exists = prompt_absolutePath\n    ? fs.existsSync(prompt_absolutePath)\n    : undefined;\n\n  const stats =\n    exists && prompt_absolutePath\n      ? await fs.stat(prompt_absolutePath)\n      : undefined;\n  const isFolder = stats ? stats.isDirectory() : false;\n  const isFile = stats ? stats.isFile() : false;\n  const pathParse = prompt_absolutePath\n    ? path.parse(prompt_absolutePath)\n    : undefined;\n\n  const contextualPromptResultsJsonPath =\n    pathParse && isFile\n      ? path.join(\n          pathParse.dir,\n          \".index\",\n          pathParse.name,\n          \"prompt-results.json\"\n        )\n      : isFolder && prompt_absolutePath\n      ? path.join(prompt_absolutePath, \".index\", \"prompt-results.json\")\n      : undefined;\n\n  return contextualPromptResultsJsonPath;\n}"
  },
  "getContextualPrompt": {
    "name": "getContextualPrompt",
    "slug": "TsFunction",
    "id": "cscisanbaedzgbbihexbegqs",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  contextualPromptSlug: string | undefined,\n  customPromptContent: string | undefined,\n  saveNewPromptWithName: string | null,\n  contextType: FileType | undefined\n): Promise<(Creation<ContextualPrompt> & { slug: string }) | undefined> => {\n  if (contextualPromptSlug) {\n    const contextualPrompts = await db.get(\"ContextualPrompt\");\n\n    const contextualPrompt = contextualPrompts.find(\n      (x) => x.slug === contextualPromptSlug\n    );\n\n    if (!contextualPrompt) {\n      return undefined;\n    }\n\n    return contextualPrompt;\n  }\n\n  if (!customPromptContent || customPromptContent.length === 0) {\n    return undefined;\n  }\n\n  const isNew = saveNewPromptWithName && saveNewPromptWithName.length > 0;\n\n  // console.log({ saveNewPromptWithName, isNew });\n  const name = isNew ? saveNewPromptWithName : generateId();\n  const newContextualPrompt: Creation<ContextualPrompt> & { slug: string } = {\n    name,\n    slug: slugify(name),\n    promptContent: customPromptContent,\n    contextType: [contextType || \"text\"],\n    model: \"chat-gpt\",\n    usesContext: customPromptContent?.includes(\"%context\"),\n    usesSelection: customPromptContent?.includes(\"%selection\"),\n    usesAnyContext: customPromptContent?.includes(\"%any\"),\n  };\n\n  if (isNew) {\n    await db.upsert(\"ContextualPrompt\", newContextualPrompt);\n  }\n\n  return newContextualPrompt;\n}"
  },
  "getObjectForkKeyRecursively": {
    "name": "getObjectForkKeyRecursively",
    "slug": "TsFunction",
    "id": "iimbxesmmvrgczbacelemjle",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " (\n  stackCount: StackCount,\n  key: string,\n  originalKey: string,\n  items: ContextualPrompt[]\n): CategoryChildObject | undefined => {\n  const categoryStack = key.split(\".\");\n\n  if (categoryStack.length !== 1) return;\n\n  const firstCategory = categoryStack[0];\n\n  //get all children:\n\n  //1) find all keys that start with firstCategory\n  const childrenKeys = Object.keys(stackCount).filter((key) =>\n    key.startsWith(`${firstCategory}.`)\n  );\n\n  //2) remove the firstCategory from the keys\n  const strippedKeys = childrenKeys.map((key) =>\n    key.replace(`${firstCategory}.`, \"\")\n  );\n\n  // create strippedStackCount\n  const strippedStackCount = strippedKeys.reduce((newStackCount, key) => {\n    return { ...newStackCount, [key]: stackCount[`${firstCategory}.${key}`] };\n  }, {} as StackCount);\n\n  //3) insert into this same function\n  const categoryChildren = strippedKeys\n    .map((strippedKey, index) =>\n      getObjectForkKeyRecursively(\n        strippedStackCount,\n        strippedKey,\n        childrenKeys[index],\n        items\n      )\n    )\n    .filter(notEmpty);\n\n  const itemChildren = items\n    .filter(\n      (x) =>\n        x.categoryStack &&\n        categoryStack[categoryStack.length - 1] ===\n          x.categoryStack[x.categoryStack.length - 1]\n    )\n    .map((item) => {\n      const { categoryStack, description, name, title, pricing } = item;\n      const object: CategoryChildObject = omitUndefinedValues({\n        categoryStack: categoryStack!,\n        count: 1,\n        description,\n        name,\n        title,\n        pricing,\n      });\n      return object;\n    });\n\n  //  console.log({ itemChildren, categoryStack });\n\n  const children = categoryChildren.concat(itemChildren);\n\n  const object: CategoryChildObject = {\n    category: firstCategory,\n    categoryStack,\n    count: stackCount[firstCategory],\n  };\n\n  if (children.length) object.children = children;\n\n  return object;\n}"
  },
  "getToolFunctions": {
    "name": "getToolFunctions",
    "slug": "TsFunction",
    "id": "csznhewxxmgptwwcbslwgwgf",
    "description": "Returns all tool functions to the frontend",
    "operationName": "ai-functions-node",
    "rawText": " async (): Promise<TsFunction[]> => {\n  const tsFunctions = await db.get(\"TsFunction\");\n\n  getPublicBundleConfig();\n  const toolFunctions = tsFunctions.filter((x) => {\n    const fn = sdk[x.name as keyof typeof sdk] as ApiFunction | undefined;\n    const isTool = fn && typeof fn === \"function\" && fn.domain;\n    return isTool;\n  });\n\n  return toolFunctions;\n}"
  },
  "gptIdeasRegisterWithContext": {
    "name": "gptIdeasRegisterWithContext",
    "slug": "TsFunction",
    "id": "wkchieyjmraaylsgxrdvmotg",
    "description": "TODO: move to gptideas backend package",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  functionContext: FunctionContext,\n  name: string,\n  email: string,\n  tier: \"free\" | \"indie\" | \"startup\" | \"sponsor\",\n  newsletter: \"daily\" | \"weekly\" | \"unsubscribe\",\n  message?: string\n) => {\n  const username = email.split(\"@\")[0] + Math.round(Math.random() * 999);\n\n  const password = generateId();\n\n  // only supported for now\n  const method: AuthenticationMethodMethod = \"usernamePassword\";\n\n  const addDeviceAuthResult = await addDeviceAuthenticationMethodWithContext(\n    functionContext,\n    method,\n    username,\n    password\n  );\n\n  const addDeviceEmailAuthResult =\n    await addDeviceAuthenticationMethodWithContext(\n      functionContext,\n      \"email\",\n      email\n    );\n\n  console.log({ addDeviceEmailAuthResult });\n\n  // console.log({ addDeviceAuthResult });\n  const { functionContext: newFunctionContext, authenticationMethod } =\n    addDeviceAuthResult;\n\n  if (!authenticationMethod?.isAuthenticated || !newFunctionContext) {\n    console.log(\"NOT AUTHENTICATED AFTER ADDING DEVICE\", {\n      authenticationMethod,\n      newFunctionContext,\n    });\n    return { isSuccessful: false, message: message || \"Strange\" };\n  }\n\n  const signupResult = await signupWithContext(functionContext, {\n    name,\n    slug: slugify(name),\n    amountAuthenticationMethodsRequired: 1,\n    authorizations: [],\n    requiredAuthenticationMethods: null,\n  });\n\n  const upsertResult = await db.upsert(\"GptIdeasUser\", {\n    email,\n    newsletter,\n    tier,\n  });\n\n  return {\n    isSuccessful: signupResult.isSuccessful,\n    message: signupResult.message,\n  };\n}"
  },
  "haiku": {
    "name": "haiku",
    "slug": "TsFunction",
    "id": "wmalfaccoxprpxoesurgnzgd",
    "description": "Write a Haiku",
    "operationName": "ai-functions-node",
    "rawText": " async (anyContext: string, prompt_projectRelativePath: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"haiku\",\n      anyContext,\nprompt_projectRelativePath\n    });\n\n    return result;\n\n  }"
  },
  "hookOneliners": {
    "name": "hookOneliners",
    "slug": "TsFunction",
    "id": "zzlcbrfjfsnrbxrofricgzxv",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"hook-oneliners\",\n      \n    });\n\n    return result;\n\n  }"
  },
  "improveCode": {
    "name": "improveCode",
    "slug": "TsFunction",
    "id": "agjegrwrjrisfkrqslgikvvj",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"improve-code\",\n      contextContent\n    });\n\n    return result;\n\n  }"
  },
  "investorPitch": {
    "name": "investorPitch",
    "slug": "TsFunction",
    "id": "uxycbxwbxlehpvnqqfvzqzgf",
    "description": "Investor pitch",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, prompt_projectRelativePath: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"investor-pitch\",\n      contextContent,\nprompt_projectRelativePath\n    });\n\n    return result;\n\n  }"
  },
  "marcusAurelius": {
    "name": "marcusAurelius",
    "slug": "TsFunction",
    "id": "wbvbacbxpcerbstehzthrcrs",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (selectionContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"marcus-aurelius\",\n      selectionContent\n    });\n\n    return result;\n\n  }"
  },
  "MAX_REGULAR_ITEMS_AMOUNT": {
    "name": "MAX_REGULAR_ITEMS_AMOUNT",
    "slug": "TsVariable",
    "id": "qondssvlnkqxjmziaglfdrgm",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "opposite": {
    "name": "opposite",
    "slug": "TsFunction",
    "id": "ysqowrlpbyfhmiqzqxtmunbq",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"opposite\",\n      contextContent\n    });\n\n    return result;\n\n  }"
  },
  "outlineToInvestorPitch": {
    "name": "outlineToInvestorPitch",
    "slug": "TsFunction",
    "id": "njzpudvuqfajbbmxpxspizmw",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"outline-to-investor-pitch\",\n      \n    });\n\n    return result;\n\n  }"
  },
  "poem": {
    "name": "poem",
    "slug": "TsFunction",
    "id": "ikyoyzohhhkaaevcnnhibtaj",
    "description": "Write a poem",
    "operationName": "ai-functions-node",
    "rawText": " async (anyContext: string, prompt_projectRelativePath: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"poem\",\n      anyContext,\nprompt_projectRelativePath\n    });\n\n    return result;\n\n  }"
  },
  "processChatGptPrompt": {
    "name": "processChatGptPrompt",
    "slug": "TsFunction",
    "id": "dnmdzsbrucefaoekjnypuhtu",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  config: ProcessPromptProps\n): Promise<ProcessPromptFunctionResult> => {\n  const {\n    //context\n    contextContent,\n    prompt_projectRelativePath,\n    selectionContent,\n    //existing or new\n    contextualPromptSlug,\n    customPromptContent,\n    saveNewPromptWithName,\n    // config\n    isHeadless,\n    isDeferred,\n    thread,\n  } = config;\n\n  const extension = prompt_projectRelativePath\n    ? path.parse(prompt_projectRelativePath).ext.slice(1)\n    : undefined;\n\n  const contextType = fileTypePerExtension[\n    extension as keyof typeof fileTypePerExtension\n  ] as FileType | undefined;\n\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return { isSuccessful: false, message: \"no projectroot\" };\n  const prompt_absolutePath = prompt_projectRelativePath\n    ? path.join(projectRoot, prompt_projectRelativePath)\n    : undefined;\n\n  const exists = prompt_absolutePath\n    ? fs.existsSync(prompt_absolutePath)\n    : undefined;\n\n  if (prompt_absolutePath && !exists) {\n    return {\n      isSuccessful: false,\n      message: `You gave a path that doesn't exist:${prompt_absolutePath}`,\n    };\n  }\n\n  const contextualPrompt = await getContextualPrompt(\n    contextualPromptSlug,\n    customPromptContent,\n    saveNewPromptWithName || null,\n    contextType\n  );\n  if (!contextualPrompt) {\n    return {\n      isSuccessful: false,\n      message: \"Couldn't create or find a contextual prompt\",\n    };\n  }\n\n  /**\nensure `%context, %selection, %comment` are all valid variables in the prompt\n\nTODO: replace this with javascrpit-alike syntax (e.g. ${variableName})\n*/\n\n  const finalPrompt = { ...contextualPrompt }.promptContent\n    .replaceAll(\"%context\", contextContent || \"\")\n    .replaceAll(\"%selection\", selectionContent || \"\")\n    .replaceAll(\"%any\", selectionContent || contextContent || \"\");\n\n  /**\n   * Disable this for now\n   */\n  const useChatGpt = true;\n\n  /**\nsend it to the processor, which sends response back after a few seconds\n*/\n  const promiseResult = controlChatGptWrapper(\n    finalPrompt,\n    isHeadless,\n    thread,\n    \"puppeteer\"\n  ).then(async (promptFunctionResult) => {\n    const newResult: Storing<ContextualPromptResult> = {\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n      createdFirstAt: Date.now(),\n      deletedAt: 0,\n      id: generateId(),\n      resultAssets: [],\n      resultText: promptFunctionResult.result?.text,\n      prompt: finalPrompt,\n      selectionString: selectionContent || undefined,\n      prompt_projectRelativePath,\n      thread: promptFunctionResult.result?.thread,\n      contextualPromptSlug: contextualPrompt.slug,\n      isFake: !useChatGpt,\n    };\n\n    // NB: insert into .index\n\n    const contextualPromptResultsJsonPath =\n      await getContextualPromptResultJsonFilePath(prompt_projectRelativePath);\n\n    const upsertResult = contextualPromptResultsJsonPath\n      ? await alterJsonMultiple(\n          {\n            absolutePath: contextualPromptResultsJsonPath,\n            modelName: \"ContextualPromptResult\",\n            operationName: null,\n            projectRelativePath: makeRelative(\n              contextualPromptResultsJsonPath,\n              projectRoot\n            ),\n          },\n          (storedData) => {\n            const result = upsert(storedData, newResult);\n            return result;\n          }\n        )\n      : undefined;\n\n    return {\n      upsertResult,\n      promptFunctionResult: promptFunctionResult?.result,\n    };\n  });\n\n  const processPromptFunctionResult = isDeferred\n    ? undefined\n    : await promiseResult;\n\n  const result =\n    isDeferred || !processPromptFunctionResult\n      ? undefined\n      : processPromptFunctionResult.promptFunctionResult;\n\n  return {\n    isSuccessful: isDeferred ? true : !!result?.text || false,\n    message: isDeferred\n      ? \"Prompt is now being executed\"\n      : processPromptFunctionResult?.upsertResult?.message || \"WentWrong\",\n    result,\n  };\n}"
  },
  "processPromptOnFile": {
    "name": "processPromptOnFile",
    "slug": "TsFunction",
    "id": "wfykvafypihzlrjtutafkkid",
    "description": "function `processPromptOnFile` to execute `processChatGptPrompt` for a file, so we don't need to store the whole file content and it can be executed later and still have the most recent file contents\n\nIn order to keep the file itself as a source of truth for its content, it's useful to have this because you can add this to the queue",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  projectRelativeFilePath: string,\n  contextualPromptSlug: string\n) => {\n  console.log(\"called processPromptOnFile\", {\n    projectRelativeFilePath,\n    contextualPromptSlug,\n  });\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No projectroot\" };\n  }\n\n  const absolutePath = path.join(projectRoot, projectRelativeFilePath);\n\n  const exists = fs.existsSync(absolutePath);\n\n  if (!exists) {\n    return { isSuccessful: false, message: \"File doesn't exist\" };\n  }\n\n  const contextContent = await fs.readFile(absolutePath, \"utf8\");\n  const result = await processChatGptPrompt({\n    contextContent,\n    contextualPromptSlug,\n    isDeferred: true,\n    prompt_projectRelativePath: projectRelativeFilePath,\n  });\n\n  return result;\n}"
  },
  "processPromptOnFolderWithContext": {
    "name": "processPromptOnFolderWithContext",
    "slug": "TsFunction",
    "id": "jszdhunxcbqaysvygzgwlihy",
    "description": "function that can execute `processPromptOnFile` for all files in a folder, by just upserting the executions to the queue.",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  functionContext: FunctionContext,\n  config: {\n    projectRelativeFolderPath: string;\n    promptSlug: string;\n    isRecursive?: boolean;\n    /**\n     * File extension(s) to be searched for in the folder\n     *\n     * If not given, just finds all file extensions\n     *\n     * exension without dot\n     */\n    extension?: string | string[];\n  }\n) => {\n  const { projectRelativeFolderPath, promptSlug, extension, isRecursive } =\n    config;\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No projectroot\" };\n  }\n  const absoluteFolderPath = path.join(projectRoot, projectRelativeFolderPath);\n\n  const exists = fs.existsSync(absoluteFolderPath);\n\n  if (!exists) {\n    return { isSuccessful: false, message: \"Folder not found\" };\n  }\n\n  const stats = await fs.stat(absoluteFolderPath);\n  if (!stats.isDirectory()) {\n    return { isSuccessful: false, message: \"That's not a folder\" };\n  }\n\n  // get files\n  const projectRelativeFilePaths = (\n    await explore({\n      basePath: absoluteFolderPath,\n      doNotExploreChildFolders: !isRecursive,\n      extension,\n      ignore: \".index\",\n    })\n  ).map((x) => makeRelative(x.path, projectRoot));\n\n  const queueItems: Creation<Queue>[] = projectRelativeFilePaths.map(\n    (projectRelativeFilePath) => {\n      return {\n        executionAuthToken: functionContext.authToken,\n        functionName: \"processPromptOnFile\",\n        parameters: [projectRelativeFilePath, promptSlug],\n        type: \"puppeteer\",\n      };\n    }\n  );\n\n  const upsertResult = await db.upsert(\"Queue\", queueItems);\n\n  return {\n    isSuccessful: upsertResult.isSuccesful,\n    message: upsertResult.isSuccesful ? \"Added to queue\" : upsertResult.message,\n  };\n}"
  },
  "quiz": {
    "name": "quiz",
    "slug": "TsFunction",
    "id": "nteuptsjoalhvsuearpxenvu",
    "description": "Quiz",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, prompt_projectRelativePath: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"quiz\",\n      contextContent,\nprompt_projectRelativePath\n    });\n\n    return result;\n\n  }"
  },
  "removeAllFake": {
    "name": "removeAllFake",
    "slug": "TsFunction",
    "id": "hdozwdntemcavbwavkkaqprj",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  basePath?: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  console.log(\"removing all fake\");\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"no projectroot\" };\n  }\n\n  const absoluteBasePath = basePath\n    ? path.join(projectRoot, basePath)\n    : projectRoot;\n\n  console.log({ absoluteBasePath });\n\n  const absolutePaths = (\n    await explore({\n      basePath: absoluteBasePath,\n      exact: true,\n      search: \"prompt-results.json\",\n      searchLevel: \"fileName\",\n    })\n  ).map((x) => x.path);\n\n  const filtered = await mapMany(\n    absolutePaths,\n    async (absolutePath) => {\n      // remove items with isFake\n\n      const json = await readJsonFile<ContextualPromptResult[]>(absolutePath);\n\n      if (!json) return false;\n\n      const newJson = json.filter((item) => item.isFake !== true);\n\n      if (newJson.length === json.length) return false;\n\n      const writeResult = await writeJsonToFile(absolutePath, newJson);\n\n      return writeResult;\n    },\n    100\n  );\n\n  console.log({ filtered: filtered });\n  return { isSuccessful: true };\n}"
  },
  "rickAndMortyRick": {
    "name": "rickAndMortyRick",
    "slug": "TsFunction",
    "id": "quwzaotwgwvglkhajhxcgall",
    "description": "Ricktalk",
    "operationName": "ai-functions-node",
    "rawText": " async (anyContext: string, prompt_projectRelativePath: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"rick-and-morty-rick\",\n      anyContext,\nprompt_projectRelativePath\n    });\n\n    return result;\n\n  }"
  },
  "rickAndMorty": {
    "name": "rickAndMorty",
    "slug": "TsFunction",
    "id": "jqllozaipboaioafggzszoxe",
    "description": "Rick teaches Morty",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, prompt_projectRelativePath: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"rick-and-morty\",\n      contextContent,\nprompt_projectRelativePath\n    });\n\n    return result;\n\n  }"
  },
  "setIsFavoritePromptResult": {
    "name": "setIsFavoritePromptResult",
    "slug": "TsFunction",
    "id": "mclattmekkkcugtsuhitdmpt",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  projectRelativePath: string,\n  id: string,\n  isFavorite: boolean\n) => {\n  const resultPath = await getContextualPromptResultJsonFilePath(\n    projectRelativePath\n  );\n\n  if (!resultPath) return { isSuccessful: false };\n\n  const result = await alterJsonMultiple(\n    {\n      absolutePath: resultPath,\n      modelName: \"ContextualPromptResult\",\n      projectRelativePath: resultPath,\n      operationName: \"\",\n    },\n    (old) => {\n      return {\n        newStoredData: old.map((item) => {\n          if (item.id !== id) return item;\n          return { ...item, isFavorite };\n        }),\n        amountUpdated: 1,\n      };\n    }\n  );\n\n  return { isSuccessful: result.amountUpdated === 1 };\n}"
  },
  "shouldAddToQueue": {
    "name": "shouldAddToQueue",
    "slug": "TsFunction",
    "id": "oupehpdgezaeryccjbuowvzr",
    "description": "Checks if system is busy and if so, adds the task to queue",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  functionName: string,\n  parameters: any[]\n) => {\n  const isBusy = await isSystemBusy();\n  if (isBusy) {\n    //add to the queue if the cpus/memory are too busy.\n    const upsertResult = await db.upsert(\"Queue\", {\n      executionAuthToken: \".....\", // what is the auth token if it's done by a watcher?\n      functionName,\n      parameters,\n    });\n\n    return true;\n  }\n  return false;\n}"
  },
  "socratesAndSnoopDogg": {
    "name": "socratesAndSnoopDogg",
    "slug": "TsFunction",
    "id": "jmztmrdcveppqzbajfeagodd",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (selectionContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"socrates-and-snoop-dogg\",\n      selectionContent\n    });\n\n    return result;\n\n  }"
  },
  "storytelling": {
    "name": "storytelling",
    "slug": "TsFunction",
    "id": "nkzyuslpfrvufuxmvmjggyka",
    "description": "Write a story about this code and what's happening in there",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"storytelling\",\n      contextContent\n    });\n\n    return result;\n\n  }"
  },
  "toolFunctionWithContext": {
    "name": "toolFunctionWithContext",
    "slug": "TsFunction",
    "id": "qhcjpowtexqjjwkwsymexquw",
    "description": "Function to be executed straight from the frontend, where details is replaced with actual parameters of the function you want to execute.\n\n`.functionContext` and `.functionName` to be stripped out of the form",
    "operationName": "ai-functions-node",
    "rawText": " async (\n  functionContext: FunctionContext,\n  functionName: string,\n  email: string,\n  /**\n   * Needed in this format because we need to show it nicely in the form (maybe not needed, try without also)\n   */\n  details: { [parameterName: string]: any }\n) => {\n  const fn = sdk[functionName as keyof typeof sdk] as ApiFunction | undefined;\n\n  const isNoTool = !fn || typeof fn !== \"function\" || !fn.domain;\n  if (isNoTool) {\n    return { isSuccessful: false, message: \"This is no tool\" };\n  }\n\n  // 1) save device email to device if not already\n  const emailAdded = await addDeviceAuthenticationMethodWithContext(\n    functionContext,\n    \"email\",\n    email\n  );\n\n  if (!emailAdded.isSuccessful) {\n    return {\n      isSuccessful: false,\n      message: \"Couldn't add your email to device\",\n    };\n  }\n\n  // 2) check how often you are running this function, there should be a rate limit, maybe later (TODO)\n\n  // 2) get parameters\n  const parameters = Object.values(details);\n\n  // 3) validate parameters (TODO, can also partly be done in function itself because we need pretty strict maybe for length and stuff)\n\n  // 4) add to queue\n  const queueItem: Creation<Queue> = {\n    functionName,\n    parameters,\n    executionAuthToken: functionContext.authToken,\n    notifyLateAfterSeconds: 60,\n    shouldNotifyOnResult: true,\n  };\n  const upsertResult = await db.upsert(\"Queue\", queueItem);\n\n  return {\n    isSuccessful: upsertResult.isSuccesful,\n    message: upsertResult.isSuccesful\n      ? \"Check your mail in a moment\"\n      : `Couldn't add to queue ${upsertResult.message}`,\n  };\n}"
  },
  "translateEverythingIntoHindi": {
    "name": "translateEverythingIntoHindi",
    "slug": "TsFunction",
    "id": "hrrqbirmdtrqvcngzfasvjes",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"translate-everything-into-hindi\",\n      contextContent\n    });\n\n    return result;\n\n  }"
  },
  "translateEverythingPortuguese": {
    "name": "translateEverythingPortuguese",
    "slug": "TsFunction",
    "id": "iowxwcsukfxcxsqgoimmnfqz",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"translate-everything-portuguese\",\n      contextContent\n    });\n\n    return result;\n\n  }"
  },
  "translateEverything": {
    "name": "translateEverything",
    "slug": "TsFunction",
    "id": "gjweewwtuldbjpnfxiyjiesn",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"translate-everything\",\n      contextContent\n    });\n\n    return result;\n\n  }"
  },
  "translateToPortuguese": {
    "name": "translateToPortuguese",
    "slug": "TsFunction",
    "id": "tcxnjmsqdpenhxdilslpdzqv",
    "description": "Translate to Portuguese",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, prompt_projectRelativePath: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"translate-to-portuguese\",\n      contextContent,\nprompt_projectRelativePath\n    });\n\n    return result;\n\n  }"
  },
  "typescriptExplain": {
    "name": "typescriptExplain",
    "slug": "TsFunction",
    "id": "niadwmbmksuqipyvcyknqysa",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (contextContent: string, selectionContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"typescript-explain\",\n      contextContent,\nselectionContent\n    });\n\n    return result;\n\n  }"
  },
  "williamShakespear": {
    "name": "williamShakespear",
    "slug": "TsFunction",
    "id": "ekyjjijzvkuiwprqxaalnpyi",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async (selectionContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"william-shakespear\",\n      selectionContent\n    });\n\n    return result;\n\n  }"
  },
  "writeContextualPromptSdk": {
    "name": "writeContextualPromptSdk",
    "slug": "TsFunction",
    "id": "kchtlnbgwzuyiqzwplauongc",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " async () => {\n  const contextualPrompts = await db.get(\"ContextualPrompt\");\n\n  const functionStrings = contextualPrompts\n    .map((contextualPrompt) => {\n      return writeCreatePromptCode(contextualPrompt);\n    })\n    .join(\"\\n\\n\\n\");\n\n  const codeString = `// this file is generated, you can edit it, but it will be re-generated based on the contextual prompts database\n  \nimport { PromptFunction } from \"ai-types\";\nimport { processChatGptPrompt } from \"./processChatGptPrompt\";\n\n${functionStrings}`;\n\n  return codeString;\n}"
  },
  "writeCreatePromptCode": {
    "name": "writeCreatePromptCode",
    "slug": "TsFunction",
    "id": "xlxakjbsfbvycixgthfirrhb",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": " (contextualPrompt: ContextualPrompt) => {\n  const parameters = [\n    contextualPrompt.usesAnyContext ? `anyContext` : undefined,\n    contextualPrompt.usesContext ? `contextContent` : undefined,\n    contextualPrompt.usesSelection ? `selectionContent` : undefined,\n    contextualPrompt.folderContentContext\n      ? `prompt_projectRelativePath`\n      : undefined,\n  ].filter(notEmpty);\n\n  const functionLineParametersString = parameters\n    .map((x) => `${x}: string`)\n    .join(\", \");\n  const objectParametersString = parameters.join(\",\\n\");\n\n  const { contextType, instantExecution, isFavorite, categoryStack } =\n    contextualPrompt;\n  const contextualPromptInfo = {\n    contextType,\n    instantExecution,\n    isFavorite,\n    categoryStack,\n  };\n  const functionName = camelCase(contextualPrompt.name);\n\n  const functionLineFullString =\n    parameters.length === 0 ? \"\" : `${functionLineParametersString}, `;\n  return `\n  ${\n    contextualPrompt.title\n      ? `/**\n  ${contextualPrompt.title}\n  */`\n      : \"\"\n  }\n  export const ${functionName}: PromptFunction = async (${functionLineFullString}isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"${contextualPrompt.slug}\",\n      ${objectParametersString}\n    });\n\n    return result;\n\n  }\n\n${functionName}.contextualPromptInfo = ${JSON.stringify(contextualPromptInfo)};\n\n${\n  contextualPrompt.isFavorite\n    ? `${functionName}.domain = \"${functionName}\";`\n    : \"\"\n}`;\n}"
  },
  "ye": {
    "name": "ye",
    "slug": "TsFunction",
    "id": "phnacxahtcybtspriineagaj",
    "description": "Let Kanye West write a poem about your selection",
    "operationName": "ai-functions-node",
    "rawText": " async (selectionContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"ye\",\n      selectionContent\n    });\n\n    return result;\n\n  }"
  },
  "yodafy": {
    "name": "yodafy",
    "slug": "TsFunction",
    "id": "wekltgthgutltiovriofqcnr",
    "description": "Let Yoda say your selection in his words",
    "operationName": "ai-functions-node",
    "rawText": " async (selectionContent: string, isDeferred?: boolean) => {\n\n    const result = await processChatGptPrompt({\n      isDeferred,\n      contextualPromptSlug: \"yodafy\",\n      selectionContent\n    });\n\n    return result;\n\n  }"
  },
  "fileTypePerExtension": {
    "name": "fileTypePerExtension",
    "slug": "TsVariable",
    "id": "nvelnottfwrlbaubyyvvwxij",
    "description": "",
    "operationName": "ai-types"
  },
  "languageModels": {
    "name": "languageModels",
    "slug": "TsVariable",
    "id": "fpqlduipfjrdmzbyvyqwweax",
    "description": "",
    "operationName": "ai-types"
  },
  "allOperationsRemoveJsSrc": {
    "name": "allOperationsRemoveJsSrc",
    "slug": "TsFunction",
    "id": "tuevcqwdrrefuklweuwlfjgd",
    "description": "BEWARE! This removes all .d.ts, .js, and .d.ts.map files in your source folder!",
    "operationName": "all",
    "rawText": " async (debug?: boolean) => {\n  await forAllFolders({\n    type: \"operations\",\n    basePath: getPathsWithOperations(),\n    command: \"[ -d \\\"src\\\" ] && find src -name '*.d.ts' -delete || echo 'hoi'\",\n    shell: true,\n  });\n\n  await forAllFolders({\n    type: \"operations\",\n    basePath: getPathsWithOperations(),\n    command: \"[ -d \\\"src\\\" ] && find src -name '*.js' -delete || echo 'hoi'\",\n    shell: true,\n  });\n\n  await forAllFolders({\n    type: \"operations\",\n    basePath: getPathsWithOperations(),\n    command:\n      \"[ -d \\\"src\\\" ] && find src -name '*.d.ts.map' -delete || echo 'hoi'\",\n    shell: true,\n  });\n}"
  },
  "allOperationsToMarkdown": {
    "name": "allOperationsToMarkdown",
    "slug": "TsFunction",
    "id": "zzgmmpvwjebpukpaavmvbqby",
    "description": "",
    "operationName": "all",
    "rawText": " async () => {\n  forAllFolders({\n    type: \"operations\",\n    basePath: getPathsWithOperations(),\n    callback: async (folderPath, index) => {\n      const operationName = getLastFolder(folderPath);\n      log(`#${index}: Making new README for ${operationName}`, {\n        type: \"success\",\n      });\n\n      const operationSummary = await getOperationSummary({ operationName });\n      if (!operationSummary) return;\n      await operationToMarkdown({\n        operationSummary,\n        returnType: \"save\",\n      });\n      return;\n    },\n  });\n}"
  },
  "clearAllTsDatabases": {
    "name": "clearAllTsDatabases",
    "slug": "TsFunction",
    "id": "mdftpfsoynsetsjvvwrcdmps",
    "description": "",
    "operationName": "all",
    "rawText": " async () => {\n  forAllFolders({\n    type: \"operations\",\n    basePath: getPathsWithOperations(),\n    callback: async (folderPath, index) => {\n      const operationName = getLastFolder(folderPath);\n      log(\n        `#${index}: Clearing Typescript Indexation Data for ${operationName}`,\n        { type: \"success\" }\n      );\n      await clearTsDatabase(operationName);\n      return;\n    },\n  });\n}"
  },
  "codeAll": {
    "name": "codeAll",
    "slug": "TsFunction",
    "id": "zcmyiyejgxhjjiuiipnpvzwn",
    "description": "opens all files in vscode",
    "operationName": "all",
    "rawText": " async (search: string) => {\n  const filePaths = (\n    await explore({\n      basePath: getProjectRoot(),\n      ignore: [\"node_modules\", \"build\"],\n      exact: true,\n      search,\n      searchLevel: \"fileName\",\n    })\n  ).map((x) => x.path);\n\n  return forAllFiles({ filePaths, command: `code $LOCATION` });\n}"
  },
  "[debug]": {
    "name": "[debug]",
    "slug": "TsVariable",
    "id": "qelphelzcdqkjaxvpklzekyq",
    "description": "",
    "operationName": "all"
  },
  "[folderName, basePath]": {
    "name": "[folderName, basePath]",
    "slug": "TsVariable",
    "id": "ipsiiiwuxyghtxqpwyvqsxvq",
    "description": "",
    "operationName": "all"
  },
  "forAllFiles": {
    "name": "forAllFiles",
    "slug": "TsFunction",
    "id": "ofchfjqttkltesclakskuwhg",
    "description": "executes a command or callback for every file\n\nin commands, $LOCATION is provided as env variable, and command is executed in the dir of the file",
    "operationName": "all",
    "rawText": " async ({\n  filePaths,\n  callback,\n  command,\n}: ForAllFilesConfig): Promise<void> => {\n  const locationPromises = filePaths.map(async (p) => {\n    if (command) {\n      execSync(command, {\n        env: {\n          LOCATION: p,\n        },\n        cwd: getFolder(p),\n        encoding: \"utf8\",\n        stdio: \"inherit\",\n      });\n    }\n\n    if (callback) {\n      callback(p);\n    }\n  });\n\n  await Promise.all(locationPromises);\n\n  console.log(\"done!\");\n}"
  },
  "forAllFolders": {
    "name": "forAllFolders",
    "slug": "TsFunction",
    "id": "hzetgxwufmcjbjgfatacljxl",
    "description": "executes a command or callback in every folder of a certain type. Supports git repos and operations now",
    "operationName": "all",
    "rawText": " async ({\n  type,\n  callback,\n  basePath,\n  onlyRoot,\n  command,\n  shell,\n  fileName,\n  folderName,\n  ignore,\n}: AllInputType): Promise<void> => {\n  let locations =\n    type === \"git\"\n      ? await exploreGitRepoFolders({ basePath })\n      : type === \"operations\"\n      ? await exploreOperationFolders({ basePath })\n      : type === \"folder\" && folderName\n      ? (\n          await explore({\n            basePath,\n            exact: true,\n            doNotExploreChildFolders: onlyRoot,\n            searchLevel: \"folder\",\n            doNotExploreMatch: true,\n            // should be able to ignore stuff\n            ignore,\n            search: folderName,\n          })\n        ).map((x) => x.path)\n      : type === \"file\"\n      ? (\n          await explore({\n            basePath,\n            exact: true,\n            searchLevel: \"fileName\",\n            search: fileName,\n          })\n        ).map((x) => x.path)\n      : [];\n\n  if (locations.length === 0) {\n    // console.log(\"Nothing found\");\n    return;\n  }\n\n  // console.log({ locations: locations.length });\n\n  if (fileName && type !== \"file\") {\n    locations = locations.map((f) => path.join(f, fileName));\n  }\n\n  // console.log({ locations });\n\n  await oneByOne(locations, async (location, index) => {\n    // console.log({ location });\n    if (command) {\n      execSync(command, {\n        env: {\n          LOCATION: location,\n        },\n        cwd: getFolder(location),\n        encoding: \"utf8\",\n        stdio: \"inherit\",\n        // shell,\n      });\n    }\n\n    if (callback) {\n      await callback(location, index);\n    }\n  });\n\n  // console.log(\"done!\");\n}"
  },
  "getAllOperationClassifications": {
    "name": "getAllOperationClassifications",
    "slug": "TsFunction",
    "id": "enuerezzpdwdcfdzzqdxgzth",
    "description": "",
    "operationName": "all",
    "rawText": " async () => {\n  const x = forAllFolders({\n    type: \"operations\",\n    basePath: getPathsWithOperations(),\n    callback: async (folderPath, index) => {\n      const operationName = getLastFolder(folderPath);\n\n      console.log(\n        `${operationName}: ${getOperationClassification(folderPath)}`\n      );\n\n      return;\n    },\n  });\n}"
  },
  "gitShipAllRepos": {
    "name": "gitShipAllRepos",
    "slug": "TsFunction",
    "id": "faogefqrsgyfkjzalgboiqtk",
    "description": "`gitShipAllPackages` Just ships code everywhere to github, wherever there's a git folder and there are changes.",
    "operationName": "all",
    "rawText": " ({\n  basePath,\n  callback,\n  fileName,\n  folderName,\n  shell = true,\n}: Omit<AllInputType, \"command\" | \"type\">) =>\n  forAllFolders({\n    type: \"git\",\n    command: 'git add . && git commit -m \"Improvements\" && git push',\n    basePath,\n    callback,\n    shell,\n    fileName,\n    folderName,\n  })"
  },
  "mdAllOperations": {
    "name": "mdAllOperations",
    "slug": "TsFunction",
    "id": "hkishrwwakuuqadhbqqqttiq",
    "description": "",
    "operationName": "all",
    "rawText": " async (debug?: boolean) => {\n  forAllFolders({\n    type: \"operations\",\n    basePath: getPathsWithOperations(),\n    callback: async (folderPath, index) => {\n      const operationName = getLastFolder(folderPath);\n      log(`#${index}: README for ${operationName}`, { type: \"success\" });\n      await operationToMarkdown({ operationName, mergeDocsInline: true });\n      return;\n    },\n  });\n}"
  },
  "minifyAllOperations": {
    "name": "minifyAllOperations",
    "slug": "TsFunction",
    "id": "vjwbuhuyihpcnzkyxpcoyqib",
    "description": "minify all operations everywhere. optionally:\n- enable the shell\n- specify a basepath (tools by default)",
    "operationName": "all",
    "rawText": " async (\n  config?: Omit<\n    AllInputType,\n    \"type\" | \"command\" | \"callback\" | \"fileName\" | \"folderName\" | \"ignore\"\n  >\n) => {\n  return forAllFolders({\n    type: \"operations\",\n    callback: (folderPath) => {\n      return minifyBuild({ buildFolderPath: path.join(folderPath, \"build\") });\n    },\n    basePath: config?.basePath || getPathsWithOperations(),\n    shell: config?.shell,\n  });\n}"
  },
  "publishAllOperations": {
    "name": "publishAllOperations",
    "slug": "TsFunction",
    "id": "gwhfwaciggrbowgaamkkdjum",
    "description": "Script to publish all packages everywhere (that also runs prepublish). Only src in git, only build in npm.",
    "operationName": "all",
    "rawText": " ({\n  basePath,\n  callback,\n  fileName,\n  folderName,\n  shell = true,\n}: Omit<AllInputType, \"type\" | \"command\">) =>\n  forAllFolders({\n    type: \"operations\",\n    fileName,\n    folderName,\n    callback,\n    basePath,\n    command: \"npm run pub --if-present\",\n    shell,\n  })"
  },
  "removeAllFiles": {
    "name": "removeAllFiles",
    "slug": "TsFunction",
    "id": "thakoomlctfuvmxorpmnjpkq",
    "description": "removes all files that have an exact match of the location (folders not because we use rm without -rf)",
    "operationName": "all",
    "rawText": " async (search: string) => {\n  const filePaths = (\n    await explore({\n      basePath: getRootPath(),\n      ignore: [\"node_modules\", \"build\"],\n      exact: true,\n      search,\n      searchLevel: \"fileName\",\n    })\n  ).map((x) => x.path);\n  console.log({ filePaths });\n  return forAllFiles({\n    filePaths,\n    callback: (filePath) => fs.rmSync(filePath),\n  });\n}"
  },
  "removeAllFoldersCli": {
    "name": "removeAllFoldersCli",
    "slug": "TsFunction",
    "id": "geeygcoktzwbrawixecnvvrh",
    "description": "",
    "operationName": "all",
    "rawText": " async () => {\n  await removeAllFolders({\n    basePath,\n    folderNames: [folderName],\n  });\n\n  console.log(\"DONE\");\n}"
  },
  "removeAllFolders": {
    "name": "removeAllFolders",
    "slug": "TsFunction",
    "id": "nwfyezaqpibbskorfgkptmnv",
    "description": "",
    "operationName": "all",
    "rawText": " async (config: {\n  basePath: string;\n  folderNames: string[];\n  ignore?: string | string[];\n  onlyRoot?: boolean;\n}) => {\n  const { basePath, folderNames, ignore, onlyRoot } = config;\n  const removeFolderPromises = folderNames.map(async (folderName) => {\n    const rmResult = await removeAll({\n      basePath,\n      type: \"folder\",\n      folderName,\n      shell: true,\n      onlyRoot,\n      ignore,\n    });\n\n    return;\n  });\n\n  await Promise.all(removeFolderPromises);\n\n  return true;\n}"
  },
  "removeAll": {
    "name": "removeAll",
    "slug": "TsFunction",
    "id": "isegdiyqmyqqkasjzxbiszzq",
    "description": "removes all xyz for a folder\n\nmake sure to specify which type you want.... folder or file most likely",
    "operationName": "all",
    "rawText": " async ({\n  basePath,\n  fileName,\n  folderName,\n  type,\n  shell,\n  ignore,\n  onlyRoot,\n}: Omit<AllInputType, \"command\">) => {\n  const callback = (folderName: string) =>\n    new Promise<void>(async (resolve) => {\n      try {\n        if (fs.existsSync(folderName)) {\n          await fs.rm(folderName, { recursive: true });\n        }\n        resolve();\n      } catch (e) {\n        console.log(\n          \"Shouldnt happen, but we got a catch at removing an existing folder\"\n        );\n        resolve();\n      }\n    });\n\n  return forAllFolders({\n    basePath,\n    fileName,\n    onlyRoot,\n    folderName,\n    type,\n    callback,\n    shell,\n    ignore,\n  });\n}"
  },
  "renameAll": {
    "name": "renameAll",
    "slug": "TsFunction",
    "id": "rbwhkrypyszzyorwmgofxcwp",
    "description": "renames all files to a new name (optionally a func, based on the old path)",
    "operationName": "all",
    "rawText": " async ({\n  filePaths,\n  newFileName,\n  newFilePath,\n}: {\n  filePaths: string[];\n  /**\n   * if given, all files will be replaces by this filename\n   */\n  newFileName?: string;\n  /**\n   * if given, this will be used to determine the new path\n   */\n  newFilePath?: (oldPath: string) => string;\n}) => {\n  return forAllFiles({\n    filePaths,\n    callback: (filePath) =>\n      new Promise<void>(async (resolve) => {\n        if (fs.existsSync(filePath)) {\n          const newPath = newFileName\n            ? path.join(getFolder(filePath), newFileName)\n            : newFilePath?.(filePath);\n\n          if (!newPath) {\n            return log(\"couldn't determine new path\", { type: \"error\" });\n          }\n          console.log(`renamed ${filePath} to ${newPath}`);\n          await fs.rename(filePath, newPath);\n        }\n        resolve();\n      }),\n  });\n}"
  },
  "runScriptEverywhere": {
    "name": "runScriptEverywhere",
    "slug": "TsFunction",
    "id": "pgwqormeaexdmnyknrxpfhya",
    "description": "runs a package script in all tools operations\n\nNB: uses npm insead of yarn, but for scripts this shouldn't matter",
    "operationName": "all",
    "rawText": " async (\n  script: string,\n  startIndex?: number\n) => {\n  forAllFolders({\n    type: \"operations\",\n    basePath: getPathsWithOperations(),\n    callback: (folderPath, index) => {\n      if (startIndex && startIndex > index) {\n        console.log(`skipping ${index}`);\n        return;\n      }\n\n      try {\n        console.log(`now: ${index} (${folderPath})`);\n        execSync(`npm run ${script} --if-present`, {\n          encoding: \"utf8\",\n          cwd: folderPath,\n        });\n      } catch (e: any) {\n        const error: {\n          status: number;\n          signal: any;\n          output: (string | null)[];\n          pid: number;\n          stdout: string;\n          stderr: string;\n        } = e;\n        console.log(error?.stdout);\n      }\n    },\n  });\n}"
  },
  "[script, startIndex]": {
    "name": "[script, startIndex]",
    "slug": "TsVariable",
    "id": "biofumzlepyhnbuyqkzwkiso",
    "description": "",
    "operationName": "all"
  },
  "[search]": {
    "name": "[search]",
    "slug": "TsVariable",
    "id": "jgndgpwtdhpjgbhjweaepgpz",
    "description": "",
    "operationName": "all"
  },
  "setScriptEverywhere": {
    "name": "setScriptEverywhere",
    "slug": "TsFunction",
    "id": "dqiqyxdzltvxkdqcvachblrh",
    "description": "set package.json script to another value in all operations in tools folder",
    "operationName": "all",
    "rawText": " async (script: string, value: string) => {\n  forAllFolders({\n    basePath: getPathsWithOperations(),\n    type: \"operations\",\n    shell: true,\n    callback: (folderPath, index) => {\n      setJsonKey({\n        jsonPath: path.join(folderPath, \"package.json\"),\n        keyLocation: `scripts.${script}`,\n        value,\n      });\n    },\n  });\n}"
  },
  "[type, command, fileName, basePath, folderName, shellString]": {
    "name": "[type, command, fileName, basePath, folderName, shellString]",
    "slug": "TsVariable",
    "id": "vrrcvoxduewsnmkfumnekfmb",
    "description": "",
    "operationName": "all"
  },
  "API_CUSTOM_URL_KEY": {
    "name": "API_CUSTOM_URL_KEY",
    "slug": "TsVariable",
    "id": "tziswbowegknunnvojobhzzn",
    "description": "",
    "operationName": "api"
  },
  "API_NO_RESPONSE_TIME_KEY": {
    "name": "API_NO_RESPONSE_TIME_KEY",
    "slug": "TsVariable",
    "id": "kzogiibmjrxgowdiwzffhgvn",
    "description": "",
    "operationName": "api"
  },
  "apiWithConfig": {
    "name": "apiWithConfig",
    "slug": "TsVariable",
    "id": "ijnoudyvrfsmvqnwuaznonjf",
    "description": "This object contains a api function for every function in the backend\n\nThe difference from `api` is that it allows you to also insert custom api configurations",
    "operationName": "api"
  },
  "api": {
    "name": "api",
    "slug": "Operation",
    "id": "LKkLDGQFSIHMUXTg",
    "operationName": "api"
  },
  "AUTH_TOKEN_STORAGE_KEY": {
    "name": "AUTH_TOKEN_STORAGE_KEY",
    "slug": "TsVariable",
    "id": "hzjmaccljkakhcdjurqiubjo",
    "description": "",
    "operationName": "api"
  },
  "fn1": {
    "name": "fn1",
    "slug": "TsFunction",
    "id": "ehiektyhpknmenmgvksdhlpa",
    "description": "There is probably some doc-comments available for the function, maybe we can fix this with proxies to pass those comments... that would be insane.",
    "operationName": "api",
    "rawText": " (a: string, b: number) => {\n  return true;\n}"
  },
  "fn2": {
    "name": "fn2",
    "slug": "TsFunction",
    "id": "gjmaijkohrqdcloyuweuopgv",
    "description": "",
    "operationName": "api",
    "rawText": " (a: string, b: number) => {\n  return 282827;\n}"
  },
  "fn3": {
    "name": "fn3",
    "slug": "TsFunction",
    "id": "emnzpysabmhmqqfcqjerqxlp",
    "description": "",
    "operationName": "api",
    "rawText": " async (a: string, b: number) => {\n  return Promise.resolve(\"yesssss\");\n}"
  },
  "getGetApiUrl": {
    "name": "getGetApiUrl",
    "slug": "TsFunction",
    "id": "jbwsxoybleapxrubrhskzhsr",
    "description": "gets an api url for a context get api\n\nreturns something like `[apiUrl]/[apiFunctionName][queryString]`",
    "operationName": "api",
    "rawText": " (\n  apiUrl: string | undefined,\n  apiFunctionName: string,\n  query: { [name: string]: string[] | string | undefined }\n): string | undefined => {\n  if (!apiUrl) return;\n  const queryString = Object.keys(query).length > 0 ? toQueryString(query) : \"\";\n  const url = `${apiUrl}/function/${apiFunctionName}${queryString}`;\n  return url;\n}"
  },
  "queries": {
    "name": "queries",
    "slug": "TsVariable",
    "id": "yaizywcpyjikervhjpsrmlmq",
    "description": "This object contains a react-query `useQuery` hook for every api function",
    "operationName": "api"
  },
  "sdkExample": {
    "name": "sdkExample",
    "slug": "TsVariable",
    "id": "kfhfiowvmqbhbqfetbkjvzab",
    "description": "",
    "operationName": "api"
  },
  "untypedApiFunction": {
    "name": "untypedApiFunction",
    "slug": "TsFunction",
    "id": "eftnfnqbdxjmsvyylfxbjobr",
    "description": "Used for calling the actual api for a function with some config\n\nNB: this is not a typed function as we are just overwriting it so we don't need any inference on this",
    "operationName": "api",
    "rawText": " async (\n  fnName: string,\n  config: ApiConfig,\n  ...parameters: any\n): Promise<RealApiReturnType<any>> => {\n  // TODO: document this convention\n  const storageAuthToken: string | undefined = await getItem(\n    AUTH_TOKEN_STORAGE_KEY\n  );\n\n  const authToken = config.authToken || storageAuthToken;\n  const realApiUrl = config.apiUrl || apiUrl;\n\n  if (realApiUrl === undefined) {\n    return {\n      isSuccessful: false,\n      isNotConnected: true,\n      message: \"The API cannot be found\",\n    };\n  }\n\n  const fullUrl = `${realApiUrl}/function/${fnName}`;\n\n  try {\n    const abortController = new AbortController();\n    const id = setTimeout(\n      () => abortController.abort(),\n      config.timeout || 10000\n    );\n\n    const response = await fetch(fullUrl, {\n      method: \"POST\",\n      signal: config.timeout ? abortController.signal : undefined,\n      headers: {\n        Accept: \"application/json\",\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ authToken, parameters }),\n    })\n      .then((response) => response.json())\n      .then((response) => {\n        setItem(API_NO_RESPONSE_TIME_KEY, \"0\");\n\n        return response;\n      })\n      .catch((error) => {\n        console.log({\n          explanation:\n            \"Your request could not be executed, you may be disconnected or the server may not be available.\",\n          error,\n          errorStatus: error.status,\n          errorString: String(error),\n        });\n\n        setItem(API_NO_RESPONSE_TIME_KEY, String(Date.now()));\n        return {\n          isSuccessful: false,\n          isNotConnected: true,\n          message:\n            \"Error! There's no API running (yet). Please read the docs to set this up locally. More info in the console.\",\n        };\n      });\n\n    clearTimeout(id);\n    return response;\n  } catch (e) {\n    setItem(API_NO_RESPONSE_TIME_KEY, String(Date.now()));\n\n    return {\n      isSuccessful: false,\n      isNotConnected: true,\n      message:\n        \"The API didn't resolve, and the fetch crashed because of it: \" +\n        String(e),\n    };\n  }\n}"
  },
  "apiStoreInitialValues": {
    "name": "apiStoreInitialValues",
    "slug": "TsVariable",
    "id": "ehkjwkkplllfhvsnwyqrsfma",
    "description": "",
    "operationName": "api-store"
  },
  "apiConventions": {
    "name": "apiConventions",
    "slug": "TsVariable",
    "id": "cezgrpqezotquubsqvqxxcur",
    "description": "API conventions:\n\n- `xyzGetApi` is only available via GET, the rest is only available with POST.\n- `xyzWithContext` is taking `FunctionContext` as its first parameter\n- `xyzWithContextRaw` is taking `FunctionContext` as its first parameter, and is expected to return the raw return type the function returns.",
    "operationName": "api-types"
  },
  "contextFunctionConventionSuffix": {
    "name": "contextFunctionConventionSuffix",
    "slug": "TsVariable",
    "id": "gekqafmwhphwaiexqiizqqer",
    "description": "",
    "operationName": "api-types"
  },
  "getFunctionConventionSuffix": {
    "name": "getFunctionConventionSuffix",
    "slug": "TsVariable",
    "id": "briyvasahubwnvjykaxtcegd",
    "description": "",
    "operationName": "api-types"
  },
  "rawFunctionConventionSuffix": {
    "name": "rawFunctionConventionSuffix",
    "slug": "TsVariable",
    "id": "qjvomkpwverjzjzlfrbiohyx",
    "description": "",
    "operationName": "api-types"
  },
  "AppsMenu": {
    "name": "AppsMenu",
    "slug": "TsFunction",
    "id": "kzzwtzphryalsffyfymxohwr",
    "description": "",
    "operationName": "apps-menu",
    "rawText": " () => {\n  const [loading, setLoading] = useState<{ [appName: string]: boolean }>({});\n  const appsQuery = queries.useGetAllAppOperations();\n  const alert = useAlert();\n  return (\n    <Div className=\"flex flex-row flex-wrap justify-center gap gap-2\">\n      {appsQuery.data?.result\n        ?.filter((x) => x.name !== \"function-server\")\n        .map((appOperation) => {\n          return (\n            <Div\n              key={appOperation.name}\n              className=\"z-50 flex flex-col items-center cursor-pointer\"\n              onClick={async () => {\n                const goToSite = () => {\n                  const url = `http://localhost:${appOperation.port}`;\n                  window.open(url, \"_blank\");\n                };\n\n                if (!appOperation.isOnline) {\n                  setLoading({ ...loading, [appOperation.name]: true });\n                  const { result, isSuccessful, message } = await api.startApp(\n                    appOperation.name,\n                    true\n                  );\n\n                  if (!isSuccessful || !result?.isSuccessful) {\n                    alert?.(\n                      `Error`,\n                      result?.error?.message || message || \"No message\"\n                    );\n                    setLoading({ ...loading, [appOperation.name]: false });\n                    return;\n                  }\n\n                  // TODO: apparently we need to wait a second before the next.js project is really start up... we can easily improve this by watching the stdout on the server and look for a message that says \"it's running on http://localhost:PORT\"\n                  setTimeout(() => {\n                    goToSite();\n                    appsQuery.refetch();\n                    setLoading({ ...loading, [appOperation.name]: false });\n                  }, 1000);\n\n                  return;\n                }\n                // if the app is already turned on, don't load, don't open api, just go there...\n                goToSite();\n              }}\n            >\n              <Tooltip\n                placement=\"top\"\n                tooltip={\n                  <MarkdownContent\n                    content={\n                      appOperation.description ||\n                      appOperation.name ||\n                      \"No description set\"\n                    }\n                    config={{}}\n                  />\n                }\n              >\n                <Div className=\"bg-white border border-black mb-2 rounded-lg w-12 h-12 flex items-center justify-center hover:scale-150 hover:mt-3 hover:-mb-3 transition-all\">\n                  {loading[appOperation.name] === true ? (\n                    <FancyLoader medium />\n                  ) : (\n                    <P title={appOperation.name} className=\"text-4xl\">\n                      {appOperation.emoji ||\n                        appOperation.name.charAt(0).toLocaleUpperCase()}\n                    </P>\n                  )}\n                </Div>\n              </Tooltip>\n\n              {appOperation.isOnline ? (\n                <Div className=\"w-2 h-2 rounded-full bg-gray-700 dark:bg-gray-200\" />\n              ) : (\n                <Div className=\"w-2 h-2\" />\n              )}\n            </Div>\n          );\n        })}\n    </Div>\n  );\n}"
  },
  "argumentsWithoutFlags": {
    "name": "argumentsWithoutFlags",
    "slug": "TsVariable",
    "id": "rywknfskqylbzvgssjjamduh",
    "description": "",
    "operationName": "ask"
  },
  "askOk": {
    "name": "askOk",
    "slug": "TsFunction",
    "id": "mwaadgupfqrtbgyhuqbqtrrm",
    "description": "",
    "operationName": "ask",
    "rawText": " async (question: string): Promise<boolean> => {\n  const answer = await ask(question);\n  return [\"yes\", \"y\", \"\"].includes(answer);\n}"
  },
  "ask": {
    "name": "ask",
    "slug": "Operation",
    "id": "kaVSSsxzjMippmUd",
    "operationName": "ask"
  },
  "getArgumentOrAsk": {
    "name": "getArgumentOrAsk",
    "slug": "TsFunction",
    "id": "obfmkziopammikbyoqqeblfw",
    "description": "",
    "operationName": "ask",
    "rawText": " async (\n  argumentPosition: number,\n  question: string,\n  isNonInteractive?: boolean\n): Promise<string> => {\n  let argument = argumentsWithoutFlags[argumentPosition + 1];\n  if (argument && argument.length > 0) return argument;\n\n  if (isNonInteractive) {\n    return \"\";\n  }\n\n  return ask(question);\n}"
  },
  "addToken": {
    "name": "addToken",
    "slug": "TsFunction",
    "id": "axmbahvjfqyaebwembukftpd",
    "description": "If previousToken is not present, will be generated randomly",
    "operationName": "asset-functions-js",
    "rawText": " (\n  name: string,\n  /**\n   * if given, uses this token, otherwise generates a new random token\n   */\n  previousToken?: string,\n  attachTokenToFilename?: boolean\n): string => {\n  if (!attachTokenToFilename) return name;\n  const newRandomToken = generateRandomString(32);\n  return `${name}${tokenPrefix}${previousToken || newRandomToken}`;\n}"
  },
  "ensureToken": {
    "name": "ensureToken",
    "slug": "TsFunction",
    "id": "pvjnbmcdhxzngpgyjzwunvay",
    "description": "Remove the token (if present), then add it again",
    "operationName": "asset-functions-js",
    "rawText": " (\n  name: string,\n  /**\n   * if given, is used for generating new token\n   *\n   * if already present, token is used from the name instead of this one\n   */\n  newToken?: string,\n  attachTokenToFilename?: boolean\n) => {\n  const { nameWithoutToken, token } = removeTokenIfPresent(\n    name,\n    attachTokenToFilename\n  );\n  const nameWithToken = addToken(\n    nameWithoutToken,\n    token || newToken,\n    attachTokenToFilename\n  );\n  return nameWithToken;\n}"
  },
  "findAssetParametersRecursively": {
    "name": "findAssetParametersRecursively",
    "slug": "TsFunction",
    "id": "ojvlqdwljwzdrvtuvegghrow",
    "description": "Recursively finds all asset parameters in an object (for example in a database model item)",
    "operationName": "asset-functions-js",
    "rawText": " (\n  object: {\n    [key: string]: any;\n  },\n  stack?: string[]\n): AssetParameter[] => {\n  if (!object) return [];\n\n  const result = Object.keys(object)\n    .map((objectProperty) => {\n      const value = object[objectProperty];\n\n      const assetInputType = getAssetInputType(objectProperty);\n\n      if (assetInputType) {\n        return [\n          {\n            assetInputType,\n            parameterName: objectProperty,\n            stack,\n          },\n        ];\n      }\n\n      if (typeof value === \"object\") {\n        const newStack = stack ? [...stack, objectProperty] : [objectProperty];\n\n        return findAssetParametersRecursively(value, newStack);\n      }\n    })\n    .filter(notEmpty)\n    .flat();\n\n  return result;\n}"
  },
  "getConversionInfoFromType": {
    "name": "getConversionInfoFromType",
    "slug": "TsFunction",
    "id": "betgqnbyyvevmwbnxamgnmyw",
    "description": "Received files contain a \"type\" like \"audio/mp3\" or \"image/jpeg\", etc...\n\nHere the extension is decided.\n\nNB: we also need to convert the file itself in case of mp3",
    "operationName": "asset-functions-js",
    "rawText": " (\n  uploadMimeType: string | undefined\n): {\n  uploadMimeType: string | undefined;\n  targetFormat: string | undefined;\n  isUnchecked?: boolean;\n} => {\n  const parts = uploadMimeType?.split(\"/\") || [];\n  const firstPart = parts.length > 0 ? parts[0] : undefined;\n  const lastPart = parts.length > 0 ? parts[parts.length - 1] : undefined;\n\n  console.log({ uploadMimeType, lastPart });\n  if (uploadMimeType === \"audio/mp4\") {\n    return { uploadMimeType, targetFormat: \"mp3\" };\n  }\n\n  if (lastPart === \"wav\") {\n    return { uploadMimeType, targetFormat: \"mp3\" };\n  }\n\n  if (lastPart === \"x-m4a\") {\n    return { uploadMimeType, targetFormat: \"mp3\" };\n  }\n\n  if (firstPart === \"audio\") {\n    return { uploadMimeType, targetFormat: \"mp3\" };\n  }\n\n  if (lastPart === \"quicktime\") {\n    return { uploadMimeType, targetFormat: \"mp4\" };\n  }\n\n  if (firstPart === \"video\") {\n    return { uploadMimeType, targetFormat: \"mp4\" };\n  }\n\n  if (firstPart === \"image\") {\n    return { uploadMimeType, targetFormat: \"jpg\" };\n  }\n\n  return { uploadMimeType, targetFormat: lastPart, isUnchecked: true };\n}"
  },
  "getExtensionFromAsset": {
    "name": "getExtensionFromAsset",
    "slug": "TsFunction",
    "id": "hfwhaqfsjpwywgqgnehyguzu",
    "description": "Returns a preliminary filename, based on the `Asset`",
    "operationName": "asset-functions-js",
    "rawText": " (asset: Asset) => {\n  const extensionFromType =\n    asset.type === \"audio\"\n      ? `mp3`\n      : asset.type === \"image\"\n      ? `jpeg`\n      : asset.type === \"video\"\n      ? `mp4`\n      : undefined;\n\n  const extension = extensionFromType\n    ? extensionFromType\n    : asset.originalFilename\n    ? getExtension(asset.originalFilename)\n    : asset.relativePath\n    ? getExtension(asset.relativePath)\n    : undefined;\n\n  return extension;\n}"
  },
  "getNameFromRelativePath": {
    "name": "getNameFromRelativePath",
    "slug": "TsFunction",
    "id": "gdtdfkfhfnbdedtolsnlakzj",
    "description": "",
    "operationName": "asset-functions-js",
    "rawText": " (relativePath: string) => {\n  const filename = relativePath.split(\"/\").pop()!;\n  const filenameWithoutExtension = withoutExtension(filename);\n  return filenameWithoutExtension;\n}"
  },
  "getNameWithTokenFromRelativePath": {
    "name": "getNameWithTokenFromRelativePath",
    "slug": "TsFunction",
    "id": "uvmwcerhuexqdsvieivmhtnl",
    "description": "first gets the name from the relativePath\n\nthen ensures the token is attached (if not already there)",
    "operationName": "asset-functions-js",
    "rawText": " (\n  relativePath: string,\n  attachTokenToFilename?: boolean,\n  newToken?: string\n): string => {\n  const name = getNameFromRelativePath(relativePath);\n  if (!attachTokenToFilename) return name;\n  return ensureToken(name, newToken, attachTokenToFilename);\n}"
  },
  "getReferencedAssetApiUrl": {
    "name": "getReferencedAssetApiUrl",
    "slug": "TsFunction",
    "id": "lemcswmkxzpfhxxvxfoxieat",
    "description": "",
    "operationName": "asset-functions-js",
    "rawText": " (\n  apiUrl: string | undefined,\n  projectRelativeReferencingFilePath: string,\n  referencingFileRelativeAssetPath: string,\n  /**\n   * If true, asset will be returned as download\n   */\n  isDownload?: boolean\n): string | undefined => {\n  if (!apiUrl) return undefined;\n  return getGetApiUrl(apiUrl, \"getReferencedAssetGetApi\", {\n    projectRelativeReferencingFilePath,\n    referencingFileRelativeAssetPath,\n    isDownload: isDownload ? \"1\" : undefined,\n  });\n}"
  },
  "getTypeFromUrlOrPath": {
    "name": "getTypeFromUrlOrPath",
    "slug": "TsFunction",
    "id": "jeqxhcjkvspdfsncmpgfzzho",
    "description": "We are assuming the asset name and extsion appear at the end of the URL",
    "operationName": "asset-functions-js",
    "rawText": " (urlOrPath: string): AssetType => {\n  const extension = getExtension(urlOrPath);\n  if ([\"mp3\", \"m4a\", \"wav\"].includes(extension)) return \"audio\";\n  if ([\"mp4\", \"avi\", \"mov\"].includes(extension)) return \"video\";\n  if ([\"jpeg\", \"jpg\", \"png\", \"gif\", \"svg\"].includes(extension)) return \"image\";\n  if (isText(urlOrPath)) return \"text\";\n  return \"other\";\n}"
  },
  "readableSize": {
    "name": "readableSize",
    "slug": "TsFunction",
    "id": "pglsbhldyczdoctshskbnstb",
    "description": "",
    "operationName": "asset-functions-js",
    "rawText": " (sizeBytes: number): string => {\n  if (sizeBytes < 1024) return `${sizeBytes} bytes`;\n  if (sizeBytes < 1024 * 1024) return `${Math.round(sizeBytes / 1024)} kb`;\n  if (sizeBytes < 1024 * 1024 * 1024)\n    return `${Math.round(sizeBytes / (1024 * 1024))} mb`;\n  if (sizeBytes < 1024 * 1024 * 1024 * 1024)\n    return `${Math.round(sizeBytes / (1024 * 1024 * 1024))} gb`;\n  if (sizeBytes < 1024 * 1024 * 1024 * 1024 * 1024)\n    return `${Math.round(sizeBytes / (1024 * 1024 * 1024 * 1024))} tb`;\n\n  return \"waaaay to big\";\n}"
  },
  "removeTokenIfPresent": {
    "name": "removeTokenIfPresent",
    "slug": "TsFunction",
    "id": "pqfxknjmnsheeabwrctzahhm",
    "description": "",
    "operationName": "asset-functions-js",
    "rawText": " (\n  name: string,\n  attachTokenToFilename?: boolean\n) => {\n  if (!attachTokenToFilename) {\n    return { nameWithoutToken: name, token: undefined };\n  }\n  const [nameWithoutToken, token] = name.split(tokenPrefix);\n  return { nameWithoutToken, token: token as string | undefined };\n}"
  },
  "tokenPrefix": {
    "name": "tokenPrefix",
    "slug": "TsVariable",
    "id": "sfhjatkrbjptnqtkjydjiday",
    "description": "NB: any filename should not be expected to enter this as part of its name. Otherwise it breaks the code and the filename will be changed to the thing before this string.\n\nNB: don't put any things inhere that are different, slugified, as the name will be slugified!",
    "operationName": "asset-functions-js"
  },
  "compressAsset": {
    "name": "compressAsset",
    "slug": "TsFunction",
    "id": "sdxggdmqoctkxsopjjsfgmdw",
    "description": "Audio, image, video can be compressed. This should be done to logical defaults, can be turned off, or can be specifically set to other dimensions using a doc-comment on the model.\n\n- audio: bitrate\n- video: fps and resolution\n- image: resolution\n\nReturns the new absolute path of the compressed asset (which can be the same as the initial path)",
    "operationName": "asset-functions-node",
    "rawText": " async (\n  absolutePath: string,\n  compressionConfig: CompressionConfig\n): Promise<string> => {\n  return absolutePath;\n}"
  },
  "deleteReferencedAsset": {
    "name": "deleteReferencedAsset",
    "slug": "TsFunction",
    "id": "iacnupqmjxordilpuaclpimo",
    "description": "",
    "operationName": "asset-functions-node",
    "rawText": " async (\n  projectRelativeReferencingFilePath: string,\n  referencingFileRelativeAssetPath: string\n) => {\n  const { absoluteAssetPath, message, isSuccessful } =\n    await findAbsoluteAssetPathFromReference(\n      projectRelativeReferencingFilePath,\n      referencingFileRelativeAssetPath\n    );\n\n  if (!absoluteAssetPath) {\n    return { isSuccessful, message };\n  }\n\n  // got `absoluteAssetPath`\n\n  await fs.rm(absoluteAssetPath);\n\n  return { isSuccessful: true, message: \"Deleted the asset\" };\n}"
  },
  "downloadRemoteAsset": {
    "name": "downloadRemoteAsset",
    "slug": "TsFunction",
    "id": "agzkyxrhchyksufdvkcaitda",
    "description": "Download a remote asset to the `assets` folder (temporary location)\n\nused for:\n\n- giphy\n- google images\n- unsplashed\n- p2p\n- youtube to mp3 picker\n- youtube to mp4 picker\n- project assets (via api)",
    "operationName": "asset-functions-node",
    "rawText": " async (): Promise<UploadAssetResult> => {\n  return {\n    isSuccessful: false,\n  };\n}"
  },
  "findAbsoluteAssetPathFromReference": {
    "name": "findAbsoluteAssetPathFromReference",
    "slug": "TsFunction",
    "id": "qivnjeigpwyklxeqrrwznpfc",
    "description": "",
    "operationName": "asset-functions-node",
    "rawText": " async (\n  projectRelativeReferencingFilePath: string,\n  referencingFileRelativeAssetPath: string\n): Promise<{\n  isSuccessful: boolean;\n  message: string;\n  absoluteAssetPath?: string;\n}> => {\n  if (\n    !projectRelativeReferencingFilePath ||\n    !referencingFileRelativeAssetPath\n  ) {\n    console.log({\n      projectRelativeReferencingFilePath,\n      referencingFileRelativeAssetPath,\n    });\n    return {\n      isSuccessful: false,\n      message:\n        \"Incorrect parameters for fetching absolute asset from reference\",\n    };\n  }\n  // TODO: STEP 1: ensure the user is authenticated and can access the referencing file\n\n  const projectRoot = getProjectRoot();\n  if (!projectRoot)\n    return {\n      isSuccessful: false,\n      message: \"No project root\",\n    };\n\n  const extension = getExtension(projectRelativeReferencingFilePath);\n  const allowedExtensions = [\"ts\", \"tsx\", \"md\", \"mdx\", \"json\"];\n  if (!allowedExtensions.includes(extension)) {\n    return {\n      isSuccessful: false,\n      message: \"Invalid extension\",\n    };\n  }\n\n  const absoluteReferencingFilePath = path.join(\n    projectRoot,\n    projectRelativeReferencingFilePath\n  );\n\n  const exists = fs.existsSync(absoluteReferencingFilePath);\n\n  if (!exists) {\n    return {\n      isSuccessful: false,\n      message: \"Invalid file\",\n    };\n  }\n\n  const contents = await fs.readFile(absoluteReferencingFilePath, \"utf8\");\n\n  const patternType = extension === \"json\" ? \"json\" : \"markdown\";\n\n  const pattern =\n    patternType === \"json\"\n      ? `\"relativePath\": \"${referencingFileRelativeAssetPath}\"`\n      : `](${referencingFileRelativeAssetPath})`;\n\n  const foundPattern = contents.includes(pattern);\n\n  const filename = path.parse(projectRelativeReferencingFilePath).name;\n\n  /**\n   * If the name of the file is extending the name of the referencing file, it doesn't need to be referenced, as it can be assumed it's an indexation file.\n   */\n  const isIndexationFile = referencingFileRelativeAssetPath.startsWith(\n    `./${filename}`\n  );\n\n  if (!foundPattern && !isIndexationFile) {\n    // console.log({ contents, pattern });\n    return {\n      isSuccessful: false,\n      message: \"Pattern not found\",\n    };\n  }\n\n  const referencingFileFolderPath = path.parse(absoluteReferencingFilePath).dir;\n\n  const absoluteAssetPath = path.join(\n    referencingFileFolderPath,\n    referencingFileRelativeAssetPath\n  );\n\n  if (!fs.existsSync(absoluteAssetPath)) {\n    return {\n      isSuccessful: false,\n      message: \"The referenced asset does not exist\",\n    };\n  }\n\n  return { isSuccessful: true, message: \"Found path\", absoluteAssetPath };\n}"
  },
  "findAllProjectMedia": {
    "name": "findAllProjectMedia",
    "slug": "TsFunction",
    "id": "qrcrggkxvakrilxockbehctx",
    "description": "Media:`.png`, `.mp4`, `.mp3`, `.zip`, `.pdf`\n\n- finds all media in all `db` folders. Can be anywhere, so an explore will probably be best.\n- finds all media in every operation in any folder except for `node_modules`, `db`, `src`, `build`, `.[anything]`. (so mostly in `todo`, `docs` and `assets`)\n- find all media in every other folder that is not an operation\n\nReturn all of this as project relative path array",
    "operationName": "asset-functions-node",
    "rawText": " async (\n  searchQuery?: string,\n  /**\n   * defaults to absolute\n   */\n  returnType?: \"projectRelative\" | \"absolute\"\n): Promise<string[]> => {\n  const projectRoot = getProjectRoot();\n\n  if (!projectRoot) return [];\n\n  const dbPath = path.join(projectRoot, databaseFolderName);\n\n  const operationBasePaths = Object.values(operations).map(\n    (projectRelativePath) => path.join(projectRoot, projectRelativePath)\n  );\n\n  const databaseFolderPaths = operationBasePaths\n    .map((absoluteOperationPath) =>\n      path.join(absoluteOperationPath, databaseFolderName)\n    )\n    .concat(dbPath)\n    .filter(fs.existsSync);\n\n  const dbResults = await explore({\n    basePath: databaseFolderPaths,\n    extension: mediaExtensions,\n    search: searchQuery,\n  });\n\n  const operationResults = await explore({\n    basePath: operationBasePaths,\n    extension: mediaExtensions,\n    ignore: [...generatedFolders, databaseFolderName, sourceFolderName],\n    search: searchQuery,\n  });\n\n  const anywhereResults = await explore({\n    cancelRecursionOn: pathArrayIsOperation,\n    basePath: projectRoot,\n    extension: mediaExtensions,\n    ignore: [databaseFolderName, \"node_modules\", \".git\"],\n  });\n\n  const results = [dbResults, operationResults, anywhereResults]\n    .flat()\n    .map((x) => x.path);\n\n  return returnType === \"projectRelative\"\n    ? results.map((x) => makeRelative(x, projectRoot))\n    : results;\n}"
  },
  "getAssetDirectlyGetApi": {
    "name": "getAssetDirectlyGetApi",
    "slug": "TsFunction",
    "id": "afysdzmqxopzksvruycetcwz",
    "description": "Useful for getting assets directly, for example for the `SelectMedia` component for `project`-media\n\nRequires more access rights\n\nRun server without too much queue execution\n\n1) Launch telebit on server startup\n\n2) Expose GET ASSET DIRECTLY, publicly, temporarily (but require a passcode in that case). Passcode should match one of the values in [filepath].public\n\n3) convert the absolute path into a HTTPS URL that can be used as imageUrl (this should be a function where you can specify to use a general purpose passcode, or a OTP, or a unique passcode)\n\n4) have a function to remove the passcode.",
    "operationName": "asset-functions-node",
    "rawText": " (\n  serverContext: Context\n): { isSuccessful: boolean; message: string } | void => {\n  /**\n  \n  const authToken = (ctx as any).cookies?.authToken;\n  const authToken2 = ctx.cookie?.authToken;\n\n  console.log({\n    authToken,\n    authToken2,\n    cookie: ctx.cookie,\n    cookies: (ctx as any).cookies,\n    headers: ctx.req.headers,\n  });\n  const isAuthed = functionAuthPlugin(\"uploadAsset\", authToken);\n  if (!isAuthed) {\n    return {\n      isSuccessful: false,\n      isUnauthorized: true,\n      message: \"You can only do this when authenticated\",\n    };\n  }\n  */\n  const isDownload = takeFirst(serverContext?.query.isDownload) === \"1\";\n\n  const projectRelativeAssetPath = takeFirst(\n    serverContext?.query.projectRelativeAssetPath\n  );\n\n  // Quick hack to keep it secure, only allow public stuff\n  if (!projectRelativeAssetPath.startsWith(\"public/\"))\n    return {\n      isSuccessful: false,\n      message: \"not allowed for now, only public data\",\n    };\n\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return {\n      isSuccessful: false,\n      message: \"No project root\",\n    };\n  }\n\n  if (!projectRelativeAssetPath) {\n    console.log({ p: serverContext?.query });\n    return {\n      isSuccessful: false,\n      message: \"No path given\",\n    };\n  }\n\n  const absoluteAssetPath = path.join(projectRoot, projectRelativeAssetPath);\n\n  const exists = fs.existsSync(absoluteAssetPath);\n\n  if (!exists) {\n    return {\n      isSuccessful: false,\n      message: \"Invalid file\",\n    };\n  }\n\n  return serverDownloadReply(absoluteAssetPath, isDownload);\n}"
  },
  "getReferencedAssetGetApi": {
    "name": "getReferencedAssetGetApi",
    "slug": "TsFunction",
    "id": "hjguernoeitjcldkyyznhory",
    "description": "Function to get a referenced asset that has been referenced from any db-model or any ts, tsx or md file, anywhere in the project.\n\nAssets should only be exposed if you have access to the model they are referenced in or to the md file they are referenced in.\n\nExposes all assets like `/asset?path=/text/interests/programming/storage-of-data/best-storage-methods.md&asset=./audio-is-amazing.m4a`\n\n\n# Security\n\nAssets are only exposed if they are referenced in a markdown file that is accessible to the user. So when looking up the asset, make sure there's a link to it via `[]()` or `![]()` in the markdown that is connected to it in the URL. If not, don't expose it!\n\nThis can be used for any ui that has the functions backend available.\n\nThe advantage is that we don't need to build it, this works in `dev` mode. there is no asset duplication.\n\nsince the name is `getReferencedAssetGetApi` this should be exposed on `getReferencedAsset`\n\nIMPLEMENTATION NOW:\n\n- check referencing file to find the reference.\n- for markdown, typescript: `](./xyz)`\n- for json: `\"relativePath\": \"./xyz\"`\n\n- If this occurs, calculate abosolute asset path from referencing file folder + relative path\n\n- If this asset exists, expose it.",
    "operationName": "asset-functions-node",
    "rawText": " async (\n  serverContext: Context\n): Promise<{\n  isSuccessful: boolean;\n  isUnauthorized?: boolean;\n  message: string;\n}> => {\n  if (!serverContext) {\n    return { isSuccessful: false, message: \"No server context provided\" };\n  }\n  /**\n  const authToken = (ctx as any).cookies?.authToken;\n  const authToken2 = ctx.cookie?.authToken;\n\n  console.log({\n    authToken,\n    authToken2,\n    cookie: ctx.cookie,\n    cookies: (ctx as any).cookies,\n    headers: ctx.req.headers,\n  });\n\n  const isAuthed = functionAuthPlugin(\"uploadAsset\", authToken);\n  if (!isAuthed) {\n    return {\n      isSuccessful: false,\n      isUnauthorized: true,\n      message: \"You can only do this when authenticated\",\n    };\n  }\n  */\n  const isDownload = takeFirst(serverContext.query.isDownload) === \"1\";\n\n  const projectRelativeReferencingFilePath = takeFirst(\n    serverContext.query.projectRelativeReferencingFilePath\n  );\n\n  const referencingFileRelativeAssetPath = takeFirst(\n    serverContext?.query.referencingFileRelativeAssetPath\n  );\n\n  const { absoluteAssetPath, message, isSuccessful } =\n    await findAbsoluteAssetPathFromReference(\n      projectRelativeReferencingFilePath,\n      referencingFileRelativeAssetPath\n    );\n\n  if (!absoluteAssetPath) {\n    return { isSuccessful, message };\n  }\n\n  return serverDownloadReply(absoluteAssetPath, isDownload);\n}"
  },
  "getStorageLocationInfo": {
    "name": "getStorageLocationInfo",
    "slug": "TsFunction",
    "id": "eltidekmoztexkhvpuwqbtnb",
    "description": "returns the  type of file the asset is referenced from, and the `baseFolderPath` where the `asset` should be stored",
    "operationName": "asset-functions-node",
    "rawText": " (\n  absoluteReferencingFilePath: string,\n  modelName?: string\n): {\n  type: \"typescript\" | \"database\" | \"markdown\";\n  absoluteAssetBaseFolderPath: string;\n} => {\n  if (absoluteReferencingFilePath.includes(`/${sourceFolderName}/`)) {\n    /**\n     *In typescript, the asset can be stored in the `/assets` folder of the operation. The alt is in the markdown.\n     */\n    const operationBasePath = findOperationBasePath(\n      absoluteReferencingFilePath\n    );\n    if (operationBasePath) {\n      const assetsPath = path.join(operationBasePath, \"assets\");\n\n      return { type: \"typescript\", absoluteAssetBaseFolderPath: assetsPath };\n    }\n  }\n  if (\n    modelName &&\n    absoluteReferencingFilePath.includes(`/${databaseFolderName}/`)\n  ) {\n    const databaseFolderBasePath = absoluteReferencingFilePath\n      .split(`/${databaseFolderName}/`)[0]\n      .concat(`/${databaseFolderName}`);\n\n    const databaseFolderRelativeReferenceLocationPath = makeRelative(\n      absoluteReferencingFilePath,\n      databaseFolderBasePath\n    );\n    const isStoredInFolder =\n      databaseFolderRelativeReferenceLocationPath.split(\"/\").length > 1;\n\n    const absoluteAssetBaseFolderPath = isStoredInFolder\n      ? path.parse(absoluteReferencingFilePath).dir\n      : path.join(databaseFolderBasePath, `${kebabCase(modelName)}-assets`);\n\n    /**\n     * In database models, the asset can be stored in\n     *\n     * - in `[modelName]-assets` folder inside of `db` if the data is stored in the root of the db\n     * - in the same folder as the data itself if the data is stored in folders and more separated files\n     */\n    return { type: \"database\", absoluteAssetBaseFolderPath };\n  }\n\n  /**\n   * In markdown, the asset can be stored in the same folder as the markdown file. The alt is in the markdown. The filename can be something else, should be kept original unless changed\n   */\n  return {\n    type: \"markdown\",\n    absoluteAssetBaseFolderPath: path.parse(absoluteReferencingFilePath).dir,\n  };\n}"
  },
  "getTemporaryAssetsFolderPath": {
    "name": "getTemporaryAssetsFolderPath",
    "slug": "TsFunction",
    "id": "swdwxieqjvbukkubkmxlmeom",
    "description": "",
    "operationName": "asset-functions-node",
    "rawText": " () => {\n  return path.join(__dirname, \"..\", \"assets\");\n}"
  },
  "mediaExtensions": {
    "name": "mediaExtensions",
    "slug": "TsVariable",
    "id": "dsuccnchcjfxhkpkeiuvjomh",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "processAsset": {
    "name": "processAsset",
    "slug": "TsFunction",
    "id": "gcyfiamqokbmstfwupjbvinc",
    "description": "Processes an asset by moving the file in the right location, if needed...\n\n- Alt is kept, nothing to do with it\n- Giving a different name will change the new path\n- relativePath is checked if it exists (if temporaryDestination is undefined). It is used to obtain the extension.\n- temporaryDestination must be checked. if it exists, must replace the file on relativePath calculated from name\n\nAfter processing, this function should return a `BackendAsset` without the non-storable parameters\n\nBEWARE: `absoluteReferencingFilePath`, and for db-models also `modelName`, need to be given here! Otherwise this won't work!",
    "operationName": "asset-functions-node",
    "rawText": " async (\n  /**\n   * The backendAsset that may need processing\n   */\n  backendAsset?: BackendAsset | BackendAsset[]\n): Promise<undefined | BackendAsset> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    console.log(\"processAsset: No project root\");\n    return;\n  }\n  const realBackendASset = backendAsset ? takeFirst(backendAsset) : undefined;\n\n  if (!realBackendASset) {\n    console.log(\"processAsset: No real backend asset\");\n\n    return;\n  }\n\n  const {\n    alt,\n    name,\n    relativePath,\n    temporaryDestination,\n    projectRelativeReferencingFilePath,\n    modelName,\n  } = realBackendASset;\n\n  if (!projectRelativeReferencingFilePath) {\n    log(\n      `processAsset: projectRelativeReferencingFilePath wasn't provided, not processing asset`,\n      { type: \"warning\" }\n    );\n    return undefined;\n  }\n\n  const absoluteReferencingFilePath = path.join(\n    projectRoot,\n    projectRelativeReferencingFilePath\n  );\n\n  // console.log(\"processing asset\", { backendAsset });\n  const slugifiedName = slugify(name && name.length > 0 ? name : \"untitled\");\n\n  if (!relativePath && !temporaryDestination) {\n    log(\"processAsset: no relativePath, no temporaryDestination\", {\n      type: \"warning\",\n    });\n    // NB: we must have either a relativePath or a temporaryDestination, otherwise this is an invalid input\n    return undefined;\n  }\n\n  const absoluteTemporaryDestination = temporaryDestination\n    ? path.join(getTemporaryAssetsFolderPath(), temporaryDestination)\n    : undefined;\n\n  // NB: If a `temporaryDestination` is given, if it doesn't exist, we return nothing, this is an invalid input.\n  if (absoluteTemporaryDestination) {\n    if (!fs.existsSync(absoluteTemporaryDestination)) {\n      log(\"processAsset: absoluteTemporaryDestination does not exist\", {\n        type: \"warning\",\n      });\n\n      return undefined;\n    }\n  }\n\n  const oldAssetStoragePath = relativePath\n    ? path.join(path.parse(absoluteReferencingFilePath).dir, relativePath)\n    : undefined;\n\n  // NB: if a relativePath is provided without a temporaryDestination, it means the file should already be there. If it's not there, we return nothing, invalid input.\n  if (oldAssetStoragePath && !temporaryDestination) {\n    if (!fs.existsSync(oldAssetStoragePath)) {\n      log(\n        `processAsset: oldAssetStoragePath does not exist (${oldAssetStoragePath})`,\n        {\n          type: \"warning\",\n        }\n      );\n\n      return undefined;\n    }\n  }\n\n  // Now we can assume the extension of the temporarydestination is correct, because it gets put there from upload\n  const extension = temporaryDestination\n    ? temporaryDestination.split(\".\").pop()\n    : relativePath?.split(\".\").pop();\n\n  if (!extension) {\n    log(\"processAsset: could not create extension\", { type: \"warning\" });\n\n    // NB: extension must exist now.\n    return undefined;\n  }\n\n  /*\n   */\n\n  const storageLocationInfo = getStorageLocationInfo(\n    absoluteReferencingFilePath,\n    modelName\n  );\n\n  const finalAssetStoragePath = path.join(\n    storageLocationInfo.absoluteAssetBaseFolderPath,\n    `${slugifiedName}.${extension}`\n  );\n\n  let finalAvailableStoragePath: string = finalAssetStoragePath;\n\n  if (absoluteTemporaryDestination) {\n    finalAvailableStoragePath = getFirstAvailableFilename(\n      finalAssetStoragePath\n    );\n\n    await renameAndCreate(\n      absoluteTemporaryDestination,\n      finalAvailableStoragePath\n    );\n  } else if (oldAssetStoragePath) {\n    if (oldAssetStoragePath !== finalAssetStoragePath) {\n      finalAvailableStoragePath = getFirstAvailableFilename(\n        finalAssetStoragePath\n      );\n\n      // the name has changed\n      await renameAndCreate(oldAssetStoragePath, finalAvailableStoragePath);\n    }\n  }\n\n  const newRelativePath = getRelativeLinkPath(\n    absoluteReferencingFilePath,\n    finalAvailableStoragePath\n  );\n\n  //({ newRelativePath });\n\n  console.log({ alt, relativePath });\n  return { alt, relativePath: newRelativePath };\n}"
  },
  "processItemAssets": {
    "name": "processItemAssets",
    "slug": "TsFunction",
    "id": "tqzweestxsmtmbbfaedozoll",
    "description": "processes all assets in an item and returns the new item",
    "operationName": "asset-functions-node",
    "rawText": " async <KInterfaceName extends keyof DbModels>(\n  item: AugmentedAnyModelType,\n  interfaceName: KInterfaceName,\n  operationName: string | null,\n  customQueryConfig: CustomQueryConfig\n): Promise<AugmentedAnyModelType | undefined> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n  const absoluteReferencingFilePath = await db.getDbFileLocationPath(\n    item,\n    operationName,\n    interfaceName,\n    customQueryConfig\n  );\n  if (!absoluteReferencingFilePath) return item;\n\n  const projectRelativeReferencingFilePath = makeRelative(\n    absoluteReferencingFilePath,\n    projectRoot\n  );\n\n  const assetParameters = findAssetParametersRecursively(item);\n\n  const assetsToPutOnObject = await Promise.all(\n    assetParameters.map(async (assetParameter) => {\n      const location = [\n        ...(assetParameter.stack || []),\n        assetParameter.parameterName,\n      ];\n\n      const value = getParameterAtLocation<\n        BackendAsset | BackendAsset[] | undefined\n      >(item, location);\n\n      const backendAssetToStore = Array.isArray(value)\n        ? (\n            await Promise.all(\n              value.map((asset) =>\n                processAsset({\n                  ...asset,\n                  projectRelativeReferencingFilePath,\n                  modelName: interfaceName,\n                })\n              )\n            )\n          ).filter(notEmpty)\n        : value\n        ? await processAsset({\n            ...value,\n            projectRelativeReferencingFilePath,\n            modelName: interfaceName,\n          })\n        : undefined;\n\n      return { backendAssetToStore, location };\n    })\n  );\n\n  assetsToPutOnObject.forEach((assetWithLocation) => {\n    setKeyAtLocation(\n      assetWithLocation.location.join(\".\"),\n      assetWithLocation.backendAssetToStore,\n      item\n    );\n  });\n\n  // console.dir(\n  //   { assetParameters, assetsToPutOnObject, finalItem: item },\n  //   { depth: 999 }\n  // );\n\n  return item;\n}"
  },
  "removeOldTemporaryAssets": {
    "name": "removeOldTemporaryAssets",
    "slug": "TsFunction",
    "id": "pvacxvezpxkjloyusmkdxhph",
    "description": "---\nrunEveryPeriod: midnight\n---\n\n\nAll temporary assets that were created more than 24 hours ago and are still there, will be removed by this function.\n\nThis allows us to easily delete assets without concequences and also if the user closes a form without submitting it, these assets uploaded will go away.\n\nThis function should be executed using a daily CRON",
    "operationName": "asset-functions-node",
    "rawText": " async (): Promise<{\n  removedAmount: number;\n}> => {\n  const temporaryAssetsFolderPath = getTemporaryAssetsFolderPath();\n  const contents = await fs.readdir(temporaryAssetsFolderPath, {\n    encoding: \"utf8\",\n  });\n\n  let removedAmount = 0;\n  await Promise.all(\n    contents.map(async (fileOrFolderName) => {\n      const absolutePath = path.join(\n        temporaryAssetsFolderPath,\n        fileOrFolderName\n      );\n\n      const statistics = await fs.stat(absolutePath);\n\n      if (Date.now() - statistics.ctimeMs > 86400 * 1000) {\n        removedAmount++;\n        // more than a day old\n        await fs.rm(absolutePath, { recursive: true });\n      }\n    })\n  );\n\n  return { removedAmount };\n}"
  },
  "serverDownloadReply": {
    "name": "serverDownloadReply",
    "slug": "TsFunction",
    "id": "mmnnhpvtzwwxowtwolxmomgc",
    "description": "Returns a `server.reply.download` or `server.reply.file` but also sets the `Content-Disposition` header correctly and the `Content-Type`\n\n\n\nFor this I finally ended up using builtin server.js stuff, we don't need to set those manually...\n\nSee https://serverjs.io/documentation/reply/#file-\nAnd https://serverjs.io/documentation/reply/#download-\n\nSee https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition\n\nNB: ensure to return the result of this function in your endpoint, otherwise it won't work",
    "operationName": "asset-functions-node",
    "rawText": " (\n  absoluteAssetPath: string,\n  isDownload: boolean\n) => {\n  const parsedAsset = path.parse(absoluteAssetPath);\n\n  if (isDownload) {\n    return server.reply.download(absoluteAssetPath, parsedAsset.base);\n  }\n  return (\n    server.reply\n      // @ts-ignore NB: TODO: why doesn't server.js has the right types???\n      .file(absoluteAssetPath)\n  );\n}"
  },
  "uploadAssetWithContext": {
    "name": "uploadAssetWithContext",
    "slug": "TsFunction",
    "id": "eofzlewlzaglioenmlxgwlow",
    "description": "Uploads an asset to the server, and puts it in a temporary location in the assets folder of `function-server`. It returns the filename of the file in the temporary location.\n\nIt can only be accessed through that random name. This random name has 32 characters so cannot be easily guessed. This should be secure enough. The file should be moved to the final destination in the actual function that needs the file.\n\nNB: this function only works by providing a file as blobs under the \"file\" property name!",
    "operationName": "asset-functions-node",
    "rawText": " async (\n  functionContext: FunctionContext\n): Promise<UploadAssetResult> => {\n  const file = functionContext.serverContext?.files.file;\n  if (!file) {\n    console.log(\"Got no file, fuktup\");\n    return { isSuccessful: false, message: \"No file found\" };\n  }\n\n  const realFile = (Array.isArray(file)\n    ? file[0]\n    : file) as unknown as ReceivedFile;\n\n  const functionFile = {\n    size: realFile.size,\n    path: realFile.path,\n    name: realFile.name,\n    type: realFile.type,\n  };\n\n  const randomName = generateRandomString(32);\n  const temporaryAssetsFolderPath = getTemporaryAssetsFolderPath();\n  const conversionInfo = getConversionInfoFromType(realFile.type);\n\n  console.log({ conversionInfo });\n\n  const temporaryFileName = `${randomName}.${conversionInfo.targetFormat}`;\n  const absoluteTemporaryDestinationPath = path.join(\n    temporaryAssetsFolderPath,\n    temporaryFileName\n  );\n\n  if (!fs.existsSync(temporaryAssetsFolderPath)) {\n    await fs.mkdir(temporaryAssetsFolderPath, { recursive: true });\n  }\n\n  if (conversionInfo.targetFormat === \"mp3\") {\n    // Conversion needed!\n    const resultingPath = await convertToMp3(\n      functionFile.path,\n      absoluteTemporaryDestinationPath\n    );\n  } else if (conversionInfo.targetFormat === \"mp4\") {\n    // in many cases, conversion needed\n    const resultingPath = await convertToMp4(\n      functionFile.path,\n      absoluteTemporaryDestinationPath\n    );\n  } else {\n    await fs.rename(functionFile.path, absoluteTemporaryDestinationPath);\n  }\n\n  return {\n    isSuccessful: true,\n    message: \"File received\",\n    temporaryDestination: temporaryFileName,\n  };\n}"
  },
  "ASPECT_RATIO": {
    "name": "ASPECT_RATIO",
    "slug": "TsVariable",
    "id": "oekxstdkophtxxbtlmiwhuwd",
    "description": "",
    "operationName": "asset-input"
  },
  "AssetInput": {
    "name": "AssetInput",
    "slug": "TsFunction",
    "id": "gbdvhquvlqzmibpefopuuuzk",
    "description": "",
    "operationName": "react-with-native-form-asset-input",
    "rawText": " (props) => {\n  const { onChange, value, extra, errors, className } = props;\n\n  const config = props.config || {};\n\n  const hasError = errors && errors.length > 0;\n  const inputClassWithError = `\n  w-full\n  ${InputTheme[extra?.theme]} \n  ${InputSize[extra?.size]}\n    ${\n      hasError\n        ? config.errorClassName\n          ? config.errorClassName\n          : \" border border-red-400\"\n        : \"\"\n    }`;\n\n  return (\n    <OriginalAssetInput\n      attachTokenToFilename={extra.attachTokenToFilename}\n      defaultAssetName={extra.defaultAssetName}\n      projectRelativeReferencingFilePath={\n        extra.projectRelativeReferencingFilePath\n      }\n      modelName={extra.modelName}\n      allowMultiple={extra.allowMultiple}\n      inputTypes={extra.inputTypes}\n      value={value}\n      onChange={(newAssets) => onChange(newAssets)}\n    />\n  );\n}"
  },
  "Audio": {
    "name": "Audio",
    "slug": "TsFunction",
    "id": "zxwkonbcfdhgfcoalcutxaam",
    "description": "",
    "operationName": "asset-input",
    "rawText": " (\n  props: React.DetailedHTMLProps<\n    React.AudioHTMLAttributes<HTMLAudioElement>,\n    HTMLAudioElement\n  >\n) => <audio {...props} />"
  },
  "base64UrltoBlob": {
    "name": "base64UrltoBlob",
    "slug": "TsFunction",
    "id": "nmxqmfixbbhgxvtrwmqgfcif",
    "description": "Taken from https://github.com/mozmorris/react-webcam/issues/65#issuecomment-385126201\n\nThere are probably much better solutions",
    "operationName": "asset-input",
    "rawText": " (dataurl: string | null) => {\n  if (!dataurl) return;\n  const arr = dataurl.split(\",\");\n  const mime = arr[0].match(/:(.*?);/)?.[1];\n  const bstr = atob(arr[1]);\n\n  let n = bstr.length;\n  const u8arr = new Uint8Array(n);\n\n  while (n--) {\n    u8arr[n] = bstr.charCodeAt(n);\n  }\n\n  return new Blob([u8arr], { type: mime });\n}"
  },
  "FileInput": {
    "name": "FileInput",
    "slug": "TsFunction",
    "id": "xslpjweftkqoxhihdfutgnkc",
    "description": "import Icon from \"./icon.svg\";",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  extra,\n  onChange,\n}) => {\n  const { getRootProps, getInputProps, acceptedFiles } = useDropzone({});\n\n  useEffect(() => {\n    onChange(acceptedFiles);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [acceptedFiles]);\n\n  const files = acceptedFiles.map((file: FileWithPath) => (\n    <Li key={file.path} className=\"text-sm\">\n      {file.path}\n    </Li>\n  ));\n\n  return (\n    <Div\n      className=\"flex justify-center px-6 pt-5 pb-6 mt-1 border-2 border-gray-300 border-dashed rounded-md\"\n      {...getRootProps()}\n    >\n      <Div className=\"space-y-1 text-center\">\n        {/* <Icon /> */}\n        <Div className=\"flex text-sm text-center text-gray-600\">\n          <Label\n            htmlFor=\"file-upload\"\n            className=\"relative font-medium text-indigo-600 bg-white rounded-md cursor-pointer hover:text-indigo-500 focus-within:outline-none focus-within:ring-2 focus-within:ring-offset-2 focus-within:ring-indigo-500\"\n          />\n          <Input id=\"file-upload\" type=\"file\" {...getInputProps()} />\n        </Div>\n        <P className=\"text-xs text-gray-500\">PNG, JPG, GIF en PDF tot 15MB</P>\n        {acceptedFiles.length > 0 ? (\n          <Aside>\n            <Ul>{files}</Ul>\n          </Aside>\n        ) : null}\n      </Div>\n    </Div>\n  );\n}"
  },
  "getTypeFromFileBlob": {
    "name": "getTypeFromFileBlob",
    "slug": "TsFunction",
    "id": "bkatitucdfcnvswiqdanonps",
    "description": "",
    "operationName": "asset-input",
    "rawText": " (file: File) => {\n  const typeFirstPart = file.type.split(\"/\")[0];\n\n  const firstPartAssetTypes = [\"image\", \"video\", \"audio\"];\n\n  const type: AssetType = firstPartAssetTypes.includes(typeFirstPart)\n    ? (typeFirstPart as AssetType)\n    : \"other\";\n\n  return type;\n}"
  },
  "HEIGHT": {
    "name": "HEIGHT",
    "slug": "TsVariable",
    "id": "rnlobnyrrzkellfmbgpbxdgl",
    "description": "",
    "operationName": "asset-input"
  },
  "makeBackendAsset": {
    "name": "makeBackendAsset",
    "slug": "TsFunction",
    "id": "kaxqwlmhewleqyshngzwfjfp",
    "description": "",
    "operationName": "asset-input",
    "rawText": " (\n  asset: Asset,\n  projectRelativeReferencingFilePath: string,\n  modelName?: string\n): BackendAsset => {\n  return {\n    alt: asset.alt,\n    name: asset.name,\n    relativePath: asset.relativePath,\n    temporaryDestination: asset.temporaryDestination,\n    projectRelativeReferencingFilePath,\n    modelName,\n  };\n}"
  },
  "MediaRecorderComponent": {
    "name": "MediaRecorderComponent",
    "slug": "TsFunction",
    "id": "dzlruyhvqusuyrzenauqcpnl",
    "description": "",
    "operationName": "asset-input",
    "rawText": " (\n  props: ReactMediaRecorderRenderProps & { type: MediaRecorderType }\n) => {\n  const {\n    status,\n    startRecording,\n    stopRecording,\n    pauseRecording,\n    resumeRecording,\n    previewAudioStream,\n    mediaBlobUrl,\n    previewStream,\n    type,\n    muteAudio,\n    unMuteAudio,\n    isAudioMuted,\n  } = props;\n\n  const AudioOrVideo = type === \"audio\" ? Audio : Video;\n\n  const buttons =\n    status === \"acquiring_media\"\n      ? []\n      : status === \"recording\"\n      ? [\n          <button key=\"stop\" onClick={stopRecording}>\n            ⏹\n          </button>,\n          <button key=\"pause\" onClick={pauseRecording}>\n            ⏸\n          </button>,\n          type === \"video\" || type === \"screen\" ? (\n            isAudioMuted ? (\n              <button key=\"unmute\" onClick={unMuteAudio}>\n                🔈\n              </button>\n            ) : (\n              <button key=\"mute\" onClick={muteAudio}>\n                🔇\n              </button>\n            )\n          ) : undefined,\n        ]\n      : status === \"paused\"\n      ? [\n          <button key=\"stop\" onClick={stopRecording}>\n            ⏹\n          </button>,\n          <button key=\"pause\" onClick={resumeRecording}>\n            ▶️\n          </button>,\n        ]\n      : [\n          <button key=\"start\" onClick={startRecording}>\n            ⏺\n          </button>,\n        ];\n\n  return (\n    <div>\n      {buttons}\n      {mediaBlobUrl && status !== \"recording\" ? (\n        <AudioOrVideo src={mediaBlobUrl} controls autoPlay />\n      ) : null}\n      {type === \"video\" && previewStream && status === \"recording\" ? (\n        <VideoPreview stream={previewStream} />\n      ) : null}\n      {type === \"audio\" && previewAudioStream && status === \"recording\"\n        ? // TODO: visualise with https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Visualizations_with_Web_Audio_API\n          null\n        : null}\n    </div>\n  );\n}"
  },
  "MediaRecorder": {
    "name": "MediaRecorder",
    "slug": "TsFunction",
    "id": "iqqtdgvnogwppwgeulurxtbp",
    "description": "",
    "operationName": "asset-input",
    "rawText": " (props: {\n  type: MediaRecorderType;\n  withBlob: (blobUrl: string, blob: Blob) => void;\n}) => {\n  const { type, withBlob } = props;\n\n  return (\n    <div>\n      <ReactMediaRecorder\n        screen={type === \"screen\"}\n        audio\n        blobPropertyBag={{ type: type === \"audio\" ? \"audio/wav\" : \"video/mp4\" }}\n        // audio={type === \"audio\"}\n        video={type === \"video\"}\n        stopStreamsOnStop\n        onStop={(blobUrl, blob) => {\n          withBlob(blobUrl, blob);\n        }}\n        render={(props) => <MediaRecorderComponent {...props} type={type} />}\n      />\n    </div>\n  );\n}"
  },
  "ReactMediaRecorder": {
    "name": "ReactMediaRecorder",
    "slug": "TsFunction",
    "id": "kknfkaqwtpggkpacrgfyiehs",
    "description": "",
    "operationName": "asset-input",
    "rawText": " (props: ReactMediaRecorderProps) =>\n  props.render(useReactMediaRecorder(props))"
  },
  "SelectMedia": {
    "name": "SelectMedia",
    "slug": "TsFunction",
    "id": "rnyqldcfdulzsyqzmvlvyfsb",
    "description": "",
    "operationName": "asset-input",
    "rawText": " (props: {\n  /**\n   * NB: please don't change the source after initialisation!\n   */\n  source: MediaSourceEnum;\n}) => {\n  // make an api for all different sources\n  const { source } = props;\n\n  // get the right media from api\n\n  // show the results using\n  return <Div>A picker for media from {props.source} should come here</Div>;\n}"
  },
  "videoConstraints": {
    "name": "videoConstraints",
    "slug": "TsVariable",
    "id": "ggydaeatofhfqzljhhswfwvs",
    "description": "",
    "operationName": "asset-input"
  },
  "VideoPreview": {
    "name": "VideoPreview",
    "slug": "TsFunction",
    "id": "lnozphpnkddfzqhkkmxicooe",
    "description": "",
    "operationName": "asset-input",
    "rawText": " ({ stream }: { stream: MediaStream | null }) => {\n  const videoRef = useRef<HTMLVideoElement>(null);\n\n  useEffect(() => {\n    if (videoRef.current && stream) {\n      videoRef.current.srcObject = stream;\n    }\n  }, [stream]);\n  if (!stream) {\n    return null;\n  }\n  return <video ref={videoRef} width={500} height={500} autoPlay controls />;\n}"
  },
  "Video": {
    "name": "Video",
    "slug": "TsFunction",
    "id": "prwuwmrondcozmqdbscxxaen",
    "description": "",
    "operationName": "asset-input",
    "rawText": " (\n  props: React.DetailedHTMLProps<\n    React.AudioHTMLAttributes<HTMLVideoElement>,\n    HTMLVideoElement\n  >\n) => <video {...props} />"
  },
  "WebcamCapture": {
    "name": "WebcamCapture",
    "slug": "TsFunction",
    "id": "jgxmpdkkmtxeajshxrzxznlx",
    "description": "",
    "operationName": "asset-input",
    "rawText": " (props: {\n  withBlob: (blobUrl: string, blob: Blob) => void;\n}) => {\n  const [snapshot, setSnapshot] = useState<string | null>(null);\n  const { withBlob } = props;\n  return (\n    <Webcam\n      audio={false}\n      height={HEIGHT}\n      width={WIDTH}\n      screenshotFormat=\"image/jpeg\"\n      videoConstraints={videoConstraints}\n      className=\"w-full h-full flex\"\n    >\n      {({ getScreenshot }) => {\n        return (\n          <Div className=\"relative\">\n            {snapshot ? (\n              <Image\n                src={snapshot}\n                className=\"absolute bottom-6 left-10 w-1/5 aspect-auto\"\n              />\n            ) : null}\n\n            <Button\n              className=\"hover:bg-gray-200 absolute bottom-6 left-1/2 p-4 border border-black bg-white rounded-full\"\n              onClick={() => {\n                const base64Url = getScreenshot();\n                const blob = base64UrltoBlob(base64Url);\n                const blobUrl = blob ? URL.createObjectURL(blob) : undefined;\n                setSnapshot(base64Url);\n                if (!blob || !blobUrl) return;\n\n                withBlob(blobUrl, blob);\n              }}\n            >\n              📸\n            </Button>\n          </Div>\n        );\n      }}\n    </Webcam>\n  );\n}"
  },
  "WIDTH": {
    "name": "WIDTH",
    "slug": "TsVariable",
    "id": "ytuprnditeoatsaqhxohwtlk",
    "description": "",
    "operationName": "asset-input"
  },
  "AssetView": {
    "name": "AssetView",
    "slug": "TsFunction",
    "id": "pvhezkfjxhxlibuyrvtvzmxh",
    "description": "",
    "operationName": "asset-view",
    "rawText": " (props: {\n  asset: Asset;\n  className?: string;\n  /**\n   * Must be provided for relative assets to know the location\n   */\n  projectRelativeReferencingFilePath?: string;\n  hideDownloadLink?: boolean;\n}) => {\n  const {\n    asset,\n    className,\n    projectRelativeReferencingFilePath,\n    hideDownloadLink,\n  } = props;\n\n  const result = useAsset(asset, projectRelativeReferencingFilePath, !isDev);\n  const { downloadUrl, rawText, src, type, extension } =\n    destructureOptionalObject(result);\n\n  // console.log({ src });\n\n  const sizeText =\n    asset.sizeBytes !== undefined\n      ? `(${readableSize(asset.sizeBytes)})`\n      : undefined;\n\n  const downloadText = \" ⬇️ Download\";\n\n  return (\n    <Span style={{ position: \"relative\" }}>\n      {downloadUrl && !hideDownloadLink ? (\n        <Div\n          style={{\n            padding: \"5px\",\n          }}\n        >\n          <A target=\"_blank\" href={downloadUrl}>\n            {downloadText} {sizeText}\n          </A>\n        </Div>\n      ) : null}\n\n      {type === \"image\" && src && (\n        <img\n          src={src}\n          className={className || \"w-40\"}\n          style={{ aspectRatio: \"auto\" }}\n        />\n      )}\n      {type === \"audio\" && src && <audio controls src={src} />}\n      {type === \"video\" && src && (\n        <video\n          style={{ aspectRatio: \"auto\" }}\n          className={className || \"w-40\"}\n          preload=\"none\"\n          // not always available, should I check first somehow?\n          poster={src.replace(\".mp4\", \".placeholder.jpeg\")}\n          controls\n          src={src}\n        />\n      )}\n\n      {type === \"text\" && rawText ? (\n        <MarkdownCodeblock text={rawText} extension={extension} />\n      ) : null}\n\n      {/* LATER: render PDF renderer here */}\n      {type === \"other\" && extension === \"pdf\" ? null : null}\n\n      {src === undefined ? <P>Asset src not found</P> : null}\n    </Span>\n  );\n}"
  },
  "defaultClassName": {
    "name": "defaultClassName",
    "slug": "TsVariable",
    "id": "forzaysldolxfezbhohsaqri",
    "description": "",
    "operationName": "asset-view"
  },
  "getSrc": {
    "name": "getSrc",
    "slug": "TsFunction",
    "id": "ronnamkmpoovmdmywfflfcmo",
    "description": "",
    "operationName": "asset-view",
    "rawText": " (\n  asset: Asset,\n  projectRelativeReferencingFilePath: string,\n  isNextStaticProductionBuild?: boolean\n) => {\n  // console.log({ apiUrl });\n  /**\n   * NB: `relativePath` is required\n   */\n  const getRemoteUrl = (isDownload: boolean) =>\n    getReferencedAssetApiUrl(\n      apiUrl,\n      projectRelativeReferencingFilePath,\n      asset.relativePath!,\n      isDownload\n    );\n\n  const getPublicUrl = (relativePath: string) =>\n    `markdown-assets/${path.join(\n      path.parse(projectRelativeReferencingFilePath).dir,\n      relativePath\n    )}`;\n  /**\n   * NB: `asset.temporaryDestination` is not a URL that can be used to retreive the image as \"src\"\n   */\n  const src = asset.absoluteUrl\n    ? asset.absoluteUrl\n    : asset.blobPath\n    ? asset.blobPath\n    : isNextStaticProductionBuild && asset.relativePath\n    ? getPublicUrl(asset.relativePath)\n    : getRemoteUrl(false);\n\n  // console.log(\"UseAssetSRC:\", src);\n  const downloadRemotely = !asset.blobPath && !!asset.relativePath;\n\n  const downloadUrl =\n    isNextStaticProductionBuild && asset.relativePath\n      ? getPublicUrl(asset.relativePath)\n      : downloadRemotely\n      ? getRemoteUrl(true)\n      : // NB: other type is ugly when downloading. Also doesn't make sense much to want to download an asset after uploading\n      asset.type !== \"other\"\n      ? asset.blobPath\n      : undefined;\n\n  return { src, downloadUrl };\n}"
  },
  "InteractiveAsset": {
    "name": "InteractiveAsset",
    "slug": "TsFunction",
    "id": "tfrvwaorstnudtphjcddetsw",
    "description": "shows an `Asset` with interactivity\n\n- Any file shows the name of the file, the size, and a link to open it in a new tab in the browser\n- Images show thumbnail\n- Audio show duration and amplitude\n- Video/screen show thumbnail and duration",
    "operationName": "asset-view",
    "rawText": " (props: {\n  asset: Asset;\n  /**\n   * See `AssetInput` for more info\n   */\n  attachTokenToFilename?: boolean;\n  projectRelativeReferencingFilePath: string;\n  remove: () => void;\n  onChange: (newAsset: Asset) => void;\n}) => {\n  const {\n    asset,\n    remove,\n    projectRelativeReferencingFilePath,\n    onChange,\n    attachTokenToFilename,\n  } = props;\n\n  /**\n   *\n   * Name that includes token\n   */\n  const nameWithToken =\n    asset.name && asset.name.length > 0\n      ? // You've edited the name, and this it's stored on the frontend `Asset`\n        asset.name\n      : asset.relativePath\n      ? // The asset comes from the backend, the name can be deducted from the `relativePath` by removing the token first, then adding it\n        getNameWithTokenFromRelativePath(\n          asset.relativePath,\n          attachTokenToFilename\n        )\n      : // There is no backend name nor there's a name set by the user. NB: this should not really happen as it must be present on Asset after recording/selecting an asset...\n        \"\";\n\n  const { nameWithoutToken, token: previousToken } = removeTokenIfPresent(\n    nameWithToken,\n    attachTokenToFilename\n  );\n\n  const uploadProgressText =\n    asset.uploadProgress === undefined || asset.uploadProgress === 0\n      ? \"\"\n      : asset.uploadProgress === 1\n      ? \"✅\"\n      : `${Math.round(asset.uploadProgress * 100)}%`;\n\n  return (\n    <Div className=\"relative border border-black rounded-xl p-2 m-2\">\n      <Span className=\"absolute right-1 top-[-7px]\">\n        <ClickableIcon emoji=\"⨯\" onClick={() => remove()} />\n      </Span>\n      <AssetView\n        projectRelativeReferencingFilePath={projectRelativeReferencingFilePath}\n        asset={asset}\n      />\n\n      <Div className=\"flex flex-row\">\n        <Input\n          placeholder=\"Name\"\n          value={nameWithoutToken}\n          style={{ backgroundColor: \"transparent\", border: \"1px solid black\" }}\n          onChange={(e) => {\n            const newName = addToken(\n              e.target.value,\n              previousToken,\n              attachTokenToFilename\n            );\n\n            console.log({ newName });\n\n            const newAsset = { ...asset, name: newName };\n            onChange(newAsset);\n          }}\n        />\n        <Input\n          placeholder=\"Alternate text\"\n          style={{ backgroundColor: \"transparent\", border: \"1px solid black\" }}\n          value={asset.alt || \"\"}\n          onChange={(e) => {\n            const newAsset = { ...asset, alt: e.target.value };\n            onChange(newAsset);\n          }}\n        />\n        {uploadProgressText}\n      </Div>\n    </Div>\n  );\n}"
  },
  "itemGetBackendAssetUrl": {
    "name": "itemGetBackendAssetUrl",
    "slug": "TsFunction",
    "id": "bpnrxdjrlfbfppcrzvurveja",
    "description": "Get remote url for a `BackendAsset` in an `AugmentedAnyModelType` database model item.\n\nIf you provide an array it'll take the first asset.",
    "operationName": "asset-view",
    "rawText": " (config: {\n  item: AugmentedAnyModelType;\n  backendAsset?: BackendAsset | BackendAsset[];\n  isDownload?: boolean;\n}) => {\n  const { backendAsset, item, isDownload } = config;\n\n  const realBackendAsset = backendAsset ? takeFirst(backendAsset) : undefined;\n\n  if (!realBackendAsset?.relativePath) {\n    return undefined;\n  }\n\n  const url = getReferencedAssetApiUrl(\n    apiUrl,\n    item.projectRelativePath,\n    realBackendAsset.relativePath,\n    isDownload\n  );\n  return url;\n}"
  },
  "ModelItemAssetView": {
    "name": "ModelItemAssetView",
    "slug": "TsFunction",
    "id": "lgsoavioqgfbwhduwuwtkdjo",
    "description": "",
    "operationName": "asset-view",
    "rawText": " <T extends AugmentedAnyModelType>(props: {\n  item: T;\n  backendAsset?: BackendAsset;\n  hideDownloadLink?: boolean;\n  className?: string;\n}) => {\n  const { backendAsset, item, hideDownloadLink, className } = props;\n\n  return backendAsset ? (\n    <AssetView\n      asset={backendAsset}\n      projectRelativeReferencingFilePath={item.projectRelativePath}\n      hideDownloadLink={hideDownloadLink}\n      className={className}\n    />\n  ) : null;\n}"
  },
  "useAssetInfo": {
    "name": "useAssetInfo",
    "slug": "TsFunction",
    "id": "idezoxhoprvbjozfvmtkktdt",
    "description": "",
    "operationName": "asset-view",
    "rawText": " (url?: string, filename?: string) => {\n  if (!url && !filename) {\n    console.log(\"MUST PROVIDE EITHER URL OR FILENAME\");\n    return;\n  }\n  const urlOrFilename = (url || filename)!;\n  const realFilename = (url ? url.split(\"/\").pop() : filename)!;\n  const isTextFile = isText(realFilename) === true ? true : false;\n\n  const [rawText, setRawText] = useState<string | null>(null);\n  useEffect(() => {\n    if (!!url && isTextFile) {\n      fetch(url).then((result) => {\n        result.text().then((text) => setRawText(text));\n      });\n    }\n  }, [url, isTextFile]);\n\n  const type = getTypeFromUrlOrPath(urlOrFilename);\n\n  return { rawText, type };\n}"
  },
  "useAsset": {
    "name": "useAsset",
    "slug": "TsFunction",
    "id": "kvtybauwkhuybtnvwoodgtpu",
    "description": "",
    "operationName": "asset-view",
    "rawText": " (\n  asset: Asset | undefined,\n  projectRelativeReferencingFilePath?: string | null,\n  isNextStaticProductionBuild?: boolean\n) => {\n  if (!asset || !projectRelativeReferencingFilePath) return;\n\n  const { src, downloadUrl } = getSrc(\n    asset,\n    projectRelativeReferencingFilePath,\n    isNextStaticProductionBuild\n  );\n\n  const extension = getExtensionFromAsset(asset);\n\n  const assetInfo = useAssetInfo(src, asset.originalFilename);\n\n  const rawText = assetInfo?.rawText || null;\n  const type = asset.type || assetInfo?.type;\n\n  return { rawText, type, downloadUrl, src, extension };\n}"
  },
  "cache": {
    "name": "cache",
    "slug": "TsVariable",
    "id": "lzqjvavrfyctprihfvotirbi",
    "description": "",
    "operationName": "augmented-word-node"
  },
  "getAugmentedWordObject": {
    "name": "getAugmentedWordObject",
    "slug": "TsFunction",
    "id": "vivvdhjqpflzpygsimhbprun",
    "description": "",
    "operationName": "augmented-word-node",
    "rawText": " async (\n  manualProjectRoot?: string\n): Promise<MappedObject<AugmentedWord> | undefined> => {\n  const projectRoot = manualProjectRoot || getProjectRoot();\n\n  if (!projectRoot) return;\n\n  if (cache) return cache;\n\n  const augmentedWordsSerializable = (await getAugmentedWords(projectRoot)).map(\n    (item) => omitUndefinedValues(item)\n  );\n\n  const mappedObject = createMappedObject(augmentedWordsSerializable, \"word\");\n\n  cache = mappedObject;\n  return mappedObject;\n}"
  },
  "getAugmentedWords": {
    "name": "getAugmentedWords",
    "slug": "TsFunction",
    "id": "ufftkvvqdbkfvwdwacrhyiow",
    "description": "Gets all augmented words of the entire project\n\n- functions, interfaces, variables, operations (`/[operation-path]#name`)\n- if this is an OS-project, also bundles (`/[docs-path]`)",
    "operationName": "augmented-word-node",
    "rawText": " async (\n  manualProjectRoot?: string\n): Promise<AugmentedWord[]> => {\n  const projectRoot = manualProjectRoot || getProjectRoot();\n\n  if (!projectRoot) return [];\n\n  const operations = await db.get(\"Operation\");\n\n  const operationAugmentedWords: AugmentedWord[] = operations\n    .map((item) => {\n      const itemLocationPath = path.join(projectRoot, item.projectRelativePath);\n      const operationPath = findOperationBasePath(itemLocationPath);\n      if (!operationPath) return;\n\n      const description = item.operation?.markdown || item.description;\n\n      const augmentedWord: AugmentedWord = {\n        queryPath: makeRelative(operationPath, projectRoot),\n        spoiler: description,\n        type: \"operation\",\n        word: item.name,\n        // NB: OperationConfig is located in operation basePath\n        projectRelativeMarkdownSourcePath: path.join(\n          operationPath,\n          \"OPERATION.md\"\n        ),\n      };\n\n      return augmentedWord;\n    })\n    .filter(notEmpty);\n\n  const tsVariables = await db.get(\"TsVariable\", {\n    manualProjectRoot: projectRoot,\n  });\n\n  const tsFunctions = await db.get(\"TsFunction\", {\n    manualProjectRoot: projectRoot,\n  });\n  const tsInterfaces = await db.get(\"TsInterface\", {\n    manualProjectRoot: projectRoot,\n  });\n\n  const interfaceAugmentedWords: AugmentedWord[] = tsInterfaces\n    .map((item) => {\n      // NB: TODO: figure out of this is always correct, this path must exist!\n      const itemLocationPath = path.join(projectRoot, item.projectRelativePath);\n      const operationPath = findOperationBasePath(itemLocationPath);\n      if (!operationPath) return;\n\n      const projectRelativeOperationPath = makeRelative(\n        operationPath,\n        projectRoot\n      );\n\n      const augmentedWord: AugmentedWord = {\n        queryPath: `${projectRelativeOperationPath}#${getImplicitId(\n          item.name\n        )}`,\n        spoiler: item.description,\n        type: \"type\",\n        word: item.name,\n        projectRelativeMarkdownSourcePath: item.projectRelativePath,\n      };\n\n      return augmentedWord;\n    })\n    .filter(notEmpty);\n\n  const functionAugmentedWords: AugmentedWord[] = tsFunctions\n    .map((item) => {\n      // NB: TODO: figure out of this is always correct, this path must exist!\n      const itemLocationPath = path.join(projectRoot, item.projectRelativePath);\n      const operationPath = findOperationBasePath(itemLocationPath);\n      if (!operationPath) return;\n\n      const projectRelativeOperationPath = makeRelative(\n        operationPath,\n        projectRoot\n      );\n\n      const augmentedWord: AugmentedWord = {\n        queryPath: `${projectRelativeOperationPath}#${getImplicitId(\n          item.name\n        )}`,\n        spoiler: item.description,\n        type: \"function\",\n        word: item.name,\n        projectRelativeMarkdownSourcePath: item.projectRelativePath,\n      };\n\n      return augmentedWord;\n    })\n    .filter(notEmpty);\n\n  const variableAugmentedWords: AugmentedWord[] = tsVariables\n    .map((item) => {\n      // NB: TODO: figure out of this is always correct, this path must exist!\n      const itemLocationPath = path.join(projectRoot, item.projectRelativePath);\n      const operationPath = findOperationBasePath(itemLocationPath);\n      if (!operationPath) return;\n\n      const projectRelativeOperationPath = makeRelative(\n        operationPath,\n        projectRoot\n      );\n\n      const augmentedWord: AugmentedWord = {\n        queryPath: `${projectRelativeOperationPath}#${getImplicitId(\n          item.name\n        )}`,\n        spoiler: item.description,\n        type: \"variable\",\n        word: item.name,\n        projectRelativeMarkdownSourcePath: item.projectRelativePath,\n      };\n\n      return augmentedWord;\n    })\n    .filter(notEmpty);\n\n  const bundleAugmentedWords: AugmentedWord[] | undefined = isBundle(\n    projectRoot\n  )\n    ? undefined\n    : await getBundleAugmentedWords();\n\n  const allAugmentedWords: AugmentedWord[] = [\n    bundleAugmentedWords,\n    operationAugmentedWords,\n    variableAugmentedWords,\n    functionAugmentedWords,\n    interfaceAugmentedWords,\n  ]\n    .filter(notEmpty)\n    .flat();\n\n  return allAugmentedWords;\n}"
  },
  "getBundleAugmentedWords": {
    "name": "getBundleAugmentedWords",
    "slug": "TsFunction",
    "id": "rnltomxkhuqlagrcoddxosgf",
    "description": "NB: should only be executed if this is not a sensible-project, as it might not have `BundleConfig` otherwise",
    "operationName": "augmented-word-node",
    "rawText": " async (): Promise<AugmentedWord[]> => {\n  // NB: we need to cast the string because in OS-projects this might otherwise fail\n  const bundles: AugmentedAnyModelType[] = await db.get(\n    \"BundleConfig\" as keyof DbModels\n  );\n\n  const bundleAugmentedWords: AugmentedWord[] = bundles.map((bundle) => {\n    const augmentedWord: AugmentedWord = {\n      queryPath: bundle.docsRelativeFolderPath,\n      spoiler: bundle.description,\n      type: \"bundle\",\n      word: bundle.slug,\n      projectRelativeMarkdownSourcePath: bundle.projectRelativePath,\n    };\n\n    return augmentedWord;\n  });\n\n  return bundleAugmentedWords;\n}"
  },
  "AuthenticationMethodsCrud": {
    "name": "AuthenticationMethodsCrud",
    "slug": "TsFunction",
    "id": "eevsjcbhhsienbooknfmezfr",
    "description": "",
    "operationName": "authentication",
    "rawText": " () => {\n  return <Div>Coming soon!</Div>;\n}"
  },
  "LoginForm": {
    "name": "LoginForm",
    "slug": "TsFunction",
    "id": "zguawnlgzfcqvcszfliyawrz",
    "description": "",
    "operationName": "authentication",
    "rawText": " () => {\n  const router = useRouter();\n  const meQuery = queries.useGetMeWithContext();\n\n  return (\n    <Div className=\"flex flex-1 flex-col mx-10\">\n      <P className=\"text-4xl\">Login</P>\n\n      {/* <Input\n        className={UI.textInput}\n        placeholder=\"Password\"\n        type=\"password\"\n        value={pass}\n        onChange={(e) => setPass(e.target.value)}\n      />\n      <BigButton title=\"Login\" onClick={() => router.reload()} /> */}\n\n      {/* New way */}\n      <FunctionForm\n        tsFunction={Index}\n        withApiResult={(\n          result: RealApiReturnType<\"loginWithPasswordWithContext\">\n        ) => {\n          if (result.isSuccessful && result.result?.isSuccessful) {\n            router.push(\"/\");\n          }\n          meQuery.refetch();\n          showStandardResponse(result);\n        }}\n      />\n      <ALink href=\"/signup\">Or click here to sign up</ALink>\n    </Div>\n  );\n}"
  },
  "LoginWrapper": {
    "name": "LoginWrapper",
    "slug": "TsFunction",
    "id": "jwesihptfdtrznfucbgpptho",
    "description": "ensures the auth-token is set",
    "operationName": "authentication",
    "rawText": " (props: { children: any }) => {\n  const { children } = props;\n  const [authToken, setAuthToken, { hydrated }] = useStore(\"api.authToken\");\n\n  // Ensure there is an authToken\n  useEffect(() => {\n    if (!hydrated) return;\n    if (!authToken || authToken.length === 0) {\n      setAuthToken(generateId());\n    }\n  }, [authToken, hydrated]);\n\n  return children;\n}"
  },
  "MeAuthenticationInfo": {
    "name": "MeAuthenticationInfo",
    "slug": "TsFunction",
    "id": "pfbnzqoanbmvzmvggtenepdw",
    "description": "little component for in banner that shows your info on top, and links to signup/login etc",
    "operationName": "authentication",
    "rawText": " () => {\n  const meQuery = queries.useGetMeWithContext();\n\n  const personInfo: PersonInfo = destructureOptionalObject(\n    meQuery.data?.result?.device\n  );\n\n  console.log({ personInfo, meQuery: meQuery.data?.result });\n\n  const router = useRouter();\n  // if no persons are connected, show circle with ? in front of user icon, with menu \"sign up\" and \"login\" next to it\n\n  // if person is connected, that icon becomes your currentaPerson picture, the text your name. if you click on it, it drops down to show the other persons connected to your device, but also \"login and sign up\"\n\n  const nobodyOrCurrent: PictureWithInfo<Person> =\n    personInfo.currentPersonCalculated\n      ? {\n          pictureUrl: itemGetBackendAssetUrl({\n            item: personInfo.currentPersonCalculated,\n            backendAsset: personInfo.currentPersonCalculated.pictureImage,\n          }),\n          info: personInfo.currentPersonCalculated?.name,\n          data: personInfo.currentPersonCalculated,\n        }\n      : {\n          info: \"Sign in\",\n          pictureUrl: undefined,\n        };\n\n  const dropdown: PictureWithInfo<Person>[] =\n    personInfo.persons?.map((x) => {\n      return {\n        pictureUrl: itemGetBackendAssetUrl({\n          item: x,\n          backendAsset: x.pictureImage,\n        }),\n        info: x.name,\n        data: x,\n        isCurrent: x.id === personInfo.currentPersonId,\n      };\n    }) || [];\n\n  return (\n    <PictureWithInfoDropdown\n      current={nobodyOrCurrent}\n      dropdown={dropdown}\n      extraItems={[\n        {\n          text: \"2FA Settings\",\n          onClick: () => router.push(`/2fa`),\n        },\n\n        {\n          text: \"Edit your profile\",\n          onClick: () => router.push(`/edit-profile`),\n        },\n\n        {\n          text: \"See your profile\",\n          onClick: () =>\n            router.push(`/profile?id=${personInfo.currentPersonId}`),\n        },\n        {\n          text: \"Login into another account\",\n          onClick: () => router.push(\"/login\"),\n        },\n        { text: \"Create a new account\", onClick: () => router.push(\"/signup\") },\n        {\n          text: `Logout from ${personInfo.currentPersonCalculated?.name}`,\n          onClick: async () => {\n            const { result, isSuccessful, message } =\n              await api.logoutWithContext();\n\n            meQuery.refetch();\n            successToast(\n              result?.message || message || \"something went wrong (no message)\"\n            );\n          },\n        },\n      ]}\n      isLoading={meQuery.isLoading}\n      onClickCurrent={\n        personInfo.currentPersonCalculated\n          ? undefined\n          : () => router.push(\"/signup\")\n      }\n      onSelectDropdownItem={async (item) => {\n        if (item?.id) {\n          const { result } = await api.switchCurrentPersonWithContext(item?.id);\n\n          toast(\n            {\n              title: result?.isSuccessful ? \"Done\" : \"Error\",\n              body: result?.message || \"Somethign went wrong\",\n            },\n            { hideProgressBar: true, position: \"bottom-right\", type: \"success\" }\n          );\n\n          meQuery.refetch();\n        }\n      }}\n    />\n  );\n}"
  },
  "PersonProfileDetailsForm": {
    "name": "PersonProfileDetailsForm",
    "slug": "TsFunction",
    "id": "oaqsooqnjwhoowjcvzgttqzo",
    "description": "",
    "operationName": "authentication",
    "rawText": " (props: {\n  personProfileDetails: PersonProfileDetails;\n}) => {\n  const meQuery = queries.useGetMeWithContext();\n\n  const projectRelativeStorageFilePath =\n    meQuery.data?.result?.device?.currentPersonCalculated?.projectRelativePath;\n  const [form, details, onChange] = useTsInterfaceForm(\n    PersonProfileDetailsIndex as Storing<TsInterface>,\n    \"test\",\n    props.personProfileDetails,\n    projectRelativeStorageFilePath,\n    \"Person\"\n  );\n\n  return form ? (\n    <FormContainer\n      onSubmit={async () => {\n        if (!details || !projectRelativeStorageFilePath) return;\n        const apiResult = await api.updateMeWithContext(details);\n        showStandardResponse(apiResult);\n        await meQuery.refetch();\n      }}\n    >\n      {form}\n    </FormContainer>\n  ) : null;\n}"
  },
  "PictureWithInfoDropdown": {
    "name": "PictureWithInfoDropdown",
    "slug": "TsFunction",
    "id": "yfkxlserkbhwzxjcvctsbbet",
    "description": "Dumb (presentational) component for a picture with info and a dropdown",
    "operationName": "authentication",
    "rawText": " <T extends unknown>(props: {\n  current: PictureWithInfo<T>;\n  dropdown: PictureWithInfo<T>[];\n  extraItems?: { onClick: () => void; text: string }[];\n  isLoading: boolean;\n  /**\n   * if not given, dropdown is opened\n   */\n  onClickCurrent?: () => void;\n  onSelectDropdownItem: (selected: PictureWithInfo<T>[\"data\"]) => void;\n}) => {\n  const {\n    current,\n    dropdown,\n    isLoading,\n    onClickCurrent,\n    onSelectDropdownItem,\n    extraItems,\n  } = props;\n\n  const router = useRouter();\n\n  const [showDropdown, setShowDropdown] = useState(false);\n\n  const toggleDropdown = () => {\n    setShowDropdown(!showDropdown);\n  };\n\n  return (\n    <Div className=\"relative\">\n      <Div\n        className=\"cursor-pointer flex flex-row justify-end pr-2 items-center gap gap-2\"\n        onClick={onClickCurrent || toggleDropdown}\n      >\n        {isLoading ? (\n          <FancyLoader />\n        ) : current.pictureUrl ? (\n          <Image\n            src={current.pictureUrl}\n            className=\"rounded-full w-8 h-8 border border-black p-0.5 bg-gray-400\"\n          />\n        ) : null}\n        <P>{current.info}</P>\n      </Div>\n      <Div className=\"relative\">\n        {showDropdown ? (\n          <Div className=\"absolute top-0 right-0 bg-slate-400 min-w-[200px] rounded-md\">\n            <b>Your accounts</b>\n            {dropdown.map((item) => {\n              return (\n                <Div\n                  className={`${\n                    item.isCurrent\n                      ? \"bg-slate-600\"\n                      : \"hover:rounded-md hover:bg-slate-600\"\n                  } px-2 cursor-pointer py-1`}\n                  onClick={() => {\n                    if (item.isCurrent) return;\n                    if (item.url) {\n                      router.push(item.url);\n                      return;\n                    }\n                    toggleDropdown();\n                    onSelectDropdownItem(item.data);\n                  }}\n                >\n                  {item.info}\n                </Div>\n              );\n            })}\n\n            <Div className=\"h-4\" />\n            <b>More</b>\n\n            {extraItems?.map((item) => {\n              return (\n                <Div\n                  className=\"hover:bg-slate-600 hover:rounded-md text-xs cursor-pointer p-2\"\n                  onClick={() => {\n                    toggleDropdown();\n                    item.onClick();\n                  }}\n                >\n                  {item.text}\n                </Div>\n              );\n            })}\n          </Div>\n        ) : null}\n      </Div>\n    </Div>\n  );\n}"
  },
  "PublicPersonComponent": {
    "name": "PublicPersonComponent",
    "slug": "TsFunction",
    "id": "tpsoiufsnjkblftwtdukxbzm",
    "description": "",
    "operationName": "authentication",
    "rawText": " (props: {\n  publicPerson: PublicPerson | undefined;\n}) => {\n  const { publicPerson } = props;\n\n  return !publicPerson ? null : (\n    <Div className=\"w-ful\">\n      <ModelItemAssetView\n        item={publicPerson}\n        backendAsset={publicPerson?.pictureImage}\n        hideDownloadLink\n        className=\"w-full\"\n      />\n      <P>{publicPerson.name}</P>\n    </Div>\n  );\n}"
  },
  "PublicProfile": {
    "name": "PublicProfile",
    "slug": "TsFunction",
    "id": "ratkdbpbclprdjwielgirhmo",
    "description": "",
    "operationName": "authentication",
    "rawText": " () => {\n  const router = useRouter();\n\n  const id = router.query?.id ? takeFirst(router.query.id) : undefined;\n  const publicPersonQuery = queries.useGetPublicPerson(id);\n\n  const publicPerson = publicPersonQuery.data?.result;\n\n  return (\n    <Div>\n      {publicPersonQuery.isLoading ? <FancyLoader /> : null}\n\n      <PublicPersonComponent publicPerson={publicPerson} />\n    </Div>\n  );\n}"
  },
  "SignupForm": {
    "name": "SignupForm",
    "slug": "TsFunction",
    "id": "mthwjipgbtdffzniunjxxtyg",
    "description": "",
    "operationName": "authentication",
    "rawText": " () => {\n  const router = useRouter();\n  const meQuery = queries.useGetMeWithContext();\n\n  return (\n    <Div className=\"flex flex-1 flex-row mx-10\">\n      <Div className=\"flex flex-1 flex-col\">\n        <P className=\"text-4xl\">Sign up</P>\n        <FunctionForm\n          modelName=\"Person\"\n          projectRelativeStorageFilePath=\"db/persons.json\"\n          tsFunction={Index}\n          withApiResult={(\n            result: RealApiReturnType<\"signupWithPasswordWithContext\">\n          ) => {\n            if (result.isSuccessful && result.result?.isSuccessful) {\n              router.push(\"/\");\n            }\n            meQuery.refetch();\n            showStandardResponse(result);\n          }}\n        />\n        <ALink href=\"/login\">Or click here to login</ALink>\n      </Div>\n    </Div>\n  );\n}"
  },
  "UpdateMeForm": {
    "name": "UpdateMeForm",
    "slug": "TsFunction",
    "id": "jjnceelxcfmmeivpvvcbwmzc",
    "description": "",
    "operationName": "authentication",
    "rawText": " () => {\n  const meQuery = queries.useGetMeWithContext();\n\n  const person = meQuery.data?.result?.device?.currentPersonCalculated;\n  const personProfileDetails: PersonProfileDetails | undefined = person\n    ? {\n        name: person.name,\n        interestSlugs: person.interestSlugs,\n        media: person.media,\n        pictureImage: person.pictureImage,\n        preferred_mediaChannelId: person.preferred_mediaChannelId,\n      }\n    : undefined;\n\n  return (\n    <Div className=\"flex flex-1 flex-row justify-center items-center\">\n      <Div className=\"w-96\">\n        <P className=\"text-4xl\">Update your profile</P>\n\n        {personProfileDetails ? (\n          <PersonProfileDetailsForm\n            personProfileDetails={personProfileDetails}\n          />\n        ) : null}\n      </Div>\n    </Div>\n  );\n}"
  },
  "BigButton": {
    "name": "BigButton",
    "slug": "TsFunction",
    "id": "rmyiyilxgfpwwwfcosviwftx",
    "description": "",
    "operationName": "big-button",
    "rawText": " (button: BigButton) => {\n  const [isLoading, setIsLoading] = useState(false);\n  const colors =\n    button.stylePreset === \"cancel\"\n      ? \"bg-red-800 hover:bg-red-600 dark:bg-red-600 dark:hover:bg-red-400\"\n      : \"bg-blue-800 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-400\";\n  return (\n    <Div\n      className={`cursor-pointer ${colors} p-3 rounded-md border-2 border-black`}\n      onClick={async () => {\n        setIsLoading(true);\n        await button.onClick();\n        setIsLoading(false);\n      }}\n    >\n      <Div className={`flex flex-row gap-6 items-center`}>\n        {button.isLoading || isLoading ? (\n          <FancyLoader />\n        ) : button.icon ? (\n          <Svg src={button.icon} width={24} height={24} />\n        ) : button.emoji ? (\n          <P className={`text-xl hover:scale-110`}>{button.emoji}</P>\n        ) : button.component ? (\n          <Div className=\"h-7\">{button.component()}</Div>\n        ) : null}\n        <P className=\"text-xs text-white\">{button.title}</P>\n      </Div>\n    </Div>\n  );\n}"
  },
  "BreadCrumbs": {
    "name": "BreadCrumbs",
    "slug": "TsFunction",
    "id": "umswyupmrmepgxobmuefwdog",
    "description": "Shows where we are in the filesystem",
    "operationName": "breadcrumbs",
    "rawText": " (props: { path: string }) => {\n  const { path } = props;\n  const chunks = (path || \"\").split(\"/\");\n\n  if (path === \"\") return <Div />;\n  return (\n    <Div className=\"border-b border-b-gray-300 mb-4 bg-[#FFFFFF] dark:bg-gray-900\">\n      <Div className=\"flex flex-row items-center ml-2\">\n        {renderBreadCrumbs(chunks)}\n      </Div>\n    </Div>\n  );\n}"
  },
  "renderBreadCrumbs": {
    "name": "renderBreadCrumbs",
    "slug": "TsFunction",
    "id": "zkngyoojmkqlwpkohxxyqlof",
    "description": "",
    "operationName": "breadcrumbs",
    "rawText": " (chunks: string[]) => {\n  return chunks?.map((chunk, index) => {\n    const isLast = chunks.length - 1 === index;\n\n    return (\n      <Div\n        key={`breadcrumb${index}`}\n        className=\"flex flex-row items-center text-xs\"\n      >\n        {chunk}\n        {isLast ? null : (\n          <Div className=\"px-2 text-gray-900 dark:text-gray-200\">▸</Div>\n        )}\n      </Div>\n    );\n  });\n}"
  },
  "getBundleSummary": {
    "name": "getBundleSummary",
    "slug": "TsFunction",
    "id": "zwefmkbubalvjbbwvdoufanp",
    "description": "Summarizes a bundle config so it can be used easily in things like explore project",
    "operationName": "bundle-util",
    "rawText": " (bundleConfig: BundleConfig): BundleSummary => {\n  const operationsPath = getRootPath(\"operations\");\n  const bundlesPath = operationsPath\n    ? path.join(operationsPath, \"niches\")\n    : undefined;\n\n  const foldersFromRepo = bundlesPath\n    ? bundleConfig.createBundleConfig.foldersFromRepo?.map((x) =>\n        path.join(bundlesPath, kebabCase(bundleConfig.name), x)\n      )\n    : undefined;\n\n  // const filesAndFoldersToInclude = [\n  //   // ...(foldersFromRepo || []),\n  //   bundleConfig.readmeRelativeFilePath,\n  //   bundleConfig.docsRelativeFolderPath,\n  // ].filter(notEmpty);\n\n  const appNames = bundleConfig.createBundleConfig.bundles\n    .map((x) => {\n      const frontendOperationNames = makeArray(\n        x.appShellOperationNames,\n        x.serverOperationName\n      );\n\n      return frontendOperationNames;\n    })\n    .flat()\n    .filter(onlyUnique2());\n\n  const uiOperationNames = makeArray(\n    bundleConfig.createBundleConfig.bundles\n      .map((x) => x.uiOperationName)\n      .filter(notEmpty)\n  );\n\n  const bundlePublicOperationNames = bundleConfig.createBundleConfig.bundles\n    .map(\n      (x) =>\n        x.operations\n          ?.filter((x) => x.privacy === \"public\")\n          .map((x) => x.operationName) || []\n    )\n    .flat();\n  const bundlePrivateOperationNames = bundleConfig.createBundleConfig.bundles\n    .map(\n      (x) =>\n        x.operations\n          ?.filter((x) => x.privacy === \"private\")\n          .map((x) => x.operationName) || []\n    )\n    .flat();\n\n  const packageNames =\n    bundleConfig.createBundleConfig.dependencies\n      ?.filter((x) => x.privacy === \"public\")\n      .map((x) => x.operationName)\n      .concat(uiOperationNames)\n      .concat(bundlePublicOperationNames)\n      .filter(onlyUnique2()) || [];\n\n  const moduleNames =\n    bundleConfig.createBundleConfig.dependencies\n      ?.filter((x) => x.privacy === \"private\")\n      .map((x) => x.operationName)\n      .concat(bundlePrivateOperationNames)\n      .filter(onlyUnique2()) || [];\n\n  const summary: BundleSummary = {\n    // filesAndFoldersToInclude,\n    slug: bundleConfig.slug,\n    packageNames,\n    moduleNames,\n    appNames,\n  };\n\n  // console.dir({ summary, bundleConfig }, { depth: 999 });\n\n  return summary;\n}"
  },
  "getDbModelsForBundle": {
    "name": "getDbModelsForBundle",
    "slug": "TsFunction",
    "id": "qjetnvzwfpurzpihgcfruzti",
    "description": "Gets all TsInterface's that are used in a bundle according to a BundleConfig",
    "operationName": "bundle-util",
    "rawText": " async (\n  bundleConfig: BundleConfig\n): Promise<TsInterface[]> => {\n  const bundleSummary = getBundleSummary(bundleConfig);\n\n  const dbModels = getDbModelsFromOperations(\n    bundleSummary.packageNames\n      .concat(bundleSummary.moduleNames)\n      .concat(bundleSummary.appNames)\n  );\n  return dbModels;\n}"
  },
  "chatGPTAuth": {
    "name": "chatGPTAuth",
    "slug": "TsFunction",
    "id": "yqogvinkgtgvlcyzmopkipfk",
    "description": "",
    "operationName": "chatgpt-controller",
    "rawText": " async (page: Page): Promise<LoginResponse> => {\n  try {\n    console.log(\"Chatgpt login chandler called\");\n    const credentials: MediaCredential[] = await db.get(\"MediaCredential\");\n    console.log({ credentials });\n    const openAICredential = credentials?.find(\n      (c) => c.username === \"openai\"\n    ) || {\n      email: \"bhagyasah4u@gmail.com\",\n      password: \"openai@199201\",\n    };\n    console.log({ openAICredential });\n    if (!openAICredential)\n      return { isSuccessfull: false, message: \"Credential not found\" };\n    const { email, password } = openAICredential || openAICredential;\n    await page.goto(\"https://chat.openai.com/auth/login\", {\n      waitUntil: \"domcontentloaded\",\n    });\n\n    const isSecurePageApear = await page.$x(\n      \"//h2[contains(., 'Checking if the site connection is secure')]\"\n    );\n\n    if (isSecurePageApear) {\n      console.log(\"Need to captcha solution\");\n      const isCaptchaExistRes = await isCaptchaExist(page);\n      console.log({ isCaptchaExistRes });\n      await page.waitForSelector(\n        'button[class=\"btn flex justify-center gap-2 btn-primary\"]'\n      );\n    }\n\n    const isLoginPageApear = await page.$x(\"//button[contains(., 'Log in')]\");\n    if (Boolean(isLoginPageApear[0])) {\n      console.log(\"LOGIN PAGE DETECTED\");\n      //@ts-ignore\n      isLoginPageApear[0].click();\n      await page.waitForNavigation({ waitUntil: \"domcontentloaded\" });\n      await page.waitForSelector('input[id=\"username\"]');\n      const usernameInput = await page.$('input[id=\"username\"]');\n\n      if (usernameInput) {\n        //@ts-ignore\n        usernameInput.click();\n        //@ts-ignore\n        await page.keyboard.type(email);\n      }\n      //Checking and solving the captcha\n      const { captchas } = await isCaptchaExist(page);\n      if (captchas.length > 0) {\n        console.log(\"CAPTCHA DETECTED\");\n        const captchaSolveResponse = await solveReptcha(page);\n        console.log({\n          captchaSolveResponse: JSON.stringify(captchaSolveResponse),\n        });\n        if (!captchaSolveResponse.error) {\n          await page.waitForSelector('button[type=\"submit\"]');\n          await page.click('button[type=\"submit\"]');\n          await page.waitForSelector('input[name=\"password\"]', {\n            timeout: 30000,\n          });\n          await page.focus('input[name=\"password\"]');\n          await page.keyboard.type(password);\n          await page.waitForSelector('button[type=\"submit\"]');\n          await page.click('button[type=\"submit\"]');\n          page.waitForNavigation({ waitUntil: \"domcontentloaded\" });\n          return { isSuccessfull: true, message: \"Login Succcessfull\" };\n        }\n      }\n    }\n    return { isSuccessfull: false, message: \"Login faild\" };\n  } catch (e: Error | any) {\n    return { isSuccessfull: false, message: e?.message };\n  }\n}"
  },
  "detectChatGptPage": {
    "name": "detectChatGptPage",
    "slug": "TsFunction",
    "id": "cvmsoqwxrhghqvuglbzmuelp",
    "description": "",
    "operationName": "chatgpt-controller",
    "rawText": " async (\n  page: Page\n): Promise<\"Login\" | \"Chat\" | \"Secure\"> => {\n  await page.goto(\"https://chat.openai.com/chat\", {\n    waitUntil: \"domcontentloaded\",\n  });\n\n  const sendMessageButton = await page.$(\n    'button[class=\"absolute p-1 rounded-md text-gray-500 bottom-1.5 right-1 md:bottom-2.5 md:right-2 hover:bg-gray-100 dark:hover:text-gray-400 dark:hover:bg-gray-900 disabled:hover:bg-transparent dark:disabled:hover:bg-transparent\"]'\n  );\n\n  const isTextAreaExist = await page.$(\"textarea\");\n\n  if (sendMessageButton && isTextAreaExist) {\n    return \"Chat\";\n  }\n\n  const isSecurePageApear = await page.$x(\n    \"//h2[contains(., 'Checking if the site connection is secure')]\"\n  );\n\n  const isLogin = 'button[class=\"btn flex justify-center gap-2 btn-primary\"]';\n  console.log({ isLogin });\n  if (isSecurePageApear && isLogin) {\n    console.log(\"Unexpected page appear please solve manually\");\n    const { captchas } = await isCaptchaExist(page);\n    if (captchas.length > 0) {\n      console.log(\"CAPTCHA DETECTED\");\n      const captchaSolveResponse = await solveReptcha(page);\n      console.log({ captchaSolveResponse });\n    }\n    try {\n      await page.waitForSelector(\n        'button[class=\"btn flex justify-center gap-2 btn-primary\"]',\n        { timeout: 60000 }\n      );\n      console.log('\"Login button appear');\n      return \"Login\";\n    } catch (e: Error | any) {\n      console.error(\"Erro to to get login page so may be its a chat page open\");\n      return \"Chat\";\n    }\n  }\n  return \"Secure\";\n}"
  },
  "openAIChat": {
    "name": "openAIChat",
    "slug": "TsFunction",
    "id": "ttzylsllxlictfeflyebbfjq",
    "description": "Send the propt to chatgpt and return the chatgpt response",
    "operationName": "chatgpt-controller",
    "rawText": " async (\n  props: OpenAIChatProps\n): Promise<ProcessPromptFunctionResult> => {\n  const { prompt, thread, isHeadless } = props;\n  console.log(\"openAIChat Called\", props);\n  // chat login test ...\n\n  const page = await openPage(thread);\n\n  if (!page) return { isSuccessful: false, message: \"Faild to create page.\" };\n  //@ts-ignore\n  const pageId = await page.target()._targetId;\n  //setting current page is not idle\n  await setBrowserPageIdle(pageId, false);\n  if (thread !== pageId) {\n    await page.goto(\"https://chat.openai.com/chat\", {\n      waitUntil: \"domcontentloaded\",\n    });\n  }\n\n  let sendMessageButton = await page.$(\n    'button[class=\"absolute p-1 rounded-md text-gray-500 bottom-1.5 right-1 md:bottom-2.5 md:right-2 hover:bg-gray-100 dark:hover:text-gray-400 dark:hover:bg-gray-900 disabled:hover:bg-transparent dark:disabled:hover:bg-transparent\"]'\n  );\n\n  let textAreaElementHandle = await page.$(\"textarea\");\n\n  if (!textAreaElementHandle || !sendMessageButton) {\n    const pageType = await detectChatGptPage(page);\n    console.log({ pageType });\n    if (pageType === \"Login\") {\n      const authResponse = await chatGPTAuth(page);\n      // console.log({ authResponse });\n      await new Promise((r) => setTimeout(r, 5000));\n    }\n  }\n\n  // Wating and typing the prompt in the textarea field\n  await page.waitForSelector(\"textarea\", { timeout: 60000 });\n  await page.waitForSelector(\n    'button[class=\"absolute p-1 rounded-md text-gray-500 bottom-1.5 right-1 md:bottom-2.5 md:right-2 hover:bg-gray-100 dark:hover:text-gray-400 dark:hover:bg-gray-900 disabled:hover:bg-transparent dark:disabled:hover:bg-transparent\"]',\n    { timeout: 60000 }\n  );\n\n  sendMessageButton = await page.$(\n    'button[class=\"absolute p-1 rounded-md text-gray-500 bottom-1.5 right-1 md:bottom-2.5 md:right-2 hover:bg-gray-100 dark:hover:text-gray-400 dark:hover:bg-gray-900 disabled:hover:bg-transparent dark:disabled:hover:bg-transparent\"]'\n  );\n  textAreaElementHandle = await page.$(\"textarea\");\n\n  if (!textAreaElementHandle || !sendMessageButton) {\n    return {\n      isSuccessful: false,\n      message: \"Text area not found\",\n      result: {\n        thread: pageId,\n      },\n    };\n  }\n\n  console.log(\"inside of set value\");\n  await new Promise(async (resolve, reject) => {\n    console.log(\"inside promise\");\n    resolve(\n      await page.evaluate((evPrompt) => {\n        const promtTextAreaField = document.getElementsByTagName(\"textarea\");\n        console.log({ promtTextAreaField });\n        if (promtTextAreaField[0]) {\n          //@ts-ignore\n          promtTextAreaField[0].focus();\n          promtTextAreaField[0].click();\n          promtTextAreaField[0].value = evPrompt;\n          const button = document.querySelector(\n            'button[class=\"absolute p-1 rounded-md text-gray-500 bottom-1.5 right-1 md:bottom-2.5 md:right-2 hover:bg-gray-100 dark:hover:text-gray-400 dark:hover:bg-gray-900 disabled:hover:bg-transparent dark:disabled:hover:bg-transparent\"]'\n          );\n          //@ts-ignore\n          button?.click();\n          return true;\n        }\n        console.log(\"TEXT AREA NOT FOUND\");\n      }, prompt)\n    );\n  });\n\n  // Waiting for re-appear send message button that show current prompt is completed\n  await page.waitForSelector(\n    'button[class=\"absolute p-1 rounded-md text-gray-500 bottom-1.5 right-1 md:bottom-2.5 md:right-2 hover:bg-gray-100 dark:hover:text-gray-400 dark:hover:bg-gray-900 disabled:hover:bg-transparent dark:disabled:hover:bg-transparent\"]',\n    { timeout: 300000 }\n  );\n\n  console.log(\"ANSWER IS COMPLETED\");\n\n  // finding the last answer\n  const result: string | undefined = await new Promise(\n    async (resolve, reject) => {\n      resolve(\n        await page.evaluate(() => {\n          // document.title = \"bhagya 1234\";\n          const allAnswer = document.querySelectorAll(\n            'div[class=\"w-full border-b border-black/10 dark:border-gray-900/50 text-gray-800 dark:text-gray-100 group bg-gray-50 dark:bg-[#444654]\"]'\n          );\n          console.log({ allAnswer });\n          let lastAnswer = \"\";\n          if (allAnswer.length > 0) {\n            lastAnswer = allAnswer[allAnswer.length - 1].outerHTML;\n            console.log({ lastAnswer });\n          }\n          return lastAnswer;\n        })\n      );\n    }\n  );\n\n  if (!result) {\n    return { isSuccessful: false, message: \"Empty result found\" };\n  }\n\n  const finalResult = html2md(result);\n  //Setting page back to idle for next prompt\n  await setBrowserPageIdle(pageId, true);\n  return {\n    isSuccessful: true,\n    message: \"Successfully done\",\n    result: {\n      text: finalResult,\n      thread: pageId,\n    },\n  };\n}"
  },
  "execAsync": {
    "name": "execAsync",
    "slug": "TsFunction",
    "id": "zyrshcpmhpzyjtqwgauilden",
    "description": "promises to exec something with response and success as result (Promised)",
    "operationName": "child-process-helper",
    "rawText": " async (\n  command: string,\n  execOptions: ExecOptions\n): Promise<{ isSuccessful: boolean; response: string }> => {\n  const result = await new Promise<{ isSuccessful: boolean; response: string }>(\n    (resolve) => {\n      exec(command, execOptions, (error, stdout, stderr) => {\n        console.log({ error, stdout, stderr });\n      })\n        .on(\"exit\", (code) => {\n          resolve({ response: String(code), isSuccessful: false });\n        })\n        .on(\"message\", (message) => {\n          console.log({ message });\n        })\n        .on(\"error\", (err) => {\n          resolve({ response: String(err), isSuccessful: false });\n        });\n    }\n  );\n\n  return result;\n}"
  },
  "spawnAsync": {
    "name": "spawnAsync",
    "slug": "TsFunction",
    "id": "tmqhhatyrljguqksignopodd",
    "description": "i don't know if this is ever useful...",
    "operationName": "child-process-helper",
    "rawText": " (\n  command: string,\n  options: SpawnOptionsWithoutStdio\n): Promise<{ success: boolean; response: string; data?: string[] }> => {\n  return new Promise((resolve) => {\n    const spawned = spawn(command, options);\n\n    const data: string[] = [];\n    spawned\n      .on(\"exit\", (code) => {\n        resolve({ response: String(code), success: false, data });\n      })\n      .on(\"message\", (message) => {\n        //not sure if this does anything\n      })\n      .on(\"data\", (message) => {\n        //not sure if this does anything\n        data.push(message);\n      })\n      .on(\"error\", (err) => {\n        resolve({ response: String(err), success: false, data });\n      });\n  });\n}"
  },
  "cleanupTsDatabase": {
    "name": "cleanupTsDatabase",
    "slug": "TsFunction",
    "id": "smkvqinowjsjmhmxttzzkjqw",
    "description": "From all Ts Index Models, removes the instances that refer to a ts file that doesn't exist anymore in the operation.",
    "operationName": "cleanup-typescript-database",
    "rawText": " async (\n  operationName: string,\n  manualProjectRoot?: string\n) => {\n  //console.log(\"let's cleanup operation \", operationName, manualProjectRoot);\n  const operationBasePath = await getOperationPath(operationName);\n\n  //console.log({ operationBasePath });\n  if (!operationBasePath) return;\n  const operationRelativePaths = (\n    await getPackageSourcePaths({ operationBasePath })\n  ).map((absolutePath) =>\n    getOperationRelativePath(absolutePath, operationBasePath)\n  );\n\n  // all typescript index models related to a ts file should be cleaned\n  const removeResults = await Promise.all(\n    typescriptIndexModels.map((modelName) => {\n      return db.remove(\n        modelName,\n        (model) => {\n          const shouldRemove = shouldDeleteTsModel(\n            model,\n            operationName,\n            operationRelativePaths\n          );\n          /*\n          if (shouldRemove) {\n            console.log({\n              modelName,\n              operationRelativePaths,\n              model: model.name,\n              shouldRemove,\n              ts: model.operationRelativeTypescriptFilePath,\n            });\n          }*/\n\n          return shouldRemove;\n        },\n        { operationName, manualProjectRoot }\n      );\n    })\n  );\n\n  //console.log({ removeResults });\n\n  const totalRemoved = removeResults.reduce(\n    (previous, current) => previous + (current.amountRemoved || 0),\n    0\n  );\n\n  return {\n    amountRemoved: totalRemoved,\n  };\n}"
  },
  "shouldDeleteTsModel": {
    "name": "shouldDeleteTsModel",
    "slug": "TsFunction",
    "id": "qguzrehatykckurjkkimwhhn",
    "description": "",
    "operationName": "cleanup-typescript-database",
    "rawText": " (\n  tsModel:\n    | TsFunction\n    | TsComment\n    | TsInterface\n    | TsBuildError\n    | TsLintWarning\n    | TsExport\n    | TsImport\n    | TsVariable,\n  operationName: string,\n  operationRelativePaths: string[]\n) => {\n  if (!tsModel.operationName) {\n    // console.log(\"no operationaName\");\n    return true;\n  }\n  if (tsModel.operationName !== operationName) {\n    // console.log(\"wrong operationName\");\n    return true;\n  }\n  if (!tsModel.operationRelativePath) {\n    //   console.log(\"no operationRelativePath\");\n    return true;\n  }\n  if (\n    !operationRelativePaths.includes(\n      tsModel.operationRelativeTypescriptFilePath\n    )\n  ) {\n    // console.log(\"no correct operationRelativeTypescriptFilePath\");\n    return true;\n  }\n\n  return false;\n}"
  },
  "ClickableIcon": {
    "name": "ClickableIcon",
    "slug": "TsFunction",
    "id": "fwynhsvuegedxtaokinvjlmz",
    "description": "Renders a simple clickable icon with some styling\n\nIcon can be either an icon (Svg src) or emoji (string)",
    "operationName": "clickable-icon",
    "rawText": " (button: ClickableIconType) => {\n  return (\n    <Button\n      className=\"flex flex-col items-center\"\n      onClick={button.disabled ? undefined : button.onClick}\n    >\n      {button.icon ? (\n        <Svg\n          src={button.icon}\n          width={24}\n          height={24}\n          className={button.disabled ? \"text-gray-500\" : \"text-black\"}\n        />\n      ) : button.emoji ? (\n        <P\n          className={`text-xl ${\n            button.disabled ? \"opacity-50\" : \"hover:scale-110\"\n          }`}\n        >\n          {button.emoji}\n        </P>\n      ) : null}\n    </Button>\n  );\n}"
  },
  "commentTypesConst": {
    "name": "commentTypesConst",
    "slug": "TsVariable",
    "id": "wfvruizuryovkxnrrscjaukh",
    "description": "",
    "operationName": "code-types"
  },
  "commentTypes": {
    "name": "commentTypes",
    "slug": "TsVariable",
    "id": "nbfkhxrenupypddjmozaxcvc",
    "description": "",
    "operationName": "code-types"
  },
  "contentTypeConst": {
    "name": "contentTypeConst",
    "slug": "TsVariable",
    "id": "dvyseixtlscrzfsbslqvazbn",
    "description": "Improves the convention for parameter names that refer to models. probably it's better to do this: `slug/id/index` are reserved on every model, let's call them \"Ref\". `modelNameRef` refers to modelName. But what if you want to call it differently? Then you'd need to distinguish a prefix from the modelName. Let's do this with a underscore (no dash because underscore preserves ability to dotting on the object). If you want a reference to a user be called author, you'd name it `author_userSlug`.\n\nTODO: reduce all TsInterfaces and functions into their parameters :D",
    "operationName": "code-types"
  },
  "datasetConfigKeys": {
    "name": "datasetConfigKeys",
    "slug": "TsVariable",
    "id": "ckcysgttymkswonfbfclxyfp",
    "description": "",
    "operationName": "code-types"
  },
  "datasetFilterOperatorConst": {
    "name": "datasetFilterOperatorConst",
    "slug": "TsVariable",
    "id": "pxyeziundbxwazxjuygqsdkg",
    "description": "NB: keys are made `humanCase` and used in UI, so keep a readable name",
    "operationName": "code-types"
  },
  "dbStorageMethodsConst": {
    "name": "dbStorageMethodsConst",
    "slug": "TsVariable",
    "id": "frpdkkcmqexyepbfjbqkkpwl",
    "description": "",
    "operationName": "code-types"
  },
  "dbStorageMethods": {
    "name": "dbStorageMethods",
    "slug": "TsVariable",
    "id": "omcvnajeliyvreplcovvmrvj",
    "description": "",
    "operationName": "code-types"
  },
  "getExamples": {
    "name": "getExamples",
    "slug": "TsFunction",
    "id": "bpvhlnnjhaqykljrubnxnqqi",
    "description": "",
    "operationName": "code-types",
    "rawText": " async (functionName: string) => {\n  // const examples = (await db.get(\"FunctionExecution\")).filter(x=>x.isExample && x.functionName === functionName)\n}"
  },
  "getFunctionExersize": {
    "name": "getFunctionExersize",
    "slug": "TsFunction",
    "id": "fgbcmhqsydbfjobyidtjqzfe",
    "description": "",
    "operationName": "code-types",
    "rawText": " async (\n  functionId: string\n): Promise<string> => {\n  //1) get the function, make the description, input, and output string\n  const descriptionString = \"\";\n  const inputString = \"\";\n  const outputString = \"\";\n  //2) get all it's examples from `FunctionExecution`, make the example string\n  const examplesString = 'Input `x, y, z`. Output should be \"a\"';\n\n  return `\nWrite a function that can do this:\n\n${descriptionString}\n\nIt should take this as its inputs:\n\n${inputString}\n\nIt should return this:\n\n${outputString}\n\nSome examples:\n\n${examplesString}\n`;\n}"
  },
  "indexDbModelFolders": {
    "name": "indexDbModelFolders",
    "slug": "TsVariable",
    "id": "ukwjjntofcprkmsradntxyzy",
    "description": "",
    "operationName": "code-types"
  },
  "indexDbModels": {
    "name": "indexDbModels",
    "slug": "TsVariable",
    "id": "rzuvwulxlneflmqjtotvnwcz",
    "description": "All type interfaces that are used to index stuff, which are added to the database\n\nNB: It's not handy to get this from the database because this is used to generate the database xD",
    "operationName": "code-types"
  },
  "modelViews": {
    "name": "modelViews",
    "slug": "TsVariable",
    "id": "lyxcdnrwpbanisipljrnxztd",
    "description": "",
    "operationName": "code-types"
  },
  "operationClassificationConst": {
    "name": "operationClassificationConst",
    "slug": "TsVariable",
    "id": "mathzwniejfzvprccubodvun",
    "description": "",
    "operationName": "code-types"
  },
  "runEveryPeriodReadonlyArray": {
    "name": "runEveryPeriodReadonlyArray",
    "slug": "TsVariable",
    "id": "eomqpqgtkxbaeiuqeopfyfzr",
    "description": "",
    "operationName": "code-types"
  },
  "runEveryPeriodStringArray": {
    "name": "runEveryPeriodStringArray",
    "slug": "TsVariable",
    "id": "ypyeatqjxugikmdkxlepxbjj",
    "description": "",
    "operationName": "code-types"
  },
  "typescriptIndexModels": {
    "name": "typescriptIndexModels",
    "slug": "TsVariable",
    "id": "cwmrnuqxysnwxkewlnodwxkm",
    "description": "",
    "operationName": "code-types"
  },
  "stripCommentEnd": {
    "name": "stripCommentEnd",
    "slug": "TsFunction",
    "id": "wpreffdrypxfbvotbjlsckex",
    "description": "only strip slahes for single-line comments",
    "operationName": "comment-util",
    "rawText": " (trimmedLine: string) =>\n  trimmedLine.endsWith(\"*/\")\n    ? trimmedLine.substring(0, trimmedLine.length - 2).trim()\n    : trimmedLine"
  },
  "stripCommentStart": {
    "name": "stripCommentStart",
    "slug": "TsFunction",
    "id": "arogemnajperdirswxzjzhrz",
    "description": "",
    "operationName": "comment-util",
    "rawText": " (trimmedLine: string) =>\n  trimmedLine.startsWith(\"/**\")\n    ? trimmedLine.substring(3).trim()\n    : trimmedLine.startsWith(\"/*\")\n    ? trimmedLine.substring(2).trim()\n    : trimmedLine"
  },
  "stripComment": {
    "name": "stripComment",
    "slug": "TsFunction",
    "id": "wyomngtcixzgbzimscasaykf",
    "description": "parses comments (single line, multiline and doc) and removes the comment syntax\n\n- removes slashes\n- removes multiline comment prefix\n- removes multiline comment suffix\n- removes doccomment stars\n\nexample input: `// comment`, output: `comment`\n\nexample input:\n```\n\nsome\nmultiline\ncomment *~/\n```\noutput:\n```\nsome\nmultiline\ncomment\n```",
    "operationName": "comment-util",
    "rawText": " (rawCommentString: string): string => {\n  const lines = rawCommentString.split(\"\\n\");\n  const strippedComment = lines\n    .map((line) => {\n      return apply(\n        [\n          trim,\n          stripSlashes,\n          stripCommentStart,\n          stripCommentEnd,\n          stripStar,\n          trim,\n        ],\n        line\n      );\n    })\n    .join(\"\\n\");\n\n  return apply([trimSurroundingNewlines], strippedComment);\n}"
  },
  "stripSlashes": {
    "name": "stripSlashes",
    "slug": "TsFunction",
    "id": "sqmvdybniwoksyytxzpydbpt",
    "description": "",
    "operationName": "comment-util",
    "rawText": " (trimmedLine: string) =>\n  trimmedLine.startsWith(\"//\") ? trimmedLine.substring(2).trim() : trimmedLine"
  },
  "stripStar": {
    "name": "stripStar",
    "slug": "TsFunction",
    "id": "dbgqfoazqxaqenwohrbivbgr",
    "description": "",
    "operationName": "comment-util",
    "rawText": " (trimmedLine: string) =>\n  trimmedLine.startsWith(\"*\") ? trimmedLine.substring(1).trim() : trimmedLine"
  },
  "trimSurroundingNewlines": {
    "name": "trimSurroundingNewlines",
    "slug": "TsFunction",
    "id": "zeczxclsfbmulmhmusolkduf",
    "description": "removes new lines at beginning and end\n\nNB: This function uses a small recursion! I don't know if this is very efficient, but shouldn't be too deep!\n\nNB: it should be noted that a newline apparently seems to be counting as a single character! Strange.",
    "operationName": "comment-util",
    "rawText": " (string: string): string => {\n  return string.startsWith(\"\\n\")\n    ? trimSurroundingNewlines(string.substring(1))\n    : string.endsWith(\"\\n\")\n    ? trimSurroundingNewlines(string.substring(0, string.length - 1))\n    : string;\n}"
  },
  "trim": {
    "name": "trim",
    "slug": "TsFunction",
    "id": "bcizxmpdmwpgjwgyslsrpmsq",
    "description": "",
    "operationName": "comment-util",
    "rawText": " (string: string) => string.trim()"
  },
  "getCompileErrors": {
    "name": "getCompileErrors",
    "slug": "TsFunction",
    "id": "ewlpszinfabulnnypdspgnvb",
    "description": "gets compileErrors of an operation. if it has no errors, it also check all dependants to see if they have errors, possibly because we changed this one\n\n1) get buildErrors for all src files of current operation\n2) if build doesn't succeed, only check for build errors in current operation\n3) if build succeeds, check iffor build errors in all files in all operations that depend on this one. this means we need compile to be ran for every operation\n\nTODO: Later, only check all build errors of all dependants if and only if an export blueprint (io) has changed and if this export was imported there",
    "operationName": "compile-typescript",
    "rawText": " async (\n  operationBasePath: string,\n  onlyDependants?: boolean,\n  manualProjectRoot?: string\n): Promise<Creation<TsBuildError>[]> => {\n  const moduleName = await getOperationPackageName(operationBasePath);\n\n  if (onlyDependants) {\n    log(\"Getting compilation errors for all dependants\", { type: \"important\" });\n\n    // should get all operations that have this module in their imports\n    // in the beginning, no indexes for this will exist, so that's fine...\n    const allImports = await db.get(\"TsImport\", { manualProjectRoot });\n    const dependants: string[] = allImports\n      .filter((imp) => imp.module === moduleName)\n      .map((imp) => imp?.operationName)\n      .filter(notEmpty)\n      .filter(onlyUnique);\n\n    log(`Dependants ${dependants.join(\", \")} (now skipping)`, {\n      type: \"important\",\n    });\n    // const stuff = (\n    //   await Promise.all(\n    //     dependants.map(async (dep) => {\n    //       const operationFolderPath = await getOperationPath(dep);\n    //       if (!operationFolderPath) return null;\n\n    //       const filePaths: string[] = await getPackageSourcePaths({\n    //         packageFolder: operationFolderPath,\n    //       });\n    //       const tsConfig = await getTsConfig(operationFolderPath);\n    //       const packageJson = await getPackageJson({ operationFolderPath });\n\n    //       if (!tsConfig) return null;\n    //       if (!packageJson) return null;\n\n    //       return {\n    //         basePath: operationFolderPath,\n    //         packageJson,\n    //         compilerOptions: tsConfig.compilerOptions,\n    //         filePaths,\n    //       };\n    //     })\n    //   )\n    // ).filter(notEmpty);\n\n    const allBuildErrors = [].map(getTypescriptErrorsFromFiles).flat();\n\n    return allBuildErrors;\n  } else {\n    const tsConfig = await getTsConfig(operationBasePath);\n    const compilerOptions = tsConfig?.compilerOptions;\n    if (!compilerOptions) {\n      log(\n        `Couldn't find tsConfig compilerOptions for this operation (${operationBasePath}`,\n        { type: \"error\" }\n      );\n      return [];\n    }\n\n    const filePaths = await getPackageSourcePaths({\n      operationBasePath,\n    });\n\n    const packageJson = await getPackageJson({\n      operationFolderPath: operationBasePath,\n    });\n\n    if (!packageJson) return [];\n\n    const buildErrorsHere = getTypescriptErrorsFromFiles({\n      packageJson,\n      basePath: operationBasePath,\n      filePaths,\n      compilerOptions,\n    });\n\n    // const buildErrorsHere: TsBuildError[] = [];\n    if (buildErrorsHere.length > 0) {\n      return buildErrorsHere;\n    } else if (!onlyDependants) {\n      // do the same for all dependants, but only if this is not already a dependant (just 1 level of recursion)...\n      return getCompileErrors(operationBasePath, true, manualProjectRoot);\n    } else {\n      return [];\n    }\n  }\n}"
  },
  "[\n  operationBasePath,\n  operationManualProjectRoot,\n  typerepoManualProjectRoot,\n]": {
    "name": "[\n  operationBasePath,\n  operationManualProjectRoot,\n  typerepoManualProjectRoot,\n]",
    "slug": "TsVariable",
    "id": "ndqyfmbhpmokyfnmjzitujzh",
    "description": "",
    "operationName": "compile-typescript"
  },
  "writeBuildErrors": {
    "name": "writeBuildErrors",
    "slug": "TsFunction",
    "id": "obrzovmuklpkreymbotvaltn",
    "description": "",
    "operationName": "compile-typescript",
    "rawText": " async (\n  operationBasePath: string,\n  operationManualProjectRoot?: string,\n  typerepoManualProjectRoot?: string\n) => {\n  const operationName = getLastFolder(operationBasePath);\n  const projectRoot = operationManualProjectRoot || getProjectRoot();\n  if (!projectRoot) return;\n  // NB: fix to globally alter real fs in order to fix EMFile error that happens in TSMorph (see https://github.com/isaacs/node-graceful-fs)\n  gracefulFs.gracefulify(realFs);\n\n  // NB: this does it for all files in the whole operation!\n  const buildErrors = await getCompileErrors(\n    operationBasePath,\n    false,\n    operationManualProjectRoot\n  );\n\n  await db.clear(\"TsBuildError\", {\n    operationName,\n    manualProjectRoot: operationManualProjectRoot,\n  });\n  // @ts-ignore\n  await db.upsert(\"TsBuildError\", buildErrors, {\n    operationName,\n    manualProjectRoot: operationManualProjectRoot,\n  });\n\n  // log(`Wrote ts-build-errors for ${operationFolder}`, { type: \"success\" });\n\n  process.exit(0);\n}"
  },
  "ContextMenuItemComponent": {
    "name": "ContextMenuItemComponent",
    "slug": "TsFunction",
    "id": "wyyepswogptzeyqqlbilnruy",
    "description": "",
    "operationName": "context-menu",
    "rawText": " (props: {\n  item: ContextMenuItem;\n  id: string | undefined;\n  onClose: () => void;\n  itemClassName?: string;\n}) => {\n  const { item, id, onClose, itemClassName } = props;\n\n  const [loading, setLoading] = useState(false);\n  return (\n    <P\n      onClick={async () => {\n        setLoading(true);\n        await item.onClick(id);\n        setLoading(false);\n        onClose();\n      }}\n      className={\n        itemClassName ||\n        \"select-none dark:text-black cursor-pointer lg:hover:bg-blue-300 py-2 px-4 flex flex-row\"\n      }\n    >\n      {loading ? (\n        <Span>\n          <FancyLoader />\n        </Span>\n      ) : null}{\" \"}\n      <Span>{item.getTitle(id)}</Span>\n    </P>\n  );\n}"
  },
  "useContextMenu": {
    "name": "useContextMenu",
    "slug": "TsFunction",
    "id": "extevahidtmobpdtkvoekltv",
    "description": "Use this if you want to render a context menu where the menu closes if you click one of the items.\n\nOptionally, you can create a custom renderer for it.\n\nid can be provided by the contextEvent.",
    "operationName": "context-menu",
    "rawText": " (props: {\n  items: ContextMenuItem[];\n  longTouchDurationMs?: number;\n  /**\n   * Customise the container class\n   */\n  className?: string;\n\n  /**\n   * Customise the contextMenuItem className\n   *\n   * Example:\n   *\n   * `select-none cursor-pointer lg:hover:bg-blue-300 py-2 px-4`\n   */\n  itemClassName?: string;\n  /**\n   * \n   * Overwrite the default item using this custom renderer:\n   * \n   * Example:\n   * \n   * ```tsx\n  customItemRender={(\n    contextMenuItem,\n    index,\n    onClose,\n    id\n  ) => (\n      <P\n        onClick={() => {\n          contextMenuItem.onClick(id);\n          onClose();\n        }}\n        className=\"select-none cursor-pointer lg:hover:bg-blue-300 py-2 px-4\"\n        key={`menu${index}`}\n      >\n        {contextMenuItem.getTitle(id)}\n      </P>)}\n              \n   * ```\n   */\n  customItemRender?: (\n    contextMenuItem: ContextMenuItem,\n    index: number,\n    onClose: () => any,\n    id: string | undefined\n  ) => JSX.Element | null;\n}) => {\n  const {\n    items,\n    longTouchDurationMs,\n    className,\n    customItemRender,\n    itemClassName,\n  } = props;\n  const {\n    renderContextPopper: renderContextMenu,\n    openContextPopperProps: openContextMenuProps,\n    onClose,\n    isOpen,\n  } = useContextPopper({\n    longTouchDurationMs,\n    renderPopper: (props) => {\n      const { id } = props;\n      return (\n        <Div\n          className={\n            // className ||\n            \"bg-white dark:bg-gray-700 border border-black max-h-80 overflow-y-scroll\"\n          }\n        >\n          {items\n            .filter((x) => (x.getIsEnabled ? x.getIsEnabled(id) : true))\n            .map((contextMenuItem, index) => {\n              if (customItemRender) {\n                return customItemRender(contextMenuItem, index, onClose, id);\n              }\n\n              return (\n                <ContextMenuItemComponent\n                  id={id}\n                  item={contextMenuItem}\n                  key={`menuItem${index}`}\n                  onClose={onClose}\n                  itemClassName={itemClassName}\n                />\n              );\n            })}\n        </Div>\n      );\n    },\n  });\n\n  // ensure it only updates when you open the menu. this breaks the whole thing! lol.\n  const result = useMemo(\n    () => ({ renderContextMenu, openContextMenuProps, onClose, isOpen }),\n    [isOpen]\n  );\n\n  return { renderContextMenu, openContextMenuProps, onClose, isOpen };\n}"
  },
  "useContextPopper": {
    "name": "useContextPopper",
    "slug": "TsFunction",
    "id": "qhgbsgrlzfyossadxdoivvom",
    "description": "Use this hook if you want to create your own custom render that opens on the right location once the `.onContextMenu` is fired.",
    "operationName": "context-menu",
    "rawText": " (props: {\n  renderPopper: (props: { id?: string }) => JSX.Element;\n  longTouchDurationMs?: number;\n}): {\n  isOpen: boolean;\n  /**\n   * Render this function anywhere in your component. Ensure it's high enough up the tree to make sure the positioning is correct. Not tested in modals and scrollable divs...\n   */\n  renderContextPopper: () => JSX.Element | null;\n\n  /**\n   * Callback to close the popper from anywhere\n   */\n  onClose: () => void;\n  /**\n   * Attach these props to the element that should be right-clickable or long-pressable\n   *\n   * You can also pass an id to this element in order to pass this to the callback\n   * e.g.\n   *\n   * ```tsx\n   * <div id=\"some-id\" {...openContextPopperProps}>your html</div>\n   * ```\n   *\n   * If you also want to attach your own properties, you can destructure this and wrap the individual props in your final prop.\n   */\n  openContextPopperProps: {\n    ref: React.RefObject<HTMLDivElement>;\n    onContextMenu: (event: React.MouseEvent<Element, MouseEvent>) => void;\n    onTouchStart: (event: React.TouchEvent<Element>) => void;\n    onTouchEnd: () => void;\n    onClick: (mouseEvent: React.MouseEvent<Element, MouseEvent>) => void;\n    style: React.CSSProperties;\n  };\n} => {\n  const { longTouchDurationMs } = props;\n  const [contextEvent, setContextEvent] = useState<ContextEvent | null>(null);\n\n  useEffect(() => {\n    if (typeof window === \"undefined\") return;\n\n    // Needed to make it go away when clicking outside of the popper, doesn't work for textarea though\n    window.addEventListener(\"click\", () => {\n      setContextEvent(null);\n    });\n  }, []);\n\n  const contextProps = useContext(\n    (contextEvent) => {\n      setContextEvent(contextEvent);\n      console.log(\"callback called\", props, contextEvent);\n    },\n    { longTouchDurationMs }\n  );\n\n  const virtualReference = useMemo(() => {\n    if (!contextEvent) {\n      //   console.log(\"NO context event,SHOULD NOT HAPPEN\");\n      return;\n    }\n\n    // console.log(\"YAY\");\n\n    // console.log({\n    //   contextEvent,\n    //   x: contextEvent?.clientX,\n    //   y: contextEvent?.clientY,\n    // });\n    return {\n      // This is going to create a virtual reference element\n\n      getBoundingClientRect() {\n        // console.log({ contextEvent });\n\n        const clientRect: ClientRect = {\n          top: contextEvent?.clientY || 10,\n          left: contextEvent?.clientX || 10,\n          bottom: 0,\n          right: 0,\n          width: 0,\n          height: 0,\n          x: 0,\n          y: 0,\n          toJSON() {\n            return \"\";\n          },\n        };\n        return clientRect;\n      },\n    };\n  }, [contextEvent]);\n\n  const popperRef = useRef<HTMLDivElement>(null);\n  const { styles, attributes } = usePopper(\n    virtualReference,\n    popperRef.current,\n    {\n      strategy: \"fixed\",\n      placement: \"auto-start\",\n      modifiers: [{ name: \"preventOverflow\", enabled: false }],\n    }\n  );\n\n  const renderContextPopper = () =>\n    virtualReference && contextEvent ? (\n      <div\n        onClick={(e) => {\n          // NB: needed to ensure it doesn't close due to the window.click\n          e.stopPropagation();\n        }}\n        style={styles.popper}\n        {...attributes.popper}\n      >\n        {props.renderPopper({ id: contextEvent.id })}\n      </div>\n    ) : null;\n\n  const openContextPopperProps = {\n    ...contextProps,\n    ref: popperRef,\n  };\n\n  const onClose = () => setContextEvent(null);\n\n  return {\n    openContextPopperProps,\n    renderContextPopper,\n    onClose,\n    isOpen: !!contextEvent,\n  };\n}"
  },
  "useContext": {
    "name": "useContext",
    "slug": "TsFunction",
    "id": "rdwkiyvvtscylorjfnohiiem",
    "description": "Use this if you want to create a completely custom behavior from a context action. On top of the default `.onContextMenu` behavior, this hook enables the possibility for a custom hold duration on mobile.",
    "operationName": "context-menu",
    "rawText": " (\n  /**\n   * The callback that activates whenever you right-click or long-press\n   */\n  callback: (position: ContextEvent) => any,\n  config?: {\n    /**\n     * Customise the time for a longpress to enable the callback. Defaults to browser default (onContextMenu default). If you set this, we detect the duration ourselves via the onTouchStart and onTouchEnd events.\n     */\n    longTouchDurationMs?: number;\n  }\n) => {\n  const [timeoutRef, setTimeoutRef] = useState<NodeJS.Timeout | null>(null);\n\n  const openTouchMenu = (event: React.TouchEvent) => {\n    const touch = event.touches.item(event.touches.length - 1);\n    const { clientX, clientY, screenX, screenY } = touch;\n    const id = event.currentTarget?.id;\n    callback({ clientX, clientY, screenX, screenY, id });\n    setTimeoutRef(null);\n  };\n\n  const openContextMenu = (event: React.MouseEvent) => {\n    const { clientX, clientY, screenX, screenY } = event;\n    const id = event.currentTarget?.id;\n    callback({ clientX, clientY, screenX, screenY, id });\n  };\n\n  const onTouchStart = (event: React.TouchEvent) => {\n    // Only allow for a single timeout\n    if (timeoutRef) return;\n    if (!config?.longTouchDurationMs) return;\n    const timeout = setTimeout(\n      () => openTouchMenu(event),\n      config.longTouchDurationMs\n    );\n    setTimeoutRef(timeout);\n  };\n\n  /**\n   * Required for ensuring that you don't close  the menu immediately when opening it on mobile, because a click-event is also fired there\n   */\n  const onClick = (mouseEvent: React.MouseEvent) => {\n    // this also makes it impossible to close big markdown files!\n    // mouseEvent.stopPropagation();\n  };\n\n  const onTouchEnd = () => {\n    if (timeoutRef) {\n      clearTimeout(timeoutRef);\n    }\n  };\n\n  const onContextMenu = (event: React.MouseEvent) => {\n    event.preventDefault();\n    // NB: needed to stop it from opening anywhere above (mobile)\n    event.stopPropagation();\n    openContextMenu(event);\n  };\n  //\n  const contextProps = {\n    onContextMenu,\n    // onContextMenuCapture: (event: React.MouseEvent) => {\n    //   event.preventDefault();\n    //   event.stopPropagation();\n    // },\n    onTouchStart,\n    onTouchEnd,\n    onClick,\n    style: {}, //userSelect: \"none\" as React.CSSProperties[\"userSelect\"]\n  };\n  return contextProps;\n}"
  },
  "camelCase": {
    "name": "camelCase",
    "slug": "TsFunction",
    "id": "ybaydpibgnqnmnxpsurvpuup",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (text: string) => convertCase(text, \"camel\")"
  },
  "capitalCase": {
    "name": "capitalCase",
    "slug": "TsFunction",
    "id": "znjsryllqejrirvtwmkbzmwc",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (text: string) => convertCase(text, \"capital\")"
  },
  "capitaliseFirstLetter": {
    "name": "capitaliseFirstLetter",
    "slug": "TsFunction",
    "id": "syadmirewmvzrrnzyeesuwkf",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (word: string) => {\n  return word.charAt(0).toUpperCase().concat(word.substring(1));\n}"
  },
  "convertCase": {
    "name": "convertCase",
    "slug": "TsFunction",
    "id": "lnjwrturyxuoeehfhlbjaemf",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (\n  /**\n   * NB: texts of more than a sentence are not supported\n   */\n  text: string,\n  target: Casing\n) =>\n  text\n    .split(nonCasingDelimiters)\n    .reduce(\n      (all, word) => all.concat(splitCasingDelimiters(word)),\n      [] as string[]\n    )\n    .map((word, index) => convertToTargetCasing(word, index, target))\n    .join(getDelimiter(target))"
  },
  "convertToTargetCasing": {
    "name": "convertToTargetCasing",
    "slug": "TsFunction",
    "id": "bhrrvvverdxlkdszolapzhmq",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (word: string, index: number, target: Casing) => {\n  if (target === \"capital\") return word.toUpperCase();\n  if (target === \"kebab\" || target === \"snake\") return word.toLowerCase();\n  if (target === \"pascal\") return capitaliseFirstLetter(word);\n  if (target === \"camel\")\n    return index === 0 ? word.toLowerCase() : capitaliseFirstLetter(word);\n\n  //human case\n  return index === 0 ? capitaliseFirstLetter(word) : word.toLowerCase();\n}"
  },
  "getDelimiter": {
    "name": "getDelimiter",
    "slug": "TsFunction",
    "id": "fkdbkluuyeazsitmyoteifoh",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (target: Casing) => {\n  if (target === \"capital\") return \"_\";\n  if (target === \"human\") return \" \";\n  if (target === \"kebab\") return \"-\";\n  if (target === \"snake\") return \"_\";\n  return \"\";\n}"
  },
  "humanCase": {
    "name": "humanCase",
    "slug": "TsFunction",
    "id": "bnkhxgqqxdmqeqhkcecxetsa",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (text: string) => convertCase(text, \"human\")"
  },
  "kebabCase": {
    "name": "kebabCase",
    "slug": "TsFunction",
    "id": "zjlmqicgokgxrsrnsoqrjeqf",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (text: string) => convertCase(text, \"kebab\")"
  },
  "lowerCaseArray": {
    "name": "lowerCaseArray",
    "slug": "TsFunction",
    "id": "gjqucazfcsbogxbilrpcalsi",
    "description": "converts any string to an array of lowercase words\n\nformat [\"word1\",\"word2\",\"word3\"] from a string of any casing.",
    "operationName": "convert-case",
    "rawText": " (text: string) => {\n  return kebabCase(text).split(\"-\");\n}"
  },
  "nonCasingDelimiters": {
    "name": "nonCasingDelimiters",
    "slug": "TsVariable",
    "id": "xvralzflrknjghvkcrgdbgqz",
    "description": "",
    "operationName": "convert-case"
  },
  "pascalCase": {
    "name": "pascalCase",
    "slug": "TsFunction",
    "id": "glnwkfbqvmialaamffxzcipt",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (text: string) => convertCase(text, \"pascal\")"
  },
  "snakeCase": {
    "name": "snakeCase",
    "slug": "TsFunction",
    "id": "wjawkxrdtctgjjeosyvwkwyj",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (text: string) => convertCase(text, \"snake\")"
  },
  "splitCasingDelimiters": {
    "name": "splitCasingDelimiters",
    "slug": "TsFunction",
    "id": "lwrlbuhjpjtyudenshruhozi",
    "description": "",
    "operationName": "convert-case",
    "rawText": " (word: string): string[] => {\n  const letters = word.split(\"\");\n  const allWords = letters.reduce(\n    (words, letter) => {\n      //get the last word, we know it's always defined because of the initial value of the reduce\n      const lastWord: string = words.pop()!;\n      //let's also get the last letter\n      const lastLetter = lastWord.substring(-1);\n      const lastLetterIsLowercase = lastLetter.toUpperCase() !== lastLetter;\n      const letterIsUppercase = letter.toUpperCase() === letter;\n      const createNewWord = lastLetterIsLowercase && letterIsUppercase;\n      const newSequence = createNewWord\n        ? [lastWord, letter]\n        : [`${lastWord}${letter}`];\n      const newWords = words.concat(newSequence);\n      return newWords;\n    },\n    [\"\"]\n  );\n\n  return allWords;\n  // if it was lowercase but it became upper, it's a new word\n}"
  },
  "errorToast": {
    "name": "errorToast",
    "slug": "TsFunction",
    "id": "cpmkuoxnjeshsxqpnilezdnm",
    "description": "",
    "operationName": "cool-toast",
    "rawText": " (message?: string) => {\n  toast(\n    {\n      title: \"\",\n      body: message || \"Something went wrong\",\n    },\n    { hideProgressBar: true, position: \"bottom-right\", type: \"error\" }\n  );\n}"
  },
  "infoToast": {
    "name": "infoToast",
    "slug": "TsFunction",
    "id": "gsikcezuboqdajkbbpemlkgk",
    "description": "",
    "operationName": "cool-toast",
    "rawText": " (message?: string) => {\n  toast(\n    {\n      title: \"\",\n      body: message || \"This is interesting\",\n    },\n    { hideProgressBar: true, position: \"bottom-right\", type: \"info\" }\n  );\n}"
  },
  "showStandardResponse": {
    "name": "showStandardResponse",
    "slug": "TsFunction",
    "id": "yzweqoyzfwogzcfvarurvlud",
    "description": "Useful to show if the api has a standard response",
    "operationName": "cool-toast",
    "rawText": " (apiResult: StandardizedApiReturnType) => {\n  if (apiResult.errors) {\n    console.log({ errors: apiResult.errors });\n  }\n\n  if (apiResult.isUnauthorized) {\n    errorToast(apiResult.message);\n    return;\n  }\n\n  if (apiResult.isNotConnected) {\n    warningToast(apiResult.message || \"Not connected\");\n    return;\n  }\n\n  if (!apiResult.isSuccessful) {\n    errorToast(apiResult.message || \"Something went wrong\");\n    return;\n  }\n\n  if (!apiResult.result) {\n    successToast(\"Done\");\n    return;\n  }\n\n  if (!apiResult.result.isSuccessful) {\n    errorToast(apiResult.result.message || \"Something went wrong\");\n    return;\n  }\n\n  successToast(apiResult.result.message || \"Done\");\n}"
  },
  "successToast": {
    "name": "successToast",
    "slug": "TsFunction",
    "id": "sozuilflerwygyqlepohygrb",
    "description": "",
    "operationName": "cool-toast",
    "rawText": " (message?: string) => {\n  toast(\n    {\n      title: \"\",\n      body: message || \"Done\",\n    },\n    { hideProgressBar: true, position: \"bottom-right\", type: \"success\" }\n  );\n}"
  },
  "warningToast": {
    "name": "warningToast",
    "slug": "TsFunction",
    "id": "dnpocdustlzizweuegxwuxkk",
    "description": "",
    "operationName": "cool-toast",
    "rawText": " (message?: string) => {\n  toast(\n    {\n      title: \"\",\n      body: message || \"This is not a good idea\",\n    },\n    { hideProgressBar: true, position: \"bottom-right\", type: \"warning\" }\n  );\n}"
  },
  "csvItemArrayToCsvString": {
    "name": "csvItemArrayToCsvString",
    "slug": "TsFunction",
    "id": "tpepfinklewpyiemfpxbhoks",
    "description": "make csv string from a csv model type",
    "operationName": "csv-util",
    "rawText": " <T extends CsvItemType>(\n  csvModelData: T[]\n): string => {\n  if (csvModelData.length === 0) return \"\";\n\n  const result = stringify(csvModelData, { header: true });\n\n  return result;\n\n  /**\n\nNB: first I did my own native raw implementation, but this doesn't have good newline support, so I fell back to csv modules (https://csv.js.org/stringify/api/)\n \n  // let propertyNames = simplifiedSchema?.properties?.map((x) => x.name);\n\n  const longestItem = csvModelData.reduce(\n    (previous, current) => {\n      const keysAmount = Object.keys(current).length;\n      if (keysAmount > previous.keysAmount) {\n        return { keysAmount, item: current };\n      }\n      return previous;\n    },\n    { keysAmount: 0, item: undefined } as {\n      keysAmount: number;\n      item: T | undefined;\n    }\n  ).item!;\n\n  const propertyNames = Object.keys(longestItem);\n\n  const headerString = propertyNames.join(\",\");\n\n  const rowStrings = csvModelData.map((row) => {\n    return propertyNames!\n      .map((propertyName) => String(row[propertyName]))\n      .join(\",\");\n  });\n\n  return `${headerString}\\n${rowStrings.join(\"\\n\")}`;\n  */\n}"
  },
  "exampleCsvItems": {
    "name": "exampleCsvItems",
    "slug": "TsVariable",
    "id": "lkvzvusdrqjboigzbqknrzez",
    "description": "the same as exampleCsvString",
    "operationName": "csv-util"
  },
  "exampleCsvString__OLD": {
    "name": "exampleCsvString__OLD",
    "slug": "TsVariable",
    "id": "hwapdqvlvvdzxxgrjmlgqgyf",
    "description": "",
    "operationName": "csv-util"
  },
  "exampleCsvString": {
    "name": "exampleCsvString",
    "slug": "TsVariable",
    "id": "dzvwmxurfdhurmptcpbjhndf",
    "description": "exuivalent to exampleCsvItems",
    "operationName": "csv-util"
  },
  "tryParseCsv": {
    "name": "tryParseCsv",
    "slug": "TsFunction",
    "id": "dbzmjuqzcaztggxryfkjnwts",
    "description": "This function parses a CSV into the object it says it has in the header",
    "operationName": "csv-util",
    "rawText": " <T extends CsvItemType>(\n  csvString: string\n): T[] | null => {\n  const [columnsString, ...rowStrings] = csvString.split(\"\\n\");\n\n  const columns = columnsString.split(\",\").map((x) => x.trim());\n\n  const rows = rowStrings.map((rowString) => {\n    const values = rowString.split(\",\");\n\n    const rowObject = mergeObjectsArray(\n      columns.map((columnName, index) => {\n        return { [columnName]: parsePrimitive(values[index]) };\n      })\n    ) as T;\n\n    return rowObject;\n  });\n\n  return rows;\n}"
  },
  "dbConfig": {
    "name": "dbConfig",
    "slug": "TsVariable",
    "id": "aigpvxrlckuxabesvzqsmlkw",
    "description": "",
    "operationName": "database"
  },
  "db": {
    "name": "db",
    "slug": "TsVariable",
    "id": "roxnzjwsmwjeoflfttcrypdi",
    "description": "",
    "operationName": "database"
  },
  "generateCsvInstance": {
    "name": "generateCsvInstance",
    "slug": "TsFunction",
    "id": "gghvrenjqbahxhdazbspvvpf",
    "description": "",
    "operationName": "database",
    "rawText": " (): Creation<CsvTestModel> => {\n  return {\n    // Needed for deletion later\n    id: generateId(),\n    age: getRanomAge(),\n    name: randomName(),\n    description: \"hello world\",\n  };\n}"
  },
  "generateJsonSingleInstance": {
    "name": "generateJsonSingleInstance",
    "slug": "TsFunction",
    "id": "nambxlsfqufftftwcdrzrlkr",
    "description": "",
    "operationName": "database",
    "rawText": " (): Creation<DefaultTestModel> => {\n  return {\n    // Needed for deletion later\n    id: generateId(),\n    description: \"ehey\",\n    special: true,\n    markdown:\n      \" jaja dit is gewoon markdown \\n\\n mooi he \\n\\n # header \\n\\n test\",\n    name: randomName(),\n  };\n}"
  },
  "generateKvmdInstance": {
    "name": "generateKvmdInstance",
    "slug": "TsFunction",
    "id": "oujhmwqsxcspywwljaxlxnds",
    "description": "",
    "operationName": "database",
    "rawText": " (): Creation<KvmdTestModel> => {\n  const id = generateId();\n  return {\n    slug: id,\n    // Needed for deletion later\n    id: id,\n    isHeaderCalculated: true,\n    categoryStack: [],\n    comment: \"comment\",\n    value: \"value\",\n    name: id,\n  };\n}"
  },
  "generateMarkdownInstance": {
    "name": "generateMarkdownInstance",
    "slug": "TsFunction",
    "id": "ijpbgqnhpvqemzffngpjpcqg",
    "description": "",
    "operationName": "database",
    "rawText": " (): Creation<MarkdownTestModel> => {\n  return {\n    // Needed for deletion later\n    id: generateId(),\n\n    age: 19,\n    canBeNull: null,\n    markdown:\n      \" jaja dit is gewoon markdown \\n\\n mooi he \\n\\n # header \\n\\n test\",\n    name: randomName(),\n    stringA: \"A\",\n    stringB: \"B\",\n    stringC: \"C\",\n    yes: true,\n    canBeUndefined: undefined,\n  };\n}"
  },
  "generateSlugTestModel": {
    "name": "generateSlugTestModel",
    "slug": "TsFunction",
    "id": "vblrjthvoeyzqxrspyovxxkj",
    "description": "",
    "operationName": "database",
    "rawText": " (): Creation<SlugTestModel> => {\n  return {\n    // Needed for deletion later\n    id: generateId(),\n    name: randomName(),\n    markdown: \"wut?\",\n    special: true,\n    description: \"test\",\n  };\n}"
  },
  "getCli": {
    "name": "getCli",
    "slug": "TsFunction",
    "id": "pqaeewvljxrcvxkyqdradmxu",
    "description": "",
    "operationName": "database",
    "rawText": " async () => {\n  const [model, configString, keysString] = process.argv.slice(2);\n  const config = configString\n    ? getObjectFromParamsString(configString)\n    : undefined;\n  const keys = keysString\n    ? keysString.split(\",\").map((x) => x.trim())\n    : undefined;\n\n  const result = await testDb.get(model as keyof TestModels, config);\n\n  console.table(\n    result.map((x) =>\n      // @ts-ignore\n      keys && typeof x === \"object\" ? getSubsetFromObject(x, keys) : x\n    )\n  );\n}"
  },
  "getMergedQueryConfig": {
    "name": "getMergedQueryConfig",
    "slug": "TsFunction",
    "id": "ogghhpejrlvdiflmrjbffapx",
    "description": "",
    "operationName": "database",
    "rawText": " (\n  modelName: keyof DbModels,\n  customQueryConfig?: CustomQueryConfig\n) => mergeConfigs<DbModels>(modelName, dbConfig, customQueryConfig)"
  },
  "getRanomAge": {
    "name": "getRanomAge",
    "slug": "TsFunction",
    "id": "oadyavfkjvplybwnnbicfuyq",
    "description": "",
    "operationName": "database",
    "rawText": " () => Math.round(Math.random() * 99)"
  },
  "get": {
    "name": "get",
    "slug": "TsFunction",
    "id": "yambpldxanoxmxrzjqoplqha",
    "description": "",
    "operationName": "database",
    "rawText": " async () => {\n  await upsert();\n\n  const items = await testDb.get(\"MarkdownTestModel\");\n  console.dir({ items }, { depth: 99 });\n}"
  },
  "main": {
    "name": "main",
    "slug": "TsFunction",
    "id": "tkixwwtdxipukwomwmhitmxj",
    "description": "",
    "operationName": "watch-operations",
    "rawText": " async () => {\n  const [manualProjectRoot] = process.argv.slice(2);\n  watchOperations({ manualProjectRoot });\n}"
  },
  "migration": {
    "name": "migration",
    "slug": "TsFunction",
    "id": "wtavcpobvvctopphyqzfrxmx",
    "description": "",
    "operationName": "database",
    "rawText": " async () => {\n  const result = await testDb.update(\n    \"TsConfig\",\n    () => true,\n    (tsConfig) => ({\n      ...tsConfig,\n      compilerOptions: { ...tsConfig.compilerOptions, resolveJsonModule: true },\n    })\n  );\n\n  console.dir(result, { depth: 111 });\n}"
  },
  "randomName": {
    "name": "randomName",
    "slug": "TsFunction",
    "id": "nqnsrsehpqlzdixodjouuxid",
    "description": "",
    "operationName": "database",
    "rawText": " () => `name${Math.round(Math.random() * 888888)}`"
  },
  "removeCli": {
    "name": "removeCli",
    "slug": "TsFunction",
    "id": "btvngddbwrtypflwviolonbj",
    "description": "",
    "operationName": "database",
    "rawText": " async () => {\n  const [model, key, value] = process.argv.slice(2);\n\n  if (!value || !model || !key) {\n    console.log(\"please provide a modelName and a key + value to remove\");\n    return;\n  }\n\n  const result = await testDb.remove(\n    model as any,\n    (content) => content[key] == value\n  );\n\n  console.table(result);\n}"
  },
  "runModelEndToEndTest": {
    "name": "runModelEndToEndTest",
    "slug": "TsFunction",
    "id": "ucbtdscfhqpbmajgjwwexjfp",
    "description": "NB: we can't do a maketest because this thing relies on logging and we don't want to auto-run it",
    "operationName": "database",
    "rawText": " async (\n  modelName: keyof TestModels,\n  generateInstance: () => Creation<AnyModelType>\n) => {\n  /**\n   * this is done synchronously for every model: set, get, push, get, remove, get, update, get, get, remove all, get\n   */\n\n  const firstInstance = generateInstance();\n  const firstId = firstInstance.id;\n\n  // console.log({ firstId, firstInstance });\n\n  //@ts-ignore\n  const setResult = await testDb.set(modelName, [firstInstance]);\n  const getResult = await testDb.get(modelName);\n\n  if (getResult.length !== 1) {\n    console.log({ setResult, getResult });\n    console.log(\"Invalid length\");\n    process.exit(1);\n  } else {\n    console.log(`${modelName} Set test passed`);\n  }\n  //@ts-ignore\n  const pushResult = await testDb.upsert(modelName, generateInstance());\n  const getResult2 = await testDb.get(modelName);\n\n  if (getResult2.length !== 2) {\n    console.log({ pushResult, getResult2 });\n    console.log(\"Invalid length\");\n    process.exit(1);\n  } else {\n    console.log(`${modelName} Push test passed`);\n  }\n\n  // NB: now we have 2 items in the db\n\n  const removeResult = await testDb.remove(\n    modelName,\n    // NB: we don't remove first Id\n    (content) => content.id !== firstId\n  );\n\n  if (removeResult.amountRemoved !== 1) {\n    console.log({ removeResult });\n\n    console.log(\"Invalid amount removed\");\n    process.exit(1);\n  } else {\n    console.log(`${modelName} Remove test: correct amount removed`);\n  }\n\n  const getResult3 = await testDb.get(modelName);\n\n  if (getResult3.length !== 1) {\n    console.log({ getResult3 });\n\n    console.log(\"Invalid length\");\n    process.exit(1);\n  } else {\n    console.log(`${modelName} Remove test passed`);\n  }\n\n  // now we have 1 item in the db\n\n  const updateResult = await testDb.update(\n    modelName,\n    (content) => content.id === firstId,\n    (content) => {\n      return { ...content, id: \"NEWIDDDD\" };\n    }\n  );\n\n  if (updateResult.amountUpdated !== 1) {\n    console.log({ updateResult });\n\n    console.log(\"Invalid rows updated\", { firstId });\n    process.exit(1);\n  } else {\n    console.log(`${modelName} Update test: right amount of rows updated`);\n  }\n\n  const getResult4 = await testDb.get(modelName);\n\n  if (getResult4[0].id !== \"NEWIDDDD\") {\n    console.log({ firstItem: getResult4[0] }, \"id != NEWIDDDD\");\n    process.exit(1);\n  } else {\n    console.log(`${modelName} Update test passed`);\n  }\n\n  if (getResult4.length !== 1) {\n    console.log({ getResult4 });\n\n    console.log(\"Invalid length\");\n    process.exit(1);\n  }\n\n  console.log(`Test Succeeded for ${modelName}`);\n\n  return true;\n}"
  },
  "set": {
    "name": "set",
    "slug": "TsFunction",
    "id": "hztxlkgvxmwxpoqhngbhzrch",
    "description": "Can set a markdown item into a subfolder in the db model folder",
    "operationName": "database",
    "rawText": " () => {\n  const item: Creation<MarkdownTestModel> = {\n    categoryStack: [\"sub\", \"folder\"],\n    name: \"hell-yeah\",\n    markdown: \"some markdown....\",\n  };\n\n  const x = testDb.set(\"MarkdownTestModel\", [item]);\n\n  return x;\n}"
  },
  "testDb": {
    "name": "testDb",
    "slug": "TsVariable",
    "id": "xggemjdsmucorfjewzjigfgw",
    "description": "a db is created with models from all different db storage methods",
    "operationName": "database"
  },
  "testOperationModels": {
    "name": "testOperationModels",
    "slug": "TsFunction",
    "id": "uelqbgwvdcwyqtgeryebsnfm",
    "description": "Test if it can find all `OperationIndex`, `OperationConfig`, `PackageJson`, `TsConfig`",
    "operationName": "database",
    "rawText": " async () => {\n  // const operationIndexs = await testDb.get(\"OperationIndex\");\n  // const operationConfigs = await testDb.get(\"OperationConfig\");\n  // const packageJsons = await testDb.get(\"PackageJson\");\n  const tsConfigs = await testDb.get(\"TsConfig\");\n\n  //operationConfigs, operationIndexs, packageJsons,\n  // console.dir({ tsConfigs });\n\n  return true;\n}"
  },
  "testPerformance": {
    "name": "testPerformance",
    "slug": "TsFunction",
    "id": "ohksirnqimardqeqsuixcbtw",
    "description": "",
    "operationName": "database",
    "rawText": " async () => {\n  const executionId = generateUniqueId();\n  const performance: (PerformanceItem | undefined)[] = [];\n  getNewPerformance(\"start\", executionId, true);\n\n  const deviceInclude: Include = {\n    referenceKey: \"personIds\",\n    include: { referenceKey: \"groupSlugs\" },\n  };\n  log(\"Devices with include\", { type: \"important\" });\n\n  const withInclude = await db.get(\"Device\", { include: deviceInclude });\n\n  log(\"Devices without include\", { type: \"important\" });\n\n  const withoutInclude = await db.get(\"Device\");\n\n  performance.push(\n    getNewPerformance(\n      \"testPerformance (2x get, 1x with double include)\",\n      executionId\n    )\n  );\n  cleanupTimer(executionId);\n  log(\"DONE\", { type: \"success\" });\n  console.log(performance);\n}"
  },
  "updateCli": {
    "name": "updateCli",
    "slug": "TsFunction",
    "id": "nmxkspzvltgtnwlgverdqdgs",
    "description": "",
    "operationName": "database",
    "rawText": " async () => {\n  const [model, filterKv, updateKv] = process.argv.slice(2);\n\n  if (!filterKv || !model || !updateKv) {\n    console.log(\n      \"please provide 3 arguments: the model name, the key:value of the instance(s) to update, and the key:value of the key to change the value of\"\n    );\n  }\n\n  const [filterKey, filterValue] = filterKv.split(\":\");\n  const [updateKey, updateValue] = updateKv.split(\":\");\n\n  const result = await testDb.update(\n    model as any,\n    (content) => content[filterKey] == filterValue,\n    (content) => ({ ...content, [updateKey]: updateValue })\n  );\n\n  console.table(result);\n}"
  },
  "upsertCli": {
    "name": "upsertCli",
    "slug": "TsFunction",
    "id": "ecotucvnnddtfehtbqybbljn",
    "description": "",
    "operationName": "database",
    "rawText": " async () => {\n  const [modelName, dataString] = process.argv.slice(2);\n\n  /**\n   FOR kvmd type:\n\n   - required: name\n   - optional: parent_xxxSlug, value, comment\n   */\n  if (!dataString || !modelName) {\n    console.log(\"please choose a model and data\");\n  }\n\n  const theObject = getObjectFromParamsString(dataString);\n  //@ts-ignore\n  const result = await testDb.upsert(modelName as any, theObject);\n\n  console.table(result);\n}"
  },
  "upsert": {
    "name": "upsert",
    "slug": "TsFunction",
    "id": "jcfvhynnojzbonjhsxbyxxkr",
    "description": "Takes stored data and an item\n\n- updates the data and sets some rows to \"item\" if the item is found (through the id or slug)\n- otherwise inserts\n\nNB: this function works for any storage method except for key value markdown",
    "operationName": "fs-orm",
    "rawText": " (\n  /**\n   * The items that were already there\n   */\n  storedData: Storing<AugmentedAnyModelType>[],\n  /**\n   * The items that need to be overwritten or inserted\n   */\n  storingItems:\n    | Storing<AugmentedAnyModelType>\n    | Storing<AugmentedAnyModelType>[],\n  /**\n   * If true, the upserting will fail if there are occuring items with equal slugs/ids\n   */\n  onlyInsert?: boolean\n): DbQueryResult & {\n  newStoredData: Storing<AugmentedAnyModelType>[];\n} => {\n  const storingItemsArray = makeArray(storingItems);\n  let amountUpdated = 0;\n\n  const newStoredData = storedData\n    .map((i) => {\n      if (!i) return;\n      // NB: for every item in the stored data, try to find one that matches\n      const storingIndex = storingItemsArray.findIndex((x) => {\n        if (!x) {\n          log(\"weird item found in your data, replacing\", { type: \"debug\" });\n          return true;\n        }\n\n        const matchId = x.id === i.id;\n        // NB: sometimes slug can be undefined for some models.\n        const matchSlug = x.slug !== undefined && x.slug === i.slug;\n\n        return matchId || matchSlug;\n      });\n\n      if (storingIndex !== -1) {\n        // NB: it needs to be updated, so simply remove it because the new item is going to be concatenated\n        amountUpdated++;\n        return;\n      }\n\n      return i;\n    })\n    .filter(notEmpty)\n    .concat(storingItems);\n\n  if (onlyInsert && amountUpdated > 0) {\n    return {\n      amountUpdated: 0,\n      amountInserted: 0,\n      newStoredData: storedData,\n      amountRemoved: 0,\n      isSuccesful: false,\n      message:\n        \"The creation failed because you already have an item with this name\",\n    };\n  }\n  return {\n    amountUpdated,\n    amountInserted: amountUpdated === 0 ? 1 : 0,\n    newStoredData,\n  };\n}"
  },
  "CrudGrid": {
    "name": "CrudGrid",
    "slug": "TsFunction",
    "id": "eovgppslaglqhacjoelyipvd",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (props: CrudViewProps) => {\n  const { actions, data, highlight, tsInterface, onEndReached } = props;\n\n  return (\n    <Div className=\"flex flex-row flex-wrap\">\n      {data?.map((item) => {\n        const imageUrl = itemGetBackendAssetUrl({\n          item,\n          backendAsset: (item as any).pictureImage,\n        });\n        return imageUrl && typeof imageUrl === \"string\" ? (\n          <SpaceCard\n            ctaText=\"More info\"\n            imageUrl={imageUrl}\n            darkened={false}\n            secondaryImageUrl={imageUrl}\n            subtitle=\"Subtitle\"\n            title=\"Title\"\n          />\n        ) : (\n          \"no img url\"\n        );\n      })}\n    </Div>\n  );\n}"
  },
  "CrudTable": {
    "name": "CrudTable",
    "slug": "TsFunction",
    "id": "tzxtqubxouivtkudtkwbdhzz",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (props: CrudViewProps) => {\n  const { tsInterface, onEndReached, data, highlight, actions } = props;\n\n  const alert = useAlert();\n  const properties = getProperties(tsInterface?.type?.typeDefinition);\n  const dataParameterNames = getPropertiesDataParameterNames(properties);\n\n  const columns: ColumnType<any>[] = properties\n    // Omit referenced data\n    .filter((property) => !dataParameterNames.includes(property.name))\n    .map((property) => {\n      const referenceParameterInfo = getReferenceParameterInfo(property.name);\n      const {\n        descriptor,\n        interfaceName,\n        isReferenceMultipleParameter,\n        isReferenceParameter,\n        isReferenceSingleParameter,\n      } = referenceParameterInfo;\n\n      const isBackendAssetParameter = getAssetInputType(property.name);\n      const presentationType = isReferenceSingleParameter\n        ? \"referenceSingle\"\n        : isReferenceMultipleParameter\n        ? \"referenceMultiple\"\n        : isBackendAssetParameter\n        ? \"backendAsset\"\n        : \"text\";\n\n      const name =\n        isReferenceParameter && interfaceName\n          ? descriptor\n            ? humanCase(`${descriptor}-${interfaceName}`)\n            : humanCase(interfaceName)\n          : humanCase(property.name);\n\n      const column: ColumnType<any> = {\n        name,\n        objectParameterKey: property.name,\n        presentationType,\n      };\n      return column;\n    })\n    .filter(notEmpty);\n\n  return (\n    <Table\n      data={data}\n      onEndReached={onEndReached}\n      shouldHighlightItem={(item: any) =>\n        !!(\n          (highlight.id && item.id === highlight.id) ||\n          (highlight.slug && item.slug === highlight.slug)\n        )\n      }\n      columns={columns}\n      renderExtraColumns={(item) => {\n        return (\n          <Div className=\"flex flex-row\">\n            {item\n              ? actions.map((action) => {\n                  return (\n                    <LabeledButton\n                      onClick={() => action.action(item)}\n                      title={action.name}\n                      emoji={action.emoji}\n                      size=\"small\"\n                    />\n                  );\n                })\n              : null}\n          </Div>\n        );\n      }}\n      extraColumnsAtStart\n    />\n  );\n}"
  },
  "CrudTimeline": {
    "name": "CrudTimeline",
    "slug": "TsFunction",
    "id": "tltmecuaodputmhwggkeinoa",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (props: CrudViewProps) => {\n  return <Div />;\n}"
  },
  "CrudTree": {
    "name": "CrudTree",
    "slug": "TsFunction",
    "id": "pkmkcgnrtsvcuraazjjdeuyf",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (props: CrudViewProps) => {\n  return <Div />;\n}"
  },
  "DatasetForm": {
    "name": "DatasetForm",
    "slug": "TsFunction",
    "id": "tsekutjabckawdzbevyoaccb",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (props: { modelName: string }) => {\n  const { modelName } = props;\n\n  const [datasetConfig, setDatasetConfig] = useStore(\"db-crud.datasetConfig\");\n\n  const [form, datasetConfigForm] = useTsInterfaceForm(\n    DatasetConfigIndex as Storing<TsInterface>,\n    datasetConfig?.id || \"noid\",\n    datasetConfig\n  );\n\n  const addDatasetFromDatasetConfig = async () => {\n    if (!modelName) return;\n\n    let name = prompt(\"What should be the name?\", \"untitled\");\n    const dataset: Creation<Dataset> = {\n      ...datasetConfigForm,\n      modelName,\n      name: name || \"untitled\",\n    };\n\n    const { isSuccessful, result, message } = await api.upsertDbModel(\n      \"Dataset\",\n      //@ts-ignore\n      dataset,\n      true\n    );\n\n    metadataQuery.refetch();\n\n    successToast(\n      isSuccessful && result?.isSuccesful\n        ? \"Succesfully added\"\n        : result?.message || message || \"Error\"\n    );\n  };\n\n  const metadataQuery = queries.useGetDbModelMetadata(modelName as DbModelEnum);\n  const { datasets, tsInterface } = destructureOptionalObject(\n    metadataQuery.data?.result\n  );\n\n  const removeDataset = async () => {\n    if (!datasetConfig?.id) return;\n\n    const { isSuccessful, result, message } = await api.deleteDbModel(\n      \"Dataset\",\n      datasetConfig.id\n    );\n\n    // refetch datasets\n    metadataQuery.refetch();\n    setDatasetConfig(null);\n\n    successToast(\n      isSuccessful && result?.isSuccesful\n        ? \"Succesfully removed\"\n        : result?.message || message || \"Error\"\n    );\n  };\n\n  const properties = getProperties(tsInterface?.type?.typeDefinition);\n\n  return (\n    <Div className=\"border rounded-md border-gray-700\">\n      <P className=\"text-3xl\">Dataset Configuration</P>\n\n      {form}\n\n      <ClickableIcon\n        emoji=\"➕ New dataset\"\n        onClick={addDatasetFromDatasetConfig}\n      />\n\n      <ClickableIcon\n        emoji=\"🧪 Apply\"\n        onClick={() =>\n          datasetConfigForm !== undefined\n            ? setDatasetConfig(datasetConfigForm)\n            : null\n        }\n      />\n\n      <ClickableIcon\n        emoji=\"🧹 Clear dataset\"\n        onClick={() => setDatasetConfig(null)}\n      />\n      {datasetConfig?.id ? (\n        <ClickableIcon emoji=\"🗑 Remove dataset\" onClick={removeDataset} />\n      ) : null}\n    </Div>\n  );\n}"
  },
  "dbCrudInitialValues": {
    "name": "dbCrudInitialValues",
    "slug": "TsVariable",
    "id": "allzjhwgppkjqamrmtvyovqr",
    "description": "",
    "operationName": "db-crud"
  },
  "DbPage": {
    "name": "DbPage",
    "slug": "TsFunction",
    "id": "hkglbehmbkdqfqyblqjhkopi",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (props: {\n  filter?: (item: AugmentedAnyModelType) => boolean;\n  modelName?: string;\n}) => {\n  const router = useRouter();\n  const { modelName, filter } = props;\n  const paths = router.query.paths ? makeArray(router.query.paths) : [];\n  const modelQuery = modelName || paths.pop();\n  const [slug] = useUrl(\"slug\");\n  const [id] = useUrl(\"id\");\n\n  return (\n    <Div scroll>\n      <ModelComponent modelName={modelQuery} highlight={{ slug, id }} />\n    </Div>\n  );\n}"
  },
  "defaultLimit": {
    "name": "defaultLimit",
    "slug": "TsVariable",
    "id": "vsxzmrvouwusxxcvojrarola",
    "description": "",
    "operationName": "db-crud"
  },
  "{ deleteDbModel }": {
    "name": "{ deleteDbModel }",
    "slug": "TsVariable",
    "id": "mjwcyfbygpoyrvffbpbkarok",
    "description": "",
    "operationName": "db-crud"
  },
  "{ getDbModel }": {
    "name": "{ getDbModel }",
    "slug": "TsVariable",
    "id": "bnrjhjiwvjzrtqvhuxcvbnlh",
    "description": "",
    "operationName": "db-crud"
  },
  "getPropertiesDataParameterNames": {
    "name": "getPropertiesDataParameterNames",
    "slug": "TsFunction",
    "id": "dpsnphycipymmepnxsxjyega",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (\n  properties: SchemaProperty[]\n) => {\n  const dataParameterNames = properties\n    .map((property) => {\n      const { dataParameterName } = getReferenceParameterInfo(property.name);\n\n      return dataParameterName;\n    })\n    .filter(notEmpty);\n\n  return dataParameterNames;\n}"
  },
  "IndexInstanceContainer": {
    "name": "IndexInstanceContainer",
    "slug": "TsFunction",
    "id": "wfkuqlyswoqbalayawsozjrs",
    "description": "container for any index instance that needs to be rendered in the explore page",
    "operationName": "db-crud",
    "rawText": " ({\n  title,\n  children,\n  buttons,\n}: {\n  title: string;\n  children: any;\n  buttons: LabeledButtonType[];\n}) => {\n  return (\n    <Div className=\"p-2 m-2 border rounded-xl border-gray-500\">\n      <Div className=\"flex flex-row justify-between items-center\">\n        <P className=\"text-3xl\">{title}</P>\n\n        <Div className=\"flex flex-row gap-3\">{buttons.map(LabeledButton)}</Div>\n      </Div>\n\n      {children}\n    </Div>\n  );\n}"
  },
  "{ isBetaEnabled }": {
    "name": "{ isBetaEnabled }",
    "slug": "TsVariable",
    "id": "vryfsgpdzsdqwyupbyaajscq",
    "description": "",
    "operationName": "db-crud"
  },
  "ModelComponent": {
    "name": "ModelComponent",
    "slug": "TsFunction",
    "id": "ztdpphkwirmrlgxuwnrimsro",
    "description": "In the table headings, all xxxSlug, xxxId etc should be called xxx.\n\nIn the table values, all slugs and ids should show the name of the instance of the refered model.\n\nIt has to be possible to navigate to an id or slug using `#[id] or #[slug]` in the URL, just add div ids to all rows",
    "operationName": "db-crud",
    "rawText": " (props: {\n  modelName?: string;\n  highlight: Highlight;\n}) => {\n  const { modelName, highlight } = props;\n  const alert = useAlert();\n  const router = useRouter();\n\n  const views = modelViews.map((modelView) => ({\n    value: modelView.view,\n    label: `${modelView.emoji} ${modelView.view}`,\n  }));\n\n  const [SelectView, viewItem] = useSelect(views, views[0]);\n  const view = viewItem!.value;\n\n  const metadataQuery = queries.useGetDbModelMetadata(modelName as DbModelEnum);\n  const { datasets, tsInterface } = destructureOptionalObject(\n    metadataQuery.data?.result\n  );\n\n  const datasetItems = datasets?.map((dataset) => ({\n    label: dataset.name,\n    value: dataset.id,\n    data: dataset,\n  }));\n\n  const datasetSelectItems: Item<Dataset>[] = [\n    { value: \"\", label: \"Select a dataset\" },\n    ...(datasetItems || []),\n    { value: \"new\", label: \"(+) New dataset\" },\n  ];\n\n  const [SelectDataset] = useSelect(\n    datasetSelectItems,\n    undefined,\n    (newValue) => {\n      if (newValue?.value === \"new\") {\n        // show a blank screen\n        setDatasetConfig({ key: `config${Math.random()}` });\n        return;\n      }\n\n      if (newValue?.value === \"\") {\n        setDatasetConfig(null);\n        return;\n      }\n\n      if (newValue?.data) {\n        setDatasetConfig({ ...newValue.data, key: `config${Math.random()}` });\n        return;\n      }\n    }\n  );\n\n  const [datasetConfig, setDatasetConfig] = useStore(\"db-crud.datasetConfig\");\n\n  const model = useInfiniteGetDbModel();\n  const modelReferences = queries.useGetReferencableModelData(\n    modelName as DbModelEnum\n  );\n\n  const isLoading = model.isLoading || model.isRefetching || model.isFetching;\n\n  const allData = model?.data?.pages\n    .map((x) => x.result?.data)\n    .flat()\n    .filter(notEmpty);\n\n  // const  count = sum(model.data?.pages.map((x) => x.result?.data.length || 0) || []);\n\n  const indexDescription = tsInterface ? (\n    <Div>\n      <P className=\"font-bold\">{tsInterface.name}</P>\n\n      <MarkdownContent\n        content={tsInterface.description || \"no description\"}\n        config={{\n          projectRelativeBaseFolderPath: getFolderJs(\n            tsInterface.projectRelativePath\n          ),\n          projectRelativeMarkdownFilePath: tsInterface.projectRelativePath,\n        }}\n      />\n    </Div>\n  ) : isLoading ? (\n    <Div />\n  ) : (\n    \"No index found\"\n  );\n\n  const headerButtons = (\n    <Div className=\"flex flex-row items-center\">\n      <LabeledButton\n        onClick={() => router.push(`/upsert/${modelName}`)}\n        title=\"New\"\n        emoji=\"➕\"\n      />\n\n      <LabeledButton\n        {...{\n          onClick: () => model.refetch(),\n          title: \"Reload\",\n          emoji: isLoading ? undefined : \"🔄\",\n          component: isLoading ? () => <FancyLoader medium /> : undefined,\n        }}\n      />\n\n      {isBetaEnabled ? <SelectView /> : null}\n\n      {isBetaEnabled ? <SelectDataset /> : null}\n\n      <SearchBar />\n    </Div>\n  );\n\n  const onEndReached = () => {\n    const pages = model.data?.pages;\n\n    const lastPage = pages ? pages[pages.length - 1] : undefined;\n\n    const hasMore = lastPage?.result?.hasMore;\n\n    if (hasMore && !model.isFetchingNextPage) {\n      model.fetchNextPage();\n    }\n  };\n\n  const deleteItem = (item: AugmentedAnyModelType) => {\n    alert?.(\"Are you sure?\", \"Do you want to delete this one?\", [\n      {\n        text: \"Yes\",\n        style: \"destructive\",\n        onPress: () => {\n          if (item?.id) {\n            // console.log({ id: item.id });\n            deleteDbModel(modelName as any, item.id).then((result) => {\n              model.refetch();\n              modelReferences.refetch();\n            });\n          }\n        },\n      },\n      { text: \"Cancel\", style: \"cancel\" },\n    ]);\n  };\n\n  const deleteAction: ItemAction = {\n    action: deleteItem,\n    emoji: \"❌\",\n    name: \"Delete\",\n  };\n\n  const updateItem = (item: AugmentedAnyModelType) =>\n    router.push(`/upsert/${modelName}?id=${item?.id}`);\n\n  const updateAction: ItemAction = {\n    name: \"Update\",\n    emoji: \"✏️\",\n    action: updateItem,\n  };\n\n  const actions: ItemAction[] = [deleteAction, updateAction];\n\n  const CrudView = {\n    table: CrudTable,\n    grid: CrudGrid,\n    timeline: CrudTimeline,\n    tree: CrudTree,\n  }[view];\n\n  const crudViewProps: CrudViewProps = {\n    actions,\n\n    //@ts-ignore\n    data: allData,\n    highlight,\n    tsInterface,\n    onEndReached,\n  };\n\n  return (\n    <Div>\n      <Div className=\"px-8 lg:px-20 py-4\">\n        {headerButtons}\n        {indexDescription}\n\n        {datasetConfig && modelName && isBetaEnabled ? (\n          <DatasetForm key={datasetConfig.key} modelName={modelName} />\n        ) : null}\n      </Div>\n\n      {/* NB: here a table view should be rendered */}\n      {Array.isArray(allData) && allData.length > 0 && CrudView ? (\n        <CrudView {...crudViewProps} />\n      ) : null}\n    </Div>\n  );\n}"
  },
  "openWhatsapp": {
    "name": "openWhatsapp",
    "slug": "TsFunction",
    "id": "yoghsjbkpjhbofxfnassgjsd",
    "description": "",
    "operationName": "db-crud",
    "rawText": " ({\n  phone,\n  text,\n}: {\n  phone: string;\n  text: string;\n}) => {\n  const url =\n    \"https://api.whatsapp.com/send/\" +\n    toQueryString({ phone, text, app_absent: 0 });\n  window.open(url, \"_blank\")?.focus();\n}"
  },
  "shimmer": {
    "name": "shimmer",
    "slug": "TsFunction",
    "id": "tnzhzfnawnfmjduvzelcmuan",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (w: number, h: number) => `\n<svg width=\"${w}\" height=\"${h}\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n  <defs>\n    <linearGradient id=\"g\">\n      <stop stop-color=\"#CCC\" offset=\"20%\" />\n      <stop stop-color=\"#AAA\" offset=\"50%\" />\n      <stop stop-color=\"#CCC\" offset=\"70%\" />\n    </linearGradient>\n  </defs>\n  <rect width=\"${w}\" height=\"${h}\" fill=\"#CCC\" />\n  <rect id=\"r\" width=\"${w}\" height=\"${h}\" fill=\"url(#g)\" />\n  <animate xlink:href=\"#r\" attributeName=\"x\" from=\"-${w}\" to=\"${w}\" dur=\"1s\" repeatCount=\"indefinite\"  />\n</svg>`"
  },
  "SimplifiedSchemaFormDebug": {
    "name": "SimplifiedSchemaFormDebug",
    "slug": "TsFunction",
    "id": "uraqxjvwxsthharpsskfffeb",
    "description": "",
    "operationName": "db-crud",
    "rawText": " ({\n  parameters,\n  values,\n}: {\n  parameters: FunctionParameter[] | undefined;\n  values: any[];\n}) => {\n  const [showParams, setShowParams] = useState(false);\n  return (\n    <Div>\n      <P>values</P>\n      <MarkdownContent\n        content={createCodeblockMarkdown(\n          JSON.stringify(values, null, 2),\n          \"json\"\n        )}\n        config={{}}\n      />\n      <P\n        className=\"hover:underline cursor-pointer\"\n        onClick={() => setShowParams(!showParams)}\n      >\n        params (toggle)\n      </P>{\" \"}\n      {showParams ? (\n        <MarkdownContent\n          content={createCodeblockMarkdown(\n            JSON.stringify(parameters, null, 2),\n            \"json\"\n          )}\n          config={{}}\n        />\n      ) : null}\n    </Div>\n  );\n}"
  },
  "sortToItem": {
    "name": "sortToItem",
    "slug": "TsFunction",
    "id": "edcmllujjgowegxgvaypteuw",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (sort: DatasetSort): Item<DatasetSort> => {\n  return {\n    label: `${sort.sortDirection === \"ascending\" ? \"↑\" : \"↓\"} ${humanCase(\n      sort.objectParameterKey\n    )}`,\n    value: `${sort.objectParameterKey},${sort.sortDirection}`,\n    data: sort,\n  };\n}"
  },
  "SpaceCard": {
    "name": "SpaceCard",
    "slug": "TsFunction",
    "id": "zqmmpmdjdjigkonlmbivrakv",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (props: {\n  secondaryImageUrl: string | null;\n  darkened: boolean;\n  base64?: string;\n  imageUrl: string;\n  ctaText: string;\n  title: string;\n  subtitle: string;\n  action?: () => any;\n}) => {\n  const {\n    secondaryImageUrl,\n    darkened,\n    base64,\n    ctaText,\n    imageUrl,\n    subtitle,\n    title,\n    action,\n  } = props;\n  const [isImageReady, setIsImageReady] = useState(false);\n\n  const onLoadCallBack = () => {\n    setIsImageReady(true);\n  };\n\n  return (\n    <ALink onClick={() => action?.()}>\n      <a\n        target={\"_blank\"}\n        className=\"transition duration-300 ease-out transform cursor-pointer mb-2\"\n      >\n        <div\n          className={`relative m-2 overflow-hidden text-center rounded-xl lg:h-[268px] lg:w-[268px] h-72 w-72 ${\n            darkened ? \"bg-black\" : \"\"\n          }`}\n        >\n          {!isImageReady && (\n            <div className={`bg-gray-300 rounded-xl flex flex-1`} />\n          )}\n          {secondaryImageUrl ? (\n            <img\n              className={`rounded-xl ${darkened ? \"opacity-50\" : \"\"}`}\n              src={secondaryImageUrl}\n              // layout=\"fill\"\n              // alt=\"banner\"\n              // onLoad={onLoadCallBack}\n              // placeholder=\"blur\"\n              // objectFit=\"cover\"\n              // blurDataURL={\n              //   base64 ||\n              //   `data:image/svg+xml;base64,${toBase64(shimmer(320, 320))}`\n              // }\n            />\n          ) : null}\n          <div className=\"absolute inset-0 duration-300 ease-in-out rounded-lg group hover:bg-black hover:bg-opacity-40\">\n            <button className=\"invisible px-4 py-2 text-sm border-2 rounded-md text-white group-hover:visible group-hover:transition duration-450 mt-28\">\n              <p className=\"flex\">\n                <div className=\"\">🔍</div>\n                <p className=\"ml-2 font-bold\">{ctaText}</p>\n              </p>\n            </button>\n          </div>\n        </div>\n        <div className=\"flex justify-between mx-2 mt-2\">\n          <div className=\"flex space-x-2\">\n            {imageUrl ? (\n              <img\n                alt=\"host image\"\n                src={imageUrl}\n                width={40}\n                height={37}\n                className=\"rounded-full\"\n                // objectFit=\"cover\"\n              />\n            ) : null}\n            <div className=\"flex flex-col\">\n              <h3 className=\"text-black text-sm\">{title}</h3>\n              <h3 className=\"text-sm text-[#C4C4C4]\">{subtitle}</h3>\n            </div>\n          </div>\n        </div>\n      </a>\n    </ALink>\n  );\n}"
  },
  "toBase64": {
    "name": "toBase64",
    "slug": "TsFunction",
    "id": "anxhrimlsjcfgljlxclsmuql",
    "description": "",
    "operationName": "db-crud",
    "rawText": " (str: string) =>\n  typeof window === \"undefined\"\n    ? Buffer.from(str).toString(\"base64\")\n    : window.btoa(str)"
  },
  "{ upsertDbModel }": {
    "name": "{ upsertDbModel }",
    "slug": "TsVariable",
    "id": "vbywxgkfminjvrwscuptmfic",
    "description": "",
    "operationName": "db-crud"
  },
  "UpsertForm": {
    "name": "UpsertForm",
    "slug": "TsFunction",
    "id": "vcycupnwxnttiojadrjnihzr",
    "description": "TODO: Provide all the fetched data with `hasMore` and `fetchAll` to the `SimplifiedJsonForm`",
    "operationName": "db-crud",
    "rawText": " (props: {\n  /**\n   * the schema for the model we want to update/create\n   */\n  simplifiedSchema: SimplifiedSchema;\n  /**\n   * an instance, if it's an update form\n   */\n  instance: any;\n  /**\n   * NB: this thing will make hooks appear, so it must be constant!\n   */\n  referencableModelNames?: string[];\n  /**\n   * Provide this\n   */\n  modelName: string;\n}) => {\n  const { instance, simplifiedSchema, referencableModelNames, modelName } =\n    props;\n  const router = useRouter();\n  const alert = useAlert();\n  const [debug, setDebug] = useState(false);\n  const [id] = useState<string>(generateId());\n  const [loading, setLoading] = useState(false);\n  const [body, setBody] = useState<any>(instance);\n  const [result, setResult] = useState<any>();\n  const modelFromUrl = useModelFromUrl();\n  const metadataQuery = queries.useGetDbModelMetadata(modelFromUrl);\n  const model = useInfiniteGetDbModel();\n  const projectRelativeStorageFilePath =\n    metadataQuery.data?.result?.projectRelativeStorageFilePath;\n\n  // NB: all items that this model has can be referenced to in other forms also need to refresh\n\n  const getReferencableModelDataQuery = queries.useGetReferencableModelData(\n    modelFromUrl as DbModelEnum\n  );\n\n  const referencableModelData = useReferencableModelData(simplifiedSchema);\n\n  const parameters: RenderableFunctionParameter[] = [\n    {\n      name: \"\",\n      required: true,\n      simplifiedSchema,\n      renderButtons: () => <Span />,\n      isDbModel: true,\n    },\n  ];\n  const values = [body];\n\n  const onSubmitForm = () => {\n    if (!modelFromUrl) return;\n\n    setLoading(true);\n\n    upsertDbModel(modelFromUrl as any, body)\n      .then(async (result) => {\n        if (!result.result?.isSuccesful) {\n          // If the upsert fails for some reason, this should be made clear\n          alert?.(\"Error\", result.result?.message || result.message);\n          setLoading(false);\n        } else {\n          // NB: we are not waiting for this, we're going back immediately, assuming that there will be loading indicators\n          getReferencableModelDataQuery.refetch();\n          model.refetch();\n\n          setLoading(false);\n          router.back();\n        }\n      })\n      .catch((e) => {\n        setLoading(false);\n        setResult(e);\n      });\n  };\n\n  const explainButton = {\n    onClick: () => {\n      setDebug(!debug);\n    },\n    title: \"Explain\",\n    emoji: \"🧐\",\n  };\n\n  const buttons: LabeledButtonType[] = [explainButton];\n\n  // console.log({ referencableModelData });\n  return (\n    <Div>\n      <IndexInstanceContainer\n        buttons={buttons}\n        title={humanCase(modelFromUrl || \"\")}\n      >\n        {simplifiedSchema ? (\n          <Div>\n            <FormContainer onSubmit={onSubmitForm} isLoading={loading}>\n              <SimplifiedSchemaForm\n                modelName={modelName}\n                itemNameOrId={body?.name || body?.id}\n                parameterNameStack={undefined}\n                projectRelativeStorageFilePath={projectRelativeStorageFilePath}\n                id={id}\n                parameters={parameters}\n                values={values}\n                onChange={(values) => setBody(values[0])}\n                referencableModelData={referencableModelData}\n                isDebug={debug}\n              />\n            </FormContainer>\n            <Div className=\"mt-6\">\n              <ClickableIcon emoji=\"❌ Go back\" onClick={() => router.back()} />\n            </Div>\n            {result ? <P>{JSON.stringify(result)}</P> : null}\n            {debug ? (\n              <SimplifiedSchemaFormDebug\n                parameters={parameters}\n                values={values}\n              />\n            ) : null}\n          </Div>\n        ) : null}\n      </IndexInstanceContainer>\n    </Div>\n  );\n}"
  },
  "UpsertPage": {
    "name": "UpsertPage",
    "slug": "TsFunction",
    "id": "xsxjejhayncjbpztsvsvdwbt",
    "description": "",
    "operationName": "db-crud",
    "rawText": " () => {\n  const router = useRouter();\n  const query = mapValuesSync(router.query, (value) => takeFirst(value));\n  const model = useInfiniteGetDbModel();\n  const allItems = model?.data?.pages\n    ?.map((x) => x.result?.data)\n    .flat()\n    .filter(notEmpty) as AugmentedAnyModelType[];\n  const instance = allItems?.find((x) => x.id === query.id);\n  const modelName = useModelFromUrl();\n  const metadataQuery = queries.useGetDbModelMetadata(modelName);\n  const { tsInterface } = destructureOptionalObject(metadataQuery.data?.result);\n  const simplifiedSchema = tsInterface?.type?.simplifiedSchema;\n  const referencableModelNames = getReferencableModels(simplifiedSchema)\n    ?.map((x) => x.interfaceName)\n    .filter(notEmpty);\n\n  return (\n    <Div scroll className=\"py-4 px-8 lg:px-20\">\n      {model.isLoading ? (\n        <FancyLoader />\n      ) : !simplifiedSchema || !modelName ? (\n        <Div>Something's wrong</Div>\n      ) : (\n        <UpsertForm\n          modelName={modelName}\n          simplifiedSchema={simplifiedSchema}\n          instance={instance}\n          referencableModelNames={referencableModelNames}\n        />\n      )}\n    </Div>\n  );\n}"
  },
  "useInfiniteGetDbModel": {
    "name": "useInfiniteGetDbModel",
    "slug": "TsFunction",
    "id": "hayokecmaisjhkfryxpvdqvx",
    "description": "",
    "operationName": "db-crud",
    "rawText": " () => {\n  const modelName = useModelFromUrl();\n\n  const [datasetConfig] = useStore(\"db-crud.datasetConfig\");\n  const [search] = useStore(\"db-crud.search\");\n\n  const dependencies = [\"getDbModel\", modelName, datasetConfig, search];\n\n  const hook = useInfiniteQuery(\n    dependencies,\n    (context) => {\n      const params = context.pageParam as PageParam | undefined;\n\n      const configuration = {\n        ...datasetConfig,\n        startFromIndex:\n          (datasetConfig?.startFromIndex || 0) + (params?.start || 0),\n        maxRows: datasetConfig?.maxRows || params?.limit || defaultLimit,\n      };\n\n      // @ts-ignore\n      const result = getDbModel(modelName!, configuration, search);\n      return result;\n    },\n    {\n      getNextPageParam: (lastPage, allPages) => {\n        const realLimit =\n          lastPage.result?.datasetConfig?.maxRows || defaultLimit;\n        const oldStart = lastPage.result?.datasetConfig?.startFromIndex || 0;\n        const pageParam: PageParam = {\n          start: oldStart + realLimit,\n          limit: realLimit,\n        };\n\n        return pageParam;\n      },\n    }\n  );\n\n  return hook;\n}"
  },
  "useModelFromUrl": {
    "name": "useModelFromUrl",
    "slug": "TsFunction",
    "id": "ddkyrtztrxjstdwmijdksavs",
    "description": "takes the model from the url",
    "operationName": "db-crud",
    "rawText": " () => {\n  const router = useRouter();\n  const paths = router.query.paths ? makeArray(router.query.paths) : [];\n  const modelQuery = paths.pop();\n  return modelQuery;\n}"
  },
  "useUrl": {
    "name": "useUrl",
    "slug": "TsFunction",
    "id": "gievtktkttzhcqpuohmuescx",
    "description": "",
    "operationName": "db-crud",
    "rawText": " <T extends keyof typeof queryStore>(queryKey: T) => {\n  /**\n   * Here you can define your global storages that can be present in any URL\n   *\n   * Make sure you use the CustomUrlConfig type\n   */\n  const queryStore = {\n    path: useCustomUrlStore<string | undefined>(\"path\", { type: \"string\" }),\n    name: useCustomUrlStore<string | undefined>(\"name\", { type: \"string\" }),\n    type: useCustomUrlStore<string | undefined>(\"type\", { type: \"string\" }),\n\n    // for db page\n    slug: useCustomUrlStore<string | undefined>(\"slug\", { type: \"string\" }),\n    id: useCustomUrlStore<string | undefined>(\"id\", { type: \"string\" }),\n  };\n\n  return queryStore[queryKey];\n}"
  },
  "cacheLookup": {
    "name": "cacheLookup",
    "slug": "TsFunction",
    "id": "xzxsrsxmmuyejkvwjhzcmosl",
    "description": "Wrapper function to cache any function and invalidate it, in some way\n\ncaching\nautomatic cache invalidation if data sources are updated\noptimistic caching after cache invalidation",
    "operationName": "db-recipes",
    "rawText": " (\n  functionName: string,\n  parameters: undefined | any[]\n): CacheLookupResult => {\n  // TODO: think of a smart way to look in cache and make sure it works with as many functions as possible with a smart cache invalidation + cleanup strategy\n  return { hasValidCache: false };\n}"
  },
  "calculateOperatingSystemBundle": {
    "name": "calculateOperatingSystemBundle",
    "slug": "TsFunction",
    "id": "yxqgbzwxqztlnohvdsfuporm",
    "description": "This function should calculate a giant bundle for the whole operating system. This should include everything, public.\n\nUsed to show the whole os as a bundle.",
    "operationName": "db-recipes",
    "rawText": " async (\n  manualProjectRoot?: string\n) => {\n  //   const bundleConfig: BundleConfig = {};\n\n  return; //bundleConfig;\n}"
  },
  "deleteDbModel": {
    "name": "deleteDbModel",
    "slug": "TsFunction",
    "id": "klqcpzymhrpopmsssybwcstx",
    "description": "deletes an instance of an db data interface from the db in a typesafe way",
    "operationName": "db-recipes",
    "rawText": " async <KInterface extends DbModelEnum>(\n  interfaceName: KInterface,\n  id: string\n): Promise<DbQueryResult> => {\n  const deleteResult = await db.remove(\n    interfaceName,\n    (content) => content.id === id\n  );\n  return deleteResult;\n}"
  },
  "functions": {
    "name": "functions",
    "slug": "TsVariable",
    "id": "ubteujhusertgplgvhwgozna",
    "description": "",
    "operationName": "function-util"
  },
  "getCachedFunctions": {
    "name": "getCachedFunctions",
    "slug": "TsFunction",
    "id": "ofdgavqxvesxzoxsdlegynjg",
    "description": "TODO: it would probably be good to create a more general purpose caching function",
    "operationName": "db-recipes",
    "rawText": " async () => {\n  if (functions.length) return functions;\n  functions = await db.get(\"TsFunction\");\n  return functions;\n}"
  },
  "getDatabaseMenu": {
    "name": "getDatabaseMenu",
    "slug": "TsFunction",
    "id": "dhmuwnaeprxzgimmdzpumifo",
    "description": "Finds all relevant Db models to show in the menu\n\n- for a bundleId, it gets all models from the bundleSummary\n- for a bundled project (bundled) gets all models from the packages\n- for the main project, gets all models from sdk-db directly\n\nTODO: NB: the first and the second are not the same, so this needs to be cleaned up.",
    "operationName": "db-recipes",
    "rawText": " async (config?: { bundleId?: string }) => {\n  const dbModelNames = await getDbModelNames(config);\n  const databaseMenu: ModelInfo[] = dbModelNames\n    .map((modelKey) => {\n      if (!modelKey) return;\n\n      const modelInfo: ModelInfo = {\n        name: humanCase(modelKey),\n        slug: modelKey,\n        rows: 0,\n      };\n      return modelInfo;\n    })\n    .filter(notEmpty);\n\n  return {\n    menu: databaseMenu,\n  };\n}"
  },
  "getDbModelMetadata": {
    "name": "getDbModelMetadata",
    "slug": "TsFunction",
    "id": "rnkjzftzhiwxzpvxolkqxszy",
    "description": "",
    "operationName": "db-recipes",
    "rawText": " async (\n  modelName: string | undefined\n): Promise<{\n  tsInterface?: TsInterface;\n  datasets?: Dataset[];\n  projectRelativeStorageFilePath?: string;\n}> => {\n  if (!modelName) return {};\n  if (!([...dbModelKeys] as string[]).includes(modelName)) {\n    return {};\n  }\n\n  const realModelName = modelName as DbModelEnum;\n\n  const mergedConfig: MergedQueryConfig = getMergedQueryConfig(realModelName);\n  const projectRelativeStorageFilePath = (\n    await getDatabaseFiles(realModelName, mergedConfig)\n  ).map((x) => x.projectRelativePath)[0];\n\n  const indexPath = sdkInterfacePaths[realModelName];\n  const tsInterface =\n    (await readProjectRelativeJsonFile<TsInterface>(indexPath)) || undefined;\n\n  const allDatasets = await db.get(\"Dataset\");\n  const datasets = allDatasets.filter((x) => x.modelName === realModelName);\n\n  return { tsInterface, datasets, projectRelativeStorageFilePath };\n}"
  },
  "getDbModelNames": {
    "name": "getDbModelNames",
    "slug": "TsFunction",
    "id": "vaxplkbdrqroolijqrjudwbb",
    "description": "",
    "operationName": "db-recipes",
    "rawText": " async (config?: {\n  bundleId?: string;\n}): Promise<(keyof DbModels)[]> => {\n  const bundleId = config?.bundleId;\n  let dbModels: TsInterface[] | undefined = undefined;\n\n  if (bundleId) {\n    const bundleConfig = (await db.get(\"BundleConfig\")).find(\n      (x) => x.id === bundleId\n    );\n\n    if (bundleConfig) {\n      dbModels = await getDbModelsForBundle(bundleConfig);\n    }\n  }\n  const projectRoot = getProjectRoot();\n  if (isBundle(projectRoot) && projectRoot) {\n    const operationNames: string[] = (\n      await exploreOperationFolders({\n        basePath: path.join(projectRoot, \"packages\"),\n      })\n    ).map(getLastFolder);\n\n    dbModels = await getDbModelsFromOperations(operationNames);\n  }\n\n  const dbModelNames = dbModels\n    ? (dbModels?.map((x) => x.name) as (keyof DbModels)[])\n    : [...dbModelKeys];\n\n  return dbModelNames;\n}"
  },
  "getDbModel": {
    "name": "getDbModel",
    "slug": "TsFunction",
    "id": "sfvhexxehajuktuoeixnxbxu",
    "description": "gets all instances of an db data interface from the db in a typesafe way",
    "operationName": "db-recipes",
    "rawText": " async <\n  KInterface extends Extract<keyof DbModels, string>,\n  TDatasetConfig extends DatasetConfig\n>(\n  /**\n   * the interfaceName you want to get\n   */\n  interfaceName: KInterface | null,\n  /**\n   * optionally, provide a configuration\n   */\n  datasetConfig?: TDatasetConfig,\n\n  /**\n   * This search should be done on the deepest JSON value's of the whole thing. The purpose is not limiting the content to user, but rather just a nice user experience where one can quickly search\n   */\n  search?: string\n): Promise<GetDbModelResult<KInterface>> => {\n  if (!interfaceName) {\n    return { data: [], hasMore: false, message: \"No interfaceName posted\" };\n  }\n\n  const data = await db.get(interfaceName);\n\n  // NB: slice the data, if needed\n  const slicedStartData = data.slice(datasetConfig?.startFromIndex);\n\n  const slicedLimitData = datasetConfig?.maxRows\n    ? slicedStartData.slice(0, datasetConfig.maxRows)\n    : slicedStartData;\n\n  const hasMore = slicedLimitData.length < slicedStartData.length;\n\n  // NB: filter the sliced data, if needed\n  const filteredData = datasetConfig?.filter?.length\n    ? datasetConfig?.filter.reduce((filteredData, datasetFilter) => {\n        const newFilteredData: DbModels[KInterface][] = filteredData.filter(\n          (item) => {\n            const key = datasetFilter.objectParameterKey as keyof typeof item;\n\n            const value = item[key];\n\n            if (datasetFilter.operator === \"equal\") {\n              return String(value) === datasetFilter.value;\n            }\n\n            if (datasetFilter.operator === \"notEqual\") {\n              return String(value) === datasetFilter.value;\n            }\n\n            const lowercaseValue = String(value).toLowerCase();\n            const lowercaseDatasetValue = String(\n              datasetFilter.value\n            ).toLowerCase();\n\n            if (datasetFilter.operator === \"endsWith\") {\n              return lowercaseValue.endsWith(lowercaseDatasetValue);\n            }\n            if (datasetFilter.operator === \"startsWith\") {\n              return lowercaseValue.startsWith(lowercaseDatasetValue);\n            }\n\n            if (datasetFilter.operator === \"includes\") {\n              return lowercaseValue.includes(lowercaseDatasetValue);\n            }\n\n            if (datasetFilter.operator === \"includesLetters\") {\n              return hasAllLetters(lowercaseValue, lowercaseDatasetValue);\n            }\n\n            if (\n              datasetFilter.operator === \"greaterThan\" &&\n              datasetFilter.value !== null &&\n              datasetFilter.value !== undefined\n            ) {\n              return Number(value) > Number(datasetFilter.value);\n            }\n\n            if (\n              datasetFilter.operator === \"lessThan\" &&\n              datasetFilter.value !== null &&\n              datasetFilter.value !== undefined\n            ) {\n              return Number(value) < Number(datasetFilter.value);\n            }\n\n            if (\n              datasetFilter.operator === \"greaterThanOrEqual\" &&\n              datasetFilter.value !== null &&\n              datasetFilter.value !== undefined\n            ) {\n              return Number(value) >= Number(datasetFilter.value);\n            }\n\n            if (\n              datasetFilter.operator === \"lessThanOrEqual\" &&\n              datasetFilter.value !== null &&\n              datasetFilter.value !== undefined\n            ) {\n              return Number(value) <= Number(datasetFilter.value);\n            }\n\n            return false;\n          }\n        );\n\n        return newFilteredData;\n      }, slicedLimitData)\n    : slicedLimitData;\n\n  // NB: sort the filtered data, if needed\n\n  const sortedData = datasetConfig?.sort\n    ? datasetConfig.sort.reduce((sortedData, datasetSort) => {\n        const newSortedData: DbModels[KInterface][] = sortedData.sort(\n          (a, b) => {\n            // @ts-ignore\n            const valueA = a[datasetSort.objectParameterKey];\n            // @ts-ignore\n            const valueB = b[datasetSort.objectParameterKey];\n\n            const directionMultiplier =\n              datasetSort.sortDirection === \"ascending\" ? 1 : -1;\n\n            return Number(valueA) < Number(valueB)\n              ? directionMultiplier\n              : directionMultiplier * -1;\n          }\n        );\n\n        return newSortedData;\n      }, filteredData)\n    : filteredData;\n\n  const searchedData =\n    search && search.length > 0\n      ? sortedData.filter((item) => {\n          const searchable = Object.values(item)\n            .map((value) => JSON.stringify(value))\n            .join(\",\")\n            .toLowerCase();\n\n          return searchable.includes(search.toLowerCase());\n        })\n      : sortedData;\n\n  const subsetData = datasetConfig?.objectParameterKeys?.length\n    ? searchedData.map(\n        (item) =>\n          getSubsetFromObject(\n            item,\n            datasetConfig.objectParameterKeys! as readonly (keyof DbModels[KInterface])[]\n          ) as DatasetItem<DbModels[KInterface], TDatasetConfig>\n      )\n    : searchedData;\n\n  const ignoredData = datasetConfig?.ignoreObjectParameterKeys?.length\n    ? subsetData.map((item) => {\n        return removeOptionalKeysFromObjectStrings(\n          item as { [key: string]: any },\n          datasetConfig.ignoreObjectParameterKeys!\n        );\n      })\n    : subsetData;\n\n  const finalData = ignoredData as DbModels[KInterface][];\n\n  return {\n    datasetConfig,\n    data: finalData,\n    hasMore,\n  };\n}"
  },
  "getFunctionIndex": {
    "name": "getFunctionIndex",
    "slug": "TsFunction",
    "id": "ttwolnuhczdpwukqtslukehj",
    "description": "finds function indexation from database\n\nTODO: this should be used!",
    "operationName": "db-recipes",
    "rawText": " async ({\n  functionName,\n}: {\n  functionName: string;\n}): Promise<{ success: boolean; response: string; function?: TsFunction }> => {\n  const cachedFunctions = await getCachedFunctions();\n\n  // get info about this operation\n  const functionIndex = cachedFunctions.find(\n    (fn) => fn.name === camelCase(functionName)\n  );\n\n  if (!functionIndex) {\n    return { success: false, response: \"Couldn't find function\" };\n  }\n\n  return { success: true, function: functionIndex, response: \"Found\" };\n}"
  },
  "getNestedDatabaseMenu": {
    "name": "getNestedDatabaseMenu",
    "slug": "TsFunction",
    "id": "zqjssgfoplbpkwauyhrjyufx",
    "description": "TODO: support search for bundles (but this can be augmented word based)",
    "operationName": "db-recipes",
    "rawText": " async (config?: {\n  noOperationPath?: boolean;\n  noOperationName?: boolean;\n  noSrcRelativeFolder?: boolean;\n  noPrefix?: boolean;\n}): Promise<{ flat?: WebPage[]; nested?: NestedWebPage[] }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return {};\n  const { noOperationPath, noOperationName, noSrcRelativeFolder, noPrefix } =\n    destructureOptionalObject(config);\n  const dbModels = (await db.get(\"TsInterface\")).filter((x) => x.isDbModel);\n\n  const queryPaths = dbModels.map((dbModel) => {\n    const projectRelativeOperationPath =\n      operations[dbModel.operationName as keyof typeof operations];\n\n    const slicedProjectRelativeOperationPath = projectRelativeOperationPath\n      .split(\"/\")\n      // in bundles, we still want to make the distinction between modules and packages, so this is great.\n      .slice(isBundle(projectRoot) ? 0 : 2)\n      .join(\"/\");\n    const operationPart = noOperationName\n      ? \"\"\n      : noOperationPath\n      ? dbModel.operationName + \"/\"\n      : slicedProjectRelativeOperationPath + \"/\";\n\n    const folder = getFolder(\n      dbModel.operationRelativeTypescriptFilePath.slice(\"src/\".length)\n    );\n    const folderPart = noSrcRelativeFolder\n      ? \"\"\n      : folder.length === 0\n      ? \"\"\n      : folder + \"/\";\n\n    const prefixPart = noPrefix ? \"\" : \"db/\";\n    const url = `${prefixPart}${operationPart}${folderPart}${dbModel.name}`;\n\n    return url;\n  });\n\n  const dbPages: WebPage[] = queryPaths.map((queryPath) => {\n    return { queryPath, pageData: null };\n  });\n\n  const upsertPages: WebPage[] = dbModels.map((dbModel) => ({\n    queryPath: `upsert/${dbModel.name}`,\n    pageData: null,\n    isMenuHidden: true,\n  }));\n\n  const flat = dbPages.concat(upsertPages);\n\n  return getMenuPagesObject(flat);\n}"
  },
  "getReferencableModelData": {
    "name": "getReferencableModelData",
    "slug": "TsFunction",
    "id": "jxydmrqcmwtqcykhoqxbfzyj",
    "description": "Get referencableModelData for a single DbModel.\n\nNB: this does not get the items that can be referenced in that model!\n\nFor getting all required `ReferencableModelData` for the prop in `SimplifiedSchemaForm`, use `useGetReferencableModelData`.",
    "operationName": "db-recipes",
    "rawText": " async (dbModelName: keyof DbModels) => {\n  if (!dbModelName) {\n    return [];\n  }\n  const referencableModelData = (await db.get(dbModelName)).map(\n    (item: AugmentedAnyModelType) => ({\n      id: item.id,\n      name: item.name,\n      slug: item.slug,\n      categoryStack: item.categoryStack,\n    })\n  );\n\n  return referencableModelData;\n}"
  },
  "hasDbRecipes": {
    "name": "hasDbRecipes",
    "slug": "TsFunction",
    "id": "zeaidhbdfhatrnwwthdnnusd",
    "description": "Simple function to test whether or not the DbRecipes endpoints are available. If it returns true through the api, the other ones are also available.",
    "operationName": "db-recipes",
    "rawText": " () => true"
  },
  "makeSrcRelativeFolder": {
    "name": "makeSrcRelativeFolder",
    "slug": "TsFunction",
    "id": "pgjqqklbrofdobbdjeuzjaon",
    "description": "gets a src relative folder path (so maybe \"\" for a file `src/util.ts` or \"util\" for a file `src/util/thing.ts`)",
    "operationName": "db-recipes",
    "rawText": " (\n  operationRelativeTypescriptFilePath: string\n): string | undefined => {\n  const srcPrefix = \"src/\";\n  if (!operationRelativeTypescriptFilePath.startsWith(srcPrefix)) return;\n  const withoutSrc = operationRelativeTypescriptFilePath.substring(\n    srcPrefix.length\n  );\n\n  const parts = withoutSrc.split(\"/\");\n\n  parts.pop();\n\n  const withoutFile = parts.join(\"/\");\n\n  if (withoutFile.length === 0) return;\n\n  return withoutFile;\n}"
  },
  "testFnWrapped": {
    "name": "testFnWrapped",
    "slug": "TsVariable",
    "id": "sbqgpayugvxqlijslfufigte",
    "description": "",
    "operationName": "db-recipes"
  },
  "testFn": {
    "name": "testFn",
    "slug": "TsFunction",
    "id": "sqpnygultvzkhabbmuidehsn",
    "description": "",
    "operationName": "db-recipes",
    "rawText": " (a: string) => {\n  return `${a}${a}`;\n}"
  },
  "tsInterfaceToDbMenu": {
    "name": "tsInterfaceToDbMenu",
    "slug": "TsFunction",
    "id": "sgtbhzwhiytalgjfdhsuekix",
    "description": "",
    "operationName": "db-recipes",
    "rawText": " (tsInterface: TsInterface, type: string) => {\n  const srcRelativeFolder = makeSrcRelativeFolder(\n    tsInterface.operationRelativeTypescriptFilePath\n  );\n  if (!tsInterface.operationName) return;\n\n  return {\n    name: tsInterface.name,\n    operationName: tsInterface.operationName,\n    type,\n    srcRelativeFolder,\n  };\n}"
  },
  "upsertDbModel": {
    "name": "upsertDbModel",
    "slug": "TsFunction",
    "id": "nrzsswugmbtrdalplnbtwvtu",
    "description": "upserts an instance of an db data interface from the db in a typesafe way",
    "operationName": "db-recipes",
    "rawText": " async <\n  KInterfaceName extends keyof DbModels,\n  KItem extends DbModels[KInterfaceName]\n>(\n  interfaceName: KInterfaceName,\n  data: KItem | KItem[],\n  /**\n   * NOT USED\n   */\n  isNew?: boolean\n): Promise<DbQueryResult> => {\n  if (!data || (Array.isArray(data) && data.length === 0)) {\n    return { isSuccesful: false, message: \"Please provide some data\" };\n  }\n\n  // use the first item to get the operationName, sometimes needed for storing in the right location\n  const item = Array.isArray(data) ? data[0] : data;\n  const { operationName } = item;\n\n  /**\n  \n  Assets need to be placed: \n\n  1) find all assets in data\n\n  2) for every parameter that adheres to asset naming convention, call `processAsset`\n\n  */\n\n  const config: CustomQueryConfig = { operationName };\n\n  const realData = (await Promise.all(\n    makeArray(data).map((item) => {\n      return processItemAssets(item, interfaceName, operationName, config);\n    })\n  )) as KItem[];\n\n  // console.dir({ realData }, { depth: 999 });\n  // return { message: \"test\" };\n  //@ts-ignore\n  const upsertResult = await db.upsert(interfaceName, realData, config);\n\n  return upsertResult;\n}"
  },
  "validateInput": {
    "name": "validateInput",
    "slug": "TsFunction",
    "id": "yjzpjazcqqoqifdgjiagqvnw",
    "description": "wrapper function that takes that data but also the interface of the function and validates the parameters before it executes the function.",
    "operationName": "db-recipes",
    "rawText": " <TFunctionName extends keyof typeof sdk>(\n  functionName: TFunctionName,\n  parameters: undefined | any[],\n  tsFunction: TsFunction\n): ValidationResult => {\n  const invalidParameters =\n    tsFunction.parameters\n      ?.map((parameter, index) => {\n        if (!parameter.schema) return;\n\n        // NB: we have a problem now because of the references missing. Recursively including all references every time can be hard though, that is another indexation step probably... May also become quite slow given the side of these schemas. We can either try and create a mapped validation object that includes the schemas for every function or we can try to use typescript-json instead, that may be easier, and better since we already need that for the backend as well. The last option would be to validate it ourselves using our own SimplifiedSchema. A validator for that would be useful anyway because it can also be used at the frontend with SimplifiedSchemaForm.\n        // const validate = ajv.compile(parameter.schema);\n        // const isValid = validate(value);\n\n        const value = parameters?.[index];\n\n        const isValid = true;\n        if (isValid) return;\n\n        return { isValid, parameter, value };\n      })\n      .filter(notEmpty) || [];\n\n  const isValid = invalidParameters.length === 0;\n  if (!isValid) {\n    log(\n      `According to the schema, you have given invalid arguments to the function`,\n      { type: \"warning\" }\n    );\n    console.dir({ invalidParameters }, { depth: 99 });\n  }\n\n  return { isValid };\n}"
  },
  "validateResult": {
    "name": "validateResult",
    "slug": "TsFunction",
    "id": "qqlqzenatkekmplhuewbcwcl",
    "description": "wrapper function that takes that data but also the interface of the function and validates the parameters before it executes the function.",
    "operationName": "db-recipes",
    "rawText": " <TFunctionName extends keyof typeof sdk>(\n  functionName: TFunctionName,\n  result: any,\n  tsFunction: TsFunction\n): ValidationResult => {\n  const fn = sdk[functionName];\n\n  type ResultType = ReturnType<typeof fn>;\n  /**\n   * NB: https://www.npmjs.com/package/typescript-json\n   *\n   * this seems a great way to validate the return type, not sure what it would do to my compile times and runtime performance and if it works at all, but if it works, it'd be great because we basically create 100% typesafety, not only for the input, but also for the output!\n   */\n  // const isValid = TSON.equal<ResultType>(result)\n\n  const schema = tsFunction.returnType.typeDefinition;\n\n  if (!schema) {\n    log(`Not able to validate ${functionName} result`, { type: \"debug\" });\n    return { isValid: true };\n  }\n\n  //const validate = ajv.compile(schema);\n\n  const isValid = true; //validate(result);\n\n  if (!isValid) {\n    log(\n      `According to the schema, you have given invalid arguments to the function`,\n      { type: \"warning\" }\n    );\n  }\n\n  return { isValid };\n}"
  },
  "wrapFunction": {
    "name": "wrapFunction",
    "slug": "TsFunction",
    "id": "jdcgkfkzcurepkoelwlvxild",
    "description": "",
    "operationName": "db-recipes",
    "rawText": " <TFunc extends (...parameters: any[]) => any>(\n  originalFunction: TFunc\n) => {\n  const wrappedFunction = (\n    ...parameters: Parameters<TFunc>\n  ): ReturnType<TFunc> => {\n    /**\ndo other stuff, both with await and without awaiting\n\n- logging io + cache lookup (@pure tag)\n- logging performance\n- logging errors\n- input validation\n- output validation\n- tracking usage quantity, checking if there is still permission for execution based on credit balance\n*/\n    console.log(\"I'm wrapping this function\", originalFunction.name);\n    return originalFunction(...parameters);\n  };\n\n  return wrappedFunction;\n}"
  },
  "filterInterfacesFromOperationNames": {
    "name": "filterInterfacesFromOperationNames",
    "slug": "TsFunction",
    "id": "gzhdxiupgmzinlzfshyqyxsz",
    "description": "",
    "operationName": "db-util",
    "rawText": " (\n  tsInterface: TsInterface,\n  operationNames?: string[]\n) => {\n  return (\n    !operationNames ||\n    (tsInterface.operationName &&\n      operationNames.includes(tsInterface.operationName))\n  );\n}"
  },
  "getDbModelsFromOperations": {
    "name": "getDbModelsFromOperations",
    "slug": "TsFunction",
    "id": "rgtqwttabhaxcztjmlkoywsb",
    "description": "",
    "operationName": "db-util",
    "rawText": " async (\n  operationNames: string[]\n): Promise<TsInterface[]> => {\n  const dbModels = (await db.get(\"TsInterface\"))\n    .filter((x) => x.isDbModel)\n    .filter(onlyUnique2<TsInterface>((a, b) => a.name === b.name))\n    .filter((tsInterface) =>\n      filterInterfacesFromOperationNames(tsInterface, operationNames)\n    )\n    .filter(onlyUnique2<TsInterface>((a, b) => a.name === b.name));\n\n  return dbModels;\n}"
  },
  "availableExtensions": {
    "name": "availableExtensions",
    "slug": "TsVariable",
    "id": "ztxcjfvttkhnksmzulkqwond",
    "description": "",
    "operationName": "docs-get-pages"
  },
  "docsGetPages": {
    "name": "docsGetPages",
    "slug": "TsFunction",
    "id": "riyhaitshffpbonretihkwpd",
    "description": "",
    "operationName": "docs-get-pages",
    "rawText": " async (\n  basePaths: { projectRelativeBasePath: string; queryPath: string }[]\n) => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return [];\n  }\n\n  const realProjectRelativeBasePaths = isBundle()\n    ? [\"docs\"]\n    : basePaths.map((x) => x.projectRelativeBasePath);\n\n  const absoluteBasePaths = realProjectRelativeBasePaths.map((x) =>\n    path.join(projectRoot, x)\n  );\n\n  const flat =\n    (await getMarkdownReaderPages({\n      projectRoot,\n      basePaths: absoluteBasePaths,\n      mapQueryPath: (queryPath) => {\n        const found = realProjectRelativeBasePaths.find((x) =>\n          queryPath.startsWith(x)\n        );\n        if (!found) {\n          return queryPath;\n        }\n        const prefix = basePaths.find(\n          (x) => x.projectRelativeBasePath === found\n        );\n\n        if (!prefix) {\n          return queryPath;\n        }\n\n        const newQueryPath = queryPath.replace(\n          prefix.projectRelativeBasePath,\n          prefix.queryPath\n        );\n\n        return newQueryPath;\n      },\n    })) || [];\n\n  return flat;\n}"
  },
  "getMarkdownReaderPages": {
    "name": "getMarkdownReaderPages",
    "slug": "TsFunction",
    "id": "mhoypauljhmbqtbtluhesqcq",
    "description": "Gets all markdownreader pages for multiple basePaths. Can add a prefix, can also remove the last folder of basePath from the suffix.",
    "operationName": "docs-get-pages",
    "rawText": " async (config: {\n  projectRoot: string;\n  /**\n   * basePaths to search for public markdown for\n   */\n  basePaths: string[];\n\n  /**\n   * If given, uses a basePath relative queryPath and prefixes this before it.\n   *\n   * if there's a prefix, don't use the basePath as prefix, but use that prefix instead.\n   *\n   * Should end with slash (/) in order for it to be folder\n   */\n  queryPathCustomPrefix?: (basePath?: string) => string | undefined;\n  /**\n   * if set, maps query path further\n   */\n  mapQueryPath?: (\n    /**\n     * already mapped the relative path to remove extension and numbers from folders\n     */\n    queryPath: string\n  ) => string;\n}): Promise<ReaderWebPage[]> => {\n  const { basePaths, projectRoot, mapQueryPath } = config;\n  const markdownReaderPages: ReaderWebPage[] = (\n    await Promise.all(\n      basePaths.map(async (basePath) => {\n        const publicMarkdownFileAbsolutePaths =\n          await getPublicMarkdownFilePaths(basePath, false);\n\n        const markdownReaderPages = publicMarkdownFileAbsolutePaths.map((x) => {\n          const filePath = makeRelative(x.path, projectRoot);\n          const pathWithoutReadme = stripReadmeFromFolder(filePath);\n          const pathWithoutExtensions =\n            removeExtensionsFromPath(pathWithoutReadme);\n\n          const mappedQueryPath = mapQueryPath\n            ? mapQueryPath(pathWithoutExtensions)\n            : pathWithoutExtensions;\n\n          const customQueryPrefix = config.queryPathCustomPrefix\n            ? config.queryPathCustomPrefix(basePath)\n            : undefined;\n\n          const relativeBasePath = makeRelative(basePath, projectRoot);\n\n          // console.log({ mappedQueryPath, relativeBasePath });\n          const queryPath = customQueryPrefix\n            ? customQueryPrefix + mappedQueryPath.replace(relativeBasePath, \"\")\n            : mappedQueryPath;\n\n          // NB: folders are no menu items because menu is built from queryPaths recursively\n          const readerWebPage: ReaderWebPage = {\n            queryPath,\n            pageData: { projectRelativeFilePath: filePath },\n            isMenuHidden: x.isFolder,\n          };\n\n          return readerWebPage;\n        });\n\n        return markdownReaderPages;\n      })\n    )\n  ).flat();\n\n  return markdownReaderPages;\n}"
  },
  "getPublicMarkdownFilePaths": {
    "name": "getPublicMarkdownFilePaths",
    "slug": "TsFunction",
    "id": "psajcdrunwpwlirrysxbcwkr",
    "description": "Returns all absolute markdown file paths within a basePath which are not drafts and which are not marked private (through frontmatter)\n\nReadme is put on top!",
    "operationName": "docs-get-pages",
    "rawText": " async (\n  baseFolderPath: string,\n  includeFoldersWithResults?: boolean\n) => {\n  const publicMarkdownFilePaths: { path: string; isFolder: boolean }[] = (\n    await explore({\n      basePath: baseFolderPath,\n      extension: \"md\",\n      readmeOnTop: true,\n      includeFoldersWithResults,\n    })\n  )\n    .filter((x) => {\n      if (x.isFolder) return true;\n\n      // NB: we have a file\n      const markdownString = fs.readFileSync(x.path, \"utf8\");\n      const { parameters } = parseFrontmatterMarkdownString(markdownString);\n      if (!shouldExposeMarkdownFile(parameters)) {\n        return false;\n      }\n      return true;\n    })\n    .map(({ path, isFolder }) => ({ path, isFolder }));\n\n  return publicMarkdownFilePaths;\n}"
  },
  "removeExtensionsFromPath": {
    "name": "removeExtensionsFromPath",
    "slug": "TsFunction",
    "id": "trzokihllkczntttgdjxzosk",
    "description": "- Removes numbers from file or foldernames in a path.\n- Removes extension of files\n- Returns the new path without numbers and without extension\n\nWorks for files and folders",
    "operationName": "docs-get-pages",
    "rawText": " (\n  /**\n   * should also work for filenames\n   */\n  relativePath: string\n): string => {\n  const chunks = trimSlashes(relativePath).split(\"/\");\n\n  const chunksWithoutNumbers = chunks.map(removeNumberPrefix);\n\n  // could be file\n  const lastChunkIndex = chunksWithoutNumbers.length - 1;\n\n  const lastChunk = chunksWithoutNumbers[lastChunkIndex];\n  const parts = lastChunk.split(\".\");\n  const lastPart = parts[parts.length - 1];\n\n  if (availableExtensions.includes(lastPart)) {\n    // remove extension\n    parts.pop();\n    chunksWithoutNumbers[lastChunkIndex] = parts.join(\".\");\n  }\n\n  const simplifiedPath = chunksWithoutNumbers.join(\"/\");\n\n  return simplifiedPath;\n}"
  },
  "removeNumberPrefix": {
    "name": "removeNumberPrefix",
    "slug": "TsFunction",
    "id": "gfkqqiulptmklacihpebytrj",
    "description": "removes number prefixes from a file or folder name. Does not remove extension\n\ndefaults to untitled if the file or folder has no name after removing numbers.",
    "operationName": "docs-get-pages",
    "rawText": " (fileOrFolderName: string): string => {\n  const parts = fileOrFolderName.split(\".\");\n\n  const newName = parts.reduce((restName, part, currentIndex, array) => {\n    if (restName) return restName;\n    const isTextPart = isNaN(Number(part));\n\n    if (isTextPart) {\n      // NB: everything after here is supposed to be part of the text\n      const restName = array.slice(currentIndex).join(\".\");\n      return restName;\n    }\n  }, undefined as string | undefined);\n\n  return newName || \"untitled\";\n}"
  },
  "shouldExposeMarkdownFile": {
    "name": "shouldExposeMarkdownFile",
    "slug": "TsFunction",
    "id": "bgtaezavttfmggfkfqmneoqh",
    "description": "markdown file should only be exposed if it doesn't say `privacy: private` or `isDraft: true` in your frontmatter.",
    "operationName": "docs-get-pages",
    "rawText": " (parameters: Frontmatter) => {\n  return !Boolean(parameters.isDraft) && parameters.privacy !== \"private\";\n}"
  },
  "stripReadmeFromFolder": {
    "name": "stripReadmeFromFolder",
    "slug": "TsFunction",
    "id": "fkxmkwuvsmvsehgvbfybosnq",
    "description": "To get the queryPath, we need to strip the README.md so we get the folder as URL instead of the attached README.md",
    "operationName": "docs-get-pages",
    "rawText": " (filePath: string): string => {\n  const suffix = \"/readme.md\";\n\n  if (filePath.toLowerCase().endsWith(suffix)) {\n    const strippedPath = filePath.slice(0, filePath.length - suffix.length);\n\n    return strippedPath;\n  }\n\n  return filePath;\n}"
  },
  "comparePassword": {
    "name": "comparePassword",
    "slug": "TsFunction",
    "id": "umcpurkvszkqfmmcfdtvntjk",
    "description": "Method to check if a raw password should be the same as the encrypted variant. Uses `bcrypt`",
    "operationName": "encrypt-password",
    "rawText": " (\n  rawPassword: string,\n  encryptedPassword: string\n): boolean => {\n  return compareSync(rawPassword, encryptedPassword);\n}"
  },
  "encryptPassword": {
    "name": "encryptPassword",
    "slug": "TsFunction",
    "id": "xvnphjnbjobtizsnvujykcuu",
    "description": "Method to encrypt any password. Uses `bcrypt`",
    "operationName": "encrypt-password",
    "rawText": " (rawPassword: string): string => {\n  return hashSync(rawPassword, 10);\n}"
  },
  "exploreOperation": {
    "name": "exploreOperation",
    "slug": "TsFunction",
    "id": "mflmfkglrvoxiflwwxmsusjm",
    "description": "for every package.json it finds, it explores the root, src, and docs.\n- in src, index is ignored\n- in docs, only md is found\n- in the root, only md is found\n- for every file in src, it shows and finds all functions, interfaces and variables, through the indexation from it",
    "operationName": "explore-project",
    "rawText": " async (operationBasePath: string) => {\n  const srcPath = path.join(operationBasePath, \"src\");\n  const docsPath = path.join(operationBasePath, \"docs\");\n\n  const rootExploreResults = await explore({\n    basePath: operationBasePath,\n    ignore: \".DS_Store\",\n    doNotExploreChildFolders: true,\n    extension: [\"md\", \"mdx\"],\n  });\n\n  const docsExploreResults = await explore({\n    basePath: docsPath,\n    ignore: \".DS_Store\",\n    extension: [\"md\", \"mdx\"],\n    includeFoldersWithResults: true,\n  });\n\n  const docsExploreResultsWithBasePath =\n    docsExploreResults.length > 0\n      ? docsExploreResults.concat([{ path: docsPath, isFolder: true }])\n      : [];\n\n  const srcExploreResults = (\n    await explore({\n      basePath: srcPath,\n      ignore: \".DS_Store\",\n      extension: [\"ts\", \"tsx\"],\n      includeFoldersWithResults: true,\n    })\n  )\n    // NB: filter out index files, they're not interesting for this usecase\n    .filter((x) => !x.path.includes(\"/src/index.ts\"));\n\n  const srcExploreResultsWithBasePath =\n    srcExploreResults.length > 0\n      ? srcExploreResults.concat([{ path: srcPath, isFolder: true }])\n      : [];\n\n  return rootExploreResults\n    .concat(docsExploreResultsWithBasePath)\n    .concat(srcExploreResultsWithBasePath);\n}"
  },
  "exploreProject": {
    "name": "exploreProject",
    "slug": "TsFunction",
    "id": "xvyaoyzzsqajnvgjebktbcoy",
    "description": "TODO: still needs to be cleaned up. It's a huge function now with many useful components. Split it up!\n\n- explores all files and folders until it finds a package.json.\n\nall items in the explore tree are clickable in the ui, and lead to different pages\n-  a folder leads to a summary of what the folder holds\n-  a operation leads to a summary of the operation\n-  a ts file leads to all functions, variables, and interfaces in that file\n-  a function, variable, or interface leads to specific pages for those things. the data, if available, is attached to the interfaces.\n- a md file leads to the editing user interface (with context) of that file\n- a json file leads to a CRUD for it...\n\n## Performance\nIn the end the data it generates should stay up to date, so it's important this exploration happens fast enough. The data involved is simply walking the filesystem once (a small subset of it) and opening some index files (fun)\n\n## Ideas for later\nLATER: some more things that would be useful:\n\n- watching all files that are also explored for changes using some watcher\n- if something changes, recalculating that part and pushing it to the UI, making the thing going over the line small so it'll be super fast, even over slow internet.\n\nhowever, this is premature optimisation. on my m1, locally, it's probably fine to just recalculate every second ^^ and send a couple megabytes over the line.",
    "operationName": "explore-project",
    "rawText": " async (config?: {\n  bundleId?: string;\n}): Promise<FolderExploration[] | undefined> => {\n  const bundleId = config?.bundleId;\n  let bundleSummary: BundleSummary | undefined = undefined;\n\n  if (bundleId) {\n    const bundle = (await db.get(\"BundleConfig\")).find(\n      (x) => x.id === bundleId\n    );\n\n    if (bundle) {\n      bundleSummary = getBundleSummary(bundle);\n    }\n  }\n\n  const operationPaths = getPathsWithOperations();\n  const textPath = getRootPath(\"text\");\n  const projectRoot = getProjectRoot();\n  if (!operationPaths || !textPath || !projectRoot) return;\n  /**\n   * STEP 1: finds all folders and files unto (and including) the operation level\n   */\n  const foldersWithMarkdownAndOperationsExplore = await explore({\n    basePath: operationPaths.concat(textPath),\n    includeFoldersWithResults: true,\n    ignore: [\n      \"node_modules\",\n      \".git\",\n      databaseFolderName,\n      \".gitignore\",\n      \".DS_Store\",\n    ],\n    // extension: [\"md\",\"mdx\"]\n    cancelRecursionOn: pathArrayIsOperation,\n  });\n\n  /**\n   * STEP 2: explore all paths to include the files of operations\n   */\n  const exploreArrayPromises = foldersWithMarkdownAndOperationsExplore.map(\n    async (exploreResult) => {\n      // NB: Here I am looking if the operationName is in the bundle summary. If there's a bundle summary and this is not the case, the operation should not be explored\n      const operationName = getLastFolder(exploreResult.path);\n      const shouldIncludeOperation = !bundleSummary\n        ? true\n        : bundleSummary.packageNames.includes(operationName);\n\n      const exploreResultArray = exploreResult.isCancelRecursionResult\n        ? shouldIncludeOperation\n          ? await exploreOperation(exploreResult.path)\n          : []\n        : [exploreResult];\n\n      return exploreResultArray;\n    }\n  );\n  const resultPaths = (await Promise.all(exploreArrayPromises))\n    .flat()\n    .map((x) => x.path);\n\n  /**\n   * STEP 3: get all data of all files\n   */\n  const indexData = {\n    functions: await db.get(\"TsFunction\"),\n    variables: await db.get(\"TsVariable\"),\n    interfaces: await db.get(\"TsInterface\"),\n    // comments: await db.get(\"TsComment\"),\n    // \"build-errors\": await db.get(\"TsBuildError\"),\n  };\n\n  const operationFolders: string[] = await exploreOperationFolders({\n    basePath: getPathsWithOperations(),\n  });\n\n  const fullIndexation = resultPaths\n    .map((absolutePath): FolderExploration | null => {\n      const relativeProjectPath = absolutePath.substring(projectRoot.length);\n      // extension like .ts or empty string if there's no extensnion (also for folders)\n      const name = path.parse(absolutePath).name;\n      const type = getExplorationType(absolutePath, operationFolders);\n\n      // Not typescript\n      if (type !== \"typescript\") {\n        // name of folder, operation, operationFolder, or md file\n        // NB: shouldn't happen\n        if (!type) return null;\n        // NB: we are filling in the children in a later step\n        return { name, relativeProjectPath, type, children: undefined };\n      }\n\n      // Typescript\n\n      const typescriptFileChildren = (\n        Object.keys(indexData) as (keyof typeof indexData)[]\n      )\n        .map((indexInstanceName): FolderExploration[] => {\n          const all = indexData[indexInstanceName];\n          const indexNames = getInstanceNames(all, relativeProjectPath);\n          const type =\n            indexInstanceName === \"functions\"\n              ? \"function\"\n              : indexInstanceName === \"interfaces\"\n              ? \"interface\"\n              : \"variable\";\n\n          const instanceChildren: FolderExploration[] = indexNames.map(\n            (name) => ({ name, relativeProjectPath, type })\n          );\n\n          return instanceChildren;\n        })\n        .flat();\n\n      return {\n        name,\n        relativeProjectPath,\n        type,\n        children: typescriptFileChildren,\n      };\n    })\n    .flat()\n    .filter(notEmpty);\n\n  //\n  const oppositeSortedFullIndexation = fullIndexation\n    // sort alphabetically on relativeProjectPath\n    .sort((a, b) => {\n      if (a.relativeProjectPath < b.relativeProjectPath) return -1;\n      if (a.relativeProjectPath > b.relativeProjectPath) return 1;\n      return 0;\n    })\n    // reverse the result so it's in opposite alphabetical order\n    .reverse();\n\n  // NB: copy because we want to test stuff first\n  const copyForNested = [...oppositeSortedFullIndexation];\n  const nestedExploration = copyForNested\n    .reduce((all, folderExploration, currentIndex) => {\n      const parsedPath = path.parse(\n        path.join(projectRoot, folderExploration.relativeProjectPath)\n      );\n\n      /** the parent folder of a folder, or the folder of a path */\n      const baseFolder =\n        parsedPath.base.length > 0\n          ? parsedPath.dir\n          : path.join(parsedPath.dir, \"..\");\n      const relativeBaseFolder = baseFolder.substring(projectRoot.length);\n\n      // console.log({\n      //   relativeBaseFolder,\n      //   relativeProjectPath: folderExploration.relativeProjectPath,\n      // });\n      const baseIndex = all.findIndex(\n        (x) => x?.relativeProjectPath === relativeBaseFolder\n      );\n\n      // there is no parent found for this one\n      if (baseIndex === -1) {\n        return all;\n      }\n\n      // we found a parent on all[baseIndex]. Lets put folderExploration in the children of that one, and remove it from the full indexation\n\n      all[baseIndex] = {\n        ...all[baseIndex],\n        children: all[baseIndex].children\n          ? all[baseIndex].children?.concat(folderExploration)\n          : [folderExploration],\n      };\n\n      delete all[currentIndex];\n\n      return all;\n    }, copyForNested as FolderExploration[])\n    // the deleted keys can now be removed\n    .filter(notEmpty);\n\n  // console.dir(\n  //   oppositeSortedFullIndexation.map((x) => x.relativeProjectPath),\n  //   { depth: 999, maxArrayLength: 9999 }\n  // );\n\n  return nestedExploration;\n}"
  },
  "getExplorationType": {
    "name": "getExplorationType",
    "slug": "TsFunction",
    "id": "yuzibjtdxgfzubozlxnztqrz",
    "description": "gets the exploration type from an absolute type",
    "operationName": "explore-project",
    "rawText": " (\n  absolutePath: string,\n  operationFolders: string[]\n): FolderExploration[\"type\"] | undefined => {\n  const parsedPath = path.parse(absolutePath);\n  if ([\".ts\", \".tsx\"].includes(parsedPath.ext)) {\n    return \"typescript\";\n  }\n  if ([\".md\", \".mdx\"].includes(parsedPath.ext)) {\n    return \"markdown\";\n  }\n\n  if (parsedPath.ext.length > 0) {\n    // NB: based on where this function is used, this should never happen\n    return undefined;\n  }\n\n  if (operationFolders.includes(absolutePath)) {\n    return \"operation\";\n  }\n  if (operationFolders.find((x) => absolutePath.startsWith(x))) {\n    return \"operationFolder\";\n  }\n  return \"folder\";\n}"
  },
  "getFileWithExtension": {
    "name": "getFileWithExtension",
    "slug": "TsFunction",
    "id": "ghssvswqocdfxduoneatczyl",
    "description": "",
    "operationName": "explore-project",
    "rawText": " (absolutePath: string) => {\n  return path.parse(absolutePath).base;\n}"
  },
  "getFolderExplorationDetails": {
    "name": "getFolderExplorationDetails",
    "slug": "TsFunction",
    "id": "lqvraazbyfawneujgrakgrph",
    "description": "",
    "operationName": "explore-project",
    "rawText": " async (\n  config: {\n    /**relative project path*/\n    path: string;\n    type: FolderExploration[\"type\"];\n    name: string;\n    sort?: string;\n    /**\n     * null gives all of them, undefined gives none\n     */\n    typeIndexType?: keyof IndexModels | null;\n  } & IndexFilter\n): Promise<ExplorationDetails> => {\n  const {\n    name,\n    path,\n    type,\n    hasCommentTypes,\n    interfaceIsDbModel,\n    sort,\n    typeIndexType,\n  } = config;\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    console.log(\"getFolderExplorationDetails: Projectroot not found\");\n    process.exit(1);\n  }\n  const absolutePath = nodePath.join(projectRoot, path);\n  const operationBasePath = findOperationBasePath(absolutePath);\n\n  const operationFolderName = operationBasePath\n    ? getLastFolder(operationBasePath)\n    : undefined;\n\n  const folderExplorationInterface = (\n    await db.get(\"TsInterface\", {\n      operationName: \"code-types\",\n    })\n  ).filter(\n    (x) => x.operationRelativeTypescriptFilePath === \"src/FolderExploration.ts\"\n  );\n\n  const isFileOrFolderType = [\n    \"folder\",\n    \"operation\",\n    \"operationFolder\",\n    \"typescript\",\n  ].includes(type);\n\n  const pathMetaData = isFileOrFolderType\n    ? await calculatePathMetaData(absolutePath)\n    : undefined;\n\n  const needsFilePath =\n    !!operationFolderName && absolutePath !== operationBasePath;\n\n  // console.log({\n  //   needsFilePath,\n  //   operationFolderName,\n  //   absolutePath,\n  //   operationBasePath,\n  //   typeIndexType,\n  //   isFileOrFolderType,\n  // });\n  const typescriptIndex =\n    isFileOrFolderType && typeIndexType !== undefined\n      ? await getFolderTypescriptIndex({\n          filePath: needsFilePath ? absolutePath : undefined,\n          basePath: !needsFilePath ? absolutePath : undefined,\n          filter: { hasCommentTypes, interfaceIsDbModel },\n          sort,\n          type: typeIndexType,\n        })\n      : null;\n\n  //   const srcPath = nodePath.join(operationBasePath, \"src\");\n  //   const operationRelativeTypescriptFilePath = absolutePath.substring(srcPath.length + 1);\n\n  if (type === \"folder\") {\n    return {\n      index: folderExplorationInterface,\n      ...typescriptIndex,\n      pathMetaData,\n    };\n  } else if (type === \"operationFolder\") {\n    return {\n      index: folderExplorationInterface,\n      ...typescriptIndex,\n      pathMetaData,\n    };\n  } else if (type === \"operation\" && operationBasePath) {\n    return {\n      index: folderExplorationInterface,\n      ...typescriptIndex,\n      pathMetaData,\n    };\n  } else if (type === \"markdown\") {\n    // markdown parse\n    const markdownPath = nodePath.join(projectRoot, path);\n    const markdown = await readMarkdownFile(markdownPath);\n    return {\n      index: folderExplorationInterface,\n      markdown: markdown || undefined,\n      success: !!markdown,\n      response: markdown ? undefined : \"reading markdown file failed\",\n    };\n  } else if (type === \"typescript\") {\n    const details = typescriptIndex || {\n      success: false,\n      response: \"reading typescript file failed\",\n    };\n\n    return { ...details, index: folderExplorationInterface, pathMetaData };\n    // all functions, interfaces, variables, lint-errors, build-errors, comments, file meta data (should become PathMetaData, better refactor immediately)\n  } else if (type === \"function\") {\n    // one function with name [name]\n    // TODO: figure out how to do with specific file\n    const tsFunction = (\n      await db.get(\"TsFunction\", { operationName: operationFolderName })\n    ).find((x) => x.name === name);\n    return {\n      tsFunctions: tsFunction ? [tsFunction] : undefined,\n      index: folderExplorationInterface,\n    };\n  } else if (type === \"interface\") {\n    // one interface with name [name]\n    const tsInterface = (\n      await db.get(\"TsInterface\", { operationName: operationFolderName })\n    ).find((x) => x.name === name);\n    return {\n      tsInterfaces: tsInterface ? [tsInterface] : undefined,\n      index: folderExplorationInterface,\n    };\n    // if it's a db-model, also the data that is found...? or maybe this should just be a separate endpoint and page where it's linke to\n  } else if (type === \"variable\") {\n    // one variable with name [name]\n    const tsVariable = (\n      await db.get(\"TsVariable\", { operationName: operationFolderName })\n    ).find((x) => x.name === name);\n    return {\n      tsVariables: tsVariable ? [tsVariable] : undefined,\n      index: folderExplorationInterface,\n    };\n  }\n\n  // Should never happen if all ifs  return....\n  return {\n    index: folderExplorationInterface,\n    success: false,\n    response: `getFolderExplorationDetails: Couldn't understand your input: ${JSON.stringify(\n      {\n        path,\n        type,\n        name,\n      }\n    )}`,\n  };\n}"
  },
  "getFrontmattersMappedObject": {
    "name": "getFrontmattersMappedObject",
    "slug": "TsFunction",
    "id": "quamydlkkjzwzcmuizlkaqhy",
    "description": "",
    "operationName": "explore-project",
    "rawText": " async (\n  projectRoot: string,\n  markdownPaths?: string[]\n) => {\n  const frontmatterPromises = markdownPaths?.map(async (markdownPath) => {\n    const absoluteFilePath = path.join(projectRoot, markdownPath);\n    const frontmatter = (await readMarkdownFile(absoluteFilePath))?.parameters;\n    return { [markdownPath]: frontmatter };\n  });\n  const frontmattersArray = frontmatterPromises\n    ? await Promise.all(frontmatterPromises)\n    : [];\n  const frontmattersMappedObject = mergeObjectsArray(frontmattersArray);\n\n  return frontmattersMappedObject;\n}"
  },
  "getInstanceNames": {
    "name": "getInstanceNames",
    "slug": "TsFunction",
    "id": "ngvnzvoaduecxsdnifdsksgy",
    "description": "returns the paths of instances in a file, like functions, variables or interfaces",
    "operationName": "explore-project",
    "rawText": " (\n  array: any[],\n  // NB: I tried with  <T extends TsIndexModelType> but didn't work with a map over an object... strange...\n  relativePathFromProjectRoot: string\n): string[] => {\n  const instances = array.filter(\n    hasSameProjectPath(relativePathFromProjectRoot)\n  );\n\n  const instancePaths = instances.map((x) => x.name);\n  return instancePaths;\n}"
  },
  "getProjectRelativePaths": {
    "name": "getProjectRelativePaths",
    "slug": "TsFunction",
    "id": "ndekbabjruklnfokvvzxgfrd",
    "description": "get file paths within your project",
    "operationName": "explore-project",
    "rawText": " async (\n  // functionContext: FunctionContext,\n  config?: {\n    /**\n     * Optionally filter the results to only:\n     *\n     * - todo: all todos in your project operations\n     * - postable: all your postables in your database\n     *\n     * by default, scans all relevant files...\n     */\n    type?: RelativePathType;\n    earliestUpdatedAt?: number;\n    /**\n     * Not implemented\n     */\n    filterDraft?: boolean;\n    /**\n     * Not implemented\n     */\n    filterPrivate?: boolean;\n    filterGenerated?: boolean;\n    sort?: \"recent\";\n  }\n): Promise<string[] | undefined> => {\n  const {\n    earliestUpdatedAt,\n    filterDraft,\n    filterGenerated,\n    filterPrivate,\n    type,\n    sort,\n  } = destructureOptionalObject(config);\n\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n  const operationsPath = getRootPath(\"operations\");\n  if (!operationsPath) return;\n  const databasePath = getRootPath(databaseFolderName);\n  if (!databasePath) return;\n  const textPath = getRootPath(\"text\");\n  if (!textPath) return;\n\n  const basePath =\n    type === \"todo\"\n      ? await findAllTodoFolderPaths(operationsPath)\n      : [operationsPath, textPath];\n\n  const shouldFilterRecency = earliestUpdatedAt !== undefined;\n  /*\n  everything from projectRoot, except for: `db`, `node_modules`, `build`\n  */\n\n  const results = await explore({\n    basePath,\n    includeStats: shouldFilterRecency || sort === \"recent\",\n    extension: [\"md\", \"ts\", \"tsx\"],\n    ignore: [databaseFolderName, ...generatedFolders],\n  });\n\n  const filtered = results.filter((result) => {\n    if (!shouldFilterRecency) return true;\n\n    const updatedAt = result.stats?.updatedAt;\n\n    // shouldn't happen\n    if (!updatedAt) return false;\n\n    const isRecentEnough = earliestUpdatedAt < updatedAt;\n\n    return isRecentEnough;\n  });\n\n  const sorted =\n    sort === \"recent\"\n      ? filtered.sort((a, b) => {\n          if (a.stats!.createdAt < b.stats!.createdAt) {\n            return 1;\n          }\n\n          return -1;\n        })\n      : filtered;\n\n  const projectRelativePaths = sorted\n    .map((result) => result.path)\n    .map((absolutePath) => makeRelative(absolutePath, projectRoot));\n  return projectRelativePaths;\n}"
  },
  "getTodoPages": {
    "name": "getTodoPages",
    "slug": "TsFunction",
    "id": "wlwqwjivpoqkejsanjhyqysn",
    "description": "`getTodoPages(): WebPage[]` function:\n\n- use getProjectRelativePaths, map the result to a queryPath + file\n- [operation-name]/[todo-relative-file-id] for operations\n- [folder-name]/[todo-relative-file-id] for todos within folders",
    "operationName": "explore-project",
    "rawText": " async (\n  config?: TodoPagesConfig\n): Promise<{ nested: NestedWebPage[]; flat: (WriterWebPage | WebPage)[] }> => {\n  // console.log({ config });\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return { nested: [], flat: [] };\n\n  //needed for matching persons but also for just showing that it has offers\n  const todoOffers = await db.get(\"TodoOffer\");\n  const todoPaths = await getTodoPaths(config);\n\n  const todoPages: WriterWebPage[] =\n    todoPaths?.map((projectRelativeFilePath) => {\n      const [before, after] = projectRelativeFilePath.split(\"/todo/\");\n      const lastFolderBeforeTodo = getLastFolder(before);\n      const todoRelativeFileId = withoutExtension(after);\n      const fileName = getLastFolder(todoRelativeFileId);\n      /**\n       * Idea: parsing the file for amount of items with and without checkmark, showing the % done and (x/y)\n       */\n      const menuTitle = humanCase(fileName);\n\n      const hasTodoOffers = !!todoOffers.find(\n        (x) => x.todoFileId === projectRelativeFilePath\n      );\n      /**\n       * showing an emoji the status of the todo-offers\n       */\n      const menuTitleAugmentation = hasTodoOffers ? \"🔥\" : undefined;\n\n      /**\n       * Idea: showing a summary, more about the progress and owner(s), and anything you just quickly wanna see\n       */\n      const menuTitleTooltip =\n        \"Tooltip example\\n\\nShould render markdown\\n\\n**Say,this is great, no?**\";\n\n      const page: WriterWebPage = {\n        pageData: {\n          projectRelativeFilePath,\n        },\n        queryPath: `${lastFolderBeforeTodo}/${todoRelativeFileId}`,\n        menuTitle,\n        menuTitleAugmentation,\n        menuTitleTooltip,\n        isMenuHidden: false,\n      };\n\n      return page;\n    }) || [];\n\n  const otherPages: WebPage<unknown>[] = [\n    {\n      queryPath: \"stats\",\n      menuTitle: \"Statistics\",\n      menuTitleTooltip: \"Some stats about cool stuff\",\n      pageData: undefined,\n    },\n\n    {\n      queryPath: \"SelfSprintReview\",\n      menuTitle: \"Sprint review\",\n      menuTitleTooltip: \"Let's do this every friday, 3PM CET\",\n      pageData: undefined,\n    },\n    {\n      queryPath: \"TodoOffer\",\n      isMenuHidden: true,\n      pageData: undefined,\n    },\n    {\n      queryPath: \"upsert/TodoOffer\",\n      isMenuHidden: true,\n      pageData: undefined,\n    },\n    {\n      queryPath: \"upsert/SelfSprintReview\",\n      isMenuHidden: true,\n      pageData: undefined,\n    },\n  ];\n\n  const flat = otherPages.concat(todoPages) as (WriterWebPage | WebPage)[];\n\n  // nestifyQueryPathObjectRecursive(flatWithoutPageData);\n\n  return getMenuPagesObject(flat);\n}"
  },
  "getTodoPaths": {
    "name": "getTodoPaths",
    "slug": "TsFunction",
    "id": "fsrfmlleiannroybijbdvcwx",
    "description": "",
    "operationName": "explore-project",
    "rawText": " async (\n  config?: TodoPagesConfig\n): Promise<string[]> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return [];\n\n  const { recency, categoryStack, personId, priority, subExtension, sort } =\n    destructureOptionalObject(config);\n\n  /**\n   * TODO:\n   */\n  const todayTimestamp = 0;\n  const thisWeekTimestamp = 0;\n  const earliestUpdatedAt =\n    recency === \"24-hours\"\n      ? Date.now() - 86400000\n      : recency === \"7-days\"\n      ? Date.now() - 86400000 * 7\n      : recency === \"today\"\n      ? todayTimestamp\n      : recency === \"this-week\"\n      ? thisWeekTimestamp\n      : undefined;\n\n  let todoPaths = await getProjectRelativePaths({\n    type: \"todo\",\n    filterPrivate: true,\n    filterDraft: true,\n    filterGenerated: true,\n    earliestUpdatedAt,\n    sort,\n  });\n\n  // filter on categoryStack, if it's there. Filter BEFORE getting the markdown frontmatter, that's slow...\n\n  if (categoryStack && categoryStack.length === 0) {\n    todoPaths = todoPaths?.filter((todoPath) => {\n      const lastIndexTodoFolder = todoPath.lastIndexOf(\"todo/\");\n\n      if (lastIndexTodoFolder === -1) {\n        return false;\n      }\n\n      const todoRelativeFileId = todoPath.slice(\n        lastIndexTodoFolder + \"todo/\".length\n      );\n\n      const depth = todoRelativeFileId.split(\"/\").length - 1;\n\n      return depth === 0;\n    });\n  }\n  if (categoryStack && categoryStack.length > 0) {\n    todoPaths = todoPaths?.filter((todoPath) => {\n      const lastIndexTodoFolder = todoPath.lastIndexOf(\"todo/\");\n\n      if (lastIndexTodoFolder === -1) {\n        return false;\n      }\n\n      const todoRelativeFileId = todoPath.slice(\n        lastIndexTodoFolder + \"todo/\".length\n      );\n\n      // console.log({ todoRelativeFileId });\n\n      const categoryStackPrefix = categoryStack.join(\"/\") + \"/\";\n\n      if (!todoRelativeFileId.startsWith(categoryStackPrefix)) {\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  if (subExtension) {\n    todoPaths = todoPaths?.filter((filePath) => {\n      const filename = path.parse(filePath).base;\n      const thisSubExtension = getSubExtension(filename);\n\n      if (subExtension !== thisSubExtension) {\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  if (personId || priority) {\n    // ONLY get the mapped object of all frontmatters if it's really needed. It may take a little longer... Filter AFTER applying filter for recency and categoryStack.\n    const frontmatterObject = await getFrontmattersMappedObject(\n      projectRoot,\n      todoPaths\n    );\n\n    if (priority) {\n      todoPaths = todoPaths?.filter((todoPath) => {\n        const frontmatterPriority = frontmatterObject[todoPath]?.priority;\n\n        const matchPriority = priority === String(frontmatterPriority);\n\n        return matchPriority;\n      });\n    }\n\n    if (personId) {\n      todoPaths = todoPaths?.filter((todoPath) => {\n        const frontmatterOwner_personId =\n          frontmatterObject[todoPath]?.owner_personId;\n\n        const matchPerson = personId === String(frontmatterOwner_personId);\n\n        return matchPerson;\n      });\n    }\n  }\n\n  return todoPaths || [];\n}"
  },
  "hasSameProjectPath": {
    "name": "hasSameProjectPath",
    "slug": "TsFunction",
    "id": "svxwdnldqqafmnppunmigbba",
    "description": "function that returns a filter function that can check if some object (that extends an TsIndexModelType) has the same relative file path from the project root",
    "operationName": "explore-project",
    "rawText": "\n  (projectRelativePath: string) =>\n  <T extends TsIndexModelType>(x: T) => {\n    const isSame = x.projectRelativePath === projectRelativePath;\n    return isSame;\n  }"
  },
  "FancyLoader": {
    "name": "FancyLoader",
    "slug": "TsFunction",
    "id": "ovvrehnnliupzojiiuiizcol",
    "description": "",
    "operationName": "fancy-loader",
    "rawText": " ({\n  big,\n  medium,\n}: {\n  big?: boolean;\n  medium?: boolean;\n}) => (\n  <Div\n    className={`rounded-full ${\n      big ? \"w-12 h-12\" : medium ? \"w-7 h-7\" : \"w-4 h-4\"\n    } border-b-orange-400 border-l-blue-400 border-t-red-400 border-r-green-400 ${\n      big ? \"border-4\" : medium ? \"border-2\" : \"border\"\n    } animate-spin`}\n  />\n)"
  },
  "[absolutePath]": {
    "name": "[absolutePath]",
    "slug": "TsVariable",
    "id": "zqqvsmrbkaxorvowmcwektps",
    "description": "",
    "operationName": "ffmpeg-util"
  },
  "compressConvert": {
    "name": "compressConvert",
    "slug": "TsFunction",
    "id": "uovkakubnvcgnwuxekqkvagd",
    "description": "Super useful wrapper around ffmpeg to do just all the stuff I want to do with it\n\nTODO: fix fps, not implemented yet",
    "operationName": "ffmpeg-util",
    "rawText": " async (\n  absoluteSourceFilePath: string,\n  config?: {\n    isStatusLogged?: boolean;\n    /**\n     * If given, outputted file will be put in this folder\n     */\n    outputFolderPath?: string;\n    /**\n     * If given, name will change into this\n     */\n    name?: string;\n    /**\n     * frames per second (only for targetformat mp4)\n     */\n    fps?: number;\n    /**\n     * width pixels, will preserve same size if not given\n     */\n    sizeWidthPx?: number;\n    /**\n     * if not given, will preserve ratio\n     */\n    aspectRatio?: { x: number; y: number };\n    /**\n     * quality number in range: 0-100\n     */\n    quality?: number;\n    targetFormat?: \"webp\" | \"png\" | \"mp4\" | \"mp3\" | \"wav\";\n    /**\n     * If true, and targetformat is wav, will convert to 16bit wav (uses `-ar 16000 -ac 1 -codec:a pcm_s16le` as extra options)\n     *\n     * Useful for whisper.cpp\n     */\n    is16bitWav?: boolean;\n    /**\n     * if true, original won't be thrown away afterwards\n     */\n    keepOriginal?: boolean;\n    isDebug?: boolean;\n  }\n) => {\n  if (isLocked(absoluteSourceFilePath)) {\n    return;\n  }\n  if (!fs.existsSync(absoluteSourceFilePath)) {\n    console.log(\"Path doesn't exist\", absoluteSourceFilePath);\n    return;\n  }\n\n  let result = ffmpeg({ source: absoluteSourceFilePath });\n  if (config?.quality) {\n    result = result.addOption(`-quality ${config?.quality || 100}`);\n  }\n\n  if (config?.fps && config.targetFormat === \"mp4\") {\n    // set output fps\n    result = result.withOutputFps(config.fps);\n  }\n\n  if (config?.targetFormat === \"wav\" && config?.is16bitWav) {\n    result = result.outputOptions([\"-ar 16000\", \"-ac 1\", \"-codec:a pcm_s16le\"]);\n  }\n\n  if (config?.sizeWidthPx) {\n    result = result.size(`${config?.sizeWidthPx}x?`);\n  }\n\n  if (config?.aspectRatio) {\n    result = result.aspect(`${config?.aspectRatio.x}:${config.aspectRatio.y}`);\n  }\n\n  if (config?.targetFormat) {\n    result = result.toFormat(config?.targetFormat);\n  }\n\n  const parsedPath = path.parse(absoluteSourceFilePath);\n\n  const destinationName = config?.name || parsedPath.name;\n\n  const folderPath = config?.outputFolderPath || parsedPath.dir;\n\n  const extension = config?.targetFormat\n    ? `.${config?.targetFormat}`\n    : parsedPath.ext;\n\n  // ffmpeg can't edit in-place\n  const destinationPath = path.join(\n    folderPath,\n    `${destinationName}.converted${extension}`\n  );\n\n  const finalDestinationPath = replaceLastOccurence(\n    destinationPath,\n    \".converted\",\n    \"\"\n  );\n\n  // if (fs.existsSync(finalDestinationPath)) {\n  //   console.log(\n  //     `Shouldn't happen, but compressConvert was called for a file for which the finalDestinationPath already seems to exist`\n  //   );\n  //   return;\n  // }\n\n  result = result.save(destinationPath);\n\n  let totalTime = 1;\n  let shownPercentage = 0;\n\n  const finalPath = await new Promise<string | undefined>((resolve) => {\n    result\n      .on(\"codecData\", (data) => {\n        // HERE YOU GET THE TOTAL TIME\n        totalTime = parseInt(data.duration.replace(/:/g, \"\"));\n        console.log(\"Converting Started...\");\n      })\n      .on(\"progress\", (progress) => {\n        // HERE IS THE CURRENT TIME\n        const time = parseInt(progress.timemark.replace(/:/g, \"\"));\n        // AND HERE IS THE CALCULATION\n        const percent = Math.floor((time / totalTime) * 100);\n\n        lock(absoluteSourceFilePath, `${percent}%`);\n\n        if (config?.isDebug) {\n          console.log(`${percent}%`);\n        } else if (\n          percent % 2 === 1 &&\n          percent !== shownPercentage &&\n          config?.isStatusLogged\n        ) {\n          shownPercentage = percent;\n          console.log(`${destinationName} status: ${percent}%`);\n        }\n      })\n      .on(\"end\", async () => {\n        if (!config?.keepOriginal) {\n          // new file is created, old one is not overwritten, and we need to remove the old\n          // NB: don't wait for it!\n          await fs.rm(absoluteSourceFilePath);\n        }\n\n        unlock(absoluteSourceFilePath);\n\n        if (fs.existsSync(finalDestinationPath)) {\n          // already exists for some reason...\n          await fs.rm(destinationPath);\n          resolve(destinationPath);\n          return;\n        }\n\n        if (!fs.existsSync(destinationPath)) {\n          //doens't existalthough we just converted it, multiple processes doing the same, probably\n          resolve(undefined);\n          return;\n        }\n\n        await fs.rename(destinationPath, finalDestinationPath);\n        resolve(finalDestinationPath);\n      })\n      .on(\"error\", (e: Error) => {\n        console.log({ e });\n        resolve(undefined);\n      });\n  });\n\n  return finalPath;\n}"
  },
  "compressImagesCli": {
    "name": "compressImagesCli",
    "slug": "TsFunction",
    "id": "rtpmivkdwxjzjjtalflhhise",
    "description": "`compressImages` CLI syntax:\n\n`compressImages [basePath]`\n\ncan also be relative path",
    "operationName": "ffmpeg-util",
    "rawText": " async () => {\n  const argumentsArray = process.argv.slice(2);\n\n  if (argumentsArray.length > 0) {\n    oneByOne(argumentsArray, async (absoluteOrRelativePath) => {\n      const absoluteFolderPath = absoluteOrRelativePath.startsWith(\".\")\n        ? path.join(process.cwd(), absoluteOrRelativePath)\n        : absoluteOrRelativePath;\n\n      if (!absoluteFolderPath) {\n        log(\"couldn't find that path\");\n        return;\n      }\n\n      // console.log({ operationNames, operationName });\n      await compressImages(absoluteFolderPath);\n    });\n  }\n}"
  },
  "compressImages": {
    "name": "compressImages",
    "slug": "TsFunction",
    "id": "xwkzlmveqjbafhslxxdzmcmf",
    "description": "searches the folder recursively for all images and converts them to webp",
    "operationName": "ffmpeg-util",
    "rawText": " async (\n  absoluteBasePath: string,\n  sizeWidthPx?: number,\n  quality?: number\n) => {\n  const results = (\n    await explore({\n      basePath: absoluteBasePath,\n      extension: [\"jpg\", \"jpeg\", \"png\"],\n    })\n  ).map((x) => x.path);\n\n  const compressionResult = await Promise.all(\n    results.map((path) =>\n      compressConvert(path, {\n        targetFormat: \"webp\",\n        quality: quality || 50,\n        sizeWidthPx: sizeWidthPx || 1920,\n      })\n    )\n  );\n\n  const isSuccessful =\n    compressionResult.filter(notEmpty).length === compressionResult.length;\n\n  console.log(\"DONE\", { isSuccessful });\n}"
  },
  "compressMp4": {
    "name": "compressMp4",
    "slug": "TsFunction",
    "id": "gdsghxtqplupnnpjogwxmxre",
    "description": "Compress mp4 to very small",
    "operationName": "ffmpeg-util",
    "rawText": " async (absolutePath: string) => {\n  const result = await compressConvert(absolutePath, {\n    quality: 20,\n    sizeWidthPx: 360,\n    targetFormat: \"mp4\",\n    fps: 4,\n    isDebug: true,\n  });\n  console.log({ result });\n}"
  },
  "compressMp4sCli": {
    "name": "compressMp4sCli",
    "slug": "TsFunction",
    "id": "doepzcokmkmecbmnmeugplmi",
    "description": "`compressMp4s` CLI syntax:\n\n`compressMp4s [basePath]`\n\ncan also be relative path",
    "operationName": "ffmpeg-util",
    "rawText": " async () => {\n  const argumentsArray = process.argv.slice(2);\n\n  if (argumentsArray.length > 0) {\n    oneByOne(argumentsArray, async (absoluteOrRelativePath) => {\n      const absoluteFilePath = absoluteOrRelativePath.startsWith(\".\")\n        ? path.join(process.cwd(), absoluteOrRelativePath)\n        : absoluteOrRelativePath;\n\n      if (!absoluteFilePath || !fs.existsSync(absoluteFilePath)) {\n        log(\"couldn't find that path\");\n        return;\n      }\n\n      // console.log({ operationNames, operationName });\n      await compressMp4(absoluteFilePath);\n    });\n  }\n}"
  },
  "convertToMp3": {
    "name": "convertToMp3",
    "slug": "TsFunction",
    "id": "fcpjlcumpznxsvkuhddrjjna",
    "description": "Uses ffmpeg to convert a file to mp3\n\nReturns the new file path on success",
    "operationName": "ffmpeg-util",
    "rawText": " (\n  sourcePath: string,\n  destinationPath: string,\n  config?: {\n    toWav?: boolean;\n  }\n): Promise<string | undefined> => {\n  const toWav = config?.toWav;\n\n  return new Promise<string | undefined>((resolve, reject) => {\n    if (!fs.existsSync(sourcePath)) {\n      console.log(\"sourcePath doesn't exist\", sourcePath);\n    }\n    ffmpeg({ source: sourcePath })\n      .toFormat(toWav ? \"wav\" : \"mp3\")\n      .saveToFile(destinationPath)\n      .on(\"end\", () => {\n        resolve(destinationPath);\n      })\n      .on(\"error\", (e: Error) => {\n        console.log({ e });\n        resolve(undefined);\n      });\n  });\n}"
  },
  "convertToMp4": {
    "name": "convertToMp4",
    "slug": "TsFunction",
    "id": "cmvhgjogbjnmcxfflqmoakvr",
    "description": "Uses ffmpeg to convert a file to mp3\n\nReturns the new file path on success",
    "operationName": "ffmpeg-util",
    "rawText": " (\n  sourcePath: string,\n  destinationPath: string\n): Promise<string | undefined> => {\n  return new Promise<string | undefined>((resolve, reject) => {\n    ffmpeg({ source: sourcePath })\n      .toFormat(\"mp4\")\n      .saveToFile(destinationPath)\n      .on(\"end\", () => {\n        resolve(destinationPath);\n      })\n      .on(\"error\", (e: Error) => {\n        resolve(undefined);\n      });\n  });\n}"
  },
  "fileExplorerOpen": {
    "name": "fileExplorerOpen",
    "slug": "TsFunction",
    "id": "xptteiyheewbzrnjhqugymnh",
    "description": "",
    "operationName": "file-explorer-open",
    "rawText": " async (\n  projectRelativePath: string\n): Promise<{ isSuccessful: boolean; message: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return {\n      isSuccessful: false,\n      message: \"No projectroot\",\n    };\n  }\n\n  const absolutePath = path.join(projectRoot, projectRelativePath);\n\n  if (!absolutePath || !fs.existsSync(absolutePath)) {\n    return { isSuccessful: false, message: \"This path doesn't exist\" };\n  }\n\n  const pathStats = await fs.stat(absolutePath);\n\n  const folderPath = pathStats.isDirectory()\n    ? absolutePath\n    : path.parse(absolutePath).dir;\n\n  var isWindows = process.platform === \"win32\";\n\n  const command = isWindows ? `start ${folderPath}` : `open ${folderPath}`;\n\n  execSync(command);\n\n  return { isSuccessful: true, message: \"Opened\" };\n}"
  },
  "getFileType": {
    "name": "getFileType",
    "slug": "TsFunction",
    "id": "fofovwypcfnozautsywwowmk",
    "description": "",
    "operationName": "file-icons",
    "rawText": " (fullPath: string): keyof typeof typeIcons => {\n  if (fullPath.endsWith(\".ts\")) return \"typescript\";\n  if (fullPath.endsWith(\".tsx\")) return \"typescript\";\n  if (fullPath.endsWith(\".js\")) return \"javascript\";\n  if (fullPath.endsWith(\".jsx\")) return \"javascript\";\n  if (fullPath.endsWith(\".md\")) return \"markdown\";\n  if (fullPath.endsWith(\".mdx\")) return \"markdown\";\n  if (fullPath.endsWith(\".json\")) return \"json\";\n  if (!fullPath.split(\"/\").pop()?.includes(\".\")) return \"folder\";\n\n  return \"other\";\n}"
  },
  "typeIcons": {
    "name": "typeIcons",
    "slug": "TsVariable",
    "id": "bgammkwbwhkpglgbrqdanshk",
    "description": "",
    "operationName": "file-icons"
  },
  "MatchingText": {
    "name": "MatchingText",
    "slug": "TsFunction",
    "id": "puocfhxxjgehwontujayxmsr",
    "description": "Component that highlights the matching text",
    "operationName": "file-search",
    "rawText": " (props: {\n  text: string;\n  search: string;\n  defaultTextClassName: string;\n  matchTextClassName: string;\n  truncateLength?: number;\n}) => {\n  const {\n    truncateLength,\n    text,\n    defaultTextClassName,\n    matchTextClassName,\n    search,\n  } = props;\n\n  // 1: find index of search in text\n  const matchIndex = text.toLowerCase().indexOf(search.toLowerCase());\n\n  // 2: find stuff before that and after that\n  const beforeText = text.slice(0, matchIndex);\n  const afterText = text.slice(matchIndex + search.length);\n  const matchText = text.slice(matchIndex, matchIndex + search.length);\n\n  const totalLength = beforeText.length + search.length + afterText.length;\n\n  const reduceCharactersAmount = truncateLength\n    ? totalLength - truncateLength\n    : 0;\n\n  const beforeTextLengthPercentage =\n    beforeText.length / (beforeText.length + afterText.length);\n  const afterTextLengthPercentage =\n    afterText.length / (beforeText.length + afterText.length);\n\n  const reduceBeforeCharacters = Math.round(\n    beforeTextLengthPercentage * reduceCharactersAmount\n  );\n  const reduceAfterCharacters = Math.round(\n    afterTextLengthPercentage * reduceCharactersAmount\n  );\n\n  const truncatedBeforeText =\n    reduceBeforeCharacters > beforeText.length && truncateLength\n      ? beforeText.slice(0, beforeText.length - reduceBeforeCharacters - 2) +\n        \"..\"\n      : beforeText;\n  const truncatedAfterText =\n    truncateLength && reduceAfterCharacters > afterText.length\n      ? \"..\" + afterText.slice(afterText.length - reduceAfterCharacters - 2)\n      : afterText;\n\n  // 3: render before, match, and after\n  return matchIndex === -1 ? (\n    // with no match, truncate at truncateLength at the end\n    <P title={text} className={defaultTextClassName}>\n      {truncateLength && text.length > truncateLength\n        ? text.substring(0, truncateLength - 2) + \"..\"\n        : text}\n    </P>\n  ) : (\n    /**\n     * with a match, the total length needs to be `truncateLength`\n     *\n     * the `search` result should not be truncated\n     *\n     * `beforeText` should be truncated at the end to reduce to `truncateLength`\n     * `afterText` should be truncated at the beginning to reduce to `truncateLength`\n     *\n     * it should be truncated as much as needed on both sides, but we must take into account at the length of the sides as well\n     */\n    <P\n      title={text} //`(${reduceCharactersAmount}== ${reduceBeforeCharacters} <> ${reduceAfterCharacters} .... ${beforeTextLengthPercentage}, ${afterTextLengthPercentage}) ${text}`\n      className={defaultTextClassName}\n    >\n      {beforeText}\n      <Span className={matchTextClassName}>{matchText}</Span>\n      {afterText}\n    </P>\n  );\n}"
  },
  "PathSearchResults": {
    "name": "PathSearchResults",
    "slug": "TsFunction",
    "id": "mklvowbfccsjswctoevmfojn",
    "description": "",
    "operationName": "file-search",
    "rawText": " (props: {\n  paths: string[];\n  search: string;\n  augmentedWords?: AugmentedWord[];\n}) => {\n  const { paths, search, augmentedWords } = props;\n\n  /**\n   * TODO: include this in the results somehow nicely...\n   */\n  const augmentedWordResults = augmentedWords?.filter((x) => {\n    const word = x.isCaseInsensitive ? x.word.toLowerCase() : x.word;\n    const searchQuery = x.isCaseInsensitive ? search.toLowerCase() : search;\n\n    const isMatch = word.includes(searchQuery);\n\n    return isMatch;\n  });\n\n  const results = paths\n    .map((path) => {\n      const augmentedWordsThisPath = augmentedWordResults?.filter(\n        (x) => x.queryPath === path\n      );\n\n      return { path, augmentedWordsThisPath };\n    })\n    .filter((item) => {\n      const isPathMatch = item.path\n        .toLowerCase()\n        .includes(search.toLowerCase());\n      const isMatch = item.augmentedWordsThisPath?.length || isPathMatch;\n\n      return isMatch;\n    })\n    .slice(0, 100);\n\n  return (\n    <Div>\n      {results.map((item) => {\n        const filename = item.path.split(\"/\").pop()!;\n\n        return (\n          <ALink href={`/${item.path}`}>\n            <Div className=\"px-2 hover:dark:bg-gray-600\">\n              <MatchingText\n                truncateLength={30}\n                text={filename}\n                search={search}\n                defaultTextClassName=\"\"\n                matchTextClassName=\"text-blue-500\"\n              />\n\n              <MatchingText\n                truncateLength={30}\n                text={item.path}\n                search={search}\n                defaultTextClassName=\"text-xs\"\n                matchTextClassName=\"text-blue-500\"\n              />\n\n              {item.augmentedWordsThisPath?.map((augmentedWord) => {\n                return (\n                  <MatchingText\n                    truncateLength={30}\n                    text={augmentedWord.word}\n                    search={search}\n                    defaultTextClassName=\"text-xs\"\n                    matchTextClassName=\"text-blue-500\"\n                  />\n                );\n              })}\n            </Div>\n          </ALink>\n        );\n      })}\n    </Div>\n  );\n}"
  },
  "fileTabsInitialValues": {
    "name": "fileTabsInitialValues",
    "slug": "TsVariable",
    "id": "sjuybnetqysrhqbiwxjmnpjd",
    "description": "",
    "operationName": "file-tabs"
  },
  "FileTabs": {
    "name": "FileTabs",
    "slug": "TsFunction",
    "id": "frbkcfkybbyqgcvttkeywhws",
    "description": "",
    "operationName": "file-tabs",
    "rawText": " <TPagesObject extends PagesObjectShape>(props: {\n  pagesObject: TPagesObject;\n}) => {\n  const { pagesObject } = props;\n\n  const router = useRouter();\n  const { query } = router;\n  const alert = useAlert();\n  const { fullPath } = usePath();\n\n  const [showOpenPages, setShowOpenPages] = useState(true);\n  const [openPages, setOpenPages] = useStore(\"openPages\");\n  const [unsavedFiles, setUnsavedFiles] = useStore(\"unsavedFiles\");\n\n  const unsavedFilePaths = Object.keys(unsavedFiles).filter(\n    (projectRelativePath) => unsavedFiles[projectRelativePath] !== undefined\n  );\n\n  const notOpenUnsavedFilesPages: OpenPage<Keys<TPagesObject>>[] =\n    unsavedFilePaths\n      .map((projectRelativeFilePath) => {\n        const already = !!openPages.find(\n          (x) => getFullPath(x.query.paths) === projectRelativeFilePath\n        );\n\n        if (already) return;\n\n        const openPage: OpenPage<Keys<TPagesObject>> = {\n          id: generateId(),\n          page: \"index\" as Keys<TPagesObject>,\n          query: {\n            paths: projectRelativeFilePath.split(\"/\"),\n          },\n          lastOpenedAt: Date.now(),\n          isUnsaved: true,\n          temporary: true,\n        };\n        return openPage;\n      })\n      .filter(notEmpty);\n\n  const currentOpenPage: OpenPage<Keys<TPagesObject>> = {\n    page: getActivePage(router.pathname, pagesObject),\n    query,\n    lastOpenedAt: 0,\n    temporary: true,\n    /*** NB: id isn't correct */\n    id: generateId(),\n  };\n\n  const openAndUnsavedPages = openPages.concat(notOpenUnsavedFilesPages);\n\n  const already = openAndUnsavedPages.find((x) => {\n    const url = getOpenPageUrl(x, pagesObject);\n    const currentUrl = router.asPath.slice(1);\n    return url === currentUrl;\n  });\n\n  const allOpenPages =\n    !already && router.asPath !== \"/\"\n      ? openAndUnsavedPages.concat(currentOpenPage)\n      : openAndUnsavedPages;\n\n  // Alt + N: new file\n  useHotkey(isAltN, () => goToOpenPage(undefined), []);\n  // `alt+o`: toggle hiding file-tabs\n  useHotkey(isAltO, () => setShowOpenPages((value) => !value), []);\n  // Alt+W: close page\n  useHotkey(isAltW, () => closeOpenPage(currentOpenPage, true), [\n    currentOpenPage.id,\n  ]);\n\n  useHotkeys([], (keyboardEvent) => {\n    const { altKey, code, shiftKey } = keyboardEvent;\n    if (altKey && code === \"Tab\") {\n      if (shiftKey) {\n        alert?.(\"Previous page\");\n      } else {\n        alert?.(\"Next page\");\n      }\n    }\n  });\n\n  const goToOpenPage = (openPage?: OpenPage<keyof TPagesObject>) => {\n    if (openPage) {\n      router.push(getOpenPageUrl(openPage, pagesObject));\n    } else {\n      router.push(`/`);\n    }\n  };\n\n  const closeOpenPage = (\n    openPage: OpenPage<keyof TPagesObject>,\n    isActive: boolean\n  ) => {\n    const newOpenPages = openPages.filter((x) =>\n      x.id === openPage.id ? false : true\n    );\n\n    setOpenPages(newOpenPages);\n\n    // if you were there, go to another page that's open\n    if (isActive) {\n      const anotherPage = newOpenPages[0];\n      goToOpenPage(anotherPage);\n    }\n  };\n\n  const renderOpenPage = (openPage: OpenPage<string>, i: number) => {\n    const type = getFileType(getOpenPageUrl(openPage, pagesObject));\n    const typeIcon = typeIcons[type];\n    const thisFullPath = getOpenPageUrl(openPage, pagesObject);\n    const isActive = thisFullPath === fullPath;\n\n    const title =\n      openPage.page === \"index\"\n        ? `${typeIcon} ${getLastPathsChunk(openPage.query.paths)}`\n        : openPage.page === \"menu\"\n        ? \"📁\"\n        : \"?\";\n\n    const clickableIcons: ClickIcon[] = [\n      {\n        visible: openPage.pinned,\n        //  svgSrc: PinIcon,\n        emoji: \"🔒\",\n        // unpin\n        onClick: (e) => {\n          const newOpenPages = openPages.map((x) =>\n            x.id === openPage.id ? { ...x, pinned: false } : x\n          );\n          setOpenPages(newOpenPages);\n        },\n      },\n      {\n        visible: !openPage.isUnsaved && !openPage.pinned,\n        // svgSrc: CloseIcon,\n        emoji: \"⨯\",\n        // close\n        onClick: (e) => {\n          e.stopPropagation();\n\n          closeOpenPage(openPage, isActive);\n        },\n      },\n      {\n        visible: openPage.isUnsaved,\n        // svgSrc: CloseIcon,\n        emoji: \"●\",\n        // close\n        // onClick: (e) => {\n        //   e.stopPropagation();\n\n        //   closeOpenPage(openPage, isActive);\n        // },\n      },\n    ];\n\n    return (\n      <Div\n        key={`openPage${i}`}\n        className={`m-0.5 flex flex-row items-center border rounded-md border-gray-900 ${\n          isActive\n            ? \"bg-gray100 dark:bg-gray-900\"\n            : \"bg-gray-200 dark:bg-gray-700\"\n        }`}\n      >\n        <ALink\n          onDoubleClick={() => {\n            if (openPage.temporary) {\n              const thisOpenPageNotTemporary: OpenPage<string> = {\n                ...openPage,\n                temporary: false,\n                isUnsaved: undefined,\n              };\n\n              setOpenPages(openPages.concat(thisOpenPageNotTemporary));\n            }\n          }}\n          onContextMenu={(e) => {\n            e.preventDefault();\n\n            //  pin/unpin\n            const newOpenPages = openPages.map((x) =>\n              x.id === openPage.id\n                ? { ...x, pinned: !x.pinned, isUnsaved: undefined }\n                : x\n            );\n            setOpenPages(newOpenPages);\n          }}\n          href={getOpenPageUrl(openPage, pagesObject)}\n          key={`p${i}`}\n        >\n          <P\n            className={`${\n              openPage.temporary\n                ? \"italic text-black dark:text-gray-200\"\n                : \"text-black dark:text-gray-200\"\n            }`}\n          >\n            {title}\n          </P>\n        </ALink>\n        {clickableIcons.filter((x) => x.visible).map(renderIcon)}\n      </Div>\n    );\n  };\n\n  return showOpenPages ? (\n    <Div className={`bg-gray-100 dark:bg-gray-900`}>\n      <Div className=\"flex flex-row flex-wrap\">\n        {allOpenPages.map(renderOpenPage)}\n      </Div>\n    </Div>\n  ) : null;\n}"
  },
  "getActivePage": {
    "name": "getActivePage",
    "slug": "TsFunction",
    "id": "kuiqocpykeyieetnhesorgdy",
    "description": "",
    "operationName": "file-tabs",
    "rawText": " <TPagesObject extends PagesObjectShape>(\n  pathname: string,\n  pagesObject: TPagesObject\n): Keys<TPagesObject> => {\n  const p = pathname.substring(1);\n\n  if (Object.keys(pagesObject).includes(p))\n    return p as Keys<typeof pagesObject>;\n\n  return \"index\" as Keys<typeof pagesObject>;\n}"
  },
  "getOpenPageUrl": {
    "name": "getOpenPageUrl",
    "slug": "TsFunction",
    "id": "knmwdxdfegxsuhcmhhyccfsm",
    "description": "gets the url of the open page\n\n- paths is a special query key that is expanded as path, not as query\n- index page should be on /",
    "operationName": "file-tabs",
    "rawText": " <TPagesObject extends PagesObjectShape>(\n  openPage: OpenPage<keyof TPagesObject>,\n  pagesObject: TPagesObject\n) => {\n  const page =\n    openPage.page === \"index\"\n      ? getFullPath(openPage.query.paths)\n      : (openPage.page as string);\n\n  const query = { ...openPage.query };\n  delete query.paths;\n\n  const queryString = toQueryString(query);\n\n  const url = `${page}${queryString}`;\n  return url;\n}"
  },
  "renderIcon": {
    "name": "renderIcon",
    "slug": "TsFunction",
    "id": "dlihhwiucyrpfiqdfzykzyhl",
    "description": "<Svg src={svgSrc} className=\"w-4 h-4 text-gray-900 dark:text-gray-200\" />",
    "operationName": "file-tabs",
    "rawText": " (item: ClickIcon, index: number) => {\n  const { onClick, emoji } = item;\n  return (\n    <Button\n      key={`icon${index}`}\n      onClick={onClick}\n      className=\"hover:bg-yellow-100 rounded-sm m-0.5 p-0.5\"\n    >\n      {emoji}\n    </Button>\n  );\n}"
  },
  "useStore": {
    "name": "useStore",
    "slug": "TsVariable",
    "id": "zoetbkqpvbigedscdjlzuzmq",
    "description": "NB: this is a `useStore` without a `StoreProvider`, because I think I won't ever need the provider since I won't ever need this as the sole storage in any component/app. If I do, I should make a provider, but it's usually better to create the `useStore` and `StoreProvider` in the component itself because it often comprises more than just this one.",
    "operationName": "file-tabs"
  },
  "OpenFileWriterPages": {
    "name": "OpenFileWriterPages",
    "slug": "TsFunction",
    "id": "usthkvqcxkbhaphessilalpa",
    "description": "",
    "operationName": "file-writer",
    "rawText": " (props: {\n  pagesObject: PagesObjectShape;\n}) => {\n  const { pagesObject } = props;\n  return <FileTabs pagesObject={pagesObject} />;\n}"
  },
  "{ saveFileContents }": {
    "name": "{ saveFileContents }",
    "slug": "TsVariable",
    "id": "bkgxvscwoxnhkvmnuflwmfdv",
    "description": "",
    "operationName": "file-writer"
  },
  "useFileWriter": {
    "name": "useFileWriter",
    "slug": "TsFunction",
    "id": "iqomamksnmyzddguxhmggxzi",
    "description": "Returns a filewriter for a project relative filePath with a function to save it",
    "operationName": "file-writer",
    "rawText": " (props: {\n  markdownModelName?: keyof DbModels;\n  projectRelativeFilePath?: string;\n  initialWriterView?: WriterViewEnum;\n  disabledMenuItems?: string[];\n  hideButtons?: boolean;\n}) => {\n  const {\n    markdownModelName,\n    projectRelativeFilePath,\n    initialWriterView,\n    disabledMenuItems,\n    hideButtons,\n  } = props;\n\n  // fullPath is the project relative path\n  const {\n    data: fileContentsResult,\n    isLoading,\n    refetch,\n  } = useGetFileContents(projectRelativeFilePath);\n  const fileContents = fileContentsResult?.result?.fileContents;\n\n  // console.log({ fileContents });\n  const [unsavedFiles, setUnsavedFiles] = useStore(\"unsavedFiles\");\n\n  const unsavedFileContent = projectRelativeFilePath\n    ? unsavedFiles[projectRelativeFilePath]\n    : undefined;\n\n  const isSaved = projectRelativeFilePath\n    ? unsavedFileContent === undefined\n    : true;\n\n  const value = isSaved ? fileContents || \"\" : unsavedFileContent || \"\";\n  const onChange = (text: string) => {\n    if (!projectRelativeFilePath) return;\n    setUnsavedFiles({ ...unsavedFiles, [projectRelativeFilePath]: text });\n  };\n\n  const save = async () => {\n    if (!projectRelativeFilePath) return;\n    const apiResult = await saveFileContents(projectRelativeFilePath, value);\n    await refetch();\n    const { isSuccessful, result, message } = apiResult;\n\n    if (!isSuccessful || !result?.isSuccessful) {\n      toast({\n        title: \"Error\",\n        body: result?.message || message || \"Something went wrong\",\n      });\n    } else {\n      // removing the file that is now saved\n      const newUnsavedFiles = { ...unsavedFiles };\n      // NB: for some reason, delete` doesn't let the updated store rerender the object. React doesn't see the change! The solution is to also set it to undefined first.\n      newUnsavedFiles[projectRelativeFilePath] = undefined;\n      delete unsavedFiles[projectRelativeFilePath];\n\n      await setUnsavedFiles(newUnsavedFiles);\n    }\n  };\n  useHotkey(isCtrlS, save, [projectRelativeFilePath, value]);\n\n  const errorMessage = !fileContentsResult?.isSuccessful\n    ? fileContentsResult?.message\n    : !fileContentsResult?.result?.isSuccessful\n    ? fileContentsResult?.result?.message\n    : null;\n\n  const renderFileWriter = () => {\n    return (\n      <Div className=\"flex flex-1 flex-col h-full\">\n        {errorMessage ? (\n          <P>{errorMessage}</P>\n        ) : (\n          <WriterInput\n            key={projectRelativeFilePath}\n            isLoading={isLoading}\n            onChange={onChange}\n            value={value}\n            projectRelativeFilePath={projectRelativeFilePath}\n            reload={refetch}\n            save={save}\n            hideButtons={hideButtons}\n            initialWriterView={initialWriterView}\n            isSaved={isSaved}\n            markdownModelName={markdownModelName}\n            disabledMenuItems={disabledMenuItems}\n          />\n        )}\n      </Div>\n    );\n  };\n  return {\n    renderFileWriter,\n    save,\n    isSaved,\n  };\n}"
  },
  "{ useGetFileContents }": {
    "name": "{ useGetFileContents }",
    "slug": "TsVariable",
    "id": "lraoqggwxhkmgsdliuybqfjl",
    "description": "",
    "operationName": "file-writer"
  },
  "{ useStore, StoreProvider }": {
    "name": "{ useStore, StoreProvider }",
    "slug": "TsVariable",
    "id": "ckwzskepgmliyxlbfjvwqgps",
    "description": "",
    "operationName": "writer-input"
  },
  "WriterLayout": {
    "name": "WriterLayout",
    "slug": "TsFunction",
    "id": "llyucdlxbbdzzlprleocqnlh",
    "description": "",
    "operationName": "file-writer",
    "rawText": " (props: { children: JSX.Element }) => {\n  const { fullPath } = usePath();\n\n  return (\n    <Div\n      className={`flex flex-col flex-1 h-full`}\n      textClassName=\"dark:text-white\"\n    >\n      <Div className=\"sticky top-0\">\n        <OpenFileWriterPages pagesObject={{}} />\n        <BreadCrumbs path={fullPath || \"\"} />\n      </Div>\n      {props.children}\n    </Div>\n  );\n}"
  },
  "allowedSearchContentExtensions": {
    "name": "allowedSearchContentExtensions",
    "slug": "TsVariable",
    "id": "vudlorbkcgbekyjdxzrzsksx",
    "description": "",
    "operationName": "filename-conventions"
  },
  "buildFolderName": {
    "name": "buildFolderName",
    "slug": "TsVariable",
    "id": "qnemuanenuabcenweuacmidx",
    "description": "",
    "operationName": "filename-conventions"
  },
  "databaseFolderName": {
    "name": "databaseFolderName",
    "slug": "TsVariable",
    "id": "dpnpmiffqkxxhqfyllwoqgoi",
    "description": "",
    "operationName": "filename-conventions"
  },
  "extensions": {
    "name": "extensions",
    "slug": "TsVariable",
    "id": "fenhgarvspkmmepfzqcjgvsl",
    "description": "",
    "operationName": "filename-conventions"
  },
  "fileTypes": {
    "name": "fileTypes",
    "slug": "TsVariable",
    "id": "zgbqpykemrccdtxqtavqphue",
    "description": "",
    "operationName": "filename-conventions"
  },
  "frontendOptionalFileSubExtensions": {
    "name": "frontendOptionalFileSubExtensions",
    "slug": "TsVariable",
    "id": "qmstbyaoadgtegbmkngeoyrw",
    "description": "these special operations are generated, so should not be copied, but should be generated in the bundle after everything is copied",
    "operationName": "filename-conventions"
  },
  "generatedFolders": {
    "name": "generatedFolders",
    "slug": "TsVariable",
    "id": "zhmwrnbyoyzkaemxuwynwowc",
    "description": "",
    "operationName": "filename-conventions"
  },
  "getFileTypeFromPath": {
    "name": "getFileTypeFromPath",
    "slug": "TsFunction",
    "id": "xrsdkjoqqnvkmkkqquffradk",
    "description": "",
    "operationName": "filename-conventions",
    "rawText": " (path?: string): FileType | \"other\" => {\n  if (!path) return \"other\";\n  //code\n  if (path.endsWith(\".ts\")) return \"code\";\n  if (path.endsWith(\".tsx\")) return \"code\";\n  if (path.endsWith(\".js\")) return \"code\";\n  if (path.endsWith(\".jsx\")) return \"code\";\n\n  //text\n  if (path.endsWith(\".md\")) return \"text\";\n  if (path.endsWith(\".mdx\")) return \"text\";\n  if (path.endsWith(\".txt\")) return \"text\";\n\n  //data\n  if (path.endsWith(\".json\")) return \"data\";\n\n  return \"other\";\n}"
  },
  "getWriterType": {
    "name": "getWriterType",
    "slug": "TsFunction",
    "id": "bbytrnmxcuagredgygfsznht",
    "description": "Gets the writer type based on the extension",
    "operationName": "filename-conventions",
    "rawText": " (extension: string | undefined): WriterType => {\n  if (!extension) return \"other\";\n  if (typescriptExtensions.includes(extension)) return \"typescript\";\n  if (markdownExtensions.includes(extension)) return \"markdown\";\n  return \"other\";\n}"
  },
  "hasSubExtension": {
    "name": "hasSubExtension",
    "slug": "TsFunction",
    "id": "fpasxgxfkcfspmbvonvxbkgh",
    "description": "Returns true if a fileid includes one of the specified subextensions.",
    "operationName": "filename-conventions",
    "rawText": " (\n  srcRelativeFileId: string,\n  subExtensions: string | string[],\n  /**\n   * if true, also returns true if the extension is the complete name of the file\n   */\n  includeRootName?: boolean\n): boolean => {\n  const subExtensionsArray = makeArray(subExtensions);\n  const parts = srcRelativeFileId.split(\".\");\n  const isSinglePart = parts.length === 1;\n  const subExtension = parts.pop()!;\n  const includesSubExtension = subExtensionsArray.includes(subExtension);\n  const isCounting = includeRootName ? true : !isSinglePart;\n  const has = isCounting && includesSubExtension;\n  return has;\n}"
  },
  "isGeneratedOperationName": {
    "name": "isGeneratedOperationName",
    "slug": "TsFunction",
    "id": "bvjqbohaclxdjhlmyplbkbwa",
    "description": "",
    "operationName": "filename-conventions",
    "rawText": " (operationName: string) => {\n  if (!operationName) return false;\n  return operationName === \"sdk\" || operationName.startsWith(\"sdk-\");\n}"
  },
  "isGeneratedOperation": {
    "name": "isGeneratedOperation",
    "slug": "TsFunction",
    "id": "uxduugiwmqtvnmnhqmxyotyj",
    "description": "",
    "operationName": "filename-conventions",
    "rawText": " (operationBasePath: string) => {\n  return operationBasePath.includes(\"/generated/\");\n}"
  },
  "isIndexableFileId": {
    "name": "isIndexableFileId",
    "slug": "TsFunction",
    "id": "kozraeovjomgompicabrmxrk",
    "description": "",
    "operationName": "filename-conventions",
    "rawText": " (fileId: string): boolean => {\n  const isOperationName = hasSubExtension(\n    fileId,\n    operationUnindexableNamesOrSubExtensions,\n    true\n  );\n\n  const isFrontendOptionalName = hasSubExtension(\n    fileId,\n    frontendOptionalFileSubExtensions,\n    false\n  );\n\n  const isIndex = fileId === \"index\";\n\n  const isIndexable = !isIndex && !isFrontendOptionalName && !isOperationName;\n\n  return isIndexable;\n}"
  },
  "jsonExtensionsConst": {
    "name": "jsonExtensionsConst",
    "slug": "TsVariable",
    "id": "cvzmhwvvgidotahepofvmodg",
    "description": "",
    "operationName": "filename-conventions"
  },
  "jsonExtensions": {
    "name": "jsonExtensions",
    "slug": "TsVariable",
    "id": "jzabgjtbmhtuaieivbznaxue",
    "description": "",
    "operationName": "filename-conventions"
  },
  "markdownExtensionsConst": {
    "name": "markdownExtensionsConst",
    "slug": "TsVariable",
    "id": "jwcskenvthckywbnpcqyufti",
    "description": "",
    "operationName": "filename-conventions"
  },
  "markdownExtensions": {
    "name": "markdownExtensions",
    "slug": "TsVariable",
    "id": "smzdehwhuyebwuvnyayyhjqk",
    "description": "",
    "operationName": "filename-conventions"
  },
  "movedFileSubextension": {
    "name": "movedFileSubextension",
    "slug": "TsVariable",
    "id": "drygltonedvnjennpuiwzkma",
    "description": "subextension indicating that a file has been moved to another location\n\nFor example, used in `watchAppleMemos`",
    "operationName": "filename-conventions"
  },
  "operationUnindexableNamesOrSubExtensions": {
    "name": "operationUnindexableNamesOrSubExtensions",
    "slug": "TsVariable",
    "id": "fxbikxwbeykeccouzajzyszy",
    "description": "",
    "operationName": "filename-conventions"
  },
  "projectRelativeGeneratedOperationsFolder": {
    "name": "projectRelativeGeneratedOperationsFolder",
    "slug": "TsVariable",
    "id": "fvusqegtvazwvxyhkpdkgumo",
    "description": "",
    "operationName": "filename-conventions"
  },
  "sourceFolderName": {
    "name": "sourceFolderName",
    "slug": "TsVariable",
    "id": "tmrddpvczwmlcioytljdsyjc",
    "description": "",
    "operationName": "filename-conventions"
  },
  "temporaryConvertedSubextension": {
    "name": "temporaryConvertedSubextension",
    "slug": "TsVariable",
    "id": "skthtpmdmxqrnuqiffdkqnwo",
    "description": "This is a temporary file for conversion with ffmpeg (see ffmpeg-util)",
    "operationName": "filename-conventions"
  },
  "typescriptExtensionsConst": {
    "name": "typescriptExtensionsConst",
    "slug": "TsVariable",
    "id": "ndtkzcyvcnyjlrlccltasown",
    "description": "",
    "operationName": "filename-conventions"
  },
  "typescriptExtensions": {
    "name": "typescriptExtensions",
    "slug": "TsVariable",
    "id": "rkncdtnljsmvqxxjmmeflzgs",
    "description": "",
    "operationName": "filename-conventions"
  },
  "findAllDependencyOperations": {
    "name": "findAllDependencyOperations",
    "slug": "TsFunction",
    "id": "aeuhtqwjbqjxzsgdnghqnfnq",
    "description": "to be used when you need to know all dependencies for multiple operation names at once\n\nTODO: NB: this breaks with circular dependencies",
    "operationName": "find-all-dependency-operations",
    "rawText": " async ({\n  imports,\n  operations,\n  operationNames,\n  ignoreOperationNames,\n  ignoreFilter,\n}: {\n  /**\n   * All imports\n   */\n  imports: TsImport[];\n  operations: Operation[];\n  operationNames: string[];\n  ignoreOperationNames?: string[];\n  ignoreFilter?: (operationName: string) => boolean;\n}) => {\n  const dependencies = (\n    await oneByOne(operationNames, async (operationName) => {\n      process.stdout.write(`${operationName} ... `);\n\n      return findDependenciesRecursively(\n        imports,\n        operations,\n        operationName,\n        operationNames,\n        ignoreOperationNames,\n        ignoreFilter\n      );\n    })\n  ).flat();\n\n  return dependencies.filter(onlyUnique);\n}"
  },
  "findDependantsRecursivelyTest": {
    "name": "findDependantsRecursivelyTest",
    "slug": "TsFunction",
    "id": "xbvopvxsspitmnwzntvdfcpw",
    "description": "",
    "operationName": "find-all-dependency-operations",
    "rawText": " async () => {\n  const sdkDependants = await findDependantsRecursively(\"sdk\");\n\n  console.log({ sdkDependants });\n}"
  },
  "findDependantsRecursively": {
    "name": "findDependantsRecursively",
    "slug": "TsFunction",
    "id": "mjynkctblgykzadlxgvnigzn",
    "description": "findDependants({\n\noperationName: \"js-util\",\n\nimportName: \"notEmpty\",\n\nreturnOperationName: false,\n\n}).then(console.log);",
    "operationName": "find-all-dependency-operations",
    "rawText": " async (\n  operationName: string,\n  already?: string[]\n): Promise<string[]> => {\n  const dependantOperationNames = await findDependants({\n    returnOperationName: true,\n    operationName,\n  });\n\n  const dependantsUntilNow = [\n    operationName,\n    ...dependantOperationNames,\n    ...(already || []),\n  ];\n\n  const recursedDependants: string[] =\n    dependantOperationNames.length > 0\n      ? (\n          await Promise.all(\n            dependantOperationNames.map((name) =>\n              findDependantsRecursively(name, dependantsUntilNow)\n            )\n          )\n        ).flat()\n      : [];\n\n  return [...dependantsUntilNow, ...recursedDependants].filter(onlyUnique2());\n}"
  },
  "findDependants": {
    "name": "findDependants",
    "slug": "TsFunction",
    "id": "akkczxxbvggcfxvjdzrhfxgt",
    "description": "finds all dependants of an operation or a specific import from that operation\n\nnormally returns the files where the operation or function is used, unless you specify to return the operationNames only.",
    "operationName": "find-all-dependency-operations",
    "rawText": " async (config: {\n  operationName: string;\n  /**\n   * Optionally specify a specific import from an operation that you want to find the dependants for\n   */\n  importName?: string;\n  returnOperationName?: boolean;\n  /**\n   * For efficiency reasons you can provide precalculated imports\n   */\n  imports?: TsImport[];\n  /**\n   * If true, only external imports are found\n   */\n  onlyExternal?: boolean;\n}) => {\n  const {\n    operationName,\n    importName,\n    returnOperationName,\n    imports,\n    onlyExternal,\n  } = config;\n\n  const resultValueKey: keyof TsImport = returnOperationName\n    ? \"operationName\"\n    : \"projectRelativePath\";\n  const theImports = imports || (await db.get(\"TsImport\"));\n  const monorepoModules = theImports\n    .filter((x) => x.module === operationName)\n    .filter((x) => (importName ? x.name === importName : true))\n    .filter((x) =>\n      onlyExternal ? x.isAbsolute && x.operationName !== operationName : true\n    )\n    .map((x) =>\n      x.isModuleFromMonorepo && x.isModuleResolved ? x[resultValueKey] : null\n    )\n    .filter(notEmpty)\n    .filter(onlyUnique);\n\n  return monorepoModules;\n}"
  },
  "findDependenciesRecursively": {
    "name": "findDependenciesRecursively",
    "slug": "TsFunction",
    "id": "vgatmbwdqavbpftyypedcrdb",
    "description": "finds all dependencies of an operation name",
    "operationName": "find-all-dependency-operations",
    "rawText": " async (\n  /**\n   * all imports\n   */\n  imports: TsImport[],\n  operations: Operation[],\n  operationName: string,\n  /**\n   * skip recursing on these ones because they are already found\n   */\n  already: string[],\n  ignore?: string[],\n  ignoreFilter?: (operationName: string) => boolean\n): Promise<string[]> => {\n  if (ignore?.includes(operationName)) return [];\n\n  const packageJson = operations.find((x) => x.operationName === operationName);\n\n  if (!packageJson) {\n    console.log(\n      `WARN: couldn't find packagejson ${operationName}. weird...`,\n      operations.slice(0, 5)\n    );\n    return [];\n  }\n\n  const indirectDependencies =\n    packageJson.operation?.indirectDependencies || [];\n\n  /**\n   * Filter out ignored ones, either by ignore prop or ignore filter\n   */\n  const onlyIncluded = (operationName: string) =>\n    !ignore?.includes(operationName) &&\n    (!ignoreFilter || ignoreFilter(operationName));\n\n  const thisImports = imports.filter((x) => x.operationName === operationName);\n\n  const monorepoModules = thisImports\n    .map((x) =>\n      x.isModuleFromMonorepo && x.isModuleResolved ? x.module : null\n    )\n    .filter(notEmpty)\n    .filter(onlyIncluded)\n    // add the indirect ones\n    .concat(indirectDependencies);\n\n  const newAlready = already.concat(monorepoModules).filter(onlyUnique);\n\n  const dependencyPromises = monorepoModules\n    .filter((x) => !already?.includes(x))\n    .map((operationName) =>\n      findDependenciesRecursively(\n        imports,\n        operations,\n        operationName,\n        newAlready,\n        ignore\n      )\n    );\n  const dependencies = (await Promise.all(dependencyPromises)).flat();\n  const all: string[] = monorepoModules.concat(dependencies);\n  return all;\n}"
  },
  "findMonorepoExports": {
    "name": "findMonorepoExports",
    "slug": "TsFunction",
    "id": "tyxhtgutxecippchcxknnpte",
    "description": "",
    "operationName": "find-all-dependency-operations",
    "rawText": " (\n  allExports: TsExport[],\n  operationName: string\n): string[] => {\n  const uniqueExports = allExports\n    .filter((x) => x.operationName === operationName)\n    .filter(onlyUnique2<TsExport>((a, b) => a.name === b.name))\n    .map((x) => x.name);\n\n  return uniqueExports;\n}"
  },
  "findMonorepoImports": {
    "name": "findMonorepoImports",
    "slug": "TsFunction",
    "id": "lqecdbtmelneshcpisqqhuwl",
    "description": "finds all unique imports in an operation name",
    "operationName": "find-all-dependency-operations",
    "rawText": " (\n  allImports: TsImport[],\n  operationName: string\n) => {\n  const imports = allImports.filter((x) => x.operationName === operationName);\n\n  const monorepoModules = imports\n    .map((x) =>\n      x.isModuleFromMonorepo && x.isModuleResolved\n        ? { module: x.module, name: x.name }\n        : null\n    )\n    .filter(notEmpty)\n    .filter(\n      onlyUnique2<{ name: string; module: string }>((a, b) => a.name === b.name)\n    );\n\n  return monorepoModules;\n}"
  },
  "findMonorepoModules": {
    "name": "findMonorepoModules",
    "slug": "TsFunction",
    "id": "irptpducmakzvowmwxzvbazn",
    "description": "finds all dependencies of an operation name",
    "operationName": "find-all-dependency-operations",
    "rawText": " async (\n  allImports: TsImport[],\n  operationName: string\n) => {\n  const imports = allImports.filter((x) => x.operationName === operationName);\n\n  const monorepoModules = imports\n    .map((x) =>\n      x.isModuleFromMonorepo && x.isModuleResolved ? x.module : null\n    )\n    .filter(notEmpty)\n    .filter(onlyUnique);\n\n  return monorepoModules;\n}"
  },
  "getDependencyObject": {
    "name": "getDependencyObject",
    "slug": "TsFunction",
    "id": "agobryiqzsdkrafmlbnwrkvy",
    "description": "findAllDependencyOperations([\"fs-orm\"]).then(console.log);\n\nhow do I get a format like this?\n\nconst x = {\n\n\"fs-orm\": [\"js-util\"],\n\n\"js-util\": [],\n\n}",
    "operationName": "find-all-dependency-operations",
    "rawText": " async () => {\n  const allOperations = await exploreOperationFolders({});\n  const allImports = await db.get(\"TsImport\");\n\n  const dependencyObject = mergeObjectsArray(\n    await Promise.all(\n      allOperations.map(async (operationFolderPath) => {\n        const operationName = getLastFolder(operationFolderPath);\n        const monorepoModules = await findMonorepoModules(\n          allImports,\n          operationName\n        );\n\n        return { [operationName]: monorepoModules };\n      })\n    )\n  );\n\n  return dependencyObject;\n}"
  },
  "getDependencyTree": {
    "name": "getDependencyTree",
    "slug": "TsFunction",
    "id": "efanuzmytdyfffcecbwreake",
    "description": "",
    "operationName": "find-all-dependency-operations",
    "rawText": " async (\n  allImports: TsImport[],\n  allExports: TsExport[],\n  operationName: string,\n  usedImports: string[],\n  alreadySearched: string[] = []\n): Promise<DependencyTreeChildObject> => {\n  console.log(operationName);\n  const uniqueExportedNames = findMonorepoExports(allExports, operationName);\n\n  const allMonorepoImports = findMonorepoImports(allImports, operationName);\n  const newStack = alreadySearched.concat(operationName);\n\n  const newImportsPerModule = allMonorepoImports\n    .map((x) => x.module)\n    .filter(onlyUnique2())\n    .map((operationName) => {\n      return {\n        operationName,\n        importNames: allMonorepoImports\n          .filter((x) => x.module === operationName)\n          .map((x) => x.name),\n      };\n    });\n\n  const children: DependencyTreeChildObject[] = (\n    await Promise.all(\n      newImportsPerModule.map((perModule) =>\n        // don't go infinite recursion\n        newStack.includes(perModule.operationName)\n          ? undefined\n          : getDependencyTree(\n              allImports,\n              allExports,\n              perModule.operationName,\n              perModule.importNames,\n              newStack\n            )\n      )\n    )\n  ).filter(notEmpty);\n\n  const object: DependencyTreeChildObject = {\n    operationName,\n    dependencyCount: children.length,\n    usedExportsCount: usedImports.length,\n    allExportsCount: uniqueExportedNames.length,\n    cumulativeExportsCount:\n      sum(children.map((x) => x.cumulativeExportsCount)) +\n      uniqueExportedNames.length,\n    cumulativeUsedExportsCount:\n      usedImports.length +\n      sum(children.map((x) => x.cumulativeUsedExportsCount)),\n    usedExports: usedImports,\n    // allExports: uniqueExportedNames,\n    children,\n  };\n\n  return object;\n}"
  },
  "getOldDependencyTree": {
    "name": "getOldDependencyTree",
    "slug": "TsFunction",
    "id": "hlezuskidjnykaqkvnjjkbva",
    "description": "",
    "operationName": "find-all-dependency-operations",
    "rawText": " async (\n  operationNames: string[],\n  stack: string[]\n): Promise<DependencyTree | null> => {\n  if (operationNames.length === 0) return null;\n  const allImports = await db.get(\"TsImport\");\n\n  const dependencyTree = mergeObjectsArray(\n    await Promise.all(\n      operationNames.map(async (name) => {\n        const deps = await findMonorepoModules(allImports, name);\n        const newStack = stack.concat(name);\n        const filtered = deps.filter((dep) => !newStack.includes(dep));\n        const filteredOut = deps.filter((dep) => newStack.includes(dep));\n        if (deps.length !== filtered.length) {\n          console.log(\n            `prevented circular dependency at ${name} (${filteredOut.join(\n              \", \"\n            )} were removed)`\n          );\n        }\n        return {\n          [name]: await getOldDependencyTree(filtered, newStack),\n        };\n      })\n    )\n  );\n\n  return dependencyTree;\n}"
  },
  "getOperationDependencyReasons": {
    "name": "getOperationDependencyReasons",
    "slug": "TsFunction",
    "id": "ppnpglnhwfpgfxrazsfobadb",
    "description": "",
    "operationName": "find-all-dependency-operations",
    "rawText": " async () => {\n  const tsImports = await db.get(\"TsImport\");\n  const operations = await db.get(\"Operation\");\n  const tsFunctions = await db.get(\"TsFunction\");\n  const tsInterfaces = await db.get(\"TsInterface\");\n\n  const result = operations.map((operation) => {\n    const packageJsonDependencies = operation.dependencies\n      ? Object.keys(operation.dependencies)\n      : undefined;\n\n    const operationImports = tsImports\n      .filter((x) => x.operationName === operation.name)\n      .filter((x) => x.isModuleResolved && x.isAbsolute);\n\n    const instances: (TsFunction | TsInterface)[] = [\n      ...tsFunctions,\n      ...tsInterfaces,\n    ];\n\n    const operationInstances = instances.filter(\n      (x) => x.operationName === operation.name\n    );\n\n    const instancesAndTheirImports = operationInstances.map((tsFunction) => {\n      return {\n        name: tsFunction.name,\n        fileName: tsFunction.operationRelativeTypescriptFilePath,\n        imports: operationImports\n          .filter(\n            (x) =>\n              x.operationRelativeTypescriptFilePath ===\n              tsFunction.operationRelativeTypescriptFilePath\n          )\n          .map((x) => `${x.name} from ${x.module}`),\n      };\n    });\n\n    const importDependencies = operationImports\n      .filter(onlyUnique2<TsImport>((a, b) => a.module === b.module))\n      .map((x) => x.module);\n\n    const result = {\n      operationName: operation.name,\n      totalInstancesCount: operationInstances.length,\n      totalImportCount: operationImports.length,\n      totalDependencyCount: importDependencies.length,\n      importDependencies,\n      packageJsonDependencies,\n      instancesAndTheirImports,\n    };\n\n    return result;\n  });\n\n  const getImportDependenciesRecurisve = (\n    array: any[],\n    operationName: string,\n    already: string[] = []\n  ): string[] => {\n    const now: string[] =\n      array.find((x) => x.operationName === operationName)\n        ?.importDependencies || [];\n\n    const filtered = now.filter((x) => !already.includes(x));\n\n    if (filtered.length !== now.length) {\n      console.log(\"circular skipped\");\n    }\n\n    const importDependencies: string[] = filtered\n      .map((x) =>\n        getImportDependenciesRecurisve(array, x, [...already, ...filtered])\n      )\n      .flat();\n\n    return [operationName, ...importDependencies].filter(onlyUnique2());\n  };\n\n  const withCumulative = result.map((item, index, array) => {\n    const cumulativeDependencies = getImportDependenciesRecurisve(\n      array,\n      item.operationName\n    );\n    return { ...item, cumulativeDependencies };\n  });\n\n  return withCumulative;\n}"
  },
  "[operationName]": {
    "name": "[operationName]",
    "slug": "TsVariable",
    "id": "dxwggcqwnljnfhthbhwqgrqu",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "test2": {
    "name": "test2",
    "slug": "TsFunction",
    "id": "zwhcacxmranujwnxvequiail",
    "description": "",
    "operationName": "read-kvmd-file",
    "rawText": " async () => {\n  const absolutePath = path.join(__dirname, \"..\", \"assets\", \"test.json\");\n\n  const kvmdParse = await readJsonFile<KeyValueMarkdownParse>(absolutePath);\n\n  if (!kvmdParse) {\n    console.log(\"reading json file failed\");\n    return;\n  }\n\n  const string = kvmdParseToMarkdownString(kvmdParse);\n\n  await writeStringToFile(\n    absolutePath.replace(\"test.json\", \"stringifiedTest.md\"),\n    string\n  );\n}"
  },
  "folderGetUpdatedAt": {
    "name": "folderGetUpdatedAt",
    "slug": "TsFunction",
    "id": "duqitdblzbonkmbglxosleet",
    "description": "get last updated file updatedAt time in whole folder, recursively. only finds typescript files, ignores index.",
    "operationName": "folder-get-updated-at",
    "rawText": " async (config: {\n  folderPath: string;\n}): Promise<number> => {\n  const { folderPath } = config;\n  const typescriptFiles = await getFolderTypescriptFiles(folderPath, true);\n  return typescriptFiles.reduce((updatedAt, file) => {\n    const fileUpdatedAt = file.stats?.updatedAt;\n    if (!fileUpdatedAt) return updatedAt;\n    if (fileUpdatedAt > updatedAt) return fileUpdatedAt;\n    return updatedAt;\n  }, 0);\n}"
  },
  "frontmatterParseToString": {
    "name": "frontmatterParseToString",
    "slug": "TsFunction",
    "id": "aeijmgnspshklzjxrxbkhrbd",
    "description": "Parses frontmatter object into a frontmatter string",
    "operationName": "frontmatter-util",
    "rawText": " (frontmatter: Frontmatter): string => {\n  const keys = Object.keys(frontmatter);\n\n  const keyValueLines = keys\n    .map((key) => {\n      const value = frontmatter[key];\n\n      const parsedFrontmatterLine = `${key}: ${value}`;\n\n      return parsedFrontmatterLine;\n    })\n    .filter(notEmpty);\n\n  return keyValueLines.length === 0\n    ? \"\"\n    : `---\\n${keyValueLines.join(\"\\n\")}\\n---\\n`;\n}"
  },
  "frontmatterToObject": {
    "name": "frontmatterToObject",
    "slug": "TsFunction",
    "id": "ispwoesqapdzynegemylpoao",
    "description": "",
    "operationName": "frontmatter-util",
    "rawText": " (\n  frontmatter: Frontmatter,\n  schema: SimplifiedSchema\n): FrontmatterParse => {\n  if (!schema.properties || !schema.properties.length) {\n    return {};\n  }\n\n  const valueObjectArray: { [key: string]: any }[] = schema.properties\n    .map((property) => {\n      const value = frontmatter[property.name]\n        ? frontmatter[property.name].trim()\n        : undefined;\n\n      if (value === undefined) return;\n\n      const assetInputType = getAssetInputType(property.name);\n\n      if (\n        (property.schema.type === \"object\" ||\n          property.schema.type === \"array\") &&\n        assetInputType?.type\n      ) {\n        // it's a backendAsset\n\n        const backendAssets: BackendAsset[] = findEmbeds(value).map((x) => {\n          return { alt: x.alt, relativePath: x.src };\n        });\n\n        if (backendAssets.length === 0) return;\n\n        if (assetInputType.isMultiple) {\n          return { [property.name]: backendAssets };\n        }\n\n        return { [property.name]: backendAssets[0] };\n      }\n\n      if (property.schema.type === \"number\" && property.name.endsWith(\"At\")) {\n        const unixTimestamp = tryParseDate(value);\n\n        return { [property.name]: unixTimestamp };\n      }\n\n      if (property.schema.type === \"boolean\") {\n        if (value === \"true\") return { [property.name]: true };\n        if (value === \"false\") return { [property.name]: false };\n        return;\n      }\n\n      if (property.schema.type === \"number\") {\n        const number = Number(value);\n\n        if (isNaN(number)) return;\n\n        return { [property.name]: number };\n      }\n\n      if (property.schema.type === \"null\") {\n        if (value !== \"null\") {\n          return;\n        }\n\n        return { [property.name]: null };\n      }\n\n      if (property.schema.type === \"string\") {\n        return { [property.name]: parseFrontmatterString(value) };\n      }\n\n      if (property.schema.type === \"array\") {\n        // turn into comma separated\n        // Let's only support string[] for now!\n\n        const itemString = value\n          .split(\",\")\n          .map((x) => x.trim())\n          .map(parseFrontmatterString);\n\n        return { [property.name]: itemString };\n      }\n\n      if (property.schema.type === \"object\") {\n        // should not be supported\n        return;\n      }\n\n      return;\n    })\n    .filter(notEmpty);\n\n  const parse = mergeObjectsArray(valueObjectArray);\n\n  return parse;\n}"
  },
  "getFrontmatterValueString": {
    "name": "getFrontmatterValueString",
    "slug": "TsFunction",
    "id": "dsuouzslmsjggwferwrxplly",
    "description": "",
    "operationName": "frontmatter-util",
    "rawText": " (\n  value: FrontmatterValue\n): string | null => {\n  if (value === undefined) return null;\n  if (value === null) return \"null\";\n  if (typeof value === \"number\") return String(value);\n  if (typeof value === \"boolean\") return String(value);\n  if (typeof value === \"boolean\") return String(value);\n  if (Array.isArray(value))\n    return value.map(quotedOrNot).map(stringifyNewlines).join(\", \");\n  if (typeof value === \"string\") return stringifyNewlines(quotedOrNot(value));\n  // NB: according to current support this should never happen\n  if (typeof value === \"object\") return `\"${JSON.stringify(value)}\"`;\n\n  return null;\n}"
  },
  "markdownModelTypeToMarkdownString": {
    "name": "markdownModelTypeToMarkdownString",
    "slug": "TsFunction",
    "id": "kedwfpdbfuactcqeqeaayzyp",
    "description": "",
    "operationName": "frontmatter-util",
    "rawText": " (\n  markdownModelType: Storing<MarkdownModelType>\n): string => {\n  const { markdown, ...parameters } = markdownModelType;\n  const frontmatterString = frontmatterParseToString(parameters);\n  return `${frontmatterString}\\n${markdown}`;\n}"
  },
  "objectToFrontmatter": {
    "name": "objectToFrontmatter",
    "slug": "TsFunction",
    "id": "blvjlpufjzgxcxyyogdzgknb",
    "description": "",
    "operationName": "frontmatter-util",
    "rawText": " (\n  parse: FrontmatterParse,\n  schema: SimplifiedSchema\n): Frontmatter => {\n  if (!schema.properties || !schema.properties.length) {\n    return {};\n  }\n\n  const propertyStringValueArray: { [key: string]: string }[] =\n    schema.properties\n      .map((property) => {\n        const value = parse[property.name];\n\n        const assetInputType = getAssetInputType(property.name);\n\n        if (\n          (property.schema.type === \"object\" ||\n            property.schema.type === \"array\") &&\n          assetInputType?.type\n        ) {\n          // it's a backendAsset\n\n          const realValue = value as BackendAsset | BackendAsset[] | undefined;\n\n          if (!realValue || typeof realValue !== \"object\") {\n            // must be an array or object, otherwise it's set to nothing\n            return;\n          }\n\n          const backendAssets = makeArray(realValue);\n\n          return {\n            [property.name]: backendAssets\n              .map((backendAsset) => {\n                return `![${backendAsset.alt || \"\"}](${\n                  backendAsset.relativePath || \"\"\n                })`;\n              })\n              .join(\", \"),\n          };\n        }\n\n        if (property.schema.type === \"number\" && property.name.endsWith(\"At\")) {\n          if (typeof value !== \"number\" || (!value && value !== 0)) {\n            // we can only process numbers\n            return;\n          }\n\n          // it's a date, convert to date\n\n          const humanReadableDate = new Date(value).toDateString();\n          return { [property.name]: humanReadableDate };\n        }\n\n        if (property.schema.type === \"boolean\") {\n          if (value === true) return { [property.name]: \"true\" };\n          if (value === false) return { [property.name]: \"false\" };\n          return;\n        }\n\n        if (property.schema.type === \"number\") {\n          if (typeof value !== \"number\" || (!value && value !== 0)) {\n            // we can only process numbers\n            return;\n          }\n\n          return { [property.name]: String(value) };\n        }\n\n        if (property.schema.type === \"null\") {\n          if (value !== null) {\n            return;\n          }\n\n          return { [property.name]: \"null\" };\n        }\n\n        if (property.schema.type === \"string\") {\n          if (typeof value !== \"string\") {\n            return;\n          }\n          return { [property.name]: quotedOrNot(stringifyNewlines(value)) };\n        }\n\n        if (property.schema.type === \"array\") {\n          // turn into comma separated\n\n          if (!Array.isArray(value)) {\n            return;\n          }\n\n          // Let's only support string[] for now!\n          //   const type = property.schema.items?.map(x=>x.schema)?.[0]\n\n          const itemString = value\n            .map((item: any) => {\n              if (typeof item !== \"string\") return;\n\n              return quotedOrNot(stringifyNewlines(item));\n            })\n            .filter(notEmpty)\n            .join(\", \");\n\n          return { [property.name]: itemString };\n        }\n\n        if (property.schema.type === \"object\") {\n          // should not be supported\n          return;\n        }\n\n        return;\n      })\n      .filter(notEmpty);\n\n  const frontmatter = mergeObjectsArray(propertyStringValueArray);\n\n  return frontmatter;\n}"
  },
  "parseFrontmatterString": {
    "name": "parseFrontmatterString",
    "slug": "TsFunction",
    "id": "rjbnwvwzoghkkjcchcjgycud",
    "description": "Parse a string as stored in frontmatter back to the original string",
    "operationName": "frontmatter-util",
    "rawText": " (value: string) => {\n  const withoutQuotes = value.includes(\",\")\n    ? value.substring(1, value.length - 1)\n    : value;\n\n  const withNewlines = withoutQuotes.replaceAll(\"\\\\n\", \"\\n\");\n\n  return withNewlines;\n}"
  },
  "quotedOrNot": {
    "name": "quotedOrNot",
    "slug": "TsFunction",
    "id": "vnfmxmrdhemzgqpwuxxortdu",
    "description": "For now, simply quote a string if it contains commas\n\nThere are probably more edgecases that need to be fixed here",
    "operationName": "frontmatter-util",
    "rawText": " (string: string) => {\n  const returnString = string?.includes(\",\") ? `\"${string}\"` : string;\n  return returnString;\n}"
  },
  "stringifyNewlines": {
    "name": "stringifyNewlines",
    "slug": "TsFunction",
    "id": "kunkkyzcyndopjylytvakdvt",
    "description": "",
    "operationName": "frontmatter-util",
    "rawText": " (string: string) => {\n  return string.replaceAll(\"\\n\", \"\\\\n\");\n}"
  },
  "addDefaultValues": {
    "name": "addDefaultValues",
    "slug": "TsFunction",
    "id": "bhrsfiaickszsgyizacxckxr",
    "description": "Adds timestamps, id, and a slug IF these things are not already present\n\nNB: slugs will be slugified here!\nNB: if there is a name present, slug will be added here!\n\nNB: for kvmd storage, id will be set to a kebab-case of the name\n\nNB: does not add the ModelLocation parameters",
    "operationName": "fs-orm",
    "rawText": " (\n  bareItem: Creation<AugmentedAnyModelType>,\n  isKvmdStorage?: boolean\n): AugmentedAnyModelType => {\n  const now = Date.now();\n\n  const defaultValues = {\n    createdAt: now,\n    updatedAt: now,\n    deletedAt: 0,\n    createdFirstAt: now,\n  };\n\n  const shouldCreateSlugFromName =\n    !!bareItem.name && bareItem.slug === undefined;\n\n  const slugifiedSlug = bareItem.slug ? slugify(bareItem.slug) : undefined;\n\n  const isValidSlug =\n    bareItem.slug === undefined || slugifiedSlug === bareItem.slug;\n\n  if (!isValidSlug) {\n    log(\n      `${bareItem.slug} is not a slugified slug, it has been altered to a valid slug`,\n      { type: \"warning\" }\n    );\n  }\n\n  const slug: string | undefined = shouldCreateSlugFromName\n    ? slugify(bareItem.name)\n    : slugifiedSlug;\n\n  const id =\n    bareItem.id === undefined\n      ? isKvmdStorage\n        ? kebabCase(bareItem.name)\n        : generateId()\n      : bareItem.id;\n\n  const item = {\n    ...defaultValues,\n    ...bareItem,\n    slug,\n    id,\n  } as AugmentedAnyModelType;\n\n  return item;\n}"
  },
  "alterAny": {
    "name": "alterAny",
    "slug": "TsFunction",
    "id": "umcwozyriwhvrkprxigqjigp",
    "description": "low level function that alters data from any storage method at a certain location\n\ncomprises all dbStorageMethods",
    "operationName": "fs-orm",
    "rawText": " async (\n  dbStorageMethod: DbStorageMethod,\n  ...alterParameters: AlterParameters\n): Promise<DbQueryResult> => {\n  if (dbStorageMethod === \"csv\") return alterCsv(...alterParameters);\n  if (dbStorageMethod === \"jsonSingle\")\n    return alterJsonSingle(...alterParameters);\n  if (dbStorageMethod === \"keyValueMarkdown\") {\n    // this case never happens, this is never the case\n    log(\"Wut??? this case should be prevented by its parent function\", {\n      type: \"warning\",\n    });\n    return alterKeyValueMarkdown(...alterParameters);\n  }\n  if (dbStorageMethod === \"markdown\") return alterMarkdown(...alterParameters);\n  return alterJsonMultiple(...alterParameters);\n}"
  },
  "alterCsv": {
    "name": "alterCsv",
    "slug": "TsFunction",
    "id": "tzpdnxbgzzzzwpwaqthnwstm",
    "description": "Alters a csv",
    "operationName": "fs-orm",
    "rawText": " async (dbFileLocation, alterFn) => {\n  const { absolutePath } = dbFileLocation;\n  const bareData =\n    (await readCsvFile<Storing<CsvItemType>>(absolutePath)) || [];\n  const isNewFile = !bareData;\n  const { newStoredData, ...queryResult } = alterFn(bareData);\n  if (newStoredData.length === 0 && !!bareData) {\n    // NB: if new array is empty, just remove the file\n    await fs.rm(absolutePath);\n    return queryResult;\n  }\n\n  const newDataString = csvItemArrayToCsvString(newStoredData);\n  const isSuccesful = await writeStringToFile(absolutePath, newDataString);\n  if (!isSuccesful) return { isSuccesful, message: \"Could not write to file\" };\n  return {\n    isNewFile,\n    isSuccesful,\n    ...queryResult,\n  };\n}"
  },
  "alterJsonMultiple": {
    "name": "alterJsonMultiple",
    "slug": "TsFunction",
    "id": "jgihjzwpykxselxmzkbvinle",
    "description": "Alters a json multiple file",
    "operationName": "fs-orm",
    "rawText": " async (\n  dbFileLocation,\n  alterFn\n) => {\n  const { absolutePath } = dbFileLocation;\n  const storedJson = await readJsonFile<Storing<AugmentedAnyModelType>[]>(\n    dbFileLocation.absolutePath\n  );\n\n  const storedData = storedJson || [];\n\n  const isNewFile = !storedJson;\n  const { newStoredData, ...queryResult } = alterFn(storedData);\n\n  if (newStoredData.length === 0 && !!storedJson) {\n    // NB: if new stored data is an empty array, just remove the file\n    await fs.rm(absolutePath);\n    return { isNewFile: false, ...queryResult };\n  }\n\n  const isSuccesful = await writeJsonToFile(absolutePath, newStoredData);\n\n  if (!isSuccesful) return { isSuccesful, message: \"Could not write to file\" };\n  return {\n    isNewFile,\n    isSuccesful,\n    ...queryResult,\n  };\n}"
  },
  "alterJsonSingle": {
    "name": "alterJsonSingle",
    "slug": "TsFunction",
    "id": "wqqvqtzyfsslmkvxwasnmlfn",
    "description": "Alters a json single file",
    "operationName": "fs-orm",
    "rawText": " async (\n  dbFileLocation,\n  alterFn\n) => {\n  const { absolutePath } = dbFileLocation;\n  const storedJson = await readJsonFile<Storing<AugmentedAnyModelType>>(\n    dbFileLocation.absolutePath\n  );\n  const isNewFile = !storedJson;\n  const storedData = storedJson ? [storedJson] : [];\n  const { newStoredData, ...queryResult } = alterFn(storedData);\n\n  const isSuccesful = await writeJsonToFile(absolutePath, newStoredData[0]);\n\n  if (!isSuccesful) return { isSuccesful, message: \"Could not write to file\" };\n  return {\n    isNewFile,\n    isSuccesful,\n    ...queryResult,\n  };\n}"
  },
  "alterKeyValueMarkdown": {
    "name": "alterKeyValueMarkdown",
    "slug": "TsFunction",
    "id": "tcvvuguvfohrjtxgrmiyzpen",
    "description": "",
    "operationName": "fs-orm",
    "rawText": " async (\n  dbFileLocation,\n  alterFn\n) => {\n  const { absolutePath } = dbFileLocation;\n\n  const kvmdParse: KeyValueMarkdownParse | null = await readKvmdFile(\n    absolutePath,\n    dbFileLocation\n  );\n\n  const isNewFile = !kvmdParse;\n\n  const storedData = kvmdParse?.data || [];\n\n  // console.log({ storedData });\n  const { newStoredData, ...queryResult } = alterFn(storedData);\n  // console.log({ newStoredData });\n  const newKvmdParse: KeyValueMarkdownParse = {\n    parameters: kvmdParse?.parameters || {},\n    data: newStoredData as KeyValueMarkdownModelType[],\n  };\n\n  const newDataString = kvmdParseToMarkdownString(newKvmdParse);\n  const isSuccesful = await writeStringToFile(absolutePath, newDataString);\n\n  if (!isSuccesful) return { isSuccesful, message: \"Could not write to file\" };\n  return {\n    isNewFile,\n    isSuccesful,\n    ...queryResult,\n  };\n}"
  },
  "alterMarkdown": {
    "name": "alterMarkdown",
    "slug": "TsFunction",
    "id": "zpkhumhnajokrbcgjmhnnntb",
    "description": "Alters a markdown file",
    "operationName": "fs-orm",
    "rawText": " async (dbFileLocation, alterFn) => {\n  const { absolutePath } = dbFileLocation;\n  const markdownParse = await readMarkdownFile(absolutePath);\n  const isNewFile = !markdownParse;\n  const markdownModelItem = markdownParseToMarkdownModelType(markdownParse);\n\n  const storedData = markdownModelItem ? [markdownModelItem] : [];\n  const { newStoredData, ...queryResult } = alterFn(storedData);\n  const finalItem: Storing<MarkdownModelType> = newStoredData[0];\n  const markdownString = markdownModelTypeToMarkdownString(finalItem);\n  const isSuccesful = await writeStringToFile(absolutePath, markdownString);\n\n  if (!isSuccesful) return { isSuccesful, message: \"Could not write to file\" };\n  return {\n    isNewFile,\n    isSuccesful,\n    ...queryResult,\n  };\n}"
  },
  "augmentItemWithReferencedDataRecursively": {
    "name": "augmentItemWithReferencedDataRecursively",
    "slug": "TsFunction",
    "id": "lsblynaciqmerfsxeiibbdkt",
    "description": "",
    "operationName": "fs-orm",
    "rawText": " (\n  item: AugmentedAnyModelType,\n\n  includeArray: Include[],\n  /**\n   * Final includeData object to take items from\n   */\n  includeData: IncludeDataObject\n): AugmentedAnyModelType => {\n  // basecase\n  if (includeArray.length === 0) {\n    return item;\n  }\n\n  const newItem = includeArray.reduce((itemNow, include) => {\n    if (!include.referenceKey) return itemNow;\n\n    const parameterInfo = getReferenceParameterInfo(include.referenceKey);\n\n    if (!parameterInfo.interfaceName) return itemNow;\n\n    const referencedItems = includeData[parameterInfo.interfaceName];\n\n    if (!referencedItems) return itemNow;\n    if (!parameterInfo.dataParameterName) return itemNow;\n    if (!parameterInfo.keyInModel) return itemNow;\n\n    const referenceItems = referencedItems.filter((x) => {\n      if (!parameterInfo.keyInModel) return false;\n      const itemReference: string | string[] | undefined =\n        itemNow[parameterInfo.parameterName];\n      const referenceItemReference = (x as any)[parameterInfo.keyInModel];\n\n      const isMatchingReference = parameterInfo.isReferenceSingleParameter\n        ? itemReference === referenceItemReference\n        : parameterInfo.isReferenceMultipleParameter\n        ? itemReference?.includes?.(referenceItemReference) || false\n        : false;\n\n      return isMatchingReference;\n    });\n\n    const augmentedReferenceData:\n      | AugmentedAnyModelType\n      | AugmentedAnyModelType[]\n      | undefined = parameterInfo.isReferenceSingleParameter\n      ? augmentItemWithReferencedDataRecursively(\n          referenceItems[0],\n          makeArray(include.include),\n          includeData\n        )\n      : parameterInfo.isReferenceMultipleParameter\n      ? referenceItems.map((i) =>\n          augmentItemWithReferencedDataRecursively(\n            i,\n            makeArray(include.include),\n            includeData\n          )\n        )\n      : undefined;\n\n    const newItemNow: AugmentedAnyModelType = {\n      ...itemNow,\n      [parameterInfo.dataParameterName]: augmentedReferenceData,\n    };\n\n    return newItemNow;\n  }, item);\n\n  return newItem;\n}"
  },
  "calculateOperationsObject": {
    "name": "calculateOperationsObject",
    "slug": "TsFunction",
    "id": "anyqmcidropciuygtxmfluxx",
    "description": "relative\n\nNeeded in case of manual project root, otherwise use SDK!\n\nReturns project relative operation base paths",
    "operationName": "fs-orm",
    "rawText": " async (manualProjectRoot: string) => {\n  const operationBasePaths = await exploreOperationFolders({\n    basePath: getPathsWithOperations({ manualProjectRoot }),\n  });\n\n  const operationsObject = mergeObjectsArray(\n    operationBasePaths.map((operationBasePath) => {\n      return {\n        [getLastFolder(operationBasePath)]: makeRelative(\n          operationBasePath,\n          manualProjectRoot\n        ),\n      };\n    })\n  );\n\n  return operationsObject;\n}"
  },
  "categoryStack": {
    "name": "categoryStack",
    "slug": "TsVariable",
    "id": "ioopqetaioyfyxatdzdmvugf",
    "description": "",
    "operationName": "fs-orm"
  },
  "createDb": {
    "name": "createDb",
    "slug": "TsFunction",
    "id": "hnaeqamegtvzaorclvhbjiaq",
    "description": "Create your database by passing your models as a generic and some optional configuration",
    "operationName": "fs-orm",
    "rawText": " <TModels extends AnyModelObject>(\n  dbConfig?: DbConfig<TModels>\n): Db<TModels> => {\n  // need to get\n\n  const getDbFileLocationPath = async (\n    storedItem: Storing<AugmentedAnyModelType>,\n    operationName: string | null,\n    modelName: Extract<keyof TModels, string>,\n    config: CustomQueryConfig\n  ) => {\n    const mergedQueryConfig = mergeConfigs(modelName, dbConfig, config);\n\n    const result = await getDbFileLocation(\n      storedItem,\n      operationName,\n      mergedQueryConfig,\n      modelName\n    );\n\n    return result?.absolutePath;\n  };\n\n  const getByFile = async <TModelName extends Keys<TModels>>(\n    modelName: TModelName,\n    config?: GetQueryConfig<TModels[TModelName]>\n  ) => {\n    const executionId = generateUniqueId();\n    const performance: (PerformanceItem | undefined)[] = [];\n\n    getNewPerformance(\"start\", executionId, true);\n\n    const mergedQueryConfig = mergeConfigs(modelName, dbConfig, config);\n    performance.push(getNewPerformance(\"mergeConfigs\", executionId));\n\n    const dbFiles = await getDatabaseFiles(modelName, mergedQueryConfig);\n    performance.push(getNewPerformance(\"getDatabaseFiles\", executionId));\n\n    // console.log(\"getByFile\", {\n    //   modelName,\n    //   mergedQueryConfig,\n    //   dbFiles: dbFiles.length,\n    // });\n\n    /**\n     * An object used for attaching all referenced data onto the model, recursively\n     */\n    let includeData: IncludeDataObject = {};\n\n    /**\n     * A recursive function that takes an Include and adds data to includeData, if it's not already there\n     */\n    const processInclude = async (includeConfig: Include) => {\n      if (!includeConfig.referenceKey) return;\n\n      const parameterInfo = getReferenceParameterInfo(\n        includeConfig.referenceKey\n      );\n\n      if (!parameterInfo.isReferenceParameter || !parameterInfo.interfaceName)\n        return;\n\n      if (!includeData[parameterInfo.interfaceName]) {\n        const includeThisData = await get(\n          parameterInfo.interfaceName as Keys<TModels>,\n          { manualProjectRoot: mergedQueryConfig.manualProjectRoot }\n        );\n        includeData[parameterInfo.interfaceName] = includeThisData;\n      }\n\n      if (includeConfig.include) {\n        // Recursively process all includes as well\n        const includeArray = makeArray(includeConfig.include);\n        await Promise.all(includeArray.map(processInclude));\n      }\n    };\n\n    // NB: for auto we need to do it per file because we don't know exactly which keys exist on the model yet\n    const isAuto: boolean =\n      config?.include && !Array.isArray(config.include)\n        ? config.include.auto === true\n          ? true\n          : false\n        : false;\n\n    // NB: Create an includeArray or fill the includeData object\n    const includeArray: Include[] =\n      isAuto || !config?.include ? [] : makeArray(config?.include);\n    await Promise.all(includeArray.map(processInclude));\n\n    performance.push(getNewPerformance(\"processInclude\", executionId));\n\n    const dbContentPromises = dbFiles.map(async (dbFileLocation) => {\n      const items = await getAugmentedData<TModels[TModelName]>(\n        dbFileLocation,\n        mergedQueryConfig.dbStorageMethod\n      );\n      if (!items) return;\n\n      const filteredItems = config?.filter\n        ? items.filter(config.filter)\n        : items;\n\n      let augmentedItems: TModels[TModelName][] = includeArray\n        ? filteredItems.map(\n            (item) =>\n              augmentItemWithReferencedDataRecursively(\n                item,\n                includeArray,\n                includeData\n              ) as TModels[TModelName]\n          )\n        : filteredItems;\n\n      if (isAuto) {\n        /**\n        TODO: \n\n        Go over all keys in the first item of augmentedItems, and see if it contains reference keys.\n\n        For every reference key, create an `Include`. call `includes.map(processInclude)`\n        \n        Call augmentItemRecursively with the includes.\n\n        */\n        log(\"auto is not supported yet\", { type: \"warning\" });\n        augmentedItems = augmentedItems;\n      }\n\n      return { [dbFileLocation.absolutePath]: augmentedItems };\n    });\n\n    performance.push(getNewPerformance(\"dbContentPromises\", executionId));\n\n    const dbContent = (await Promise.all(dbContentPromises)).filter(notEmpty);\n\n    performance.push(getNewPerformance(\"dbContent\", executionId));\n\n    const dbContentObject = mergeObjectsArray(dbContent);\n\n    performance.push(getNewPerformance(\"dbContentObject\", executionId));\n\n    // console.log(\"get performance\", performance);\n\n    cleanupTimer(executionId);\n\n    // console.log({ dbContentObject });\n    return dbContentObject;\n  };\n\n  const get: DbGet<TModels> = async <TModelName extends Keys<TModels>>(\n    modelName: TModelName,\n    config?: GetQueryConfig<TModels[TModelName]>\n  ) => {\n    const items = (\n      Object.values(\n        await getByFile(modelName, config)\n      ) as TModels[TModelName][][]\n    ).flat();\n    return items;\n  };\n\n  /**\n   *\n   */\n  const clear = async <TModelName extends Keys<TModels>>(\n    modelName: TModelName,\n    config?: CustomQueryConfig\n  ) => {\n    const mergedConfig = mergeConfigs(modelName, dbConfig, config);\n    const locations = await getDatabaseFiles(modelName, mergedConfig);\n\n    await mapMany(\n      locations,\n      async (loc) => fs.existsSync(loc.absolutePath) && fs.rm(loc.absolutePath),\n      maxConcurrency\n    );\n\n    return {\n      amountRemoved: locations.length,\n      isSuccesful: true,\n      message: `${locations.length} files removed`,\n    };\n  };\n\n  /**\n   * It seems problematic to remove a file temporarily because other query's may require it to be there.\n   */\n  const set: DbSet<TModels> = async <TModelName extends Keys<TModels>>(\n    modelName: TModelName,\n    data: Creation<TModels[TModelName]>[],\n    config?: CustomQueryConfig\n  ) => {\n    const mergedConfig = mergeConfigs(modelName, dbConfig, config);\n    const { dbStorageMethod } = mergedConfig;\n\n    const itemsPerFile = await groupByFile(data, mergedConfig, modelName);\n    const newFilePaths = Object.keys(itemsPerFile);\n    const oldLocations = await getDatabaseFiles(modelName, mergedConfig);\n    const removableLocations = oldLocations.filter(\n      (x) => !newFilePaths.includes(x.absolutePath)\n    );\n\n    // Then, if there are new items for that file location, also set that file to contain the new items\n\n    const upsertResults = (\n      await mapMany(newFilePaths, async (fileKey) => {\n        const value = itemsPerFile[fileKey];\n\n        if (!value) return;\n\n        const { dbFileLocation, items } = value;\n\n        log(`set new values to there: ${items.length}`, {\n          type: \"debug\",\n        });\n        // if the item-array is empty, upsert nothing.\n        if (items.length === 0) return;\n\n        const result = await upsertItems<TModels, TModelName>(\n          dbStorageMethod,\n          dbFileLocation,\n          items\n        );\n\n        return result;\n      })\n    ).filter(notEmpty);\n    if (removableLocations.length) {\n      console.log({\n        removableLocations,\n        oldLocations,\n        itemsPerFile,\n        newFilePaths,\n        data,\n      });\n    }\n    await mapMany(\n      removableLocations,\n      async (dbFileLocation) => {\n        // First remove the file\n        if (fs.existsSync(dbFileLocation.absolutePath)) {\n          log(`Removing ${dbFileLocation.absolutePath}`, { type: \"warning\" });\n          await fs.rm(dbFileLocation.absolutePath);\n        }\n      },\n      maxConcurrency\n    );\n    const amountInserted = sum(upsertResults.map((x) => x.amountInserted || 0));\n\n    return {\n      isSuccesful: true,\n      amountInserted,\n    };\n  };\n\n  /**\n   * TODO: currently very memory inefficient\n   * cannot even update\n   */\n  const upsert: DbUpsert<TModels> = async <TModelName extends Keys<TModels>>(\n    modelName: TModelName,\n    data: Creation<TModels[TModelName]> | Creation<TModels[TModelName]>[],\n    config?: UpsertQueryConfig\n  ) => {\n    const mergedConfig = mergeConfigs(modelName, dbConfig, config);\n    const { dbStorageMethod } = mergedConfig;\n    const creationItems = makeArray(data);\n\n    //  splits the items into the needed files\n    const dataPerStorageFile = await groupByFile(\n      creationItems,\n      mergedConfig,\n      modelName\n    );\n\n    // console.dir({ dataPerStorageFile }, { depth: 9 });\n    // console.log({ dataPerStorageFile: Object.keys(dataPerStorageFile) });\n\n    //  upserts items for every file, grouped, efficiently.\n    const result = await mapMany(\n      Object.keys(dataPerStorageFile),\n      async (absolutePath) => {\n        const itemsObject = dataPerStorageFile[absolutePath];\n        const { dbFileLocation, items } = itemsObject;\n        if (config?.removeUntouched && fs.existsSync(absolutePath)) {\n          await fs.rm(absolutePath);\n        }\n\n        // wait until there's no lockfile\n\n        const lockfilePath = dbFileLocation.absolutePath + \".lock\";\n\n        await waitForLockfile(lockfilePath);\n\n        // console.log(\n        //   `upserting ${dbStorageMethod} ${modelName}`,\n        //   dbFileLocation.absolutePath\n        // );\n        const result = await upsertItems<TModels, TModelName>(\n          dbStorageMethod,\n          dbFileLocation,\n          items,\n          config?.onlyInsert\n        );\n\n        await fs.rm(lockfilePath);\n        // delete lockfile\n\n        return result;\n      },\n      maxConcurrency\n    );\n\n    return {\n      isSuccesful: true,\n      message: `Upserted into ${result.length} files`,\n    };\n  };\n\n  const remove: DbRemove<TModels> = async <TModelName extends Keys<TModels>>(\n    modelName: TModelName,\n    removeWhere: (content: TModels[TModelName]) => boolean,\n    config?: CustomQueryConfig\n  ) => {\n    const mergedQueryConfig = mergeConfigs(modelName, dbConfig, config);\n    const dbFiles = await getDatabaseFiles(modelName, mergedQueryConfig);\n\n    // console.log({ modelName, config, mergedQueryConfig, dbFiles });\n    // console.log({ modelName, mergedQueryConfig, dbFiles: dbFiles });\n\n    const amountRemovedArray = await mapMany(\n      dbFiles,\n      async (dbFileLocation) => {\n        const { amountRemoved } = await removeMultiple(\n          mergedQueryConfig.dbStorageMethod,\n          dbFileLocation,\n          (content) => removeWhere(content as TModels[TModelName])\n        );\n\n        // console.log({ amountRemoved });\n\n        return amountRemoved || 0;\n      },\n      maxConcurrency\n    );\n\n    const amountRemoved = sum(amountRemovedArray);\n\n    if (amountRemoved === 0) {\n      return { isSuccesful: false, message: \"Nothing removed\", amountRemoved };\n    }\n\n    return {\n      amountRemoved,\n      isSuccesful: true,\n      message: \"Items removed\",\n    };\n  };\n\n  const update: DbUpdate<TModels> = async <TModelName extends Keys<TModels>>(\n    modelName: TModelName,\n    updateWhere: undefined | ((content: TModels[TModelName]) => boolean),\n    map: (oldValue: TModels[TModelName]) => TModels[TModelName],\n    config?: CustomQueryConfig\n  ) => {\n    // `get` -> `update` -> `groupByFile(newItems)` -> set (overwrite those files, remove leftover files)\n\n    const data = await get(modelName, config);\n\n    if (data.length === 0) {\n      return {\n        amountUpdated: 0,\n        isSuccesful: true,\n        message: \"Nothing to update\",\n      };\n    }\n    let amountUpdated = 0;\n\n    const newData: Creation<TModels[TModelName]>[] = data.map((item) => {\n      const needsUpdate = updateWhere ? updateWhere(item) : true;\n      if (needsUpdate) {\n        amountUpdated++;\n      }\n      return needsUpdate ? map(item) : item;\n    });\n\n    const { isSuccesful, message } = await set(modelName, newData, config);\n\n    const result: DbQueryResult = {\n      amountUpdated,\n      message,\n      isSuccesful,\n    };\n\n    return result;\n  };\n\n  return {\n    get,\n    getDbFileLocationPath,\n    getByFile,\n    clear,\n    upsert,\n    set,\n    remove,\n    // uses set\n    update,\n  };\n}"
  },
  "findParent": {
    "name": "findParent",
    "slug": "TsFunction",
    "id": "vxqznrxiiwphcnfssnnixauy",
    "description": "this location matches any category that equals the categorystack",
    "operationName": "fs-orm",
    "rawText": " (\n  arrayItem: Storing<KeyValueMarkdownModelType>,\n  newCategoryStack: CategoryStack\n) => {\n  const categoryStackWithItself = arrayItem.categoryStack.concat(\n    arrayItem.slug\n  );\n  const locationString = categoryStackWithItself.join(\",\");\n  const newItemLocationString = newCategoryStack.join(\",\");\n  const isSameLocation = locationString === newItemLocationString;\n\n  return isSameLocation;\n}"
  },
  "getAugmentedData": {
    "name": "getAugmentedData",
    "slug": "TsFunction",
    "id": "mczfhgrucgbuktaiyumcaxwy",
    "description": "Gets the stored data from any file with any storage method, and augments the modelLocation onto it...\n\nAlso augments the `name`, `slug` and `categoryStack` onto this if the `dbStorageMethod` is `markdown` or `jsonSingle` and if `operationRelativePath` is not set",
    "operationName": "fs-orm",
    "rawText": " async <T>(\n  dbFileLocation: DbFileLocation,\n  dbStorageMethod: DbStorageMethod\n): Promise<T[] | null> => {\n  const { absolutePath, modelName, ...modelLocation } = dbFileLocation;\n\n  const parsedPath = path.parse(absolutePath);\n\n  const isSingleMethod =\n    dbStorageMethod === \"markdown\" || dbStorageMethod === \"jsonSingle\";\n\n  const hasOperationRelativePath = !!modelLocation.operationRelativePath;\n  const shouldAddSingleInfo = isSingleMethod && !hasOperationRelativePath;\n\n  const slugifiedName = shouldAddSingleInfo\n    ? slugify(parsedPath.name)\n    : undefined;\n  const isNameValid = shouldAddSingleInfo\n    ? slugifiedName === parsedPath.name\n    : true;\n  if (!isNameValid) {\n    log(`${parsedPath.name} is not a valid (slugified) filename`, {\n      type: \"warning\",\n    });\n  }\n\n  const rootRelativePath =\n    modelLocation.operationRelativePath || modelLocation.projectRelativePath;\n  const dbModelFolderPath = `db/${pluralize(kebabCase(modelName))}`;\n\n  const dbModelFolderRelativePath = makeRelative(\n    trimSlashes(rootRelativePath),\n    dbModelFolderPath\n  );\n  const chunks = dbModelFolderRelativePath.split(\"/\");\n  // remove the name\n  chunks.pop();\n  // What's left is the folders, if any.\n  const categoryStack = chunks;\n\n  const singleInfo = shouldAddSingleInfo\n    ? { name: slugifiedName, slug: slugifiedName, categoryStack }\n    : undefined;\n  const ext = parsedPath.ext;\n\n  if (ext === \".json\") {\n    const jsonContent = await readJsonFile<any>(absolutePath);\n    const jsonContentArray = jsonContent ? makeArray(jsonContent) : null;\n    const augmented: T[] | null = jsonContentArray\n      ? (jsonContentArray.map((x) => ({\n          ...x,\n          ...modelLocation,\n          ...singleInfo,\n        })) as T[])\n      : null;\n\n    return augmented;\n  }\n\n  if (ext === \".csv\") {\n    const csvContent = await readCsvFile<any>(absolutePath);\n\n    if (!csvContent) return null;\n\n    const augmented: T[] = csvContent.map((x) => ({\n      ...x,\n      ...modelLocation,\n    }));\n    return augmented;\n  }\n\n  if (ext === \".md\") {\n    const mdParse = await readMarkdownFile(absolutePath);\n\n    if (!mdParse) return null;\n    const frontmatter = mdParse?.parameters;\n    if (dbStorageMethod === \"markdown\") {\n      const markdownContent = {\n        ...frontmatter,\n\n        markdown: mdParse.raw,\n        ...modelLocation,\n        ...singleInfo,\n        // NB: have to convert to unknown here first because of the specified markdown prop\n      } as unknown as T;\n\n      // console.log({ frontmatter, modelLocation, singleInfo });\n      return [markdownContent];\n    }\n\n    const keyValueMarkdownParse = markdownStringToKvmdParse(\n      mdParse.raw,\n      dbFileLocation\n    );\n\n    // NB: typing as unknown is required because it will only work for keyValueMarkdown models\n    const keyValueMarkdown = keyValueMarkdownParse.data as unknown as T[];\n\n    return keyValueMarkdown;\n  }\n\n  return null;\n}"
  },
  "getDatabaseFiles": {
    "name": "getDatabaseFiles",
    "slug": "TsFunction",
    "id": "famiuzqtwtmekqyocjuvwkeb",
    "description": "This function gets the files that the data can be stored, by convention, based on the model and the config\n\nOnly returns the file paths that actually exist.\n\nCONVENTION:\n\nWhen searching for data, `fs-orm` will look in:\n- `db/` in your project root\n- `db/` in any operation\n\nIn these folders, `fs-orm` will search for files based on your storage method.\n@see DbStorageMethod for more info\n\nReturns not only the file paths, but also where they were found (`operationName, projectRelativePath, operationRelativePath`)",
    "operationName": "fs-orm",
    "rawText": " async (\n  modelName: string,\n  mergedConfig: MergedQueryConfig\n): Promise<DbFileLocation[]> => {\n  const executionId = generateUniqueId();\n  const performance: (PerformanceItem | undefined)[] = [];\n  getNewPerformance(\"start\", executionId, true);\n\n  const projectRoot =\n    mergedConfig?.manualProjectRoot || mergedConfig.projectRoot;\n  if (!projectRoot) return [];\n\n  const dbStorageMethod = mergedConfig.dbStorageMethod;\n\n  performance.push(getNewPerformance(\"get projectRoot\", executionId));\n\n  const pattern = getLocationPattern(dbStorageMethod, modelName, mergedConfig);\n\n  performance.push(getNewPerformance(\"get location pattern\", executionId));\n\n  const operationPath = await getMergedConfigOperationPath(\n    mergedConfig,\n    projectRoot\n  );\n\n  performance.push(\n    getNewPerformance(\"get merged config operation path\", executionId)\n  );\n\n  // console.log({ pattern, operationPath });\n\n  // Please note, it can return false as well, which should continue here\n  if (operationPath === undefined) return [];\n\n  const rootFolders = await getRootFolders({\n    mergedConfig,\n    operationPath,\n    projectRoot,\n    manualProjectRoot: projectRoot,\n  });\n\n  // console.log({ rootFolders });\n  performance.push(getNewPerformance(\"getRootFolders\", executionId));\n\n  cleanupTimer(executionId);\n  // console.log({ performance });\n\n  /**\n  based on configuration and convention, we will fill this array with the files to get data from\n\n  NB: this should contain the actual files, not the patterns\n   */\n  let dbFiles: DbFileLocation[] = [];\n\n  const isOperationFile =\n    !!mergedConfig.operationName &&\n    !!operationPath &&\n    !!mergedConfig.operationRelativePath;\n\n  if (isOperationFile && !!operationPath) {\n    const exactAbsoluteOperationFilePath = path.join(\n      operationPath,\n      mergedConfig.operationRelativePath!\n    );\n    //make sure that extension matches `dbStorageMethod`, warn otherwise\n    const customExt = mergedConfig.operationRelativePath\n      ? path.parse(mergedConfig.operationRelativePath).ext\n      : undefined;\n    const isWrongExtension =\n      customExt !== getDbStorageMethodExtension(dbStorageMethod);\n\n    if (isWrongExtension) {\n      log(\n        `Incorrect extension found in operationRelativePath, found ${customExt}`,\n        { type: \"warning\" }\n      );\n    }\n\n    const projectRelativePath = exactAbsoluteOperationFilePath.substring(\n      projectRoot.length\n    );\n    const operationRelativePath =\n      mergedConfig.operationName === null\n        ? undefined\n        : exactAbsoluteOperationFilePath.substring(operationPath.length);\n\n    dbFiles.push({\n      modelName,\n      absolutePath: exactAbsoluteOperationFilePath,\n      operationName: mergedConfig.operationName!,\n      projectRelativePath,\n      operationRelativePath,\n    });\n  }\n\n  if (!isOperationFile && mergedConfig.projectRelativePath) {\n    const absolutePath = path.join(\n      projectRoot,\n      mergedConfig.projectRelativePath\n    );\n    const operationName = null;\n    const projectRelativePath = mergedConfig.projectRelativePath;\n\n    dbFiles.push({\n      modelName,\n      absolutePath,\n      operationName,\n      projectRelativePath,\n    });\n  }\n\n  if (!mergedConfig.projectRelativePath && !isOperationFile && pattern) {\n    // no exact path\n\n    const conventionedPaths: DbFileLocation[] = (\n      await Promise.all(\n        rootFolders.map(async (rootFolder) => {\n          const absolutePathPattern = path.join(rootFolder.basePath, pattern);\n          const projectRelativePath = absolutePathPattern.substring(\n            projectRoot.length\n          );\n\n          const operationRelativePath =\n            rootFolder.operationName === null\n              ? undefined\n              : absolutePathPattern.substring(rootFolder.basePath.length);\n\n          const parsedPath = path.parse(absolutePathPattern);\n\n          if (parsedPath.name === \"*\") {\n            const fileNames = getWildcardDbFileLocations({\n              modelName,\n              parsedPath,\n              operationName: rootFolder.operationName,\n              projectRoot,\n              rootFolder,\n            });\n\n            return fileNames;\n          } else {\n            const dbFileLocation: DbFileLocation = {\n              modelName,\n              absolutePath: absolutePathPattern,\n              operationName: rootFolder.operationName,\n              projectRelativePath,\n              operationRelativePath,\n            };\n            return [dbFileLocation];\n          }\n        })\n      )\n    ).flat();\n\n    dbFiles = dbFiles.concat(conventionedPaths);\n  }\n\n  return dbFiles;\n}"
  },
  "getDatabaseRootFolder": {
    "name": "getDatabaseRootFolder",
    "slug": "TsFunction",
    "id": "bgiwpjxolaawlwxviinoxbdb",
    "description": "Tries to get the root folder where the database folder can be found.\n\nIf an operationName is specified, this will be the operation base path\nIf not, this will be the project root.",
    "operationName": "fs-orm",
    "rawText": " async (\n  operationName: string | null | undefined,\n  manualProjectRoot?: string\n): Promise<string | undefined> => {\n  const projectRoot = manualProjectRoot || getProjectRoot();\n  if (!projectRoot) {\n    log(\"getDatabaseRootFolder: No project root found\");\n    process.exit(1);\n  }\n\n  if (!operationName) {\n    return projectRoot;\n  }\n\n  const operationBasePath = await getOperationPath(operationName, {\n    manualProjectRoot,\n  });\n\n  if (!operationBasePath) {\n    log(`Couldn't find operation base path for ${operationName}`, {\n      type: \"error\",\n    });\n  }\n\n  return operationBasePath;\n}"
  },
  "getDbFileLocation": {
    "name": "getDbFileLocation",
    "slug": "TsFunction",
    "id": "zseptxbtxvfdklgmtqwpuush",
    "description": "Used by `groupByFile`, which is used for `set` (and thus, also `update`) and `upsert`: determines the new file location.\n\nApplies the convention to get the db-file-location of an item\n\nBased on the merged config:\n\n- if `operationRelativePath` is specified, gets a filePath in the operation\n- if `projectRelativePath` is specified, gets a filepath in the project\n- otherwise gets the pattern and replaces \"*\" with the slug (or id if slug is not available)\n\nBesides the absolute path, the operationName, projectRelativePath and operationRelativePath are also supplied.\n\nNB: currently, the item's `operationName`, `operationRelativePath` or `projectRelativePath` is not taken into account. It will simply look at the convention to see where it should be saved, and apply the MergedQueryConfig...",
    "operationName": "fs-orm",
    "rawText": " async (\n  /**\n   * The ModelLocation properties in the item are completely ignored.\n   *\n   * Only the ID, slug and categoryStack are used to determine the exact file the item should be stored in.\n   *\n   * NB: storedItem MUST have a slug or ID, but this should probably be generated before this funciton\n   */\n  storedItem: Storing<AugmentedAnyModelType>,\n  /**\n   * Should be the operationName from the modellocation of the actual item.\n   *\n   * If it is given, this will take priority over the merged query config.\n   */\n  operationName: null | string,\n  mergedConfig: MergedQueryConfig,\n  modelName: string\n): Promise<DbFileLocation | undefined> => {\n  const projectRoot =\n    mergedConfig.manualProjectRoot || mergedConfig.projectRoot;\n\n  if (!projectRoot) {\n    log(\"No project root\", { type: \"error\" });\n    return;\n  }\n  const realOperationName = operationName || mergedConfig.operationName;\n\n  const rootFolder = await getDatabaseRootFolder(\n    realOperationName,\n    mergedConfig.manualProjectRoot\n  );\n\n  if (!rootFolder) return;\n\n  const isSingleItemStorageMethod =\n    mergedConfig.dbStorageMethod === \"jsonSingle\" ||\n    mergedConfig.dbStorageMethod === \"markdown\";\n\n  const filename = storedItem.slug || storedItem.id;\n\n  const relativeFolder: string | undefined =\n    storedItem.categoryStack?.join?.(\"/\");\n  const dbModelFolderRelativeLocation: string =\n    isSingleItemStorageMethod && relativeFolder\n      ? path.join(relativeFolder, filename)\n      : filename;\n\n  const pattern = getLocationPattern(\n    mergedConfig.dbStorageMethod,\n    modelName,\n    mergedConfig\n  );\n  if (!pattern) return;\n\n  const absolutePath = path.join(\n    rootFolder,\n    pattern.replace(\"*\", dbModelFolderRelativeLocation)\n  );\n  if (!absolutePath) return;\n\n  const operationRelativePath = makeRelative(absolutePath, rootFolder);\n  const projectRelativePath = makeRelative(absolutePath, projectRoot);\n\n  const dbFileLocation: DbFileLocation = {\n    modelName,\n    absolutePath,\n    operationName: realOperationName || null,\n    projectRelativePath,\n    operationRelativePath,\n  };\n\n  return dbFileLocation;\n}"
  },
  "getDbStorageMethodExtension": {
    "name": "getDbStorageMethodExtension",
    "slug": "TsFunction",
    "id": "yhexszftuvhrronavpqzfpdb",
    "description": "",
    "operationName": "fs-orm",
    "rawText": " (\n  dbStorageMethod: DbStorageMethod\n): string => {\n  if (dbStorageMethod === \"csv\") return \".csv\";\n  if (dbStorageMethod === \"jsonMultiple\") return \".json\";\n  if (dbStorageMethod === \"jsonSingle\") return \".json\";\n  if (dbStorageMethod === \"keyValueMarkdown\") return \".md\";\n  return \".md\";\n}"
  },
  "getDefaultLocationPattern": {
    "name": "getDefaultLocationPattern",
    "slug": "TsFunction",
    "id": "shreboegeirbsopbarmvtubr",
    "description": "DB main storage convention",
    "operationName": "fs-orm",
    "rawText": " (\n  dbStorageMethod: DbStorageMethod,\n  modelName: string\n): string | undefined => {\n  const fileOrFolderName = pluralize(kebabCase(modelName));\n  if (dbStorageMethod === \"jsonMultiple\") return `db/${fileOrFolderName}.json`;\n  if (dbStorageMethod === \"keyValueMarkdown\")\n    return `db/${fileOrFolderName}.md`;\n  if (dbStorageMethod === \"csv\") return `db/${fileOrFolderName}.csv`;\n\n  if (dbStorageMethod === \"jsonSingle\") return `db/${fileOrFolderName}/*.json`;\n  if (dbStorageMethod === \"markdown\") return `db/${fileOrFolderName}/*.md`;\n}"
  },
  "getItemModelLocation": {
    "name": "getItemModelLocation",
    "slug": "TsFunction",
    "id": "svmhefjhihuvgxbluvqtqbyl",
    "description": "",
    "operationName": "fs-orm",
    "rawText": " <T extends { [key: string]: any }>(\n  item: T\n): ModelLocation => {\n  const { operationName, projectRelativePath, operationRelativePath, ...rest } =\n    item;\n\n  return { operationName, projectRelativePath, operationRelativePath };\n}"
  },
  "getLength": {
    "name": "getLength",
    "slug": "TsFunction",
    "id": "xmlisrzsvtvxwjtiedcvxmcq",
    "description": "Safely gets the length of something",
    "operationName": "fs-orm",
    "rawText": " (array: any[]) => {\n  if (!Array.isArray(array)) {\n    log(`Array is not array`, { type: \"error\" }, { array });\n    return 0;\n  }\n  return array.length;\n}"
  },
  "getLocationPattern": {
    "name": "getLocationPattern",
    "slug": "TsFunction",
    "id": "cxcnswahubuymjnuvbngukei",
    "description": "Returns the pattern or an exact relative path that the file(s) should be stored at.\n\nIf a pattern contains a star at the place of the filename, it will search the folder recursively for all files with the extension in the pattern.\n\nReturning relative path has no preceding slash",
    "operationName": "fs-orm",
    "rawText": " (\n  dbStorageMethod: DbStorageMethod,\n  modelName: string,\n  mergedConfig: MergedQueryConfig\n): string | undefined => {\n  const { operationRelativePath, projectRelativePath } = mergedConfig;\n\n  if (operationRelativePath) return operationRelativePath;\n  if (projectRelativePath) return projectRelativePath;\n\n  return getDefaultLocationPattern(dbStorageMethod, modelName);\n}"
  },
  "getMergedConfigOperationPath": {
    "name": "getMergedConfigOperationPath",
    "slug": "TsFunction",
    "id": "duefqgbbveouousmiixsmojw",
    "description": "NB: returns 3 things:\n- false: no operation path\n- undefined: operation path undefined\n- path: the specific operation path",
    "operationName": "fs-orm",
    "rawText": " async (\n  mergedConfig: MergedQueryConfig,\n  manualProjectRoot?: string\n): Promise<false | string | undefined> => {\n  if (mergedConfig.operationName && mergedConfig.operationName !== \"*\") {\n    const operationPath = await getOperationPath(mergedConfig.operationName, {\n      manualProjectRoot,\n      notUseSdk: !!manualProjectRoot,\n    });\n    //\n    if (operationPath === undefined) {\n      log(`Operation wasn't found ${mergedConfig.operationName}`, {\n        type: \"warning\",\n      });\n    }\n\n    return operationPath;\n  }\n  // NB: not the same as undefined!\n  return false;\n}"
  },
  "getParentSlug": {
    "name": "getParentSlug",
    "slug": "TsFunction",
    "id": "hjzqxrqjyrvncuuzlckjdxwh",
    "description": "get a parent slug without the parent_xxxSlug reference (uses the categoryStack)\n\ncan be undefined if the item has no parent",
    "operationName": "fs-orm",
    "rawText": " (\n  item: Storing<KeyValueMarkdownModelType>\n): string | undefined => {\n  const parentSlug: string | undefined =\n    item.categoryStack[item.categoryStack.length - 1];\n  return parentSlug;\n}"
  },
  "getRootFolders": {
    "name": "getRootFolders",
    "slug": "TsFunction",
    "id": "duqgzvrbejslzrajkyduruho",
    "description": "Gets all root folders where db folders can be located inside of\n\nNB: Before november '22, this function is quite slow if it needs to find all operation folders becuase this takes at least 60ms.",
    "operationName": "fs-orm",
    "rawText": " async (config: {\n  manualProjectRoot?: string;\n  projectRoot: string;\n  mergedConfig: MergedQueryConfig;\n  operationPath: string | false;\n}): Promise<RootDbFolder[]> => {\n  const { mergedConfig, operationPath, projectRoot, manualProjectRoot } =\n    config;\n\n  // simple case: specific operation\n  if (operationPath && mergedConfig.operationName) {\n    return [\n      { basePath: operationPath, operationName: mergedConfig.operationName },\n    ];\n  }\n\n  const shouldSearchOperations = mergedConfig.operationName === \"*\";\n  const shouldSearchProject =\n    mergedConfig.operationName === undefined ||\n    mergedConfig.operationName === null ||\n    mergedConfig.operationName !== \"*\";\n\n  const projectFolder: RootDbFolder | undefined = shouldSearchProject\n    ? { operationName: null, basePath: projectRoot }\n    : undefined;\n\n  if (!shouldSearchOperations) {\n    // early return for performance reasons\n    return shouldSearchProject && projectFolder ? [projectFolder] : [];\n  }\n\n  // NB: for this we need to be sure that sdk-operations is up-to-date!\n  const realProjectRelativeOperationPathsObject: {\n    [operationName: string]: string;\n  } = manualProjectRoot\n    ? // NB: this is super slow!!! (up to 80ms)\n      await calculateOperationsObject(manualProjectRoot)\n    : operations;\n\n  const operationFolders: RootDbFolder[] = Object.keys(\n    realProjectRelativeOperationPathsObject\n  ).map((operationName) => {\n    const operationBasePath = path.join(\n      projectRoot,\n      realProjectRelativeOperationPathsObject[operationName]\n    );\n\n    return {\n      basePath: operationBasePath,\n      operationName,\n    };\n  });\n\n  const rootFolders: RootDbFolder[] = [\n    projectFolder,\n    ...operationFolders,\n  ].filter(notEmpty);\n\n  return rootFolders;\n}"
  },
  "getWildcardDbFileLocations__OLD": {
    "name": "getWildcardDbFileLocations__OLD",
    "slug": "TsFunction",
    "id": "gyfxnpmpwvvldnymkdzaiahf",
    "description": "If it all seems good, I can delete this. This is the old method of looking just in the folder itself, it's replaced by looking in all subfolders as well, recursively.",
    "operationName": "fs-orm",
    "rawText": " async (options: {\n  modelName: string;\n  parsedPath: ParsedPath;\n  operationName: string | null;\n  projectRoot: string;\n  rootFolder: RootDbFolder;\n}): Promise<DbFileLocation[]> => {\n  const { modelName, operationName, parsedPath, projectRoot, rootFolder } =\n    options;\n  if (fs.existsSync(parsedPath.dir)) {\n    // if parsedPath ends with *, read everything in the folder\n    const fileNames: DbFileLocation[] = (await fs.readdir(parsedPath.dir))\n      .filter((fileName) => fileName.endsWith(parsedPath.ext))\n      .map((fileName) => {\n        const absolutePath = path.join(parsedPath.dir, fileName);\n        const projectRelativePath = absolutePath.substring(projectRoot.length);\n        const operationRelativePath = absolutePath.substring(\n          rootFolder.basePath.length\n        );\n        const dbFileLocation: DbFileLocation = {\n          modelName,\n          absolutePath,\n          operationName: rootFolder.operationName,\n          projectRelativePath,\n          operationRelativePath,\n        };\n\n        return dbFileLocation;\n      });\n\n    return fileNames;\n  }\n\n  return [];\n}"
  },
  "getWildcardDbFileLocations": {
    "name": "getWildcardDbFileLocations",
    "slug": "TsFunction",
    "id": "klsnkvugevsrmttovrkshaum",
    "description": "",
    "operationName": "fs-orm",
    "rawText": " async (options: {\n  modelName: string;\n  parsedPath: ParsedPath;\n  operationName: string | null;\n  projectRoot: string;\n  rootFolder: RootDbFolder;\n}): Promise<DbFileLocation[]> => {\n  const { modelName, operationName, parsedPath, projectRoot, rootFolder } =\n    options;\n\n  if (fs.existsSync(parsedPath.dir)) {\n    // if parsedPath ends with *, read everything in the folder\n\n    const exploreAbsolutePaths = (\n      await explore({\n        basePath: parsedPath.dir,\n        extension: getExtension(parsedPath.base),\n      })\n    ).map((x) => x.path);\n\n    const dbFileLocations: DbFileLocation[] = exploreAbsolutePaths.map(\n      (absolutePath) => {\n        const dbFileOperationName = rootFolder.operationName;\n\n        const projectRelativePath = absolutePath.substring(projectRoot.length);\n\n        const operationRelativePath = dbFileOperationName\n          ? absolutePath.substring(rootFolder.basePath.length)\n          : undefined;\n\n        const dbFileLocation: DbFileLocation = {\n          modelName,\n          absolutePath,\n          operationName: dbFileOperationName,\n          projectRelativePath,\n          operationRelativePath,\n        };\n\n        return dbFileLocation;\n      }\n    );\n\n    return dbFileLocations;\n  }\n\n  return [];\n}"
  },
  "groupByFile": {
    "name": "groupByFile",
    "slug": "TsFunction",
    "id": "mbnmqpfvorblngdyqfeemxkf",
    "description": "Used for `set` and `upsert`. Groups creation items into an object where keys are file paths and values are items that need to be stored",
    "operationName": "fs-orm",
    "rawText": " async <T extends { [key: string]: any }>(\n  creationItems: Creation<T>[],\n  mergedConfig: MergedQueryConfig,\n  modelName: string\n): Promise<ItemPerFileObject<T>> => {\n  const dataWithLocations = (\n    await Promise.all(\n      creationItems.map(async (item) => {\n        if (!item) {\n          console.log(\"WARN\");\n          return;\n        }\n\n        const fullItem = addDefaultValues(item);\n        const storingItem = makeStoringItem(fullItem) as Storing<T>;\n\n        const itemModelLocation = getItemModelLocation(fullItem);\n\n        const dbFileLocation = await getDbFileLocation(\n          storingItem,\n          itemModelLocation.operationName,\n          mergedConfig,\n          modelName\n        );\n\n        if (!dbFileLocation) return;\n\n        return { storingItem, dbFileLocation };\n      })\n    )\n  ).filter(notEmpty);\n\n  const dataPerStorageFile = dataWithLocations.reduce(\n    (fileObject, itemWithLocation) => {\n      const { absolutePath } = itemWithLocation.dbFileLocation;\n\n      const newItems = fileObject[absolutePath]\n        ? fileObject[absolutePath].items.concat(itemWithLocation.storingItem)\n        : [itemWithLocation.storingItem];\n\n      fileObject[absolutePath] = {\n        items: newItems,\n        dbFileLocation: itemWithLocation.dbFileLocation,\n      };\n\n      return fileObject;\n    },\n    {} as ItemPerFileObject<T>\n  );\n\n  return dataPerStorageFile;\n}"
  },
  "makeStoringItem": {
    "name": "makeStoringItem",
    "slug": "TsFunction",
    "id": "illlclvdhvgmywypkbhmsgda",
    "description": "Three things need to happen in order to store an item\n\n1) keys that can be inferred from the file path are omitted\n2) referenced data is omitted\n3) calculated data is omitted",
    "operationName": "fs-orm",
    "rawText": " <T extends AugmentedAnyModelType>(\n  item: T\n): Storing<T> => {\n  // remove location related stuff\n\n  const { operationName, projectRelativePath, operationRelativePath, ...rest } =\n    item;\n\n  // remove referenced model data\n\n  const dataParameterNames = getDataParameterNames(item);\n  const restWithoutDataParameters = removeOptionalKeysFromObject(\n    rest,\n    dataParameterNames as any\n  );\n\n  // remove `.xyzCalculated` keys\n\n  const calculatedKeys = Object.keys(restWithoutDataParameters).filter((key) =>\n    key.endsWith(\"Calculated\")\n  );\n  const finalItem = removeOptionalKeysFromObject(\n    restWithoutDataParameters,\n    calculatedKeys as any\n  ) as Storing<T>;\n\n  return finalItem;\n}"
  },
  "maxConcurrency": {
    "name": "maxConcurrency",
    "slug": "TsVariable",
    "id": "njigbxzdprctmgsgtpjmpljj",
    "description": "Crashes for upsert at 1024 on m2. It would be good to find a way to ensure we never crash here, or at least report where the out of memory bug came from.",
    "operationName": "fs-orm"
  },
  "maxQueryTimeSeconds": {
    "name": "maxQueryTimeSeconds",
    "slug": "TsVariable",
    "id": "rquaflbgibvijbdlkvajzgrs",
    "description": "",
    "operationName": "fs-orm"
  },
  "mergeConfigs": {
    "name": "mergeConfigs",
    "slug": "TsFunction",
    "id": "qghxeejgjcddfshyauvurkgt",
    "description": "",
    "operationName": "fs-orm",
    "rawText": " <TModels extends AnyModelObject>(\n  modelName: Keys<TModels>,\n  dbConfig?: DbConfig<TModels>,\n  config?: CustomQueryConfig | GetQueryConfig<TModels[keyof TModels]>\n) => {\n  const hardcodedDefaultQueryConfig: QueryConfig = {\n    dbStorageMethod: \"jsonMultiple\",\n    // NB: this was hardcoded, but this is reducing performance a lot! Not sure why this was needed...\n    // manualProjectRoot: getProjectRoot(),\n  };\n\n  const modelConfig = dbConfig?.modelQueryConfig?.[modelName];\n\n  const mergedQueryConfig = mergeObjects<QueryConfig>(\n    hardcodedDefaultQueryConfig,\n    dbConfig?.defaultQueryConfig,\n    modelConfig,\n    config\n  )!;\n\n  // NB: dbStorageMethod is now always set\n  const merged = {\n    projectRoot: getProjectRoot(),\n    ...mergedQueryConfig,\n  } as MergedQueryConfig;\n  return merged;\n}"
  },
  "removeKeyValueMarkdown": {
    "name": "removeKeyValueMarkdown",
    "slug": "TsFunction",
    "id": "jcaarganwvpzwblqgrzygmdb",
    "description": "Takes stored data and a slug to remove",
    "operationName": "fs-orm",
    "rawText": " (\n  storedData: Storing<KeyValueMarkdownModelType>[],\n  /** slug to remove */\n  slug: string\n): DbQueryResult & {\n  newStoredData: Storing<KeyValueMarkdownModelType>[];\n} => {\n  // console.log(\"hummmmmm\");\n  // Base case\n  const foundItem = storedData.find((item) => item.slug === slug);\n\n  // console.log({ foundItem, storedData, slug });\n  if (!foundItem) {\n    return {\n      newStoredData: storedData,\n      amountRemoved: 0,\n      message: \"slug not found\",\n      isSuccesful: true,\n    };\n  }\n\n  if (foundItem.isHeaderCalculated) {\n    // console.log(\"is header calculated, remove all childs\");\n    // NB: remove all children (items of which the joined categoryStack starts with headerLocation)\n\n    const headerLocation = foundItem.categoryStack\n      .concat(foundItem.slug)\n      .join(\",\");\n\n    const newStoredData = storedData.filter((x) => {\n      const isHeaderCalculatedToRemove = x.slug === foundItem.slug;\n      const isCategoryStackSubset = x.categoryStack\n        .join(\",\")\n        .startsWith(headerLocation);\n\n      return !isHeaderCalculatedToRemove && !isCategoryStackSubset;\n    });\n\n    const amountRemoved = storedData.length - newStoredData.length;\n    return {\n      newStoredData,\n      amountRemoved,\n      isSuccesful: true,\n      message: \"removed header and all it's children\",\n    };\n  }\n\n  // console.log(\"ITS ITEM\");\n  // It's an item...\n\n  const allItemsInThisCategory = storedData.filter(\n    (x) => getParentSlug(x) === getParentSlug(foundItem)\n  );\n\n  if (allItemsInThisCategory.length === 0) {\n    return {\n      isSuccesful: false,\n      message: \"Tautology\",\n      newStoredData: storedData,\n      amountRemoved: 0,\n    };\n  }\n\n  // If the item is one of many in a category, we can simply remove it, because the category is still relevant\n  if (allItemsInThisCategory.length > 1) {\n    // console.log(\"More itesm in cateogry\", storedData);\n    const newStoredData = storedData.filter((x) => x.slug !== foundItem.slug);\n    const amountRemoved = storedData.length - newStoredData.length;\n    return {\n      newStoredData,\n      isSuccesful: true,\n      amountRemoved,\n      message: \"Removed item where item has more items in its category\",\n    };\n  }\n\n  // the item is the only one in a category (allItemsInThisCategory.length === 1)\n\n  const item = allItemsInThisCategory[0];\n  const category = storedData.find((x) => x.slug === getParentSlug(item));\n  const newStoredDataWithoutItemAndCategory = storedData.filter(\n    (x) => x.slug !== item.slug && x.slug !== getParentSlug(item)\n  );\n\n  if (!category) {\n    // NB: empty categorystack for the item... this means it is a root item, no worries, we did not remove any category, so we don't need to place it back either\n    const amountRemoved =\n      storedData.length - newStoredDataWithoutItemAndCategory.length;\n    return {\n      isSuccesful: true,\n      amountRemoved,\n      message: \"Removed it from the root\",\n      newStoredData: newStoredDataWithoutItemAndCategory,\n    };\n  }\n\n  /** \n  we need to make the category the first item of its parent (or the start of the file)\n  \n  first remove the item and the category, then add it in the right place\n  */\n\n  const parentSlug = getParentSlug(category);\n\n  const parentIndex = newStoredDataWithoutItemAndCategory.findIndex(\n    (x) => x.slug === parentSlug\n  );\n\n  const newItem: Storing<KeyValueMarkdownModelType> = {\n    ...category,\n    isHeaderCalculated: false,\n  };\n\n  if (parentIndex === -1) {\n    // parent doesn't exist. This means the category should become an item at the root of the file\n    const newStoredData = [newItem, ...newStoredDataWithoutItemAndCategory];\n    const amountRemoved = storedData.length - newStoredData.length;\n    return { isSuccesful: true, newStoredData, amountRemoved };\n  }\n\n  // parent exists, so, like I said before, we need to make the category the first item of its parent (or the start of the file)\n\n  const before = newStoredDataWithoutItemAndCategory.slice(0, parentIndex);\n  const after = newStoredDataWithoutItemAndCategory.slice(parentIndex + 1);\n  const parent = newStoredDataWithoutItemAndCategory[parentIndex];\n  const newStoredData = [...before, parent, newItem, ...after];\n\n  const amountRemoved = storedData.length - newStoredData.length;\n  return { newStoredData, isSuccesful: true, amountRemoved };\n}"
  },
  "removeMultiple": {
    "name": "removeMultiple",
    "slug": "TsFunction",
    "id": "adbpzzujmigjtthuaksggsax",
    "description": "Function that lets you remove items from one specific file, for any storage method",
    "operationName": "fs-orm",
    "rawText": " async (\n  dbStorageMethod: DbStorageMethod,\n  dbFileLocation: DbFileLocation,\n  removeWhere: (content: AugmentedAnyModelType) => boolean\n): Promise<DbQueryResult> => {\n  const { absolutePath, modelName, ...modelLocation } = dbFileLocation;\n  const isSingleItemStorageMethod =\n    dbStorageMethod === \"jsonSingle\" || dbStorageMethod === \"markdown\";\n\n  // NB: for single item storage methods, we can simply remove the file\n  if (isSingleItemStorageMethod) {\n    const content = await getAugmentedData<AugmentedAnyModelType>(\n      dbFileLocation,\n      dbStorageMethod\n    );\n    const item = content ? content[0] : null;\n    if (\n      fs.existsSync(dbFileLocation.absolutePath) &&\n      canWriteSync(dbFileLocation.absolutePath) &&\n      item &&\n      removeWhere(item)\n    ) {\n      const res = await fs.rm(dbFileLocation.absolutePath);\n      return { amountRemoved: 1 };\n    }\n\n    return { amountRemoved: 0 };\n  }\n\n  if (dbStorageMethod === \"keyValueMarkdown\") {\n    return alterKeyValueMarkdown(dbFileLocation, (storedData) => {\n      const realStoredData = storedData as Storing<KeyValueMarkdownModelType>[];\n\n      const finalStoredData = realStoredData.reduce((storedDataNow, item) => {\n        const completeItem: KeyValueMarkdownModelType = {\n          ...item,\n          ...modelLocation,\n        };\n\n        if (removeWhere(completeItem)) {\n          // If remove, remove it with all its children\n          const { newStoredData } = removeKeyValueMarkdown(\n            storedDataNow,\n            completeItem.slug\n          );\n          return newStoredData;\n        }\n\n        // Otherwise it stays the same\n        return storedDataNow;\n      }, realStoredData as Storing<KeyValueMarkdownModelType>[]);\n\n      return {\n        newStoredData: finalStoredData,\n        isSuccesful: true,\n        amountRemoved: getLength(storedData) - getLength(finalStoredData),\n      };\n    });\n  }\n\n  // otherwise, we'll remove the item from the array\n  return alterAny(dbStorageMethod, dbFileLocation, (storedData) => {\n    const fullData = storedData.map((item) => ({\n      ...item,\n      ...modelLocation,\n    })) as AugmentedAnyModelType[];\n\n    const newFullData = fullData.filter((item) => {\n      return !removeWhere(item);\n    });\n    const newStoredData = newFullData.map((item) => makeStoringItem(item));\n    const amountRemoved = getLength(storedData) - getLength(newFullData);\n    return {\n      amountRemoved,\n      allRemoved: getLength(newFullData) === 0,\n      newStoredData,\n      isSuccesful: true,\n    };\n  });\n}"
  },
  "upsertItems": {
    "name": "upsertItems",
    "slug": "TsFunction",
    "id": "ijssyexaqnlzrzmnwrwdeomy",
    "description": "upsert an item into storage in any storage method",
    "operationName": "fs-orm",
    "rawText": " async <\n  TModels extends AnyModelObject = any,\n  TModelName extends string = any\n>(\n  dbStorageMethod: DbStorageMethod,\n  dbFileLocation: DbFileLocation,\n  storingItems: Storing<TModels[TModelName]> | Storing<TModels[TModelName]>[],\n  onlyInsert?: boolean\n): Promise<DbQueryResult> => {\n  const storingItemsArray = makeArray(storingItems);\n\n  // Special case!\n  // TODO: we don't support multiple items for this case\n  if (dbStorageMethod === \"keyValueMarkdown\") {\n    const storingItem = storingItemsArray[0];\n\n    /**\n     * Convention for KVMD storage!\n     */\n    const parentKey = Object.keys(storingItem).find(\n      (x) => x.startsWith(\"parent_\") && x.endsWith(\"Slug\")\n    );\n    const parentSlug = parentKey ? storingItem[parentKey] : undefined;\n\n    return alterKeyValueMarkdown(dbFileLocation, (storedData) => {\n      // NB: CategoryStack is overwritten! We are first making sure that categoryStack is a real existing categoryStack based on the parent_xxxSlug.\n      const realStoredData = storedData as Storing<KeyValueMarkdownModelType>[];\n      const parent = parentSlug\n        ? realStoredData.find((x) => x.slug === parentSlug)\n        : undefined;\n\n      // NB: we overwrite categoryStack, unless the parentKey wasn't found in the storingItem.\n      const categoryStack: string[] = !parentKey\n        ? storingItem.categoryStack || []\n        : parent\n        ? parent.categoryStack.concat(parent.slug)\n        : [];\n\n      // console.log({ parentKey, parentSlug, parent, categoryStack });\n\n      const realStoringItem = {\n        ...storingItem,\n        categoryStack,\n        isHeaderCalculated:\n          storingItem.isHeaderCalculated !== undefined\n            ? storingItem.isHeaderCalculated\n            : false,\n        comment: storingItem.comment === undefined ? null : storingItem.comment,\n        // convert to unknown first because not every TModels[TModelName] is of type KeyValueMarkdownModelType\n      } as unknown as Storing<KeyValueMarkdownModelType>;\n\n      return upsertKeyValueMarkdown(realStoredData, realStoringItem);\n    });\n  }\n\n  return alterAny(dbStorageMethod, dbFileLocation, (storedData) =>\n    upsert(storedData, storingItemsArray, onlyInsert)\n  );\n}"
  },
  "upsertKeyValueMarkdown": {
    "name": "upsertKeyValueMarkdown",
    "slug": "TsFunction",
    "id": "itgxcrpvcysnrjtzciqvyawc",
    "description": "Takes stored data and an item\n\n- updates the data and sets some rows to \"item\" if the item is found (through the slug). this works almost the same as the regular upsert function\n\n- otherwise inserts, at the right category, in the right place in the array\n\nBEWARE:\n\n- the categoryStack must be existing in the markdownfile.\n- you cannot insert a header, always insert an item with `isHeaderCalculated:false`",
    "operationName": "fs-orm",
    "rawText": " (\n  storedData: Storing<KeyValueMarkdownModelType>[],\n  storingItem: Storing<KeyValueMarkdownModelType>\n): DbQueryResult & {\n  newStoredData: Storing<KeyValueMarkdownModelType>[];\n} => {\n  // First case: try to update if the slug is the same\n  let amountUpdated = 0;\n  const updatedData = storedData.map((i) => {\n    const needsUpdate = i.slug === storingItem.slug;\n    if (needsUpdate) {\n      amountUpdated++;\n      // NB: you cannot change something to be a header or not, this is a calculated value\n      return { ...storingItem, isHeaderCalculated: i.isHeaderCalculated };\n    }\n    return i;\n  });\n\n  if (amountUpdated > 0) {\n    return {\n      amountUpdated,\n      amountInserted: 0,\n      newStoredData: updatedData,\n    };\n  }\n\n  // If no \"update\", let's insert\n\n  if (storingItem.isHeaderCalculated) {\n    // Headers cannot be inserted.\n    const errorMessage = `\n      This case is not supported.\n       \nYou cannot insert a header because it will not have any items, which is not what we want.\n\nIf you create items for a parent-item, the parent-item will convert into a header.\n`;\n    log(`upsertKeyValueMarkdown: ${errorMessage}`, {\n      type: \"warning\",\n    });\n\n    return {\n      isSuccesful: false,\n      newStoredData: storedData,\n      amountInserted: 0,\n      amountUpdated: 0,\n      message: errorMessage,\n    };\n  }\n\n  // insert an item\n\n  const parentIndex = storedData.findIndex(\n    (x) => x.slug === getParentSlug(storingItem)\n  );\n  const parent: Storing<KeyValueMarkdownModelType> | undefined =\n    storedData[parentIndex];\n  // If there is no parent, insert it at the start of the file\n  if (!parent) {\n    const newStoredData = [storingItem, ...storedData];\n    return { isSuccesful: true, amountInserted: 1, newStoredData };\n  }\n\n  if (parent.isHeaderCalculated) {\n    /*\n    the parent is a category. in this case, we simply put the item as the first item below that category\n    */\n\n    const newStoredData = insertAt(\n      storedData,\n      makeArray(storingItem),\n      parentIndex + 1\n    );\n\n    return {\n      amountInserted: 1,\n      newStoredData,\n      isSuccesful: true,\n      message: \"Inserted the item in the header parent\",\n    };\n  }\n\n  /**\n           \n  The parent is an item. in this case:\n\n  1) the parent needs to become a category\n  2) the item needs to be placed under it\n  3) the parent should be removed\n  4) the last item that has the same categoryStack as the parent should be found\n  5) This new category with its sole item needs to be placed as the last item value of its parent (below other items, but above sub categories)\n\n  */\n\n  // 1\n  const parentHeader = { ...parent, isHeaderCalculated: true };\n  // 2\n  const newCategory = [parentHeader, storingItem];\n\n  // WORKS console.log({ newCategory });\n  // 3\n  const storedDataWithoutParentItem = removeIndexFromArray(\n    storedData,\n    parentIndex\n  );\n\n  // WORKS console.log({ storedDataWithoutItem });\n\n  // 4\n\n  const finalItemIndex =\n    findLastIndex(\n      storedDataWithoutParentItem,\n      (item) =>\n        item.categoryStack.join(\",\") === parentHeader.categoryStack.join(\",\") &&\n        !item.isHeaderCalculated\n    ) ||\n    // NB: not sure if this would fix all edgecases but if the only item in a category is the one that we removed, the finalItemIndex is the parentIndex -1 (but now it's a category)\n    parentIndex - 1;\n\n  // if (finalItemIndex === undefined) {\n  //   console.log(\"Unsupported Edgecase... \", { storedData, storingItem });\n  //   return {\n  //     newStoredData: storedData,\n  //     amountRemoved: 0,\n  //     amountInserted: 0,\n  //     amountUpdated: 0,\n  //   };\n  // }\n\n  const newStoredData = insertAt(\n    storedDataWithoutParentItem,\n    newCategory,\n    finalItemIndex + 1\n  );\n\n  return {\n    amountUpdated: 1,\n    amountInserted: 1,\n    newStoredData,\n    message: \"Inserted into an item (made that item a category, moved it)\",\n  };\n}"
  },
  "waitForLockfile": {
    "name": "waitForLockfile",
    "slug": "TsFunction",
    "id": "oqwrmbjjpecilxpgwwwieizm",
    "description": "",
    "operationName": "fs-orm",
    "rawText": " async (\n  lockfilePath: string\n): Promise<boolean> => {\n  if (fs.existsSync(lockfilePath)) {\n    const unixDate = await fs.readFile(lockfilePath, \"utf8\");\n    const msAgo = Date.now() - Number(unixDate);\n    if (msAgo < maxQueryTimeSeconds * 1000) {\n      // wait a 100ms!\n      // console.log(\"Waiting for lockfile...\");\n\n      await new Promise<undefined>((resolve) =>\n        setTimeout(() => resolve(undefined), 100)\n      );\n      return waitForLockfile(lockfilePath);\n    }\n\n    // if we get here, the file exists for more than 10 seconds\n\n    console.log(\n      \"Warning: lockfile exists more than ten seconds. I'm assuming the query failed, but this is not good! Should never have such slow queries.\"\n    );\n  }\n\n  await writeStringToFile(lockfilePath, String(Date.now()));\n\n  return true;\n}"
  },
  "access": {
    "name": "access",
    "slug": "TsVariable",
    "id": "sbpawiujcdcxmjaegtpbzhsq",
    "description": "",
    "operationName": "fs-util"
  },
  "appendFile": {
    "name": "appendFile",
    "slug": "TsVariable",
    "id": "gshgxpbzjinfzzsdfrxlojsk",
    "description": "",
    "operationName": "fs-util"
  },
  "canAccessSync": {
    "name": "canAccessSync",
    "slug": "TsFunction",
    "id": "ooivkhesjsujdtkneumpixsk",
    "description": "uses fs.access to determine if something can be accessed\n\nCheck File access constants for possible values of mode. It is possible to create a mask consisting of the bitwise OR of two or more values (e.g. fs.constants.W_OK | fs.constants.R_OK).",
    "operationName": "fs-util",
    "rawText": " (p: PathLike, mode: number): boolean => {\n  try {\n    fs.accessSync(p, mode);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}"
  },
  "canAccess": {
    "name": "canAccess",
    "slug": "TsFunction",
    "id": "mcngnsaijmfepdkgrkwalrll",
    "description": "uses fs.access to determine if something can be accessed\n\nCheck File access constants for possible values of mode. It is possible to create a mask consisting of the bitwise OR of two or more values (e.g. fs.constants.W_OK | fs.constants.R_OK).",
    "operationName": "fs-util",
    "rawText": " async (\n  p: PathLike,\n  mode: number\n): Promise<boolean> => {\n  try {\n    await fs.access(p, mode);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}"
  },
  "canExecuteSync": {
    "name": "canExecuteSync",
    "slug": "TsFunction",
    "id": "oxtnzdlbycznfcpzwmojjwql",
    "description": "File is executable to the calling process",
    "operationName": "fs-util",
    "rawText": " (p: PathLike) =>\n  canAccessSync(p, fs.constants.X_OK)"
  },
  "canExecute": {
    "name": "canExecute",
    "slug": "TsFunction",
    "id": "ksynvjifbexnrvxksmyjvddc",
    "description": "File is executable to the calling process",
    "operationName": "fs-util",
    "rawText": " async (p: PathLike) =>\n  canAccess(p, fs.constants.X_OK)"
  },
  "canReadSync": {
    "name": "canReadSync",
    "slug": "TsFunction",
    "id": "hvtnvjdbysufgcmbpzfszwiv",
    "description": "File is readable to the calling process",
    "operationName": "fs-util",
    "rawText": " (p: PathLike) => canAccessSync(p, fs.constants.R_OK)"
  },
  "canRead": {
    "name": "canRead",
    "slug": "TsFunction",
    "id": "gziycznzssskjlvccntzixmz",
    "description": "File is readable to the calling process",
    "operationName": "fs-util",
    "rawText": " async (p: PathLike) => canAccess(p, fs.constants.R_OK)"
  },
  "canSeeSync": {
    "name": "canSeeSync",
    "slug": "TsFunction",
    "id": "lyljundnmbxkuyyyklxadudt",
    "description": "File is visible to the calling process",
    "operationName": "fs-util",
    "rawText": " async (p: PathLike) =>\n  canAccessSync(p, fs.constants.F_OK)"
  },
  "canSee": {
    "name": "canSee",
    "slug": "TsFunction",
    "id": "xvujwmqejgoapsslarugrxxt",
    "description": "File is visible to the calling process",
    "operationName": "fs-util",
    "rawText": " async (p: PathLike) => canAccess(p, fs.constants.F_OK)"
  },
  "canWriteSync": {
    "name": "canWriteSync",
    "slug": "TsFunction",
    "id": "qzufyvkacyrzpmwehqopzxhw",
    "description": "File is writable to the calling process",
    "operationName": "fs-util",
    "rawText": " (p: PathLike) =>\n  canAccessSync(p, fs.constants.W_OK)"
  },
  "canWrite": {
    "name": "canWrite",
    "slug": "TsFunction",
    "id": "ofwpitrysnfdnimcyicjcixn",
    "description": "File is writable to the calling process",
    "operationName": "fs-util",
    "rawText": " async (p: PathLike) => canAccess(p, fs.constants.W_OK)"
  },
  "chmod": {
    "name": "chmod",
    "slug": "TsVariable",
    "id": "nnbfamxjqrqnsogvcdciejrb",
    "description": "",
    "operationName": "fs-util"
  },
  "chown": {
    "name": "chown",
    "slug": "TsVariable",
    "id": "lqgpxwjqezicffccmjanahct",
    "description": "",
    "operationName": "fs-util"
  },
  "copyAllRelativeFiles": {
    "name": "copyAllRelativeFiles",
    "slug": "TsFunction",
    "id": "ztcmbdnfewkzhuhminzsnvng",
    "description": "copy a bunch of relative files from one root folder to another",
    "operationName": "fs-util",
    "rawText": " async (\n  relativeFilePaths: string[],\n  absoluteSourceRoot: string,\n  absoluteDestinationRoot: string,\n  /**\n   * Overwrite existing file or directory\n   */\n  force?: boolean\n) => {\n  const promises = relativeFilePaths.map(async (relativeFilePath) => {\n    const fullSourcePath = path.join(absoluteSourceRoot, relativeFilePath);\n    const fullDestinationPath = path.join(\n      absoluteDestinationRoot,\n      relativeFilePath\n    );\n    if (fs.existsSync(fullSourcePath)) {\n      await fs.cpAsync(fullSourcePath, fullDestinationPath, {\n        recursive: true,\n        force: force || false,\n      });\n    }\n  });\n  await Promise.all(promises);\n\n  return true;\n}"
  },
  "copyFile": {
    "name": "copyFile",
    "slug": "TsVariable",
    "id": "zqykfiqpzfhydczxvyhvpgch",
    "description": "",
    "operationName": "fs-util"
  },
  "cp": {
    "name": "cp",
    "slug": "TsVariable",
    "id": "qcryzgljhjaudydxfjnvqedn",
    "description": "",
    "operationName": "fs-util"
  },
  "findFileNameCaseInsensitive": {
    "name": "findFileNameCaseInsensitive",
    "slug": "TsFunction",
    "id": "ntokqftxruirleevugzlpsrs",
    "description": "returns a path of a fileName",
    "operationName": "fs-util",
    "rawText": " async (\n  folderPath: string,\n  /**\n   * fileName with extension\n   */\n  fileName: string\n): Promise<string | undefined> => {\n  if (!fs.existsSync(folderPath)) return;\n\n  const results = await fs.readdir(folderPath);\n\n  const foundPath = results\n    .map((fileName) => {\n      const absolutePath = path.join(folderPath, fileName);\n      return absolutePath;\n    })\n    .find((absolutePath) => {\n      const parsedPath = path.parse(absolutePath);\n      const isMatchCaseInsensitive =\n        parsedPath.base.toLowerCase() === fileName.toLowerCase();\n\n      return isMatchCaseInsensitive;\n    });\n\n  return foundPath;\n}"
  },
  "fsPromises": {
    "name": "fsPromises",
    "slug": "TsVariable",
    "id": "nwsuwkaznejelxhgujybvqmd",
    "description": "",
    "operationName": "fs-util"
  },
  "fs": {
    "name": "fs",
    "slug": "TsVariable",
    "id": "yklzpnqrwazfydsffvqjrhwc",
    "description": "NB: for some reason some of the graceful-fs functions aren't complete. For example, I can't seem to copy folders with cp from graceful-fs (cp)\n\nFor that one I added cpAsync.",
    "operationName": "fs-util"
  },
  "getAllFoldersUntilFolder": {
    "name": "getAllFoldersUntilFolder",
    "slug": "TsFunction",
    "id": "fhrziyljjyjrnxnrouktxcda",
    "description": "NB: I already have this somewhere else but couldn't find it!\n\nIf the path is /a/random/path\n\nThe result of this function will be:\n\n['/a', '/a/random', '/a/random/path']",
    "operationName": "fs-util",
    "rawText": " (folderPath: string): string[] => {\n  const chunks = trimSlashes(folderPath).split(\"/\");\n  // chunks = ['a', 'random', 'path']\n\n  const result = chunks.map((_, index, array) => {\n    return \"/\" + array.slice(0, index + 1).join(\"/\");\n  });\n\n  return result;\n}"
  },
  "getFileName": {
    "name": "getFileName",
    "slug": "TsFunction",
    "id": "btobhzciiigimsghgxhkriuz",
    "description": "removes everything before the last slash to get file name",
    "operationName": "fs-util",
    "rawText": " (pathString: string) => {\n  return path.basename(pathString);\n}"
  },
  "getFirstAvailableFilename": {
    "name": "getFirstAvailableFilename",
    "slug": "TsFunction",
    "id": "ssphnjblxcdusiuclybiupkg",
    "description": "",
    "operationName": "fs-util",
    "rawText": " (absoluteFilePath: string): string => {\n  // If that doesn't exist, use that\n  if (!fs.existsSync(absoluteFilePath)) return absoluteFilePath;\n\n  const parsedPath = path.parse(absoluteFilePath);\n\n  const newFilename = `${oneUp(parsedPath.name)}${parsedPath.ext}`;\n  const newProposedPath = path.join(parsedPath.dir, newFilename);\n  return getFirstAvailableFilename(newProposedPath);\n}"
  },
  "getFolderSizeObject": {
    "name": "getFolderSizeObject",
    "slug": "TsFunction",
    "id": "gdyhfrvrpooobltcgyezrezv",
    "description": "returns an object with all sizes of all folders and files, recursively",
    "operationName": "fs-util",
    "rawText": " async (\n  absoluteFolderPath: string,\n  /**\n   * Folders smaller than this won't provide details\n   */\n  minimumReportSizeMb: number = 0,\n  ignoreGenerated: boolean = true\n): Promise<ChildObject<{ size: number; name: string }>[]> => {\n  const files = await fs.readdir(absoluteFolderPath, { withFileTypes: true });\n\n  const paths = (\n    await Promise.all(\n      files.map(async (file) => {\n        const newPath = path.join(absoluteFolderPath, file.name);\n\n        if (file.isDirectory()) {\n          if (\n            ignoreGenerated &&\n            [...generatedFolders, \"public\"].includes(file.name)\n          )\n            return;\n          const children = await getFolderSizeObject(newPath);\n\n          const size = sum(children.map((x) => x.size));\n          return {\n            name: file.name,\n            size,\n            /**\n             *\n             */\n            children:\n              size > minimumReportSizeMb * 1024 * 1024 ? children : undefined,\n          };\n        }\n\n        if (file.isFile()) {\n          const { size } = await fs.stat(newPath);\n\n          return {\n            size,\n            children: undefined,\n            name: file.name,\n          };\n        }\n\n        return minimumReportSizeMb\n          ? undefined\n          : { size: 0, children: undefined, name: file.name };\n      })\n    )\n  ).filter(notEmpty);\n\n  return paths;\n}"
  },
  "getFolderSize": {
    "name": "getFolderSize",
    "slug": "TsFunction",
    "id": "evtyabcjymqmfxfqzegslugr",
    "description": "",
    "operationName": "fs-util",
    "rawText": " async (absoluteFolderPath: string): Promise<number> => {\n  const files = await fs.readdir(absoluteFolderPath, { withFileTypes: true });\n\n  const paths = files.map(async (file) => {\n    const newPath = path.join(absoluteFolderPath, file.name);\n\n    if (file.isDirectory()) return await getFolderSize(newPath);\n\n    if (file.isFile()) {\n      const { size } = await fs.stat(newPath);\n\n      return size;\n    }\n\n    return 0;\n  });\n\n  return (\n    (await Promise.all(paths))\n      //  NB: lol!\n      .flat(Infinity)\n      .reduce((i, size) => i + size, 0)\n  );\n}"
  },
  "getFolder": {
    "name": "getFolder",
    "slug": "TsFunction",
    "id": "huptewfehrxzlbgaeafnbcvp",
    "description": "if the path exists:\n- if the pathString is a folder, that is returned.\n- if the pathstring is not a folder, returns the pathstring without the file suffix\n\nif the path doesn't exist: returns pathString witout last chunk (this would only work for file paths)",
    "operationName": "fs-util",
    "rawText": " (pathString: string) => {\n  const parsedPath = path.parse(pathString);\n  const hasExtension = parsedPath.ext.length > 0;\n\n  if (hasExtension) {\n    // NB: assume it's a file, let's avoid folders with dots!\n    const pathChunks = pathString.split(\"/\");\n    pathChunks.pop(); //remove the filename\n    return pathChunks.join(\"/\");\n  } else {\n    // NB: it's already a folder!\n    return pathString;\n  }\n}"
  },
  "getLastFolder": {
    "name": "getLastFolder",
    "slug": "TsFunction",
    "id": "rcemfqzftoeokckqiyaqzjzw",
    "description": "removes everything after the last slash to get folder path\n\ninput: /Users/king/Documents/some/folder/xyz\noutput: xyz\n\ninput: /Users/king/Documents/some/folder/xyz.txt\noutput: folder",
    "operationName": "fs-util",
    "rawText": " (pathString: string) => {\n  const lastFolder = getFolder(pathString).split(\"/\").pop()!;\n  // console.log({ pathString, lastFolder });\n  return lastFolder;\n}"
  },
  "getOneFolderUpPath": {
    "name": "getOneFolderUpPath",
    "slug": "TsFunction",
    "id": "diycqtxqhwjshmcsmqtzqahe",
    "description": "Takes a folder path and returns a path that is one folder up",
    "operationName": "fs-util",
    "rawText": " (folderPath: string) => {\n  const pathParts = folderPath.split(\"/\");\n  pathParts.pop();\n  return pathParts.join(\"/\");\n}"
  },
  "getPathCombinations": {
    "name": "getPathCombinations",
    "slug": "TsFunction",
    "id": "tfqsyyvjxryjbqdsjidbutgd",
    "description": "gets combinations for paths\n\ninput: [[\"operation1\",\"operation2\"], \"db/value-export\", [\"index.ts\",\"test.ts\",\"cli.ts\"]]\noutput: [\"operation1/db/value-export/index.ts\",\"operation2/db/value-export/index.ts\",\"operation1/db/value-export/test.ts\",\"operation2/db/value-export/test.ts\",\"operation1/db/value-export/cli.ts\",\"operation2/db/value-export/cli.ts\"]",
    "operationName": "fs-util",
    "rawText": " (\n  ...chunksSegments: (string[] | string)[]\n): string[] => {\n  return (\n    chunksSegments\n      .map((x) => makeArray(x))\n      // small check to prevent crashes in case there is an invalid type given (not a string)\n      .map((chunks) => chunks.filter(notEmpty))\n      .reduce((cumSegments, chunks) => {\n        // first chunk is the combination of itself\n        if (cumSegments.length === 0) return chunks;\n        // all next chunks use the accummualted segments and reduce them\n        const nextCumSegments = cumSegments.reduce((all, segment) => {\n          // for every segment add all the chunks to that segment\n          const newChunks = chunks.map((chunk) => path.join(segment, chunk));\n          //add them to all new cumSegments\n          return all.concat(newChunks);\n        }, [] as string[]);\n        return nextCumSegments;\n      }, [] as string[])\n  );\n}"
  },
  "gracefulFsConstants": {
    "name": "gracefulFsConstants",
    "slug": "TsVariable",
    "id": "mbscolqvdhgxyjvomxqrzjjv",
    "description": "",
    "operationName": "fs-util"
  },
  "gracefulFsPromises": {
    "name": "gracefulFsPromises",
    "slug": "TsVariable",
    "id": "ikvmwntdfgqkbyekmxtmscpz",
    "description": "",
    "operationName": "fs-util"
  },
  "mkdir": {
    "name": "mkdir",
    "slug": "TsVariable",
    "id": "habpjuauednobzyjgfozrkqr",
    "description": "",
    "operationName": "fs-util"
  },
  "oneUp": {
    "name": "oneUp",
    "slug": "TsFunction",
    "id": "iroixezmsbreyxfuzvbumpsm",
    "description": "Finds the number at the end of a filename and increases it\nIf there is no number yet, concatenates '1' to a string\n\nE.g.\n\n- `hello-world` becomes `hello-world1`\n- `hello36` becomes `hello37`",
    "operationName": "fs-util",
    "rawText": " (filename: string): string => {\n  const lastNumber = filename.match(/\\d+$/)?.[0];\n  const newNumber = lastNumber ? String(Number(lastNumber) + 1) : \"1\";\n  return `${filename}${newNumber}`;\n}"
  },
  "parseMd": {
    "name": "parseMd",
    "slug": "TsFunction",
    "id": "qwceirowfmzdvnnikulpuckv",
    "description": "DEPRECATED: just use `md-to-json-parse`\n\nparse a md file to all the needed info\n@param mdFilePath path to a md file\n@returns Md",
    "operationName": "fs-util",
    "rawText": " (mdFilePath: Path): Markdown => {\n  const fileContents = fs.readFileSync(mdFilePath, \"utf8\");\n  const fileStats = fs.statSync(mdFilePath);\n\n  const config: matter.GrayMatterOption<string, any> | undefined = undefined;\n  const matterResult = matter(fileContents, config);\n\n  const fileName = mdFilePath.split(\"/\").pop()!.replace(/\\.md$/, \"\");\n\n  return {\n    content: matterResult.content,\n    createdAt: fileStats.birthtimeMs,\n    fileName,\n    openedAt: fileStats.atimeMs,\n    params: matterResult.data,\n    updatedAt: fileStats.ctimeMs,\n    modifiedAt: fileStats.mtimeMs,\n  };\n}"
  },
  "path": {
    "name": "path",
    "slug": "TsVariable",
    "id": "jplgjudzqciyfjbwirbyedtz",
    "description": "",
    "operationName": "fs-util-js"
  },
  "readFileSync": {
    "name": "readFileSync",
    "slug": "TsVariable",
    "id": "vyexvcmyumoqqbupgmdetqah",
    "description": "",
    "operationName": "fs-util"
  },
  "readFile": {
    "name": "readFile",
    "slug": "TsVariable",
    "id": "bqiwcentdkcrhmbsuhuxjudo",
    "description": "",
    "operationName": "fs-util"
  },
  "readdirSync": {
    "name": "readdirSync",
    "slug": "TsVariable",
    "id": "ktpdyokyyhhcstpwvjbxzbnn",
    "description": "",
    "operationName": "fs-util"
  },
  "readdir": {
    "name": "readdir",
    "slug": "TsVariable",
    "id": "hriqyyrhmqiftdbszjgniiog",
    "description": "",
    "operationName": "fs-util"
  },
  "realpath": {
    "name": "realpath",
    "slug": "TsVariable",
    "id": "lsiwyqiljzoiassvegahoyre",
    "description": "",
    "operationName": "fs-util"
  },
  "removeAllExcept": {
    "name": "removeAllExcept",
    "slug": "TsFunction",
    "id": "aendinnqjwdktznvktcacvoe",
    "description": "Removes everything inside a folder except some files and folders that can, optionally, be ignored for removal. does not remove the folder itself\n\nNB: make this work with subdirectories!",
    "operationName": "fs-util",
    "rawText": " async (\n  folderPath: string,\n  config?: {\n    /**\n     * array of relative folder paths and file paths that should not be removed (include the extensions!)\n     */\n    ignore?: string[];\n    typeToRemove?: \"file\" | \"folder\";\n  }\n): Promise<\n  {\n    name: string;\n    removed: boolean;\n  }[]\n> => {\n  const filesAndFolders = await fs.readdir(folderPath, {\n    encoding: \"utf8\",\n    withFileTypes: true,\n  });\n\n  const removePromises = filesAndFolders.map((dirent) => {\n    if (config?.ignore?.find((x) => x.includes(dirent.name)))\n      return { name: dirent.name, removed: false };\n\n    if (config?.typeToRemove === \"file\" && !dirent.isFile())\n      return { name: dirent.name, removed: false };\n\n    if (config?.typeToRemove === \"folder\" && !dirent.isDirectory())\n      return { name: dirent.name, removed: false };\n\n    return fs\n      .rm(path.join(folderPath, dirent.name), { recursive: true })\n      .then(() => ({ name: dirent.name, removed: true }));\n  });\n\n  const promised = await Promise.all(removePromises);\n  return promised;\n}"
  },
  "renameAndCreate": {
    "name": "renameAndCreate",
    "slug": "TsFunction",
    "id": "ctnpwzagkshkvviwgnybswlr",
    "description": "",
    "operationName": "fs-util",
    "rawText": " async (oldPath: string, newPath: string) => {\n  const newPathFolderPath = path.parse(newPath).dir;\n\n  if (!fs.existsSync(newPathFolderPath)) {\n    await fs.mkdir(newPathFolderPath, { recursive: true });\n  }\n\n  await fs.rename(oldPath, newPath);\n}"
  },
  "rename": {
    "name": "rename",
    "slug": "TsVariable",
    "id": "ugozpulobtsxlkxmmuhpipfp",
    "description": "",
    "operationName": "fs-util"
  },
  "rm": {
    "name": "rm",
    "slug": "TsVariable",
    "id": "sbixcupupabrdgzspsqwgriy",
    "description": "",
    "operationName": "fs-util"
  },
  "stat": {
    "name": "stat",
    "slug": "TsVariable",
    "id": "rbaosuchnnnirmdbuzurpmgi",
    "description": "",
    "operationName": "fs-util"
  },
  "updateSingleNestedJsonFile": {
    "name": "updateSingleNestedJsonFile",
    "slug": "TsFunction",
    "id": "hfjuaqnchlvgccxhfkpeopax",
    "description": "Uses mergeNestedObject on a JSON file",
    "operationName": "fs-util",
    "rawText": " async <T extends O>(\n  path: string,\n  partialNewObject: NestedPartial<T>\n) => {\n  const json = await readJsonFile<T>(path);\n  if (!json) return false;\n  const newData = mergeNestedObject(json, partialNewObject);\n  const isSuccessful = await writeJsonToFile(path, newData);\n  return isSuccessful;\n}"
  },
  "watch": {
    "name": "watch",
    "slug": "TsVariable",
    "id": "mazhpxmnttzhiutenbujioba",
    "description": "",
    "operationName": "fs-util"
  },
  "writeFileSync": {
    "name": "writeFileSync",
    "slug": "TsVariable",
    "id": "pvogwxfktrbqtyjgjmosezbw",
    "description": "",
    "operationName": "fs-util"
  },
  "writeFile": {
    "name": "writeFile",
    "slug": "TsVariable",
    "id": "ezvpqmvmejybunudxvusxjnt",
    "description": "",
    "operationName": "fs-util"
  },
  "writeJsonToFile": {
    "name": "writeJsonToFile",
    "slug": "TsFunction",
    "id": "aiiumpqgfdtpbcnenmivkhml",
    "description": "write json to a file\n\nmakes the dir and file if they don't exist",
    "operationName": "fs-util",
    "rawText": " async <T>(\n  p: Path,\n  data: T\n): Promise<boolean> => {\n  if (!data) {\n    console.log({ p, data });\n    return false;\n  }\n  const stringifiedData = JSON.stringify(data, null, 2);\n\n  const folderToBe = getFolder(p);\n  if (!fs.existsSync(folderToBe)) {\n    //first, make sure the folder exists\n    await fs.mkdir(folderToBe, { recursive: true });\n  }\n  //then write it\n  await fs.writeFile(p, stringifiedData, \"utf8\");\n  return true;\n}"
  },
  "writeStringToFile": {
    "name": "writeStringToFile",
    "slug": "TsFunction",
    "id": "ibkseknybunqykfdhewxynhe",
    "description": "write string to a file\n\nmakes the dir and file if they don't exist",
    "operationName": "fs-util",
    "rawText": " async (\n  p: Path,\n  data: string\n): Promise<boolean> => {\n  if (data === undefined || data === null || typeof data !== \"string\") {\n    log(`Incorrect data provided`, data);\n    return false;\n  }\n\n  const folderToBe = getFolder(p);\n\n  if (!fs.existsSync(folderToBe)) {\n    //first, make sure the folder exists\n    await fs.mkdir(folderToBe, { recursive: true });\n  }\n\n  //then write it\n  await fs.writeFile(p, data, \"utf8\");\n\n  return true;\n}"
  },
  "writeToFiles": {
    "name": "writeToFiles",
    "slug": "TsFunction",
    "id": "jhjjsmrmzwkjolyizljzfumq",
    "description": "writes all values in an object to the file that should be specified as key of that value",
    "operationName": "fs-util",
    "rawText": " async (fileObject: {\n  [absoluteFilePath: string]: any;\n}) => {\n  let s = 0;\n  let e = 0;\n  const writePromises = Object.keys(fileObject).map(async (filePath) => {\n    const value = fileObject[filePath];\n    const success = await writeJsonToFile(filePath, value);\n    if (success) s++;\n    if (!success) e++;\n\n    return success;\n  });\n  await Promise.all(writePromises);\n}"
  },
  "getExtension": {
    "name": "getExtension",
    "slug": "TsFunction",
    "id": "ijdlgnugjczvykmjbpeiymns",
    "description": "returns the extension of the filename or path WITHOUT dot\n\nNB: not sure, but could be nice to replace this with path.extname(pathString)",
    "operationName": "fs-util-js",
    "rawText": " (fileNameOrPath: string) => {\n  const pieces = fileNameOrPath.split(\".\");\n  return pieces.pop()!;\n}"
  },
  "getFileOrFolderName": {
    "name": "getFileOrFolderName",
    "slug": "TsFunction",
    "id": "tttmtfvzjsoafhjmixdazars",
    "description": "",
    "operationName": "fs-util-js",
    "rawText": " <T extends string | undefined>(\n  fileOrFolderPath: T\n): T => {\n  if (!fileOrFolderPath) return undefined as T;\n  const last = fileOrFolderPath.split(\"/\").pop()!;\n  return last as T;\n}"
  },
  "getFolderJs": {
    "name": "getFolderJs",
    "slug": "TsFunction",
    "id": "kqpqpxuiwbaisnglmzjgtuyi",
    "description": "",
    "operationName": "fs-util-js",
    "rawText": " <T extends string | undefined>(filePath: T): T => {\n  if (filePath === undefined) return undefined as T;\n  const chunks = filePath.split(\"/\");\n  chunks.pop();\n  const allWithoutFile = chunks.join(\"/\") as T;\n  return allWithoutFile;\n}"
  },
  "getSubExtension": {
    "name": "getSubExtension",
    "slug": "TsFunction",
    "id": "efdogeivfxegaqrlugqcouly",
    "description": "Provide a filename including its extension, to get the subextension.",
    "operationName": "fs-util-js",
    "rawText": " (filename: string): string | undefined => {\n  const parts = filename.split(\".\");\n  //removes extension\n  parts.pop();\n  //returns extension that's left (the sub-extension)\n  const subExtension = parts.pop();\n  return subExtension;\n}"
  },
  "isPathRelative": {
    "name": "isPathRelative",
    "slug": "TsFunction",
    "id": "ugjlhclmbmuqfkrnayamutax",
    "description": "",
    "operationName": "fs-util-js",
    "rawText": " (path: string) =>\n  path.startsWith(\"./\") || path.startsWith(\"../\")"
  },
  "join": {
    "name": "join",
    "slug": "TsFunction",
    "id": "fqxisohhiurnewxvtwoyyhrp",
    "description": "",
    "operationName": "fs-util-js",
    "rawText": " (...chunks: string[]) => {\n  return chunks.join(\"/\");\n}"
  },
  "makeRelative": {
    "name": "makeRelative",
    "slug": "TsFunction",
    "id": "bvfiuhixwcturwoynetzibkw",
    "description": "Makes a path relative using proper parsing\n\nResulting path will apply the paths conventions\n- no slash at the end\n- no slash at the beginning",
    "operationName": "fs-util-js",
    "rawText": " (\n  /**\n   * absolute path of a file or folder without a slash at the end\n   */\n  absolutePath: string,\n  /**\n   * folder path without a slash at the end\n   */\n  baseFolderPath: string\n): string => {\n  // basecase should be handled, we don't want to get some weird slice edgecase\n  if (absolutePath.length < baseFolderPath.length) return \"\";\n\n  return absolutePath.slice(baseFolderPath.length + 1);\n}"
  },
  "removeTrailingSlash": {
    "name": "removeTrailingSlash",
    "slug": "TsFunction",
    "id": "tyaiuxumiugyzgeluvlgwlxs",
    "description": "",
    "operationName": "fs-util-js",
    "rawText": " (p: string) =>\n  p.charAt(0) === \"/\" ? p.slice(1) : p"
  },
  "withoutExtension": {
    "name": "withoutExtension",
    "slug": "TsFunction",
    "id": "bazuavxffcowjxjvptpbpfro",
    "description": "removes extension from the filename",
    "operationName": "fs-util-js",
    "rawText": " (fileName: string) => {\n  const pieces = fileName.split(\".\");\n  pieces.pop();\n  return pieces.join(\".\");\n}"
  },
  "withoutSubExtensions": {
    "name": "withoutSubExtensions",
    "slug": "TsFunction",
    "id": "ywsmhqphyjbxrmivqtwfengk",
    "description": "Removes all subextensions from the filename (if any) including main extension.\n\nOnly returns everything before the first dot (.)",
    "operationName": "fs-util-js",
    "rawText": " (fileName: string) => {\n  const pieces = fileName.split(\".\");\n  return pieces[0];\n}"
  },
  "FunctionForm": {
    "name": "FunctionForm",
    "slug": "TsFunction",
    "id": "dnkzxdcflxhwklupwvqjptde",
    "description": "FunctionForm is a very easy way to create a frontend component that is connected with an api that is connected with a function on your backend (that can do anything)\n\nAll you need to provide is a `TsFunction`\n\nThis component only works if your `api` is up-to-date and your function is succesfully indexed using `typerepo`. For authentication, the `api` convention is used. See the `api` docs.\n\n@see TsFunction",
    "operationName": "function-form",
    "rawText": " <T extends (...params: any[]) => any>(props: {\n  /**\n   * Must be given if you want to store assets with this\n   */\n  projectRelativeStorageFilePath?: string;\n  /**\n   * Must be given if you want to store assets with this\n   */\n  modelName?: string;\n  /**\n   * Add the tsfunction here imported from `your-operation/db/ts-functions/[function-name].json` directly\n   *\n   * Typed as `any` because you can import it from JSON, but this should be a `TsFunction`.\n   *\n   * @see TsFunction\n   */\n  tsFunction: any;\n  /**\n   * For js functions, provide the function to be executed here. If not given, it will try to use the api.\n   *\n   * NB: this should be the same function as the function you provide the index of at `tsFunction`\n   */\n  submitFunction?: T;\n  /**\n   * If you provide a `submitFunction`, you can also provide a callback that does something with the result of the function\n   */\n  withResult?: (result: WithoutPromise<ReturnType<T>>) => void;\n  /**\n   * callback to call after the api has resulted with a result\n   *\n   * Please type this yourself as `RealApiReturnType<\"functionName\">`\n   *\n   * If you don't provide this but an api call is done, we'll call `showStandardResponse`\n   */\n  withApiResult?: (result: any) => void;\n  initialValues?: any[];\n  showResult?: boolean;\n  /**\n   * Provide referencable model data if you want to\n   */\n  referencableModelData?: ReferencableModelData;\n}) => {\n  const {\n    initialValues,\n    modelName,\n    projectRelativeStorageFilePath,\n    tsFunction,\n    submitFunction,\n    withResult,\n    withApiResult,\n    showResult,\n    referencableModelData,\n  } = props;\n  const { parameters, name } = tsFunction;\n  const isFirstParameterFunctionContext =\n    parameters?.[0]?.name === \"functionContext\";\n\n  const slicedParameters = isFirstParameterFunctionContext\n    ? parameters?.slice(1)\n    : parameters;\n\n  const [isLoading, setIsLoading] = useState(false);\n\n  const [values, setValues] = useState<any[]>(\n    slicedParameters?.map((_: any, index: number) => initialValues?.[index])\n  );\n\n  // console.log({ slicedParameters, initialValues, values });\n\n  const [result, setResult] = useState<RealApiReturnType<any> | undefined>(\n    undefined\n  );\n\n  if (!slicedParameters) {\n    console.log({\n      tsFunction,\n      parameters,\n      slicedParameters,\n      isFirstParameterFunctionContext,\n    });\n    return (\n      <Div>No parameters found, please find the tsFunction in console</Div>\n    );\n  }\n\n  const renderResult = () => {\n    return (\n      <Div>\n        {result?.isUnauthorized ? (\n          <P className=\"text-red-500 font-bold\">Unauthorized!</P>\n        ) : null}\n        {result?.errors?.map((error) => (\n          <P className=\"text-red-500\">{error.error}</P>\n        ))}\n        {result?.message ? (\n          <P\n            className={result.isSuccessful ? \"text-green-500\" : \"text-red-500\"}\n          >\n            {result.message}\n          </P>\n        ) : null}\n\n        {result?.result ? (\n          <textarea\n            className=\"w-full h-[300px]\"\n            value={JSON.stringify(result.result, undefined, 2)}\n          />\n        ) : null}\n      </Div>\n    );\n  };\n  return (\n    <Div>\n      <FormContainer\n        isLoading={isLoading}\n        onSubmit={async () => {\n          setIsLoading(true);\n\n          if (submitFunction) {\n            //@ts-ignore\n            const result = await submitFunction(...values);\n            withResult?.(result);\n\n            setIsLoading(false);\n\n            return;\n          }\n\n          // @ts-ignore\n          const apiFunction = api[name];\n\n          if (!apiFunction || typeof apiFunction !== \"function\") {\n            showStandardResponse({\n              isSuccessful: false,\n              message: \"Could not find this function in the SDK\",\n            });\n            setIsLoading(false);\n            return;\n          }\n\n          // Apply it if it's there\n          const apiResult = await apiFunction(...values);\n          setResult(apiResult);\n\n          if (withApiResult) {\n            withApiResult(apiResult);\n          } else {\n            showStandardResponse(apiResult);\n          }\n\n          setIsLoading(false);\n        }}\n      >\n        {showResult ? renderResult() : null}\n\n        <SimplifiedSchemaForm\n          projectRelativeStorageFilePath={projectRelativeStorageFilePath}\n          modelName={modelName}\n          parameters={slicedParameters}\n          id={name}\n          onChange={(values) => {\n            setValues(values);\n          }}\n          values={values}\n          referencableModelData={referencableModelData}\n        />\n      </FormContainer>\n    </Div>\n  );\n}"
  },
  "getFunctionExecutions": {
    "name": "getFunctionExecutions",
    "slug": "TsFunction",
    "id": "jlafyuztsxtpzmlllovkrorw",
    "description": "",
    "operationName": "function-functions-node",
    "rawText": " async (\n  functionName: string | undefined\n): Promise<FunctionExecution[]> => {\n  if (!functionName) return [];\n  const functionExecutions = (\n    await db.get(\"FunctionExecution\", {\n      // TODO: ensure executiosn are stored in the right place before I add this back\n      //  operationName: tsFunction.operationName,\n    })\n  )\n    .filter((x) => x.functionName === functionName)\n    .map(omitUndefinedValues);\n\n  return functionExecutions;\n}"
  },
  "getFunctionQueryPaths": {
    "name": "getFunctionQueryPaths",
    "slug": "TsFunction",
    "id": "cgqprhuainhnaxbmqfrouood",
    "description": "Calculate all required query paths for the function UI menu...\n\n- bundles + main project as root folders (`[\"main project\", ...bundleNames]`)\n- per folder all operations it contains, nested, in the project relative folder where it should be ending up\n- per operation all functions it contains, nested, relative to the src folder. not file, only folders should become menu\n\nExample:\n\n- main\n- modules\n- packages\n- db-ui\n- components\n- `<IndexInstanceContainer>`\n- `<Layout>`\n- `<UpsertForm>`\n- hooks\n- `useGetDbModelQuery`\n- `useReferencableModelDataQuery`\n- pages\n- Page\n- Page\n- Page\n- getPageTitle\n- generated\n- himalayajeep-functions\n- apps\n- bundle A\n- bundle B\n\nNB: if possible, rename the menu items if the items in a folder are not unique (use file-name to replace item name if this happens)",
    "operationName": "function-functions-node",
    "rawText": " async (\n  tsFunctions?: TsFunction[]\n): Promise<{ nested: NestedWebPage[]; flat: WebPage[] }> => {\n  // if you don't provide it, overwrite it from the db\n  tsFunctions =\n    tsFunctions || (await db.get(\"TsFunction\")).filter((x) => x.isExported);\n\n  // TODO: use the `functionQueryPaths` and add the needed ones to main project and every bundle available\n  const bundles = await db.get(\"BundleConfig\");\n\n  // console.log({ tsFunctions });\n\n  const functionQueryPaths: string[] = tsFunctions\n    .map((tsFunction) => {\n      if (!tsFunction.operationName) {\n        console.log(`no name`);\n        return;\n      }\n\n      // part 1: relative path from project root until operation name\n      const operationPath =\n        operations[tsFunction.operationName as keyof typeof operations];\n\n      if (!operationPath) return;\n\n      // part 2: src relative folder path (without file)\n\n      const srcRelativeFolderPath = getSrcRelativeFolderPath(\n        tsFunction.operationRelativeTypescriptFilePath\n      );\n\n      // part 3: name of the function\n      const name = tsFunction.name;\n\n      const queryPath = srcRelativeFolderPath\n        ? `${operationPath}/${srcRelativeFolderPath}/${name}`\n        : `${operationPath}/${name}`;\n\n      return queryPath;\n    })\n    .filter(notEmpty)\n    .sort((a, b) => {\n      if (a < b) return -1;\n      return 1;\n    });\n\n  const flat = functionQueryPaths.map((queryPath) => {\n    const webPage: WebPage = {\n      queryPath,\n      pageData: null,\n    };\n    return webPage;\n  });\n\n  const menuObject = getMenuPagesObject(flat);\n\n  return menuObject;\n}"
  },
  "getPublicBundleConfig": {
    "name": "getPublicBundleConfig",
    "slug": "TsFunction",
    "id": "omhdxphalxxvwomtuhvrrnhy",
    "description": "",
    "operationName": "function-functions-node",
    "rawText": " async () => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n  const publicBundleConfigPath = path.join(\n    projectRoot,\n    \"public-bundle-config.json\"\n  );\n\n  const publicBundleConfig = await readJsonFile<PublicBundleConfig>(\n    publicBundleConfigPath\n  );\n\n  if (!publicBundleConfig) {\n    return;\n  }\n  return publicBundleConfig;\n}"
  },
  "getSrcRelativeFolderPath": {
    "name": "getSrcRelativeFolderPath",
    "slug": "TsFunction",
    "id": "augprwzsnserleunbcjxqzhc",
    "description": "",
    "operationName": "function-functions-node",
    "rawText": " (\n  operationRelativeSourcePath: string\n) => {\n  // 1) remove src/\n  const withouSrc = operationRelativeSourcePath.startsWith(\"src/\")\n    ? operationRelativeSourcePath.slice(\"src/\".length)\n    : undefined;\n\n  const folder = getFolderJs(withouSrc);\n\n  if (folder === \"\") return undefined;\n\n  return folder;\n}"
  },
  "getTsFunction": {
    "name": "getTsFunction",
    "slug": "TsFunction",
    "id": "mwnohilogywoqekzbqvagzpg",
    "description": "Uses the `sdk-function-paths` sdk to the indexation of any function in the project.",
    "operationName": "function-server-endpoints",
    "rawText": " async (\n  functionName: string\n): Promise<TsFunction | null> => {\n  const tsFunctionPath: string | undefined =\n    sdkFunctionPaths[functionName as keyof typeof sdkFunctionPaths];\n  const projectRoot = getProjectRoot();\n  if (!tsFunctionPath || !projectRoot) {\n    return null;\n  }\n  const absoluteTsFunctionPath = path.join(projectRoot, tsFunctionPath);\n  const tsFunction = await readJsonFile<TsFunction>(absoluteTsFunctionPath);\n\n  return tsFunction;\n}"
  },
  "calculateDeviceName": {
    "name": "calculateDeviceName",
    "slug": "TsFunction",
    "id": "nadjgnhiwfxedrgxecdnbzpi",
    "description": "",
    "operationName": "function-server-endpoints",
    "rawText": " (\n  ipInfo: IPInfo,\n  userAgent: IResult\n): string => {\n  const deviceName: string = slugify(\n    `${userAgent.os.name}-${userAgent.browser.name}-${ipInfo.country}-${\n      ipInfo.region\n    }-${ipInfo.city}-${ipInfo.ip}-${generateRandomString(4)}`\n  );\n\n  return deviceName;\n}"
  },
  "executeFunctionWithParameters": {
    "name": "executeFunctionWithParameters",
    "slug": "TsFunction",
    "id": "qlelojdgyfmrehqvlxicabqo",
    "description": "steps for someone to use the API\n\n1) auth\n2) cache lookup\n3) input validation\n4) running function\n5) store cache\n6) store performance\n7) returning result\n\nTODO: make it possible to return result BEFORE storing cache and performance. we probably need to use the server.reply for this, which makes this function unusable in any other setting than an api, so let's make it optional",
    "operationName": "function-server-endpoints",
    "rawText": " async <\n  TFunctionName extends keyof typeof sdk\n>(\n  functionName: TFunctionName,\n  parameters: undefined | any[],\n  serverContext: Context\n): Promise<RealApiReturnType<any>> => {\n  const publicBundleConfig = await getPublicBundleConfig();\n  const executionId = generateId();\n\n  if (isGetEndpoint(functionName)) {\n    // NB: shortcut for now, until we have cookie support:\n\n    const result = await (sdk[functionName] as any)(serverContext);\n\n    return result;\n  }\n\n  const performance: (PerformanceItem | undefined)[] = [];\n\n  performance.push(getNewPerformance(\"start\", executionId, true));\n\n  // 1) upsert device\n  const device = await upsertDevice(serverContext);\n  if (!device) {\n    console.log(\"Couldn't create device\");\n    return {\n      isSuccessful: false,\n      message: \"Couldn't create device\",\n    };\n  }\n\n  performance.push(getNewPerformance(\"upsertDevice\", executionId));\n\n  // 2) get ts function\n  const tsFunction = await getTsFunction(functionName);\n  if (!tsFunction) {\n    return {\n      isSuccessful: false,\n      message: `TsFunction file could not be found in \"sdk-function-paths\" (${functionName}). Maybe you need to rebuild your operation and update your SDK?`,\n    };\n  }\n  performance.push(getNewPerformance(\"getTsFunction\", executionId));\n\n  // 4) cache lookup\n  const cacheLookupResult = cacheLookup(functionName, parameters);\n  if (cacheLookupResult.hasValidCache) {\n    return {\n      result: cacheLookupResult.result,\n      isSuccessful: true,\n      isCached: true,\n    };\n  }\n  performance.push(getNewPerformance(\"cacheLookup\", executionId));\n\n  // 5) validation\n  //@ts-ignore\n  const validationResult = validateInput(functionName, parameters, tsFunction);\n\n  // if (!validationResult.isValid) {\n  //   return {\n  //     isSuccessful: false,\n  //     errors: validationResult.errors,\n  //     message: `Your input has some errors. Input ${JSON.stringify(\n  //       parameters\n  //     )}.`,\n  //   };\n  // }\n  performance.push(getNewPerformance(\"inputValidation\", executionId));\n\n  // 6) running function\n  const fn = sdk[functionName];\n\n  if (typeof fn !== \"function\") {\n    return {\n      isSuccessful: false,\n      message: `Function not found in the api-sdk: ${functionName}`,\n    };\n  }\n\n  const { hasAuthorization, authorizations, groups } = getAuthorizationInfo(\n    device,\n    tsFunction,\n    fn\n  );\n\n  if (publicBundleConfig?.slug !== \"passionfruit\" && !hasAuthorization) {\n    return {\n      isSuccessful: false,\n      isUnauthorized: true,\n      message:\n        \"You are not authorized to execute this function, you might need to login.\",\n    };\n  }\n\n  // 3) auth\n  // OLD simple way (passionfruit-only, to be deprecated once admin signup works good enough)\n  const authToken: string | undefined = serverContext.data?.authToken;\n  if (\n    publicBundleConfig?.slug === \"passionfruit\" &&\n    privateAuthToken !== authToken\n  ) {\n    return {\n      isSuccessful: false,\n      isUnauthorized: true,\n      message:\n        \"You are not authorized to execute this function, you might need to login.\",\n    };\n  }\n\n  performance.push(getNewPerformance(\"auth\", executionId));\n\n  /**\n   * Convention\n   */\n\n  const needsReturnRaw =\n    functionName.endsWith(apiConventions.rawFunctionConventionSuffix) ||\n    functionName.endsWith(apiConventions.getFunctionConventionSuffix);\n\n  const needsFunctionContext =\n    functionName.endsWith(apiConventions.contextFunctionConventionSuffix) ||\n    needsReturnRaw;\n\n  const functionContext: FunctionContext = {\n    tsFunction,\n    authorizations,\n    device,\n    groups,\n    hasAuthorization,\n    authToken: device.authToken,\n    serverContext,\n  };\n\n  const parametersWithContext = needsFunctionContext\n    ? [functionContext].concat(parameters || [])\n    : parameters;\n\n  console.dir(\n    { executeFunctionWithParameters: functionContext },\n    { depth: 99 }\n  );\n  // console.log(`We are authorized to execute ${functionName}! Let's do it`);\n  // @ts-ignore\n  const result = await fn(...parametersWithContext);\n  performance.push(getNewPerformance(\"function\", executionId));\n\n  cleanupTimer(executionId);\n\n  //@ts-ignore\n  const resultValidation = validateResult(functionName, result, tsFunction);\n\n  // console.log({ serverwithPar: performance });\n  // 6) store performance\n  storeFunctionExecution(\n    tsFunction,\n    parameters,\n    result,\n    performance.filter(notEmpty),\n    false\n  );\n\n  // need to return this immediately without the surrounding object, because it might do stuff with that server context that needs to be returned\n  if (needsReturnRaw) return result;\n\n  if (result === undefined) {\n    return {\n      isSuccessful: true,\n      isCached: false,\n      message: \"Function was executed but did not give any response\",\n      result: undefined,\n    };\n  }\n\n  return {\n    isSuccessful: true,\n    isCached: false,\n    result,\n  };\n}"
  },
  "functionGetEndpoints": {
    "name": "functionGetEndpoints",
    "slug": "TsVariable",
    "id": "rynwishonuwwaotpgwztmdzu",
    "description": "routes to post and execute operation functions",
    "operationName": "function-server-endpoints"
  },
  "functionPostEndpoints": {
    "name": "functionPostEndpoints",
    "slug": "TsVariable",
    "id": "svvksbpojiduygzppafvctvw",
    "description": "routes to post and execute operation functions",
    "operationName": "function-server-endpoints"
  },
  "getAuthorizationInfo": {
    "name": "getAuthorizationInfo",
    "slug": "TsFunction",
    "id": "wwwnvbfyoxtakcwpsszyaptm",
    "description": "returns `AuthorizationInfo` for a device + function",
    "operationName": "function-server-endpoints",
    "rawText": " (\n  device: Storing<Device>,\n  tsFunction: TsFunction,\n  fn: { (...parameters: any): any; [key: string]: any }\n): AuthorizationInfo => {\n  const everyPersonsGroups =\n    device?.persons\n      ?.map((x) => x.groups)\n      .flat()\n      .filter(notEmpty)\n      .filter(onlyUnique2<Group>((a, b) => a.slug === b.slug)) || [];\n\n  // Accumulating all authorizations: the public authorization of the function, the manual person authorizations, and the group authorizations\n  const authorizations = everyPersonsGroups\n    .map((group) => group.customAuthorizations)\n    .flat()\n    .filter(notEmpty);\n\n  const hasAuthorization = !!authorizations.find((auth) => {\n    const authAppliesToThisFunction =\n      auth.tsFunctionId === tsFunction.id ||\n      auth.authorizedOperationName === tsFunction?.operationName ||\n      (auth.authorizedProjectRelativePath &&\n        tsFunction.projectRelativePath.startsWith(\n          auth.authorizedProjectRelativePath\n        ));\n\n    return authAppliesToThisFunction && auth.canExecute;\n  });\n\n  /**\n   * Function might ne an `ApiFunction`\n   */\n  const isPublic = fn.isPublic;\n\n  const result = {\n    hasAuthorization: isPublic || hasAuthorization,\n    authorizations,\n    groups: everyPersonsGroups,\n  };\n\n  console.log({ getAuthorizationInfo: result });\n  return result;\n}"
  },
  "isGetEndpoint": {
    "name": "isGetEndpoint",
    "slug": "TsFunction",
    "id": "uhxiipnozmswyklctypgxgnn",
    "description": "",
    "operationName": "function-server-endpoints",
    "rawText": " (functionName: string) => {\n  return functionName.endsWith(apiConventions.getFunctionConventionSuffix);\n}"
  },
  "privateAuthToken": {
    "name": "privateAuthToken",
    "slug": "TsVariable",
    "id": "jeavcouewkshzcjhowsaysrq",
    "description": "",
    "operationName": "function-server-endpoints"
  },
  "savePageVisit": {
    "name": "savePageVisit",
    "slug": "TsFunction",
    "id": "tfuwifbyyuotbmaxkcggujnr",
    "description": "",
    "operationName": "function-server-endpoints",
    "rawText": " async (\n  deviceId: Id,\n  ipInfo: IPInfo,\n  referer: string\n) => {\n  const pageVisit: Creation<PageVisit> = { ipInfo, path: referer, deviceId };\n\n  await db.upsert(\"PageVisit\", pageVisit, { onlyInsert: true });\n}"
  },
  "storeFunctionExecution": {
    "name": "storeFunctionExecution",
    "slug": "TsFunction",
    "id": "uiwbzudmkwzkyqubmkollvsx",
    "description": "wrapper function that stores execution-speed in an object with `FunctionPerformance` data-structure. Store this using `db.push` if it adds value\n.",
    "operationName": "function-server-endpoints",
    "rawText": " async (\n  tsFunction: TsFunction,\n  inputParameters: any[] | undefined,\n  output: any,\n  performance: PerformanceItem[],\n  isResultFromCache: boolean\n) => {\n  // TODO: store using db (if useful)\n\n  const functionExecution: Creation<FunctionExecution> = {\n    functionName: tsFunction.name,\n    tsFunctionId: tsFunction.id,\n    inputParameters,\n    isExample: false,\n    isTest: false,\n    isResultFromCache,\n    output,\n    performance,\n  };\n\n  //@ts-ignore\n  const result = await db.upsert(\"FunctionExecution\", functionExecution, {\n    onlyInsert: true,\n    operationName: tsFunction.operationName,\n  });\n  return;\n}"
  },
  "upsertDevice": {
    "name": "upsertDevice",
    "slug": "TsFunction",
    "id": "tghiiudcnynkpqdijuvahasp",
    "description": "Returns device with all attached (logged in) `Person`s, and `currentPersonCalculated`\n\nEither finds the device and updates it according to the new request metadata, or creates a new device.\n\nShould never return `undefined` if the database functions...\n\nTODO: Use cookies (https://serverjs.io/documentation/reply/#cookie-) to login\n\nNeeded for having `authToken` with GET as well in a safe manner (e.g. for images)",
    "operationName": "function-server-endpoints",
    "rawText": " async (\n  serverContext: Context\n): Promise<Storing<Device> | undefined> => {\n  // in your function\n  const executionId = generateUniqueId();\n  const performance: (PerformanceItem | undefined)[] = [];\n\n  performance.push(getNewPerformance(\"start\", executionId, true));\n\n  const authToken: string | undefined = serverContext.data?.authToken;\n  const ip = serverContext.ip;\n\n  if (!authToken || authToken.length < 24) {\n    console.log(\"warn upsert device: no authToken\");\n    return;\n  }\n\n  // NB: range: [ <low bound of IP block>, <high bound of IP block> ], the rest is described in the type interface\n  // const ipLookup = (geoip.lookup(ip) || {}) as Partial<geoip.Lookup>;\n  // const {\n  //   city,\n  //   area: positionRadiusKm,\n  //   ll,\n  //   country,\n  //   region,\n  //   timezone,\n  // } = ipLookup;\n\n  // const position: Position | undefined =\n  //   !!ll?.[0] && !!ll?.[1] ? { latitude: ll[0], longitude: ll[1] } : undefined;\n\n  const userAgentString = serverContext.req.get(\"User-Agent\");\n  const userAgent: IResult = parseUserAgent(userAgentString);\n\n  // const ipInfo: IPInfo = {\n  //   ip,\n  //   city,\n  //   position,\n  //   positionRadiusKm,\n  //   country,\n  //   region,\n  //   timezone,\n  // };\n\n  const origin = serverContext.req.get(\"Origin\") as string;\n  const referer = serverContext.req.get(\"Referrer\") as string;\n\n  const dbPath = getRootPath(\"db\");\n  if (!dbPath) return;\n  const deviceFilePath = path.join(dbPath, \"devices\", `${authToken}.json`);\n\n  const exists = fs.existsSync(deviceFilePath);\n\n  const deviceBefore: Storing<Device> | null = exists\n    ? await readJsonFile<Storing<Device>>(deviceFilePath)\n    : null;\n\n  const newDevice: Storing<Device> | null = !exists\n    ? {\n        authToken,\n        authenticationMethods: [],\n        ip,\n        createdAt: Date.now(),\n        createdFirstAt: Date.now(),\n        deletedAt: 0,\n        id: authToken,\n        lastOnlineAt: Date.now(),\n        name: authToken,\n        updatedAt: Date.now(),\n        userAgentString: userAgentString || \"no useragent\",\n      }\n    : null;\n\n  if (newDevice) {\n    await writeJsonToFile(deviceFilePath, newDevice);\n  }\n\n  //savePageVisit(authToken, {ip}, referer);\n\n  // attach persons and groups\n  const groups = await db.get(\"Group\");\n  const persons = (await db.get(\"Person\"))\n    .filter((x) => deviceBefore?.personIds?.includes(x.id))\n    .map((p) => {\n      return {\n        ...p,\n        groups: groups.filter((g) => p.groupSlugs?.includes(g.slug)),\n      };\n    });\n\n  const augmentedDevice: Storing<Device> = deviceBefore\n    ? { ...deviceBefore, persons }\n    : newDevice!;\n\n  // console.dir({ augmentedDevice }, { depth: 999 });\n  return augmentedDevice;\n}"
  },
  "chat": {
    "name": "chat",
    "slug": "TsFunction",
    "id": "wofagristrkwqeebmbycksur",
    "description": "",
    "operationName": "function-util",
    "rawText": " () => {\n  // 1- listen\n  // 2- respond\n  chat();\n}"
  },
  "converse": {
    "name": "converse",
    "slug": "TsFunction",
    "id": "dfikqyznijkzpewxatcgirtz",
    "description": "this is the `yo` cli. takes a message",
    "operationName": "function-util",
    "rawText": " async (searchMessage: string) => {\n  const sdkFunctionPaths = await getSdkFunctionPaths();\n  if (!sdkFunctionPaths) return false;\n  const sdkKeyMatches = findSentenceMatches(\n    searchMessage,\n    sdkFunctionPaths,\n    (x) => x.matcher.replaceAll(\"/\", \" \")\n  );\n\n  if (sdkKeyMatches.length === 0) {\n    log(\"Wut?\", { type: \"error\" });\n  } else if (sdkKeyMatches.length === 1) {\n    const match = sdkKeyMatches[0];\n    log(`Match: ${humanCase(match.name)}`, {\n      type: \"success\",\n    });\n\n    await getParametersAndExecute(match);\n  } else {\n    log(\n      `There are ${sdkKeyMatches.length} things we can do: \\n\\n${sdkKeyMatches\n        .map(\n          (match, index) =>\n            `${index}: ${match.name} (from ${match.relativeOperationPath})`\n        )\n        .join(\", \\n\")}`,\n      { type: \"important\" }\n    );\n\n    const n = await ask(\"Which number do you want?\");\n\n    if (isNaN(Number(n))) {\n      log(`That's not a number`, { type: \"error\" });\n      return;\n    }\n\n    const choice = sdkKeyMatches[Number(n)];\n\n    if (!choice) {\n      log(`That's not a function from the list`, { type: \"error\" });\n      return;\n    }\n\n    await getParametersAndExecute(choice);\n  }\n}"
  },
  "doCli": {
    "name": "doCli",
    "slug": "TsFunction",
    "id": "qzagsmpixdjvlmdnwiwbtrmn",
    "description": "",
    "operationName": "function-util",
    "rawText": " async () => {\n  const [cliNameString, ...parameterStrings] = process.argv.slice(2);\n  const cliPath = `src/cli/${cliNameString}.cli.ts`;\n  const tsFunction = (\n    await db.get(\"TsFunction\", {\n      filter: (fn) => fn.operationRelativeTypescriptFilePath === cliPath,\n    })\n  )[0];\n\n  if (!tsFunction || !tsFunction.operationName) {\n    console.log(\"not found\", cliPath);\n    return;\n  }\n\n  const fileId = getSrcRelativeFileId(\n    tsFunction.operationRelativeTypescriptFilePath\n  );\n\n  const operationPath = await getOperationPath(tsFunction.operationName);\n  if (!operationPath) return;\n  const jsPath = path.join(operationPath, \"build\", `${fileId}.js`);\n\n  execSync(`node ${jsPath} ${parameterStrings.join(\" \")}`, {\n    stdio: \"inherit\",\n  });\n}"
  },
  "executeSdkFunction": {
    "name": "executeSdkFunction",
    "slug": "TsFunction",
    "id": "iptfpzgmhxtihjlnflqpugsz",
    "description": "",
    "operationName": "function-util",
    "rawText": " async (\n  operationString: string,\n  parameters: string[] | undefined\n) => {\n  const sdkOperation = operationString as keyof typeof sdk;\n  const operationFunction = sdk[sdkOperation];\n\n  if (typeof operationFunction === \"function\") {\n    const result = parameters\n      ? // @ts-ignore\n        operationFunction(...parameters)\n      : // @ts-ignore\n        operationFunction();\n\n    return result;\n  } else {\n    log(`Could not find ${operationString}`, { type: \"error\" });\n  }\n}"
  },
  "exportsArray": {
    "name": "exportsArray",
    "slug": "TsVariable",
    "id": "mulrtffehgtuqsgoeiagedjb",
    "description": "",
    "operationName": "function-util"
  },
  "getCachedExportedFunctions": {
    "name": "getCachedExportedFunctions",
    "slug": "TsFunction",
    "id": "iftpgocpngwftyujcqykskcb",
    "description": "",
    "operationName": "function-util",
    "rawText": " async () => {\n  if (functions.length) return functions;\n  functions = await db.get(\"TsFunction\");\n  exportsArray = await db.get(\"TsExport\");\n  const fnIsExported = (fn: TsFunction) =>\n    exportsArray.find(\n      (e) => e?.operationName === fn?.operationName && e.name === fn.name\n    );\n  return functions.filter(fnIsExported);\n}"
  },
  "getMenu": {
    "name": "getMenu",
    "slug": "TsFunction",
    "id": "gqpjbwzfalyiohneykzypdkc",
    "description": "",
    "operationName": "function-util",
    "rawText": " async () => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n  const operationFolders: string[] = await exploreOperationFolders({\n    basePath: getPathsWithOperations(),\n  });\n  const relativeOperationFolders = operationFolders.map((p) =>\n    p.slice(projectRoot.length)\n  );\n\n  const fns = await getCachedExportedFunctions();\n  const functionsPerOperation = relativeOperationFolders.map(\n    (relativeOperationFolder) => ({\n      [relativeOperationFolder.slice(1)]: fns.filter(\n        (fn) => fn.operationName === getLastFolder(relativeOperationFolder)\n      ),\n      // optionally, maybe I should just return the function names here.\n    })\n  );\n  return {\n    success: true,\n    response: \"Menu found\",\n    menu: mergeObjectsArray(functionsPerOperation),\n  };\n}"
  },
  "getParametersAndExecute": {
    "name": "getParametersAndExecute",
    "slug": "TsFunction",
    "id": "kcpddjwbkgzdaifnguteffes",
    "description": "",
    "operationName": "function-util",
    "rawText": " async (fn: FnMatch) => {\n  console.log(`finding ${fn.name} as ${fn.matcher}`);\n\n  log(\n    `Fill in the parameters of this function (JSON or string) (Leave empty for no parameter)`\n  );\n  const parameters = await getParameters(fn.parameters);\n  await executeSdkFunction(fn.name, parameters);\n}"
  },
  "getParameters": {
    "name": "getParameters",
    "slug": "TsFunction",
    "id": "ellgiqvucvnsvuloyladpbhz",
    "description": "",
    "operationName": "function-util",
    "rawText": " async (parameters?: FunctionParameter[]) => {\n  return parameters\n    ? oneByOne(parameters, async (parameter) => {\n        /** TODO: Walking:\n         * - if a parameter is a string, it's easy\n         * - if a parameter is a number or boolean, just cast string to that\n         * - if a parameter is an object, walk over all keys\n         * - if a parameter is/can be an array, just insert the first via the above way, but ask if you want to insert another entry after that\n         * - for every entry you can also enter '?'. This will look for all operations that return something that could be used as entry here.\n         */\n        const answer = await ask(`${parameter.name} (${parameter.required})`);\n        return answer;\n      })\n    : undefined;\n}"
  },
  "getSdkFunctionPaths": {
    "name": "getSdkFunctionPaths",
    "slug": "TsFunction",
    "id": "lkazvgbmhwrhvplkahjqnrkz",
    "description": "",
    "operationName": "function-util",
    "rawText": " async (): Promise<false | FnMatch[]> => {\n  const menu = await getMenu();\n\n  if (!menu) {\n    return false;\n  }\n\n  const paths = Object.keys(menu).reduce((all, relativeOperationPath) => {\n    //@ts-ignore\n    const fnArray: TsFunction[] | undefined = menu[relativeOperationPath];\n\n    return fnArray && Array.isArray(fnArray)\n      ? all.concat(\n          fnArray.map((x) => {\n            return {\n              matcher: `${relativeOperationPath}/${x.name}`,\n              relativeOperationPath,\n              ...x,\n            };\n          })\n        )\n      : all;\n  }, [] as FnMatch[]);\n\n  return paths;\n}"
  },
  "listen": {
    "name": "listen",
    "slug": "TsFunction",
    "id": "nwzxbthkipnzwfiaxvhjloca",
    "description": "generates structured operations based on unstructured instructions\n\nThis is huge. we need to start somewhere though. Plan:\n\n- all operations can be formatted as a word[] with specified order\n- all words can have synonyms\n- some operations can have aliases or different word orders that would mean the exact same\n- speech to text is a prerequisite for speaking out instructions\n- text to speech is already there\n\nWith this in place, we can define a structured way to do things.\n\n1) find the right operation to apply\n2) every parameter needs to be filled in (or use default) or we need to use a preset (from previous input logs). this can be some sort of conversation\n3) the opo (operation output) can be added to context, if needed\n4) the opi (operation input) can be added to presets, if needed\n\nCan you imagine that? I am creating a script that runs all the time and listens and responds to anything I say. My own Siri, but much more powerful. It seems hard, but if you look at it, it's actually just a different UI for all the things I already have. Among other things, it will make it possible to work while doing anything.\n\nThe power lies in being able to recursively ask for all the parameters. if you provide a new operation instead of a value, it will ask for all its parameters in order to continue.\n\nThis conversation could actually be used to generate code! It's kind of `context.reverse().map(createTsLine);` In fact, if we can make that, we can maybe even reverse code into conversations as well! This is insanely powerful.",
    "operationName": "function-util",
    "rawText": " ({\n  instruction,\n  context,\n}: {\n  instruction: string;\n  /**\n   * should be in fifo order, so no push but unshift! the further in the array, the less important the context (forgetting)\n   */\n  context: Context[];\n}): { operation: string; input: any; certainty: number }[] => {\n  return [];\n}"
  },
  "message": {
    "name": "message",
    "slug": "TsVariable",
    "id": "wlrivgemrhuqpdouoizrqfoi",
    "description": "",
    "operationName": "function-util"
  },
  "wordArray": {
    "name": "wordArray",
    "slug": "TsVariable",
    "id": "vpcxfqjsbcktfmozriztfnus",
    "description": "",
    "operationName": "function-util"
  },
  "generateNamedIndex": {
    "name": "generateNamedIndex",
    "slug": "TsFunction",
    "id": "gbjoikfanfaqkstzfemcdfao",
    "description": "Generates an index.ts file based on named statements in the operation. Also generates test array. Not used currently.\n\nNB: This overwrites the indexfile of the operation in the src folder! Make sure you don't have anything there still.. All functions should be in other filenames.\n\nShould be ran every time an operation changes",
    "operationName": "generate-index",
    "rawText": " async ({\n  operationName,\n  manualProjectRoot,\n}: {\n  manualProjectRoot?: string;\n  operationName: string;\n}) => {\n  if (!operationName) {\n    log(\"No operation name, can't create index\", { type: \"error\" });\n    return;\n  }\n  const operationBasePath = await getOperationPath(operationName, {\n    manualProjectRoot,\n  });\n\n  if (!operationBasePath) {\n    log(`operationPath not found ${operationName}`, { type: \"error\" });\n    return;\n  }\n  const outputPath = path.join(operationBasePath, \"src\", \"index.ts\");\n\n  const functionArray = (\n    await db.get(\"TsFunction\", {\n      operationName,\n      manualProjectRoot,\n    })\n  )\n    .filter(\n      (x) =>\n        x.isExported && x.operationRelativeTypescriptFilePath !== \"src/index.ts\"\n    )\n    .map((item) => mapToImportStatement(item, \"function\"));\n\n  const variableArray = (\n    await db.get(\"TsVariable\", {\n      operationName,\n      manualProjectRoot,\n    })\n  )\n    .filter(\n      (x) =>\n        x.isExported && x.operationRelativeTypescriptFilePath !== \"src/index.ts\"\n    )\n    .map((item) => mapToImportStatement(item, \"variable\"));\n\n  const interfacesArray = (\n    await db.get(\"TsInterface\", {\n      operationName,\n      manualProjectRoot,\n    })\n  )\n    .filter(\n      (x) =>\n        x.isExported && x.operationRelativeTypescriptFilePath !== \"src/index.ts\"\n    )\n    .map((item) => mapToImportStatement(item, \"interface\"));\n\n  const importStatements: ImportStatement[] = [\n    ...interfacesArray,\n    ...functionArray,\n    ...variableArray,\n  ];\n  // PART 1) mapping and filtering data\n\n  const testStatements = importStatements.filter((x) => isTestFn(x));\n  const otherStatements = importStatements.filter(\n    (x) => lowerCaseArray(x.name).pop() !== \"test\"\n  );\n\n  const importStatementsString = importStatements\n    // import all values (mostly functions, some consts)\n    .map((statement) => {\n      return `import { ${statement.name} } from \"./${statement.srcRelativeFileId}\";`;\n    })\n    .filter(notEmpty)\n    .join(\"\\n\")\n    .concat(\"\\n\");\n\n  /**\n   * this should return an array of all tests of all files\n   */\n  const exportTestString =\n    testStatements.length > 0\n      ? `export const test = [${testStatements\n          .map((exp) => exp.name)\n          .join(\", \")}].flat();\\n`\n      : \"\";\n\n  /**\n   * export all values separately.\n   */\n  const exportStatementsString =\n    otherStatements.length > 0\n      ? `export { ${otherStatements.map((x) => x.name).join(\", \")} };\\n`\n      : \"\";\n\n  // PART 3) Aggreagating all scripts into one big string\n\n  const indexationString = \"// THIS FILE HAS BEEN GENERATED\\n\"\n    .concat(\"\\n\")\n    // all imports\n    .concat(importStatementsString)\n    .concat(\"\\n\\n\")\n    // all exports\n    .concat(exportTestString)\n    .concat(exportStatementsString)\n    .concat(\"\\n\")\n    .concat(\"// THANK YOU\\n\");\n\n  await fs.writeFile(outputPath, indexationString, { encoding: \"utf8\" });\n\n  log(`Created index for ${operationName}`, { type: \"debug\" });\n}"
  },
  "generateSimpleIndex": {
    "name": "generateSimpleIndex",
    "slug": "TsFunction",
    "id": "yidtnphdbnzvfomfrdgdjwjg",
    "description": "generates operation index and writes it to index.ts in src of the operation.\n\nNB: This overwrites the indexfile of the operation in the src folder! Make sure you don't have anything there still.. All functions should be in other filenames.\n\nShould be ran every time an operation changes",
    "operationName": "generate-index",
    "rawText": " async ({\n  operationName,\n  manualProjectRoot,\n}: {\n  /**\n   * if given, just exports * from those\n   */\n  operationName: string;\n  manualProjectRoot?: string;\n}): Promise<string | undefined> => {\n  if (!operationName) {\n    log(\"No operation name, can't create index\", { type: \"error\" });\n    return;\n  }\n  const operationBasePath = await getOperationPath(operationName, {\n    manualProjectRoot,\n  });\n\n  if (!operationBasePath) {\n    log(`operationPath not found ${operationName}`, { type: \"error\" });\n    return;\n  }\n\n  const classification = getOperationClassification(operationBasePath);\n\n  if (classification === \"ui-web\") {\n    log(\"Not generating index.ts for next.js project, not needed.\", {\n      type: \"default\",\n    });\n    return;\n  }\n\n  const outputPath = path.join(operationBasePath, \"src\", \"index.ts\");\n\n  const files = await getPackageSourcePaths({ operationBasePath });\n\n  const srcRelativeFileIds = files.map((fullPath) =>\n    getSrcRelativeFileId(makeRelative(fullPath, operationBasePath))\n  );\n\n  const indexationString = srcRelativeFileIds\n    .filter(isIndexableFileId)\n    .map((id) => `export * from \"./${id}\";`)\n    .join(\"\\n\");\n\n  await fs.writeFile(outputPath, indexationString, { encoding: \"utf8\" });\n\n  return outputPath;\n}"
  },
  "isTestFn": {
    "name": "isTestFn",
    "slug": "TsFunction",
    "id": "cpzvotuhxnfpjuoqrfqvvwec",
    "description": "",
    "operationName": "generate-index",
    "rawText": " (x: ImportStatement) => {\n  const nameEndsWithTest = lowerCaseArray(x.name).pop() === \"test\";\n  const typeIsFn = x.type === \"function\";\n  return typeIsFn && nameEndsWithTest;\n}"
  },
  "mapToImportStatement": {
    "name": "mapToImportStatement",
    "slug": "TsFunction",
    "id": "ksajlyovymavslxdujsrcwnp",
    "description": "",
    "operationName": "generate-index",
    "rawText": " (\n  item: TsFunction | TsVariable | TsInterface,\n  type: ImportStatement[\"type\"]\n): ImportStatement => {\n  const srcRelativeFileId = getSrcRelativeFileId(\n    item.operationRelativeTypescriptFilePath\n  );\n\n  return { name: item.name, srcRelativeFileId, type };\n}"
  },
  "generateDbSdkCli": {
    "name": "generateDbSdkCli",
    "slug": "TsFunction",
    "id": "ykgsnxnxrcyqttahxyffrhnp",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " () => {\n  const [customProjectRoot] = process.argv.slice(2);\n  const defaultProjectRoot = getProjectRoot(process.cwd());\n\n  generateDbSdk({ manualProjectRoot: customProjectRoot || defaultProjectRoot });\n}"
  },
  "generateDbSdk": {
    "name": "generateDbSdk",
    "slug": "TsFunction",
    "id": "sjdkybimrmytngpsgrpkmzct",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n  skipYarnInstall?: boolean;\n  dryrun?: boolean;\n}) => {\n  // const dependants = await findDependantsRecursively(\"sdk-db\");\n\n  const manualProjectRoot = config?.manualProjectRoot;\n  const skipYarnInstall = config?.skipYarnInstall;\n  const dryrun = config?.dryrun;\n\n  const allDbModels = await getAllDbModels(manualProjectRoot);\n  const typeImportsString = allDbModels\n    .map((tsInterface) => {\n      return `import type { ${tsInterface.name} } from \"${tsInterface.operationName}\";`;\n    })\n    .filter(notEmpty)\n    .join(\"\\n\")\n    .concat(\"\\n\");\n\n  const exportDbTypesString = `export type DbModels = { ${allDbModels\n    .map((x) => `${x.name}: ${x.name}`)\n    .join(\",\")} };\\n`;\n\n  const exportDbKeysString = `export const dbModelKeys = [ ${allDbModels\n    .map((x) => `\"${x.name}\"`)\n    .join(\",\")} ] as const;\\n`;\n\n  const exportDbModelEnumString =\n    \"export type DbModelEnum = typeof dbModelKeys[number];\\n\";\n\n  const exportModelQueryConfigString = `export const modelQueryConfig = {\n    ${allDbModels\n      ?.map((model) => {\n        if (!model.dbStorageMethod) return;\n        return `${model.name}: {\n          ${\n            model.operationStorageLocationRelativeFilePath ||\n            model.isOperationIndex\n              ? `operationName: \"*\",`\n              : \"\"\n          }\n          dbStorageMethod: \"${model.dbStorageMethod}\",\n          ${\n            model.operationStorageLocationRelativeFilePath\n              ? `operationRelativePath: \"${model.operationStorageLocationRelativeFilePath}\",`\n              : \"\"\n          }\n        }`;\n      })\n      .filter(notEmpty)\n      .join(\",\\n\")}\n  };`;\n\n  // console.log({ dbLength: allDbModels.length });\n  // PART 3) Aggreagating all scripts into one big string\n\n  const indexationString = \"// THIS FILE HAS BEEN GENERATED\\n\"\n    .concat(\"\\n\")\n    // all imports\n    .concat(typeImportsString)\n    .concat(\"\\n\\n\")\n    // all exports\n    .concat(exportDbTypesString)\n    .concat(exportDbKeysString)\n    .concat(exportDbModelEnumString)\n    .concat(exportModelQueryConfigString)\n    .concat(\"\\n\")\n    .concat(\"// THANK YOU\\n\");\n\n  await newOperationWithFiles(\n    \"sdk-db\",\n    await getSdkDescription(\"sdk-db\"),\n    { \"src/sdk-db.ts\": indexationString },\n    { overwriteIfExists: true, skipYarnInstall, manualProjectRoot, dryrun }\n  );\n}"
  },
  "generateEnvSdksCli": {
    "name": "generateEnvSdksCli",
    "slug": "TsFunction",
    "id": "njzfudaxsctntjxvoyvoghgd",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " async () => {\n  const bundleConfig = (await db.get(\"BundleConfig\"))[0];\n\n  if (!bundleConfig) {\n    console.log(\"DIDNT WORK\");\n    return;\n  }\n\n  const [customProjectRoot] = process.argv.slice(2);\n  const defaultProjectRoot = getProjectRoot(process.cwd());\n\n  await generateEnvSdks(bundleConfig, {\n    manualProjectRoot: customProjectRoot || defaultProjectRoot,\n  });\n}"
  },
  "generateEnvSdks": {
    "name": "generateEnvSdks",
    "slug": "TsFunction",
    "id": "xwdsgraerovidegemnfnbcdv",
    "description": "generates sdk-env-public and sdk-env-private\n\nreturns the paths of the geneated operations",
    "operationName": "generate-sdk-operations",
    "rawText": " async (\n  bundleConfig: BundleConfig,\n  config?: {\n    manualProjectRoot?: string;\n    skipYarnInstall?: boolean;\n    dryrun?: boolean;\n  }\n) => {\n  const promises = [\n    newEnvSdk(bundleConfig, \"public\", config),\n    newEnvSdk(bundleConfig, \"private\", config),\n  ];\n\n  const results = await Promise.all(promises);\n\n  return results;\n}"
  },
  "generateFunctionPathsSdk": {
    "name": "generateFunctionPathsSdk",
    "slug": "TsFunction",
    "id": "gffwdhyxmyztrnsrpkbtalys",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n  skipYarnInstall?: boolean;\n  dryrun?: boolean;\n}) => {\n  const skipYarnInstall = config?.skipYarnInstall;\n  const dryrun = config?.dryrun;\n  const manualProjectRoot = config?.manualProjectRoot;\n  const projectRoot = manualProjectRoot || getProjectRoot();\n  if (!projectRoot) return;\n\n  const tsFunctions = await db.get(\"TsFunction\", { manualProjectRoot });\n\n  const functionPathsObject = mergeObjectsArray(\n    tsFunctions\n      .map((tsFunction) => {\n        const projectRelativePath = tsFunction.projectRelativePath;\n        const exists = fs.existsSync(\n          path.join(projectRoot, projectRelativePath)\n        );\n        if (!exists) return;\n        return { [tsFunction.name]: projectRelativePath };\n      })\n      .filter(notEmpty)\n  );\n\n  const operationObjectString = `export const sdkFunctionPaths = ${JSON.stringify(\n    functionPathsObject,\n    null,\n    2\n  )};`;\n\n  await newOperationWithFiles(\n    \"sdk-function-paths\",\n    await getSdkDescription(\"sdk-function-paths\"),\n    { \"src/sdk-function-paths.ts\": operationObjectString },\n    { overwriteIfExists: true, skipYarnInstall, manualProjectRoot, dryrun }\n  );\n}"
  },
  "generateFunctionSdksCli": {
    "name": "generateFunctionSdksCli",
    "slug": "TsFunction",
    "id": "uzwbmsazyyuqvpddqvkrcjbe",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " () => {\n  const [dryrunString, customProjectRoot] = process.argv.slice(2);\n  const dryrun = dryrunString === \"true\";\n  const defaultProjectRoot = getProjectRoot(process.cwd());\n  generateFunctionSdks({\n    manualProjectRoot: customProjectRoot || defaultProjectRoot,\n    dryrun,\n  });\n}"
  },
  "generateFunctionSdks": {
    "name": "generateFunctionSdks",
    "slug": "TsFunction",
    "id": "hgmbthiwhajidlbooxhvolns",
    "description": "Creates\n\n- sdk-api + sdk-api-keys (for all exposed functions)\n- sdk-js (functions that can be executed anywhere)\n- sdk-ui (functions that use JSX)\n\nOverwrites them if they already exist with minimal interruption time of the system",
    "operationName": "generate-sdk-operations",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n  skipYarnInstall?: boolean;\n  dryrun?: boolean;\n}) => {\n  const manualProjectRoot = config?.manualProjectRoot;\n\n  const { apiFunctions, jsFunctions, uiFunctions } =\n    await getFunctionSdksContent({ manualProjectRoot });\n\n  if (!apiFunctions || !jsFunctions || !uiFunctions) return;\n\n  const promises = [\n    // sdks\n    newFunctionSdkOperation(\"sdk-api\", apiFunctions, config),\n    newFunctionSdkOperation(\"sdk-js\", jsFunctions, config),\n    newFunctionSdkOperation(\"sdk-ui\", uiFunctions, config),\n\n    /**\n     * SDK Keys operations: Needed because \"sdk-api\" is node-only\n     */\n    newFunctionKeysSdkOperation(\n      \"sdk-api-keys\",\n      [\n        {\n          variableName: \"functionApiKeys\",\n          values: apiFunctions.map((x) => x.name),\n        },\n      ],\n      config\n    ),\n  ];\n\n  await Promise.all(promises);\n}"
  },
  "generateInterfacePathsSdkCli": {
    "name": "generateInterfacePathsSdkCli",
    "slug": "TsFunction",
    "id": "fvbaiglodtiqifnnzwudwnfu",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " () => {\n  const [dryrunString, customProjectRoot] = process.argv.slice(2);\n  const dryrun = dryrunString === \"true\";\n  const defaultProjectRoot = getProjectRoot(process.cwd());\n\n  const manualProjectRoot = customProjectRoot || defaultProjectRoot;\n  generateInterfacePathsSdk({ dryrun, manualProjectRoot });\n}"
  },
  "generateInterfacePathsSdk": {
    "name": "generateInterfacePathsSdk",
    "slug": "TsFunction",
    "id": "cfulweqdhoeyyucntaogfptb",
    "description": "`sdk-function-paths` indexes all operations and builds an object containing all operations.",
    "operationName": "generate-sdk-operations",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n  skipYarnInstall?: boolean;\n  dryrun?: boolean;\n}) => {\n  const skipYarnInstall = config?.skipYarnInstall;\n  const dryrun = config?.dryrun;\n  const manualProjectRoot = config?.manualProjectRoot;\n  const projectRoot = manualProjectRoot || getProjectRoot();\n  if (!projectRoot) return;\n\n  const tsInterfaces = await db.get(\"TsInterface\", {\n    manualProjectRoot,\n    operationName: \"*\",\n  });\n\n  const interfacePathsObject = mergeObjectsArray(\n    tsInterfaces\n      .map((tsInterface) => {\n        const projectRelativePath = tsInterface.projectRelativePath;\n        const exists = fs.existsSync(\n          path.join(projectRoot, projectRelativePath)\n        );\n        if (!exists) return;\n        return { [tsInterface.name]: projectRelativePath };\n      })\n      .filter(notEmpty)\n  );\n\n  const operationObjectString = `export const sdkInterfacePaths = ${JSON.stringify(\n    interfacePathsObject,\n    null,\n    2\n  )};`;\n\n  await newOperationWithFiles(\n    \"sdk-interface-paths\",\n    await getSdkDescription(\"sdk-interface-paths\"),\n    { \"src/sdk-interface-paths.ts\": operationObjectString },\n    { overwriteIfExists: true, skipYarnInstall, manualProjectRoot, dryrun }\n  );\n}"
  },
  "generateOperationsSdkCli": {
    "name": "generateOperationsSdkCli",
    "slug": "TsFunction",
    "id": "oouqrjftskrikrgboduyhwix",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " () => {\n  const [customProjectRoot] = process.argv.slice(2);\n  const defaultProjectRoot = getProjectRoot(process.cwd());\n\n  generateOperationsSdk({\n    manualProjectRoot: customProjectRoot || defaultProjectRoot,\n  });\n}"
  },
  "generateOperationsSdk": {
    "name": "generateOperationsSdk",
    "slug": "TsFunction",
    "id": "kyotzmkiuhpprppqwnmgikse",
    "description": "`sdk-operations` indexes all operations and builds an object containing all operations.",
    "operationName": "generate-sdk-operations",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n  skipYarnInstall?: boolean;\n  dryrun?: boolean;\n}) => {\n  const skipYarnInstall = config?.skipYarnInstall;\n  const dryrun = config?.dryrun;\n  const manualProjectRoot = config?.manualProjectRoot;\n  const projectRoot = manualProjectRoot || getProjectRoot();\n  if (!projectRoot) return;\n\n  const operationFolderPaths = await exploreOperationFolders({\n    basePath: getPathsWithOperations({ manualProjectRoot }),\n  });\n\n  const operationNamePathRows = operationFolderPaths.map(\n    (operationFolderPath) => {\n      const operationName = getLastFolder(operationFolderPath);\n\n      return `\"${operationName}\": \"${makeRelative(\n        operationFolderPath,\n        projectRoot\n      )}\"`;\n    }\n  );\n  const operationObjectString = `export const operations = { ${operationNamePathRows.join(\n    \",\\n\"\n  )} };`;\n\n  await newOperationWithFiles(\n    \"sdk-operations\",\n    await getSdkDescription(\"sdk-operations\"),\n    { \"src/sdk-operations.ts\": operationObjectString },\n    { overwriteIfExists: true, skipYarnInstall, manualProjectRoot, dryrun }\n  );\n}"
  },
  "generateSdkApiCli": {
    "name": "generateSdkApiCli",
    "slug": "TsFunction",
    "id": "yzaeeqcyoauhkledxgwhghsu",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " () => {\n  const [customProjectRoot] = process.argv.slice(2);\n  const defaultProjectRoot = getProjectRoot(process.cwd());\n\n  generateSdkApi({\n    manualProjectRoot: customProjectRoot || defaultProjectRoot,\n  });\n}"
  },
  "generateSdkApiWatcher": {
    "name": "generateSdkApiWatcher",
    "slug": "TsFunction",
    "id": "wrryfpmlzsopkboivpsdkilu",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " async () => {\n  if (isRegenerating === true) {\n    // Don't run if it's already running\n    return;\n  }\n  // console.log(\"Generate sdk-api...\");\n\n  // isRegenerating = true;\n  // await generateSdkApi();\n\n  // console.log(\"DONE, exiting server\");\n  // isRegenerating = false;\n  process.exit();\n}"
  },
  "generateSdkApi": {
    "name": "generateSdkApi",
    "slug": "TsFunction",
    "id": "uavhkpfgcxbcmemnduemzkjl",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n  skipYarnInstall?: boolean;\n  dryrun?: boolean;\n}) => {\n  const manualProjectRoot = config?.manualProjectRoot;\n\n  const { apiFunctions } = await getFunctionSdksContent({ manualProjectRoot });\n\n  if (!apiFunctions) return;\n\n  const promises = [\n    // sdks\n    newFunctionSdkOperation(\"sdk-api\", apiFunctions, config),\n\n    /**\n     * SDK Keys operations: Needed because \"sdk-api\" is node-only\n     */\n    newFunctionKeysSdkOperation(\n      \"sdk-api-keys\",\n      [\n        {\n          variableName: \"functionApiKeys\",\n          values: apiFunctions.map((x) => x.name),\n        },\n      ],\n      { ...config, skipYarnInstall: true }\n    ),\n  ];\n\n  await Promise.all(promises);\n}"
  },
  "generateSdkOperationsCli": {
    "name": "generateSdkOperationsCli",
    "slug": "TsFunction",
    "id": "puxscbyicjcfqrdcaplvcszm",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " () => {\n  const [dryrunString, customProjectRoot] = process.argv.slice(2);\n\n  const dryrun = dryrunString ? Boolean(dryrunString) : undefined;\n\n  const defaultProjectRoot = getProjectRoot(process.cwd());\n\n  generateSdkOperations(undefined, {\n    dryrun,\n    yarnInstallAfter: true,\n    manualProjectRoot: customProjectRoot || defaultProjectRoot,\n  });\n\n  if (dryrun) {\n    console.log(\"Check new-operation/assets\");\n  } else {\n    console.log(\"Check generated\");\n  }\n}"
  },
  "generateSdkOperations": {
    "name": "generateSdkOperations",
    "slug": "TsFunction",
    "id": "tqbtgvtvsdpkmyapprjvuodb",
    "description": "(re)generates all sdk operations for any project",
    "operationName": "generate-sdk-operations",
    "rawText": " async (\n  /**\n   * if not provided, will not generate env-sdks\n   */\n  bundleConfig?: BundleConfig,\n  config?: {\n    /**\n     * If true, will try to run yarn install before and if it fails, does not continue.\n     */\n    yarnInstallBefore?: boolean;\n    /**\n     * if true, yarn install will be skipped when generating the sdks, but run one time afterwards\n     *\n     * useful if you are sure that there will be multiple yarn Installs needed otherwise\n     *\n     * for os installation (where all operations already exist, don't do this, yarn installs will probably not happen at all)\n     */\n    yarnInstallAfter?: boolean;\n    manualProjectRoot?: string;\n    dryrun?: boolean;\n  }\n): Promise<boolean> => {\n  const manualProjectRoot = config?.manualProjectRoot;\n  const projectRoot = manualProjectRoot || getProjectRoot();\n  const yarnInstallAfter = config?.yarnInstallAfter;\n  const yarnInstallBefore = config?.yarnInstallBefore;\n  const dryrun = config?.dryrun;\n\n  if (!projectRoot) {\n    return false;\n  }\n\n  // NB: install this first, otherwise sdk-operations cannot be found\n  const promises = [\n    generateOperationsSdk({\n      manualProjectRoot,\n      dryrun,\n    }),\n    generateFunctionPathsSdk({\n      manualProjectRoot,\n      dryrun,\n    }),\n    generateInterfacePathsSdk({ manualProjectRoot, dryrun }),\n    generateDbSdk({\n      manualProjectRoot,\n      skipYarnInstall: yarnInstallAfter,\n      dryrun,\n    }),\n    generateFunctionSdks({\n      manualProjectRoot,\n      skipYarnInstall: yarnInstallAfter,\n      dryrun,\n    }),\n\n    bundleConfig\n      ? generateEnvSdks(bundleConfig, {\n          manualProjectRoot,\n          skipYarnInstall: yarnInstallAfter,\n          dryrun,\n        })\n      : undefined,\n  ];\n\n  await Promise.all(promises);\n\n  if (yarnInstallAfter) {\n    process.stdout.write(`Installing repo `);\n    try {\n      // NB: I got an engine error which seemed to break it, so to fix it I ignore engines now https://stackoverflow.com/questions/56617209/the-engine-node-is-incompatible-with-this-module\n\n      const result = execSync(\"yarn --prefer-offline --ignore-engines\", {\n        cwd: projectRoot,\n        encoding: \"utf8\",\n        stdio: \"pipe\",\n      });\n\n      console.log(\"✅\");\n\n      return true;\n    } catch (e: any) {\n      console.log(\"❌\");\n      const error: {\n        status: number;\n        signal: any;\n        output: (string | null)[];\n        pid: number;\n        stdout: string;\n        stderr: string;\n      } = e;\n      console.log(`Could not install:`, error);\n\n      return false;\n    }\n  }\n\n  return true;\n}"
  },
  "getFunctionSdksContent": {
    "name": "getFunctionSdksContent",
    "slug": "TsFunction",
    "id": "hfnbahxczlnyfrglvcpqvsmo",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n}): Promise<{\n  jsFunctions?: TsFunction[];\n  apiFunctions?: TsFunction[];\n  uiFunctions?: TsFunction[];\n}> => {\n  const manualProjectRoot = config?.manualProjectRoot;\n\n  const functionsPerClassification = await getSdkFunctionsPerClassification({\n    manualProjectRoot,\n  });\n\n  if (!functionsPerClassification) return {};\n\n  const jsFunctions = functionsPerClassification[\"cjs\"].concat(\n    functionsPerClassification[\"esm\"]\n  );\n\n  const apiFunctions = functionsPerClassification[\"node-cjs\"]\n    .concat(functionsPerClassification[\"node-esm\"])\n    .concat(functionsPerClassification[\"cjs\"])\n    .concat(functionsPerClassification[\"esm\"]);\n\n  const uiFunctions = functionsPerClassification[\"ui-cjs\"].concat(\n    functionsPerClassification[\"ui-esm\"]\n  );\n\n  return { jsFunctions, apiFunctions, uiFunctions };\n}"
  },
  "getSdkDescription": {
    "name": "getSdkDescription",
    "slug": "TsFunction",
    "id": "wonulqwinxxqvitewazgoqsa",
    "description": "Gets a description of any sdk operation from the assets",
    "operationName": "generate-sdk-operations",
    "rawText": " async (\n  operationName: string\n): Promise<string | undefined> => {\n  const descriptionPath = path.join(\n    __dirname,\n    \"..\",\n    \"assets\",\n    \"descriptions\",\n    `${operationName}.md`\n  );\n\n  if (!fs.existsSync(descriptionPath)) return;\n\n  const contents = await fs.readFile(descriptionPath, \"utf8\");\n\n  return contents;\n}"
  },
  "getSdkFunctionsPerClassification": {
    "name": "getSdkFunctionsPerClassification",
    "slug": "TsFunction",
    "id": "drwlnyptrzuwnzooqwvpnkeo",
    "description": "returns all sdk functions grouped by operation classification",
    "operationName": "generate-sdk-operations",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n}): Promise<FunctionsPerClassification | undefined> => {\n  const manualProjectRoot = config?.manualProjectRoot;\n  const projectRoot = manualProjectRoot || getProjectRoot();\n  if (!projectRoot) return;\n\n  const sdkDependants = await findDependantsRecursively(\"sdk\");\n\n  const tsFunctions = await db.get(\"TsFunction\", { manualProjectRoot });\n\n  const exportedFunctions = tsFunctions\n    .filter((x) => x.isExported)\n    .filter(tsFunctionIsIndexable)\n    .filter((x) => {\n      return x.operationName && !sdkDependants.includes(x.operationName);\n    })\n    .filter(onlyUnique2<TsFunction>((a, b) => a.name === b.name));\n\n  console.log({ exportedFunctions: exportedFunctions.length });\n\n  const operationFolders = await exploreOperationFolders({});\n  const operationClassificationObject =\n    await getOperationClassificationObject();\n\n  // console.log({ operationClassificationObject });\n  const operationIsSdkableObject = mergeObjectsArray(\n    await Promise.all(\n      operationFolders.map(async (operationFolderPath) => {\n        const packageJson = await getPackageJson({ operationFolderPath });\n        const isSdkable = packageJson?.operation?.isNotSdkable ? false : true;\n        const operationName = getLastFolder(operationFolderPath);\n\n        return { [operationName]: isSdkable };\n      })\n    )\n  );\n\n  const sdkFunctionsPerClassification = mergeObjectsArray(\n    operationClassificationConst.map((operationClassification) => {\n      const sdkFunctions = exportedFunctions\n        .filter((x) => {\n          if (!x.operationName) return false;\n          const isSdkable = operationIsSdkableObject[x.operationName];\n          return isSdkable;\n        })\n        .filter((x) =>\n          tsFunctionIsSdkable(\n            x,\n            operationClassificationObject,\n            operationClassification\n          )\n        )\n        .filter(onlyUnique2<TsFunction>((a, b) => a.name === b.name));\n\n      log(\n        `for ${operationClassification} we found ${sdkFunctions.length} functions`,\n        { type: \"debug\" }\n      );\n      if (sdkFunctions.length === 0)\n        log(\n          `Warning: 0 functions found for ${operationClassification} operations`,\n          { type: \"debug\" }\n        );\n\n      return { [operationClassification]: sdkFunctions };\n    })\n  ) as FunctionsPerClassification;\n\n  return sdkFunctionsPerClassification;\n}"
  },
  "isNonUiOperationBuild": {
    "name": "isNonUiOperationBuild",
    "slug": "TsFunction",
    "id": "umdtsnbiatuavgutqnrbhgig",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " (\n  eventName: WatchEventType,\n  path: string\n) => {\n  // for indexation we don't care about any other event than adding or changing a file\n  if (![\"add\", \"change\"].includes(eventName)) return false;\n  // in order to index a file, it must be in an operation, which means it must be in src\n  if (!path.includes(\"/build/\")) return false;\n  // only ts and tsx files matter, the rest doesn't need to be indexed\n  if (![\"js\"].includes(getExtension(path))) return false;\n\n  // only for operations\n  const operationPath = findOperationBasePath(path);\n  if (!operationPath) return false;\n\n  // we don't care about ui operations\n  const classification = getOperationClassification(operationPath);\n  if (!classification || classification.startsWith(\"ui-\")) {\n    return false;\n  }\n  return true;\n}"
  },
  "isRegenerating": {
    "name": "isRegenerating",
    "slug": "TsVariable",
    "id": "sogvgruiykcgpdvfrcnuyypr",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "newEnvSdk": {
    "name": "newEnvSdk",
    "slug": "TsFunction",
    "id": "bwsozprmlkrdjmcjzxcyjoki",
    "description": "# Environment variables\n\nAs a full stack app we need a good solution for environment variables that need to be accessible anywhere and can be customized, some `.gitignore'd`, some not. Some public, some only in the backend.\n\nconifg:\n- public (local, remote) = sdk-env-public\n- private (local, remote) = sdk-env-private\n\nThis information will be fetched from the bundleconfig",
    "operationName": "generate-sdk-operations",
    "rawText": " async (\n  /**\n   * NB: if this is not a bundle, a more general purpose bundle config should be used\n   */\n  bundleConfig: BundleConfig,\n  type: \"public\" | \"private\",\n  config?: {\n    manualProjectRoot?: string;\n    skipYarnInstall?: boolean;\n    dryrun?: boolean;\n  }\n): Promise<string | undefined> => {\n  // 1. gets env from bundle\n  const operationName = `sdk-env-${type}`;\n  const description = await getSdkDescription(operationName);\n\n  const projectRoot = config?.manualProjectRoot || getProjectRoot();\n  if (!projectRoot) return;\n\n  const skipYarnInstall = config?.skipYarnInstall;\n  const dryrun = config?.dryrun;\n  const envVariables =\n    bundleConfig.customisableBundleConfig[`${type}EnvironmentVariables`];\n  const realEnv =\n    envVariables && typeof envVariables === \"object\" ? envVariables : {};\n\n  // 2. creates [type].ts and [type]-local.ts that adheres a type interface\n\n  const typescriptFileString = `export const ${type}EnvironmentVariables = ${JSON.stringify(\n    realEnv,\n    null,\n    2\n  )};`;\n\n  const localComment =\n    \"Optionally, overwrite some of your environent variables locally here. Only applied in development. NB: When working in a team, it may be useful to .gitignore this file!\";\n\n  const localTypescriptFileString = `import { ${type}EnvironmentVariables } from \"./${type}\";\\n// ${localComment}\\nexport const ${type}LocalEnvironmentVariables: Partial<typeof ${type}EnvironmentVariables> = {};`;\n\n  const srcFileContentObject = {\n    [`src/${type}-local.ts`]: localTypescriptFileString,\n    [`src/${type}.ts`]: typescriptFileString,\n  };\n\n  // keep the same operationconfig as the os project, or make a new one if not found\n\n  const operationBasePath = await newOperationWithFiles(\n    operationName,\n    description,\n    srcFileContentObject,\n    { manualProjectRoot: projectRoot, skipYarnInstall, dryrun }\n  );\n  return operationBasePath;\n}"
  },
  "newFunctionKeysSdkOperation": {
    "name": "newFunctionKeysSdkOperation",
    "slug": "TsFunction",
    "id": "krmorpzpisrtczjayfsqwmpu",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " async (\n  operationName: string,\n  keyVariables: {\n    variableName: string;\n    values: string[];\n  }[],\n  config?: {\n    manualProjectRoot?: string;\n    skipYarnInstall?: boolean;\n    dryrun?: boolean;\n  }\n) => {\n  const keysConstString = keyVariables\n    .map((keyVariable) => {\n      return `export const ${keyVariable.variableName} = [ ${keyVariable.values\n        .map((value) => `\"${value}\"`)\n        .join(\",\\n\")} ];`;\n    })\n    .join(\"\\n\\n\");\n\n  const result = await newOperationWithFiles(\n    operationName,\n    undefined,\n    { [`src/${operationName}.ts`]: keysConstString },\n    { overwriteIfExists: true, ...config }\n  );\n\n  return result;\n}"
  },
  "newFunctionSdkOperation": {
    "name": "newFunctionSdkOperation",
    "slug": "TsFunction",
    "id": "yliybslonyhumwwrrgpifxhk",
    "description": "Uses an array of functions to create an operation that imports all those functions and exports an object where all those functions have been comprised",
    "operationName": "generate-sdk-operations",
    "rawText": " async (\n  operationName: string,\n  tsFunctions: TsFunction[],\n  config?: {\n    manualProjectRoot?: string;\n    skipYarnInstall?: boolean;\n    dryrun?: boolean;\n  }\n) => {\n  log(`${operationName} should contain ${tsFunctions.length} functions`, {\n    type: \"debug\",\n  });\n  const skipYarnInstall = config?.skipYarnInstall;\n  const manualProjectRoot = config?.manualProjectRoot;\n  const dryrun = config?.dryrun;\n  const importsString = tsFunctions\n    .map((fn) => `import { ${fn.name} } from \"${fn.operationName}\";`)\n    .join(\"\\n\");\n  const sdkConstString = `export const sdk = { ${tsFunctions\n    .map((fn) => `${fn.name}`)\n    .join(\",\\n\")}};`;\n\n  const sdkTypeString = `export type SdkType = typeof sdk;`;\n\n  const sdkTypescriptFileString = `${importsString}\\n\\n${sdkConstString}\\n\\n${sdkTypeString}`;\n\n  const description = await getSdkDescription(operationName);\n\n  const filesObject = { [`src/${operationName}.ts`]: sdkTypescriptFileString };\n  const result = await newOperationWithFiles(\n    operationName,\n    description,\n    filesObject,\n    {\n      overwriteIfExists: true,\n      manualProjectRoot,\n      skipYarnInstall,\n      dryrun,\n    }\n  );\n\n  return result;\n}"
  },
  "tsFunctionIsIndexable": {
    "name": "tsFunctionIsIndexable",
    "slug": "TsFunction",
    "id": "zxudegohdidtkfszusunnesv",
    "description": "The path of the function should be indexed by `generateSimpleIndex`, otherwise we can't import it either!",
    "operationName": "generate-sdk-operations",
    "rawText": " (tsFunction: TsFunction) => {\n  const fileId = getSrcRelativeFileId(\n    tsFunction.operationRelativeTypescriptFilePath\n  );\n  return isIndexableFileId(fileId);\n}"
  },
  "tsFunctionIsSdkable": {
    "name": "tsFunctionIsSdkable",
    "slug": "TsFunction",
    "id": "wgsxrdlkhdapebylmwysaefc",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " (\n  tsFunction: TsFunction,\n  operationClassificationObject: OperationClassificationObject,\n  operationClassification: OperationClassification\n) => {\n  const { operationName } = tsFunction;\n  if (!operationName) return false;\n\n  const functionClassification = operationClassificationObject[operationName];\n\n  const isSdkable = functionClassification === operationClassification;\n\n  return isSdkable;\n}"
  },
  "updateClassifications": {
    "name": "updateClassifications",
    "slug": "TsFunction",
    "id": "yctdycjwpatiieqnwpncrhhi",
    "description": "",
    "operationName": "generate-sdk-operations",
    "rawText": " () => {\n  forAllFolders({\n    type: \"operations\",\n    basePath: getPathsWithOperations(),\n    callback: async (folderPath, index) => {\n      const operationName = getLastFolder(folderPath);\n\n      const classificationIndexed = getOperationClassification(folderPath);\n      console.log(`${operationName}: ${classificationIndexed}`);\n\n      await db.update(\n        \"Operation\",\n        (item) => item.name === operationName,\n        (old) =>\n          mergeNestedObject(old, { operation: { classificationIndexed } }),\n        { operationName }\n      );\n\n      console.log(\"updated\");\n\n      return;\n    },\n  });\n}"
  },
  "augmentMarkdown": {
    "name": "augmentMarkdown",
    "slug": "TsFunction",
    "id": "kejuswerfazrqjdsygzhafim",
    "description": "Now that I've written this all down, it seems to be a quite an expensive operation, but we never need to do it for ensire websites, just for one page, and the result can easily be cached. I need to write a regex function that matches all text from a list of searchterms in markdown except if it's part of a link or image, and reduce the matches, creating a new markdown string every time. I think there are algorithms though that are more efficient because if there are like thousands of matches on a 2mb text, the thing would take much longer. Maybe it's more efficient to split up the text in smaller pieces and do the regex for every piece individually. This would have a limitation that you can't select cross-section, but I don't think that's my usecase anyway. If we later add support for making statements about a chapter or subsection and stuff like that, this limitation can also be resolved.\n\nAugments markdown in many ways for multiple purposes.\n\n- Parse the markdown instead of showing the results as React buttons. The link to \"#\" alt can become the same as a nice AugmentedWord hover, when it's found to be a selection result, we can highlight the selection whenever we hover over a link with that same text as alt as well, and add that hover as a note at the end of the selection.\n- ensure the parse parses `WordCombination`, `WordMatrix`, `Statement`, `AugmentedWord`, and `ContextualPromptResult`. It's a lot of work, but definitely worth it. Should be parsed as\n- remove the parsing of everything in the markdown render. This is also the end of sending `AugmentedWord`s to the frontend\n\nLATER:\n\n- CTA's, headers, footers, ads (check how I was planning to get those at codestorys-node or so)\n- Word frequency occurency styling\n- Subtexts and subwords",
    "operationName": "generative-functions-node",
    "rawText": " async <T extends string | null | undefined>(\n  markdown: T,\n  config?: {\n    isAdmin?: boolean;\n    /**\n     * TODO: make this faster first by finding all codeblocks in the file first (if this is enabled) and taking a subset of the mapped object then (mapped object  from sdk) and then placing it into the md\n     */\n    augmentCode?: boolean;\n    augmentWords?: boolean;\n    augmentStatements?: boolean;\n    /**\n     * Useful for sites like dev.to and medium where I don't have the capability for creating my own context-menu\n     */\n    augmentContextualPrompts?: boolean;\n    augmentContextualPromptResults?: boolean;\n    markdown_projectRelativeFilePath?: string;\n    /**\n     * If given, all augmented hyperlinks will be absolute to this given domain. Useful for posting on other sites\n     */\n    externalHost?: string;\n  }\n): Promise<{\n  augmentedMarkdown: T;\n  /**\n   * Still needed if you want to show the variants and derivatives in your own way\n   */\n  contextualPromptResults?: ContextualPromptResult[] | null;\n  /**\n   * Still needed if you watn to make it possible to do prompts in another way\n   */\n  contextualPromptsObject?: Omit<\n    ContextualPromptsObject,\n    \"databaseContextualPromptSlugs\"\n  >;\n}> => {\n  if (!markdown || markdown.trim() === \"\") {\n    // no markdown, just return the input\n    return {\n      augmentedMarkdown: markdown,\n    };\n  }\n\n  const {\n    isAdmin,\n    augmentCode,\n    augmentContextualPrompts,\n    augmentContextualPromptResults,\n    augmentStatements,\n    augmentWords,\n    markdown_projectRelativeFilePath,\n    externalHost,\n  } = destructureOptionalObject(config);\n  // do stuff with this configuration here\n\n  const fileType = getFileTypeFromPath(markdown_projectRelativeFilePath);\n\n  const augmentedWordObject = augmentCode\n    ? await getAugmentedWordObject()\n    : undefined;\n  // we need all prompts that seem interesting for this type of content\n\n  const isDev = isAdmin || process.env.NODE_ENV !== \"production\";\n\n  // we can't augment this to the markdown because it's a much more interactive thing, it probably wouldn't work. unless I do something with hyperlinks to the original content, where I make a page that lets you sign up to prompt something 🤯 this way I can integrate with any place that accepts hyperlinks in posts (linkedin, medium, dev.to, etc.)\n  const { databaseContextualPromptSlugs, ...contextualPromptsObject } =\n    await getContextualPrompts(\n      fileType === \"other\" ? undefined : fileType,\n      undefined,\n      isDev\n    );\n\n  //WordCombination, WordMatrix, Statement, AugmentedWord, and ContextualPromptResult\n\n  const contextualPromptResults = augmentContextualPromptResults\n    ? (\n        (await getContextualPromptResults({\n          promptSlugs: databaseContextualPromptSlugs,\n          prompt_projectRelativePath: markdown_projectRelativeFilePath,\n        })) || []\n      ).filter((x) => {\n        if (isDev) return true;\n        return !x.isFake && x.isFavorite;\n      })\n    : [];\n\n  const wordMatrixs = augmentWords\n    ? (await db.get(\"WordMatrix\")).map((x) =>\n        getSubsetFromObject(x, [\n          \"slug\",\n          \"name\",\n          \"description\",\n          \"descriptionAudio\",\n          \"emoji\",\n          \"image\",\n          \"rank\",\n          \"priorityLevel\",\n          \"type\",\n          \"usageCountCalculated\",\n          \"english\",\n        ])\n      )\n    : [];\n\n  const mappedWordMatrix = createMappedObject(wordMatrixs, \"slug\");\n\n  const wordCombinations = augmentWords ? await db.get(\"WordCombination\") : [];\n  const statements = augmentStatements ? await db.get(\"Statement\") : [];\n\n  // `tsFunctions, tsVariables, tsInterfaces`: find words between backticks, replace the word between `backticks` with `[\"term\"(---description and maybe code---)](url-to-file-or-#)`\n  //  to support multiline tooltips, the augmented markdown should contain `<br>` instead of newlines in the alt. It should be a configuration, and if newlines should be disabled, the tooltip should show only that that is capable of being on a single line.\n\n  const markdownWithCodespanAugmentation = markdown\n    .split(\" \")\n    .map((word) => {\n      if (!word.startsWith(\"`\") || !word.endsWith(\"`\")) {\n        return word;\n      }\n\n      const wordWithoutBackticks = word.slice(1, word.length - 1);\n\n      const augmentedWord = augmentedWordObject?.[wordWithoutBackticks];\n      if (!augmentedWord || !augmentedWord.spoiler) {\n        return word;\n      }\n\n      return makeMarkdownLink(\n        wordWithoutBackticks,\n        undefined,\n        augmentedWord.spoiler\n      );\n    })\n    .join(\" \");\n\n  const markdownAfterContextualPromptResults = contextualPromptResults.reduce(\n    (previousMarkdown, contextualPromptResult) => {\n      if (!contextualPromptResult.selectionString) {\n        // console.log(\"NO selectionString\");\n        return previousMarkdown;\n      }\n\n      const newMarkdown: string = previousMarkdown.replace(\n        contextualPromptResult.selectionString,\n        `${contextualPromptResult.selectionString} ${makeMarkdownLink(\n          \"?\",\n          undefined,\n          `${contextualPromptResult.selectionString}\\n\\n${contextualPromptResult.contextualPromptSlug}\\n\\n${contextualPromptResult.resultText}`\n        )}`\n      );\n\n      return newMarkdown;\n    },\n    markdownWithCodespanAugmentation\n  );\n  /**\n     `statements and selection results`: add [\"?\"(----reader-agreement, agreement, importancy, results----)](link-to-knowledge-base-or-#) at the end of the selection/statement\n     \n     Most expensive now are statements (selection results are limited because they are tied to the file already, but statements are not). We can later enhance the efficiency of statements to index which wordMatrix words they tie to, and filter out the unneeded ones this way.\n\n     */\n  const markdownAfterStatements = statements.reduce((previous, statement) => {\n    /**\n     * how to get this efficiently even if the propmt reulsts aren't always part of it? tough titty\n     */\n    const newMarkdown = previous.replace(\n      statement.description,\n      `${statement.description} ${makeMarkdownLink(\n        \"?\",\n        undefined,\n        `Statement: ${statement.description}.\\n\\nreaders-agreement: ${statement.readersAgreement}, agreement: ${statement.agreement}, importancy ${statement.importancy}`\n      )}`\n    );\n    return newMarkdown;\n  }, markdownAfterContextualPromptResults);\n\n  const markdownAfterWordCombinations = wordCombinations.reduce(\n    (previousMarkdown, wordCombination) => {\n      const words: Pick<\n        WordMatrix,\n        | \"english\"\n        | \"slug\"\n        | \"name\"\n        | \"description\"\n        | \"descriptionAudio\"\n        | \"emoji\"\n        | \"image\"\n        | \"rank\"\n        | \"priorityLevel\"\n        | \"type\"\n        | \"usageCountCalculated\"\n      >[] =\n        wordCombination.wordMatrixSlugs\n          ?.map((slug) =>\n            mappedWordMatrix[slug] ? mappedWordMatrix[slug] : undefined\n          )\n          .filter(notEmpty) || [];\n\n      // TODO: later I can add things like audio and statistics\n      const wordDefinitions = words\n        .map((word) => {\n          return `${word.name}: ${word.description}`;\n        })\n        .join(\"\\n\\n\");\n      const fullDescription = `${wordCombination.description}\\n\\n${wordDefinitions}`;\n      // `wordCombinations`: replace term with `[\"term\"(----description----)](link-to-website-or-#)` where description is the description of the term, but below that also all word definitions of the underlying wordmatrix words are explained\n      const newMarkdown = previousMarkdown.replace(\n        wordCombination.name,\n        makeMarkdownLink(wordCombination.name, undefined, fullDescription)\n      );\n\n      return newMarkdown;\n    },\n    markdownAfterStatements\n  );\n\n  /**\n  TODO:\n  LATER:\n\n  First I need to fix that I can either ADD things into a broader link that is already encapsulating something. Then I can do either that or create a new one. That will be the best solution\n\n  - `wordMatrixs`: if there is a wordcombination here already this doesn't matter. Otherwise, just replace the word with `[\"word\"(---description, audio, etc---)](#)`\n\n  - `prompts`: add the prompts like `[\"promptname\"(prompt-description)](link-to-execute-prompt?selection=abcdefg)` at the end of a header section for selection prompts, and at the end of a page for page-prompts\n\n  */\n  const augmentedMarkdown = markdownAfterWordCombinations as NonNullable<T>;\n\n  // console.log({ augmentedMarkdown });\n  return {\n    contextualPromptResults,\n    augmentedMarkdown,\n    contextualPromptsObject,\n  };\n}"
  },
  "canSeeFileContent": {
    "name": "canSeeFileContent",
    "slug": "TsFunction",
    "id": "myxttqugfqoqzrwrszwpnbkv",
    "description": "",
    "operationName": "generative-functions-node",
    "rawText": " (\n  parameters: Frontmatter | undefined,\n  isDev: boolean\n) => {\n  // dev can always see it\n  if (isDev) {\n    return true;\n  }\n\n  // no parameters seems fine\n  if (!parameters) {\n    return true;\n  }\n\n  if (parameters.isDraft === \"true\" || parameters.isSecret === \"true\") {\n    return false;\n  }\n\n  if (\n    parameters.authorizedGroup?.trim() === \"premium\" ||\n    parameters.authorizedGroup?.trim() === \"enterprise\"\n  ) {\n    // for now we have no way to check if you're premium/enterprise\n    return false;\n  }\n\n  if (parameters.isPrivate === \"true\") {\n    //\n    return false;\n  }\n\n  return true;\n}"
  },
  "canSeeFile": {
    "name": "canSeeFile",
    "slug": "TsFunction",
    "id": "uvtqeowseykndxjbvkcwqhee",
    "description": "TODO: use something like this to ensure we have the type safety and not work with strings >.<\n\n```ts\nimport { frontmatterToObject } from \"frontmatter-util\";\nimport webMarkdownFileTsInterface from \"markdown-types/db/ts-interfaces/webmarkdownfile.json\";\n```",
    "operationName": "generative-functions-node",
    "rawText": " (\n  parameters: FolderContent | undefined,\n  isDev: boolean\n) => {\n  // dev can always see it\n  if (isDev) {\n    return true;\n  }\n\n  // no parameters seems fine\n  if (!parameters) {\n    return true;\n  }\n\n  if (parameters.isDraft || parameters.isSecret) {\n    return false;\n  }\n\n  if (\n    parameters.authorizedGroup === \"premium\" ||\n    parameters.authorizedGroup === \"enterprise\"\n  ) {\n    // for now we have no way to check if you're premium/enterprise, but we can still see them\n    return true;\n  }\n\n  if (parameters.isPrivate) {\n    // private files can still be seen, just not the content\n    return true;\n  }\n\n  return true;\n}"
  },
  "expandFrontmatter": {
    "name": "expandFrontmatter",
    "slug": "TsFunction",
    "id": "ybhvcbwpaxqrpjdpxvshsbka",
    "description": "",
    "operationName": "generative-functions-node",
    "rawText": " (frontmatter?: Frontmatter) => {\n  if (!frontmatter) return {};\n  return {\n    isPrivate: frontmatter.isPrivate === \"true\",\n    authorizedGroup: frontmatter.authorizedGroup,\n    isDraft: frontmatter.isDraft === \"true\",\n    isSecret: frontmatter.isSecret === \"true\",\n  };\n}"
  },
  "findClosestAbsolutePath": {
    "name": "findClosestAbsolutePath",
    "slug": "TsFunction",
    "id": "wpckvdhzzqwndejjrqmcsuto",
    "description": "",
    "operationName": "generative-functions-node",
    "rawText": " async (\n  absoluteQueryPath: string\n): Promise<{\n  absoluteQueryPath: string;\n  isFile?: boolean;\n  isFolder?: boolean;\n}> => {\n  const pathExists = fs.existsSync(absoluteQueryPath);\n\n  const stats = pathExists ? await fs.stat(absoluteQueryPath) : null;\n  const isFile = stats?.isFile();\n  const isFolder = stats?.isDirectory();\n\n  const isValidPath = pathExists && (isFile || isFolder);\n\n  if (isValidPath) return { absoluteQueryPath, isFile, isFolder };\n\n  // no valid path\n\n  const folderUpPath = getFolderJs(absoluteQueryPath);\n\n  return findClosestAbsolutePath(folderUpPath);\n}"
  },
  "getContextualPromptResults": {
    "name": "getContextualPromptResults",
    "slug": "TsFunction",
    "id": "lqgicekrmhydukmfghmyntks",
    "description": "Gets all contextualPromptResults, but only if specific things are true\n\n- For any prompt we have for this filetype: get it from the database\n- For prompts about a folder: path/to/folder/.index/prompt-results.json\n- For prompts about a file or a selection thereof: path/to/folder/.index/[filename]/prompt-results.json\n\nNB: the slug of the ones in index should be the ID, and does not need to be set by the user, because we cannot guarantee that it's no duplicate.",
    "operationName": "generative-functions-node",
    "rawText": " async (config?: {\n  /**\n   * If given, will only provide `ContextualPromptResult`s for this path\n   */\n  prompt_projectRelativePath?: string;\n  /**\n   * If given, will only return the db result if it is part of this array\n   */\n  promptSlugs?: string[];\n}): Promise<ContextualPromptResult[] | null> => {\n  const { prompt_projectRelativePath, promptSlugs } =\n    destructureOptionalObject(config);\n\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    console.log(\"NO projectroot in getContextualPromptResults.ts\");\n    return null;\n  }\n  const prompt_absolutePath = prompt_projectRelativePath\n    ? path.join(projectRoot, prompt_projectRelativePath)\n    : undefined;\n\n  const exists = prompt_absolutePath\n    ? fs.existsSync(prompt_absolutePath)\n    : undefined;\n\n  const stats =\n    exists && prompt_absolutePath\n      ? await fs.stat(prompt_absolutePath)\n      : undefined;\n\n  const isFolder = stats ? stats.isDirectory() : false;\n  const isFile = stats ? stats.isFile() : false;\n  const pathParse = prompt_absolutePath\n    ? path.parse(prompt_absolutePath)\n    : undefined;\n\n  if (prompt_absolutePath && !exists) {\n    console.log(\"You gave a path that doesn't exist\", { prompt_absolutePath });\n    return null;\n  }\n\n  const dbResults = (await db.get(\"ContextualPromptResult\")).map(\n    omitUndefinedValues\n  );\n\n  const onlyForPath = prompt_projectRelativePath\n    ? dbResults?.filter(\n        (x) => x.prompt_projectRelativePath === prompt_projectRelativePath\n      )\n    : dbResults;\n\n  const onlyForPrompts = promptSlugs\n    ? onlyForPath.filter((result) => {\n        if (!result.contextualPromptSlug) return false;\n\n        if (promptSlugs.includes(result.contextualPromptSlug)) return true;\n\n        return false;\n      })\n    : onlyForPath;\n\n  if (!prompt_projectRelativePath || !pathParse || !prompt_absolutePath) {\n    // we don't need the .index one\n    console.log(\"No .index needed\", {\n      prompt_projectRelativePath,\n      pathParse,\n      prompt_absolutePath,\n    });\n    return onlyForPrompts;\n  }\n\n  const contextualPromptResultsJsonPath = isFile\n    ? path.join(pathParse.dir, \".index\", pathParse.name, \"prompt-results.json\")\n    : isFolder\n    ? path.join(prompt_absolutePath, \".index\", \"prompt-results.json\")\n    : undefined;\n\n  if (\n    !contextualPromptResultsJsonPath ||\n    !fs.existsSync(contextualPromptResultsJsonPath)\n  ) {\n    // console.log(\"results json path doesn't exist\", {\n    //   contextualPromptResultsJsonPath,\n    // });\n    return onlyForPrompts;\n  }\n\n  const indexResults = await readJsonFile<ContextualPromptResult[]>(\n    contextualPromptResultsJsonPath\n  );\n\n  if (!indexResults) {\n    console.log(\n      \"We tried to read the results but couldn't\",\n      contextualPromptResultsJsonPath\n    );\n    return onlyForPrompts;\n  }\n\n  const allResults: ContextualPromptResult[] = onlyForPrompts\n    .concat(indexResults)\n    .sort((a, b) => {\n      if (a.isFake) return 1;\n      if (b.isFake) return -1;\n      return 0;\n    })\n    .sort((a, b) => {\n      if (a.isFavorite) return -1;\n      if (b.isFavorite) return 1;\n      return 0;\n    });\n  return allResults;\n}"
  },
  "getContextualPromptsArray": {
    "name": "getContextualPromptsArray",
    "slug": "TsFunction",
    "id": "upeejpbgmbaufjwyvvljxmbf",
    "description": "Wrapper around the database to support the usecase of storing a file in a custom location for contextualPrompts.",
    "operationName": "generative-functions-node",
    "rawText": " async (\n  /**\n   * If available, will also get the scoped context\n   */\n  scopeProjectRelativePath?: string\n): Promise<{\n  databaseResult: ContextualPrompt[];\n  scopeResult?: ContextualPrompt[];\n}> => {\n  const databaseResult = await db.get(\"ContextualPrompt\");\n  if (!scopeProjectRelativePath) {\n    return { databaseResult };\n  }\n\n  // if we need the scoped contextual prompt, it should be saved in the index of the file itself.\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return { databaseResult };\n\n  // it can be a file or a folder\n\n  const scopeAbsolutePath = path.join(projectRoot, scopeProjectRelativePath);\n\n  if (!fs.existsSync(scopeAbsolutePath)) {\n    return { databaseResult };\n  }\n\n  const stats = await fs.stat(scopeAbsolutePath);\n\n  const parsedScopePath = path.parse(scopeAbsolutePath);\n  const filename = stats.isFile() ? parsedScopePath.base : undefined;\n  const scopeFolderPath = stats.isDirectory()\n    ? scopeAbsolutePath\n    : parsedScopePath.dir;\n  const scopeAbsoluteDbPath = path.join(\n    scopeFolderPath,\n    getFolderRelativeScopeDbFilePath(filename)\n  );\n\n  if (!fs.existsSync(scopeAbsoluteDbPath)) return { databaseResult };\n\n  // if it exists, add it to the result\n  const jsonString = await fs.readFile(scopeAbsoluteDbPath, \"utf8\");\n  const scopeResult = tryParseJson<ContextualPrompt[]>(jsonString);\n  if (!scopeResult) return { databaseResult };\n\n  const finalScopeResult: ContextualPrompt[] = scopeResult.map((x) => ({\n    ...x,\n    scopeProjectRelativePath,\n  }));\n\n  // add the scopeProjectRelativePath so we don't need to store it in the db\n  return {\n    databaseResult,\n    scopeResult: finalScopeResult,\n  };\n}"
  },
  "getContextualPrompts": {
    "name": "getContextualPrompts",
    "slug": "TsFunction",
    "id": "xcsxctuusvdampjiijqoguiv",
    "description": "Returns all contextual prompts for the selection and for the page with the right context type",
    "operationName": "generative-functions-node",
    "rawText": " async (\n  /**\n   * If not given, will return all\n   */\n  contextType?: FileType,\n  scopeProjectRelativePath?: string,\n  isDev?: boolean\n): Promise<ContextualPromptsObject> => {\n  const contextualPromptsObject = await getContextualPromptsArray(\n    scopeProjectRelativePath\n  );\n\n  const databaseContextualPromptSlugs =\n    contextualPromptsObject.databaseResult.map((x) => x.slug);\n  const contextualPrompts = Object.values(contextualPromptsObject).flat();\n\n  const rightType = contextualPrompts\n    .filter((x) => (contextType ? x.contextType?.includes(contextType) : true))\n    .filter((x) => (isDev ? true : x.isFavorite))\n    .map(omitUndefinedValues)\n    // sort on fav first\n    .sort((a, b) => {\n      if (a.isFavorite && !b.isFavorite) return -1;\n      if (b.isFavorite && !a.isFavorite) return 1;\n      return 0;\n    });\n\n  const selectionContextualPrompts = rightType.filter(\n    (x) => x.usesSelection || x.usesAnyContext\n  );\n\n  const pageContextualPrompts = rightType.filter(\n    (x) => (!x.usesSelection && x.usesContext) || x.usesAnyContext\n  );\n\n  const folderContextualPrompts = rightType.filter(\n    (x) =>\n      (!x.usesSelection && !x.usesContext && x.folderContentContext) ||\n      x.usesAnyContext\n  );\n  return {\n    selectionContextualPrompts,\n    pageContextualPrompts,\n    folderContextualPrompts,\n    databaseContextualPromptSlugs,\n  };\n}"
  },
  "getFirstFile": {
    "name": "getFirstFile",
    "slug": "TsFunction",
    "id": "ytxgctodozncvmgfzzbthoie",
    "description": "Gets the first file in a directory:\n\nEither readme or index, or the first file it finds.",
    "operationName": "generative-functions-node",
    "rawText": " async (\n  fullPath: string\n): Promise<string | undefined> => {\n  const content = await fs.readdir(fullPath, {\n    encoding: \"utf8\",\n    withFileTypes: true,\n  });\n  const files = content.filter((x) => x.isFile());\n  const readme = files.find((x) => x.name.toLowerCase() === \"readme.md\")?.name;\n  const index = files.find((x) => x.name.startsWith(\"index.\"))?.name;\n  const firstFile = readme || index || files[0]?.name || undefined;\n  return firstFile;\n}"
  },
  "getFolderRelativeScopeDbFilePath": {
    "name": "getFolderRelativeScopeDbFilePath",
    "slug": "TsFunction",
    "id": "nbfqmdwuawugulnubexcxacl",
    "description": "Function to centralise the convention of the db file location of a scoped prompt",
    "operationName": "generative-functions-node",
    "rawText": " (filename?: string) => {\n  return filename\n    ? `.index/${filename}/contextual-prompts.json`\n    : `.index/contextual-prompts.json`;\n}"
  },
  "getReaderPageProps": {
    "name": "getReaderPageProps",
    "slug": "TsFunction",
    "id": "jxebnopljosbsfgnjwdhumxo",
    "description": "NB: this thing doesn't know about the basepath, it allows any path in the project.\n\nIdea: would it be easy to allow for path outside of project as well?",
    "operationName": "generative-functions-node",
    "rawText": " async (\n  /**\n   * BasePath for this project\n   */\n  basePath: string | undefined,\n  /**\n   * QueryPath as in the URL\n   */\n  queryPath: string,\n  /**\n   * If true, isDev will be overwritten to be false, even in prod\n   */\n  isAdmin?: boolean,\n  /**\n   * If given, will be used instead of basePath, if it exists.\n   */\n  absoluteBasePath?: string\n) => {\n  const contextualPromptCategories: CategoryChildObject =\n    await getContextualPromptCategories();\n\n  // console.log(\"getReaderPageProps:\", { projectRelativeFilePath });\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return {\n      props: {\n        notFound: true,\n        notFoundReason: \"No projectroot\",\n        contextualPromptCategories,\n      },\n    };\n  }\n\n  const expectedAbsolutePath = absoluteBasePath\n    ? path.join(absoluteBasePath, queryPath)\n    : basePath\n    ? path.join(projectRoot, basePath, queryPath)\n    : path.join(projectRoot, queryPath);\n\n  const { absoluteQueryPath, isFile, isFolder } = await findClosestAbsolutePath(\n    expectedAbsolutePath\n  );\n  const isValidPath = absoluteQueryPath === expectedAbsolutePath;\n\n  const folderPath = isFile\n    ? path.parse(absoluteQueryPath).dir\n    : absoluteQueryPath;\n\n  const dirents = await fs.readdir(folderPath, {\n    withFileTypes: true,\n    encoding: \"utf8\",\n  });\n\n  // TODO: Confirm that this works if you run the server locally. For development locally it should be working\n  const isDev = process.env.NODE_ENV === \"development\";\n\n  const readmeDirent = dirents.find(\n    (x) => x.name.toLowerCase() === \"readme.md\"\n  );\n\n  const readmePath = readmeDirent\n    ? path.join(folderPath, readmeDirent.name)\n    : undefined;\n  const readmeFrontmatter = readmePath\n    ? (await readMarkdownFile(readmePath))?.parameters\n    : undefined;\n  const canSeeFolder = readmePath\n    ? canSeeFileContent(readmeFrontmatter, isDev)\n    : true;\n  // TODO: look in all readmes from basePath until the folder we are, to see if this should be allowed to see. It's very easy now to still see and access content if there's folders inside of folders that should not be allowed to be seen.\n\n  const navigation: FolderContent[] = (\n    await Promise.all(\n      dirents.map(async (dirent) => {\n        // TODO: think about it. Maybe we should do something with symbolic links because we don't want to go deep forever, it could actually be nice to use this feature of the OS as well!\"\n\n        const ignoredFilesFolders = [\".DS_Store\", \".index\"];\n        if (ignoredFilesFolders.includes(dirent.name)) return;\n\n        const fullPath = path.join(folderPath, dirent.name);\n\n        const type = dirent.isDirectory()\n          ? \"folder\"\n          : dirent.isSymbolicLink()\n          ? \"link\"\n          : dirent.isFile()\n          ? \"file\"\n          : \"unknown\";\n\n        const firstFile =\n          type === \"folder\" ? await getFirstFile(fullPath) : undefined;\n\n        /**\n         * If it's a markdown file, take its parameters\n         * If it's a folder, take the parameters of the REAMDE in that folder.\n         */\n        const frontmatter =\n          getExtension(dirent.name) === \"md\"\n            ? (await readMarkdownFile(fullPath))?.parameters\n            : type === \"folder\"\n            ? (await readMarkdownFile(path.join(fullPath, \"README.md\")))\n                ?.parameters\n            : undefined;\n        const folderContent: FolderContent = {\n          type,\n          name: dirent.name,\n          firstFile,\n          frontmatter,\n\n          projectRelativePath: makeRelative(\n            path.join(folderPath, dirent.name),\n            projectRoot\n          ),\n        };\n\n        return folderContent;\n      })\n    )\n  )\n    .filter(notEmpty)\n    .map(({ frontmatter, ...other }) => {\n      const folderContent: FolderContent = {\n        ...other,\n        ...expandFrontmatter(frontmatter),\n      };\n      return folderContent;\n    })\n    .filter((file) => {\n      // filter out the files that should be HIDDEN\n      return canSeeFile(file, isDev);\n    })\n    .map(omitUndefinedValues);\n\n  const markdownParse = isFile\n    ? await readMarkdownFile(absoluteQueryPath)\n    : null;\n\n  const allowedOtherExtensions = [\".ts\", \".tsx\", \".json\"];\n\n  const pathParse = path.parse(absoluteQueryPath);\n\n  const rawContent =\n    isFile && allowedOtherExtensions.includes(pathParse.ext)\n      ? await fs.readFile(absoluteQueryPath, \"utf8\")\n      : undefined;\n\n  // TODO: in case of a folder, we might be able to show an indexed thing based on the information of this emptyness (just the files and folders around it). This could provide a lot of interesting content already.\n  const canSeeContent = canSeeFileContent(markdownParse?.parameters, isDev);\n\n  const fileContentString =\n    !canSeeContent || !canSeeFolder || !isFile\n      ? null\n      : markdownParse\n      ? markdownParse.raw\n      : rawContent\n      ? rawContent\n      : null;\n\n  const augmentedResult = await augmentMarkdown(fileContentString, {\n    // for now no code yet, it's too slow\n    isAdmin,\n    augmentCode: false,\n    augmentContextualPrompts: false,\n    augmentContextualPromptResults: true,\n    augmentStatements: true,\n    augmentWords: true,\n    externalHost: undefined,\n    markdown_projectRelativeFilePath: makeRelative(\n      absoluteQueryPath,\n      projectRoot\n    ),\n  });\n\n  const props: ReaderProps = {\n    contextualPromptCategories,\n    notFound: !isValidPath,\n    notFoundReason: isValidPath\n      ? null\n      : `Path isn't valid: ${expectedAbsolutePath}. We found ${absoluteQueryPath}`,\n    isFolder,\n    canSeeContent,\n    unauthorizedWarningMessage: canSeeContent\n      ? null\n      : \"You have to be premium to see this. [Click here to see our offers](/offers)\",\n    markdown: augmentedResult?.augmentedMarkdown || rawContent || null,\n    navigation,\n    actualProjectRelativeFilePath: makeRelative(absoluteQueryPath, projectRoot),\n    contextualPromptResults: augmentedResult?.contextualPromptResults || null,\n    contextualPromptsObject: augmentedResult?.contextualPromptsObject || null,\n  };\n\n  return { props };\n}"
  },
  "makeMarkdownLink": {
    "name": "makeMarkdownLink",
    "slug": "TsFunction",
    "id": "mdtmrsrhfjwrzezmkhxenome",
    "description": "function that writes markdown for a text + url + alt. This may differ per platform in the end, for now I'll use my own: `[\"text\"(alt)](url)`",
    "operationName": "generative-functions-node",
    "rawText": " (text: string, url?: string, alt?: string) => {\n  return `[${text}](${url || \"#\"}${\n    alt ? ` \"${alt.replaceAll(\"\\n\", \"<br>\").replaceAll('\"', '\\\\\"')}\"` : \"\"\n  })`;\n}"
  },
  "readerPageGetStaticPaths": {
    "name": "readerPageGetStaticPaths",
    "slug": "TsFunction",
    "id": "tqvjkppphmwdttfbuyrmrdgo",
    "description": "NB: I can't do this with a fallback , because next.js doesn't include my docs folder into the bundle.\n\nA solution could be to add the docs folder into the next.js folder or copy it...\n\nhttps://github.com/vercel/next.js/discussions/32236?sort=new#discussioncomment-3029649\n\nTher are other workarounds here to make sure it ends up in the bundle.",
    "operationName": "generative-functions-node",
    "rawText": " async () => {\n  // TODO: what does context.locale do? can we use that for the domain or so? because it's the only context we have here , so that might be super useful\n\n  const basePath = process.env.NEXT_PUBLIC_BASEPATH;\n  // can probably also fetch the domain using the api, right? I might be able to determine what the basepath is based on an environment variable.\n\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    console.log(\"NO PROJECTROOT\");\n    return { fallback: \"blocking\", paths: [] };\n  }\n\n  const realBasePath = basePath\n    ? path.join(projectRoot, basePath)\n    : projectRoot;\n\n  // const paths = (\n  //   await explore({ basePath: realBasePath, includeFoldersWithResults: true })\n  // ).map((x) => x.path);\n\n  // for now, let's just generate the props every time. later we can fetch the actual paths here, but that would require lots of calculation, so this might actually be fine since it will cache the result. We can also make the page load until the props are provided. I need to read the docs about it to make it all super smooth\n  return {\n    paths: [],\n\n    // paths.map((path) => {\n    //   const queryPath = makeRelative(path, realBasePath).split(\"/\");\n    //   return {\n    //     params: {\n    //       queryPath,\n    //     },\n    //   };\n    // }),\n    // TODO: Maybe needs to be \"false\"?\n    fallback: \"blocking\",\n  };\n}"
  },
  "readerPageGetStaticProps": {
    "name": "readerPageGetStaticProps",
    "slug": "TsFunction",
    "id": "jvmrgfpbsgtyuadolwfdptoa",
    "description": "",
    "operationName": "generative-functions-node",
    "rawText": " async (\n  context: GetStaticPropsContext\n) => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    // NB: this can happen on revalidation and blocked static requests, because we aren't using .projectRoot file anywhere. It's fine\n    console.log(\"NO PROJECTROOT\");\n\n    const props: ReaderProps = {\n      notFound: true,\n      notFoundReason: \"This file cannot be found.\",\n    };\n\n    return { props };\n  }\n\n  const basePath = process.env.NEXT_PUBLIC_BASEPATH;\n\n  // the queryPath from\n  const queryPath = context.params?.queryPath;\n  const realQueryPathArray = queryPath ? makeArray(queryPath) : [];\n  const realQueryPath = realQueryPathArray.join(\"/\");\n\n  const staticPropResult = omitUndefinedValues(\n    await getReaderPageProps(basePath || \"\", realQueryPath, false)\n  );\n\n  return staticPropResult;\n}"
  },
  "Dataset": {
    "name": "Dataset",
    "slug": "TsFunction",
    "id": "vqkognfdaeowkopnhmegcgaq",
    "description": "",
    "operationName": "generative-ui",
    "rawText": " () => {\n  const categoriesQuery = queries.useGetContextualPromptCategories();\n\n  return (\n    <Div id=\"dataset\" className=\"h-screen overflow-y-scroll\">\n      <MarkdownContent\n        config={{}}\n        content={`\\`\\`\\`json\\n${JSON.stringify(\n          categoriesQuery.data?.result,\n          undefined,\n          2\n        )}\\n\\`\\`\\``}\n      />\n    </Div>\n  );\n}"
  },
  "FileActions": {
    "name": "FileActions",
    "slug": "TsFunction",
    "id": "ksrhomxujftckatimhvchlpj",
    "description": "",
    "operationName": "generative-ui",
    "rawText": " (props: {\n  basePath?: string;\n  navigation?: FolderContent[];\n  projectRelativeFilePath?: string;\n}) => {\n  const { basePath, navigation, projectRelativeFilePath } = props;\n  const actions = useFileActions(basePath, navigation);\n  const admin = useAdmin();\n  const alert = useAlert();\n  const { save, isSaved } = useFileWriter({\n    projectRelativeFilePath,\n    hideButtons: true,\n    initialWriterView: \"edit\",\n  });\n\n  const saveAction: ContextMenuItem = {\n    getTitle: () => \"💾 Save\",\n    getIsEnabled: () => !isSaved,\n    onClick: () => save(),\n  };\n\n  const allActions = [saveAction].concat(actions);\n\n  return (\n    <Div className=\"flex flex-row flex-wrap\">\n      {allActions.map((action) => {\n        if (action.getIsEnabled?.(projectRelativeFilePath) === false) {\n          return null;\n        }\n\n        return (\n          <Div\n            className=\"hover:bg-black/10 p-2 cursor-pointer\"\n            onClick={async () => {\n              await action.onClick(projectRelativeFilePath);\n\n              if (!admin.refetch) {\n                alert?.(\"WTF no admin\");\n              }\n              admin.refetch?.();\n            }}\n          >\n            {action.getTitle(projectRelativeFilePath)}\n          </Div>\n        );\n      })}\n    </Div>\n  );\n}"
  },
  "generativeWebInitialValues": {
    "name": "generativeWebInitialValues",
    "slug": "TsVariable",
    "id": "ucmvvvwxaqbjyjbzqpzotjbt",
    "description": "",
    "operationName": "generative-ui"
  },
  "Menu": {
    "name": "Menu",
    "slug": "TsFunction",
    "id": "cbtmtvcymbqnrwgapwlkshjh",
    "description": "`\"wise\"` component that lets you render a menu easily, including search\n\n-----\n\nTODO:\n\n- provide menu with NestedWebPage<unknown>[]",
    "operationName": "menu",
    "rawText": " (\n  props: MenuProps & {\n    message?: string;\n  }\n) => {\n  const {\n    queryPaths,\n    isLoading,\n    message,\n    augmentedWords,\n    webPagesNested,\n    webPagesFlat,\n    menuHeader,\n  } = props;\n\n  const realWebPages: NestedWebPage[] =\n    !webPagesNested && queryPaths\n      ? getLegacyMenu(queryPaths) || []\n      : webPagesNested || [];\n\n  const [showMenu, setShowMenu] = useStore(\"menu.showMenu\");\n\n  useHotkey(isCtrlP, () => setShowMenu(true), []);\n  useHotkey(isAltB, () => setShowMenu(!showMenu), [showMenu]);\n\n  const [isMobileMenuEnabled, setIsMobileMenuEnabled] = useStore(\n    \"menu.isMobileMenuEnabled\"\n  );\n\n  /**\n   * This is a slow function to calculate for a lot of paths, needs to be optimised\n   */\n\n  const [search, setSearch] = useState(\"\");\n  const isSearching = search.length > 0;\n\n  const closeMenu = (\n    <Div className=\"lg:hidden\">\n      <Div>\n        <ClickableIcon\n          emoji=\"╳\"\n          onClick={() => {\n            setIsMobileMenuEnabled(false);\n          }}\n        />\n      </Div>\n    </Div>\n  );\n\n  return (\n    <Div>\n      <Div className=\"flex flex-row justify-between w-full\">\n        {menuHeader?.()}\n        {closeMenu}\n      </Div>\n\n      <Input\n        value={search}\n        placeholder=\"Search\"\n        onChange={(e) => setSearch(e.target.value)}\n        className=\"border px-2 border-white bg-transparent w-full rounded-lg h-9 focus:outline-none\"\n        autoComplete=\"off\"\n      />\n\n      {isLoading ? (\n        <FancyLoader />\n      ) : isSearching && webPagesFlat ? (\n        <PathSearchResults\n          search={search}\n          paths={webPagesFlat.map((x) => x.queryPath)}\n          augmentedWords={augmentedWords}\n        />\n      ) : !isSearching && realWebPages ? (\n        <NestedMenu items={realWebPages} headersClickable />\n      ) : (\n        <P>{message || \"Menu.tsx: Something's wrong, no message given\"}) </P>\n      )}\n    </Div>\n  );\n}"
  },
  "NavButton": {
    "name": "NavButton",
    "slug": "TsFunction",
    "id": "kmmbnwcfuxvxlyluoyovubub",
    "description": "",
    "operationName": "generative-ui",
    "rawText": " (props: {\n  onClick?: () => void;\n  href?: string;\n  isActive?: boolean;\n  title: string;\n  id?: string;\n  isDisabled?: boolean;\n  openContextMenuProps?: object;\n}) => {\n  const {\n    href,\n    title,\n    onClick,\n    isActive,\n    openContextMenuProps,\n    id,\n    isDisabled,\n  } = props;\n\n  const className = ` ${isActive ? \"dark:bg-blue-800\" : \"dark:bg-gray-700\"} ${\n    isDisabled ? \"\" : \"dark:hover:bg-gray-600\"\n  } ${isActive ? \"bg-blue-300\" : \"bg-gray-100\"} ${\n    isDisabled ? \"\" : \"light:hover:bg-gray-200\"\n  } rounded-md border border-black p-2 my-1 mr-2 cursor-pointer lg:mr-4`;\n  if (onClick) {\n    return (\n      <P\n        id={id}\n        onClick={onClick}\n        className={className}\n        {...openContextMenuProps}\n      >\n        {title}\n      </P>\n    );\n  }\n\n  return (\n    <ALink id={id} href={href} className={className}>\n      <div id={id} {...openContextMenuProps}>\n        {title}\n      </div>\n    </ALink>\n  );\n}"
  },
  "PromptButton": {
    "name": "PromptButton",
    "slug": "TsFunction",
    "id": "qgswwmpzbffvjnbcklhafamq",
    "description": "",
    "operationName": "generative-ui",
    "rawText": " (props: {\n  item: ContextualPrompt;\n  markdown?: string | null;\n  contextSelection?: string | null;\n  projectRelativeFilePath?: string;\n}) => {\n  const { item, markdown, projectRelativeFilePath, contextSelection } = props;\n  const admin = useAdmin();\n  const router = useRouter();\n  const showPromptAlert = usePromptResultAlert();\n  const alert = useAlert();\n  const title = `${item.isFavorite ? \"⭐️ \" : \"\"}${item.title || item.name}`;\n\n  const projectRelativeFolderPath = getFolderJs(projectRelativeFilePath);\n  return (\n    <Tooltip\n      hoverTimeout={100}\n      tooltip={\n        <Div>\n          <P className=\"font-bold text-xl\">{title}</P>\n          {item.description ? (\n            <MarkdownContent content={item.description} config={{}} />\n          ) : null}\n          <br />\n\n          <ClickableIcon\n            emoji={\n              item.isFavorite\n                ? \"⭐️ Favorite (click to change)\"\n                : \"💩 Not favorite (click to change)\"\n            }\n            onClick={async () => {\n              // go to upsert ContextualPrompt db page.\n              const apiResult = await api.upsertDbModel(\"ContextualPrompt\", {\n                ...item,\n                isFavorite: !item.isFavorite,\n              });\n\n              showStandardResponse(apiResult);\n\n              admin.refetch?.();\n            }}\n          />\n\n          <ClickableIcon\n            emoji=\"✏️ Edit\"\n            onClick={() => {\n              if (!admin.isAdminActive) {\n                warningToast(\n                  \"You can't do this yet! You first need to install your server on your machine\"\n                );\n                return;\n              }\n              // go to upsert ContextualPrompt db page.\n              router.push(`/edit/ContextualPrompt?id=${item.id}`);\n            }}\n          />\n\n          <ClickableIcon\n            emoji=\"🗑 Delete\"\n            onClick={async () => {\n              alert?.(\n                \"Are you sure?\",\n                \"You're going to remove this prompt from your database\",\n                [\n                  {\n                    text: \"Do it\",\n                    style: \"destructive\",\n                    onPress: async () => {\n                      const apiResult = await api.deleteDbModel(\n                        \"ContextualPrompt\",\n                        item.id\n                      );\n\n                      showStandardResponse(apiResult);\n\n                      if (apiResult?.result?.isSuccesful) {\n                        admin.refetch?.();\n                      }\n                    },\n                  },\n                  {\n                    text: \"Cancel\",\n                    style: \"cancel\",\n                  },\n                ]\n              );\n              // delete prompt\n            }}\n          />\n\n          {contextSelection ? null : (\n            <ClickableIcon\n              emoji=\"💥 Apply on folder\"\n              onClick={() => {\n                if (!projectRelativeFolderPath) return;\n\n                alert?.(\n                  \"Apply on folder\",\n                  `You're going to apply the prompt ${item.name} on all files in the folder. Are you sure?`,\n                  [\n                    { style: \"cancel\", text: \"cancel\" },\n                    {\n                      style: \"default\",\n                      text: \"Yes\",\n                      onPress: async () => {\n                        const apiResult =\n                          await api.processPromptOnFolderWithContext({\n                            projectRelativeFolderPath,\n                            promptSlug: item.slug,\n                            isRecursive: false,\n                          });\n\n                        showStandardResponse(apiResult);\n                      },\n                    },\n                    {\n                      style: \"destructive\",\n                      text: \"Yes, recursive\",\n                      onPress: async () => {\n                        const apiResult =\n                          await api.processPromptOnFolderWithContext({\n                            projectRelativeFolderPath,\n                            promptSlug: item.slug,\n                            isRecursive: true,\n                          });\n\n                        showStandardResponse(apiResult);\n                      },\n                    },\n                  ]\n                );\n              }}\n            />\n          )}\n        </Div>\n      }\n      placement=\"top\"\n    >\n      <NavButton\n        onClick={async () => {\n          if (!markdown) return;\n          await processPrompt({\n            contextualPromptSlug: item.slug,\n            showPromptAlert,\n            contextualContent: {\n              contextContent: markdown,\n              contextSelection,\n              context_projectRelativeFilePath: projectRelativeFilePath,\n            },\n          });\n\n          router.replace({\n            query: {\n              queryPath: router.query.queryPath,\n              variant: item.slug,\n            },\n          });\n        }}\n        title={item.title || item.name}\n      />\n    </Tooltip>\n  );\n}"
  },
  "ReaderPageNext": {
    "name": "ReaderPageNext",
    "slug": "TsFunction",
    "id": "omeyoyeawwxfvriszpihslui",
    "description": "ReaderPage to export for next project. Uses either the props from the next server, or if they're available, the props from the query.",
    "operationName": "generative-ui",
    "rawText": " (props: ReaderProps) => {\n  // props provide the static data for the website\n  const queryPath = useQueryPath();\n  const basePath = process.env.NEXT_PUBLIC_BASEPATH;\n  const [config] = useStore(\"generativeWeb.config\");\n\n  const readerPageQuery = queries.useGetReaderPageProps(\n    basePath,\n    queryPath,\n    true,\n    config.activeCustomBasePath\n  );\n\n  const queryProps = readerPageQuery.data?.result?.props;\n\n  // either use the props returned from the query or from the static site\n  const realProps = queryProps?.actualProjectRelativeFilePath\n    ? queryProps\n    : props;\n  return <Div>TeSt</Div>;\n  //  return <ReaderPage {...realProps} />;\n}"
  },
  "ReaderPage": {
    "name": "ReaderPage",
    "slug": "TsFunction",
    "id": "scnmidvgzxbklskuxpddkupz",
    "description": "",
    "operationName": "generative-ui",
    "rawText": " (props: ReaderProps) => {\n  const [sidebarHidden, setSidebarHidden] = useState(false);\n  const router = useRouter();\n  const [customUrl, setCustomUrl, customUrlInfo] = useStore(\"api.customUrl\");\n  const [_, setAuthToken] = useStore(\"api.authToken\");\n  const admin = useAdmin();\n  const queryPath = router.asPath.slice(1);\n  const showPromptAlert = usePromptResultAlert();\n  const alert = useAlert();\n  const basePath = process.env.NEXT_PUBLIC_BASEPATH;\n\n  const {\n    markdown,\n    actualProjectRelativeFilePath,\n    contextualPromptResults,\n    contextualPromptsObject,\n    navigation,\n    isFolder,\n    canSeeContent,\n    unauthorizedWarningMessage,\n    notFound,\n  } = props;\n\n  const { renderFileWriter, save, isSaved } = useFileWriter({\n    projectRelativeFilePath: actualProjectRelativeFilePath,\n    hideButtons: true,\n    initialWriterView: \"edit\",\n  });\n\n  const promo = `**What to do now?**\n- [🤝 Let's get to know each other! Book a call](https://calendly.com/karsens/30min)\n- [🕺 Join our discord](https://discord.gg/gehCtKJk)${\n    admin.isAdminActive\n      ? \"\"\n      : \"\\n- [🧪 Install your server](/gpt-ide/README.md)\"\n  }\n- [🏛 See my premium services and offers](/offers)\n- [🤯 Join our AI hacker villa 🏝](https://codefrombali.com)`;\n\n  const onFocus = async () => {\n    if (!customUrlInfo.hydrated) {\n      return;\n    }\n    const localUrl = \"http://localhost:42000\";\n\n    if (customUrl === localUrl) {\n      return;\n    }\n\n    const isAlive = (await apiWithConfig.ping({ apiUrl: localUrl })).result;\n\n    if (isAlive) {\n      setCustomUrl(localUrl);\n      // NB: Hardcoded?\n      setAuthToken(\"xwjkfycqhakpudymxmysxlei\");\n      alert?.(\n        \"Connected to localhost\",\n        \"It seems your server is running locally, you're now connected. You can now interact with your local file system to apply prompts on your own knowledge base!\",\n        [\n          { text: \"Okay\", style: \"default\", onPress: () => router.reload() },\n          {\n            text: \"Undo\",\n            style: \"destructive\",\n            onPress: () => {\n              setCustomUrl(null);\n            },\n          },\n        ]\n      );\n    }\n  };\n\n  React.useEffect(() => {\n    window.addEventListener(\"focus\", onFocus);\n    //   window.addEventListener(\"blur\", onBlur);\n    // Calls onFocus when the window first loads\n    onFocus();\n    // Specify how to clean up after this effect:\n    return () => {\n      window.removeEventListener(\"focus\", onFocus);\n      //  window.removeEventListener(\"blur\", onBlur);\n    };\n  }, []);\n\n  const projectRelativeBaseFolderPath = isFolder\n    ? actualProjectRelativeFilePath\n    : getFolderJs(actualProjectRelativeFilePath);\n\n  const filename = isFolder\n    ? undefined\n    : getFileOrFolderName(actualProjectRelativeFilePath);\n\n  const thePrompts = isFolder\n    ? contextualPromptsObject?.folderContextualPrompts || []\n    : contextualPromptsObject?.pageContextualPrompts || [];\n\n  const fileContextualPromptResults = contextualPromptResults?.filter(\n    (x) => !x.selectionString\n  );\n  const selectionContextualPromptResults = contextualPromptResults?.filter(\n    (x) => !!x.selectionString\n  );\n\n  const variantResult = useVariantResult(contextualPromptResults);\n  // const fileType =\n  //   fileTypePerExtension[\n  //     getExtension(\n  //       props.projectRelativeFilePath\n  //     ) as keyof typeof fileTypePerExtension\n  //   ] || undefined;\n  // NB: this doesn't allow inline links so we cannot use this type of color highlihgting...\n  const codeblockWrappedMarkdown = variantResult?.resultText\n    ? variantResult?.resultText\n    : // : fileType === \"code\"\n      // ? `\\`\\`\\`tsx\\n${markdown}\\n\\`\\`\\``\n      // : fileType === \"data\"\n      // ? `\\`\\`\\`json\\n${markdown}\\n\\`\\`\\``\n      markdown;\n\n  const contentString = codeblockWrappedMarkdown\n    ? codeblockWrappedMarkdown\n    : !canSeeContent && unauthorizedWarningMessage\n    ? unauthorizedWarningMessage\n    : props.notFound\n    ? props.notFoundReason || \"Not found\"\n    : \"No content\";\n  const markdownParse = mdToJsonParse(contentString);\n\n  const folderPath = isFolder ? queryPath : getFolderJs(queryPath);\n\n  const markdownContentConfig = {\n    fileContextualPromptResults,\n    selectionContextualPromptResults,\n    projectRelativeBaseFolderPath,\n    projectRelativeMarkdownFilePath: actualProjectRelativeFilePath,\n    disableSelectionContextMenu: true,\n    selectionPrompts: contextualPromptsObject?.selectionContextualPrompts,\n  };\n\n  const renderEditContent = () => {\n    return (\n      <Div className=\"flex flex-1 flex-col lg:h-full lg:overflow-y-scroll\">\n        <FileActions\n          projectRelativeFilePath={actualProjectRelativeFilePath}\n          basePath={basePath}\n          navigation={navigation}\n        />\n        {actualProjectRelativeFilePath ? renderFileWriter() : null}\n      </Div>\n    );\n  };\n\n  const renderPage = () => (\n    <Div className=\"flex flex-1 flex-col\">\n      <FileActions\n        projectRelativeFilePath={actualProjectRelativeFilePath}\n        basePath={basePath}\n        navigation={navigation}\n      />\n      {sidebarHidden ? (\n        <Div className=\"max-lg:hidden lg:block flex justify-end\">\n          <ClickableIcon emoji=\"<<\" onClick={() => setSidebarHidden(false)} />\n        </Div>\n      ) : null}\n      <VariantSelector\n        projectRelativeFilePath={actualProjectRelativeFilePath}\n        folderPath={folderPath}\n        isFolder={isFolder}\n        filename={filename}\n        contextualPromptResults={fileContextualPromptResults}\n      />\n\n      {/* <Shareable > */}\n      <Div className={\"p-1\"}>\n        <MarkdownContent\n          config={markdownContentConfig}\n          content={contentString}\n        />\n      </Div>\n      {/* </Shareable> */}\n\n      <SelectionPrompts\n        contentString={contentString}\n        projectRelativeFilePath={actualProjectRelativeFilePath}\n        selectionContextualPrompts={\n          props.contextualPromptsObject?.selectionContextualPrompts\n        }\n      />\n\n      <Div>\n        <P className=\"font-bold\">Apply a prompt on the whole file</P>\n        <Div className=\"flex flex-row flex-wrap\">\n          {/* Speak */}\n          <NavButton\n            title=\"🎤 Speak\"\n            onClick={async () => {\n              alert?.(\"Coming soon\", \"coming soon\");\n            }}\n          />\n          {/* Free form */}\n          {isFolder ? null : (\n            <NavButton\n              title=\"🕊 Free-form prompt\"\n              onClick={async () => {\n                let question = prompt(\n                  \"What do you want to ask/prompt about this file?\"\n                );\n\n                if (!question || question === \"\") {\n                  return;\n                }\n\n                let name = prompt(\n                  \"If we should add this prompt into the database, how should we call it? (leave empty if you don't want to save it)\"\n                );\n\n                const realName = name === \"\" ? null : name;\n\n                const customPromptContent = `I am reading this file:\\n\\n\\`\\`\\`\\n%context\\n\\`\\`\\`\\n\\n${question}`;\n\n                await processPrompt({\n                  contextualContent: {\n                    contextContent: contentString,\n                    context_projectRelativeFilePath:\n                      actualProjectRelativeFilePath,\n                  },\n                  showPromptAlert,\n                  customPromptContent,\n                  saveNewPromptWithName: realName,\n                });\n              }}\n            />\n          )}\n\n          {thePrompts.map((prompt) => {\n            return (\n              <PromptButton\n                key={`prompt${prompt.id}`}\n                item={prompt}\n                markdown={markdown}\n                projectRelativeFilePath={actualProjectRelativeFilePath}\n              />\n            );\n          })}\n        </Div>\n      </Div>\n      {isFolder && admin.isAdminActive ? (\n        <Div>\n          Execute for all files\n          <Div className=\"flex flex-row flex-wrap\">\n            {contextualPromptsObject?.pageContextualPrompts.map((prompt) => {\n              return (\n                <NavButton\n                  onClick={() => {\n                    alert?.(\n                      \"Not implemented yet\",\n                      \"Execute a certain prompt for all files in a folder, recursively. Should not show the result immediately because these things should be queued and the result is too big to show immediately. There should be settings before you execute all prompts: recursively nested folders? how fast should it be executed? Which model? Etc.\"\n                    );\n                  }}\n                  title={prompt.title || prompt.name}\n                />\n              );\n            })}\n          </Div>\n        </Div>\n      ) : null}\n\n      <Div className=\"pt-4 pb-12\">\n        <MarkdownContent content={promo} config={{}} />\n      </Div>\n    </Div>\n  );\n\n  const variantsOnLg =\n    !fileContextualPromptResults ||\n    sidebarHidden ||\n    !fileContextualPromptResults.length ? null : (\n      <Div className=\"lg:block max-lg:hidden lg:w-[280px] 2xl:w-[400px] lg:h-full lg:overflow-y-scroll\">\n        <Div className=\"flex flex-row ml-3\">\n          <ClickableIcon emoji=\"╳\" onClick={() => setSidebarHidden(true)} />\n          <P className=\"ml-2 font-bold\">File Prompt Results</P>\n        </Div>\n        {fileContextualPromptResults?.map((result) => {\n          if (!result.resultText) return null;\n          return (\n            <Div className=\"m-2 p-2 bg-gray-100 dark:bg-slate-800 rounded-lg\">\n              <Div className=\"w-full flex justify-between\">\n                <P className=\"font-bold\">{result.contextualPromptSlug}</P>\n                <ClickableIcon\n                  emoji=\"👀\"\n                  onClick={() => {\n                    const query: {\n                      queryPath: string | string[] | undefined;\n                      variant?: string;\n                    } = {\n                      queryPath: router.query.queryPath,\n                      variant: result.contextualPromptSlug,\n                    };\n\n                    router.push({ query }, undefined, { shallow: true });\n                  }}\n                />\n              </Div>\n              <MarkdownContent\n                config={markdownContentConfig}\n                content={result.resultText}\n              />\n            </Div>\n          );\n        })}\n      </Div>\n    );\n  return true ? (\n    <MarkdownParsePresentation\n      markdownParse={markdownParse}\n      projectRelativeBaseFolderPath={projectRelativeBaseFolderPath || \"/\"}\n      projectRelativeMarkdownFilePath={actualProjectRelativeFilePath || \"/\"}\n    />\n  ) : (\n    <Div className=\"lg:flex lg:flex-row h-full\">\n      <Menu\n        notFound={notFound}\n        projectRelativeFilePath={actualProjectRelativeFilePath}\n        folderPath={folderPath}\n        filename={filename}\n        isFolder={isFolder}\n        navigation={navigation}\n        contextualPromptsObject={contextualPromptsObject}\n        fileContextualPromptResults={fileContextualPromptResults}\n        selectionContextualPromptResults={selectionContextualPromptResults}\n        thePrompts={thePrompts}\n      />\n\n      <div className=\"flex flex-col flex-1 lg:h-full lg:overflow-y-scroll\">\n        <Tabs\n          tabs={[\n            { emoji: \"🪄\", title: \"Generate\", renderTab: renderPage },\n            {\n              emoji: \"🛝\",\n              title: \"Slides\",\n              renderTab: () => (\n                <MarkdownParsePresentation\n                  markdownParse={markdownParse}\n                  projectRelativeBaseFolderPath={\n                    projectRelativeBaseFolderPath || \"/\"\n                  }\n                  projectRelativeMarkdownFilePath={\n                    actualProjectRelativeFilePath || \"/\"\n                  }\n                />\n              ),\n            },\n            { emoji: \"✏️\", title: \"Write\", renderTab: renderEditContent },\n          ]}\n          title={queryPath.split(\"?\")[0]}\n        />\n      </div>\n\n      {variantsOnLg}\n    </Div>\n  );\n}"
  },
  "SelectionPrompts": {
    "name": "SelectionPrompts",
    "slug": "TsFunction",
    "id": "paosivmpketjsdyofykrvncz",
    "description": "",
    "operationName": "generative-ui",
    "rawText": " (props: {\n  selectionContextualPrompts?: ContextualPrompt[];\n  contentString: string;\n  projectRelativeFilePath?: string;\n}) => {\n  const showPromptAlert = usePromptResultAlert();\n  const alert = useAlert();\n  const { selectionContextualPrompts, contentString, projectRelativeFilePath } =\n    props;\n  const admin = useAdmin();\n\n  const { selection: contextSelection, reset } = useLastSelection();\n\n  /**\n   * TODO: also sort them here based on which selection you make (`.contextualContent.contextSelection`) and your settings (probably isFavorite first, but other sorting may be beneficial.\n   */\n  const promptItems: SelectionItem[] =\n    selectionContextualPrompts?.map((prompt) => {\n      const item: SelectionItem = {\n        onClick: () =>\n          processPrompt({\n            contextualPromptSlug: prompt.slug,\n            contextualContent: {\n              contextSelection,\n              contextContent: contentString,\n              context_projectRelativeFilePath: projectRelativeFilePath,\n            },\n            showPromptAlert,\n          }),\n        title: prompt.name || \"Noname\",\n        // TODO: not sure if this is the right level, but eventually we want to filter based on the selection, maybe\n        isEnabled: true,\n      };\n\n      return item;\n    }) || [];\n\n  const selectionWordCount = contextSelection\n    ? contextSelection.split(\" \").length\n    : 0;\n\n  const isStatement = selectionWordCount > 1;\n  const isWord = selectionWordCount <= 4;\n\n  const selectionItems: SelectionItem[] = [\n    {\n      onClick: async () => {\n        if (!contextSelection) {\n          alert?.(\n            \"Select a word\",\n            `You didn't select a word or word-combination (up to 4 words)`\n          );\n          return;\n        }\n        const apiResult = await api.addWord(contextSelection, undefined);\n\n        showStandardResponse(apiResult);\n\n        admin.refetch?.();\n      },\n      title: \"🧠 Add word\",\n      isEnabled: isWord,\n    },\n\n    {\n      onClick: async () => {\n        if (!contextSelection) {\n          alert?.(\n            \"Select a statement\",\n            `You didn't select a statement (minimum 2 words)`\n          );\n          return;\n        }\n\n        // NB: for now, don't let user add agreement and importancy, just assume the defaults. Let's see where this goes first\n\n        const apiResult = await api.addStatement(\n          contextSelection,\n          undefined,\n          undefined\n        );\n\n        showStandardResponse(apiResult);\n\n        admin.refetch?.();\n      },\n      title: \"🧠 Add statement\",\n      isEnabled: isStatement,\n    },\n\n    {\n      title: \"🕊 Free-form prompt\",\n      isEnabled: true,\n      onClick: async () => {\n        let question = prompt(\"What do you want to ask/prompt?\");\n\n        if (!question || question === \"\") {\n          return;\n        }\n\n        let name = prompt(\n          \"How should we call the prompt? (empty for not storing)\"\n        );\n        const realName = name === \"\" ? null : name;\n\n        const customPromptContent = `I am reading this file:\\n\\n\\`\\`\\`\\n%context\\n\\`\\`\\`\\n\\nMore specifically, I'm looking at this part: \\n\\n\\`\\`\\`\\n%selection\\n\\`\\`\\`\\n\\n${question}`;\n\n        await processPrompt({\n          contextualContent: {\n            contextContent: contentString,\n            context_projectRelativeFilePath: projectRelativeFilePath,\n            contextSelection,\n          },\n          showPromptAlert,\n          customPromptContent,\n          saveNewPromptWithName: realName,\n        });\n      },\n    },\n\n    {\n      title: \"🎤 Speak\",\n      isEnabled: true,\n      onClick: () => {\n        alert?.(\n          \"Coming soon!\",\n          <Div>\n            <P>\n              This button should let you record your voice so you can ask a\n              question through human speech. The speech will be converted into\n              text by whisper, it will then choose an existing prompt action, or\n              if it can't find that, do a free-form prompt.\n            </P>\n\n            <P>\n              P.S. Would be nice if this option is there by default, also for\n              other menus, or it's even accessible via other ways, but this is a\n              great way to try it out first.\n            </P>\n          </Div>\n        );\n      },\n    },\n  ];\n\n  return (\n    <Div>\n      <P className=\"font-bold\">Apply a prompt on your selection</P>\n      <Div className=\"bg-black/20 dark:bg-white/20 flex flex-row justify-between rounded-md p-2 my-2\">\n        {contextSelection ? (\n          <>\n            <P>{contextSelection}</P>\n            <ClickableIcon emoji=\"❌\" onClick={() => reset()} />\n          </>\n        ) : (\n          <P>Please select a piece of text first</P>\n        )}\n      </Div>\n\n      {contextSelection ? (\n        <Div className=\"flex flex-row flex-wrap\">\n          {selectionItems\n            .filter((selectionItem) => selectionItem.isEnabled)\n            .map((item, index) => {\n              return (\n                <NavButton\n                  title={item.title}\n                  onClick={item.onClick}\n                  key={`sele${index}`}\n                />\n              );\n            })}\n\n          {selectionContextualPrompts?.map((prompt) => {\n            return (\n              <PromptButton\n                key={`selectPrompt${prompt.id}`}\n                item={prompt}\n                contextSelection={contextSelection}\n                markdown={contentString}\n                projectRelativeFilePath={projectRelativeFilePath}\n              />\n            );\n          })}\n        </Div>\n      ) : null}\n    </Div>\n  );\n}"
  },
  "setConfig": {
    "name": "setConfig",
    "slug": "TsFunction",
    "id": "zojsizmvwbpfqoxdpqykpsmz",
    "description": "",
    "operationName": "react-with-native-form",
    "rawText": " <TInputs, TState extends { [key: string]: any }>(\n  DataForm: (props: DataFormProps<TInputs, TState>) => JSX.Element,\n  config: DataFormConfig<TInputs>\n) => {\n  return (props: DataFormProps<TInputs, TState>) => {\n    return <DataForm {...config} {...props} />;\n  };\n}"
  },
  "SettingsPage": {
    "name": "SettingsPage",
    "slug": "TsFunction",
    "id": "ludmybtqnrrwpanukwycbxnx",
    "description": "",
    "operationName": "generative-ui",
    "rawText": " () => {\n  const [config, _, { hydrated }] = useStore(\"generativeWeb.config\");\n  const [customUrl, __, { hydrated: apiHydrated }] = useStore(\"api.customUrl\");\n  return (\n    <Div className=\"max-lg:mx-4 lg:mx-20\">\n      {hydrated && apiHydrated ? (\n        <FunctionForm\n          tsFunction={SetConfigIndex}\n          initialValues={[\n            customUrl,\n            config.disableAdmin,\n            config.customAbsoluteBasePaths,\n          ]}\n          submitFunction={setConfig}\n          withResult={() => {\n            showStandardResponse({ isSuccessful: true, message: \"Updated\" });\n          }}\n        />\n      ) : (\n        <FancyLoader />\n      )}\n    </Div>\n  );\n}"
  },
  "useAdmin": {
    "name": "useAdmin",
    "slug": "TsFunction",
    "id": "ztrdgbcnhuhheuhzsatpgcxo",
    "description": "Useful hook to make a static site dynamic for administrator",
    "operationName": "generative-ui",
    "rawText": " () => {\n  const queryPath = useQueryPath();\n  const { refetch, isLoading } = queries.useGetReaderPageProps(\n    process.env.NEXT_PUBLIC_BASEPATH || \"\",\n    queryPath,\n    true\n  );\n\n  const meQuery = queries.useGetMeWithContext();\n\n  const isAdmin = !!meQuery.data?.result?.groups?.find(\n    (x: Group) => x.slug === \"admin\"\n  );\n\n  const [config] = useStore(\"generativeWeb.config\");\n\n  const isAdminActive = isAdmin && !config.disableAdmin;\n  const result: {\n    isAdminActive: boolean;\n    isLoading?: boolean;\n    refetch?: typeof refetch;\n  } = isAdminActive\n    ? {\n        isAdminActive,\n        isLoading,\n        refetch,\n      }\n    : { isAdminActive };\n\n  return result;\n}"
  },
  "useFileActions": {
    "name": "useFileActions",
    "slug": "TsFunction",
    "id": "gilyjdqskaakuewtpkfzizif",
    "description": "",
    "operationName": "generative-ui",
    "rawText": " (\n  basePath?: string,\n  navigation?: FolderContent[]\n) => {\n  const admin = useAdmin();\n\n  const updateFrontmatter = async (\n    projectRelativePath: string | undefined,\n    newFrontmatter: { [key: string]: string }\n  ) => {\n    if (!projectRelativePath) return;\n\n    if (!basePath) return;\n\n    const apiResult = await api.updateFrontmatter({\n      projectRelativePath,\n      frontmatter: newFrontmatter,\n    });\n\n    showStandardResponse(apiResult);\n\n    if (apiResult.result?.isSuccessful) {\n      admin.refetch?.();\n    }\n  };\n\n  const alert = useAlert();\n\n  const items: ContextMenuItem[] = [\n    {\n      getTitle: () => \"🗑 Delete\",\n      onClick: (projectRelativePath) => {\n        if (!projectRelativePath) return;\n\n        if (!basePath) return;\n\n        const basePathRelative = makeRelative(projectRelativePath, basePath);\n        alert?.(\"Are you sure?\", `Do you want to delete ${basePathRelative}?`, [\n          { style: \"cancel\", text: \"Cancel\" },\n          {\n            text: \"Delete\",\n            style: \"destructive\",\n            onPress: async () => {\n              // delete also works, but trash seems better for now.\n              const apiResult = await api.deleteFileOrFolder(\n                projectRelativePath\n              );\n\n              showStandardResponse(apiResult);\n\n              if (apiResult?.result?.isSuccessful) {\n                admin.refetch?.();\n              }\n            },\n          },\n        ]);\n      },\n    },\n    {\n      getTitle: () => \"📣 Rename\",\n      onClick: async (projectRelativePath) => {\n        if (!projectRelativePath) return;\n        let newFilename = prompt(\n          \"What should the new name be?\",\n          getFileOrFolderName(projectRelativePath)\n        );\n        if (!newFilename) return;\n        const apiResult = await api.renameFileOrFolder(\n          projectRelativePath,\n          newFilename\n        );\n\n        showStandardResponse(apiResult);\n        if (apiResult?.result?.isSuccessful) {\n          admin.refetch?.();\n        }\n      },\n    },\n    {\n      getTitle: () => \"↩️ Move\",\n      onClick: async (projectRelativePath) => {\n        if (!projectRelativePath) return;\n\n        if (!basePath) return;\n\n        const basePathRelative = makeRelative(projectRelativePath, basePath);\n        let newLocation = prompt(\n          \"Where should this file/folder be moved to?\",\n          getFolderJs(basePathRelative)\n        );\n        if (!newLocation) return;\n\n        const apiResult = await api.movePath(\n          projectRelativePath,\n          basePath + \"/\" + newLocation\n        );\n\n        showStandardResponse(apiResult);\n        if (apiResult?.result?.isSuccessful) {\n          admin.refetch?.();\n        }\n      },\n    },\n\n    {\n      getTitle: () => \"👯‍♀️ Make a copy\",\n      onClick: async (projectRelativePath) => {\n        if (!projectRelativePath) return;\n\n        const apiResult = await api.copyPath(projectRelativePath);\n\n        showStandardResponse(apiResult);\n\n        if (apiResult?.result?.isSuccessful) {\n          admin.refetch?.();\n        }\n      },\n    },\n\n    {\n      getTitle: () => \"🔎 Open in Explorer\",\n      onClick: async (projectRelativePath) => {\n        if (!projectRelativePath) return;\n\n        if (!basePath) return;\n\n        const apiResult = await api.fileExplorerOpen(projectRelativePath);\n\n        showStandardResponse(apiResult);\n      },\n    },\n\n    {\n      getTitle: () => \"💻 Open in VSCode\",\n      onClick: async (projectRelativePath) => {\n        if (!projectRelativePath) return;\n\n        if (!basePath) return;\n\n        const apiResult = await api.vscodeOpen({\n          files: [{ projectRelativePath }],\n        });\n\n        showStandardResponse(apiResult);\n      },\n    },\n\n    {\n      getIsEnabled: (projectRelativePath) =>\n        navigation?.find((x) => x.projectRelativePath === projectRelativePath)\n          ?.authorizedGroup !== \"\",\n      getTitle: () => \"🕊 Make free\",\n      onClick: (path) => updateFrontmatter(path, { authorizedGroup: \"\" }),\n    },\n    {\n      getIsEnabled: (projectRelativePath) =>\n        navigation?.find((x) => x.projectRelativePath === projectRelativePath)\n          ?.authorizedGroup !== \"premium\",\n\n      getTitle: () => \"🏛 Make indie-only\",\n      onClick: (path) =>\n        updateFrontmatter(path, { authorizedGroup: \"premium\" }),\n    },\n\n    {\n      getIsEnabled: (projectRelativePath) =>\n        navigation?.find((x) => x.projectRelativePath === projectRelativePath)\n          ?.authorizedGroup !== \"enterprise\",\n      getTitle: () => \"🚀 Make startup-only\",\n      onClick: (path) =>\n        updateFrontmatter(path, { authorizedGroup: \"enterprise\" }),\n    },\n\n    {\n      getIsEnabled: (projectRelativePath) =>\n        !navigation?.find((x) => x.projectRelativePath === projectRelativePath)\n          ?.isPrivate,\n      getTitle: () => \"🔑 Set private\",\n      onClick: (path) => updateFrontmatter(path, { isPrivate: \"true\" }),\n    },\n    {\n      getIsEnabled: (projectRelativePath) =>\n        navigation?.find((x) => x.projectRelativePath === projectRelativePath)\n          ?.isPrivate === true,\n      getTitle: () => \"🔑 Set public\",\n      onClick: (path) => updateFrontmatter(path, { isPrivate: \"false\" }),\n    },\n    {\n      getIsEnabled: (projectRelativePath) =>\n        navigation?.find((x) => x.projectRelativePath === projectRelativePath)\n          ?.isSecret !== true,\n      getTitle: () => \"🔒 Set secret\",\n      onClick: (path) => updateFrontmatter(path, { isSecret: \"true\" }),\n    },\n    {\n      getIsEnabled: (projectRelativePath) =>\n        navigation?.find((x) => x.projectRelativePath === projectRelativePath)\n          ?.isSecret === true,\n      getTitle: () => \"🔒 Set open\",\n      onClick: (path) => updateFrontmatter(path, { isSecret: \"false\" }),\n    },\n    {\n      getIsEnabled: (projectRelativePath) =>\n        navigation?.find((x) => x.projectRelativePath === projectRelativePath)\n          ?.isDraft !== true,\n      getTitle: () => \"🧪 Set draft\",\n      onClick: (path) => updateFrontmatter(path, { isDraft: \"true\" }),\n    },\n    {\n      getIsEnabled: (projectRelativePath) =>\n        navigation?.find((x) => x.projectRelativePath === projectRelativePath)\n          ?.isDraft === true,\n      getTitle: () => \"🧪 Set live\",\n      onClick: (path) => updateFrontmatter(path, { isDraft: \"false\" }),\n    },\n  ];\n\n  return items;\n}"
  },
  "useQueryPath": {
    "name": "useQueryPath",
    "slug": "TsFunction",
    "id": "fpvgfzfbbjeyvrryvofsfjpk",
    "description": "Returns the queryPath of your URL without everything after ? and #",
    "operationName": "generative-ui",
    "rawText": " () => {\n  const router = useRouter();\n  const queryPath = router.query.queryPath;\n  const realQueryPathArray = queryPath ? makeArray(queryPath) : [];\n\n  const realQueryPath = realQueryPathArray.join(\"/\");\n  return realQueryPath;\n}"
  },
  "useVariantResult": {
    "name": "useVariantResult",
    "slug": "TsFunction",
    "id": "uanztrxvhqzjrehuqkismddl",
    "description": "",
    "operationName": "generative-ui",
    "rawText": " (\n  fileContextualPromptResults?: ContextualPromptResult[] | null\n) => {\n  const router = useRouter();\n  const [defaultVariant] = useStore(\"generativeWeb.defaultVariant\");\n\n  /**\n   * Variant either comes from URL or from the stored default variant slug from localStorage\n   */\n  const variantResultPromptSlug = router.query?.variant\n    ? takeFirst(router.query.variant)\n    : defaultVariant\n    ? defaultVariant\n    : undefined;\n\n  const variantResult = fileContextualPromptResults?.find(\n    (x) => x.contextualPromptSlug === variantResultPromptSlug\n  );\n\n  return variantResult;\n}"
  },
  "VariantSelector": {
    "name": "VariantSelector",
    "slug": "TsFunction",
    "id": "ispfyzgzfonlrwabqflwpvwj",
    "description": "",
    "operationName": "generative-ui",
    "rawText": " (props: {\n  projectRelativeFilePath?: string;\n  folderPath: string;\n  isFolder?: boolean;\n  filename?: string;\n  contextualPromptResults?: ContextualPromptResult[];\n}) => {\n  const { contextualPromptResults, folderPath, isFolder, filename } = props;\n\n  const router = useRouter();\n  const [defaultVariant, setDefaultVariant] = useStore(\n    \"generativeWeb.defaultVariant\"\n  );\n  const [isEditing, setIsEditing] = useStore(\"generativeWeb.isEditing\");\n  const admin = useAdmin();\n  const variantResult = useVariantResult(contextualPromptResults);\n\n  const resultItems =\n    contextualPromptResults?.map((x) => {\n      const item: Item<string> = {\n        label: `${x.isFake ? \"🧪\" : \"\"}${x.isFavorite ? \"⭐️\" : \"\"}${\n          x.contextualPromptSlug\n        }`,\n        value: x.contextualPromptSlug,\n      };\n\n      return item;\n    }) || [];\n\n  const items: Item<string>[] = [\n    { label: \"Original\", value: \"___NONE___\" },\n    ...resultItems,\n  ];\n\n  const withValue = (value: Item<string> | null | undefined) => {\n    const query: {\n      queryPath: string | string[] | undefined;\n      variant?: string;\n    } = {\n      queryPath: router.query.queryPath,\n    };\n\n    if (value && value.value && value.value !== \"___NONE___\") {\n      query.variant = value.value;\n    }\n    if (value?.value === \"___NONE___\") {\n      setDefaultVariant(null);\n    }\n    router.push({ query }, undefined, { shallow: true });\n  };\n\n  return (\n    <Div\n      className=\" \n    lg:flex-row lg:w-full w-min\"\n    >\n      <Div className=\"dark:bg-gray-700 dark:hover:bg-gray-600 rounded-md border border-black p-2 m-1 cursor-pointer flex flex-row\">\n        <P>Variant:</P>\n        <Select\n          className=\"bg-transparent\"\n          title=\"Test\"\n          onChange={withValue}\n          value={items.find(\n            (x) => x.value === variantResult?.contextualPromptSlug\n          )}\n          options={items}\n        />\n        {/* {variantResult?.id ? (\n          <ALink\n            href={`${folderPath}/.index/${\n              isFolder ? \"\" : filename ? withoutExtension(filename) : \"\"\n            }`}\n          >\n            Go to index\n          </ALink>\n        ) : null} */}\n\n        {(variantResult?.contextualPromptSlug || null) !== defaultVariant ? (\n          <ClickableIcon\n            emoji=\"📌\"\n            onClick={() =>\n              setDefaultVariant(variantResult?.contextualPromptSlug || null)\n            }\n          />\n        ) : null}\n\n        {variantResult && admin.isAdminActive ? (\n          // delete, star/unstar\n          <Div className=\"flex flex-row\">\n            <ClickableIcon\n              emoji=\"🗑\"\n              onClick={async () => {\n                if (!variantResult.prompt_projectRelativePath) return;\n                const apiResult = await api.deletePromptResult(\n                  variantResult.prompt_projectRelativePath,\n                  variantResult.id\n                );\n                showStandardResponse(apiResult);\n\n                if (apiResult?.result?.isSuccessful) {\n                  admin.refetch?.();\n                }\n              }}\n            />\n            <ClickableIcon\n              emoji={variantResult.isFavorite ? \"💩\" : \"⭐️\"}\n              onClick={async () => {\n                if (!variantResult.prompt_projectRelativePath) return;\n                const apiResult = await api.setIsFavoritePromptResult(\n                  variantResult.prompt_projectRelativePath,\n                  variantResult.id,\n                  !variantResult.isFavorite\n                );\n                showStandardResponse(apiResult);\n\n                if (apiResult?.result?.isSuccessful) {\n                  admin.refetch?.();\n                }\n              }}\n            />\n          </Div>\n        ) : null}\n      </Div>\n    </Div>\n  );\n}"
  },
  "getAllOperationSourcePaths": {
    "name": "getAllOperationSourcePaths",
    "slug": "TsFunction",
    "id": "zlxntnkppfxoooneffpjvvdl",
    "description": "returns src folder paths of all operations",
    "operationName": "get-all-operation-source-paths",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n}) => {\n  const manualProjectRoot = config?.manualProjectRoot;\n  const operationFolders: string[] = await exploreOperationFolders({\n    basePath: getPathsWithOperations({ manualProjectRoot }),\n  });\n\n  const operationSourceFolders = operationFolders.reduce(\n    (allSources, operationPath) => {\n      const srcPath = path.join(operationPath, \"src\");\n\n      if (!fs.existsSync(srcPath)) return allSources;\n\n      return allSources.concat(\n        [srcPath]\n        // TODO: this function would be great, but the inputs in tsconfig contain glob patterns and that doesn't work.\n        // getPackageSourcePaths({ packageFolder: operationPath })\n      );\n    },\n    [] as string[]\n  );\n\n  return operationSourceFolders;\n}"
  },
  "getImportedDependencies": {
    "name": "getImportedDependencies",
    "slug": "TsFunction",
    "id": "pbgeqievteyhykinrxmpxbuk",
    "description": "DEPRECATED: should use generated index files with imports instead!\n\ngets all imported packages (dependencies) in a project\ndoesn't take into account the fact that someone can set up a rule for absolute imports within the package.\nthis assumes that any absolute package comes from node_modules.",
    "operationName": "get-imported-dependencies",
    "rawText": " ({\n  operationFolderPath,\n}: {\n  operationFolderPath: string;\n}) => {\n  const project = getTsMorphProject(operationFolderPath);\n  if (!project) return;\n  const sourceFiles = project.getSourceFiles(\"src/*\");\n  const importModuleStrings = sourceFiles.reduce((imports, sourceFile) => {\n    const allImports: ImportDeclaration[] = sourceFile.getImportDeclarations();\n    const absoluteImports = allImports.map((i) =>\n      i.getModuleSpecifier().getLiteralText()\n    );\n    return imports.concat(absoluteImports);\n  }, [] as string[]);\n\n  const packages = importModuleStrings.filter(isAbsoluteImport).map(getPackage);\n  return packages;\n}"
  },
  "getPackage": {
    "name": "getPackage",
    "slug": "TsFunction",
    "id": "nahxcsxcgeigmjziyiqenaxc",
    "description": "only the first part",
    "operationName": "get-imported-dependencies",
    "rawText": " (absoluteModuleString: string) =>\n  absoluteModuleString.split(\"/\")[0]"
  },
  "isAbsoluteImport": {
    "name": "isAbsoluteImport",
    "slug": "TsFunction",
    "id": "kwyhubovdzgfbtlkgreisqji",
    "description": "",
    "operationName": "get-imports-exports",
    "rawText": " (moduleString: string | undefined) =>\n  moduleString ? !moduleString.startsWith(\".\") : false"
  },
  "calculatePackageJsonDependencies": {
    "name": "calculatePackageJsonDependencies",
    "slug": "TsFunction",
    "id": "dszwdweaukjuhgwwesnqbtbd",
    "description": "Calculates new packageJson dependencies object based on imports found in the whole operation.\n\nFor monorepo modules, uses the version inside its packagejson (Uses the database to obtain the package.json)\n\nGenerated packages are not added to dependencies. Instead a config is added saying this operation only works within a monorepo since it has generated operation deps that are not on the npm registry\n\nFor external modules, uses the version that was already present in dependencies, or uses \"*\"\n\nAlso keeps the dependencies that were already there, nothing is removed.",
    "operationName": "get-imports-exports",
    "rawText": " (\n  /**\n   * Current dependencies object in your operation\n   */\n  dependencies: PackageInfoObject | undefined,\n  /**\n   * All imports found in your operation\n   */\n  imports: Creation<TsImport>[],\n  /**\n   * All package-json's in your monorepo\n   */\n  operations: Operation[],\n  operationName: string\n) => {\n  const dependencyImports = imports\n    .filter((x) => x.isAbsolute)\n    .filter((x) => !isAbsoluteImportBuiltin(x.module))\n    .filter((x) => !isImportFromOptionalFile(x))\n    .filter(onlyUnique2<Creation<TsImport>>((a, b) => a.module === b.module));\n\n  /**\n   *  NB: imports of types are removed and need not to be installed for running this package\n   */\n  const valueDependencyImports = dependencyImports.filter(\n    (x) => x.type === \"value\"\n  );\n\n  const monorepoImports = dependencyImports.filter(\n    (x) =>\n      operationName &&\n      x.isModuleFromMonorepo &&\n      !isGeneratedOperationName(x.module)\n  );\n\n  const hasGeneratedDependenciesIndexed =\n    valueDependencyImports.filter(isImportGenerated).length > 0;\n\n  // console.log({ valueDependencyImports, hasGeneratedDependenciesIndexed });\n  // const hasGeneratedImportsIndexed =\n  //   dependencyImports.filter(isImportGenerated).length > 0;\n\n  const externalImports = dependencyImports.filter(\n    (x) => !x.isModuleFromMonorepo\n  );\n\n  const externalDependencyObject = mergeObjectsArray(\n    externalImports\n      .map((x) => {\n        const moduleName = getPackageNameFromAbsoluteImport(x.module);\n        if (!moduleName) return;\n        const already = dependencies?.[moduleName];\n        /**\n         * TODO: fetch this from monorepo\n         */\n        const calculatedVersion = \"*\";\n\n        /**\n         * NB: Minimize the use of \"*\"\n         */\n        const version =\n          already !== \"*\" && already !== undefined\n            ? already\n            : calculatedVersion;\n        return { [moduleName]: version };\n      })\n      .filter(notEmpty)\n  );\n\n  const monorepoDependencyObject = mergeObjectsArray(\n    monorepoImports\n      .map((x) => {\n        const moduleName = getPackageNameFromAbsoluteImport(x.module);\n        if (!moduleName) return;\n        const operation = operations.find((x) => x.name === moduleName);\n        if (!operation) return;\n        const { version } = operation;\n        if (!version) return;\n        return { [moduleName]: version };\n      })\n      .filter(notEmpty)\n  );\n\n  // console.log({\n  //   imports: imports.length,\n  //   dependencyImports: dependencyImports,\n  //   dependencies,\n  //   monorepoImports,\n  //   monorepoDependencyObject,\n  //   externalDependencyObject,\n  // });\n\n  const newDependencies: PackageInfoObject = {\n    ...dependencies,\n    ...monorepoDependencyObject,\n    ...externalDependencyObject,\n  };\n\n  return {\n    newDependencies,\n    hasGeneratedDependenciesIndexed,\n    // hasGeneratedImportsIndexed,\n  };\n}"
  },
  "CONCURRENTLY_INDEXED_FILES_AMOUNT": {
    "name": "CONCURRENTLY_INDEXED_FILES_AMOUNT",
    "slug": "TsVariable",
    "id": "jkliogyxavnyeblkgdfeinsz",
    "description": "",
    "operationName": "get-imports-exports"
  },
  "findAndWriteImportsExports": {
    "name": "findAndWriteImportsExports",
    "slug": "TsFunction",
    "id": "mkansgsjtxjgolzhibdvljtk",
    "description": "takes an operation base path and finds all imports and exports in all the files, and writes it to the ts-imports/ts-exports indexes\n\nNB: has a side effect: it also updates the package.json to include all needed dependencies.",
    "operationName": "get-imports-exports",
    "rawText": " async (\n  operationBasePath: string,\n  /**\n   * Manual project root of the operation where the imports and exports needs to be detected and written to database\n   */\n  manualProjectRoot?: string\n): Promise<void> => {\n  const operationName = getLastFolder(operationBasePath);\n  const sourceFiles = await getAllTsMorphSourceFiles(operationBasePath);\n\n  if (!sourceFiles || sourceFiles.length === 0) {\n    const problem = `couldn't load any SourceFiles for ${operationBasePath} (sourceFiles=${sourceFiles})`;\n    log(problem, { type: \"error\" });\n    await writeResult({\n      success: false,\n      message: problem,\n      operationName,\n      manualProjectRoot,\n    });\n    return;\n  }\n\n  const importsAndExports = await getImportsExports({\n    sourceFiles,\n    manualProjectRoot,\n  });\n\n  if (!importsAndExports) {\n    const problem = \"Something went wrong creating imports/exports\";\n    log(problem, { type: \"error\" });\n    await writeResult({\n      success: false,\n      message: problem,\n      operationName,\n      manualProjectRoot,\n    });\n\n    return;\n  }\n\n  const { exports, imports } = importsAndExports;\n\n  // When rebuilding operations, add `packageJson.dependencies` according to imports found.\n  const operations = await db.get(\"Operation\", { manualProjectRoot });\n\n  await db.update(\n    \"Operation\",\n    // NB: this should always be true, but this extra check will make sure it doesn't update too much...\n    (x) => x.name === operationName,\n    (packageJson) => {\n      const { newDependencies, hasGeneratedDependenciesIndexed } =\n        calculatePackageJsonDependencies(\n          packageJson.dependencies,\n          imports,\n          operations,\n          operationName\n        );\n\n      const newOperation: Operation = {\n        ...packageJson,\n        operation: {\n          ...packageJson.operation,\n          hasGeneratedDependenciesIndexed,\n        },\n        dependencies: newDependencies,\n      };\n      return newOperation;\n    },\n    { operationName, manualProjectRoot }\n  );\n\n  await db.clear(\"TsImport\", { operationName, manualProjectRoot });\n  await db.clear(\"TsExport\", { operationName, manualProjectRoot });\n\n  // @ts-ignore\n  await db.upsert(\"TsImport\", imports, { operationName, manualProjectRoot });\n  // @ts-ignore\n  await db.upsert(\"TsExport\", exports, { operationName, manualProjectRoot });\n\n  await writeResult({\n    success: true,\n    message: \"Succesfully created imports and exports\",\n    operationName,\n    manualProjectRoot,\n  });\n}"
  },
  "getDefaultSymbolType": {
    "name": "getDefaultSymbolType",
    "slug": "TsFunction",
    "id": "zovuvfjamildekofwbwjqbka",
    "description": "gets type of a symbol and if the type has a generic, without recursing.",
    "operationName": "get-imports-exports",
    "rawText": " (\n  symbol: Symbol,\n  debug?: boolean\n): TypeSpecifier => {\n  if (debug) {\n    console.log({\n      kinds: symbol\n        .getDeclarations()\n        .map((x) => ({ kind: x.getKindName(), name: x.getText() })),\n    });\n  }\n  const symbolTypeDeclarations = getSymbolTypeDeclarations(symbol);\n\n  const type = symbolTypeDeclarations.length > 0 ? \"type\" : \"value\";\n  /**\n   * checks whether the symbol contains a type declaration which has a generic parameter\n   */\n  const hasGeneric =\n    type === \"type\"\n      ? !!symbolTypeDeclarations.find(\n          // NB: type parameters gets the generics\n          (declaration) => getHasGeneric(declaration)\n        )\n      : undefined;\n\n  return { type, hasGeneric };\n}"
  },
  "getExportSpecifierNames": {
    "name": "getExportSpecifierNames",
    "slug": "TsFunction",
    "id": "snyejyimcnmmwctgbbhxanlm",
    "description": "",
    "operationName": "get-imports-exports",
    "rawText": " (symbol: Symbol) => {\n  return (\n    symbol\n      ?.getDeclarations()\n      ?.filter((x) => x.isKind(SyntaxKind.ExportSpecifier))\n      .map((x) => x.asKind(SyntaxKind.ExportSpecifier))\n      .filter(notEmpty)\n      .map((x) => x.getName()) || []\n  );\n}"
  },
  "getExportSymbolTypeRecursive": {
    "name": "getExportSymbolTypeRecursive",
    "slug": "TsFunction",
    "id": "jqzjrxlspnrprxghvdfmzjzx",
    "description": "gets type of exportSymbols. recurses if it's an exportsymbol\n\nTODO: NB: exports that come from a destructured initialiser aren't found! fix it",
    "operationName": "get-imports-exports",
    "rawText": " (\n  symbol: Symbol,\n  sourceFile: SourceFile,\n  debug?: boolean\n): TypeSpecifier | undefined => {\n  const exportSpecifierNames = getExportSpecifierNames(symbol);\n\n  if (debug) console.log(exportSpecifierNames);\n\n  if (exportSpecifierNames.length > 0) {\n    // get the ImportSpecifier of this ExportSpecifier, and if one exists, recurse this function on it.\n\n    const importSpecifiers = getImportSpecifiersWithNames(\n      sourceFile,\n      exportSpecifierNames\n    );\n\n    if (importSpecifiers.length > 1) {\n      // NB: warn if there is more than one as that would be strange\n\n      log(\n        `More than one importsSpecifiers with that name: ${exportSpecifierNames.join(\n          \",\"\n        )} (imports: ${importSpecifiers\n          .map((x) => x.getName())\n          .join(\",\")})... file: ${sourceFile.getFilePath()}`,\n        {\n          type: \"warning\",\n        }\n      );\n    }\n\n    if (importSpecifiers.length > 0) {\n      return getTypeFromImportSpecifierRecursive(importSpecifiers[0], debug);\n    }\n\n    /* REmoved this.... seems that this will make it never do the default one\n      else {\n        if (debug) {\n          console.log(\n            \"Weird, we couldn't find the importspecifier for exportSpecifiers\"\n          );\n        }\n        return { type: undefined };\n      }\n      */\n  }\n\n  return getDefaultSymbolType(symbol, debug);\n}"
  },
  "getImportSpecifiersWithNames": {
    "name": "getImportSpecifiersWithNames",
    "slug": "TsFunction",
    "id": "mryxvgchwgzmicufgtntibhd",
    "description": "get the ImportSpecifier(s) of with a certain name.",
    "operationName": "get-imports-exports",
    "rawText": " (\n  sourceFile: SourceFile,\n  names: string[]\n) => {\n  return sourceFile\n    .getImportDeclarations()\n    .map((x) => x.getNamedImports())\n    .flat()\n    .filter((x) => names.includes(x.getName()));\n}"
  },
  "getImportsExportsTest": {
    "name": "getImportsExportsTest",
    "slug": "TsFunction",
    "id": "zowsfvpaebbmudtptpchbtap",
    "description": "",
    "operationName": "get-imports-exports",
    "rawText": " async () => {\n  const operationBasePath = await getOperationPath(\n    \"react-with-native-notification\"\n  );\n  if (!operationBasePath) {\n    return console.log(\"wtf\");\n  }\n\n  const sourceFilePaths = await getPackageSourcePaths({\n    operationBasePath,\n  });\n  const project = getTsMorphProject(operationBasePath);\n  if (!project) {\n    return log(\"couldn't load project\", { type: \"error\" });\n  }\n\n  const sourceFiles = project.getSourceFiles(sourceFilePaths);\n  if (!sourceFiles) {\n    return log(`couldn't load files`, { type: \"error\" });\n  }\n\n  const impexp = await getImportsExports({ sourceFiles });\n\n  return impexp;\n\n  // console.dir(impexp, { depth: 999 });\n}"
  },
  "getImportsExports": {
    "name": "getImportsExports",
    "slug": "TsFunction",
    "id": "wygvcgvfolldbgpceuvuefcm",
    "description": "Uses ts-morph to get all exports inside all files in a project or an array of source files.\nDoesn't use index, it actually looks in all files except index,\nso some of them may not be exported from the package itself depending on your indexing strategy!\n\nNB: uses a lot of memory!\n\n#performance",
    "operationName": "get-imports-exports",
    "rawText": " async ({\n  sourceFiles,\n  debug,\n  manualProjectRoot,\n}: {\n  /**\n   * if given, only these sourcefiles are used, otherwise takes all source files from project.\n   */\n  sourceFiles: SourceFile[];\n  debug?: boolean;\n  manualProjectRoot?: string;\n}): Promise<ImportsAndExports | undefined> => {\n  if (sourceFiles.length === 0) {\n    log(\"No source files provided\", { type: \"warning\" });\n    return;\n  }\n\n  const allOperationsPaths = await exploreOperationFolders({\n    basePath: manualProjectRoot,\n  });\n  const allOperations = allOperationsPaths.map(getLastFolder);\n  const firstFilePath = sourceFiles[0].getFilePath();\n  if (!firstFilePath) return;\n\n  const operationBasePath = findOperationBasePath(firstFilePath);\n  if (!operationBasePath) return;\n\n  const packageJson = await readJsonFile<Operation>(\n    path.join(operationBasePath, \"package.json\")\n  );\n\n  if (!packageJson) {\n    log(\"PackageJson could not be found\", { type: \"error\" });\n    return;\n  }\n\n  const allTsExports: Creation<TsExport>[] = (\n    await mapMany(\n      sourceFiles,\n      async (sourceFile) => {\n        const absoluteFilePath = sourceFile.getFilePath();\n        if (!absoluteFilePath) return;\n\n        const operationRelativeTypescriptFilePath = makeRelative(\n          absoluteFilePath,\n          operationBasePath\n        );\n\n        const exportSymbols: Symbol[] = sourceFile.getExportSymbols();\n        const tsExports: Creation<TsExport>[] = exportSymbols.map((symbol) => {\n          const name = symbol.getName();\n          const typeSpecifier: TypeSpecifier = { type: \"value\" };\n\n          /**getExportSymbolTypeRecursive(\n            symbol,\n            sourceFile,\n            debug\n          );*/\n\n          const exportObject: Creation<TsExport> = {\n            name,\n            slug: kebabCase(name),\n            operationRelativeTypescriptFilePath,\n            // TODO:\n            comments: [],\n            type: typeSpecifier?.type,\n            hasGeneric: typeSpecifier?.hasGeneric,\n          };\n          return exportObject;\n        });\n\n        return tsExports;\n      },\n      CONCURRENTLY_INDEXED_FILES_AMOUNT\n    )\n  )\n    .filter(notEmpty)\n    .flat();\n\n  const allTsImports: Creation<TsImport>[] = (\n    await oneByOne(sourceFiles, async (sourceFile) => {\n      const absoluteFilePath = sourceFile.getFilePath();\n      if (!absoluteFilePath) return;\n      const operationRelativeTypescriptFilePath = makeRelative(\n        absoluteFilePath,\n        operationBasePath\n      );\n\n      try {\n        const importDeclarations: ImportDeclaration[] =\n          sourceFile.getImportDeclarations();\n\n        const importInfos = (\n          await oneByOne(importDeclarations, async (importDeclaration) => {\n            try {\n              const module = String(\n                importDeclaration.getModuleSpecifier().getLiteralText()\n              );\n              const importSpecifiers = importDeclaration.getNamedImports();\n\n              const namedImports: NamedImport[] = await oneByOne(\n                importSpecifiers,\n                async (x) => {\n                  const name = x.getName();\n\n                  const isOperation = allOperations.includes(module);\n\n                  const typeSpecifier = isOperation\n                    ? getTypeFromImportSpecifierRecursive(x, debug)\n                    : undefined;\n\n                  const namedImport: NamedImport = {\n                    name,\n                    slug: kebabCase(name),\n                    type: typeSpecifier?.type,\n                    hasGeneric: typeSpecifier?.hasGeneric,\n                  };\n\n                  return namedImport;\n                }\n              );\n\n              const isModuleResolved =\n                !!importDeclaration.getModuleSpecifierSourceFile();\n\n              return { namedImports, module, isModuleResolved };\n            } catch (e) {\n              console.log(\n                `catched generating import-info for import-declaration`\n              );\n            }\n          })\n        ).filter(notEmpty);\n\n        const tsImports: Creation<TsImport>[] = importInfos\n          .map((importInfo) => {\n            const { module, namedImports, isModuleResolved } = importInfo;\n\n            const nodeModules = [\"fs\", \"path\"];\n            const reactModules = [\"react\", \"react-dom\", \"react-native\", \"expo\"];\n\n            const classification: ImportClassification = nodeModules.includes(\n              module\n            )\n              ? \"node\"\n              : reactModules.includes(module)\n              ? \"react\"\n              : allOperations.includes(module)\n              ? \"operation\"\n              : !isAbsoluteImport(module)\n              ? \"internal\"\n              : \"package\";\n\n            const importObjects: Creation<TsImport>[] = namedImports.map(\n              (namedImport) => ({\n                ...namedImport,\n                module,\n                isModuleResolved,\n                // TODO\n                comments: [],\n                operationRelativeTypescriptFilePath,\n                classification,\n                isAbsolute: isAbsoluteImport(module),\n                isModuleFromMonorepo: allOperations.includes(module),\n                // NB: will not be resolved if build folder doesn't exist or if entry file doesn't exist\n              })\n            );\n\n            return importObjects;\n          })\n          .filter(notEmpty)\n          .flat();\n\n        return tsImports;\n      } catch (e) {\n        return;\n      }\n    })\n  )\n    .filter(notEmpty)\n    .flat();\n\n  return { imports: allTsImports, exports: allTsExports };\n}"
  },
  "getPackageNameFromAbsoluteImport": {
    "name": "getPackageNameFromAbsoluteImport",
    "slug": "TsFunction",
    "id": "sgezayoolfxqqujsebuinkfu",
    "description": "parses the absolute import name into the actual package name\n\n- removes internal navigation in the package (everything after the package name)\n- assumes packages don't have slashes in their names, execpt that it takes into account scoped packages (e.g. `@company/package`)\n- removes things that come before any column (`:`) e.g. `node:fs` becomes `fs`",
    "operationName": "get-imports-exports",
    "rawText": " (\n  absoluteImportName: string\n) => {\n  const slashParts = absoluteImportName.split(\"/\");\n  const beforeSlash = slashParts[0];\n\n  if (!beforeSlash || beforeSlash.length === 0) return;\n\n  // NB: scoped packages look like `@company/package` and should be parsed correctly as well\n  const withoutInternalNavigation = beforeSlash.startsWith(\"@\")\n    ? slashParts.slice(0, 2).join(\"/\")\n    : beforeSlash;\n\n  const columnParts = withoutInternalNavigation.split(\":\");\n\n  const partAfterColumns = columnParts.pop()!;\n\n  return partAfterColumns;\n}"
  },
  "getSymbolDeclarationsOfKind": {
    "name": "getSymbolDeclarationsOfKind",
    "slug": "TsFunction",
    "id": "erdwpsxjffvfajgjthmvniql",
    "description": "",
    "operationName": "get-imports-exports",
    "rawText": " <T>(symbol: Symbol, kind: SyntaxKind) => {\n  const declarations = symbol\n    .getDeclarations()\n    .filter((x) => x.getKind() === kind)\n    .map((x) => x.asKind(kind))\n    .filter(notEmpty) as unknown as T[];\n\n  return declarations;\n}"
  },
  "getSymbolTypeDeclarations": {
    "name": "getSymbolTypeDeclarations",
    "slug": "TsFunction",
    "id": "dhalcnfkrbhmnbggsmxxthjk",
    "description": "",
    "operationName": "get-imports-exports",
    "rawText": " (symbol: Symbol) => {\n  return [\n    ...getSymbolDeclarationsOfKind<TypeAliasDeclaration>(\n      symbol,\n      SyntaxKind.TypeAliasDeclaration\n    ),\n    ...getSymbolDeclarationsOfKind<InterfaceDeclaration>(\n      symbol,\n      SyntaxKind.InterfaceDeclaration\n    ),\n  ];\n}"
  },
  "getTypeFromImportSpecifierRecursive": {
    "name": "getTypeFromImportSpecifierRecursive",
    "slug": "TsFunction",
    "id": "dkxxbffjftvlpdhojvlaxtei",
    "description": "Recursive function that gets the type specifier from an import specifier",
    "operationName": "get-imports-exports",
    "rawText": " (\n  importSpecifier: ImportSpecifier,\n  debug?: boolean,\n  /**\n   * Files it was already in (to prevent infinite loops)\n   */\n  fileStack?: string[]\n): TypeSpecifier | undefined => {\n  // NB: find the file where the import is defined\n\n  try {\n    const fileOfExport = importSpecifier\n      .getImportDeclaration()\n      .getModuleSpecifierSourceFile();\n\n    // NB: without the module source we can't know the type of this importspecifier\n    if (!fileOfExport) return;\n    const filePath = fileOfExport.getFilePath();\n    if (!filePath) return;\n\n    const realFileStack = fileStack || [];\n\n    if (realFileStack.includes(filePath)) {\n      console.log(\"Infinite loop found, returning...\", { filePath, fileStack });\n      return;\n    }\n\n    const newFileStack = realFileStack.concat(filePath);\n\n    // NB: in the source, find all exported stuff\n    const exportSymbols: Symbol[] = fileOfExport.getExportSymbols();\n\n    // NB: find the export with the same name as the import\n    const importedSymbol = exportSymbols.find(\n      (x) => x.getName() === importSpecifier.getName()\n    );\n\n    // NB: if the source doesn't contain any export with that name, we can't know its type\n    if (!importedSymbol) return;\n\n    /**\n     * NB: all ExportSpecifiers don't have a more specific SyntaxKind because they are imported.\n     * If there are any ExportSpecifiers with a matching ImportSpecifier, recurse on that!\n     */\n    const exportSpecifierNames = getExportSpecifierNames(importedSymbol);\n\n    if (exportSpecifierNames.length > 0) {\n      const importSpecifiers = getImportSpecifiersWithNames(\n        fileOfExport,\n        exportSpecifierNames\n      );\n\n      if (importSpecifiers.length > 1) {\n        // NB: warn if there is more than one as that would be strange\n\n        log(\"More than one importsSpecifiers with that name\", {\n          type: \"warning\",\n        });\n      }\n\n      if (importSpecifiers.length > 0 && newFileStack.length < 10) {\n        // console.log(`recursing`, { newFileStack, filePath });\n\n        // NB: recursion!\n        const first = importSpecifiers[0];\n        return getTypeFromImportSpecifierRecursive(first, debug, newFileStack);\n      } else {\n        if (debug)\n          console.log(\"Weird, no importspecifiers found for exportSpecifier!!\");\n        return;\n      }\n    }\n\n    // console.log({\n    //   fileOfExport: fileOfExport?.getFilePath(),\n    //   exportSymbols: exportSymbols?.map((x) => x.getName()),\n    //   importSpecifier: importSpecifier.getName(),\n    //   importedSymbol: importedSymbol?.getName(),\n    //   name: importSpecifier.getName(),\n    // });\n\n    return getDefaultSymbolType(importedSymbol, debug);\n  } catch (e) {\n    console.log(\"failed\");\n    return;\n  }\n}"
  },
  "isAbsoluteImportBuiltin": {
    "name": "isAbsoluteImportBuiltin",
    "slug": "TsFunction",
    "id": "arsfdwpybivltneiobaxawsu",
    "description": "returns true if the absolute import is built in into node",
    "operationName": "get-imports-exports",
    "rawText": " (absoluteImportName: string) => {\n  const realModuleName = getPackageNameFromAbsoluteImport(absoluteImportName);\n  return realModuleName ? builtinModules.includes(realModuleName) : false;\n}"
  },
  "isImportFromOptionalFile": {
    "name": "isImportFromOptionalFile",
    "slug": "TsFunction",
    "id": "abdfudmwehecfvzwjuffzmbr",
    "description": "returns true if the import was found in an optional file, e.g. this import is not always included in the bundle, so should not be a dependency",
    "operationName": "get-imports-exports",
    "rawText": " (tsImport: Creation<TsImport>) => {\n  const srcRelativeFileId = getSrcRelativeFileId(\n    tsImport.operationRelativeTypescriptFilePath\n  );\n  return hasSubExtension(srcRelativeFileId, frontendOptionalFileSubExtensions);\n}"
  },
  "isImportGenerated": {
    "name": "isImportGenerated",
    "slug": "TsFunction",
    "id": "usmmzhmgxvpdjytsknayivrg",
    "description": "",
    "operationName": "get-imports-exports",
    "rawText": " (x: Creation<TsImport>) =>\n  x.isModuleFromMonorepo && isGeneratedOperationName(x.module)"
  },
  "[operationBasePath, manualProjectRoot]": {
    "name": "[operationBasePath, manualProjectRoot]",
    "slug": "TsVariable",
    "id": "izlrdlwwgjrtlupffbvfpdhd",
    "description": "",
    "operationName": "get-imports-exports"
  },
  "writeResult": {
    "name": "writeResult",
    "slug": "TsFunction",
    "id": "rdxtzauuidvpbyrvypfdvtkq",
    "description": "",
    "operationName": "get-imports-exports",
    "rawText": " async (options: {\n  operationName: string;\n  success: boolean;\n  message: string;\n  manualProjectRoot?: string;\n}) => {\n  const { message, operationName, success, manualProjectRoot } = options;\n\n  if (!success) {\n    log(`Couldn't write imports/exports.`);\n\n    await db.update(\n      \"Operation\",\n      () => true,\n      (old) =>\n        mergeNestedObject(old, {\n          operation: {\n            buildResultIndexed: { indexImportExportError: message },\n          },\n        }),\n      { operationName, manualProjectRoot }\n    );\n\n    return false;\n  }\n}"
  },
  "getOperationBins": {
    "name": "getOperationBins",
    "slug": "TsFunction",
    "id": "loytmhlzanwpyuubuhxzvjhg",
    "description": "returns array of bins. by convention, these bins should also be exported from operation index file",
    "operationName": "get-package-json",
    "rawText": " async (operationFolderPath: string) => {\n  const packageJson = await getPackageJson({ operationFolderPath });\n  return packageJson?.bin ? Object.keys(packageJson.bin) : [];\n}"
  },
  "getOperationPackageName": {
    "name": "getOperationPackageName",
    "slug": "TsFunction",
    "id": "wbubnpzxtgtgfonuctanofkb",
    "description": "",
    "operationName": "get-package-json",
    "rawText": " async (operationFolderPath: string) => {\n  const packageJson = await getPackageJson({ operationFolderPath });\n  return packageJson?.name;\n}"
  },
  "getPackageJson": {
    "name": "getPackageJson",
    "slug": "TsFunction",
    "id": "mqaajejudabrmygjvnhhotma",
    "description": "",
    "operationName": "get-package-json",
    "rawText": " async (config: {\n  operationFolderPath: string;\n}): Promise<Operation | null> => {\n  const { operationFolderPath } = config;\n  const packageJsonPath = path.join(operationFolderPath, \"package.json\");\n  const packageJson = readJsonFile<Operation>(packageJsonPath);\n  return packageJson;\n}"
  },
  "getPackageSourcePaths": {
    "name": "getPackageSourcePaths",
    "slug": "TsFunction",
    "id": "eglpyubohaigkgoyqebkctyq",
    "description": "Returns an array of absolute file paths of (typescript) files in the src of your operation\n\nTODO: we need a way to explore these glob patterns inside of tsConfig.include.\nuntil then, just assume we use \"src\" as the only folder",
    "operationName": "get-package-source-paths",
    "rawText": " async ({\n  operationBasePath,\n  ignoreIndexFiles,\n  allTypes,\n}: {\n  operationBasePath: string;\n  ignoreIndexFiles?: boolean;\n  /**\n   * by default, only searches for ts and tsx files, if this is true, it will search for any type\n   */\n  allTypes?: boolean;\n}) => {\n  const filePaths = (\n    await explore({\n      basePath: path.join(operationBasePath, \"src\"),\n      extension: allTypes ? undefined : [\"ts\", \"tsx\"],\n      ignore: ignoreIndexFiles ? [\"index.ts\", \"index.tsx\"] : undefined,\n    })\n  ).map((x) => x.path);\n\n  return filePaths;\n}"
  },
  "findFolderWhereMatch": {
    "name": "findFolderWhereMatch",
    "slug": "TsFunction",
    "id": "haybgxvgvbcrksvhegmodjal",
    "description": "recursive. goes up a folder until it finds a package.json",
    "operationName": "get-path",
    "rawText": " <T>(\n  fullSourcePath: string,\n  /**\n   * match must be truthy in order to match, and falsy if it's not a match\n   *\n   * the result of the matchFunction will be returned at the end of the recursion\n   */\n  matchFunction: (folderPath: string) => T\n): undefined | { folderPath: string; matchResult: T } => {\n  if (fullSourcePath === undefined) {\n    console.log(\"WTF\");\n    process.exit(1);\n  }\n  // Basecase to make sure that the provided sourcepath is valid\n  if (!fs.existsSync(fullSourcePath)) {\n    log(`full source path invalid ${fullSourcePath}`, { type: \"debug\" });\n    return;\n  }\n\n  // Basecase to make sure that it doesn't go on infinitely, even if package.json doesn't exist anywhere\n  if (fullSourcePath === \"/\") {\n    log(`folder was not found, went all the way to root '/'`, {\n      type: \"debug\",\n    });\n    return;\n  }\n\n  const matchResult = matchFunction(fullSourcePath);\n\n  if (matchResult) return { folderPath: fullSourcePath, matchResult };\n\n  return findFolderWhereMatch(path.join(fullSourcePath, \"..\"), matchFunction);\n}"
  },
  "findOperationBasePathWithClassification": {
    "name": "findOperationBasePathWithClassification",
    "slug": "TsFunction",
    "id": "mubhebicdwvwgtzpvnsdrwhh",
    "description": "recursive. goes up until it finds a folder that's an operation\n\nbecause it had to read the package.json anyway, it's returning the operation classification as well",
    "operationName": "get-path",
    "rawText": " (\n  startPath: string\n):\n  | { folderPath: string; classification: OperationClassification }\n  | undefined => {\n  // returns if `getOperationClassification` does not return `undefined`\n  const result = findFolderWhereMatch(startPath, getOperationClassification);\n\n  return result\n    ? { folderPath: result.folderPath, classification: result.matchResult! }\n    : undefined;\n}"
  },
  "findOperationBasePath": {
    "name": "findOperationBasePath",
    "slug": "TsFunction",
    "id": "gfkrcwjdhavfdyfkmfninart",
    "description": "",
    "operationName": "get-path",
    "rawText": " (\n  startPath: string\n): string | undefined => {\n  return findOperationBasePathWithClassification(startPath)?.folderPath;\n}"
  },
  "getAllPackageJsonDependencies": {
    "name": "getAllPackageJsonDependencies",
    "slug": "TsFunction",
    "id": "jwwymqedrueiqmcgvpjbaxtj",
    "description": "",
    "operationName": "get-path",
    "rawText": " (\n  operation: Operation\n): string[] => {\n  const dependencies = operation.dependencies\n    ? Object.keys(operation.dependencies)\n    : [];\n  const devDependencies = operation.devDependencies\n    ? Object.keys(operation.devDependencies)\n    : [];\n  const peerDependencies = operation.peerDependencies\n    ? Object.keys(operation.peerDependencies)\n    : [];\n\n  return [...dependencies, ...devDependencies, ...peerDependencies];\n}"
  },
  "getCommonAncestor": {
    "name": "getCommonAncestor",
    "slug": "TsFunction",
    "id": "psdejivpdhlfiywkywgxpdfl",
    "description": "Finds the common ancestor for two absolute pahts",
    "operationName": "get-path",
    "rawText": " (path1: string, path2: string): string => {\n  const chunks = path1.split(\"/\");\n  const chunks2 = path2.split(\"/\");\n\n  const firstFolderMismatchIndex = chunks.findIndex((chunk, index, array) => {\n    const isMismatch = chunks2[index] !== chunk;\n\n    return isMismatch;\n  });\n\n  const commonAncestor = chunks.slice(0, firstFolderMismatchIndex).join(\"/\");\n\n  return commonAncestor;\n}"
  },
  "getOperationClassificationObject": {
    "name": "getOperationClassificationObject",
    "slug": "TsFunction",
    "id": "ebjsdpvzbgnbytpbvbmjjwwf",
    "description": "",
    "operationName": "get-path",
    "rawText": "\n  async (): Promise<OperationClassificationObject> => {\n    const operationFolders = await exploreOperationFolders({});\n\n    return mergeObjectsArray(\n      operationFolders\n        .map((operationBasePath) => {\n          const operationClassification =\n            getOperationClassification(operationBasePath);\n          if (!operationClassification) return;\n          const operationName = getLastFolder(operationBasePath);\n          return { [operationName]: operationClassification };\n        })\n        .filter(notEmpty)\n    );\n  }"
  },
  "getOperationClassification": {
    "name": "getOperationClassification",
    "slug": "TsFunction",
    "id": "sovbanmzefahfxguqyxkizyp",
    "description": "Returns `OperationClassification` if it's an operation, or undefined if it's not\n\nNB: don't confuse this with `ImportClassification`",
    "operationName": "get-path",
    "rawText": " (\n  folderPath: string\n): OperationClassification | undefined => {\n  if (folderPath === undefined) {\n    console.log(\n      \"Incorrect type at getOperationClassification\"\n      // getOperationClassification.caller\n    );\n    process.exit(1);\n  }\n\n  if (!isOperation(folderPath)) {\n    return;\n  }\n\n  const packageJsonPath = path.join(folderPath, \"package.json\");\n  const packageJson = tryParseJson<Operation>(\n    fs.readFileSync(packageJsonPath, \"utf8\")\n  );\n\n  const tsconfigPath = path.join(folderPath, \"tsconfig.json\");\n\n  const tsconfig = readJsonFileSync<TsConfig>(tsconfigPath);\n\n  if (!tsconfig) return;\n\n  if (!packageJson || packageJson.workspaces) {\n    return;\n  }\n\n  const nextConfigPath = path.join(folderPath, \"next.config.js\");\n  const existsNextConfig = fs.existsSync(nextConfigPath);\n  const isNextApp = existsNextConfig;\n  if (isNextApp) return \"ui-web\";\n\n  const appJsonPath = path.join(folderPath, \"app.json\");\n  const existsAppJson = fs.existsSync(appJsonPath);\n  const isReactNativeApp = existsAppJson;\n  if (isReactNativeApp) return \"ui-app\";\n\n  const isTs = packageCompilesTs(packageJson);\n\n  const isEsm = tsconfigCompilesEsm(tsconfig);\n\n  const isUi = isUiOperation(tsconfig, packageJson);\n\n  const compileType = isEsm ? \"esm\" : isTs ? \"ts\" : \"cjs\";\n\n  if (isUi) {\n    return `ui-${compileType}`;\n  }\n\n  const hasTypesNode = hasDependency(packageJson, \"@types/node\");\n\n  if (hasTypesNode) {\n    if (packageJson.operation?.isNodeServer) {\n      return \"server-cjs\";\n    }\n    return `node-${compileType}`;\n  }\n\n  return compileType;\n}"
  },
  "getOperationPathParse": {
    "name": "getOperationPathParse",
    "slug": "TsFunction",
    "id": "efyiemdgdctfsrxiqlswblug",
    "description": "get all operation-related path information that can be inferred from the path\n\nNB: currently it also looks up the operation name from its packagejson",
    "operationName": "get-path",
    "rawText": " (\n  absolutePath: string\n): OperationPathParse | undefined => {\n  if (!absolutePath) return;\n  const pathParse = getPathParse(absolutePath);\n  if (!pathParse) return;\n  const projectRoot = getProjectRoot(absolutePath);\n  if (!projectRoot) return;\n  const operationBasePath = findOperationBasePath(absolutePath);\n  if (!operationBasePath) return;\n  const operationSrcPath = path.join(operationBasePath, \"src\");\n\n  const operationFolderName = getLastFolder(operationBasePath);\n  const operationName = readJsonFileSync<Operation>(\n    path.join(operationBasePath, \"package.json\")\n  )?.name;\n\n  const operationRelativeTypescriptFilePath = getOperationRelativePath(\n    absolutePath,\n    operationBasePath\n  );\n\n  const parsedPath = path.parse(absolutePath);\n  const srcFileId = makeRelative(\n    path.join(parsedPath.dir, parsedPath.name),\n    operationSrcPath\n  );\n\n  const relativeOperationBasePathFromProjectRoot = operationBasePath.slice(\n    projectRoot.length\n  );\n\n  return {\n    relativePathFromProjectRoot: pathParse.relativePathFromProjectRoot,\n    srcFileId,\n    operationFolderName,\n    operationRelativeTypescriptFilePath,\n    relativeOperationBasePathFromProjectRoot,\n    operationName,\n  };\n}"
  },
  "getOperationPath": {
    "name": "getOperationPath",
    "slug": "TsFunction",
    "id": "gqnlacuofzamqzjkbpbepgdi",
    "description": "Gets a path of any operation in the project\n\nNB: relies on `sdk-operations` 100%",
    "operationName": "get-path",
    "rawText": " async (\n  /**\n   * specify the operation folder name\n   */\n  operationName: string,\n  config?: {\n    manualProjectRoot?: string;\n    /**\n     * if true, will not use sdk (defaults to using it first...)\n     */\n    notUseSdk?: boolean;\n  }\n): Promise<string | undefined> => {\n  // NB: In case of manualProjectRoot, we should not use the SDK! The sdk is from our own project root.\n  if (!config?.notUseSdk && !config?.manualProjectRoot) {\n    const projectRelativeOperationPath =\n      operations[operationName as keyof typeof operations];\n    const projectRoot = getProjectRoot();\n    if (projectRelativeOperationPath && projectRoot) {\n      return path.join(projectRoot, projectRelativeOperationPath);\n    }\n  }\n\n  // if that didn't work, let's find it in realtime\n  const basePath = getPathsWithOperations({\n    manualProjectRoot: config?.manualProjectRoot,\n  });\n\n  const operationPaths: string[] = await exploreOperationFolders({ basePath });\n\n  if (operationPaths.length === 0) {\n    log(\"No operations available\", { type: \"error\" });\n    return;\n  }\n  const operationPathsWithTheirFolder = await Promise.all(\n    operationPaths.map(async (p) => ({\n      path: p,\n      folderName: getLastFolder(p),\n    }))\n  );\n\n  const foundPath = operationPathsWithTheirFolder.find(\n    (f) => f.folderName === operationName\n  )?.path;\n\n  return foundPath;\n}"
  },
  "getOperationRelativePath": {
    "name": "getOperationRelativePath",
    "slug": "TsFunction",
    "id": "wfumgttvlrlcldsdvkgetgtc",
    "description": "something like src/xxx/xxx/x.ts (no slash at start)",
    "operationName": "get-path",
    "rawText": " (\n  absolutePath: string,\n  operationBasePath: string\n) => {\n  return absolutePath.slice(operationBasePath.length + 1);\n}"
  },
  "getPathParse": {
    "name": "getPathParse",
    "slug": "TsFunction",
    "id": "rofdxpxyhmkwncueumwiabck",
    "description": "gets all kinds of information that can be inferred from any path (file or folder).",
    "operationName": "get-path",
    "rawText": " (absolutePath: string): PathParse | undefined => {\n  const projectRoot = getProjectRoot(absolutePath);\n  if (!projectRoot) return;\n  const relativePathFromProjectRoot = absolutePath.slice(projectRoot.length);\n  return { relativePathFromProjectRoot };\n}"
  },
  "getPathsWithOperations": {
    "name": "getPathsWithOperations",
    "slug": "TsFunction",
    "id": "uczfvxbpioddljbijttpuifb",
    "description": "returns an array of all (absolute) paths containing operations\n\nfor a bundled project, that means /apps, /packages, /modules\n\nfor the OS project, that means /operations/tools and /operations/niches",
    "operationName": "get-path",
    "rawText": " (config?: {\n  /**\n   * if given, this will be taken as the project root instead of the one that can be found automatically (useful for bundling or working with multiple projects that alter each other)\n   */\n  manualProjectRoot?: string;\n}): string[] => {\n  const rootPath = config?.manualProjectRoot || getProjectRoot();\n\n  if (!rootPath) {\n    log(`no rootpath found!`, { type: \"error\" });\n    process.exit(1);\n  }\n\n  if (isBundle(rootPath)) {\n    const pathsWithOperations = [\"apps\", \"packages\", \"modules\"]\n      .map((folderName) => path.join(rootPath, folderName))\n      .filter((fullPath) => fs.existsSync(fullPath));\n\n    if (pathsWithOperations.length === 0) {\n      log(`Couldn't find any operations in ${rootPath}`);\n      process.exit(1);\n    }\n\n    return pathsWithOperations;\n  }\n  const toolsPath = path.join(rootPath, \"operations/tools\");\n  const bundlesPath = path.join(rootPath, \"operations/niches\");\n  if (!fs.existsSync(toolsPath) || !fs.existsSync(bundlesPath)) {\n    log(`Couldn't find tools or bundles folder in ${rootPath}`);\n    process.exit(1);\n  }\n\n  return [toolsPath, bundlesPath];\n}"
  },
  "getProjectRoot": {
    "name": "getProjectRoot",
    "slug": "TsFunction",
    "id": "lpzkeingbqvtsuifioioqttv",
    "description": "returns project root folder path\n\nrecursive. goes up until it finds a folder that's the project root\n\nif no source path is given, uses the directory name where the function is executed from as a starting point",
    "operationName": "get-path",
    "rawText": " (fullSourcePath?: string): string | undefined => {\n  const matchFolder = findFolderWhereMatch(\n    fullSourcePath || process.cwd(),\n    hasProjectRootFile\n  );\n  if (!matchFolder) return;\n  return matchFolder.folderPath;\n}"
  },
  "getRelativeLinkPath": {
    "name": "getRelativeLinkPath",
    "slug": "TsFunction",
    "id": "wpmuhhvuncknfornvpwyiksa",
    "description": "returns a relative link between two files",
    "operationName": "get-path",
    "rawText": " (\n  absoluteFromFilePath: string,\n  absoluteToFilePath: string,\n  debug?: boolean\n): string => {\n  const commonAncestorPath = getCommonAncestor(\n    absoluteFromFilePath,\n    absoluteToFilePath\n  );\n\n  //1 - go from `absoluteFromPath` to `commonAncestorPath`\n  const commonAncestorRelativeFromPath = makeRelative(\n    absoluteFromFilePath,\n    commonAncestorPath\n  );\n  const commonAncestorRelativeToPath = makeRelative(\n    absoluteToFilePath,\n    commonAncestorPath\n  );\n\n  const foldersToGoBackAmount =\n    commonAncestorRelativeFromPath.split(\"/\").length - 1;\n\n  const backOrStart =\n    foldersToGoBackAmount === 0 ? \"./\" : \"../\".repeat(foldersToGoBackAmount);\n\n  //2 - go from `commonAncestorPath` to `absoluteToPath`\n  const relativeLinkPath = `${backOrStart}${commonAncestorRelativeToPath}`;\n\n  if (debug) {\n    console.log({\n      commonAncestorPath,\n      commonAncestorRelativeFromPath,\n      commonAncestorRelativeToPath,\n    });\n  }\n\n  return relativeLinkPath;\n}"
  },
  "getRelativePath": {
    "name": "getRelativePath",
    "slug": "TsFunction",
    "id": "wpkvukkaxvkudrbqonxlsmwz",
    "description": "gets the relative path from a specified root\n\nwill start with \"/\"",
    "operationName": "get-path",
    "rawText": " (\n  absolutePath: string,\n  relativeFrom: \"project-root\"\n) => {\n  const rootPath =\n    relativeFrom === \"project-root\" ? getRootPath() : getRootPath();\n\n  if (!rootPath) return;\n\n  const relativePath = absolutePath.replace(rootPath, \"\");\n\n  return relativePath;\n}"
  },
  "getRootPath": {
    "name": "getRootPath",
    "slug": "TsFunction",
    "id": "fmajimvcaylpyqidbywegubz",
    "description": "Gets project path, or a folder in the root that is convention",
    "operationName": "get-path",
    "rawText": " (\n  /**\n   * if not specified, will return project root path\n   */\n  name?: OSRootFolder | ProjectRootFolder,\n  config?: { manualProjectRoot?: string }\n): string | undefined => {\n  const projectRootDir = config?.manualProjectRoot || getProjectRoot();\n  if (!projectRootDir) return;\n\n  if (!name) {\n    return projectRootDir;\n  }\n\n  if (isBundle(projectRootDir)) {\n    if (projectRootFolders.concat(osRootFolders).includes(name)) {\n      const projectFolder =\n        name === \"text\"\n          ? \"docs\"\n          : name === \"operations\"\n          ? \"packages\"\n          : name === databaseFolderName\n          ? databaseFolderName\n          : null;\n      if (!projectFolder) {\n        console.log(\"get root path: This should never happen\", name);\n        return;\n      }\n\n      const folderPath = path.resolve(projectRootDir, projectFolder);\n      return folderPath;\n    }\n  }\n\n  // non-bundled projects\n\n  if (projectRootFolders.concat(osRootFolders).includes(name)) {\n    const folderPath = path.resolve(projectRootDir, name);\n    return folderPath;\n  }\n\n  console.log(\n    \"getRootPath: Should never happen, probably a wrong input was provided:\",\n    { name }\n  );\n\n  return;\n}"
  },
  "getSrcRelativeFileId": {
    "name": "getSrcRelativeFileId",
    "slug": "TsFunction",
    "id": "fzfizbxnfivdtmnnwsbsbrvu",
    "description": "returns a file id (path without extension) relative to the src folder of an operation\n\ne.g. \"general\" for src/general.ts\n\nNB: assumes all src is in the src folder\n\nNB: removes \"/\" in the beginning, if found",
    "operationName": "get-path",
    "rawText": " (operationRelativePath: string) => {\n  const srcRelativePath = operationRelativePath.replace(\"src/\", \"\");\n  const parts = srcRelativePath.split(\".\");\n  // remove the last one\n  parts.pop();\n  const srcRelativeFileId = parts.join(\".\");\n\n  const finalId = srcRelativeFileId.startsWith(\"/\")\n    ? srcRelativeFileId.substring(1)\n    : srcRelativeFileId;\n  return finalId;\n}"
  },
  "getSubExtensions": {
    "name": "getSubExtensions",
    "slug": "TsFunction",
    "id": "cncupfaxxwbxdauoxgyjizzv",
    "description": "",
    "operationName": "get-path",
    "rawText": " (absolutePath: string): string[] => {\n  const fileName = path.parse(absolutePath).name;\n  const allSubExtensionsArray = fileName?.split(\".\") || [];\n  const allSubExtensions = allSubExtensionsArray.slice(\n    1,\n    allSubExtensionsArray.length - 1\n  );\n\n  return allSubExtensions;\n}"
  },
  "hasDependency": {
    "name": "hasDependency",
    "slug": "TsFunction",
    "id": "ggghsdbwgjcjwlkibjywbbcb",
    "description": "",
    "operationName": "get-path",
    "rawText": " (operation: Operation, dependency: string) => {\n  return getAllPackageJsonDependencies(operation).includes(dependency);\n}"
  },
  "hasProjectRootFile": {
    "name": "hasProjectRootFile",
    "slug": "TsFunction",
    "id": "cjeomsyyavdnjsdbmhuhgogr",
    "description": "",
    "operationName": "get-path",
    "rawText": " (absolutePath: string) => {\n  const osRootFilePath = path.join(absolutePath, \".project-root\");\n  const osRootFileExists = fs.existsSync(osRootFilePath);\n  return osRootFileExists;\n}"
  },
  "isBundle": {
    "name": "isBundle",
    "slug": "TsFunction",
    "id": "eabtucpbrvzwjrshtavssico",
    "description": "",
    "operationName": "get-path",
    "rawText": " (folderPath?: string): boolean => {\n  const realFolderPath = folderPath || getProjectRoot();\n  if (!realFolderPath) return false;\n  // get package-json and check operation config\n  const packageJson = readJsonFileSync<Operation>(\n    path.join(realFolderPath, \"package.json\")\n  );\n  const isBundle = packageJson?.operation?.isBundle || false;\n  return isBundle;\n}"
  },
  "isOperation": {
    "name": "isOperation",
    "slug": "TsFunction",
    "id": "ydtnptyknzypfomexinxhxbi",
    "description": "Checks whether or not an absolute path contains an operation. The only check it's doing is that the folder must contain both a package.json as well as a tsconfig.json",
    "operationName": "get-path",
    "rawText": " (absoluteFolderPath: string): boolean => {\n  const packageJsonPath = path.join(absoluteFolderPath, \"package.json\");\n  const existsPackageJson = fs.existsSync(packageJsonPath);\n  const tsConfigPath = path.join(absoluteFolderPath, \"tsconfig.json\");\n  const existsTsConfig = fs.existsSync(tsConfigPath);\n  // NB: must have these two in order to be an operation at all\n  if (!existsPackageJson || !existsTsConfig) {\n    return false;\n  }\n  return true;\n}"
  },
  "isUiOperation": {
    "name": "isUiOperation",
    "slug": "TsFunction",
    "id": "pmtujkunpisijrydumgaudwi",
    "description": "",
    "operationName": "get-path",
    "rawText": " (\n  tsconfig: TsConfig | null,\n  packageJson: Operation | null\n) => {\n  const isReactPackage =\n    !!packageJson &&\n    (hasDependency(packageJson, \"react\") ||\n      hasDependency(packageJson, \"react-native\") ||\n      hasDependency(packageJson, \"next\") ||\n      hasDependency(packageJson, \"expo\"));\n\n  const usesJsx = !!tsconfig?.compilerOptions?.jsx;\n\n  return isReactPackage && usesJsx;\n}"
  },
  "isWorkspaceRoot": {
    "name": "isWorkspaceRoot",
    "slug": "TsFunction",
    "id": "ygaiosistsahepbjbnawyqrb",
    "description": "simple sync function to check if a folder is the root of a workspace (not operation but a workspace)",
    "operationName": "get-path",
    "rawText": " (\n  folderPath: string\n): undefined | { isBundle: boolean; isWorkspaceRoot: boolean } => {\n  const packageJsonPath = path.join(folderPath, \"package.json\");\n  const existsPackageJson = fs.existsSync(packageJsonPath);\n  if (!existsPackageJson) return;\n\n  const packageJson = tryParseJson<Operation>(\n    fs.readFileSync(packageJsonPath, \"utf8\")\n  );\n\n  if (!packageJson || !packageJson.workspaces) {\n    return;\n  }\n\n  return {\n    isBundle: packageJson.operation?.isBundle || false,\n    isWorkspaceRoot: true,\n  };\n}"
  },
  "osRootFoldersConst": {
    "name": "osRootFoldersConst",
    "slug": "TsVariable",
    "id": "ekruenhmrvfqusncsrvbavye",
    "description": "can only be accessed in the OS",
    "operationName": "get-path"
  },
  "osRootFolders": {
    "name": "osRootFolders",
    "slug": "TsVariable",
    "id": "fevbdlhlwkehkzrhklqktqmg",
    "description": "",
    "operationName": "get-path"
  },
  "packageCompilesTs": {
    "name": "packageCompilesTs",
    "slug": "TsFunction",
    "id": "adbfyyixfdeumetnilmibzxt",
    "description": "",
    "operationName": "get-path",
    "rawText": " (packageJson: Operation | null) => {\n  return (\n    !!packageJson?.main &&\n    packageJson.main.startsWith(\"src/\") &&\n    (packageJson.main.endsWith(\".ts\") || packageJson.main.endsWith(\".tsx\"))\n  );\n}"
  },
  "projectRootFoldersConst": {
    "name": "projectRootFoldersConst",
    "slug": "TsVariable",
    "id": "pztrqemayhhpxnwbpdfzyufq",
    "description": "can be accessed in projects as well as in the OS",
    "operationName": "get-path"
  },
  "projectRootFolders": {
    "name": "projectRootFolders",
    "slug": "TsVariable",
    "id": "ttmjyzssskfsduxsmqkcjsnz",
    "description": "",
    "operationName": "get-path"
  },
  "tsconfigCompilesEsm": {
    "name": "tsconfigCompilesEsm",
    "slug": "TsFunction",
    "id": "drcjprvbxghpqktiyuzxwsnt",
    "description": "",
    "operationName": "get-path",
    "rawText": " (tsconfig: TsConfig) => {\n  return (\n    !!tsconfig.compilerOptions.module &&\n    !!tsconfig.compilerOptions.moduleResolution &&\n    tsconfig.compilerOptions.module !== ModuleKind.CommonJS &&\n    tsconfig.compilerOptions.moduleResolution !== ModuleResolutionKind.Classic\n  );\n}"
  },
  "getTsConfig": {
    "name": "getTsConfig",
    "slug": "TsFunction",
    "id": "iztzayzesnvqusncpuqmsldu",
    "description": "",
    "operationName": "get-ts-config",
    "rawText": " (packageFolder: string) => {\n  const jsonPath = path.join(packageFolder, \"tsconfig.json\");\n  const json = readJsonFile<TsConfig>(jsonPath);\n  return json;\n}"
  },
  "isAltB": {
    "name": "isAltB",
    "slug": "TsFunction",
    "id": "nvrrjvtffscbdnjfwkighwbl",
    "description": "⎇ B",
    "operationName": "hotkeys",
    "rawText": " (keyboardEvent: KeyboardEvent) => {\n  const { altKey, code } = keyboardEvent;\n  return altKey && code === \"KeyB\";\n}"
  },
  "isAltN": {
    "name": "isAltN",
    "slug": "TsFunction",
    "id": "sqsgvwgbdvcyruznzjckwvne",
    "description": "",
    "operationName": "hotkeys",
    "rawText": " (keyboardEvent: KeyboardEvent) => {\n  const { altKey, code } = keyboardEvent;\n  return altKey && code === \"KeyN\";\n}"
  },
  "isAltO": {
    "name": "isAltO",
    "slug": "TsFunction",
    "id": "iqhirzjkrjvpqrnjwroryvmg",
    "description": "",
    "operationName": "hotkeys",
    "rawText": " (keyboardEvent: KeyboardEvent) => {\n  const { altKey, code } = keyboardEvent;\n  return altKey && code === \"KeyO\";\n}"
  },
  "isAltW": {
    "name": "isAltW",
    "slug": "TsFunction",
    "id": "laendfkogqkjmnbotrsvxjxm",
    "description": "",
    "operationName": "hotkeys",
    "rawText": " (keyboardEvent: KeyboardEvent) => {\n  const { altKey, code } = keyboardEvent;\n  return altKey && code === \"KeyW\";\n}"
  },
  "isCtrlBacktick": {
    "name": "isCtrlBacktick",
    "slug": "TsFunction",
    "id": "ihndizrysxsknbutrjttfoqj",
    "description": "^ `",
    "operationName": "hotkeys",
    "rawText": " (keyboardEvent: KeyboardEvent) => {\n  const { ctrlKey, code } = keyboardEvent;\n\n  return ctrlKey && code === \"Backquote\";\n}"
  },
  "isCtrlP": {
    "name": "isCtrlP",
    "slug": "TsFunction",
    "id": "kekhbhnxktqfypyfcelranvi",
    "description": "^ P",
    "operationName": "hotkeys",
    "rawText": " (keyboardEvent: KeyboardEvent) => {\n  const { ctrlKey, code } = keyboardEvent;\n\n  return ctrlKey && code === \"KeyP\";\n}"
  },
  "isCtrlS": {
    "name": "isCtrlS",
    "slug": "TsFunction",
    "id": "myrrsfuloscjewitnbonalip",
    "description": "^ S",
    "operationName": "hotkeys",
    "rawText": " (keyboardEvent: KeyboardEvent) => {\n  const { ctrlKey, code } = keyboardEvent;\n\n  return ctrlKey && code === \"KeyS\";\n}"
  },
  "isCtrlSpace": {
    "name": "isCtrlSpace",
    "slug": "TsFunction",
    "id": "ptwchakhvqhbqdunatbrjvyg",
    "description": "^ `",
    "operationName": "hotkeys",
    "rawText": " (keyboardEvent: KeyboardEvent) => {\n  const { code, ctrlKey } = keyboardEvent;\n  return ctrlKey && code === \"Space\";\n}"
  },
  "useHotkey": {
    "name": "useHotkey",
    "slug": "TsFunction",
    "id": "sbtrvzynnlrjvayvoyvsyfwz",
    "description": "hook that creates an eventlistener for keydown and cleans it up when needed",
    "operationName": "hotkeys",
    "rawText": " (\n  /**\n   * callback that needs to launch on any keyboard event\n   */\n  isRightKey: (keyboardEvent: KeyboardEvent) => boolean,\n  /**\n   * function to be executed when hotkey occurs\n   */\n  callback: () => void,\n  /**\n   * when the callback needs to be reloaded\n   */\n  dependencies: any[]\n) => {\n  const fullCallback = (keyboardEvent: KeyboardEvent) => {\n    if (isRightKey(keyboardEvent)) {\n      callback();\n    }\n  };\n  return useHotkeys(dependencies, fullCallback);\n}"
  },
  "useHotkeys": {
    "name": "useHotkeys",
    "slug": "TsFunction",
    "id": "rhyvkqnntnefdgvxsrbfpfsv",
    "description": "hook that creates an eventlistener for keydown and cleans it up when needed",
    "operationName": "hotkeys",
    "rawText": " (\n  /**\n   * when the callback needs to be reloaded\n   */\n  dependencies: any[],\n  /**\n   * callback that needs to launch on any keyboard event\n   */\n  callback: (keyboardEvent: KeyboardEvent) => void\n) => {\n  return useEffect(() => {\n    if (typeof window === \"undefined\") return;\n    window.addEventListener(\"keydown\", callback);\n    return () => window.removeEventListener(\"keydown\", callback);\n  }, dependencies);\n}"
  },
  "ajvMap": {
    "name": "ajvMap",
    "slug": "TsVariable",
    "id": "movkhjaesbtilvsqmrnltkdr",
    "description": "",
    "operationName": "index-typescript"
  },
  "cli": {
    "name": "cli",
    "slug": "TsFunction",
    "id": "sbfkxskkajyvpcqnxmewtxcx",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " async () => {\n  const [filePath] = process.argv.slice(2);\n\n  const operationBasePath = findOperationBasePath(filePath);\n  if (!operationBasePath) {\n    console.log(\"Please provide a filePath that is part of an operation\");\n    return;\n  }\n  const operationName = getLastFolder(operationBasePath);\n\n  // NB: last argument has been removed, which should be the manualProjectRoot\n  await findAndUpsertTsInterfaces({ filePath, operationName });\n}"
  },
  "definitions": {
    "name": "definitions",
    "slug": "TsVariable",
    "id": "lqwtskqzofwaondajqteedcb",
    "description": "",
    "operationName": "index-typescript"
  },
  "findAndUpsertTsInterfaces": {
    "name": "findAndUpsertTsInterfaces",
    "slug": "TsFunction",
    "id": "rwgsfaqkeqxveqgepcteqynd",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " async (config: {\n  /**\n   * If not provided, will load the project at the operation base path of the filepath, and get the source file at the filePath\n   */\n  sourceFile?: SourceFile;\n  operationName: string;\n  /**\n   * path of the file to find TsInterfaces in\n   */\n  filePath: string;\n  projectRoot?: string;\n}): Promise<undefined | Creation<TsInterface>[]> => {\n  const { filePath, operationName, projectRoot } = config;\n  let { sourceFile } = config;\n\n  const operationBasePath = findOperationBasePath(filePath);\n  if (!operationBasePath) return;\n\n  if (!sourceFile) {\n    const project = getTsMorphProject(operationBasePath);\n    if (!project) return;\n    sourceFile = project.getSourceFile(filePath);\n  }\n\n  if (!sourceFile) {\n    console.log(\"Filepath not existing\");\n    return;\n  }\n\n  // NB: we need to get the named absolute import names because there may be type interfaces in there that we should add into our database!\n  const namedAbsoluteImportNames = sourceFile\n    .getImportDeclarations()\n    .map((importDeclaration) => {\n      const module = String(\n        importDeclaration.getModuleSpecifier().getLiteralText()\n      );\n      if (isAbsoluteImport(module)) {\n        const namedImports: string[] = importDeclaration\n          .getNamedImports()\n          .map((x) => x.getName());\n\n        return namedImports;\n      }\n    })\n    .filter(notEmpty)\n    .flat();\n\n  const morphInterfaceInfo: MorphInterfaceInfo[] = sourceFile\n    .getInterfaces()\n    .map((x) => ({\n      hasGeneric: getHasGeneric(x),\n      raw: x.getFullText(),\n      name: x.getName(),\n      isExported: x.isExported(),\n      description: x\n        .getLeadingCommentRanges()\n        .map((x) => x.getText())\n        .join(\"\\n\\n\"),\n      extensions: x.getExtends().map((x) => x.getText()),\n    }));\n\n  const morphTypeInfo: MorphInterfaceInfo[] = sourceFile\n    .getTypeAliases()\n    .map((x) => {\n      const isExported = x.isExported();\n      const name = x.getName();\n      return {\n        hasGeneric: getHasGeneric(x),\n        raw: x.getFullText(),\n        isExported,\n        description: x\n          .getLeadingCommentRanges()\n          .map((x) => x.getText())\n          .join(\"\\n\\n\"),\n        name,\n        extensions: [],\n      };\n    });\n\n  const morphTypesAndInterfacesInfo = morphTypeInfo.concat(morphInterfaceInfo);\n\n  const tsInterfaces = await generateSchema(\n    filePath,\n    morphTypesAndInterfacesInfo,\n    namedAbsoluteImportNames\n  );\n\n  const operationRelativeTypescriptFilePath = getOperationRelativePath(\n    filePath,\n    operationBasePath\n  );\n  // console.log({\n  //   morphTypeNames: morphTypesAndInterfacesInfo.map((x) => x.name),\n  //   namedAbsoluteImportNames,\n  //   tsInterfacesLength: tsInterfaces.length,\n  // });\n\n  // @ts-ignore\n  await db.remove(\n    \"TsInterface\",\n    (i) =>\n      i.operationRelativeTypescriptFilePath ===\n        operationRelativeTypescriptFilePath &&\n      !tsInterfaces.map((x) => x.name).includes(i.name),\n    { operationName, manualProjectRoot: projectRoot }\n  );\n  // @ts-ignore\n  const result = await db.upsert(\"TsInterface\", tsInterfaces, {\n    operationName,\n    removeUntouched: true,\n    manualProjectRoot: projectRoot,\n  });\n\n  // log(`Done`, { type: \"debug\" }, result);\n  return tsInterfaces;\n}"
  },
  "findCommentTypes": {
    "name": "findCommentTypes",
    "slug": "TsFunction",
    "id": "jqobleqgkgjaonhbsncslbyi",
    "description": "returns all types that are found as start of a line in the comment (capitalised, with a \":\" behind)",
    "operationName": "index-typescript",
    "rawText": " (\n  commentWithoutFrontmatter: string\n): CommentType[] => {\n  const lines = commentWithoutFrontmatter.split(\"\\n\");\n\n  const types = commentTypes.filter((type) =>\n    lines.find((line) => line.trimStart().startsWith(`${type.toUpperCase()}:`))\n  );\n\n  return types;\n}"
  },
  "generateSchema": {
    "name": "generateSchema",
    "slug": "TsFunction",
    "id": "ykgnowvtmxkvaazmdouosshe",
    "description": "If existing schema is not stale, just require it.\nOtherwise, generate it for a file\n\nNB: The `createGenerator` function finds also imported TsInterfaces, which leads to duplicate TsInterfaces. With pushing the interfaces to the slug filename, this is no problem though, there should not be any duplication!",
    "operationName": "index-typescript",
    "rawText": " async (\n  filePath: string,\n  morphInterfaceInfo: MorphInterfaceInfo[],\n  namedAbsoluteImportNames: string[]\n): Promise<Creation<TsInterface>[]> => {\n  // console.log({ filePath, namedAbsoluteImportNames });\n  const problems: string[] = [];\n\n  const operationBasePath = findOperationBasePath(filePath);\n  if (!operationBasePath) {\n    log(\"No operation base path\");\n    return [];\n  }\n  const operationRelativePath = makeRelative(filePath, operationBasePath);\n  const operationFolderName = getLastFolder(operationBasePath);\n  if (operationRelativePath === \"src/index.ts\") {\n    // should not index index\n    log(\"This should never happen, operationRelativePath is src/index\");\n    return [];\n  }\n\n  const tsConfigPath = path.join(operationBasePath, \"tsconfig.json\");\n  const tsConfigExists = fs.existsSync(tsConfigPath);\n\n  if (!tsConfigExists) {\n    const problem = `no tsconfig found for ${filePath}, not generating schemas`;\n    log(problem, {\n      type: \"error\",\n    });\n    problems.push(problem);\n\n    await db.update(\n      \"Operation\",\n      (item) => item.name === operationFolderName,\n      (old) =>\n        mergeNestedObject(old, {\n          operation: { buildResultIndexed: { indexInteracesErrors: problems } },\n        }),\n      { operationName: operationFolderName }\n    );\n\n    return [];\n  }\n\n  // TODO: check the defaults and possibilities in the docs/readme\n  const config: Config = {\n    // skipTypeCheck: true,\n    path: filePath,\n    tsconfig: tsConfigPath,\n    skipTypeCheck: true,\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n  };\n  const { schema, error } = tryCreateSchema(config);\n\n  if (!schema || !schema.definitions) {\n    const problem = `No schema/definitions found for ${filePath}. Error: ${error}`;\n    log(problem, { type: \"warning\" });\n\n    await db.update(\n      \"Operation\",\n      (item) => item.name === operationFolderName,\n      (old) =>\n        mergeNestedObject(old, {\n          operation: {\n            buildResultIndexed: { indexInteracesErrors: [problem] },\n          },\n        }),\n      { operationName: operationFolderName }\n    );\n\n    return [];\n  }\n\n  const interfacePromises = Object.keys(schema.definitions).map((typeName) => {\n    const thisMorphInterfaceInfo = morphInterfaceInfo.find(\n      (x) => x.name === typeName\n    );\n\n    const tsMorphFoundTypeAlso = !!thisMorphInterfaceInfo;\n    const isImportedType = namedAbsoluteImportNames.includes(typeName);\n    const isNamedParameters = typeName.startsWith(\"NamedParameters\");\n    if (tsMorphFoundTypeAlso || isImportedType || isNamedParameters) {\n      return schemaToTsInterface(\n        filePath,\n        typeName,\n        schema,\n        thisMorphInterfaceInfo\n      );\n    }\n\n    // console.log({ definitionNames: Object.keys(schema.definitions) });\n\n    log(\n      `Skipping type ${typeName}`,\n      { type: \"debug\" },\n      { tsMorphFoundTypeAlso, isImportedType, isNamedParameters }\n    );\n\n    // NB: only the interfaces declared in this file end up in the database! otherwise you'll get duplicates anyway.\n\n    // NB: we are still allowing absolute imported types to end up in the database. They will not be exported from our index, but we still need them for some frontend-generation tasks.\n    return;\n  });\n\n  const interfaces = (await Promise.all(interfacePromises)).filter(notEmpty);\n\n  return interfaces;\n}"
  },
  "getAllComments": {
    "name": "getAllComments",
    "slug": "TsFunction",
    "id": "zfhbbleksifueaypobxxrhpn",
    "description": "gets all leading comments and trailing comments raw text, put together, separated with newlines",
    "operationName": "index-typescript",
    "rawText": " (\n  tsMorphNode: VariableDeclaration | Statement | Expression,\n  fileContent: string,\n  operationRelativeTypescriptFilePath: string\n): Creation<TsComment>[] => {\n  const statementName = tsMorphNode\n    .asKind(SyntaxKind.VariableDeclaration)\n    ?.getName();\n  const rawStatement = tsMorphNode.getText();\n  const leadingComments = tsMorphNode\n    .getLeadingCommentRanges()\n    .map((commentRange) =>\n      makeTsComment({\n        operationRelativeTypescriptFilePath,\n        commentRange,\n        rawStatement,\n        statementName,\n        fileContent,\n      })\n    );\n  const trailingComments = tsMorphNode\n    .getTrailingCommentRanges()\n    .map((commentRange) =>\n      makeTsComment({\n        operationRelativeTypescriptFilePath,\n        commentRange,\n        rawStatement,\n        statementName,\n        fileContent,\n      })\n    );\n\n  const all = leadingComments.concat(trailingComments);\n  return all;\n}"
  },
  "getDbStorageMethod": {
    "name": "getDbStorageMethod",
    "slug": "TsFunction",
    "id": "beftkisopponirfseqtgsxtf",
    "description": "Gets db storage method for indexation\n\n1) Frontmatter overrules everything\n2) Special extensions are looked at",
    "operationName": "index-typescript",
    "rawText": " (config: {\n  typeName: string;\n  frontmatter: Frontmatter;\n  extensions?: string[];\n}): DbStorageMethod | undefined => {\n  const { typeName, frontmatter, extensions } = config;\n  const frontmatterResult = getFrontmatterDbStorageMethod(frontmatter);\n\n  // NB: can also become null if isDbModel is specifically set to false!\n  if (frontmatterResult !== undefined) return frontmatterResult || undefined;\n\n  const specialExtensionStorageMethod =\n    getSpecialExtensionDbStorageMethod(extensions);\n\n  if (specialExtensionStorageMethod) {\n    return specialExtensionStorageMethod;\n  }\n\n  const typeWords = lowerCaseArray(typeName);\n  const isModelTypeName =\n    typeWords.length >= 2 && [\"model\", \"db\"].includes(typeWords.pop()!);\n\n  const dbStorageMethodFromModelTypeName = isModelTypeName\n    ? \"jsonMultiple\"\n    : null;\n\n  if (dbStorageMethodFromModelTypeName) {\n    return dbStorageMethodFromModelTypeName;\n  }\n\n  return;\n}"
  },
  "getFrontmatterDbStorageMethod": {
    "name": "getFrontmatterDbStorageMethod",
    "slug": "TsFunction",
    "id": "obblvucnfxcsstbvkzhtetck",
    "description": "if isDbModel is specifically set to false, this will return null (which means this should overwrite other things)",
    "operationName": "index-typescript",
    "rawText": " (\n  parameters: null | Frontmatter\n): DbStorageMethod | null | undefined => {\n  if (!parameters) return;\n\n  const dbStorageMethod =\n    parameters.dbStorageMethod &&\n    typeof parameters.dbStorageMethod === \"string\" &&\n    dbStorageMethods.includes(parameters.dbStorageMethod)\n      ? (parameters.dbStorageMethod as DbStorageMethod)\n      : undefined;\n\n  if (dbStorageMethod) return dbStorageMethod;\n\n  const isDbModel = parameters.isDbModel;\n\n  if (isDbModel === \"true\") return \"jsonMultiple\";\n\n  if (isDbModel === \"false\") return null;\n}"
  },
  "getFrontmatterFunctionParameters": {
    "name": "getFrontmatterFunctionParameters",
    "slug": "TsFunction",
    "id": "eydlritwqfvrnpdqbzpgiuyi",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " (frontmatter: Frontmatter) => {\n  const isApiExposed = frontmatter.isApiExposed === \"true\";\n\n  const runEveryPeriod = runEveryPeriodStringArray.includes(\n    String(frontmatter.runEveryPeriod)\n  )\n    ? (String(frontmatter.runEveryPeriod) as RunEveryPeriodEnum)\n    : undefined;\n\n  const publicAuthorizationArray = frontmatter.publicAuthorization\n    ? String(frontmatter.publicAuthorization)\n        ?.split(\",\")\n        .map((x) => x.trim())\n    : undefined;\n\n  // const publicAuthorizationFrontmatter = publicAuthorizationArray\n  //   ?.filter((text) => authorizationLevelStringArray.includes(text))\n  //   .map((string) => string as AuthorizationLevel);\n\n  // NB: by default, users are authorized to search and read docs\n  // const publicAuthorization: AuthorizationLevel[] =\n  //   publicAuthorizationFrontmatter || [\"read\", \"search\"];\n\n  const result = { runEveryPeriod, isApiExposed };\n\n  return result;\n}"
  },
  "getIndexId": {
    "name": "getIndexId",
    "slug": "TsFunction",
    "id": "zskhmpmgrgexeijscsyocqwp",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " async (\n  filePath: string,\n  name: string\n): Promise<TsIndexModelType | undefined> => {\n  const operationPathParse = getOperationPathParse(filePath);\n  if (!operationPathParse) return;\n  const operationBasePath = findOperationBasePath(filePath);\n  if (!operationBasePath) return;\n\n  const { operationRelativeTypescriptFilePath, relativePathFromProjectRoot } =\n    operationPathParse;\n\n  // TODO: not sure if the projectRelativepath is correc,t that is probably needs to be a path to the db file!\n  const tsIndexModelType: TsIndexModelType = {\n    operationName: operationPathParse.operationName || null,\n    operationRelativeTypescriptFilePath,\n    // TODO: FIX\n    projectRelativePath: relativePathFromProjectRoot,\n    // operationName: \"\",\n    // operationRelativePath: \"\",\n    // projectRelativePath: \"\",\n    // operationRelativeTypescriptFilePath: \"\",\n    // srcFileId: \"\",\n\n    id: generateId(),\n    name,\n    slug: kebabCase(name),\n  };\n\n  return tsIndexModelType;\n}"
  },
  "getMaxIndentationDepth": {
    "name": "getMaxIndentationDepth",
    "slug": "TsFunction",
    "id": "kjzbifolfmpqajadcssgxhgc",
    "description": "gets the maximum indentation depth of any piece of code\n\ndoes this simply by splitting up the piece of code into lines and checking the indentation of every line, finding the highest one.\n\nassumes an indentation contains 2 spaces.",
    "operationName": "index-typescript",
    "rawText": " (functionText: string) => {\n  const lines = functionText.split(\"\\n\");\n  const maxDepth = lines.reduce((max, line) => {\n    const prefixSpaces = line.length - line.trimStart().length;\n    const lineIndentationDepth = Math.floor(prefixSpaces / 2);\n    return max > lineIndentationDepth ? max : lineIndentationDepth;\n  }, 0);\n\n  return maxDepth;\n}"
  },
  "getMinMaxValidation": {
    "name": "getMinMaxValidation",
    "slug": "TsFunction",
    "id": "ctnpdgckrnkoatprrfkpgvdk",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " (\n  keyword: \"min\" | \"max\",\n  type: string,\n  value: number\n) => {\n  const t = type.toLowerCase() as keyof typeof ajvMap;\n  return set({}, keyword + ajvMap[t], value);\n}"
  },
  "getNumberOfLines": {
    "name": "getNumberOfLines",
    "slug": "TsFunction",
    "id": "tcpzkijjwjvzkyaqlldesblh",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " (string: string) => {\n  return string.split(\"\\n\").length;\n}"
  },
  "getObjectSchema": {
    "name": "getObjectSchema",
    "slug": "TsFunction",
    "id": "ugwgvhnyexpmpolvddcqewqo",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " (\n  type: Type,\n  decorators: Decorator[],\n  schemaProps: { [key: string]: any } = {}\n) => {\n  const schema: SimpleJsonSchema = {};\n  // schema = {} handleExplicitValidation(\"object\", schema, decorators);\n  schema.type = \"object\";\n  schema.properties = {};\n  schema.required = schema.required || [];\n  const typeText = type.getText();\n  const nonNullableType = type.getNonNullableType();\n  const nonNullableTypeText = nonNullableType.getText();\n  schema.optional = nonNullableTypeText !== typeText;\n  type\n    .getNonNullableType()\n    .getProperties()\n    .forEach((prop) => {\n      const key = prop.getName();\n      const isGetter = prop.hasFlags(SymbolFlags.GetAccessor);\n      if ([\"request\", \"reply\"].includes(key) || isGetter) return;\n      const valueDeclaration = prop.getValueDeclarationOrThrow();\n      const decorators = (valueDeclaration as any).getDecorators\n        ? (valueDeclaration as any).getDecorators()\n        : [];\n\n      schema.properties[key] = {\n        ...(getParamSchema(valueDeclaration.getType(), decorators, prop) || {}),\n        ...(schemaProps[key] || {}),\n      };\n\n      if (!schema.properties[key]) {\n        console.warn(\"missing type for - \" + key);\n        schema.properties[key] = { type: \"object\" };\n      }\n      if (schema.properties[key].optional !== true) {\n        schema.required?.push(key);\n      }\n      delete schema.properties[key].optional;\n    });\n\n  if (!schema.required.length) {\n    delete schema.required;\n  }\n\n  return schema;\n}"
  },
  "getParamSchema": {
    "name": "getParamSchema",
    "slug": "TsFunction",
    "id": "jmnyqwzoymdenamyyzgihjpa",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " (\n  type: Type,\n  decorators: Decorator[] = [],\n  prop: tsSymbol | undefined = undefined\n) => {\n  const typeText = type.getText();\n  const nonNullableType = type.getNonNullableType();\n  const nonNullableTypeText = nonNullableType.getText();\n  let schema: SimpleJsonSchema = {};\n\n  schema.optional = nonNullableTypeText !== typeText;\n\n  if (nonNullableType.isArray()) {\n    schema = handleExplicitValidation(\"array\", schema, decorators);\n    schema.type = \"array\";\n    // NB: recursion!\n    schema.items =\n      getParamSchema(nonNullableType.getArrayElementTypeOrThrow(), []) || {};\n    Object.keys(schema.items).forEach(\n      (key) => delete schema.items[key].optional\n    );\n    delete schema.items.optional;\n    return schema;\n  }\n  if (nonNullableType.getText() === \"Date\") {\n    schema.type = \"string\";\n    schema.format = \"date-time\";\n    return schema;\n  }\n\n  if (isPrimitive(nonNullableType)) {\n    schema.type = typeText.replace(\" | undefined\", \"\");\n    if (schema.type === \"string\") {\n      schema[\"allOf\"] = [{ transform: [\"trim\"] }, { minLength: 1 }];\n    }\n    schema = handleExplicitValidation(\n      nonNullableType.getText(),\n      schema,\n      decorators\n    );\n    return schema;\n  }\n\n  if (nonNullableType.isClass() || nonNullableType.isInterface()) {\n    const name =\n      nonNullableType.getText().split(\").\")[1] || nonNullableType.getText();\n    const importPath = typeText.split('\").')[0].split('import(\"')[1];\n    if (importPath && importPath.includes(\"/node_modules/\")) return schema;\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const c =\n      importPath && !importPath?.includes(\"/node_modules/\")\n        ? require(importPath)[name]\n        : undefined;\n    if (importPath && !c) {\n      console.log(`not found type: ${name}`);\n      return schema;\n    }\n    // NB: we seem not to have it, see https://medium.com/jspoint/introduction-to-reflect-metadata-package-and-its-ecmascript-proposal-8798405d7d88\n    // I installed reflect-metdata and added as require on top. Hope that works!\n    const classSchema = c\n      ? // @ts-ignore\n        Reflect.getMetaData(symbols.validations, c.prototype) || {}\n      : {};\n\n    schema[\"$ref\"] = \"#/definitions/\" + name;\n    if (!definitions[name]) {\n      definitions[name] = getObjectSchema(type, decorators, classSchema);\n    }\n    return schema;\n  }\n\n  if (nonNullableType.isObject()) {\n    schema = getObjectSchema(type, decorators);\n    return schema;\n  }\n  // enum --------------------------------------\n  if (nonNullableType.isEnumLiteral() && prop) {\n    const name = prop.getName();\n    const enumMembers = prop\n      ?.getValueDeclarationOrThrow()\n      ?.getSourceFile()\n      .getEnum((e) => e.getName() === nonNullableType.getText())\n      ?.getMembers();\n\n    const enumSchema: {\n      enum?: string[];\n      \"x-enumNames\"?: (string | number | undefined)[];\n      type?:\n        | \"string\"\n        | \"number\"\n        | \"bigint\"\n        | \"boolean\"\n        | \"symbol\"\n        | \"undefined\"\n        | \"object\"\n        | \"function\";\n    } = {};\n    enumSchema.enum = enumMembers?.map((m) => m.getName());\n    enumSchema[\"x-enumNames\"] = enumMembers?.map((m) => m.getValue());\n\n    enumSchema.type = enumSchema.enum?.[0]\n      ? typeof enumSchema.enum?.[0]\n      : undefined;\n\n    definitions[name] = enumSchema;\n    schema[\"$ref\"] = \"#/definitions/\" + name;\n    return schema;\n  }\n\n  if (nonNullableType.isEnum()) {\n    const name = last(nonNullableType.getText().split(\".\"))!;\n    const enumSchema: any = {};\n    enumSchema.enum = nonNullableType\n      .getUnionTypes()\n      .map((t) => t.getLiteralValueOrThrow());\n    enumSchema[\"x-enumNames\"] = nonNullableType\n      .getUnionTypes()\n      .map((t) => last(t.getText().split(\".\")) as string);\n    enumSchema.type = typeof enumSchema.enum[0];\n    definitions[name] = enumSchema;\n    schema[\"$ref\"] = \"#/definitions/\" + name;\n    return schema;\n  }\n\n  const unionTypes = type.getUnionTypes().filter((t) => !t.isUndefined());\n  if (unionTypes.length > 1) {\n    schema.oneOf = unionTypes.map((t) =>\n      getParamSchema(t, decorators)\n    ) as SimpleJsonSchema[];\n    if (!schema.oneOf[0]) {\n      delete schema.oneOf;\n      schema.enum = unionTypes.map((t) => t.getText().slice(1, -1));\n      schema[\"x-enumNames\"] = unionTypes.map((t) => t.getText().slice(1, -1));\n      schema.type = typeof schema.enum[0];\n    }\n    return schema;\n  }\n}"
  },
  "getParametersFromInterfaces": {
    "name": "getParametersFromInterfaces",
    "slug": "TsFunction",
    "id": "dyjbnedzwcayeymatjvgvmfm",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " (\n  functionName: string,\n  /**\n   * NB: we need ALL interfaces here across the project because there may be others that were not found in the interfaces in the file, but only in the functions.\n   */\n  interfaces: Creation<TsInterface>[]\n) => {\n  const parametersInterface = interfaces.find(\n    (x) => x.name === `NamedParameters<typeof ${functionName}>`\n  );\n\n  /*\n    NB: this is how a named parameters typeDefinition looks for a function with 2 arguments\n    {\n      \"type\": \"object\",\n      \"properties\": {\n        \"markdownString\": { \"type\": \"string\" },\n        \"level\": { \"type\": \"number\" }\n      },\n      \"required\": [\"markdownString\", \"level\"],\n      \"additionalProperties\": false\n    }\n    */\n  const properties = parametersInterface?.type.typeDefinition?.properties;\n\n  const parameters: FunctionParameter[] = properties\n    ? Object.keys(properties)\n        .map((name) => {\n          const propertySchema = getSchema(\n            parametersInterface.type.typeDefinition?.properties?.[name]\n          );\n          const required =\n            parametersInterface.type.typeDefinition?.required?.includes(name) ||\n            false;\n\n          return propertySchema\n            ? {\n                name,\n                schema: propertySchema,\n                simplifiedSchema: simplifySchema(\n                  name,\n                  propertySchema,\n                  getPossibleRefs(interfaces),\n                  []\n                ),\n                required,\n              }\n            : undefined;\n        })\n        .filter(notEmpty)\n    : [];\n\n  return parameters;\n}"
  },
  "getPossibleRefs": {
    "name": "getPossibleRefs",
    "slug": "TsFunction",
    "id": "slvlemnpgnujsopwgakvfvwm",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " (\n  interfaces: Creation<TsInterface>[]\n): { name: string; schema: JSONSchema7 }[] => {\n  const possibleRefs2 = interfaces.map((tsInterface) => {\n    return tsInterface.type.typeDefinition\n      ? {\n          name: tsInterface.name,\n          schema: tsInterface.type.typeDefinition,\n        }\n      : null;\n  });\n\n  const possibleRefs = possibleRefs2.filter(notEmpty);\n\n  return possibleRefs;\n}"
  },
  "getSizeSummary": {
    "name": "getSizeSummary",
    "slug": "TsFunction",
    "id": "uufncghdlffytlgjpaefsxnc",
    "description": "gets a size summary for a file path\n\nDoes not calculate this for files that are too big (bigger than 1MB)",
    "operationName": "path-util",
    "rawText": " async (\n  filePath: string\n): Promise<SizeSummary> => {\n  const stat = await fs.stat(filePath);\n\n  const bytes = stat.size;\n  const characters = bytes;\n\n  const bytesPerCharacter = bytes / characters;\n  let lines = 1;\n  const charactersPerLine = characters / lines;\n  const numberOfFiles = 1;\n  let linesPerFile = lines;\n  if (bytes > 1024 * 1024) {\n    // NB: too big to watch content\n\n    return {\n      bytes,\n      lines: 0,\n      characters,\n      bytesPerCharacter,\n      charactersPerLine,\n      linesPerFile,\n      numberOfFiles,\n    };\n  }\n\n  const content = await fs.readFile(filePath, \"utf8\");\n  lines = content.split(\"\\n\").length;\n  linesPerFile = lines;\n\n  return {\n    bytes,\n    lines,\n    characters,\n    bytesPerCharacter,\n    charactersPerLine,\n    linesPerFile,\n    numberOfFiles,\n  };\n}"
  },
  "getSpecialExtensionDbStorageMethod": {
    "name": "getSpecialExtensionDbStorageMethod",
    "slug": "TsFunction",
    "id": "hltsvfslvytvurxjanbzodof",
    "description": "returns undefined if there is not a special extension. if there is, it returns the dbStorageMethod",
    "operationName": "index-typescript",
    "rawText": " (extensions?: string[]) => {\n  if (!extensions) return;\n\n  /**\n   * put any models here that should, if they are used as extension, have a db model generated\n   */\n  const specialExtensions = {\n    TsIndexModelType: \"jsonMultiple\",\n    OperationIndexModelType: \"jsonMultiple\",\n    DefaultModelType: \"jsonMultiple\",\n    SlugModelType: \"jsonMultiple\",\n    CsvModelType: \"csv\",\n    KeyValueMarkdownModelType: \"keyValueMarkdown\",\n    CategoryModelType: \"jsonMultiple\",\n    MarkdownModelType: \"markdown\",\n  };\n\n  const specialExtensionKeys = Object.keys(specialExtensions);\n\n  const specialExtension = extensions.find((x) =>\n    specialExtensionKeys.includes(x)\n  ) as undefined | keyof typeof specialExtensions;\n\n  if (!specialExtension) return;\n\n  const dbStorageMethod = specialExtensions[\n    specialExtension\n  ] as DbStorageMethod;\n  return dbStorageMethod;\n}"
  },
  "getTsStatements": {
    "name": "getTsStatements",
    "slug": "TsFunction",
    "id": "lskaiiubnilwmrtmqkrghvxe",
    "description": "Gets functions and variables from a tsmorph sourcefile",
    "operationName": "index-typescript",
    "rawText": " async (\n  sourceFile: SourceFile,\n  /**\n   * NB: we require all interfaces here across the monorepo because the ones indexed by the schema generator aren't complete.\n   */\n  tsInterfaces: Creation<TsInterface>[],\n  operationRelativeTypescriptFilePath: string,\n  fileContent: string\n) => {\n  const tsVariables: Creation<TsVariable>[] = sourceFile\n    .getVariableStatements()\n    .map((variableStatement) => {\n      const declarations = variableStatement.getDeclarations();\n      const inits = declarations\n        .map((x) => x.getInitializer())\n        .filter(notEmpty);\n\n      const name = declarations[0]?.getName();\n      const value = inits[0]?.getText();\n\n      const isExported = variableStatement.isExported();\n\n      const classification = variableStatement\n        .getDeclarationKind()\n        .toString()\n        .toLowerCase() as TsVariable[\"classification\"];\n\n      const description = variableStatement\n        .getJsDocs()\n        .map((x) => x.getText())\n        .map(stripComment)\n        .join(\"\\n\\n\");\n\n      const slug = kebabCase(name);\n\n      const type = getTypeInfo(declarations[0]?.getType());\n      const tsVariable: Creation<TsVariable> = {\n        classification,\n        comments: [],\n        isExported,\n        name,\n        slug,\n        operationRelativeTypescriptFilePath,\n        type,\n        value,\n        description,\n      };\n      return tsVariable;\n    });\n\n  const morphVars: VariableDeclarationInfo[] = sourceFile\n    .getStatements()\n    .map((x) => {\n      const variableDeclarations = x\n        .asKind(SyntaxKind.VariableStatement)\n        ?.getDeclarations();\n\n      if (!variableDeclarations || variableDeclarations.length === 0) return;\n\n      const explicitTypeName = variableDeclarations\n        .map((x) => x.getTypeNode()?.getText())\n        .filter(notEmpty)[0];\n      return {\n        explicitTypeName,\n        isExported: variableDeclarations[0].isExported(),\n        variableDeclarations,\n        // NB: if this is a VariableStatement\n        kindName: x.getKindName(),\n\n        // NB: this is how we can check if it's an arrow function (declaration Initializer Kind Names Includes Arrow Function)\n        isArrowFunction: variableDeclarations\n          .map((v) => v.getInitializer())\n          .map((x) => x?.getKindName())\n          .includes(\"ArrowFunction\"),\n\n        // NB: if it's a variable, we can get the name like this\n        names: variableDeclarations.map((x) => x.getName()),\n\n        comments: x\n          .getLeadingCommentRanges()\n          .map((x) => x.getText())\n          .map(stripComment),\n      };\n    })\n    .filter(notEmpty);\n\n  // const stringLiterals = morphVars.filter((v) => !v.isArrowFunction);\n\n  /*\n   * \n   * This was the old way of parsing tsVariables, but it was not finding the comments.\n   * \n   * \n  const tsVariables: Creation<TsVariable>[] = stringLiterals\n    .map((v) => {\n      const inits = v.variableDeclarations\n        .map((x) => x.getInitializer())\n        .filter(notEmpty);\n\n      const initComments = inits\n        .map((x) => x.getLeadingCommentRanges().map((x) => x.getText()))\n        .flat()\n        .join(\"\\n\\n\");\n      const variableDeclarationComments = v.variableDeclarations\n        .map((x) => x.getLeadingCommentRanges().map((x) => x.getText()))\n        .flat()\n        .join(\"\\n\\n\");\n\n      const name = v.names[0] || \"__NO_NAME__\";\n      const slug = kebabCase(name);\n      const value =\n        inits.map((x) => x.getText()).filter(notEmpty)[0] || \"__NO_VALUE__\";\n\n      // TODO: TEST, should return const, var or let\n      const classification = v.variableDeclarations[0]\n        .getVariableStatement()\n        ?.getDeclarationKind()\n        .toString()\n        .toLowerCase() as TsVariable[\"classification\"];\n\n      const variableDeclaration = v.variableDeclarations?.[0];\n\n      if (!variableDeclaration) {\n        return;\n      }\n\n      const variableComments = getAllComments(\n        variableDeclaration,\n        fileContent,\n        operationRelativeTypescriptFilePath\n      );\n\n      const statementComments: Creation<TsComment>[] = variableDeclaration\n        .getDescendantStatements()\n        .map((x) => {\n          const allComments = getAllComments(\n            x,\n            fileContent,\n            operationRelativeTypescriptFilePath\n          );\n          return allComments;\n        })\n        .flat();\n\n      const comments = variableComments\n        ? [...variableComments, ...statementComments]\n        : statementComments;\n\n      const isExported = v.isExported;\n\n      console.log({ comments, initComments, variableDeclarationComments });\n      const description = undefined;\n      const variable: Creation<TsVariable> = {\n        description,\n        isExported,\n        operationRelativeTypescriptFilePath,\n        comments,\n        name,\n        slug,\n        value,\n        // NB: still using typeToSchema here, is there another way?\n        type: getTypeInfo(variableDeclaration.getType()),\n        classification,\n      };\n      return variable;\n    })\n    .filter(notEmpty);\n    */\n\n  const morphFunctions = sourceFile.getFunctions();\n  const arrowFunctionVars = morphVars.filter((v) => v.isArrowFunction);\n\n  const arrowFunctions: Creation<TsFunction>[] = arrowFunctionVars\n    .map((v) => {\n      const isExported = v.isExported;\n\n      const arrowFunction = v.variableDeclarations?.map((x) =>\n        x.getInitializer()?.asKind(SyntaxKind.ArrowFunction)\n      )[0];\n\n      if (!arrowFunction) {\n        log(\"Should never get here, arrow function not found\", {\n          type: \"error\",\n        });\n        return;\n      }\n\n      const description = v.comments.join(\"\\n\\n\");\n\n      const name = v.names?.[0] || \"no name\";\n\n      const returnType = getTypeInfo(\n        arrowFunction.getReturnType().getApparentType()\n      );\n      const functionText = arrowFunction.getFullText();\n      const fullText = functionText.concat(description);\n\n      const parsedDescription = parseFrontmatterMarkdownString(description);\n      const frontmatter = parsedDescription.parameters;\n\n      const frontmatterParameters =\n        getFrontmatterFunctionParameters(frontmatter);\n\n      const fn: Creation<TsFunction> = {\n        ...frontmatterParameters,\n        isExported,\n        explicitTypeName: v.explicitTypeName,\n\n        operationRelativeTypescriptFilePath,\n\n        // TODO:\n        commentsInside: [],\n        rawText: functionText,\n        name,\n        slug: kebabCase(name),\n        parameters: getParametersFromInterfaces(name, tsInterfaces),\n        description,\n        returnType,\n        maxIndentationDepth: getMaxIndentationDepth(functionText),\n\n        // TODO: isolate the size calculations...\n\n        // size of function including comments\n        size: getSizeSummary(fullText),\n\n        // split it up\n        //codeSize: {},\n        //commentSize:{},\n\n        // cumulativeCodeSize:{},\n        // cumulativeCommentSize:{},\n        // cumulativeSize:{},\n      };\n\n      return fn;\n    })\n    .filter(notEmpty);\n\n  const regularFunctions: Creation<TsFunction>[] = morphFunctions.map(\n    (functionDeclaration) => {\n      const returnType = getTypeInfo(\n        functionDeclaration.getReturnType().getApparentType()\n      );\n\n      const functionText = functionDeclaration.getFullText();\n\n      const description = functionDeclaration\n        .getJsDocs()\n        .map((x) => x.getFullText())\n        .join(\"\\n\\n\");\n\n      const fullText = functionText.concat(description);\n\n      const parsedDescription = parseFrontmatterMarkdownString(description);\n      const frontmatter = parsedDescription.parameters;\n      const frontmatterParameters =\n        getFrontmatterFunctionParameters(frontmatter);\n\n      const name = functionDeclaration.getName() || \"__anonymous__\";\n\n      const fn: Creation<TsFunction> = {\n        ...frontmatterParameters,\n\n        name,\n\n        slug: kebabCase(name),\n        isExported: functionDeclaration.isExported(),\n        operationRelativeTypescriptFilePath,\n        // TODO:\n        commentsInside: [],\n        // function metadata\n        // function info\n        description,\n        parameters: getParametersFromInterfaces(name, tsInterfaces),\n        returnType,\n        size: getSizeSummary(fullText),\n        rawText: functionText,\n        maxIndentationDepth: getMaxIndentationDepth(functionText),\n      };\n\n      return fn;\n    }\n  );\n\n  const tsFunctions = arrowFunctions.concat(regularFunctions);\n\n  // console.log({ tsFunctions: tsFunctions.length });\n  return { tsFunctions, tsVariables };\n}"
  },
  "getTypeInfo": {
    "name": "getTypeInfo",
    "slug": "TsFunction",
    "id": "oxumurfggjlykzbvcdbcucqc",
    "description": "takes a ts morph type and returns all info about it\n\nif available, a schema should be provided about the type because it's hard to infer it (probably buggy)",
    "operationName": "index-typescript",
    "rawText": " (type: Type, schema?: Schema): TypeInfo => {\n  const rawType = type.getApparentType().getText();\n  const isArray = type.isArray();\n  const isEnum = type.isEnum();\n  const isEnumLiteral = type.isEnumLiteral();\n  const isPrimitive = type.isString() || type.isNumber() || type.isBoolean();\n  const isObject = type.isObject();\n\n  let typeDefinition: Schema | undefined = undefined;\n  try {\n    typeDefinition = schema || typeToSchema(type);\n  } catch (e) {\n    log(`Type to schema failed with error: ${e}`, { type: \"debug\" });\n  }\n\n  const typeInfo: TypeInfo = {\n    rawType,\n    typeDefinition,\n    // TODO:\n    typeCoverage: 0,\n    // this is easy to infer\n    isArray,\n    isEnum,\n    isObject,\n    isPrimitive,\n    isEnumLiteral,\n    simplifiedSchema: typeDefinition\n      ? simplifySchema(\"type\", typeDefinition, [], [])\n      : undefined,\n  };\n\n  return typeInfo;\n}"
  },
  "getValidatedOperationPathParse": {
    "name": "getValidatedOperationPathParse",
    "slug": "TsFunction",
    "id": "kaxkpgigiwelxkrfznspdqwv",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " (\n  filePath: string\n): undefined | CompleteOperationPathParse => {\n  const fileParse = path.parse(filePath);\n\n  if (![\".ts\", \".tsx\"].includes(fileParse.ext)) {\n    log(`Incorrect extension ${fileParse.ext}`, { type: \"warning\" });\n    return;\n  }\n\n  // NB: filename is not only a name here but a relative path\n  if (!fs.existsSync(filePath)) {\n    log(`couldn't retreive filepath ${filePath}`, { type: \"error\" });\n    return;\n  }\n\n  const operationPathParse = getOperationPathParse(filePath);\n  if (!operationPathParse) {\n    log(\"Operation must have a pathparse to be indexed\", { type: \"error\" });\n    return;\n  }\n\n  return { ...operationPathParse, filePath };\n}"
  },
  "hasTypescriptFileChanged": {
    "name": "hasTypescriptFileChanged",
    "slug": "TsFunction",
    "id": "ezteplqgbrrzkdkpsuvvtrmz",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " (\n  eventName: WatchEventType,\n  path: string\n) => {\n  // for indexation we don't care about any other event than adding or changing a file\n  if (![\"add\", \"change\"].includes(eventName)) return false;\n  // in order to index a file, it must be in an operation, which means it must be in src\n  if (!path.includes(\"/src/\")) return false;\n  // only ts and tsx files matter, the rest doesn't need to be indexed\n  if (![\"ts\", \"tsx\"].includes(getExtension(path))) return false;\n\n  return true;\n}"
  },
  "indexImportsExportsForFilePath": {
    "name": "indexImportsExportsForFilePath",
    "slug": "TsFunction",
    "id": "jvavurpfglzhlajxbvxwscag",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " async (\n  eventName,\n  filePath\n) => {\n  const name = path.parse(filePath).name;\n  process.stdout.write(`Change detected: ${name}\\n`);\n  const operationBasePath = findOperationBasePath(filePath);\n  if (!operationBasePath) {\n    console.log(\"\\nCouldn't find operationBasePath\");\n    return;\n  }\n  process.stdout.write(`Indexing operation imports ...`);\n\n  await findAndWriteImportsExports(operationBasePath);\n\n  console.log(\"✅\\n\");\n}"
  },
  "indexTypescriptFilePath": {
    "name": "indexTypescriptFilePath",
    "slug": "TsFunction",
    "id": "zamdnfvhlcoscevyiyxxvhdl",
    "description": "Index a single typescript file",
    "operationName": "index-typescript",
    "rawText": " async (\n  eventName,\n  filePath\n) => {\n  const name = path.parse(filePath).name;\n  process.stdout.write(`Indexing file: ${name}`);\n\n  await indexTypescript({\n    filePaths: [filePath],\n    manualProjectRoot: null,\n    showLogging: false,\n  });\n\n  console.log(\"✅\\n\");\n}"
  },
  "indexTypescriptFile": {
    "name": "indexTypescriptFile",
    "slug": "TsFunction",
    "id": "tgapsmepcvspfoqiamtudrlo",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " async (\n  project: Project,\n  file: CompleteOperationPathParse,\n  projectRoot: string\n) => {\n  const problems: string[] = [];\n\n  const { filePath, operationName, operationRelativeTypescriptFilePath } = file;\n  if (!operationName) return;\n\n  // console.log(`indexing file`, {\n  //   operationName,\n  //   filePath,\n  //   operationRelativeTypescriptFilePath,\n  // });\n  // END VALIDATION\n\n  const fileContent = await fs.readFile(filePath, \"utf8\");\n\n  //select correct SourceFile from tsmorph project\n  const sourceFile = project.getSourceFile(filePath);\n\n  if (!sourceFile) {\n    const problem = `couldn't load file ${filePath}`;\n    problems.push(problem);\n\n    await db.update(\n      \"Operation\",\n      (item) => item.name === operationName,\n      (old) =>\n        mergeNestedObject(old, {\n          operation: { buildResultIndexed: { indexInteracesErrors: problems } },\n        }),\n      { operationName }\n    );\n\n    log(problem, { type: \"error\" });\n    return;\n  }\n\n  const newTsInterfaces = await findAndUpsertTsInterfaces({\n    filePath,\n    sourceFile,\n    operationName,\n    projectRoot,\n  });\n\n  if (!newTsInterfaces) {\n    log(\"Shouldn't happen but tsInterfaces is undefined here...\");\n    return;\n  }\n\n  const allTsInterfaces = await db.get(\"TsInterface\");\n\n  const allWithNewTsInterfaces = [\n    ...newTsInterfaces,\n    ...allTsInterfaces,\n  ].filter(onlyUnique2<Creation<TsInterface>>((a, b) => a.name === b.name));\n  // NB: interfaces are a prerequisite for function...\n\n  // console.log({\n  //   newTsInterfaces: newTsInterfaces.length,\n  //   allTsInterfaces: allTsInterfaces.length,\n  //   allWithNewTsInterfacesUnique: allWithNewTsInterfaces.length,\n  // });\n  // TODO:\n  const tsLintWarnings: TsLintWarning[] = [];\n\n  // TODO: get main comment from top of file or associated md\n  const mainComment = undefined;\n  const pathMetaData = await calculatePathMetaData(filePath);\n\n  const { tsFunctions, tsVariables } = await getTsStatements(\n    sourceFile,\n    allWithNewTsInterfaces,\n    operationRelativeTypescriptFilePath,\n    fileContent\n  );\n\n  // gets all top level statements\n  const topLevelComments: Creation<TsComment>[] = sourceFile\n    .getStatementsWithComments()\n    .map((x) => {\n      const comments = getAllComments(\n        x,\n        fileContent,\n        operationRelativeTypescriptFilePath\n      );\n      return comments;\n    })\n    .flat();\n\n  const functionComments: Creation<TsComment>[] = tsFunctions\n    .map((f) => f.commentsInside)\n    .flat();\n  const interfaceComments: Creation<TsComment>[] = newTsInterfaces\n    .map((f) => f.commentsInside)\n    .flat();\n  const variableComments: Creation<TsComment>[] = tsVariables\n    .map((f) => f.comments)\n    .flat();\n\n  // TODO: get all top level comments from the statements, but also get all comments already found in functions, variables, and interfaces, put together.\n  const tsComments: Creation<TsComment>[] = [\n    topLevelComments,\n    functionComments,\n    interfaceComments,\n    variableComments,\n  ].flat();\n\n  // Inserting all results into the database...\n\n  // @ts-ignore\n  await db.remove(\n    \"TsFunction\",\n    (fn) =>\n      fn.operationRelativeTypescriptFilePath ===\n        operationRelativeTypescriptFilePath &&\n      !tsFunctions.map((x) => x.name).includes(fn.name),\n    { operationName, manualProjectRoot: projectRoot }\n  );\n\n  // console.log({ tsFunctions: tsFunctions.length, operationName, projectRoot });\n  // @ts-ignore\n  await db.upsert(\"TsFunction\", tsFunctions, {\n    operationName,\n    manualProjectRoot: projectRoot,\n  });\n\n  await db.remove(\n    \"TsVariable\",\n    (v) =>\n      v.operationRelativeTypescriptFilePath ===\n        operationRelativeTypescriptFilePath &&\n      !tsVariables.map((x) => x.name).includes(v.name),\n    { operationName, manualProjectRoot: projectRoot }\n  );\n  await db.upsert(\"TsVariable\", tsVariables, {\n    operationName,\n    removeUntouched: true,\n    manualProjectRoot: projectRoot,\n  });\n\n  await db.remove(\n    \"TsComment\",\n    (c) =>\n      c.operationRelativeTypescriptFilePath ===\n      operationRelativeTypescriptFilePath,\n    { operationName, manualProjectRoot: projectRoot }\n  );\n  await db.upsert(\"TsComment\", tsComments, {\n    operationName,\n    removeUntouched: true,\n    manualProjectRoot: projectRoot,\n  });\n}"
  },
  "indexTypescript": {
    "name": "indexTypescript",
    "slug": "TsFunction",
    "id": "mkitjsveebwwyayfzirxodes",
    "description": "Creates a typescript file index in 3 steps\n1) Introspects the file\n2) Calculates all needed information about it\n3) Saves the result to /db/******.json in the operation root\n\nNB: Build errors are done separately as this is done operation-wide, everything else is done for each file\n\nNB: I don't think this is super efficient, because the project is taken to just index a single file. It's probably better to pass the project and the sourcefile in here, right?\n\nTODO: if a typescript file starst with a comment before any statements (but possibly after the `#!/usr/bin/env xyz` statement), this should be indexed as the main file comment... This can be shown when opening the file in the admin... It should also check if there is an associated md file for that in src, so that can also be added in the index.",
    "operationName": "index-typescript",
    "rawText": " async (props: {\n  showLogging?: boolean;\n  /**\n   * filepaths of files to index. must be files from the same operation.\n   */\n  filePaths: string[];\n  manualProjectRoot: string | null;\n}): Promise<void> => {\n  const { filePaths, manualProjectRoot, showLogging } = props;\n  // NB: fix to globally alter real fs in order to fix EMFile error that happens in TSMorph (see https://github.com/isaacs/node-graceful-fs)\n  gracefulFs.gracefulify(realFs);\n\n  const firstFilePath = filePaths[0];\n  if (!firstFilePath) {\n    log(\"Please provide some file paths\");\n  }\n\n  // NB: we can assume all files are from the same operation\n  const operationBasePath = findOperationBasePath(firstFilePath);\n  if (!operationBasePath) {\n    log(\"Operation must have a basepath to be indexed\", { type: \"error\" });\n    return;\n  }\n  const projectRoot = manualProjectRoot || getProjectRoot(firstFilePath);\n  if (!projectRoot) {\n    log(\"No project root found\", { type: \"error\" });\n    return;\n  }\n  const packageJson = await readJsonFile<Operation>(\n    path.join(operationBasePath, \"package.json\")\n  );\n\n  if (!packageJson) {\n    log(\"Operation must have a package.json to be indexed\", { type: \"error\" });\n    return;\n  }\n\n  const operationName = packageJson.name;\n\n  if (!operationName) {\n    log(\"Operation must have a name to be indexed\", { type: \"error\" });\n    return;\n  }\n\n  const problems: string[] = [];\n\n  // TODO: this takes a long time. I should probably execute everything for every file after this and use the same project\n\n  //create tsmorph project for full operation\n  const project = getTsMorphProject(operationBasePath);\n\n  if (!project) {\n    const problem = \"couldn't load project\";\n    problems.push(problem);\n    await db.update(\n      \"Operation\",\n      (item) => item.name === getFolder(operationBasePath),\n      (old) =>\n        mergeNestedObject(old, {\n          operation: { buildResultIndexed: { indexErrors: problems } },\n        })\n    );\n\n    log(problem, { type: \"error\" });\n    return;\n  }\n\n  const filePathsToIndex = filePaths\n    .map(getValidatedOperationPathParse)\n    .filter(notEmpty);\n\n  // NB: one by one because if you do multiple at once, writing commets goes corrupt because concurrent writing.\n  await oneByOne(filePathsToIndex, async (file, index) => {\n    if (showLogging) {\n      process.stdout.write(`${index + 1}) ${file.srcFileId} `);\n    }\n    const result = await indexTypescriptFile(project, file, projectRoot);\n    if (showLogging) {\n      console.log(\"✅\");\n    }\n    return result;\n  });\n}"
  },
  "isPrimitive": {
    "name": "isPrimitive",
    "slug": "TsFunction",
    "id": "uyzvpzjplhpvfyjadpqxzmzu",
    "description": "export const getDefinitions = () => definitions;\n\nexport const getClass = (name) => allClasses[name];",
    "operationName": "index-typescript",
    "rawText": " (type: Type) =>\n  type.isBoolean() || type.isNumber() || type.isString()"
  },
  "makeTsComment": {
    "name": "makeTsComment",
    "slug": "TsFunction",
    "id": "qyeqjdevcwzuoasexyhlurty",
    "description": "this is actually a fundamental part of the OS. How should comments be structured?\n\nI think, in general, that we should make it look as much as possible at markdown, because it should always be able to have markdown anyway.",
    "operationName": "index-typescript",
    "rawText": " (config: {\n  operationRelativeTypescriptFilePath: string;\n  commentRange: CommentRange;\n  /**\n   * if we can give the statement a name, it should be provided here\n   */\n  statementName: string | undefined;\n  rawStatement: string;\n  /** needed for calculating line numbers */\n  fileContent: string;\n}): Creation<TsComment> => {\n  const {\n    commentRange,\n    rawStatement,\n    statementName,\n    fileContent,\n    operationRelativeTypescriptFilePath,\n  } = config;\n  const fullCommentText = commentRange.getText();\n  const strippedComment = stripComment(fullCommentText);\n\n  // NB: wouldn't hurt to put character positions in the TsComment as well, would it? But let's not do it until we need it\n  const firstCharacter = commentRange.getPos();\n  const lastCharacter = commentRange.getEnd();\n  const firstLine = getNumberOfLines(fileContent.substring(0, firstCharacter));\n  const lastLine = getNumberOfLines(fileContent.substring(0, lastCharacter));\n  const isSingleLineComment = firstLine === lastLine;\n\n  const { parameters, raw: comment }: MarkdownParse = isSingleLineComment\n    ? { raw: strippedComment, parameters: {} }\n    : parseFrontmatterMarkdownString(strippedComment);\n\n  const types = findCommentTypes(comment);\n\n  const tsComment: Creation<TsComment> = {\n    name: \"Comment\",\n    slug: kebabCase(\"Comment\"),\n    operationRelativeTypescriptFilePath,\n    comment,\n    statementName,\n    rawStatement,\n    parameters,\n    types,\n    firstLine,\n    lastLine,\n  };\n\n  return tsComment;\n}"
  },
  "removeTypescriptIndex": {
    "name": "removeTypescriptIndex",
    "slug": "TsFunction",
    "id": "zmwrmzsujudukytvbontrrlz",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " async (\n  eventName,\n  filePath\n) => {\n  // NB: need to provide get folder because the original file is gone so it can't be detected\n  const operationPath = findOperationBasePath(getFolder(filePath));\n  if (!operationPath) {\n    return;\n  }\n\n  const operationName = getLastFolder(operationPath);\n  // console.log(`Found operationName: ${operationName}...`);\n\n  const result = await cleanupTsDatabase(operationName);\n  console.log(\n    `Cleaned up ${result?.amountRemoved || 0} indexes (removed ${\n      path.parse(filePath).base\n    })`\n  );\n}"
  },
  "schemaToTsInterface": {
    "name": "schemaToTsInterface",
    "slug": "TsFunction",
    "id": "gaoxnwvlzzuplyfctfvtzwwj",
    "description": "make a tsInterface from a schema generated from the file",
    "operationName": "index-typescript",
    "rawText": " async (\n  filePath: string,\n  typeName: string,\n  schema: Schema,\n  morphInterfaceInfo: MorphInterfaceInfo | undefined\n): Promise<Creation<TsInterface> | undefined> => {\n  const definitionOrBoolean = schema.definitions?.[typeName];\n\n  const operationBasePath = findOperationBasePath(filePath);\n  if (!operationBasePath) return;\n\n  const possibleRefs = schema.definitions\n    ? Object.keys(schema.definitions)\n        .map((typeName) => {\n          const theSchema = getSchema(schema.definitions?.[typeName]);\n          return theSchema ? { name: typeName, schema: theSchema } : null;\n        })\n        .filter(notEmpty)\n    : [];\n  const definition: Schema | undefined =\n    typeof definitionOrBoolean === \"object\" ? definitionOrBoolean : undefined;\n\n  if (!definition) return undefined;\n\n  const parsedDescription = parseFrontmatterMarkdownString(\n    stripComment(\n      morphInterfaceInfo?.description || definition.description || \"\"\n    )\n  );\n\n  const frontmatter = parsedDescription.parameters;\n\n  const { operationRelativePath } = frontmatter;\n\n  const isOperationIndex: boolean =\n    frontmatter.isOperationIndex === undefined\n      ? morphInterfaceInfo?.extensions.includes(\"TsIndexModelType\") || false\n      : Boolean(frontmatter.isOperationIndex);\n\n  const dbStorageMethod = getDbStorageMethod({\n    typeName,\n    frontmatter,\n    extensions: morphInterfaceInfo?.extensions,\n  });\n\n  const isDbModel = !!dbStorageMethod;\n\n  const slug = slugify(typeName);\n\n  const operationRelativeTypescriptFilePath = getOperationRelativePath(\n    filePath,\n    operationBasePath\n  );\n\n  const hasGeneric = !!morphInterfaceInfo?.hasGeneric;\n  const isExported = !!morphInterfaceInfo?.isExported;\n\n  const simplifiedSchema = simplifySchema(\n    typeName,\n    definition,\n    possibleRefs,\n    []\n  );\n\n  const interfaceObject: Creation<TsInterface> = {\n    // identifiers\n    id: slug,\n    name: typeName,\n    slug,\n\n    operationRelativeTypescriptFilePath,\n\n    hasGeneric,\n    isExported,\n\n    rawText: morphInterfaceInfo?.raw,\n    extensions: morphInterfaceInfo?.extensions,\n    isOperationIndex,\n    operationStorageLocationRelativeFilePath: operationRelativePath\n      ? String(operationRelativePath)\n      : undefined,\n    // interface info\n    description: parsedDescription?.raw,\n    dbStorageMethod,\n    isDbModel,\n    // TODO:\n    commentsInside: [],\n    type: {\n      // TODO: test\n      typeDefinition: definition,\n      simplifiedSchema,\n      // TODO:\n      typeCoverage: 0,\n      rawType: typeName,\n      // TODO:\n      isArray: false,\n      isEnum: false,\n      isEnumLiteral: false,\n      isObject: false,\n      isPrimitive: false,\n    },\n  };\n\n  return interfaceObject;\n}"
  },
  "symbols": {
    "name": "symbols",
    "slug": "TsVariable",
    "id": "qwnferkbluwyfizeweejcufm",
    "description": "",
    "operationName": "index-typescript"
  },
  "toSnack": {
    "name": "toSnack",
    "slug": "TsFunction",
    "id": "ugkdrxwjieibuazmequxbqjk",
    "description": "",
    "operationName": "index-typescript",
    "rawText": " (key: string) =>\n  key.replace(/([A-Z])/g, ($1) => \"-\" + $1.toLowerCase()).replace(/^-/, \"\")"
  },
  "tryCreateSchema": {
    "name": "tryCreateSchema",
    "slug": "TsFunction",
    "id": "lvwrwqjhekacspifvffsfshb",
    "description": "Try because sometimes generateSchema fails",
    "operationName": "index-typescript",
    "rawText": " (\n  config: Config\n): { schema?: Schema; error?: string } => {\n  try {\n    const generator = createGenerator(config);\n    const schema: Schema = generator.createSchema(config.type);\n    return { schema };\n  } catch (e) {\n    return { error: String(e) };\n  }\n}"
  },
  "typeToSchema": {
    "name": "typeToSchema",
    "slug": "TsFunction",
    "id": "gjhcegfxlguifrttitedvfqo",
    "description": "calculates the schema of a type\n\nthis is great for types inside of parameters of variables that are not declared separately, however, it's probably not as good as vega's json schema generator... therefore, it would be great to always prefer vega's way above this.\n\nNB: this method throws sometimes if it can't find some stuff, so make sure to try/catch it.\n\nTODO: Test and improve this one",
    "operationName": "index-typescript",
    "rawText": " (type: Type) => getParamSchema(type)"
  },
  "fetchWithTimeout": {
    "name": "fetchWithTimeout",
    "slug": "TsFunction",
    "id": "lowiodlohehgukeegeeuneej",
    "description": "",
    "operationName": "is-online",
    "rawText": " async (\n  url: string,\n  timeoutMs: number\n): Promise<{\n  isSuccessful: boolean;\n  isConnected: boolean;\n  response?: any;\n  message: string;\n}> => {\n  try {\n    const abortController = new AbortController();\n    const id = setTimeout(() => abortController.abort(), timeoutMs || 10000);\n\n    const response = await fetch(url, {\n      method: \"GET\",\n      signal: abortController.signal,\n      headers: {\n        Accept: \"application/json\",\n        \"Content-Type\": \"application/json\",\n      },\n    })\n      .then((response) => {\n        return {\n          isConnected: true,\n          isSuccessful: true,\n          message: \"Resolved\",\n          result: response,\n        };\n      })\n      .catch((error) => {\n        if (!timeoutMs) {\n          console.warn(error);\n        }\n        return {\n          isSuccessful: false,\n          isConnected: false,\n          message: \"The API didn't resolve: \" + error, //error + error.status +\n        };\n      });\n\n    clearTimeout(id);\n    return response;\n  } catch (e) {\n    return {\n      isSuccessful: false,\n      isConnected: false,\n      message: \"The API didn't resolve: \" + e,\n    };\n  }\n}"
  },
  "isOnline": {
    "name": "isOnline",
    "slug": "TsFunction",
    "id": "schqyjzrfdrkyejxieesxpbp",
    "description": "Fetches google.com to check if we have an internet connection",
    "operationName": "is-online",
    "rawText": " async () => {\n  const { isConnected } = await fetchWithTimeout(\"https://google.com\", 10000);\n\n  return isConnected;\n}"
  },
  "isSystemBusy": {
    "name": "isSystemBusy",
    "slug": "TsFunction",
    "id": "jcvfitxvbfezygdnhyopqsia",
    "description": "",
    "operationName": "is-system-busy",
    "rawText": " async (): Promise<boolean> => {\n  const percentage = await new Promise<number>((resolve) =>\n    cpuUsage((percentage) => resolve(percentage))\n  );\n\n  return percentage > 0.75;\n\n  //    This is not useful enough....\n  //   console.dir(\n  //     {\n  //       cpus: cpus(),\n  //       totalmem: totalmem(),\n  //       freemem: freemem(),\n  //       load: loadavg(),\n  //     },\n  //     { depth: 99 }\n  //   );\n}"
  },
  "apply": {
    "name": "apply",
    "slug": "TsFunction",
    "id": "xpbtdgpxzpdegrnfwjxbzqfw",
    "description": "sum([1, 2, 3]);\n\nfunction that takes an array of functions and applies them one by one, on the value or the result of the previous function. Only possible if the type of the value stays the same.",
    "operationName": "js-util",
    "rawText": " <T>(functions: ((input: T) => T)[], value: T) => {\n  return functions.reduce((val, fn) => {\n    return fn(val);\n  }, value);\n}"
  },
  "concatenate": {
    "name": "concatenate",
    "slug": "TsFunction",
    "id": "gklauchfwbmtcoyoragsckkp",
    "description": "",
    "operationName": "js-util",
    "rawText": " async (letter: string) => `${letter}+${letter}`"
  },
  "createEnum": {
    "name": "createEnum",
    "slug": "TsFunction",
    "id": "xucgvjzwvjfpoxfztcnmaqzf",
    "description": "creates an enum object from a readonly const array so you don't have to\n------\nconst taskNames = [\"a\",\"b\",\"c\"] as const;\ntype TaskNames = typeof taskNames[number];\nconst enummm = createEnum(taskNames);\n(value of enummm: { a: \"a\", b: \"b\", c: \"c\" })",
    "operationName": "js-util",
    "rawText": " <T extends readonly string[]>(\n  array: T\n): { [K in typeof array[number]]: K } =>\n  array.reduce((previous, current) => {\n    return { ...previous, [current]: current };\n  }, {} as any)"
  },
  "createMappedObject": {
    "name": "createMappedObject",
    "slug": "TsFunction",
    "id": "pjkirnwvkqbvtfhyirhnyhgs",
    "description": "Creates a `MappedObject` of an array of any type. `MappedObject`s are great for increasing efficiency to get an item from an array. Especially useful when finds are needed on a specific key match for huge arrays. Instead of finding on the array you can simply get the right property from this object.\n\nNB: Don't use this inside of render functions, it's a very slow function, the whole idea is that this makes it faster, so just do it once!",
    "operationName": "js-util",
    "rawText": " <T extends { [key: string]: any }, U = T>(\n  array: T[],\n  /**\n   Key to make the map from. Must be unique or it could be overwritten. Key must be a string\n   */\n  mapKey: keyof T,\n  /**\n   * If the result of the mapped object, based on the object should have mapped values, provide this mapfunction to get them.\n   */\n  mapFn?: (value: T, array: T[]) => U\n): MappedObject<U> => {\n  const mappedObject = mergeObjectsArray(\n    array.map((item) => {\n      const key: string = item[mapKey];\n      const value = mapFn ? mapFn(item, array) : (item as unknown as U);\n\n      return {\n        [key]: value,\n      };\n    })\n  );\n\n  return mappedObject;\n}"
  },
  "destructureOptionalObject": {
    "name": "destructureOptionalObject",
    "slug": "TsFunction",
    "id": "iusskkqiychkocmxxdilbpgz",
    "description": "Easy way to destructure your object even if it may be `undefined` or `null`.\n\nHave you ever had a function with an optional configuration parameter, but you want to access all its properties? It's a hassle. This function lets you turn `doSomething` into `doSomethingBetter`. Check the code.\n\n```ts\n\n\nconst doSomething = (config?: { a: string; b: boolean; c: number }) => {\nconst a = config?.a;\nconst b = config?.b;\nconst c = config?.c;\n\nreturn \"something\" + a + b + c;\n};\n\nconst doSomethingBetter = (config?: { a: string; b: boolean; c: number }) => {\nconst { a, b, c } = destructureOptionalObject(config);\nreturn \"something\" + a + b + c;\n};\n\n```\n\n<!-- It would be great if I could also make examples that not only refer to input/output combos but maybe another function that showcases it's usage... -->",
    "operationName": "js-util",
    "rawText": " <T extends { [key: string]: any }>(\n  object: T | null | undefined\n): Partial<T> => {\n  if (!object) return {} as Partial<T>;\n  return object;\n}"
  },
  "findLastIndex": {
    "name": "findLastIndex",
    "slug": "TsFunction",
    "id": "dyuuhahpuewctbavzinlmpfu",
    "description": "finds the last index of an array where a certain filter holds true",
    "operationName": "js-util",
    "rawText": " <T>(array: T[], findFn: (item: T) => boolean) => {\n  const lastIndex = array\n    .map((item, index) => ({ item, index }))\n    .filter(({ item }) => findFn(item))\n    .pop()?.index;\n\n  return lastIndex;\n}"
  },
  "getObjectFromParamsString": {
    "name": "getObjectFromParamsString",
    "slug": "TsFunction",
    "id": "wevltklowdnekbkcvhprtqlp",
    "description": "useful for cli's that only take strings. This creates an object from a string\n\ninput: \"x:a, y:b, z:c\"\noutput: { x: \"a\", y: \"b\", z: \"c\" }\n\nTODO: would be nice if we can validate this string immediately using a JSON SCHEMA",
    "operationName": "js-util",
    "rawText": " (paramsString: string) =>\n  mergeObjectsArray(\n    paramsString\n      .split(\",\")\n      .map((x) => x.trim().split(\":\"))\n      .map((pair) =>\n        pair[0] && pair[1] ? { [pair[0].trim()]: pair[1] } : null\n      )\n      .filter(notEmpty)\n  )"
  },
  "getObjectKeysArray": {
    "name": "getObjectKeysArray",
    "slug": "TsFunction",
    "id": "dviufmvcycxibktviqzmzmmi",
    "description": "Handy function to get the keys of an object, but typed.\n\nNB: The only difference from Object.keys is that this returns the keys in a typesafe manner",
    "operationName": "js-util",
    "rawText": " <TObject extends { [key: string]: any }>(\n  object: TObject\n) => {\n  return Object.keys(object) as Extract<keyof TObject, string>[];\n}"
  },
  "getParameterAtLocation": {
    "name": "getParameterAtLocation",
    "slug": "TsFunction",
    "id": "wrzezmcfufpfbmqivplpgmiu",
    "description": "utility function to get a parameter inside of a nested object",
    "operationName": "js-util",
    "rawText": " <T = any>(\n  object: { [key: string]: any },\n  location: string[]\n): T => {\n  const firstParameter = object[location[0]];\n\n  if (location.length === 1) return firstParameter;\n\n  return getParameterAtLocation(firstParameter, location.slice(1));\n}"
  },
  "getSubsetFromObject": {
    "name": "getSubsetFromObject",
    "slug": "TsFunction",
    "id": "mpzknizwtrpqkguerlgqwpek",
    "description": "takes an object and a subset of its keys and returns a subset of that object\n\ninput: { x: \"a\", y: \"b\", z: \"c\" } and [\"x\"]\n\noutput: { x: \"a\" }",
    "operationName": "js-util",
    "rawText": " <T, K extends readonly (keyof T)[]>(\n  object: T,\n  keys: K\n) => {\n  type Subset = typeof keys[number];\n\n  const subsetObject = keys.reduce((obj, key) => {\n    return { ...obj, [key]: object[key] };\n  }, {} as Partial<T>) as Pick<T, Subset>;\n  return subsetObject;\n}"
  },
  "groupByKey": {
    "name": "groupByKey",
    "slug": "TsFunction",
    "id": "vlnpbsdmqnvnxowffhpjhldz",
    "description": "key should be of type string!\n\ninput = [{path:\"xyz\"},{path:\"xyz\"},{path:\"abc\"}]\ngroupByKey(input, \"path\")\nouput: { xyz: [{path:\"xyz\"},{path:\"xyz\"}], abc: [{path:\"abc\"}]}",
    "operationName": "js-util",
    "rawText": " <T extends { [key: string]: any }>(\n  array: T[],\n  key: keyof T\n) => {\n  return array.reduce((all, item) => {\n    const newAll = all;\n\n    const keyToUse: string = item[key as string];\n\n    const already = newAll[keyToUse];\n    if (!already) {\n      // create a new parameter in the group-object\n      newAll[item[key]] = [item];\n    } else {\n      // push to existing group-object parameter\n      newAll[item[key]].push(item);\n    }\n\n    return newAll;\n  }, {} as { [key: string]: T[] });\n}"
  },
  "hasAllLetters": {
    "name": "hasAllLetters",
    "slug": "TsFunction",
    "id": "vclbgudyaetmywlxyiixlter",
    "description": "all letters of b can be found in a, in order (but other letters in between are allowed)",
    "operationName": "js-util",
    "rawText": " (a: string, b: string) => {\n  const lettersLeft = a\n    .split(\"\")\n    .reduce((lettersLeft, lowercaseValueLetter) => {\n      if (lettersLeft[0] === lowercaseValueLetter) {\n        lettersLeft.shift();\n      }\n\n      return lettersLeft;\n    }, b.split(\"\"));\n\n  return lettersLeft.length === 0;\n}"
  },
  "insertAt": {
    "name": "insertAt",
    "slug": "TsFunction",
    "id": "fftfcbtkoiiecqwawnbuqpnv",
    "description": "Insert an array or item inside of an array before a certain index\n\nExample:\n\n```ts\n\nconst testArray = [1, 2, 3, 4, 5];\nconst result = insertAt(testArray, [99, 100], 2);\nconsole.log({ testArray, result });\n\n```",
    "operationName": "js-util",
    "rawText": " <T>(\n  array: T[],\n  items: T | T[],\n  /**\n   *\n   */\n  beforeIndex: number\n): T[] => {\n  const itemsArray = Array.isArray(items) ? items : [items];\n\n  // NB: slice makes copies\n  const before = array.slice(0, beforeIndex);\n  const after = array.slice(beforeIndex);\n  return [...before, ...itemsArray, ...after];\n}"
  },
  "isAllTrue": {
    "name": "isAllTrue",
    "slug": "TsFunction",
    "id": "dbwxwhzyulwbzvfzwvnggbhe",
    "description": "checks if all items in an array are true",
    "operationName": "js-util",
    "rawText": " (array: boolean[]): boolean => {\n  return !array.find((x) => !x);\n}"
  },
  "isArrayEqual": {
    "name": "isArrayEqual",
    "slug": "TsFunction",
    "id": "xqclirfmoxkqswjgroxpclop",
    "description": "",
    "operationName": "js-util",
    "rawText": " (a: any[], b: any[]): boolean => {\n  return (\n    Array.isArray(a) &&\n    Array.isArray(b) &&\n    a.length === b.length &&\n    a.every((val, index) => val === b[index])\n  );\n}"
  },
  "makeArray": {
    "name": "makeArray",
    "slug": "TsFunction",
    "id": "wpfvpulmtydcoykdicmrujjf",
    "description": "if something is not an array, returns it as the first element of an array\n\nif the input is undefined, an empty array will be returned.\n\nNB: TODO: find out the workings of the array constructor (`Array(\"any value\")`), because maybe it does something very similar. No need to have a dependency then if it's similar.",
    "operationName": "js-util",
    "rawText": " <T>(...arrayOrNotArray: (T | T[] | undefined)[]) => {\n  return arrayOrNotArray\n    .map((arrayOrNot) => {\n      const array: T[] = arrayOrNot\n        ? Array.isArray(arrayOrNot)\n          ? arrayOrNot\n          : [arrayOrNot]\n        : [];\n\n      return array;\n    })\n    .flat();\n}"
  },
  "mapAsync": {
    "name": "mapAsync",
    "slug": "TsFunction",
    "id": "iohlriuftrunntxkgvweosuy",
    "description": "mapAsync makes it possible to map over an array async without having to do the promise.all afterwards\n\nIt saves a lot of lines of code, and makes it more readable\nExample usage:\n\n\n```ts\n\nconst myNumbers = [1, 2, 3, 4, 5];\n\nconst doubleAsync = (num) => Promise.resolve(num + num);\nconst sqrtAsync = (sum) => Promise.resolve(sum * sum);\nconst halfAsync = (time) => Promise.resolve(time / 2);\n\nconst doubleSqrtHalfs = await mapAsync(myNumbers, doubleAsync)\n.then((sums) => mapAsync(sums, sqrtAsync))\n.then((times) => mapAsync(times, halfAsync));\n```",
    "operationName": "js-util",
    "rawText": " <T, U>(\n  array: T[],\n  callback: (value: T, index: number, array: T[]) => Promise<U>\n) => {\n  const u = Promise.all(array.map(callback));\n  return u;\n}"
  },
  "mapItem": {
    "name": "mapItem",
    "slug": "TsFunction",
    "id": "wamupyjqmkuvexghlrxdekxk",
    "description": "",
    "operationName": "js-util",
    "rawText": " async <T, U>(\n  mapFn: MapFn<T, U>,\n  currentValue: T,\n  index: number,\n  array: T[]\n): Promise<{\n  status: \"fulfilled\" | \"rejected\";\n  value?: U;\n  reason?: unknown;\n}> => {\n  try {\n    return {\n      status: \"fulfilled\",\n      value: await mapFn(currentValue, index, array),\n    };\n  } catch (reason) {\n    return {\n      status: \"rejected\",\n      reason,\n    };\n  }\n}"
  },
  "mapKeys": {
    "name": "mapKeys",
    "slug": "TsFunction",
    "id": "skhqqbfctcjlluxgumpbcxdm",
    "description": "maps over all keys in an object and replaces them using a mapfn",
    "operationName": "js-util",
    "rawText": " async (\n  object: { [key: string]: any },\n  mapFn: (key: string) => string | Promise<string> | undefined\n) => {\n  const keyPairs = await Promise.all(\n    Object.keys(object).map(async (oldKey) => {\n      return { oldKey, newKey: await mapFn(oldKey) };\n    })\n  );\n\n  return mergeObjectsArray(\n    keyPairs\n      .map((pair) => {\n        return pair.newKey ? { [pair.newKey]: object[pair.oldKey] } : null;\n      })\n      .filter(notEmpty)\n  );\n}"
  },
  "mapMany": {
    "name": "mapMany",
    "slug": "TsFunction",
    "id": "uaprfbebrttbqlbglfnpuoug",
    "description": "Lets you map over any array with a async function while setting a max. concurrency\n\nTaken and improved from https://codeburst.io/async-map-with-limited-parallelism-in-node-js-2b91bd47af70",
    "operationName": "js-util",
    "rawText": " async <T, U>(\n  array: T[],\n  mapFn: (item: T, index: number, array: T[]) => Promise<U>,\n  /**\n   * Limit of amount of items at the same time\n   */\n  limit?: number\n): Promise<U[]> => {\n  const result: U[] = [];\n\n  if (array.length === 0) {\n    return result;\n  }\n\n  const generator = arrayGenerator(array);\n  const realLimit = Math.min(limit || array.length, array.length);\n  const workers = new Array(realLimit);\n\n  for (let i = 0; i < realLimit; i++) {\n    workers.push(worker(i, generator, mapFn, result));\n  }\n\n  // console.log(`Initialized ${limit} workers`);\n\n  await Promise.all(workers);\n\n  return result;\n}"
  },
  "mapValuesSync": {
    "name": "mapValuesSync",
    "slug": "TsFunction",
    "id": "mrldsijncyiccwoxyzwcdxpi",
    "description": "maps over all values in an object and replaces them using a mapfn\n\nsync",
    "operationName": "js-util",
    "rawText": " <T, U>(\n  object: { [key: string]: T },\n  mapFn: (value: T) => U\n) => {\n  const valueObjectParts = Object.keys(object).map((key) => {\n    return { [key]: mapFn(object[key]) };\n  });\n\n  return mergeObjectsArray(valueObjectParts);\n}"
  },
  "mergeNestedObjectTest": {
    "name": "mergeNestedObjectTest",
    "slug": "TsFunction",
    "id": "iicnsuthexzgkfqsvjtnuate",
    "description": "",
    "operationName": "js-util",
    "rawText": " () => {\n  const testObject: {\n    a: string;\n    b: number;\n    c: { x: string; y: number; z: { a: string; b: number; c: { x: \"wow\" } } };\n  } = {\n    a: \"lol\",\n    b: 8,\n    c: { x: \"lol\", y: 88, z: { a: \"wow\", b: 888, c: { x: \"wow\" } } },\n  };\n\n  const result = mergeNestedObject(testObject, {\n    c: { z: { c: { x: undefined }, b: 999 } },\n  });\n\n  console.dir({ testObject, result }, { depth: 999 });\n}"
  },
  "mergeNestedObject": {
    "name": "mergeNestedObject",
    "slug": "TsFunction",
    "id": "ilednzfreabqtgrxnmakjglp",
    "description": "type X = IsOptional<string|undefined>;\n\nMerges an object into an object, ensuring typesafety. The second object needs to be a recursive subset of the first.\n\nLIMITATION: When you set a value to undefined, ensure that it is allowed by the original object, we are not checking for this!\n\nTODO: is it possible to remove this type unsafety? It would be nice to only be able to set it to undefined if that is allowed by T. Not sure if it's possible to check the difference bewteen a key not being present and a key being present and the value being undefined... Look it up!\n\nExample:\n\n\n```ts\n\nconst testObject: {\na: string;\nb: number;\nc: { x: string; y: number; z: { a: string; b: number; c: { x: \"wow\" } } };\n} = {\na: \"lol\",\nb: 8,\nc: { x: \"lol\", y: 88, z: { a: \"wow\", b: 888, c: { x: \"wow\" } } },\n};\n\nconst result = mergeNestedObject(testObject, {\nc: { z: { c: { x: undefined }, b: 999 } },\n});\n\nconsole.dir({ testObject, result }, { depth: 10 });\n\nresult will be: { a: 'lol', b: 8, c: { x: 'lol', y: 88, z: { a: 'wow', b: 999, c: { x: undefined } } }\n}\n\n```\n\nIt's great, because you can't make any type mistakes, and your code becomes much shorter for altering an object",
    "operationName": "js-util",
    "rawText": " <T extends O>(\n  object: T,\n  otherObject: NestedPartial<T> | undefined\n): T => {\n  if (object === undefined && otherObject !== undefined) {\n    // basecase that is used if the original object has some optional value undefined. in that case, the otherObject is used to set that key\n    return otherObject as T;\n  }\n  if (otherObject === undefined) return object;\n  // put `otherObject` on object, make sure\n\n  // const withoutUndefinedOtherObject = omitUndefinedValues(otherObject);\n  const partialNewObject = mergeObjectsArray(\n    // go over all keys in otherObject...\n    getObjectKeysArray(otherObject).map((key) => {\n      // get the value for it\n      const otherObjectValue = otherObject[key];\n\n      //   if it's defined, but not an object.. the value is definite.\n      // NB: arrays are also objects, but in this case they should also return\n      if (\n        typeof otherObjectValue !== \"object\" ||\n        Array.isArray(otherObjectValue)\n      ) {\n        return { [key]: otherObject[key] };\n      }\n\n      //   if it's defined and its type is an object, that object needs to be merged with the full object\n      const newValue = mergeNestedObject(object[key], otherObject[key]);\n\n      return { [key]: newValue };\n    })\n  ) as T;\n\n  //   ensure to merge the result with the original object to also do the first level\n  return { ...object, ...partialNewObject };\n}"
  },
  "mergeObjectParameters": {
    "name": "mergeObjectParameters",
    "slug": "TsFunction",
    "id": "smlryyhmgqerltnvbxbwmwtr",
    "description": "merges two objects: a config object and a defaults object. If the config object has something missing, a default will be used from the defaults object.\n\nIn short: merges two objects, for every parameter, use the default as a fallback\n\nDEPRECATED: in favor of mergeObjects",
    "operationName": "js-util",
    "rawText": " <T>(\n  config: T | undefined,\n  defaults: T | undefined\n) => {\n  const parameters = Object.keys({\n    ...config,\n    ...defaults,\n  }) as (keyof T)[];\n\n  const mergedConfig = parameters.reduce(\n    (getConfig, p) => ({ ...getConfig, [p]: config?.[p] || defaults?.[p] }),\n    {} as Partial<T>\n  );\n  return mergedConfig;\n}"
  },
  "mergeObjectsArray": {
    "name": "mergeObjectsArray",
    "slug": "TsFunction",
    "id": "jhlerfkbifwjedkcbylwuthh",
    "description": "TODO: find a way to return the correct type interface",
    "operationName": "js-util",
    "rawText": " <T extends { [key: string]: any }>(\n  objectsArray: T[]\n): T => {\n  const result = objectsArray.reduce((previous, current) => {\n    return { ...previous, ...current };\n  }, {} as T);\n\n  return result;\n}"
  },
  "mergeObjects": {
    "name": "mergeObjects",
    "slug": "TsFunction",
    "id": "zpvavkgekkjlgjebklencctr",
    "description": "merges multiple objects, overwriting the previous one with the next. Can be useful for configs where there are multiple layers of configs that overwrite each other.\n\nPlease note though, that only the root keys of the object are overwriting each other, so if there is nested datastructures, the last one with a specific key overwrites the previous ones copletely\n\nPlease note that you can provide partial objects as well, as long as you are sure that the final object is full, the type interface is correct.\n\nPlease note that if a latter object has a key which holds \"undefined\", it will NOT overwrite it. Anything else WILL",
    "operationName": "js-util",
    "rawText": " <T extends { [key: string]: any | undefined }>(\n  ...objects: (Partial<T> | undefined)[]\n): T | undefined => {\n  if (objects.length === 0) return;\n\n  const firstObject = objects[0];\n\n  const mergedObject = objects.reduce((previous, current) => {\n    if (!current) return previous;\n\n    const currentWithoutUndefined = omitUndefinedValues(current);\n\n    const newObject: Partial<T> | undefined = !previous\n      ? current\n      : { ...previous, ...currentWithoutUndefined };\n\n    return newObject;\n    // NB: we cannot guarantee this based on the input!\n  }, firstObject) as T;\n\n  return mergedObject;\n}"
  },
  "noEmptyString": {
    "name": "noEmptyString",
    "slug": "TsFunction",
    "id": "btqjhtopfswnwenwmkvckujo",
    "description": "",
    "operationName": "js-util",
    "rawText": " (\n  input: string | undefined\n): string | undefined => {\n  if (input === \"\") return undefined;\n  return input;\n}"
  },
  "objectMapAsync": {
    "name": "objectMapAsync",
    "slug": "TsFunction",
    "id": "txrbumikdeeiwynnsmlhqjym",
    "description": "Map an object asynchronously and return the same object with the mapped result in its values\n\nExample usage:\n\n\n```ts\n\nconst srcFileContentObject = {\n\"index.ts\": indexString,\n\"public-local.ts\": publicLocalTypescriptFileString,\n\"public.ts\": publicTypescriptFileString,\n};\n\nconst srcFileWriteSuccessObject = await objectMapAsync(srcFileContentObject, async (operationRelativeTypescriptFilePath,content)=>{\n\ntry {\nawait fs.writeFile(\npath.join(operationBasePath, \"src\", operationRelativeTypescriptFilePath),\ncontent,\n\"utf8\"\n);\n\nreturn true;\n\n} catch {\nreturn false;\n}\n\n});\n\n```",
    "operationName": "js-util",
    "rawText": " async <\n  TObject extends { [key: string]: any },\n  TResultValue,\n  TResultObject extends {\n    [key in keyof TObject]: TResultValue;\n  }\n>(\n  object: TObject,\n  mapFn: (\n    key: Extract<keyof TObject, string>,\n    value: TObject[keyof TObject]\n  ) => Promise<TResultValue>\n): Promise<TResultObject> => {\n  const keys = getObjectKeysArray(object);\n\n  const result = mergeObjectsArray(\n    await Promise.all(\n      keys.map(async (key) => {\n        const value = object[key];\n        return { [key]: await mapFn(key, value) };\n      })\n    )\n  ) as unknown as TResultObject;\n\n  return result;\n}"
  },
  "objectMapSync": {
    "name": "objectMapSync",
    "slug": "TsFunction",
    "id": "glmdarzpbcujyfkqwviwpmky",
    "description": "maps over all values in an object and replaces them using a mapfn\n\nExample usage:\n\n```ts\n\nconst result = objectMapSync({ hello: \"world\", isTrue: true }, (key,value) => {\nreturn `${value}123`;\n});\n```",
    "operationName": "js-util",
    "rawText": " <\n  TObject extends { [key: string]: any },\n  TMapResult,\n  TResultObject extends { [key in keyof TObject]: TMapResult }\n>(\n  object: TObject,\n  mapFn: (key: keyof TObject, value: TObject[keyof TObject]) => TMapResult\n): TResultObject => {\n  const valueObjectParts = getObjectKeysArray(object).map((key) => {\n    return { [key]: mapFn(key, object[key]) };\n  });\n\n  const merged = mergeObjectsArray(\n    valueObjectParts\n  ) as unknown as TResultObject;\n\n  return merged;\n}"
  },
  "objectValuesMap": {
    "name": "objectValuesMap",
    "slug": "TsFunction",
    "id": "qlhrohkbejssnvwsrcdgddso",
    "description": "not sure if this is the best way, but it does save some lines of code!\n\nmaps over an object's values with a map function\n\nDEPRECATED in favour of objectMapSync and objectMapAsync",
    "operationName": "js-util",
    "rawText": " <\n  T extends { [key: string]: T[string] },\n  U extends unknown\n>(\n  object: T,\n  mapFn: (key: string, value: T[string]) => U\n): { [key: string]: U } => {\n  return Object.keys(object).reduce(function (result, key) {\n    result[key] = mapFn(key, object[key]);\n    return result;\n  }, {} as any);\n}"
  },
  "omitUndefinedValues": {
    "name": "omitUndefinedValues",
    "slug": "TsFunction",
    "id": "ipxafiwvglslmhatridcxkyo",
    "description": "",
    "operationName": "js-util",
    "rawText": " <T extends { [key: string]: any }>(\n  object: T\n) => {\n  Object.keys(object).map((key) => {\n    const value = object[key];\n    if (value === undefined) {\n      delete object[key];\n    }\n  });\n\n  return object;\n}"
  },
  "onlyDuplicates": {
    "name": "onlyDuplicates",
    "slug": "TsFunction",
    "id": "figktdxsikssqeuxbavdwjey",
    "description": "",
    "operationName": "js-util",
    "rawText": "\n  <U>(isEqualFn?: (a: U, b: U) => boolean) =>\n  <T extends U>(value: T, index: number, self: T[]) => {\n    return (\n      self.findIndex((v) => (isEqualFn ? isEqualFn(v, value) : v === value)) !==\n      index\n    );\n  }"
  },
  "onlyUnique2": {
    "name": "onlyUnique2",
    "slug": "TsFunction",
    "id": "kkssresuzgkldykdngcrynrq",
    "description": "function that returns a filter function that can be used as a filter for any array. removes duplicates.\n\noptionally takes a compare function that should return a \"true\" if two instances are equal. if you use this function, make sure to pass a generic of the type the items will have, in order to make this equality function type safe as well",
    "operationName": "js-util",
    "rawText": "\n  <U>(isEqualFn?: (a: U, b: U) => boolean) =>\n  <T extends U>(value: T, index: number, self: T[]) => {\n    return (\n      self.findIndex((v) => (isEqualFn ? isEqualFn(v, value) : v === value)) ===\n      index\n    );\n  }"
  },
  "pickRandomArrayItem": {
    "name": "pickRandomArrayItem",
    "slug": "TsFunction",
    "id": "sazaakosiozopbkflolxylfp",
    "description": "",
    "operationName": "js-util",
    "rawText": " <T>(array: T[]) => {\n  return array[Math.floor((array.length - 1) * Math.random())];\n}"
  },
  "putIndexAtIndex": {
    "name": "putIndexAtIndex",
    "slug": "TsFunction",
    "id": "lfygyiuzalgtlycnqrnznfjw",
    "description": "Takes an item from an index of an array and put it somewhere at another index",
    "operationName": "js-util",
    "rawText": " <T>(\n  array: T[],\n  index: number,\n  toIndex: number\n) => {\n  const item = array[index];\n  const arrayWithoutIndex = removeIndexFromArray(array, index);\n  const changedArray = insertAt(arrayWithoutIndex, item, toIndex);\n  return changedArray;\n}"
  },
  "removeIndexFromArray": {
    "name": "removeIndexFromArray",
    "slug": "TsFunction",
    "id": "hwzlcsykgmmtkbhbnpnycjgk",
    "description": "removes an index from an array\n\nexample:\n\n```ts\nconst exampleArray = [\"a\", \"b\", \"c\", \"d\", \"e\"];\nconsole.log(removeIndexFromArray(exampleArray, 2)); //c should be removed\n```",
    "operationName": "js-util",
    "rawText": " <T>(array: T[], index: number) => {\n  const before = array.slice(0, index);\n  const after = array.slice(index + 1);\n  return [...before, ...after];\n}"
  },
  "removeOptionalKeysFromObjectStrings": {
    "name": "removeOptionalKeysFromObjectStrings",
    "slug": "TsFunction",
    "id": "gemzjcipcnkxskwsrymsfgql",
    "description": "",
    "operationName": "js-util",
    "rawText": " <TObject extends O>(\n  object: TObject,\n  keys: string[]\n): TObject => {\n  const newObject = keys.reduce((objectNow, key) => {\n    return {\n      ...objectNow,\n      [key]: undefined,\n    };\n  }, object);\n\n  return newObject;\n}"
  },
  "removeOptionalKeysFromObject": {
    "name": "removeOptionalKeysFromObject",
    "slug": "TsFunction",
    "id": "ohhfnbpztpgbbbtdcjjpvsmt",
    "description": "",
    "operationName": "js-util",
    "rawText": " <TObject extends O>(\n  object: TObject,\n  keys: OptionalKeys<TObject>[]\n): TObject => {\n  return removeOptionalKeysFromObjectStrings(object, keys);\n}"
  },
  "replaceLastOccurence": {
    "name": "replaceLastOccurence",
    "slug": "TsFunction",
    "id": "zxuwzqyiefaealqleoqvpnmo",
    "description": "Replaces the last occerence of something in a string by something else\n\nExample:\n\n```ts\nconst result = replaceLastOccurence(\"theBestSlugSlugSlug\", \"Slug\", \"Slack\");\nconsole.log(result); // returns theBestSlugSlugSlack\n```\n\nNB: this is not the most efficient method, as it reverses the string by making it an array, twice. It can probably be done more efficiently by using `String.lastIndexOf`",
    "operationName": "js-util",
    "rawText": " (\n  string: string,\n  searchValue: string,\n  replaceValue: string\n) => {\n  const [reversedString, reversedSearchValue, reversedReplaceValue] = [\n    string,\n    searchValue,\n    replaceValue,\n  ].map(reverseString);\n\n  const replacedReversedString = reversedString.replace(\n    reversedSearchValue,\n    reversedReplaceValue\n  );\n\n  const replacedString = reverseString(replacedReversedString);\n\n  return replacedString;\n}"
  },
  "reverseString": {
    "name": "reverseString",
    "slug": "TsFunction",
    "id": "wjovcjnvveovckovphbgnmqw",
    "description": "",
    "operationName": "js-util",
    "rawText": " (string: string): string => {\n  return string.split(\"\").reverse().join(\"\");\n}"
  },
  "sumAllKeys": {
    "name": "sumAllKeys",
    "slug": "TsFunction",
    "id": "znthvzgfrjydtkfgcttdxpkx",
    "description": "sums all keys of an array of objects, assuming the objects have the same datastructure and assuming the values contain either numbers or undefined",
    "operationName": "js-util",
    "rawText": " <T extends { [key: string]: number | undefined }>(\n  objectArray: T[],\n  keys: (keyof T)[]\n): T => {\n  const sumObject = objectArray.reduce((total, item) => {\n    // NB: not needed normally, but there seems to be some corrupt data here and there\n    if (!item) return total;\n    const newTotal = mergeObjectsArray(\n      keys.map((key) => {\n        const value1: number = total ? total[key] || 0 : 0;\n        const value2: number = item?.[key] || 0;\n\n        const sum =\n          (!total || total[key] === undefined) && item[key] === undefined\n            ? undefined\n            : value1 + value2;\n\n        return { [key]: sum };\n      })\n    ) as T;\n\n    return newTotal;\n  }, null as null | T) as T;\n\n  return sumObject;\n}"
  },
  "sumObjectParameters": {
    "name": "sumObjectParameters",
    "slug": "TsFunction",
    "id": "zbqfpcpianewmwqjyeymryer",
    "description": "sums all parameters in two objects together",
    "operationName": "js-util",
    "rawText": " <TObject extends { [key: string]: number }>(\n  object1: TObject,\n  object2: TObject\n): TObject => {\n  const objectKeys: (keyof TObject)[] = Object.keys(object1);\n  const summedObject = mergeObjectsArray(\n    objectKeys.map((key) => {\n      const summedObjectPart = { [key]: object1[key] + object2[key] };\n\n      return summedObjectPart;\n    })\n  ) as TObject;\n  // NB: too bad we still need `as TObject` here. I would love to learn how to prevent that\n\n  return summedObject;\n}"
  },
  "sum": {
    "name": "sum",
    "slug": "TsFunction",
    "id": "tdcqmbyzpjgbciavpmnqcpnq",
    "description": "NB: Tried, but doesn't work, probably because it only invalidates cache for one file, not all the files that are required by that file... we need a separate process\n\nconst requireWithoutCache = (filePath: string) => {\n\ndelete require.cache[path.resolve(filePath)];\n\nreturn require(filePath);\n\n};\n\nexample function that can be tested",
    "operationName": "k-test",
    "rawText": " (a: number, b: number): number => a + b"
  },
  "takeFirst": {
    "name": "takeFirst",
    "slug": "TsFunction",
    "id": "acjnhnpbzkivjmephszplnev",
    "description": "takes any type T or an array of T and returns T or the first of the array (which is T)",
    "operationName": "js-util",
    "rawText": " <T>(arrayOrNot: T | T[]) => {\n  return makeArray(arrayOrNot)[0];\n}"
  },
  "trimSlashes": {
    "name": "trimSlashes",
    "slug": "TsFunction",
    "id": "onemoquzvgkivegkwffsxcai",
    "description": "Trims a slash on both sides in any path",
    "operationName": "js-util",
    "rawText": " (absoluteOrRelativePath: string) => {\n  const isFirstCharacterSlash = absoluteOrRelativePath.charAt(0) === \"/\";\n  const isLastCharacterSlash =\n    absoluteOrRelativePath.charAt(absoluteOrRelativePath.length - 1) === \"/\";\n\n  const withoutSlashPrefix = isFirstCharacterSlash\n    ? absoluteOrRelativePath.slice(1)\n    : absoluteOrRelativePath;\n  const withoutSlashSuffix = isLastCharacterSlash\n    ? withoutSlashPrefix.slice(0, withoutSlashPrefix.length - 1)\n    : withoutSlashPrefix;\n\n  return withoutSlashSuffix;\n}"
  },
  "getSimpleJsonString": {
    "name": "getSimpleJsonString",
    "slug": "TsFunction",
    "id": "okdwvlhriiqcrjduakaogqvp",
    "description": "stringifies simple json things if the json is one of them, otherwise returns undefined",
    "operationName": "json-util",
    "rawText": " (json: Json): string | undefined => {\n  if (\n    [\n      \"string\",\n      \"number\",\n      \"bigint\",\n      \"boolean\",\n      \"symbol\",\n      \"undefined\",\n      // \"function\", // I don't think function is that simple, is it?\n    ].includes(typeof json) ||\n    json === null\n  ) {\n    return String(json);\n  }\n}"
  },
  "devCli": {
    "name": "devCli",
    "slug": "TsFunction",
    "id": "kokuqqviwbapisjgzhrcypli",
    "description": "The dev-cli runs the `dev` command which watches your operations with restarts\n\nYou can specify a customManualProjectRoot, which can be a relative or absolute path. If relative, it will use your cwd with the relative path to make an absolute path, that will in turn be passed to the `dev` function.",
    "operationName": "k-dev",
    "rawText": " async () => {\n  const [customManualProjectRoot] = process.argv.slice(2);\n\n  if (!customManualProjectRoot) return dev();\n\n  if (customManualProjectRoot.startsWith(\".\")) {\n    // relative path\n    const realProjectRootPath = path.join(\n      process.cwd(),\n      customManualProjectRoot\n    );\n\n    return dev(realProjectRootPath);\n  }\n\n  // absolute path\n  dev(customManualProjectRoot);\n}"
  },
  "dev": {
    "name": "dev",
    "slug": "TsFunction",
    "id": "wpihejfhnvynnbshaufbtblz",
    "description": "Running this function will start a watcher that watches all your operations for changes and rebuilds the operation on every change (compiling and indexing the altered file(s))",
    "operationName": "k-dev",
    "rawText": " (\n  /**\n   * manual project root for finding the operations\n   */\n  manualProjectRoot?: string\n): void => {\n  if (manualProjectRoot && !fs.existsSync(manualProjectRoot)) {\n    console.log(\"Please enter a manualProjectRoot that exists\");\n    return;\n  }\n\n  const vars = manualProjectRoot ? [manualProjectRoot] : undefined;\n  nodemon(\"watch-operations\", \"watchOperations\", vars);\n}"
  },
  "arg1": {
    "name": "arg1",
    "slug": "TsVariable",
    "id": "kkqprukhaswkwmxurbvrrktm",
    "description": "",
    "operationName": "k-explore"
  },
  "arg2": {
    "name": "arg2",
    "slug": "TsVariable",
    "id": "zxeaxitesplnubiahaymliyt",
    "description": "",
    "operationName": "k-explore"
  },
  "benchmark": {
    "name": "benchmark",
    "slug": "TsFunction",
    "id": "miahidujjodcxyfcuvswshik",
    "description": "",
    "operationName": "k-explore",
    "rawText": " async (amount: number = 100) => {\n  const key = `find src folders x${amount}`;\n  console.time(key);\n  let docs = await exploreOperationFolders({\n    basePath: getPathsWithOperations(),\n  });\n\n  console.timeEnd(key);\n  console.log(docs.length, \"folders found\", docs);\n}"
  },
  "determineFileType": {
    "name": "determineFileType",
    "slug": "TsFunction",
    "id": "sxqkdbqqzgvnliyaoghkwylh",
    "description": "returns the file type or null if it's unknown",
    "operationName": "k-explore",
    "rawText": " (filePath: string): FileType | null => {\n  const extension = path.parse(filePath).ext.substring(1);\n  if (!isSearchContentExtension(extension)) return null;\n  const index = fileTypes.findIndex((fileType) =>\n    extensions[fileType].includes(extension)\n  );\n  const fileType = fileTypes[index];\n  return fileType;\n}"
  },
  "exploreGitRepoFolders": {
    "name": "exploreGitRepoFolders",
    "slug": "TsFunction",
    "id": "xpucwwsdyszrtcrfgsiaoulu",
    "description": "find all active git folders (folders having `.git`)",
    "operationName": "k-explore",
    "rawText": " async (config: BaseConfig) => {\n  return (await findAllDotGitFolders(config))\n    .map((textJson) => textJson.path)\n    .map((p) => path.resolve(p, \"..\"));\n}"
  },
  "exploreMultiple": {
    "name": "exploreMultiple",
    "slug": "TsFunction",
    "id": "rhzruswwdegmtljykpkuskuv",
    "description": "DEPRECATED: not sure if we still need it, look up usecases, can prob be replaced now",
    "operationName": "k-explore",
    "rawText": " async (searchConfigs: SearchConfig[]) => {\n  const textJsonPromises = searchConfigs.map(async (config) => {\n    return explore(config);\n  });\n\n  return (await Promise.all(textJsonPromises)).flat();\n}"
  },
  "exploreOperationFolders": {
    "name": "exploreOperationFolders",
    "slug": "TsFunction",
    "id": "zizjzgmnapgwukxaoyysxlbb",
    "description": "find all active operations (folders having `package.json` but also `tsconfig.json`)\n\nreturns folder path array",
    "operationName": "k-explore",
    "rawText": " async (\n  config: BaseConfig\n): Promise<string[]> => {\n  const folders = (\n    await findAllPackages({\n      basePath: config?.basePath,\n    })\n  )\n    .map((x) => x.path)\n    .map((p) => getFolder(p))\n    .filter((p) => {\n      const alsoTsConfig = fs.existsSync(path.join(p, \"tsconfig.json\"));\n      return alsoTsConfig;\n    });\n\n  return folders;\n}"
  },
  "explorePreset": {
    "name": "explorePreset",
    "slug": "TsFunction",
    "id": "hvuhluabnmiimzdigrdqqxcr",
    "description": "",
    "operationName": "k-explore",
    "rawText": " (\n  preset: \"packages\" | \"markdown\" | \"todo\" | \"docs\" | \"src\" | \"git\",\n  config?: BaseConfig\n) => {\n  const basePath = config?.basePath;\n\n  const searchConfigs: SearchConfig[] =\n    preset === \"packages\"\n      ? [\n          {\n            basePath,\n            search: \"package.json\",\n            exact: true,\n            extension: \"json\",\n            ignore: generatedFolders,\n          },\n        ]\n      : preset === \"markdown\"\n      ? [\n          {\n            basePath,\n            extension: [\"md\", \"mdx\"],\n            ignore: generatedFolders,\n          },\n        ]\n      : preset === \"todo\"\n      ? // finds all `*.todo.md`,` todo/**/*.md` and returns the path + content\n\n        [\n          {\n            basePath,\n            extension: [\"md\", \"mdx\"],\n            search: \"/todo/\",\n            searchLevel: \"filePath\",\n            ignore: generatedFolders,\n          },\n          {\n            basePath,\n            extension: [\"md\", \"mdx\"],\n            search: \"todo.md\",\n            exact: true,\n            searchLevel: \"fileName\",\n            ignore: generatedFolders,\n          },\n          {\n            basePath,\n            extension: [\"md\", \"mdx\"],\n            subExtension: \"todo\",\n            exact: false,\n            searchLevel: \"fileName\",\n            ignore: generatedFolders,\n          },\n        ]\n      : preset === \"docs\"\n      ? [\n          {\n            basePath,\n            extension: [\"md\", \"mdx\"],\n            search: \"/docs/\",\n            searchLevel: \"filePath\",\n            ignore: generatedFolders,\n          },\n          {\n            basePath,\n            extension: [\"md\", \"mdx\"],\n            search: \"readme.md\",\n            exact: true,\n            searchLevel: \"fileName\",\n            ignore: generatedFolders,\n          },\n          {\n            basePath,\n            extension: [\"md\", \"mdx\"],\n            subExtension: [\"readme\"],\n            exact: false,\n            searchLevel: \"fileName\",\n            ignore: generatedFolders,\n          },\n        ]\n      : preset === \"src\"\n      ? [\n          {\n            basePath,\n            searchLevel: \"folder\",\n            exact: true,\n            search: \"src\",\n            doNotExploreMatch: true,\n            ignore: generatedFolders,\n          },\n        ]\n      : [];\n\n  const textJsons = exploreMultiple(searchConfigs);\n  return textJsons;\n}"
  },
  "explore": {
    "name": "explore",
    "slug": "TsFunction",
    "id": "bupnkvrfwgxlvzebejkismbd",
    "description": "This is the safe and friendly version of `findFilesRecursively`",
    "operationName": "k-explore",
    "rawText": " async ({\n  basePath,\n  searchLevel = \"fileName\",\n  debug,\n  ...other\n}: SearchConfig): Promise<TextJson[]> => {\n  /** accessability depends on whether we need to be able to read the file, or just see it */\n  const canAccess = async (p: string) =>\n    await (searchLevel === \"outline\" || searchLevel === \"full\"\n      ? canRead\n      : canSee)(p);\n\n  /** basepaths becomes an array of only the basepaths that we can access */\n  const accessibleBasePaths = makeArray(basePath || getProjectRoot())\n    .filter(fs.existsSync)\n    .filter(canAccess);\n\n  if (debug) console.log(`finding files in ${accessibleBasePaths.join(\",\")}`);\n\n  const textJsonPromises = accessibleBasePaths.map(async (p) =>\n    findFilesRecursively({ basePath: p, searchLevel, debug, ...other })\n  );\n\n  const textJsons = (await Promise.all(textJsonPromises)).flat();\n\n  return textJsons;\n}"
  },
  "findAllDocsFolderPaths": {
    "name": "findAllDocsFolderPaths",
    "slug": "TsFunction",
    "id": "sfjcgnqizcxejrkmjbkbmbvw",
    "description": "Returns absolute paths for all docs folders (not the files inside)",
    "operationName": "k-explore",
    "rawText": " async (\n  /**\n   * Don't look for docs folders inside of operation folders\n   */\n  ignoreOperations?: boolean,\n  /**\n   * optionally, ignore some folders\n   */\n  ignoreFolders?: string[]\n): Promise<string[]> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return [];\n  const docsBasePath = isBundle(projectRoot)\n    ? projectRoot\n    : getRootPath(\"operations\");\n\n  if (!docsBasePath) return [];\n\n  const docsFolderPaths = await findAllFoldersWithName({\n    basePath: docsBasePath,\n    folderName: \"docs\",\n    ignoreOperations,\n    ignoreFolders,\n  });\n  return docsFolderPaths;\n}"
  },
  "findAllDotGitFolders": {
    "name": "findAllDotGitFolders",
    "slug": "TsFunction",
    "id": "peugkbhksackyvkbqjeneovo",
    "description": "",
    "operationName": "k-explore",
    "rawText": " (config: BaseConfig) => {\n  return explore({\n    basePath: config?.basePath,\n    search: \".git\",\n    exact: true,\n    searchLevel: \"folder\",\n    doNotExploreMatch: true,\n    // I guess we can assume there will never be git folders inside an operation on a deeper level, that would be strange... Therefore, these can be ignored\n    ignore: [\"node_modules\", \"build\", \".next\", \"src\", \"assets\", \"data\"],\n  });\n}"
  },
  "findAllFoldersWithName": {
    "name": "findAllFoldersWithName",
    "slug": "TsFunction",
    "id": "mfcozmbejngfnxqyroscjftk",
    "description": "",
    "operationName": "k-explore",
    "rawText": " async (config: {\n  basePath: string;\n  folderName: string;\n  ignoreOperations?: boolean;\n  /**\n   * folders to ignore\n   */\n  ignoreFolders?: string[];\n}): Promise<string[]> => {\n  const { basePath, folderName, ignoreOperations, ignoreFolders } = config;\n\n  const result = (\n    await explore({\n      basePath,\n      searchLevel: \"folder\",\n      search: folderName,\n      ignore: [...generatedFolders, ...(ignoreFolders || [])],\n      exact: true,\n      cancelRecursionOn: ignoreOperations ? pathArrayIsOperation : undefined,\n    })\n  ).map((x) => x.path);\n\n  return result;\n}"
  },
  "findAllPackages": {
    "name": "findAllPackages",
    "slug": "TsFunction",
    "id": "rcanhfjkzutdcjjxzklasknf",
    "description": "",
    "operationName": "k-explore",
    "rawText": " (config?: {\n  basePath: string | string[] | undefined;\n}) => {\n  return explore({\n    basePath: config?.basePath || getPathsWithOperations(),\n    search: \"package.json\",\n    exact: true,\n    extension: \"json\",\n    searchLevel: \"fileName\",\n    ignore: generatedFolders.concat([\"src\", \"assets\", \"data\"]),\n  });\n}"
  },
  "findAllTodoFolderPaths": {
    "name": "findAllTodoFolderPaths",
    "slug": "TsFunction",
    "id": "ljwkiiegwymudgkmghurgimu",
    "description": "",
    "operationName": "k-explore",
    "rawText": " (\n  basePath: string,\n  ignoreOperations?: boolean\n): Promise<string[]> => {\n  return findAllFoldersWithName({\n    basePath,\n    folderName: \"todo\",\n    ignoreOperations,\n  });\n}"
  },
  "findFilesRecursively": {
    "name": "findFilesRecursively",
    "slug": "TsFunction",
    "id": "hunubkcawtfvtwsmdcsepqsf",
    "description": "Explores your files with many possibilities.\n\nNB: this function only searches one basePath, while explore can do multiple\n\nTODO: since this not only finds files but also explores them, naming should be exploreFilesRecursively, probably.\n\nTODO: TextJson[] is a bit weird name for the resulting type interface...",
    "operationName": "k-explore",
    "rawText": " async (\n  config: Omit<SearchConfig, \"basePath\"> & {\n    // this is the only difference compared to the other searchconfig\n    basePath: string;\n  }\n): Promise<TextJson[]> => {\n  const {\n    basePath,\n    ignore,\n    searchLevel,\n    extension,\n    subExtension,\n    search,\n    //booleans:\n    includeFoldersWithResults,\n    doNotExploreMatch,\n    doNotExploreChildFolders,\n    debug,\n    exact,\n    readmeOnTop,\n    includeStats,\n    includeMetaData,\n    cancelRecursionOn,\n  } = config;\n  // NB: we know we only use this function like this\n  const subExtensions = makeArray(subExtension);\n  const extensions = makeArray(extension);\n  const searches = makeArray(search);\n  const ignores = makeArray(ignore);\n\n  const contents = await fs.readdir(basePath, {\n    withFileTypes: true,\n    encoding: \"utf8\",\n  });\n\n  // NB: if there's a readme and readmeOnTop is true, make sure it ends up on top\n  const readmeIndex = readmeOnTop\n    ? contents.findIndex((x) => x.name.toLowerCase() === \"readme.md\")\n    : -1;\n  const sortedContents: Dirent[] =\n    readmeIndex !== -1\n      ? [contents[readmeIndex], ...removeIndexFromArray(contents, readmeIndex)]\n      : contents;\n\n  const pathArray = sortedContents.map((x) => path.join(basePath, x.name));\n\n  // if contents should not be explored, return an empty array\n  if (cancelRecursionOn?.(pathArray)) {\n    return includeFoldersWithResults\n      ? [{ path: basePath, isCancelRecursionResult: true, isFolder: false }]\n      : [];\n  }\n\n  if (debug)\n    console.log(`contents contains ${sortedContents.length} files/folders`);\n\n  const textJsonPromises: Promise<TextJson[] | null>[] = sortedContents.map(\n    async (dirent) => {\n      // don't check files if search level is folder\n      if (searchLevel === \"folder\" && dirent.isFile()) {\n        return null;\n      }\n\n      //if dir/file name should be ignored, skip it\n      if (ignores.includes(dirent.name)) {\n        if (debug) console.log(\"Ignoring\", dirent.name);\n        return null;\n      }\n\n      // if we want specific sub-extensions and this file isn't one of them, return\n      if (\n        dirent.isFile() &&\n        subExtensions &&\n        subExtensions.length > 0 &&\n        !subExtensions.find((ext) => getSubExtension(dirent.name) === ext)\n      ) {\n        if (debug)\n          console.log(\n            `ignoring ${dirent.name} because of subextension mismatch`\n          );\n        return null;\n      }\n\n      // if we want specific extensions and this file isn't one of them, return\n      if (\n        dirent.isFile() &&\n        extensions &&\n        extensions.length > 0 &&\n        !extensions.find((ext) => getExtension(dirent.name) === ext)\n      ) {\n        if (debug)\n          console.log(`ignoring ${dirent.name} because of extension mismatch`);\n        return null;\n      }\n\n      const filePath: string = path.join(basePath, dirent.name);\n\n      // if it's a file, we don't go into recursion.\n      if (dirent.isFile()) {\n        const ext = getExtension(dirent.name) || \"\";\n\n        //getting extension\n\n        const isJson = jsonExtensions.includes(ext);\n        const isTypescript = typescriptExtensions.includes(ext);\n        const isMarkdown = markdownExtensions.includes(ext);\n\n        //NB: be careful when ever changing this logic!\n        // It should never get contents when it doesn't need to,\n        // because this is a very heavy operation.\n\n        const searchContender =\n          searchLevel === \"folder\"\n            ? dirent.name\n            : searchLevel === \"fileName\"\n            ? dirent.name\n            : searchLevel === \"filePath\" || !isSearchContentExtension(ext)\n            ? filePath //withoutExtension? dirent.name or filePath??? we also want to match folder names before it, right?\n            : //TODO: is getOutLine() evaluated if it's not an outline? it also seems the default, which I don't like. Test this, it's an important aspect of exploring efficiently.\n            searchLevel === \"outline\"\n            ? getOutline(filePath)!\n            : searchLevel === \"full\"\n            ? await getContents(filePath)\n            : \"SHOULD_NEVER_HAPPEN\";\n\n        if (debug) console.log(`searchContender: ${searchContender}`);\n        const match = isMatch({ exact, searchContender, searches });\n\n        const json: any | undefined =\n          isJson && searchLevel === \"full\" ? getContents(filePath) : undefined;\n\n        const markdownJson: MarkdownParse | undefined =\n          isMarkdown && searchLevel === \"full\"\n            ? // TODO: get markdown parse here\n              await getContents(filePath)\n            : undefined;\n\n        // NB: TODO: we don't do typescript json yet\n        // TODO: I think double special comments (like the above) on a single line isn't indexed yet, is it?\n        const typescriptJson: undefined = isTypescript ? undefined : undefined;\n\n        const stats = includeStats ? await fs.stat(filePath) : undefined;\n\n        if (debug) console.log(`${dirent.name}? match ${match}`);\n        //match found...\n        const matchOrNot: TextJson[] | null = match\n          ? [\n              {\n                path: filePath,\n                json,\n                isFolder: false,\n                markdownJson,\n                typescriptJson,\n                stats: stats\n                  ? {\n                      createdAt: stats.ctimeMs,\n                      updatedAt: stats.mtimeMs,\n                    }\n                  : undefined,\n              },\n            ]\n          : null;\n        return matchOrNot;\n      }\n\n      // ^ these were all the base cases ^. Now the recursion.\n\n      if (dirent.isDirectory() && !doNotExploreChildFolders) {\n        let results: TextJson[] = [];\n        let shouldRecurse = true;\n        if (searchLevel === \"folder\") {\n          const searchContender = dirent.name;\n          const match = isMatch({ searchContender, exact, searches });\n\n          if (match) {\n            results.push({\n              path: filePath,\n              isFolder: true,\n            });\n            shouldRecurse = !doNotExploreMatch;\n          }\n        }\n\n        /**\n       don't dive into folder if:\n      - we're looking for folders \n      - the folder has matched \n      - we don't explore matches\n      */\n        if (shouldRecurse) {\n          const thisFolderPath = path.join(basePath, dirent.name);\n          const thisFolderResults = await findFilesRecursively({\n            basePath: thisFolderPath,\n            extension,\n            search,\n            searchLevel,\n            subExtension,\n            ignore,\n            debug,\n            exact,\n            // NB: I think we just need to fill in everything in the recursion, right?\n            cancelRecursionOn,\n            includeFoldersWithResults,\n            includeMetaData,\n            includeStats,\n            doNotExploreChildFolders,\n            doNotExploreMatch,\n          });\n\n          if (thisFolderResults.length > 0) {\n            results = results.concat(thisFolderResults);\n\n            if (includeFoldersWithResults) {\n              // NB: we can't show any stats because this fs.stats function only works on files. We could sum all stats recursively\n\n              // TODO: should use calcualtePathMetaData here, but we first need to do some more stuff before this can be done... calcualtePathMetaData probably needs to receive a full path instead of a operationFolderPath + relativePath because it can be used outside of operations as well...\n              const metaData = undefined;\n\n              const folderResult: TextJson = {\n                path: thisFolderPath,\n                metaData,\n                isFolder: true,\n              };\n\n              results.push(folderResult);\n            }\n          }\n        }\n\n        return results;\n      }\n\n      return null;\n    }\n  );\n\n  const allMatches = (await Promise.all(textJsonPromises))\n    .filter(notEmpty)\n    .flat();\n\n  return allMatches;\n}"
  },
  "getArgument": {
    "name": "getArgument",
    "slug": "TsFunction",
    "id": "kvpkraqlvlntoreruzfnpizd",
    "description": "",
    "operationName": "k-explore",
    "rawText": " (number: number) => {\n  return process.argv[1 + number];\n}"
  },
  "getContents": {
    "name": "getContents",
    "slug": "TsFunction",
    "id": "mrhlwelhckyfxscokojsdckq",
    "description": "gets needed contents of file path, based on the extension\n\nreturns a markdownparse if it's markdown, a json parse for json, or a file content string for anything else",
    "operationName": "k-explore",
    "rawText": " async (filePath: string) => {\n  // console.log(\"Get contents\", filePath);\n  const extension = getExtension(filePath);\n  if (!isSearchContentExtension(extension)) {\n    return;\n  }\n\n  if (extension === \"json\") {\n    return readJsonFile<any>(filePath);\n  } else if (markdownExtensions.includes(extension)) {\n    const contents = await fs.readFile(filePath, \"utf8\");\n    const markdownParse = mdToJsonParse(contents);\n    return markdownParse;\n  } else {\n    const fileString = fs.readFile(filePath, \"utf8\");\n    return fileString;\n  }\n}"
  },
  "getFolderTypescriptFiles": {
    "name": "getFolderTypescriptFiles",
    "slug": "TsFunction",
    "id": "xfuteuwonkvrkdlogwjlodlq",
    "description": "",
    "operationName": "k-explore",
    "rawText": " async (\n  folderPath: string,\n  includeStats: boolean\n) => {\n  return explore({\n    basePath: folderPath,\n    includeStats,\n    extension: [\"ts\", \"tsx\"],\n    ignore: [\"index.ts\", \"build\", \"db\", \"node_modules\"],\n  });\n}"
  },
  "getOutline": {
    "name": "getOutline",
    "slug": "TsFunction",
    "id": "oofwhojlcopudgpdxcwqiiav",
    "description": "low-level function that gets the outline for MarkdownParse\n\nNB: with books usually the pages are referred in the outline. Since that depends on the font size and dimensions, this cannot be done straight from the markdown parse. Eventually we probably need to check the made pdf for its content, maybe there is even a pdf feature that creates an outline for you. There must be more people having this problem.",
    "operationName": "markdown-parsings",
    "rawText": " (\n  markdownParse: MarkdownParse\n): string | undefined => {\n  const titles = markdownParse.content?.map(getTitlesRecursively).flat();\n  const outlineString = printNestedTitles(titles);\n  return outlineString;\n}"
  },
  "isMatch": {
    "name": "isMatch",
    "slug": "TsFunction",
    "id": "iseovjdtmyitauoppesxayrp",
    "description": "",
    "operationName": "k-explore",
    "rawText": " ({\n  exact,\n  searchContender,\n  searches,\n}: {\n  exact: boolean | undefined;\n  searches: string[];\n  searchContender: string;\n}) => {\n  return searches.length === 0\n    ? true\n    : exact\n    ? searches.includes(searchContender)\n    : searches.find((s) => searchContender.includes(s));\n}"
  },
  "isSearchContentExtension": {
    "name": "isSearchContentExtension",
    "slug": "TsFunction",
    "id": "jlvukhgeyxplhwhskwzavuxy",
    "description": "type checker for a string to be an extension that can be searched for",
    "operationName": "k-explore",
    "rawText": " (\n  extension: string\n): extension is SearchableExtension => {\n  return allowedSearchContentExtensions\n    .map((x) => x as string)\n    .includes(extension);\n}"
  },
  "pathArrayIsOperation": {
    "name": "pathArrayIsOperation",
    "slug": "TsFunction",
    "id": "xksslnfqbauwcawzxqjqtzgb",
    "description": "Checks if pathArray contains a package.json and a tsconfig.json and thus should be an operation\n\nHandy for `cancelRecursionOn` in `explore`",
    "operationName": "k-explore",
    "rawText": " (pathArray: string[]) => {\n  const hasPackageJson = !!pathArray.find(\n    (x) => path.parse(x).base === \"package.json\"\n  );\n  const hasTsConfig = !!pathArray.find(\n    (x) => path.parse(x).base === \"tsconfig.json\"\n  );\n\n  const isOperation = hasPackageJson && hasTsConfig;\n  return isOperation;\n}"
  },
  "[operationName, manualProjectRoot]": {
    "name": "[operationName, manualProjectRoot]",
    "slug": "TsVariable",
    "id": "euntkpgmdzusugpwpleoqznn",
    "description": "",
    "operationName": "k-test"
  },
  "runTestsForOperation": {
    "name": "runTestsForOperation",
    "slug": "TsFunction",
    "id": "yqggrjeesmrugxabthxvnheq",
    "description": "runTestsForOperation(operationName) runs all tests that can be found in an operation. nicely logs and returns which funtions are working or not and why\n\nthis assumes the index file exports all tests under the `test` constant, which should be done using this framework\n\nthis also assumes your tests are exported from build/index.js (which means you need to build your code, not transpile, so it's not possible for every type of operation)",
    "operationName": "k-test",
    "rawText": " async (\n  operationName: string,\n  writeResultsToIndex?: boolean,\n  manualProjectRoot?: string\n) => {\n  // console.log(`TESTING ${operationName}`);\n  const operationBasePath = await getOperationPath(operationName, {\n    manualProjectRoot,\n  });\n  if (!operationBasePath) {\n    console.log(\"k-test:Couldn't find operation base path...\", {\n      operationName,\n    });\n    return;\n  }\n\n  const operationIndexJsPath = path.join(operationBasePath, \"build/index.js\");\n\n  if (!fs.existsSync(operationIndexJsPath)) {\n    console.log(\"Couldn't find operation build/index.js file\", {\n      operationName,\n      operationIndexJsPath,\n    });\n    return;\n  }\n\n  const tests: Test | undefined = require(operationIndexJsPath).test;\n\n  if (!tests) {\n    log(`No tests found for ${operationName}`, { type: \"debug\" });\n    return;\n  }\n\n  return runTests(tests, operationName);\n}"
  },
  "runTests": {
    "name": "runTests",
    "slug": "TsFunction",
    "id": "tdedlxrjiuzanpzfhmgmnhha",
    "description": "run tests and log the results.\n\ninput: Test\n\noutput: isAllValid (boolean)",
    "operationName": "k-test",
    "rawText": " async (\n  test: Test,\n  operationName?: string\n): Promise<boolean> => {\n  const tests = makeArray(test);\n  if (tests.length === 0) return true;\n  const testsValid = await Promise.all(\n    // NB: doing an extra check on the type of the test in the array here, because it may contain a corrupt value\n    tests.map((t) => (typeof t === \"function\" ? t() : true))\n  );\n  const passedAmount = testsValid.filter((x) => x).length;\n  const failedAmount = testsValid.filter((x) => !x).length;\n\n  /**\n   * TODO:\n   * - makeTest should return the reuslts of the test, not only a boolean\n   * - save test results into operationIndex if operationName is given\n   */\n\n  console.log(\n    `${\n      operationName ? `${operationName}: ` : \"\"\n    }✅ ${passedAmount} tests passed, ${\n      failedAmount === 0 ? \"\" : \"❌ \"\n    }${failedAmount} tests failed`\n  );\n  return isAllTrue(testsValid);\n}"
  },
  "exampleKeyValueMarkdownParse": {
    "name": "exampleKeyValueMarkdownParse",
    "slug": "TsVariable",
    "id": "mkdphhgaidgbvmvorxzdlpit",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "exampleKvMdString": {
    "name": "exampleKvMdString",
    "slug": "TsVariable",
    "id": "mjjxevnvgdltrxmolptoruuh",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "exampleLine": {
    "name": "exampleLine",
    "slug": "TsVariable",
    "id": "aejrbxssexcoejwlwewrevxd",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "flattenMarkdownChunks": {
    "name": "flattenMarkdownChunks",
    "slug": "TsFunction",
    "id": "vohuhpavpwytxclygzueeplb",
    "description": "Flatten markdown content into an array of paragraphs",
    "operationName": "key-value-markdown-js",
    "rawText": " (\n  markdownChunks: MarkdownChunk[]\n): MarkdownParagraph[] => {\n  const flatMarkdownChunks = markdownChunks\n    .map((chunk) => getParagraphsRecursively(chunk))\n    .flat();\n  return flatMarkdownChunks;\n}"
  },
  "getKvmdItemsRecursively": {
    "name": "getKvmdItemsRecursively",
    "slug": "TsFunction",
    "id": "kcmdyybjfqrhvwmoufffirjx",
    "description": "recursively dives into the Chunk to get all kvmd items\n\nNB: this doesn't have a reference to its parent yet, but this will be added in fs-orm on the fly because the key for that is based on the model name",
    "operationName": "key-value-markdown-js",
    "rawText": " (\n  chunk: MarkdownChunk,\n  categoryStackUntilNow?: CategoryStack\n): Storing<KeyValueMarkdownModelType>[] => {\n  // NB: copy\n  let categoryStack = categoryStackUntilNow ? [...categoryStackUntilNow] : [];\n\n  let allKvmdItems: Storing<KeyValueMarkdownModelType>[] = [];\n\n  // If this chunk has a title (this is a header)\n  if (chunk.title) {\n    const headerParsedKvmdLine = parseKvmdLine(chunk.title);\n\n    // NB: titles with an empty key are ignored\n    if (headerParsedKvmdLine) {\n      // NB: also add the title as a model item\n      const headerKvmdItem: Storing<KeyValueMarkdownModelType> = {\n        ...headerParsedKvmdLine,\n        isHeaderCalculated: true,\n        // NB: copy!\n        categoryStack: [...categoryStack],\n      };\n      allKvmdItems.push(headerKvmdItem);\n\n      // NB: the slug of the title is added to the categoryStack, but only AFTER adding the kvmd item of the title\n      categoryStack.push(headerParsedKvmdLine.slug);\n    }\n  }\n\n  const childKvmdItems =\n    chunk.children\n      ?.map((childChunk) => getKvmdItemsRecursively(childChunk, categoryStack))\n      .flat() || [];\n\n  allKvmdItems = allKvmdItems.concat(childKvmdItems);\n\n  const lineKvmdItems = (chunk.content || \"\")\n    // NB: we are splitting on newlines here because content can still contain newlines.\n    .split(\"\\n\")\n    .map((line) => {\n      const parsedKvmdLine = parseKvmdLine(line);\n      if (!parsedKvmdLine) return;\n\n      const contentKvmdItem: Storing<KeyValueMarkdownModelType> = {\n        ...parsedKvmdLine,\n        isHeaderCalculated: false,\n        categoryStack,\n      };\n\n      return contentKvmdItem;\n    })\n    .filter(notEmpty);\n\n  allKvmdItems = allKvmdItems.concat(lineKvmdItems);\n\n  return allKvmdItems;\n}"
  },
  "getParagraphsRecursively": {
    "name": "getParagraphsRecursively",
    "slug": "TsFunction",
    "id": "znpjqslhfbgjhyvnhmndabpn",
    "description": "recursively dives into the Chunk to get all paragraphs inside",
    "operationName": "key-value-markdown-js",
    "rawText": " (\n  chunk: MarkdownChunk,\n  categoryStackUntilNow?: CategoryStack\n): MarkdownParagraph[] => {\n  // NB: no copy!\n  const categoryStack = categoryStackUntilNow ? categoryStackUntilNow : [];\n\n  if (chunk.title) {\n    categoryStack.push(chunk.title);\n  }\n\n  const childParagraphs =\n    chunk.children\n      ?.map((childChunk) => getParagraphsRecursively(childChunk, categoryStack))\n      .flat() || [];\n\n  const thisParagraph: MarkdownParagraph = {\n    paragraph: chunk.content || \"\",\n    categoryStack,\n  };\n\n  return [thisParagraph, ...childParagraphs];\n}"
  },
  "kvmdDataMap": {
    "name": "kvmdDataMap",
    "slug": "TsFunction",
    "id": "agkmphpamxepnwzkjfigfluz",
    "description": "DEPRECATED: probably never needed, unless I make it useful\n\nmapper function to give a kvmd data object other parameters.\n\nNB: not sure if this is useful. it would be useful if we could auto-generate the application of this function for multiple db models.",
    "operationName": "key-value-markdown-js",
    "rawText": " <\n  T extends { [key: string]: string | string[] | undefined }\n>(\n  data: KeyValueMarkdownModelType[],\n  {\n    keyName,\n    valueName,\n    categoryStackName,\n    commentName,\n  }: {\n    /**\n     * key by default\n     */\n    keyName?: string;\n    /**\n     * value by default\n     */\n    valueName?: string;\n    /**\n     * comment by default\n     */\n    commentName?: string;\n    /**\n     * categoryStack by default\n     */\n    categoryStackName?: string;\n  }\n): T[] => {\n  const newDataObject = data.map((item) => {\n    const newData = {\n      [keyName || \"name\"]: item.name,\n      [valueName || \"value\"]: item.value,\n      [commentName || \"comment\"]: item.comment,\n      [categoryStackName || \"categoryStack\"]: item.categoryStack,\n    } as T;\n\n    return newData;\n  });\n\n  return newDataObject;\n}"
  },
  "kvmdDataToString": {
    "name": "kvmdDataToString",
    "slug": "TsFunction",
    "id": "ycgahmkrisdepxhrlpyfymwu",
    "description": "parses KeyValueMarkdownModelType into a string which can be part of a new markdown file\n\nNB: we need to know the previous line as well because the header we need to print depends on it",
    "operationName": "key-value-markdown-js",
    "rawText": " (\n  kvmdData: KeyValueMarkdownModelType,\n  previous: KeyValueMarkdownModelType | undefined\n) => {\n  // headers only need a newline before it if it's not the first item (so there is a previous)\n  const newlineIfHeader = kvmdData.isHeaderCalculated && !!previous ? \"\\n\" : \"\";\n\n  const level = kvmdData.isHeaderCalculated\n    ? kvmdData.categoryStack.length + 1\n    : 0;\n\n  const headerPrefix = kvmdData.isHeaderCalculated\n    ? \"#\".repeat(level).concat(\" \")\n    : \"\";\n\n  const isFirstItem =\n    !kvmdData.isHeaderCalculated && previous?.isHeaderCalculated;\n  const itemPrefix = isFirstItem ? \"\\n\" : \"\";\n\n  const line = `${newlineIfHeader}${headerPrefix}${itemPrefix}${\n    kvmdData.name ? `${kvmdData.name}: ` : \"\"\n  }${kvmdData.value || \"\"}${\n    kvmdData.comment ? ` <!-- ${kvmdData.comment} -->` : \"\"\n  }\\n`;\n\n  return line;\n}"
  },
  "kvmdParseToMarkdownString": {
    "name": "kvmdParseToMarkdownString",
    "slug": "TsFunction",
    "id": "qgvupdoyofmixeyzkzvuenug",
    "description": "parses KeyValueMarkdownParse into a markdown string so it can be saved as a markdown file",
    "operationName": "key-value-markdown-js",
    "rawText": " (\n  keyValueMarkdownParse: KeyValueMarkdownParse\n) => {\n  const frontmatterString = frontmatterParseToString(\n    keyValueMarkdownParse.parameters\n  );\n\n  //2 go over every row, and parse it back into the line\n  const result = keyValueMarkdownParse.data\n    .map((kvmdData, index) => {\n      const previous: KeyValueMarkdownModelType | undefined =\n        keyValueMarkdownParse.data[index - 1];\n      const string = kvmdDataToString(kvmdData, previous);\n      return string;\n    })\n    .join(\"\");\n\n  return `${frontmatterString}${result}`;\n}"
  },
  "markdownStringToKvmdParse": {
    "name": "markdownStringToKvmdParse",
    "slug": "TsFunction",
    "id": "yffysdmqtcqqnqbmvvjwdect",
    "description": "parses a key value md string (with support for headings and frontmatter)",
    "operationName": "key-value-markdown-js",
    "rawText": " (\n  kvMdString: string,\n  dbFileLocation: DbFileLocation\n): KeyValueMarkdownParse => {\n  const { parameters, content } = mdToJsonParse(kvMdString);\n  const { absolutePath, modelName, ...modelLocation } = dbFileLocation;\n\n  const parentKey = `parent_${camelCase(modelName)}Slug`;\n\n  if (!content) {\n    console.log(\"NO CONTENT FOUND\");\n    return { parameters: {}, data: [] };\n  }\n\n  const kvmdItems = content\n    .map((chunk) => getKvmdItemsRecursively(chunk))\n    .flat();\n\n  const data: KeyValueMarkdownModelType[] = kvmdItems.map((x) => ({\n    ...x,\n    ...modelLocation,\n    // NB: here we set the reference to its parent (which is equal to the last item in the categoryStack)\n    [parentKey]: x.categoryStack[x.categoryStack.length - 1],\n  }));\n\n  return { parameters, data };\n}"
  },
  "parseKvmdLine": {
    "name": "parseKvmdLine",
    "slug": "TsFunction",
    "id": "rkifxfjtrwosyuygbctazude",
    "description": "parses a kv md line with data into a key, value, and comment (if available)\n\nif the key is an empty string, the line will return undefined",
    "operationName": "key-value-markdown-js",
    "rawText": " (string: string): KvmdLine | undefined => {\n  const htmlCommentRegex = /<!--[\\s\\S]*?-->/g;\n  const lineWithoutComment = string.replace(htmlCommentRegex, \"\");\n\n  const commentMatch = string.match(htmlCommentRegex)?.[0];\n  const comment = commentMatch\n    ? commentMatch.replace(\"<!--\", \"\").replace(\"-->\", \"\").trim()\n    : null;\n\n  const [keyString, valueString] = lineWithoutComment\n    .split(\":\")\n    .map((x) => x.trim());\n\n  const value = valueString?.length ? valueString : undefined;\n  const slug = slugify(keyString);\n\n  if (keyString.length === 0) return;\n\n  return {\n    id: slug,\n    name: keyString,\n    value,\n    comment,\n    slug,\n  };\n}"
  },
  "LabeledButton": {
    "name": "LabeledButton",
    "slug": "TsFunction",
    "id": "jkshyipulilupqmyemkdgtvz",
    "description": "",
    "operationName": "labeled-button",
    "rawText": " (button: LabeledButtonType, index: number) => {\n  const size = button.size === \"small\" ? 12 : 24;\n  const heightClass = button.size === \"small\" ? \"h-4\" : \"h-7\";\n  const textSizeClass = button.size === \"small\" ? \"text-xs\" : \"text-xl\";\n  return (\n    <Button\n      key={`labeledbutton${index}`}\n      className={`flex flex-col items-center`}\n      onClick={button.onClick}\n    >\n      <Div\n        className={`w-10 ${\n          button.isActive ? \"bg-blue-900 dark:bg-blue-600 rounded-full\" : \"\"\n        }`}\n      >\n        {button.icon ? (\n          <Svg src={button.icon} width={size} height={size} />\n        ) : button.emoji ? (\n          <P className={`${textSizeClass} hover:scale-110`}>{button.emoji}</P>\n        ) : button.component ? (\n          <Div className={heightClass}>{button.component()}</Div>\n        ) : null}\n      </Div>\n      {button.size === \"small\" ? null : (\n        <P className=\"text-xs\">{button.title}</P>\n      )}\n    </Button>\n  );\n}"
  },
  "AuthenticationLayout": {
    "name": "AuthenticationLayout",
    "slug": "TsFunction",
    "id": "phgfdcnhgqendkidcsmoqjuw",
    "description": "Layout that includes default pages and header for authentication",
    "operationName": "layout",
    "rawText": " (props: {\n  /**\n   * If given, menu will be rendered\n   */\n  menu?: MenuProps;\n\n  overwriteDefaultPages?: string[];\n  customHeader?: React.ReactNode;\n  custom404Page?: React.ReactNode;\n  // how to build up the menu\n\n  // typed as any needed because of react-bug\n  nextPage?: any;\n  pageProps?: any;\n}) => {\n  const publicBundleConfig = queries.useGetPublicBundleConfig().data?.result;\n  const {\n    nextPage,\n    pageProps,\n    menu,\n    customHeader,\n    custom404Page,\n    overwriteDefaultPages,\n  } = props;\n  const router = useRouter();\n  const path = router.asPath.substring(1).split(\"?\")[0];\n\n  const pages: { [key: string]: (props?: any) => JSX.Element } = {\n    login: LoginForm,\n    signup: SignupForm,\n    \"edit-profile\": UpdateMeForm,\n    profile: PublicProfile,\n    \"2fa\": AuthenticationMethodsCrud,\n  };\n\n  const NextPage = nextPage;\n\n  // seems unneeded\n\n  // const hasQueryPath = !!menu?.queryPaths?.includes(path);\n  // const hasWebPage = !!menu?.webPagesFlat?.find((x) => x.queryPath === path);\n\n  // const hasWebPageInThisFolder = !!menu?.webPagesFlat?.find((x) =>\n  //   x.queryPath.startsWith(path)\n  // );\n\n  // const shouldRenderCustom =\n  //   hasQueryPath || hasWebPage || path === \"\" || hasWebPageInThisFolder;\n\n  const DefaultPage = pages[path] ? pages[path] : undefined;\n\n  const children =\n    DefaultPage && !overwriteDefaultPages?.includes(path) ? (\n      <DefaultPage />\n    ) : (\n      <NextPage {...pageProps} />\n    );\n\n  const header = (\n    <Div>\n      {customHeader !== undefined ? (\n        customHeader\n      ) : (\n        <Header publicBundleConfig={publicBundleConfig} />\n      )}\n    </Div>\n  );\n\n  return (\n    <LoginWrapper>\n      <LayoutGrid header={header} menu={menu}>\n        {children}\n      </LayoutGrid>\n    </LoginWrapper>\n  );\n}"
  },
  "Header": {
    "name": "Header",
    "slug": "TsFunction",
    "id": "dexmgkfzargymyisxsxkgaph",
    "description": "",
    "operationName": "reader-ui",
    "rawText": " (props: {\n  publicBundleConfig?: PublicBundleConfig | null;\n}) => {\n  const [isMobileMenuEnabled, setIsMobileMenuEnabled] = useStore(\n    \"menu.isMobileMenuEnabled\"\n  );\n  const { publicBundleConfig } = props;\n  const title =\n    publicLocalEnvironmentVariables.markdownReaderTitle ||\n    publicEnvironmentVariables.markdownReaderTitle ||\n    publicBundleConfig?.name;\n\n  return (\n    <Div\n      style={{\n        backgroundColor: props.publicBundleConfig?.primaryColor,\n        justifyContent: \"space-between\",\n        display: \"flex\",\n        flexDirection: \"row\",\n        alignItems: \"center\",\n      }}\n    >\n      <ALink\n        href={\n          typeof window !== \"undefined\"\n            ? location.protocol + \"//\" + location.host\n            : \"#\"\n        }\n        style={{ fontSize: 32 }}\n      >\n        {props.publicBundleConfig?.emoji}\n      </ALink>\n\n      <Div>\n        <P className=\"font-bold text-white \">{title}</P>\n        <P className=\"text-xs text-white italic\">\n          {props.publicBundleConfig?.description}\n        </P>\n      </Div>\n\n      <Div className=\"flex flex-row\">\n        <Div className=\"lg:hidden\">\n          <ClickableIcon\n            emoji=\"🔍\"\n            onClick={() => setIsMobileMenuEnabled(!isMobileMenuEnabled)}\n          />\n        </Div>\n        {props.publicBundleConfig?.isGitRepoPublic &&\n        props.publicBundleConfig.gitRepoUrl ? (\n          <ALink target=\"_blank\" href={props.publicBundleConfig.gitRepoUrl}>\n            GitHub\n          </ALink>\n        ) : null}\n      </Div>\n    </Div>\n  );\n}"
  },
  "LayoutGrid": {
    "name": "LayoutGrid",
    "slug": "TsFunction",
    "id": "pmbruadjkwcexkhqjnskixhv",
    "description": "Style for creating a grid for the layout that is mobile friendly and has menu support\n\n\n\nI run into this problem all the time\n\nhttps://stackoverflow.com/questions/71616561/css-tailwind-grid-height-100vh-not-working\n\nfinal solution came from here\n\nhttps://stackoverflow.com/questions/47094742/fullscreen-flex-layouts-necessity-of-intermediate-flex-boxes\n\nUnfortunately, I can't seem to hide stuff anymore for some reason on non-mobile. \"lg:flex hidden\" just doesn't work, just hides!\n\nMy elegant solution was to just use visible/invisible and make the mobile layout hover over the invisible one in case of a small screen, it works!",
    "operationName": "layout",
    "rawText": " (props: {\n  children: React.ReactNode;\n  header: React.ReactNode;\n  /**\n   * Menu is only rendered if you pass it here\n   */\n  menu?: MenuProps;\n}) => {\n  const { children, header, menu } = props;\n\n  const [isMobileMenuEnabled] = useStore(\"menu.isMobileMenuEnabled\");\n\n  const renderMenu = () => {\n    return menu ? <Menu {...menu} message={undefined} /> : null;\n  };\n\n  return (\n    <main className=\"dark:bg-zinc-900 dark:text-white relative\">\n      {/* mobile layout */}\n      <Div className=\"lg:invisible absolute overflow-y-scroll top-0 left-0 w-screen h-screen\">\n        {header}\n        {isMobileMenuEnabled ? <Div>{renderMenu()}</Div> : children}\n      </Div>\n\n      {/* Big screen layout */}\n      <Div\n        className={`w-screen h-screen flex flex-1 invisible lg:visible flex-col`}\n      >\n        {header}\n\n        <Div\n          className={`h-full overflow-hidden flex-1 flex ${\n            menu?.menuPosition === \"left\" ? \"flex-row-reverse\" : \"flex-row\"\n          }`}\n        >\n          <Div className=\"min-h-0 overflow-y-scroll w-full h-full inline-block\">\n            {children}\n          </Div>\n          {menu ? (\n            <Div className=\"inline-block min-h-0 overflow-y-scroll h-full w-80\">\n              {renderMenu()}\n            </Div>\n          ) : null}\n        </Div>\n      </Div>\n    </main>\n  );\n}"
  },
  "PingApi": {
    "name": "PingApi",
    "slug": "TsFunction",
    "id": "nidfvhinolxcwlfzqfuwdalj",
    "description": "",
    "operationName": "layout",
    "rawText": " () => {\n  const [isOffline, setIsOffline] = useState(false);\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      getItem(API_NO_RESPONSE_TIME_KEY).then((value) => {\n        if (!value) {\n          if (isOffline) {\n            setIsOffline(false);\n            return;\n          }\n        }\n\n        const lastNoResponse = Number(value);\n        const timeAgo = Date.now() - lastNoResponse;\n        if (timeAgo < timeBeforeNotOffline && isOffline) {\n          setIsOffline(false);\n        } else {\n          setIsOffline(true);\n        }\n      });\n    }, 1000);\n\n    return () => clearInterval(intervalId);\n  }, []);\n\n  return (\n    <Div className=\"mx-4\">\n      <ALink href=\"/settings\">{isOffline ? \"🔺\" : \"💚\"} API</ALink>\n    </Div>\n  );\n}"
  },
  "timeBeforeNotOffline": {
    "name": "timeBeforeNotOffline",
    "slug": "TsVariable",
    "id": "vlziqbdlnovixhwwqkgllghu",
    "description": "",
    "operationName": "layout"
  },
  "preIndexLint": {
    "name": "preIndexLint",
    "slug": "TsFunction",
    "id": "qtmeennvmnbapyxzpapdutlz",
    "description": "Should be a collection of small functions that check if all conventions are used and if there isn't used anything that should NOT be used. this can later become a linter. make sure to research how eslint works first\n\nPlan:\n\n1) just use my own sdk's as much as possible to provide some handy convention checks in a package\n2) later integrate this into vscode, i'm sure this is how it's done\n\nthis lint can be done before indexation",
    "operationName": "lint",
    "rawText": " async ({\n  operationFolderPath,\n}: {\n  operationFolderPath: string;\n}) => {\n  const problems: string[] = [];\n\n  const packageJson = await getPackageJson({ operationFolderPath });\n  if (!packageJson) {\n    problems.push(\"package.json should exist\");\n  } else {\n    if (!packageJson.name) {\n      problems.push(\"package.json needs a name\");\n    }\n    if (!packageJson.version) {\n      problems.push(\"package.json needs a version\");\n    }\n  }\n\n  const tsConfig = await getTsConfig(operationFolderPath);\n  if (!tsConfig) {\n    problems.push(\"tsconfig.json should exist\");\n  } else {\n    // we can lint tsconfig here too\n  }\n\n  const operationFolderName = getLastFolder(operationFolderPath);\n\n  if (operationFolderName !== packageJson?.name) {\n    problems.push(\n      \"operation folder should have the same name as the package.json name\"\n    );\n  }\n\n  return problems;\n}"
  },
  "maximumLockTime": {
    "name": "maximumLockTime",
    "slug": "TsVariable",
    "id": "bojoubynxccimvrtbskerxhb",
    "description": "",
    "operationName": "lock-system"
  },
  "isLocked": {
    "name": "isLocked",
    "slug": "TsFunction",
    "id": "wtonphzhogrbbmynivithhyo",
    "description": "",
    "operationName": "lock-util",
    "rawText": " (absolutePath: string) => {\n  const parsedPath = path.parse(absolutePath);\n  const potentialLockFilePath = path.join(\n    parsedPath.dir,\n    `${parsedPath.name}.lock`\n  );\n\n  if (fs.existsSync(potentialLockFilePath)) {\n    const lock = readJsonFileSync<LockInfo>(potentialLockFilePath);\n\n    // there's a lockfile\n    if (lock?.updatedAt && Date.now() - lock.updatedAt < maximumLockTime) {\n      // status has recently enough been updated\n      return true;\n    }\n  }\n  return false;\n}"
  },
  "lock": {
    "name": "lock",
    "slug": "TsFunction",
    "id": "louizclyvudhizgwkmbhmbwk",
    "description": "either creates the lockfile if it didn't exist or it will update it with new updatedAt and status. If status isn't set, status will be removed",
    "operationName": "lock-util",
    "rawText": " async (\n  aboluteLockableFilePath: string,\n  status?: string\n) => {\n  const parsedPath = path.parse(aboluteLockableFilePath);\n  const lockFilePath = path.join(parsedPath.dir, `${parsedPath.name}.lock`);\n\n  await writeJsonToFile<LockInfo>(lockFilePath, {\n    status: status || \"busy\",\n    updatedAt: Date.now(),\n  });\n}"
  },
  "unlock": {
    "name": "unlock",
    "slug": "TsFunction",
    "id": "rxobrpyvgbahyxsalgifzsad",
    "description": "NB: don't provide the path to the lockfile but the path to the file that the lock should be removed from",
    "operationName": "lock-util",
    "rawText": " (aboluteLockedFilePath: string) => {\n  return fs.rm(aboluteLockedFilePath);\n}"
  },
  "DEBUG": {
    "name": "DEBUG",
    "slug": "TsVariable",
    "id": "eclyttivmibxqomkjbjxuvmc",
    "description": "if true, also shows debug messages",
    "operationName": "log"
  },
  "getCallerFileName": {
    "name": "getCallerFileName",
    "slug": "TsFunction",
    "id": "qzhjicvbtknafbqdusqdtwrt",
    "description": "TODO: this is great. now also get the operationName. If the operationName appears in the config, for debug, show the log, otherwise don't show",
    "operationName": "log",
    "rawText": " () => {\n  const stack = new Error().stack;\n  if (!stack) return;\n\n  // console.log(\"Complete stack\", stack);\n  const firstRelevantLine = stack.split(\"\\n\")[3];\n  if (!firstRelevantLine) return;\n\n  const jsFilePath = firstRelevantLine.split(\"at \")[1].split(\":\")[0];\n\n  if (!jsFilePath) return;\n\n  const srcPath = jsFilePath.replace(\"/build/\", \"/src/\").replace(\".js\", \".ts\");\n\n  return srcPath;\n}"
  },
  "log": {
    "name": "log",
    "slug": "Operation",
    "id": "utIDjwWGsHDpuZby",
    "operationName": "log"
  },
  "options": {
    "name": "options",
    "slug": "TsVariable",
    "id": "olyfxvyfoimbrbfpefllotsb",
    "description": "special character combinations that make the console message be printed differently",
    "operationName": "log"
  },
  "parseTitle": {
    "name": "parseTitle",
    "slug": "TsFunction",
    "id": "nsbqwoxiitnmhyoojcxcszyn",
    "description": "TODO: Should parse a title from markdown",
    "operationName": "log",
    "rawText": " (markdown: string) => {\n  const sentences = markdown\n    .split(\"\\n\")\n    .map((x) => x.split(\".\"))\n    .flat();\n\n  const [title, ...rest] = sentences;\n\n  return { title, rest: rest.filter((x) => x.length > 0).join(\"\\n\") };\n}"
  },
  "resetString": {
    "name": "resetString",
    "slug": "TsVariable",
    "id": "nlkfxatmkoekvizjudgmcepn",
    "description": "",
    "operationName": "log"
  },
  "sendMail": {
    "name": "sendMail",
    "slug": "TsFunction",
    "id": "rflwyhgipnummiamgjktcmom",
    "description": "Sends email(s) using sendgrid\n\nEnsure your OS config is there",
    "operationName": "mail",
    "rawText": " async (\n  mailData: MailDataFromOptional | MailDataFromOptional[],\n  isMultiple?: boolean\n): Promise<ClientResponse | undefined> => {\n  const persona = await getPrimaryPersona();\n\n  if (!persona) {\n    return;\n  }\n\n  const { sendgridApiKey, sendgridFromEmail } = persona;\n\n  if (!sendgridApiKey) {\n    console.log(\"Please setup your Sendgrid credentials first\");\n    return;\n  }\n\n  const realMailData: MailDataRequired[] = makeArray(mailData)\n    .map((data) => {\n      const { from: dataFrom, ...otherData } = data;\n\n      const from = dataFrom || sendgridFromEmail;\n\n      if (!from) {\n        console.log(\n          \"From is missing in email and also not present in OsConfig. Please provide at least one of those. Not sending email!\"\n        );\n        return;\n      }\n\n      // NB: it's a bit ugly, but doesn't work without typecast, and i'm pretty sure the type is correct...\n      const mailData = { from, ...otherData } as MailDataRequired;\n\n      return mailData;\n    })\n    .filter(notEmpty);\n\n  sgMail.setApiKey(sendgridApiKey);\n\n  const result = await sgMail\n    .send(realMailData, isMultiple)\n    .then(([result]) => {\n      return result;\n    })\n    .catch((error: ResponseError) => {\n      console.log(\"Error sending email\", { error });\n\n      return undefined;\n    });\n\n  return result;\n}"
  },
  "makeFileType": {
    "name": "makeFileType",
    "slug": "TsFunction",
    "id": "gjuumjwmkirwmjapohohpmhc",
    "description": "",
    "operationName": "make-file-type",
    "rawText": " async (\n  filePath: string\n): Promise<FileType | undefined> => {\n  const exists = fs.existsSync(filePath);\n  const stats = exists ? await fs.stat(filePath) : null;\n  const mtime_ms = stats?.mtimeMs || 0;\n\n  const operationBasePath = findOperationBasePath(filePath);\n  if (!operationBasePath) return;\n  const operationSrcPath = path.join(operationBasePath, \"src\");\n  const relativePath = filePath.slice(operationSrcPath.length);\n  const name = relativePath;\n  // should not only be name, but also the relative path from src/*\n  // const parsedPath = path.parse(filePath);\n  //const name = `${parsedPath.name}${parsedPath.ext}`;\n\n  const size = stats?.size || 0;\n  const type = \"f\";\n  const file: FileType = { exists, mtime_ms, name, size, type };\n  return file;\n}"
  },
  "isResultOfInterface": {
    "name": "isResultOfInterface",
    "slug": "TsFunction",
    "id": "deunzrbudderslyhtqclhayc",
    "description": "TODO: need validate-json-schema. also this can be its own little package, as it can be used in many other places\n\nnot sure if this should be part of make-test at all, because we want operations to be able to operate independently without the os, right? so then it won't work because you don't always have indexes...",
    "operationName": "make-test",
    "rawText": " <TResult>(\n  result: TResult,\n  jsonSchema: JSONSchema\n): boolean => {\n  return true;\n}"
  },
  "makeTest": {
    "name": "makeTest",
    "slug": "TsFunction",
    "id": "ywhmswjczsfjkwrtqikpnryq",
    "description": "create a test that is testable with `runAllTests`...",
    "operationName": "make-test",
    "rawText": " <TResult>(\n  /**\n   * callback that calls the function to test with a certain input\n   */\n  testFunction: (() => Promise<TResult>) | (() => TResult),\n  /** If not given, assumes it passes if it returns the type interface it says it returns (and it doesn't crash) */\n  isValid?: (result: TResult) => boolean\n) => {\n  // NB: don't execute the test immideately, so we return a callback that actually tests\n  return async () => {\n    // try because funning the test may crash the app if the function doesn't work properly\n    try {\n      // TODO: what's the difference between TResult and Awaited<TResult>?\n      const result: TResult = await testFunction();\n\n      /**\n       * TODO:\n       */\n      const shouldBeInterface = {};\n\n      const correctInterface = isResultOfInterface(result, shouldBeInterface);\n      const isResultValid = isValid\n        ? correctInterface && isValid(result)\n        : correctInterface;\n\n      if (!isResultValid) {\n        console.dir(\n          {\n            response: `❌ TEST FAILED`,\n            test: testFunction.toString(),\n            result,\n          },\n          { depth: 999 }\n        );\n      } //\n\n      return isResultValid;\n    } catch (error) {\n      // TODO: check if toString here returns the right thing (a string representation of the function to test). otherwise, find a different solution.\n      console.log(`❌ TEST FAILED: ${testFunction.toString()}`, error);\n      return false;\n    }\n  };\n}"
  },
  "defaultExpandedMode": {
    "name": "defaultExpandedMode",
    "slug": "TsVariable",
    "id": "spmzsadnoqldvwuetbejvxeu",
    "description": "",
    "operationName": "markdown"
  },
  "defaultMinimalMode": {
    "name": "defaultMinimalMode",
    "slug": "TsVariable",
    "id": "wycnpqqvgckpealqtzyxasqa",
    "description": "",
    "operationName": "markdown"
  },
  "getRealSrc": {
    "name": "getRealSrc",
    "slug": "TsFunction",
    "id": "sbzgjvsmfopidmjcettyrgxm",
    "description": "Based on markdown info, gest the real source for an asset",
    "operationName": "markdown",
    "rawText": " (\n  src: string | undefined,\n  config: MarkdownParseRenderConfig\n) => {\n  // src from static folder of next.js\n  const relativeUrlStrategy =\n    config.isDev || !config.isStatic ? \"api\" : \"static\";\n\n  if (!src) return undefined;\n\n  if (\n    isPathRelative(src) &&\n    config.projectRelativeBaseFolderPath &&\n    config.projectRelativeMarkdownFilePath\n  ) {\n    return getUrlFromRelativeUrl(\n      src,\n      relativeUrlStrategy,\n      config.projectRelativeBaseFolderPath,\n      config.projectRelativeMarkdownFilePath\n    );\n  }\n\n  return src;\n}"
  },
  "getUrlFromRelativeUrl": {
    "name": "getUrlFromRelativeUrl",
    "slug": "TsFunction",
    "id": "vnyxtvuqfpsbfyhhqyiukrky",
    "description": "gets the renderable asset url from the relative url",
    "operationName": "markdown",
    "rawText": " (\n  relativeUrl: string,\n  relativeUrlStrategy: \"api\" | \"static\",\n  projectRelativeBaseFolderPath: string,\n  projectRelativeMarkdownFilePath: string\n) => {\n  if (relativeUrlStrategy === \"static\")\n    return path.join(projectRelativeBaseFolderPath, relativeUrl);\n\n  const relativeUrlWithoutStart = relativeUrl.slice(2);\n\n  return getReferencedAssetApiUrl(\n    apiUrl,\n    projectRelativeMarkdownFilePath,\n    relativeUrlWithoutStart\n  );\n}"
  },
  "getYoutubeId": {
    "name": "getYoutubeId",
    "slug": "TsFunction",
    "id": "gorgenmuibireionncprpwlr",
    "description": "",
    "operationName": "markdown",
    "rawText": " (url: string | undefined): string | undefined => {\n  if (!url) return;\n\n  const regExp =\n    /^.*(youtu.be\\/|v\\/|u\\/\\w\\/|embed\\/|watch\\?v=|\\&v=|\\?v=)([^#\\&\\?]*).*/;\n  const match = url.match(regExp);\n\n  if (match && match[2].length == 11) {\n    return match[2];\n  }\n  return;\n}"
  },
  "HtmlHeader": {
    "name": "HtmlHeader",
    "slug": "TsFunction",
    "id": "rurxrlepbabzynzherauzele",
    "description": "",
    "operationName": "markdown",
    "rawText": " ({ level, children }) => {\n  const levelSize =\n    level === 1\n      ? \"text-3xl\"\n      : level === 2\n      ? \"text-2xl\"\n      : level === 3\n      ? \"text-xl\"\n      : level === 4\n      ? \"text-lg\"\n      : level === 5\n      ? \"text-md\"\n      : level === 6\n      ? \"text-sm\"\n      : \"text-xs\";\n  // {...props\n  return (\n    <Div id={getImplicitId(String(children))} className={levelSize}>\n      {children}\n    </Div>\n  );\n}"
  },
  "MarkdownCodeblock": {
    "name": "MarkdownCodeblock",
    "slug": "TsFunction",
    "id": "gdglwbvyxofoxsugjqhrutqq",
    "description": "Renders a markdown codeblock with a text as content and an optional extension",
    "operationName": "markdown",
    "rawText": " (props: {\n  /**\n   * STRING! don't put a JSON object here,  first use JSON.stringify!\n   */\n  text: string;\n  extension?: string;\n  /**\n   * If set, this is the mode when minimised\n   */\n  minimalMode?: CodeblockMode;\n  /**\n   * If set, this is the mode when expanded\n   */\n  expandedMode?: CodeblockMode;\n  /**\n   * if true, by default it's expanded\n   */\n  isInitiallyExpanded?: boolean;\n  /**\n   * if true, mode cannot be changed\n   */\n  isModeStatic?: boolean;\n}) => {\n  const {\n    text,\n    extension,\n    expandedMode,\n    isInitiallyExpanded,\n    minimalMode,\n    isModeStatic,\n  } = props;\n\n  const [isExpanded, setIsExpanded] = useState(isInitiallyExpanded);\n\n  const mode = isExpanded\n    ? expandedMode || defaultExpandedMode\n    : minimalMode || defaultMinimalMode;\n\n  const realText =\n    mode === \"preview\"\n      ? text.length > 200\n        ? text.slice(0, 198) + \"..\"\n        : text\n      : text;\n\n  const nothingToExpand = mode === \"preview\" && text === realText;\n  return (\n    <Div className=\"w-full\">\n      {isModeStatic ? null : nothingToExpand ? null : (\n        <Div>\n          <ClickableIcon\n            onClick={() => {\n              setIsExpanded(!isExpanded);\n            }}\n            emoji={isExpanded ? \"➖ Minimise\" : \"➕ Expand\"}\n          />\n        </Div>\n      )}\n\n      <Div\n        className={\n          mode === \"scroll\"\n            ? \"overflow-y-auto max-h-[60vh] max-w-[60vw]\"\n            : mode === \"preview\"\n            ? \"opacity-25 bg-black\"\n            : undefined\n        }\n      >\n        {renderMarkdownContent(\n          createCodeblockMarkdown(realText, extension || null),\n          // The config below is not needed since all that is renderedd is a codeblock, which doesn't need to render links etc.\n          {\n            projectRelativeBaseFolderPath: \"\",\n            projectRelativeMarkdownFilePath: \"\",\n          }\n        )}\n      </Div>\n    </Div>\n  );\n}"
  },
  "MarkdownContentRender": {
    "name": "MarkdownContentRender",
    "slug": "TsFunction",
    "id": "qcfwaiqobinzkezgzyescjjo",
    "description": "",
    "operationName": "markdown",
    "rawText": " (props: {\n  content: string;\n  config: MarkdownParseRenderConfig;\n}) => {\n  const { config, content } = props;\n\n  const markdownRender = (\n    <ReactMarkdown\n      className={config?.big ? \"max-w-lg\" : undefined}\n      rehypePlugins={[rehypeHighlight, remarkGfm, rehypeRaw]}\n      components={{\n        h1: HtmlHeader,\n        h2: HtmlHeader,\n        h3: HtmlHeader,\n        h4: HtmlHeader,\n        h5: HtmlHeader,\n        h6: HtmlHeader,\n\n        img: ({ src, alt }) => {\n          if (!src) return <Div>Bad asset src</Div>;\n          const isRelative = isPathRelative(src);\n          if (isRelative && !config.projectRelativeMarkdownFilePath) {\n            // We can't show the asset in this scenario\n            return (\n              <P>\n                ![${alt}](${src})\n              </P>\n            );\n          }\n\n          const url = isRelative ? undefined : src;\n          const relativePath = isRelative ? src : undefined;\n          const asset: Asset = { alt, relativePath, absoluteUrl: url };\n\n          return (\n            <AssetView\n              asset={asset}\n              projectRelativeReferencingFilePath={\n                config.projectRelativeMarkdownFilePath\n              }\n              hideDownloadLink\n              className=\"w-96\"\n            />\n          );\n        },\n        //Fix newlines with `<br>`\n        br: ({ node, ...props }: any) => (\n          // @ts-ignore\n          <br {...props} />\n        ),\n\n        details: ({ node, ...props }) => {\n          return (\n            // @ts-ignore\n            <details\n              className=\"group border border-gray-600 rounded-lg\"\n              {...props}\n            />\n          );\n        },\n\n        summary: ({ node, ...props }: any) => {\n          return (\n            // @ts-ignore\n            <summary\n              className=\"bg-gray-200 dark:bg-gray-700 p-2 rounded-lg group-open:rounded-b-none group-open:border group-open:border-b-gray-600 select-none\"\n              {...props}\n            />\n          );\n        },\n\n        td: ({ node, children, ...props }: any) => {\n          return (\n            // @ts-ignore\n            <td\n              className=\"border-spacing-1 border-t border-r last:border-r-0 border-gray-600 dark:border-gray-100 p-2\"\n              {...props}\n            >\n              {children?.map((child: any) =>\n                child === \"<br />\" ? <br /> : child\n              )}\n            </td>\n          );\n        },\n        th: ({ node, ...props }) => (\n          // @ts-ignore\n          <th className=\"\" {...props} />\n        ),\n\n        table: ({ node, ...props }) => (\n          // @ts-ignore\n          <div className=\"inline-block rounded-lg border shadow-2xl\">\n            <table className=\"\" {...props} />\n          </div>\n        ),\n\n        tbody: ({ node, ...props }) => (\n          // @ts-ignore\n          <tbody className=\"border-gray-600 dark:border-gray-100\" {...props} />\n        ),\n\n        tr: ({ node, ...props }) => (\n          // @ts-ignore\n          <tr\n            className=\"dark:even:bg-black even:bg-gray-400 even:bg-opacity-30\"\n            {...props}\n          />\n        ),\n\n        ol: ({ node, ...props }: any) => (\n          <ol className=\"list-decimal mx-3 p-2\" {...props} />\n        ),\n        ul: ({ node, ...props }: any) => (\n          <ul\n            style={{ listStyleType: \"circle\" }}\n            className=\"mx-3 p-2\"\n            {...props}\n          />\n        ),\n\n        p: ({ node, ...props }) => {\n          // TODO: make this work for components as well, now only works if the children of p is raw text...\n          // const text = makeArray(props.children)\n          //   .map((x) => {\n          //     if (typeof x === \"string\" || typeof x === \"number\") {\n          //       return String(x);\n          //     }\n          //     return undefined;\n          //   })\n          //   .filter(notEmpty)\n          //   .join(\"\");\n\n          // const selectionResultsThisParagraph =\n          //   config.selectionContextualPromptResults?.filter((x) =>\n          //     x.selectionString ? text.includes(x.selectionString) : false\n          //   );\n\n          return (\n            <p\n              style={{\n                marginTop: 15,\n                marginBottom: 15,\n                whiteSpace: \"pre-line\",\n              }}\n              {...props}\n            />\n          );\n\n          // <>\n\n          {\n            /* {selectionResultsThisParagraph?.map((result) => {\n                return (\n                  <Div key={`result-${result.id}`}>\n                    {result.contextualPromptSlug}: {result.resultText}{\" \"}\n                    (selection: {result.selectionString})\n                  </Div>\n                );\n              })} */\n          }\n          {\n            /* </> */\n          }\n        },\n        li: ({ node, ...props }: any) => <li className=\"\" {...props} />,\n\n        code: ({ node, children, ...props }) => {\n          // NB: There's a big problem with this because all code elements get put in a `<pre>` element. I don't think this is easy to remove, but we can look in the issues. we can also look in google for how to improve it with css because i couldn't figure it out myself\n          const word: React.ReactNode | string = children[0];\n\n          const wordString: string | undefined =\n            typeof word === \"string\" ? word : undefined;\n\n          return wordString?.startsWith(\".\") ? (\n            <Parameter text={wordString} />\n          ) : (\n            <code\n              className=\"dark:bg-gray-700\"\n              {...props}\n              style={{\n                color: \"darkcyan\",\n                // NB: the below doesn't work!\n                wordBreak: \"break-all\",\n                wordWrap: \"break-word\",\n              }}\n            >\n              {children}\n            </code>\n          );\n        },\n        a: ({ node, href, title, ...props }) => {\n          const youtubeId = getYoutubeId(href);\n          if (youtubeId) {\n            return (\n              <iframe\n                className=\"aspect-video w-full\"\n                src={`https://www.youtube.com/embed/${youtubeId}`}\n                title=\"Youtube vid\"\n                frameBorder=\"0\"\n                allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n                allowFullScreen\n              ></iframe>\n            );\n          }\n          return (\n            <Tooltip\n              placement=\"left\"\n              tooltip={\n                title ? (\n                  <div className=\"px-3\">\n                    <MarkdownContent content={title} config={{}} />\n                  </div>\n                ) : null\n              }\n            >\n              <a\n                className=\"dark:text-blue-200 text-blue-500\"\n                href={href}\n                {...props}\n              />\n            </Tooltip>\n          );\n        },\n      }}\n    >\n      {content}\n    </ReactMarkdown>\n  );\n\n  return markdownRender;\n}"
  },
  "MarkdownContent": {
    "name": "MarkdownContent",
    "slug": "TsFunction",
    "id": "dhuhqmtsezafwbvedwredrje",
    "description": "Renders a markdown string (without frontmatter)",
    "operationName": "markdown",
    "rawText": " (props: {\n  content: string;\n  config: MarkdownParseRenderConfig;\n}): JSX.Element => {\n  const { config, content } = props;\n\n  if (!content) return <Div>No content</Div>;\n\n  return <MarkdownContentRender content={content} config={config} />;\n}"
  },
  "Parameter": {
    "name": "Parameter",
    "slug": "TsFunction",
    "id": "qhvhqoukugjesphiwootmtgj",
    "description": "In markdown, if you wish to refer to a parameter, you can backtick it and put a \".\" in front. You can also add a value to it if you wish, by adding the \":\" and the value afterwards.",
    "operationName": "markdown",
    "rawText": " (props: { text: string }) => {\n  const { text } = props;\n  if (!text) return null;\n  const [parameter, value] = text\n    .slice(1)\n    .split(\":\")\n    .map((x) => x.trim());\n  return (\n    <Span className=\"rounded-md bg-purple-400 dark:bg-purple-800 px-1\">\n      {parameter ? <Span>{parameter}</Span> : null}\n      {value ? <Span className=\"bg-white bg-opacity-50\">{value}</Span> : null}\n    </Span>\n  );\n}"
  },
  "renderFrontmatter": {
    "name": "renderFrontmatter",
    "slug": "TsFunction",
    "id": "sacuhhrcmyerrnlmrdhuxgdj",
    "description": "Renders markdown frontmatter parameters (and optionally a spacer)",
    "operationName": "markdown",
    "rawText": " (\n  parameters: Frontmatter,\n  config?: { renderSpacer?: boolean }\n) => {\n  const frontMatterKeys = Object.keys(parameters);\n\n  return frontMatterKeys.length > 0 ? (\n    <Div>\n      <Div>\n        {frontMatterKeys.map((key) => (\n          <P>\n            {key}: {parameters[key]}\n          </P>\n        ))}\n      </Div>\n\n      {config?.renderSpacer ? <P>------------</P> : null}\n    </Div>\n  ) : null;\n}"
  },
  "renderMarkdownChunk": {
    "name": "renderMarkdownChunk",
    "slug": "TsFunction",
    "id": "weutkeypwjgrhgcmqinvnggv",
    "description": "renders a MarkdownChunk interface",
    "operationName": "markdown",
    "rawText": " (\n  chunk: MarkdownChunk,\n  config: MarkdownParseRenderConfig\n) => {\n  const title = chunk.title\n    ? renderMarkdownTitle(chunk.title, chunk.level)\n    : null;\n  return (\n    <Div>\n      {title}\n      {chunk.content ? renderMarkdownContent(chunk.content, config) : null}\n      {chunk.children?.map((chunk) => renderMarkdownChunk(chunk, config))}\n    </Div>\n  );\n}"
  },
  "renderMarkdownContent": {
    "name": "renderMarkdownContent",
    "slug": "TsFunction",
    "id": "usdlcjlhzgnjfrmluasujsva",
    "description": "Renders a markdown string (without frontmatter)\n\nTODO:\n\n- **Show selection prompt-results** In `renderMarkdownContent`, augment the alineas with the `ContextualPromptResult`. Would be great to see the results when hovering over the selected thing, or maybe showing it with a button, or inline, even.",
    "operationName": "markdown",
    "rawText": " (\n  content: string,\n  config: MarkdownParseRenderConfig\n): JSX.Element => {\n  if (!content) return <Div>No content</Div>;\n\n  const markdownRender = (\n    <ReactMarkdown\n      className={config?.big ? \"max-w-lg\" : undefined}\n      rehypePlugins={[rehypeHighlight, remarkGfm, rehypeRaw]}\n      components={{\n        h1: HtmlHeader,\n        h2: HtmlHeader,\n        h3: HtmlHeader,\n        h4: HtmlHeader,\n        h5: HtmlHeader,\n        h6: HtmlHeader,\n\n        img: ({ src, alt }) => {\n          if (!src) return <Div>Bad asset src</Div>;\n          const isRelative = isPathRelative(src);\n          if (isRelative && !config.projectRelativeMarkdownFilePath) {\n            // We can't show the asset in this scenario\n            return (\n              <P>\n                ![${alt}](${src})\n              </P>\n            );\n          }\n\n          const url = isRelative ? undefined : src;\n          const relativePath = isRelative ? src : undefined;\n          const asset: Asset = { alt, relativePath, absoluteUrl: url };\n\n          return (\n            <AssetView\n              asset={asset}\n              projectRelativeReferencingFilePath={\n                config.projectRelativeMarkdownFilePath\n              }\n              hideDownloadLink\n              className=\"w-96\"\n            />\n          );\n        },\n        //Fix newlines with `<br>`\n        br: ({ node, ...props }: any) => (\n          // @ts-ignore\n          <br {...props} />\n        ),\n\n        details: ({ node, ...props }) => {\n          return (\n            // @ts-ignore\n            <details\n              className=\"group border border-gray-600 rounded-lg\"\n              {...props}\n            />\n          );\n        },\n\n        summary: ({ node, ...props }: any) => {\n          return (\n            // @ts-ignore\n            <summary\n              className=\"bg-gray-200 dark:bg-gray-700 p-2 rounded-lg group-open:rounded-b-none group-open:border group-open:border-b-gray-600 select-none\"\n              {...props}\n            />\n          );\n        },\n\n        td: ({ node, children, ...props }: any) => {\n          return (\n            // @ts-ignore\n            <td\n              className=\"border-spacing-1 border-t border-r last:border-r-0 border-gray-600 dark:border-gray-100 p-2\"\n              {...props}\n            >\n              {children?.map((child: any) =>\n                child === \"<br />\" ? <br /> : child\n              )}\n            </td>\n          );\n        },\n        th: ({ node, ...props }) => (\n          // @ts-ignore\n          <th className=\"\" {...props} />\n        ),\n\n        table: ({ node, ...props }) => (\n          // @ts-ignore\n          <div className=\"inline-block rounded-lg border shadow-2xl\">\n            <table className=\"\" {...props} />\n          </div>\n        ),\n\n        tbody: ({ node, ...props }) => (\n          // @ts-ignore\n          <tbody className=\"border-gray-600 dark:border-gray-100\" {...props} />\n        ),\n\n        tr: ({ node, ...props }) => (\n          // @ts-ignore\n          <tr\n            className=\"dark:even:bg-black even:bg-gray-400 even:bg-opacity-30\"\n            {...props}\n          />\n        ),\n\n        ol: ({ node, ...props }: any) => (\n          <ol className=\"list-decimal mx-3 p-2\" {...props} />\n        ),\n        ul: ({ node, ...props }: any) => (\n          <ul\n            style={{ listStyleType: \"circle\" }}\n            className=\"mx-3 p-2\"\n            {...props}\n          />\n        ),\n\n        p: ({ node, ...props }) => {\n          // TODO: make this work for components as well, now only works if the children of p is raw text...\n          const text = makeArray(props.children)\n            .map((x) => {\n              if (typeof x === \"string\" || typeof x === \"number\") {\n                return String(x);\n              }\n              return undefined;\n            })\n            .filter(notEmpty)\n            .join(\"\");\n\n          const selectionResultsThisParagraph =\n            config.selectionContextualPromptResults?.filter((x) =>\n              x.selectionString ? text.includes(x.selectionString) : false\n            );\n\n          return (\n            <>\n              <p\n                style={{\n                  marginTop: 15,\n                  marginBottom: 15,\n                  whiteSpace: \"pre-line\",\n                }}\n                {...props}\n              />\n              {selectionResultsThisParagraph?.map((result) => {\n                return (\n                  <Div key={`result-${result.id}`}>\n                    {result.contextualPromptSlug}: {result.resultText}{\" \"}\n                    (selection: {result.selectionString})\n                  </Div>\n                );\n              })}\n            </>\n          );\n        },\n        li: ({ node, ...props }: any) => <li className=\"\" {...props} />,\n\n        code: ({ node, children, ...props }) => {\n          // NB: There's a big problem with this because all code elements get put in a `<pre>` element. I don't think this is easy to remove, but we can look in the issues. we can also look in google for how to improve it with css because i couldn't figure it out myself\n          const word: React.ReactNode | string = children[0];\n\n          const wordString: string | undefined =\n            typeof word === \"string\" ? word : undefined;\n\n          const foundWord: AugmentedWord | undefined = wordString\n            ? config?.augmentedWordObject?.[wordString]\n            : undefined;\n\n          return foundWord &&\n            foundWord.spoiler &&\n            foundWord.spoiler.length > 0 ? (\n            <Tooltip\n              placement=\"left\"\n              tooltip={\n                <>\n                  <div className=\"font-semibold px-3 mb-0 border-b border-solid border-gray-100 rounded-t-lg\">\n                    {foundWord.word}\n                  </div>\n                  <div className=\"px-3\">\n                    {renderMarkdownContent(foundWord.spoiler, {\n                      projectRelativeBaseFolderPath: getFolderJs(\n                        foundWord.projectRelativeMarkdownSourcePath\n                      )!,\n                      projectRelativeMarkdownFilePath:\n                        foundWord.projectRelativeMarkdownSourcePath,\n                    })}\n                  </div>\n                </>\n              }\n            >\n              <a\n                href={`/${foundWord?.queryPath}`}\n                style={{ color: \"darkred\" }}\n                {...props}\n              >\n                {children}\n              </a>\n            </Tooltip>\n          ) : wordString?.startsWith(\".\") ? (\n            <Parameter text={wordString} />\n          ) : (\n            <code\n              className=\"dark:bg-gray-700\"\n              {...props}\n              style={{\n                color: \"darkcyan\",\n                // NB: the below doesn't work!\n                wordBreak: \"break-all\",\n                wordWrap: \"break-word\",\n              }}\n            >\n              {children}\n            </code>\n          );\n        },\n        a: ({ node, href, ...props }) => {\n          const youtubeId = getYoutubeId(href);\n          if (youtubeId) {\n            return (\n              <iframe\n                width=\"560\"\n                height=\"315\"\n                src={`https://www.youtube.com/embed/${youtubeId}`}\n                title=\"YouTube video player\"\n                frameBorder=\"0\"\n                allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n                allowFullScreen\n              ></iframe>\n            );\n          }\n          return (\n            <a\n              className=\"dark:text-blue-200 text-blue-500\"\n              href={href}\n              {...props}\n            />\n          );\n        },\n      }}\n    >\n      {content}\n    </ReactMarkdown>\n  );\n\n  return markdownRender;\n}"
  },
  "renderMarkdownParse": {
    "name": "renderMarkdownParse",
    "slug": "TsFunction",
    "id": "plsygnmsxlrplfjccdzuuwpm",
    "description": "renders the MardkownParse interface (including frontmatter)",
    "operationName": "markdown",
    "rawText": " (\n  markdownParse: MarkdownParse,\n  config: MarkdownParseRenderConfig\n) => {\n  // NB: not sure if this is the best way, there may be mulitiple markdown parses....\n  useOpenHashDetails();\n\n  return (\n    <Div>\n      {renderFrontmatter(markdownParse.parameters, { renderSpacer: true })}\n      {/* NB: Previously we needed renderMarkdownTtile, renderMarkdownChunk etc... but this was not rightly parsed, so we are going to use the regular raw parser now from `react-markdown` instead... */}\n      {renderMarkdownContent(markdownParse.raw, config)}\n    </Div>\n  );\n}"
  },
  "renderMarkdownTitle": {
    "name": "renderMarkdownTitle",
    "slug": "TsFunction",
    "id": "tqpupzbqzsfivjxkohidxqas",
    "description": "renders a markdown title (level should be 1 for h1 and 6 for h6)",
    "operationName": "markdown",
    "rawText": " (title: string, level: number) => {\n  const levelSize =\n    level === 1\n      ? \"text-3xl\"\n      : level === 2\n      ? \"text-2xl\"\n      : level === 3\n      ? \"text-xl\"\n      : level === 4\n      ? \"text-lg\"\n      : level === 5\n      ? \"text-md\"\n      : level === 6\n      ? \"text-sm\"\n      : \"text-xs\";\n\n  return (\n    <P id={getImplicitId(title)} className={levelSize}>\n      {title}\n    </P>\n  );\n}"
  },
  "useOpenHashDetails": {
    "name": "useOpenHashDetails",
    "slug": "TsFunction",
    "id": "ejqtgthfjamejibnjglittqv",
    "description": "",
    "operationName": "markdown",
    "rawText": " () => {\n  React.useEffect(() => {\n    const openHashDetailsEventHandler = () => {\n      //  console.log(\"openHashEventHander\");\n      if (typeof window === \"undefined\") return;\n\n      const hash = location.hash.substring(1);\n\n      if (!hash) return;\n\n      //  console.log(`hash: ${hash}`);\n\n      const idElement = document.getElementById(hash);\n      const maybeDetails = idElement?.closest(\"details\");\n\n      // console.log({ idElement, maybeDetails });\n\n      if (!idElement || !maybeDetails) return;\n      maybeDetails.open = true;\n\n      //console.log(\"OPENED\");\n\n      scrollToId(idElement);\n    };\n\n    const scrollToId = (idElement: HTMLElement) => {\n      //console.log(\"Scroll To ID\");\n      history.scrollRestoration = \"manual\";\n      idElement.scrollIntoView({ behavior: \"smooth\" });\n      history.scrollRestoration = \"auto\";\n    };\n\n    if (document.readyState === \"complete\") {\n      openHashDetailsEventHandler();\n    }\n    addEventListener(\"load\", openHashDetailsEventHandler);\n    addEventListener(\"hashchange\", openHashDetailsEventHandler);\n\n    return () => {\n      removeEventListener(\"hashchange\", openHashDetailsEventHandler);\n      removeEventListener(\"load\", openHashDetailsEventHandler);\n    };\n  }, []);\n}"
  },
  "chunkToStringRecursively": {
    "name": "chunkToStringRecursively",
    "slug": "TsFunction",
    "id": "swvrdjvpuovymqhlibbdbmgz",
    "description": "",
    "operationName": "markdown-parse-js",
    "rawText": " (chunk: MarkdownChunk): string => {\n  return `${\"#\".repeat(chunk.level)} ${chunk.title || \"\"}\\n\\n${\n    chunk.content || \"\"\n  }\\n\\n${chunk.children?.map(chunkToStringRecursively)}\\n\\n`;\n}"
  },
  "exampleMarkdownFileContents": {
    "name": "exampleMarkdownFileContents",
    "slug": "TsVariable",
    "id": "wodybgirtflgfbjnermjbchv",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "getChunkParagraphsRecursively": {
    "name": "getChunkParagraphsRecursively",
    "slug": "TsFunction",
    "id": "jyfrlugnhselwblohmdasqrh",
    "description": "Get all paragraphs (`content` values) recursively from a `MarkdownChunk`",
    "operationName": "markdown-parse-js",
    "rawText": " (\n  chunk: MarkdownChunk\n): string[] => {\n  const childrenParagraphs =\n    chunk.children?.map(getChunkParagraphsRecursively).flat() || [];\n  const thisParagraph = chunk.content;\n  const paragraphs = [thisParagraph, ...childrenParagraphs].filter(notEmpty);\n  return paragraphs;\n}"
  },
  "getImplicitId": {
    "name": "getImplicitId",
    "slug": "TsFunction",
    "id": "xydgmqvnghonahzxvlnhzpkd",
    "description": "Implicit ids are a convention in markdown. A title gets an implicit id by removing spaces and making the title lowercase.\n\nSee https://stackoverflow.com/questions/6695439/how-to-link-to-a-named-anchor-in-multimarkdown",
    "operationName": "markdown-parse-js",
    "rawText": " (title: string): string => {\n  return slugify(title);\n}"
  },
  "getMarkdownIntro": {
    "name": "getMarkdownIntro",
    "slug": "TsFunction",
    "id": "vscrticobttwnmkokujiqxyl",
    "description": "This function takes a markdown parse and gets the first paragraph and a title from it, if available.\n\nCurrently assumes that the first paragraph starts directly after the title or there is no title and the content is at the beginning.\n\nTODO: It would be better to find the first paragraph based on the level.",
    "operationName": "markdown-parse-js",
    "rawText": " (markdownParse: MarkdownParse | null) => {\n  const firstChunk = markdownParse?.content?.[0];\n  const title = firstChunk?.title;\n  const firstParagraph = firstChunk?.title\n    ? firstChunk?.children?.[0]?.content || null\n    : firstChunk?.content || null;\n\n  return { title, firstParagraph };\n}"
  },
  "getMarkdownParseParagraphs": {
    "name": "getMarkdownParseParagraphs",
    "slug": "TsFunction",
    "id": "ybxdcmnvlsobjnyqkebclrqx",
    "description": "Gets all paragraphs (recursively) from a `MarkdownParse`",
    "operationName": "markdown-parse-js",
    "rawText": " (\n  markdownParse: MarkdownParse\n): string[] => {\n  const paragraphs =\n    markdownParse.content?.map(getChunkParagraphsRecursively).flat() || [];\n\n  return paragraphs;\n}"
  },
  "getMarkdownReferencePaths": {
    "name": "getMarkdownReferencePaths",
    "slug": "TsFunction",
    "id": "gvibksogkojamewtxbpopubk",
    "description": "",
    "operationName": "markdown-parse-js",
    "rawText": " (markdownString: string): string[] => {\n  const markdownParse = mdToJsonParse(markdownString);\n  const paragraphs = getMarkdownParseParagraphs(markdownParse);\n  const references = paragraphs.map(getMarkdownReferencesFromParagraph).flat();\n  const paths = references.map((x) => x.path);\n  return paths;\n}"
  },
  "getMarkdownReferencesFromParagraph": {
    "name": "getMarkdownReferencesFromParagraph",
    "slug": "TsFunction",
    "id": "adfnjligeroehqemtokgnxns",
    "description": "Gets all markdown references from a paragraph",
    "operationName": "markdown-parse-js",
    "rawText": " (\n  paragraph: string\n): MarkdownReference[] => {\n  const references = parseMarkdownParagraph(paragraph)\n    .map((x) => x.reference)\n    .filter(notEmpty);\n\n  return references;\n}"
  },
  "markdownParseToMarkdownStringFromContent": {
    "name": "markdownParseToMarkdownStringFromContent",
    "slug": "TsFunction",
    "id": "dcheexgconkurlmikvxwvynj",
    "description": "",
    "operationName": "markdown-parse-js",
    "rawText": " (\n  markdownParse: MarkdownParse\n): string | undefined => {\n  const contentResult = markdownParse.content\n    ?.map(chunkToStringRecursively)\n    .join(\"\\n\\n\");\n\n  const frontMatterString = frontmatterParseToString(markdownParse.parameters);\n\n  return `${frontMatterString}\\n${contentResult}`;\n}"
  },
  "markdownParseToMarkdownString": {
    "name": "markdownParseToMarkdownString",
    "slug": "TsFunction",
    "id": "ntfsmdkptoammftgibghwdyb",
    "description": "NB: this just uses RAW!\n\nUse `markdownParseToMarkdownStringFromContent` for the real deal",
    "operationName": "markdown-parse-js",
    "rawText": " (\n  markdownParse: MarkdownParse\n): string => {\n  const frontMatterString = frontmatterParseToString(markdownParse.parameters);\n  return `${frontMatterString}${markdownParse.raw}`;\n}"
  },
  "mdContentParseRecursively": {
    "name": "mdContentParseRecursively",
    "slug": "TsFunction",
    "id": "tmyvcaxeiaaurdiyegwjzmeu",
    "description": "recursively parses a string containing markdown (without frontmatter) into a MarkdownChunk[]\n\nImprove:\n- include the comment-type (TODO/NB/etc), both on a chunk level and on root level\n- parse paragraphs further around the assets",
    "operationName": "markdown-parse-js",
    "rawText": " (\n  markdownString: string,\n  level: number\n): MarkdownChunk[] => {\n  const chunks = parseMdToChunks(markdownString, level);\n\n  const chunksWithChildren = chunks.map(\n    (chunk: MarkdownChunk): MarkdownChunk[] => {\n      // NB: chunk is a paragraph\n      if (chunk.level === 0 && !chunk.title && chunk.content) {\n        // const lines = chunk.content.split(\"\\n\");\n\n        // // For every line, copy the chunk...\n        // const chunks = lines?.map((line) => ({\n        //   ...chunk,\n        //   content: line,\n        // }));\n\n        // return chunks;\n        return [chunk];\n      }\n\n      // NB: h6 is highest level\n      const children =\n        chunk.content && [1, 2, 3, 4, 5, 6].includes(chunk.level)\n          ? mdContentParseRecursively(chunk.content, chunk.level + 1)\n          : undefined;\n\n      const content = children ? undefined : chunk.content;\n\n      // NB: here we are splitting content with multiple lines into lines only for level 0 chunks\n      return content\n        ? [{ ...chunk, content }]\n        : [{ ...chunk, children, content: undefined }];\n    }\n  );\n\n  return chunksWithChildren.flat();\n}"
  },
  "mdToJsonParse": {
    "name": "mdToJsonParse",
    "slug": "TsFunction",
    "id": "rbixmbvwuferfqgxohvjnuag",
    "description": "makes a markdown parse from a markdown string\n\nTODO: `markdownStringToMarkdownParse` is a better name. First make a refactor script for this, because it is too hard to rename stuff that is used a lot.\n\nTODO: BUG: it doesn't take into account triple backticks! if there is markdown inside of the triple backticks, it can still be seen as main markdown. Triple backticks are stronger!",
    "operationName": "markdown-parse-js",
    "rawText": " (\n  markdownString: string,\n  fileName?: string,\n  config?: MarkdownParseConfig\n): MarkdownParse => {\n  const { parameters, raw } = parseFrontmatterMarkdownString(\n    markdownString,\n    config\n  );\n  return {\n    fileName,\n    raw,\n    parameters,\n    content: mdContentParseRecursively(raw, 1),\n  };\n}"
  },
  "parseFrontmatterMarkdownString": {
    "name": "parseFrontmatterMarkdownString",
    "slug": "TsFunction",
    "id": "epwymjkstkqtjxooxzchsocj",
    "description": "splits a markdown string into its frontmatter object and the raw content (without frontmatter)",
    "operationName": "markdown-parse-js",
    "rawText": " (\n  markdownWithFrontmatter: string,\n  config?: MarkdownParseConfig\n): MarkdownParse => {\n  const lines = markdownWithFrontmatter.split(\"\\n\");\n\n  const frontmatterStartIndex = lines.findIndex((x) => x === \"---\");\n\n  //console.log({ frontmatterStartIndex });\n  if (frontmatterStartIndex === -1) {\n    return { raw: markdownWithFrontmatter, parameters: {}, content: [] };\n  }\n\n  const linesAfterStart = lines.slice(frontmatterStartIndex + 1);\n  const frontmatterEndIndex =\n    linesAfterStart.findIndex((x) => x === \"---\") + frontmatterStartIndex + 1;\n\n  //console.log({ frontmatterEndIndex });\n  const frontmatterLines = lines.slice(\n    frontmatterStartIndex + 1,\n    frontmatterEndIndex\n  );\n\n  const parameters: Frontmatter = mergeObjectsArray(\n    frontmatterLines.map((line) => {\n      const needTrim = !config?.noFinal;\n      const key = line.split(\":\")[0]?.trim();\n      const value = line.split(\":\")[1];\n      const finalValue = needTrim ? value?.trim() : value;\n\n      return { [key]: finalValue };\n    })\n  );\n\n  const raw = lines.slice(frontmatterEndIndex + 1).join(\"\\n\");\n\n  return { parameters, raw, content: [] };\n}"
  },
  "parseMarkdownParagraph": {
    "name": "parseMarkdownParagraph",
    "slug": "TsFunction",
    "id": "ltybmsyaxhjzdkvudzpijlho",
    "description": "Parse markdown paragraph\n\nShould split it up for every thing it encounters...",
    "operationName": "markdown-parse-js",
    "rawText": " (\n  paragraph: string\n): MarkdownParagraphChunk[] => {\n  return [];\n}"
  },
  "parseMdToChunks": {
    "name": "parseMdToChunks",
    "slug": "TsFunction",
    "id": "ssumkervviqokgmsapzzwzgl",
    "description": "should get chunks recursively. first just look for every h1 line. everything after the h1 line is the children  until there's another h1 line, then do this recursivley for h2, h3, etc.",
    "operationName": "markdown-parse-js",
    "rawText": " (\n  markdownString: string,\n  level: number\n): MarkdownChunk[] => {\n  const lines = markdownString.split(\"\\n\");\n\n  const chunks = lines.reduce(\n    (chunks, line) => {\n      // NB: please note the space at the end, it's very important for this to work\n      const prefix = level !== 0 ? `${\"#\".repeat(level)} ` : null;\n\n      if (prefix && line.startsWith(prefix)) {\n        // Seems to be a header!\n\n        // NB: new header of this level detected, new chunk begins\n        return chunks.concat([\n          {\n            level,\n            title: removeHeaderPrefix(line),\n          },\n        ]);\n      } else {\n        // line is part of previous chunk, just add it to it\n\n        // NB: since the initial value contains something, we can assert it not being empty\n        const lastItem: MarkdownChunk = chunks.pop()!;\n        const previousContent = lastItem.content ? `${lastItem.content}\\n` : \"\";\n        const content = `${previousContent}${line}`;\n        return chunks.concat([{ ...lastItem, content }]);\n      }\n    },\n    // NB: by default it's a paragraph without header\n    [{ level: 0 }] as MarkdownChunk[]\n  );\n  // NB: we need something... filter out empty chunks!\n  return chunks.filter((x) => x.content || x.title || x.children);\n}"
  },
  "removeHeaderPrefix": {
    "name": "removeHeaderPrefix",
    "slug": "TsFunction",
    "id": "pmcplqmdrdtyaxgoaopcqqml",
    "description": "removes header prefix (##### etc) and trims whats behind that",
    "operationName": "markdown-parse-js",
    "rawText": " (string: string) => {\n  const trimmed = string.split(\"\").reduce(\n    (cum, letter) => {\n      const isHeaderPrefix = cum.isHeaderPrefix && letter === \"#\";\n      return {\n        string: isHeaderPrefix ? \"\" : cum.string.concat(letter),\n        isHeaderPrefix,\n      };\n    },\n    { string: \"\", isHeaderPrefix: true }\n  );\n\n  return trimmed.string.trim();\n}"
  },
  "addDependantCount": {
    "name": "addDependantCount",
    "slug": "TsFunction",
    "id": "hdluspgalzdfxmljxtwwzebr",
    "description": "Double arrow function to get the count for the item",
    "operationName": "markdown-parsings",
    "rawText": "\n  (type: \"tsFunction\" | \"tsVariable\" | \"tsInterface\", imports: TsImport[]) =>\n  async (\n    item: TsFunction | TsVariable | TsInterface\n  ): Promise<DependantCountObject> => {\n    return {\n      [type]: item,\n      externalDependantFiles: item.operationName\n        ? await findDependants({\n            operationName: item.operationName,\n            importName: item.name,\n            imports,\n            onlyExternal: true,\n          })\n        : [],\n    } as DependantCountObject;\n  }"
  },
  "bundleFolderWithMarkdown": {
    "name": "bundleFolderWithMarkdown",
    "slug": "TsFunction",
    "id": "luqmfxqaxftfcqoovkdwtjae",
    "description": "Finds all md files in a folder and creates a single MarkdownParse\n\nhandy for creating a single documentation file or other things that have to include multiple markdown files in a structured way\n\nNB: it recursively structures the files and folders with headings",
    "operationName": "markdown-parsings",
    "rawText": " async (\n  outlineTitle: string,\n  /**\n   * content of every markdown\n   */\n  markdownStrings: string[],\n  /**\n   * filename to include in the final MarkdownParse\n   */\n  resultFileName?: string\n): Promise<{ markdownParse: MarkdownParse; outlineString: string }> => {\n  // TODO: Optionally, wrap in `details` for every docs page\n\n  const markdownParses = markdownStrings.map((content) =>\n    mdToJsonParse(content)\n  );\n  const { merged, outline } = mergeMarkdownParse(\n    markdownParses,\n    resultFileName\n  );\n\n  // BUSY HERE\n\n  const outlineString = makeOutlineMarkdownString(outlineTitle, outline);\n\n  return { markdownParse: merged, outlineString };\n}"
  },
  "bundleToBookMarkdown": {
    "name": "bundleToBookMarkdown",
    "slug": "TsFunction",
    "id": "iklftppztmiladqytwyulmty",
    "description": "Input: BundleConfig (one or more folder(s), readme, operations with a docs folder)\n\nOutput should be all md files concatenated in the right order with the right titles",
    "operationName": "markdown-parsings",
    "rawText": " async (config: {\n  bundleConfig: BundleConfig;\n  title?: string;\n  coverImagePath?: string;\n  isModulesIncluded?: boolean;\n  manualProjectRoot?: string;\n}) => {\n  const {\n    bundleConfig,\n    coverImagePath,\n    title,\n    isModulesIncluded,\n    manualProjectRoot,\n  } = config;\n\n  const bundleSummary = getBundleSummary(bundleConfig);\n\n  const bundleDocs = bundleConfig.createBundleConfig.docsRelativeFolderPath;\n\n  const moduleNamesOrNot = isModulesIncluded ? [] : bundleSummary.moduleNames;\n\n  const allOperations = [\n    ...bundleSummary.appNames,\n    ...bundleSummary.packageNames,\n    ...moduleNamesOrNot,\n  ];\n\n  const operationMarkdownParses = (\n    await Promise.all(\n      allOperations.map(async (operationName) => {\n        const operationSummary = await getOperationSummary({\n          operationName,\n          manualProjectRoot,\n        });\n        if (!operationSummary) return;\n        const markdownParse = (await operationToMarkdown({\n          operationSummary,\n          returnType: \"parse\",\n        })) as MarkdownParse;\n        if (!markdownParse) return;\n\n        return markdownParse;\n      })\n    )\n  ).filter(notEmpty);\n\n  const mergedMarkdown = mergeMarkdownParse(operationMarkdownParses);\n\n  //   getOutline();\n\n  // 1) getOutline\n  // 2) mergeMarkdownParse\n  // 3) add cover + outline + contents together\n}"
  },
  "bundleToMarkdown": {
    "name": "bundleToMarkdown",
    "slug": "TsFunction",
    "id": "ipwhhmyorefqnzpupsmqmxab",
    "description": "creates a summary for a whole bundle\n\nNB: Related to `bundleToBookMd`",
    "operationName": "markdown-parsings",
    "rawText": " ({\n  bundleConfigId,\n  includeModules,\n}: {\n  bundleConfigId: string;\n  /** if true, also includes the private modules */\n  includeModules?: boolean;\n}): string => {\n  /**\n       - explain operation config itself, e.g. which apps there are and an outline of the packages and modules\n    \n       - extract all needed operations from bundle config (with or without modules) and use operationToMd for those\n      \n       - extract docs and readmes from bundle config and bundle those\n      */\n  return \"\";\n}"
  },
  "concatMarkdownFiles": {
    "name": "concatMarkdownFiles",
    "slug": "TsFunction",
    "id": "gwidcysjzclzpxrderzyypro",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " async () => {\n  //\n  const absoluteBasePath = \"/Users/king/King/operations/tools/ai/free-docs\";\n  const results = await explore({\n    basePath: absoluteBasePath,\n    extension: \"md\",\n    readmeOnTop: true,\n  });\n\n  const string = results\n    .map((x) => x.path)\n    .map(\n      (path) =>\n        `## ${makeRelative(\n          path,\n          getProjectRoot()! + \"/operations/tools\"\n        )}\\n\\n` + fs.readFileSync(path, \"utf8\")\n    )\n    .join(\n      \"\\n\\n\\n\\n_© Code From Anywhere - Discord: https://discord.gg/9jMHwBEW_\\n\\n\\n\\n\\n\\n\"\n    );\n\n  writeToAssets(__filename, string, \"result.md\");\n}"
  },
  "createMinimizedSectionMarkdown": {
    "name": "createMinimizedSectionMarkdown",
    "slug": "TsFunction",
    "id": "jvkayzxosnpavyyvlskrivji",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (\n  markdown: string,\n  expandTitle: string\n) => {\n  return `<details><summary>${expandTitle}</summary>\n    \n  ${markdown}\n  </details>`;\n}"
  },
  "createMinimizedSection": {
    "name": "createMinimizedSection",
    "slug": "TsFunction",
    "id": "vslmdgltudrmjvrowgblgmoi",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (\n  markdown: string | undefined,\n  title: string,\n  expandTitle: string\n): MarkdownParse | undefined => {\n  if (!markdown) return;\n  return mdToJsonParse(\n    createMinimizedSectionMarkdown(markdown, expandTitle),\n    title\n  );\n}"
  },
  "deployToVercel": {
    "name": "deployToVercel",
    "slug": "TsFunction",
    "id": "ymgbdsowtwbckhrsvhhmtbmo",
    "description": "NB: Obviously, this is not the right place for this function, but none of these functions are properly located yet...\n\nshould deploy any bundle or next project folder project to Vercel by first creating and pushing it into git, and then creating it in vercel through their api\n\nshould return an url where the project will be served and the estimated time when it will be live",
    "operationName": "markdown-parsings",
    "rawText": " () => {}"
  },
  "emailMarkdownParse": {
    "name": "emailMarkdownParse",
    "slug": "TsFunction",
    "id": "rvxpprqynwchqshdnxyrehac",
    "description": "should email a markdown parse to some email (or multiple)",
    "operationName": "markdown-parsings",
    "rawText": " () => {}"
  },
  "flattenNestedObject": {
    "name": "flattenNestedObject",
    "slug": "TsFunction",
    "id": "lmauhntuwavzzhtbvdunyqdb",
    "description": "Flattens a nested object by returning an object that hasa the nested path as the key and the leaf as the value\n\nTODO: Finish, if needed. seems hard!",
    "operationName": "markdown-parsings",
    "rawText": " <T>(\n  nestedObject: NestedObject<T>,\n  isLeaf?: (content: NestedObject<T> | T | undefined) => boolean\n) => {\n  Object.keys(nestedObject).map((key) => {\n    const value = nestedObject[key];\n\n    const isValueLeaf = isLeaf ? isLeaf(value) : typeof value !== \"object\";\n\n    return;\n  });\n}"
  },
  "generateStaticSite": {
    "name": "generateStaticSite",
    "slug": "TsFunction",
    "id": "ddkeptlhvoibbjryixauegqq",
    "description": "generates static site from a markdown file, with a menu on the right by default\n\nuses next.js\n\nbecause it is static, the markdown can be in the frontend assets and there is no need for a backend",
    "operationName": "markdown-parsings",
    "rawText": " ({\n  projectRelativeMdFilePath,\n  singlePage,\n}: {\n  singlePage?: boolean;\n  projectRelativeMdFilePath?: string;\n}) => {\n  //\n}"
  },
  "getJsonSchemaSummary": {
    "name": "getJsonSchemaSummary",
    "slug": "TsFunction",
    "id": "tlgapsvsbslpldpuwwuehylk",
    "description": "Generates short markdown summary",
    "operationName": "markdown-parsings",
    "rawText": " (\n  schema: JSONSchema7 | undefined,\n  isMarkdown: boolean\n) => {\n  if (!schema) return;\n\n  const typeDescriptor = getTypeDescriptorRecursive(schema, isMarkdown);\n\n  return {\n    typeDescriptor,\n    description: schema.description,\n  };\n}"
  },
  "getMarkdownContents": {
    "name": "getMarkdownContents",
    "slug": "TsFunction",
    "id": "hkhrateyqdhgafbztnkzbyeh",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " async (\n  absoluteFolderPath: string\n): Promise<{ content: string; relativePath: string }[] | undefined> => {\n  if (!fs.existsSync(absoluteFolderPath)) return;\n  const markdownFiles = await getPublicMarkdownFilePaths(absoluteFolderPath);\n  const markdownContents = await Promise.all(\n    markdownFiles\n      .filter((x) => fs.existsSync(x.path))\n      .map(async (x) => {\n        return {\n          content: await fs.readFile(x.path, \"utf8\"),\n          relativePath: makeRelative(x.path, absoluteFolderPath),\n        };\n      })\n  );\n\n  return markdownContents;\n}"
  },
  "getMergedMarkdownOutlineUrl": {
    "name": "getMergedMarkdownOutlineUrl",
    "slug": "TsFunction",
    "id": "vofagexjgtmtgogmlktcukvo",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (title: string) => {\n  return { title, hashtagPath: getImplicitId(title) };\n}"
  },
  "getOperationSummary": {
    "name": "getOperationSummary",
    "slug": "TsFunction",
    "id": "kekjxbvgjbwxmotxjisdvjjo",
    "description": "Summarises operation into useful information about it. Especially useful for generating docs.",
    "operationName": "markdown-parsings",
    "rawText": " async (config: {\n  operationName: string;\n  manualProjectRoot?: string;\n}): Promise<undefined | OperationSummary> => {\n  const { manualProjectRoot, operationName } = config;\n\n  const projectRoot = manualProjectRoot || getProjectRoot();\n  if (!projectRoot) {\n    log(\"Projectroot not found\", { type: \"error\" });\n    return;\n  }\n\n  const operationFolderPath = await getOperationPath(operationName, {\n    manualProjectRoot,\n  });\n\n  if (!operationFolderPath) {\n    log(\"OperationFolder not found\", { type: \"error\" });\n    return;\n  }\n\n  /**    \n  operation info\n  */\n\n  const operation = (await db.get(\"Operation\", { operationName }))[0];\n\n  if (!operation) {\n    log(\"Operation not found\", { type: \"error\" });\n    return;\n  }\n\n  const description = operation.operation?.markdown;\n\n  const coreDependenciesString =\n    noEmptyString(operation.operation?.coreDependenciesIndexed?.join(\", \")) ||\n    \"none\";\n  const operationDependenciesString =\n    noEmptyString(\n      operation.operation?.operationDependenciesIndexed?.join(\", \")\n    ) || \"none\";\n  const packageDependenciesString =\n    noEmptyString(\n      operation.operation?.packageDependenciesIndexed?.join(\", \")\n    ) || \"none\";\n\n  const docsPath = path.join(operationFolderPath, \"docs\");\n\n  const docs = await getMarkdownContents(docsPath);\n\n  /**\n   * all imports at other operations\n   */\n  const imports = (await db.get(\"TsImport\")).filter(\n    (x) => x.operationName !== operationName\n  );\n\n  const tsFunctions = (await db.get(\"TsFunction\", { operationName })).filter(\n    onlyUnique2<TsFunction>((a, b) => a.name === b.name)\n  );\n\n  const exportedTsFunctions = tsFunctions.filter((x) => x.isExported);\n\n  const variables = await db.get(\"TsVariable\", { operationName });\n\n  const exportedVariables = variables.filter((x) => x.isExported);\n\n  const interfaces = (await db.get(\"TsInterface\", { operationName })).filter(\n    (x) => !x.name.startsWith(\"NamedParameters<\")\n  );\n  const exportedInterfaces = interfaces.filter((x) => x.isExported);\n\n  const dependantTsFunctions: DependantCountObject[] = await Promise.all(\n    exportedTsFunctions.map(addDependantCount(\"tsFunction\", imports))\n  );\n\n  const dependantTsInterfaces: DependantCountObject[] = await Promise.all(\n    exportedInterfaces.map(addDependantCount(\"tsInterface\", imports))\n  );\n\n  const dependantTsVariables: DependantCountObject[] = await Promise.all(\n    exportedVariables.map(addDependantCount(\"tsVariable\", imports))\n  );\n\n  // Sort it! :D\n  const sortedDependantCountArray = [\n    dependantTsFunctions,\n    dependantTsInterfaces,\n    dependantTsVariables,\n  ]\n    .flat()\n    .sort((a, b) =>\n      a.externalDependantFiles.length > b.externalDependantFiles.length ? -1 : 1\n    );\n\n  const externalItems = sortedDependantCountArray.filter(\n    (x) => x.externalDependantFiles.length > 0\n  );\n\n  const internalItems = sortedDependantCountArray.filter(\n    (x) => x.externalDependantFiles.length === 0\n  );\n\n  const items: StatementItem[] = [\n    tsFunctions.map((tsFunction) => ({ tsFunction })),\n    interfaces.map((tsInterface) => ({ tsInterface })),\n    variables.map((tsVariable) => ({ tsVariable })),\n  ].flat();\n\n  const testItems = items.filter((x) =>\n    isConventionFileStatement(\n      (x.tsFunction || x.tsInterface || x.tsVariable)!,\n      \"test\"\n    )\n  );\n  const cliItems = items.filter((x) =>\n    isConventionFileStatement(\n      (x.tsFunction || x.tsInterface || x.tsVariable)!,\n      \"cli\"\n    )\n  );\n\n  const summary: OperationSummary = {\n    operationFolderPath,\n    operationName,\n    classification: operation.operation?.classificationIndexed,\n    description,\n    size: operation.operation?.sizeIndexed,\n    coreDependenciesString,\n    operationDependenciesString,\n    packageDependenciesString,\n    docs,\n    cliItems,\n    testItems,\n    internalItems,\n    externalItems,\n  };\n\n  return summary;\n}"
  },
  "getPublicMarkdownNestedPathObject": {
    "name": "getPublicMarkdownNestedPathObject",
    "slug": "TsFunction",
    "id": "mdrignkyvjuohebfbkklkjmh",
    "description": "Recursively searches a folder for public markdown files, and returns a `NestedObject` with the keys being the file or folder names, and the leafs being the absolute file paths.\n\nFile and folder names are stripped (number prefixes are removed, )\n\nexample:\n```json\n{\n\"README\": \"path/path/README.md\"\n\"folder1\":{\n\"README\": \"path/path/folder1/REAMDE.md\"\n\"file1\": \"path/path/folder1/file1.md\",\n}\n}",
    "operationName": "markdown-parsings",
    "rawText": " async (\n  absoluteFolderPath: string\n): Promise<NestedObject<string>> => {\n  const promises = (\n    await getPublicMarkdownFilePaths(absoluteFolderPath, true)\n  ).map(async (result) => {\n    const name = getFolderJs(removeExtensionsFromPath(result.path));\n\n    const nestedPathObjectOrPath: NestedObject<string> | string =\n      result.isFolder\n        ? await getPublicMarkdownNestedPathObject(result.path)\n        : result.path;\n\n    return {\n      [name]: nestedPathObjectOrPath,\n    };\n  });\n\n  const completeNestedObject: NestedObject<string> = mergeObjectsArray(\n    await Promise.all(promises)\n  );\n\n  return completeNestedObject;\n}"
  },
  "getTitlesRecursively": {
    "name": "getTitlesRecursively",
    "slug": "TsFunction",
    "id": "kxcihpbarknvvtqbkhdnpecd",
    "description": "helper function to get a nested array of the titles and its subtitles",
    "operationName": "markdown-parsings",
    "rawText": " (chunk: MarkdownChunk) => {\n  const childrenTitles: NestedTitle[] | undefined =\n    chunk.children?.map(getTitlesRecursively);\n\n  const returnStatement: NestedTitle[] = [];\n\n  if (chunk.title) returnStatement.push(chunk.title);\n  if (childrenTitles?.length) returnStatement.push(childrenTitles);\n\n  return returnStatement;\n}"
  },
  "getTypeDescriptorRecursive": {
    "name": "getTypeDescriptorRecursive",
    "slug": "TsFunction",
    "id": "wxttmydazzklixhhyopxpryp",
    "description": "Returns a single line descriptor of the type of a json schema. Can be used in markdown tables.",
    "operationName": "markdown-parsings",
    "rawText": " (\n  schema: JSONSchema7,\n  /**\n   * If true, references will be links, otherwise, just the name of the referred interface\n   */\n  isMarkdown: boolean\n): string => {\n  const refLink = getRefLink(schema.$ref);\n  // console.log({ $ref: schema.$ref, refLink });\n\n  const type = Array.isArray(schema.type) ? schema.type[0] : schema.type;\n\n  if (refLink) {\n    return isMarkdown ? `\\`${refLink}\\`` : refLink;\n  } //(#${getImplicitId(refLink)})\n\n  if (schema.enum) {\n    const enumString = `${schema.enum.map(String).join(\" / \")}`;\n    return type === \"number\" ? `${enumString} (number)` : enumString;\n  }\n\n  if (type === \"boolean\") return \"boolean\";\n  if (type === \"string\") return \"string\";\n  if (type === \"number\" || type === \"integer\") return \"number\";\n  if (type === \"null\") return \"null\";\n  if (type === \"array\") {\n    const items = getSchemaItems(schema);\n\n    const itemsString = items\n      .map((item) => getTypeDescriptorRecursive(item, true))\n      .join(\" | \");\n\n    return `${items.length > 1 ? `(${itemsString})` : itemsString}[]`;\n  }\n\n  //   NB: only type object is left now\n\n  const properties = getProperties(schema);\n\n  const additionalProperties = getSchema(schema.additionalProperties);\n  const additionalPropertiesString = additionalProperties\n    ? `[key: string]: ${getTypeDescriptorRecursive(\n        additionalProperties,\n        isMarkdown\n      )}`\n    : \"\";\n\n  const propertyStrings = properties\n    .map((property) => {\n      const propertyString = `${property.name}${\n        property?.required ? \":\" : \"?:\"\n      } ${getTypeDescriptorRecursive(property.schema, isMarkdown)}`;\n\n      return propertyString;\n    })\n    .concat(additionalPropertiesString);\n\n  return isMarkdown\n    ? noNewlines(`{ ${propertyStrings.join(\", \\n\")} }`)!\n    : propertyStrings.join(\", \");\n}"
  },
  "isConventionFileStatement": {
    "name": "isConventionFileStatement",
    "slug": "TsFunction",
    "id": "zustraxoupcdkngnlaaigsbr",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (\n  item: TsFunction | TsVariable | TsInterface,\n  conventionFile: \"test\" | \"cli\"\n) => {\n  const fileId = getSrcRelativeFileId(item.operationRelativeTypescriptFilePath);\n  return hasSubExtension(fileId, [conventionFile], true);\n}"
  },
  "isUpperCase": {
    "name": "isUpperCase",
    "slug": "TsFunction",
    "id": "tadxfzpatznvhactcqviykmp",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (text: string) => {\n  return text.toUpperCase() === text;\n}"
  },
  "makeOutlineMarkdownString": {
    "name": "makeOutlineMarkdownString",
    "slug": "TsFunction",
    "id": "vgmldbewpawfekeuhveekros",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (\n  title: string,\n  urls: MergedMarkdownOutlineUrl[]\n): string => {\n  const outlineString =\n    urls.length > 0\n      ? `## ${title}\\n\\n${urls\n          .map((url) => {\n            return `- [${url.title}](#${url.hashtagPath})`;\n          })\n          .join(\"\\n\")}\\n\\n`\n      : \"\";\n\n  return outlineString;\n}"
  },
  "makePropertiesTable": {
    "name": "makePropertiesTable",
    "slug": "TsFunction",
    "id": "xpvmqdkcnvjcaeoekjrwnxac",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (\n  properties: SimplifiedSchemaProperty[] | undefined\n) => {\n  return properties && properties.length > 0\n    ? `Properties: \\n\\n | Name | Type | Description |\\n|---|---|---|\\n${properties\n        .map(propertyToTableRow)\n        .join(\"\\n\")}\\n`\n    : \"\";\n}"
  },
  "markdownChunkToMarkdownStringRecursive": {
    "name": "markdownChunkToMarkdownStringRecursive",
    "slug": "TsFunction",
    "id": "dlvnidazdlwnojnamywvbhoo",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (\n  markdownChunk: MarkdownChunk\n): string => {\n  const title =\n    markdownChunk.title && markdownChunk.level !== 0\n      ? `${\"#\".repeat(markdownChunk.level)} ${markdownChunk.title}`\n      : undefined;\n\n  const content = markdownChunk.content;\n\n  const children = markdownChunk.children\n    ? markdownChunksToMarkdownStringRecursive(markdownChunk.children)\n    : \"\";\n\n  return `${title ? `${title}\\n\\n` : \"\"}${\n    content ? `${content}\\n\\n` : \"\"\n  }${children}`;\n}"
  },
  "markdownChunksToMarkdownStringRecursive": {
    "name": "markdownChunksToMarkdownStringRecursive",
    "slug": "TsFunction",
    "id": "ppbcugqgyjnxytalrmtliysy",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (\n  markdownChunks: MarkdownChunk[]\n): string => {\n  const result: string = markdownChunks\n    .map(markdownChunkToMarkdownStringRecursive)\n    .join(\"\");\n\n  return result;\n}"
  },
  "markdownToSayable": {
    "name": "markdownToSayable",
    "slug": "TsFunction",
    "id": "caxgcberkggcnznatjknycju",
    "description": "all mp3s should be stored in a separate location because we don't need them in the file system and we don't reference them, as they are data that is located by convention. all markdowns should have a linked `TextToSpeechAudio[]` which is auto updated every time `dev` is ran. `TextToSpeechAudio` also includes infromation about the `duration`, `voice` and more...\n\na bigger `.md.mp3` file is auto-created for every markdown file that concatenates all `sayable` audio pieces in the right order, but also includes the audio pieces in between.",
    "operationName": "markdown-parsings",
    "rawText": " ({\n  markdown,\n  markdownFilePath,\n}: {\n  markdownFilePath: string;\n  markdown: MarkdownParse;\n}): Sayable[] => {\n  //1 get markdownparse\n\n  //2. alter every piece of content as needed into a sayable text that can be understood through audio only\n\n  /*\n    - headings should be paused before (long) and after (shorter)\n    - headings should be numbered\n    - images and other inline assets should be referenced with alt text, unless it's an audio file\n    - new alineas should get some pause before\n    - OPTIONAL: maybe, when starting a (sub)chapter, tell the reader how many subchapters there are in this (sub)chapter. This can give a better orientation\n    */\n\n  return [];\n}"
  },
  "mdToPdf": {
    "name": "mdToPdf",
    "slug": "TsFunction",
    "id": "mqilanggrosgifejlvukyhcw",
    "description": "Have function `mdToPdf` like the vscode plugin. Probably exists.\n\nHowever, may be good to do it myself since I want different renderings",
    "operationName": "markdown-parsings",
    "rawText": " ({\n  absoluteFilePath,\n  markdown,\n  markdownParse,\n  pdfAbsoluteFilePath,\n}: {\n  absoluteFilePath?: string;\n  markdown?: string;\n  markdownParse?: MarkdownParse;\n  pdfAbsoluteFilePath?: string;\n}) => {\n  //\n}"
  },
  "mergeMarkdownParse": {
    "name": "mergeMarkdownParse",
    "slug": "TsFunction",
    "id": "ksoqrxqnhhpgyyuwxscyldyk",
    "description": "Merges multiple markdown parses to create a new markdown parse",
    "operationName": "markdown-parsings",
    "rawText": " (\n  markdownParses: MarkdownParse[],\n  fileName?: string\n): { merged: MarkdownParse; outline: MergedMarkdownOutlineUrl[] } => {\n  const allParameters = mergeObjectsArray(\n    markdownParses.map((x) => x.parameters)\n  );\n\n  const allMarkdownChunks = markdownParses.map((x) => {\n    const newMarkodwnChunk: MarkdownChunk = {\n      children: upMarkdownChunkLevelRecursively(x.content),\n      level: 1,\n      content: undefined,\n      title: x.fileName\n        ? humanCase(removeExtensionsFromPath(x.fileName))\n        : undefined,\n    };\n\n    return newMarkodwnChunk;\n  });\n\n  const newMarkdownParse: MarkdownParse = {\n    parameters: allParameters,\n    raw: markdownChunksToMarkdownStringRecursive(allMarkdownChunks),\n    content: allMarkdownChunks,\n    fileName,\n  };\n\n  const outline: MergedMarkdownOutlineUrl[] = markdownParses\n    .map((markdownParse) => {\n      if (!markdownParse.fileName) return;\n\n      const title = humanCase(markdownParse.fileName);\n\n      const implicitId = getImplicitId(title);\n      return {\n        title,\n        // NB: because the title in the markdownparse is humancase, we need to slugify that to get the hashtagpath\n        hashtagPath: implicitId,\n      };\n    })\n    .filter(notEmpty);\n\n  return { merged: newMarkdownParse, outline };\n}"
  },
  "noNewlines": {
    "name": "noNewlines",
    "slug": "TsFunction",
    "id": "abfpimvcuvsjeydaykbvrddk",
    "description": "Replaces newlines with a <br />",
    "operationName": "markdown-parsings",
    "rawText": " (\n  markdown: string | undefined\n): string | undefined => {\n  return markdown?.replaceAll(\"\\n\", \"<br />\");\n}"
  },
  "operationRadio": {
    "name": "operationRadio",
    "slug": "TsFunction",
    "id": "nlcrtheqmhoozoijozueuliz",
    "description": "randomly plays mp3 summaries of operations on the project",
    "operationName": "markdown-parsings",
    "rawText": " () => {}"
  },
  "operationToMarkdown": {
    "name": "operationToMarkdown",
    "slug": "TsFunction",
    "id": "zvgnhqbigamjyxtdighudbha",
    "description": "converts an operation and all its contents into a flat markdown file that contains the needed information. configurable.\n\nmarkdown for reading (so there are no links)",
    "operationName": "markdown-parsings",
    "rawText": " async (config: {\n  operationSummary: OperationSummary;\n  /**\n   * - save: saves the result in the operation `README.md` and `CONTRIBUTING.md` and other default md files\n   * - string: returns the full markdown string\n   * - parse: returns the `MarkdownParse`\n   */\n  returnType?: \"parse\" | \"string\" | \"save\";\n  includeDocs?: boolean;\n  includeInfo?: boolean;\n}): Promise<string | MarkdownParse | undefined> => {\n  const {\n    operationSummary: {\n      classification,\n      cliItems,\n      coreDependenciesString,\n      description,\n      docs,\n      externalItems,\n      internalItems,\n      operationDependenciesString,\n      operationName,\n      packageDependenciesString,\n      size,\n      testItems,\n      operationFolderPath,\n    },\n    returnType,\n  } = config;\n\n  const detailDocsContentStrings = docs?.map((content) =>\n    createMinimizedSectionMarkdown(content.content, content.relativePath)\n  );\n\n  const docsBundle = detailDocsContentStrings\n    ? await bundleFolderWithMarkdown(\"Docs\", detailDocsContentStrings, \"docs\")\n    : undefined;\n\n  const sizeString = `Size: ${size?.codeSize?.lines} LOC, ${\n    size?.dataSize?.characters !== undefined\n      ? `${size?.dataSize?.characters} data characters, `\n      : \"\"\n  }${\n    size?.textSize?.characters !== undefined\n      ? `${size?.textSize?.characters} text characters, `\n      : \"\"\n  }`;\n\n  const operationInfoMd = `${operationName} (\\`OperationClassification\\` ${classification})\n\n${description ? `${description}\\n\\n` : \"\"}`;\n\n  const infoString = config.includeInfo\n    ? `\n${sizeString}\n \nImported dependencies:\n\n- From Core Libraries: ${coreDependenciesString}\n- From Packages: ${packageDependenciesString}\n- From Operations: ${operationDependenciesString}`\n    : undefined;\n\n  const operationInfoMarkdownParse = mdToJsonParse(\n    operationInfoMd,\n    operationName\n  );\n\n  const [cliMarkdown, testMarkdown] = [cliItems, testItems].map((items) =>\n    items.map(statementItemToMarkdown).filter(notEmpty).join(\"\\n\\n\")\n  );\n\n  const [externalItemsMarkdown, internalItemsMarkdown] = [\n    externalItems,\n    internalItems,\n  ].map((countArray) => {\n    const res = countArray\n      .map(statementItemToMarkdown)\n      .filter(notEmpty)\n      .join(\"\\n\\n\");\n\n    return res;\n  });\n\n  const apiReference = mdToJsonParse(externalItemsMarkdown!, \"api-reference\");\n\n  const infoMarkdownParse = infoString\n    ? mdToJsonParse(infoString, \"info\")\n    : undefined;\n\n  const internalSection = createMinimizedSection(\n    internalItemsMarkdown,\n    \"internal\",\n    `Show internal (${internalItems.length})`\n  );\n\n  const testSection = createMinimizedSection(\n    testMarkdown,\n    \"tests\",\n    `Show test information(${testItems.length})`\n  );\n\n  const cliSection = createMinimizedSection(\n    cliMarkdown,\n    \"CLI\",\n    `Show CLI information (${cliItems.length})`\n  );\n\n  const { merged } = mergeMarkdownParse(\n    [\n      operationInfoMarkdownParse,\n      infoMarkdownParse,\n      config?.includeDocs\n        ? mdToJsonParse(docsBundle?.outlineString || \"\")\n        : undefined,\n      config?.includeDocs ? docsBundle?.markdownParse : undefined,\n      apiReference,\n      cliSection,\n      testSection,\n      internalSection,\n    ].filter(notEmpty)\n  );\n\n  let returnString: string | undefined = undefined;\n  if (returnType !== \"parse\") {\n    returnString = markdownParseToMarkdownString(merged);\n  }\n\n  const shouldSave = returnType === \"save\" || !returnType;\n  if (shouldSave && returnString) {\n    await fs.writeFile(\n      path.join(operationFolderPath, \"README.md\"),\n      returnString,\n      \"utf8\"\n    );\n  }\n\n  const returnValue =\n    returnType === \"parse\"\n      ? merged\n      : returnType === \"string\"\n      ? returnString\n      : undefined;\n\n  return returnValue;\n}"
  },
  "printNestedTitles": {
    "name": "printNestedTitles",
    "slug": "TsFunction",
    "id": "ukhjblkfrrlqfpiacaephxwa",
    "description": "helper function (recursive) that prints nested titles with .. as prefix and a newline after every title\n\nTODO: allow for numbering titles",
    "operationName": "markdown-parsings",
    "rawText": " (\n  nestedTitles: NestedTitle[] | undefined,\n  depth?: number\n): string | undefined => {\n  const realDepth = depth || 0;\n  const prefix = \"..\".repeat(realDepth);\n\n  const printedTogether = nestedTitles\n    ?.map((nestedTitle) => {\n      return Array.isArray(nestedTitle)\n        ? printNestedTitles(nestedTitle, realDepth + 1)\n        : `${prefix}${nestedTitle}\\n`;\n    })\n    .join(\"\\n\");\n\n  return printedTogether;\n}"
  },
  "print": {
    "name": "print",
    "slug": "TsFunction",
    "id": "bzszqnkzeldootjztvdojibp",
    "description": "should print any file using a preconfigured printer (which can be local or remote. if remote and there is no connection, it should save the task for later)\n\nthis function maybe needs \"generateStaticSite\"",
    "operationName": "markdown-parsings",
    "rawText": " ({ absoluteFilePath }: { absoluteFilePath: string }) => {\n  /**\n    \n    markdown files should be rendered via the renderer first\n    \n    ts, json files should be color highlighted (we can simply wrap this in triple backticks and print it as markdown)\n    */\n}"
  },
  "projectToMarkdown": {
    "name": "projectToMarkdown",
    "slug": "TsFunction",
    "id": "lalybbjedxwvcmapebogsuhh",
    "description": "summarizes the whole OS project into a markdown string",
    "operationName": "markdown-parsings",
    "rawText": " ({\n  includeTodo,\n}: {\n  includeTodo?: boolean;\n  includeOperationDetails?: boolean;\n}): string => {\n  /**\n    \n     - the folder structure should be the outline\n     - hierarchically delve into folders with all its content (md and operations)\n  \n     */\n  return \"\";\n}"
  },
  "propertyToTableRow": {
    "name": "propertyToTableRow",
    "slug": "TsFunction",
    "id": "erdxuhghtuyqvdwludfmlyqt",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (\n  property: SimplifiedSchemaProperty\n): string => {\n  const requiredString = property.required ? \"\" : \"(optional)\";\n\n  const descriptionString = noNewlines(property.schema.description) || \"\";\n\n  // TODO: stack deeper objects and make sure to also print tables for those\n  return `| ${property.name} ${requiredString} | ${property.schema.type} | ${descriptionString} |`;\n}"
  },
  "sayablesToMp3": {
    "name": "sayablesToMp3",
    "slug": "TsFunction",
    "id": "wrdfctbwelowdvnltzotjxwu",
    "description": "Creates a single audiofile of a Sayable[] and stores that in a configured location",
    "operationName": "markdown-parsings",
    "rawText": " (config: {\n  destinationAbsoluteFilePath: string;\n  sayables: Sayable[];\n}) => {\n  const { sayables, destinationAbsoluteFilePath } = config;\n  /**\n  \n  \n  \n   */\n}"
  },
  "selectRandomOperation": {
    "name": "selectRandomOperation",
    "slug": "TsFunction",
    "id": "jksdxmxnpxiccvsvyjfzocfo",
    "description": "selects a random operation",
    "operationName": "markdown-parsings",
    "rawText": " async (\n  baseFolderPath?: string\n): Promise<string> => {\n  return \"\";\n}"
  },
  "simplifiedSchemaToMarkdownString": {
    "name": "simplifiedSchemaToMarkdownString",
    "slug": "TsFunction",
    "id": "qxtmgiswpfogozvarzqzpmzm",
    "description": "Should render a string with one or more markdown tables to represent the simplifiedSchema",
    "operationName": "markdown-parsings",
    "rawText": " (\n  simplifiedSchema: SimplifiedSchema | undefined,\n  /**\n   * if not given, no title is printed\n   */\n  name: string | undefined,\n  isRequired: boolean,\n  /** the headers level, defaults to 1 */\n  level?: number\n): string => {\n  if (!simplifiedSchema) return \"\";\n\n  const refLinkString = simplifiedSchema.circularRefName\n    ? `[${simplifiedSchema.circularRefName}](#${getImplicitId(\n        simplifiedSchema.circularRefName\n      )})`\n    : \"\";\n\n  const enumString = simplifiedSchema.enum\n    ? `(Enum: ${simplifiedSchema.enum.map(String).join(\" | \")}) `\n    : \"\";\n\n  const optionalSubtitle = `${isRequired ? \"\" : \" (optional)\"}`;\n\n  const nameWithoutNewlines = name ? name.replaceAll(\"\\n\", \"\") : undefined;\n  const type = `${simplifiedSchema.type}${enumString}${refLinkString}`;\n  const title = name\n    ? `${\"#\".repeat(\n        level || 1\n      )} ${nameWithoutNewlines}${optionalSubtitle}: ${type}`\n    : undefined;\n\n  const arrayString = simplifiedSchema.items\n    ? simplifiedSchema.items\n        .map((item) => {\n          const itemString = `- ${item.name}: ${item.schema.type}`;\n          return itemString;\n        })\n        .join(\"\\n\")\n    : \"\";\n\n  const description = simplifiedSchema.description\n    ? `> ${noNewlines(simplifiedSchema.description)}`\n    : \"\";\n\n  const objectString = makePropertiesTable(simplifiedSchema.properties);\n  const togetherString = [title, arrayString, description, objectString]\n    .filter(notEmpty)\n    .join(\"\\n\\n\");\n\n  return togetherString;\n}"
  },
  "statementItemToMarkdown": {
    "name": "statementItemToMarkdown",
    "slug": "TsFunction",
    "id": "zjtskrktwdpdkbdadxfuyplf",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (\n  statementItem: StatementItem\n): string | undefined => {\n  if (statementItem.tsFunction) {\n    return tsFunctionToMarkdownString(statementItem.tsFunction);\n  }\n\n  if (statementItem.tsInterface) {\n    return tsInterfaceToMarkdownString(statementItem.tsInterface);\n  }\n\n  if (statementItem.tsVariable) {\n    return tsVariableToMarkdownString(statementItem.tsVariable);\n  }\n}"
  },
  "tsFunctionToMarkdownString": {
    "name": "tsFunctionToMarkdownString",
    "slug": "TsFunction",
    "id": "rtqnphczkeiarftfyvxlmfne",
    "description": "TsFunction:\n- name and operation\n- size\n- description (doc-comment)\n- input, output",
    "operationName": "markdown-parsings",
    "rawText": " (tsFunction: TsFunction): string => {\n  const isComponent =\n    tsFunction.operationRelativeTypescriptFilePath.endsWith(\".tsx\") &&\n    isUpperCase(tsFunction.name.charAt(0));\n\n  const titleString = `# ${\n    isComponent ? `\\`<${tsFunction.name} />\\`` : `${tsFunction.name}()`\n  }`;\n\n  const infoString = `${\n    tsFunction.codeSize?.lines ? `${tsFunction.codeSize.lines} LOC, ` : \"\"\n  }Max. indexation depth: ${tsFunction.maxIndentationDepth}, ${\n    tsFunction.cumulativeCodeSize?.lines\n      ? `${tsFunction.cumulativeCodeSize?.lines} Cumulative LOC`\n      : \"\"\n  }`;\n\n  const returnString = tsFunction.returnType.simplifiedSchema\n    ? simplifiedSchemaToMarkdownString(\n        tsFunction.returnType.simplifiedSchema,\n        \"Returns\",\n        true,\n        2\n      )\n    : \"\";\n\n  /*\n\n| Input      |        |     |\n| ---------- | ------ | --- |\n| fileId     | string |     |\n| **Output** |        |     |\n| object     |        |     |\n\n\n    */\n\n  const paramaterTableRows =\n    tsFunction.parameters && tsFunction.parameters.length > 0\n      ? tsFunction.parameters.map((parameter) => {\n          const summary = getJsonSchemaSummary(parameter.schema, true);\n          return `| ${parameter.name}${\n            parameter.required ? \"\" : \" (optional)\"\n          } | ${summary?.typeDescriptor || \"\"} | ${\n            summary?.description || \"\"\n          } |`;\n        })\n      : \"| - | | |\";\n\n  // const argumentStrings =\n  // tsFunction.parameters && tsFunction.parameters.length > 0\n  //   ? `## Parameters (${\n  //       tsFunction.parameters.length\n  //     })\\n\\n${tsFunction.parameters\n  //       .map((x, i) =>\n  //         simplifiedSchemaToMarkdownString(\n  //           x.simplifiedSchema,\n  //           `Parameter ${i + 1}: ${x.name}`,\n  //           x.required,\n  //           3\n  //         )\n  //       )\n  //       .join(\"\\n\\n\")}`\n  //   : undefined;\n\n  const returnTypeMarkdownString = tsFunction.returnType.typeDefinition\n    ? getTypeDescriptorRecursive(tsFunction.returnType.typeDefinition, true)\n    : \"\";\n\n  const outputRow = `| **Output** | ${returnTypeMarkdownString}   | ${\n    tsFunction.returnType.typeDefinition?.description || \"\"\n  }   |`;\n  const tableString = `\n| Input      |    |    |\n| ---------- | -- | -- |\n${paramaterTableRows}\n${outputRow}\n`;\n\n  const alineas: (string | undefined)[] = [\n    titleString,\n    // infoString, // TODO: Maybe make it optional.\n    tsFunction.description,\n    // returnTypeString,\n    tableString,\n  ];\n\n  return alineas.filter(notEmpty).join(\"\\n\\n\");\n}"
  },
  "tsInterfaceToMarkdownString": {
    "name": "tsInterfaceToMarkdownString",
    "slug": "TsFunction",
    "id": "uhezgtlhdgufvcymkiszjrnn",
    "description": "properties, their type, and their description\n\nuse simplifiedJsonSchema, but split up nested things into multiple tables (ive written a thing for splitting up nested objects before, use that)",
    "operationName": "markdown-parsings",
    "rawText": " (\n  tsInterface: TsInterface\n): string => {\n  const icon = tsInterface.isDbModel ? \"🔸\" : \"🔹\";\n\n  const titleString = `# ${icon} ${tsInterface.name}`;\n  const storageMethodString = tsInterface.dbStorageMethod\n    ? `${tsInterface.dbStorageMethod} model\\n\\n`\n    : undefined;\n\n  // const operationName = tsInterface.operationName\n  //   ? `(from: \\`${tsInterface.operationName}\\`)`\n  //   : undefined;\n\n  // const interfaceText = `\\`\\`\\`ts\\n${tsInterface.rawText}\\n\\`\\`\\``;\n\n  const interfaceText = simplifiedSchemaToMarkdownString(\n    tsInterface.type.simplifiedSchema,\n    undefined,\n    true,\n    2\n  );\n\n  const alineas: (string | undefined)[] = [\n    titleString,\n    // operationName,\n    storageMethodString,\n    tsInterface.description,\n    interfaceText,\n  ];\n\n  return alineas.filter(notEmpty).join(\"\\n\\n\");\n}"
  },
  "tsVariableToMarkdownString": {
    "name": "tsVariableToMarkdownString",
    "slug": "TsFunction",
    "id": "gjdhxxvatutrjdhvcngcwnqd",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": " (tsVariable: TsVariable): string => {\n  const titleString = `# 📄 ${tsVariable.name} (${\n    tsVariable.isExported ? \"exported\" : \"unexported\"\n  } ${tsVariable.classification})`;\n\n  const alineas: (string | undefined)[] = [titleString, tsVariable.description];\n\n  return alineas.filter(notEmpty).join(\"\\n\\n\");\n}"
  },
  "upMarkdownChunkLevelRecursively": {
    "name": "upMarkdownChunkLevelRecursively",
    "slug": "TsFunction",
    "id": "qhclovutdatkqrigtzyzmtib",
    "description": "Ups the levels of the markdownChunk array, recursively.\n\nCan be useful for merging multiple markdown sources",
    "operationName": "markdown-parsings",
    "rawText": " (\n  markdownChunks: MarkdownChunk[] | undefined\n): MarkdownChunk[] | undefined => {\n  if (!markdownChunks) return;\n\n  const newMarkdownChunks: MarkdownChunk[] = markdownChunks.map((chunk) => ({\n    ...chunk,\n    level: chunk.level + 1,\n    children: upMarkdownChunkLevelRecursively(chunk.children),\n  }));\n\n  return newMarkdownChunks;\n}"
  },
  "copyStaticAssetsCli": {
    "name": "copyStaticAssetsCli",
    "slug": "TsFunction",
    "id": "vqecasefvsvlyuveoqgvfrgn",
    "description": "",
    "operationName": "markdown-reader-functions",
    "rawText": " async () => {\n  const markdownReaderPages = await getAllMarkdownReaderPages();\n\n  if (!markdownReaderPages) return;\n  const isSuccessful = await copyStaticAssets(markdownReaderPages);\n\n  console.log({ isSuccessful });\n}"
  },
  "copyStaticAssets": {
    "name": "copyStaticAssets",
    "slug": "TsFunction",
    "id": "hrjwsblgwdwcsnlqewpczaai",
    "description": "uses `getMarkdownReferencePaths` for all markdown files in the `markdown-reader-ui` and copies them into the `markdown-reader-web/public` folder, keeping the original folder structure.\n\nNB: Removes all files in the public folder first.\n\nTo get a file from public assets after running this function, you need to get it from the `projectRelativeFilePath`, not the file relative, so you need to render it differently.",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  readerWebPages: ReaderWebPage[],\n  config?: {\n    /**\n     * by default, uses `markdown-reader-web`\n     */\n    operationName?: string;\n  }\n): Promise<boolean | undefined> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n\n  const nextWebFolder = await getOperationPath(\n    config?.operationName || \"markdown-reader-web\"\n  );\n\n  if (!nextWebFolder) return;\n\n  const referencePathsPromises = readerWebPages.map(async (page) => {\n    if (!page.pageData.projectRelativeFilePath) return;\n    const absoluteMarkdownFilePath = path.join(\n      projectRoot,\n      page.pageData.projectRelativeFilePath\n    );\n    const markdownString = await fs.readFile(absoluteMarkdownFilePath, \"utf8\");\n    const referencePaths = getMarkdownReferencePaths(markdownString);\n    return referencePaths;\n  });\n\n  const absoluteReferencePaths = (await Promise.all(referencePathsPromises))\n    .filter(notEmpty)\n    .flat()\n    .filter(onlyUnique2());\n\n  const projectRelativeReferencePaths = absoluteReferencePaths.map((x) =>\n    makeRelative(x, projectRoot)\n  );\n\n  const publicAssetsFolder = path.join(nextWebFolder, \"public\");\n\n  const removed = await removeAllExcept(publicAssetsFolder);\n\n  const isSuccessful = await copyAllRelativeFiles(\n    projectRelativeReferencePaths,\n    projectRoot,\n    publicAssetsFolder\n  );\n\n  return isSuccessful;\n}"
  },
  "docsGetStaticPaths": {
    "name": "docsGetStaticPaths",
    "slug": "TsFunction",
    "id": "nncbibyhbnayunhfdjzvjfxd",
    "description": "Function that tells Next.js what the pages are that need to be statically generated",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  context: GetStaticPathsContext,\n  basePaths: { projectRelativeBasePath: string; queryPath: string }[]\n): Promise<GetStaticPathsResult> => {\n  const paths: string[] | undefined = (await docsGetPages(basePaths)).map(\n    (x) => x.queryPath\n  );\n\n  // console.log({ paths });\n  if (!paths) {\n    return { paths: [], fallback: \"blocking\" };\n  }\n\n  const staticPaths = paths\n    .filter((x) => x !== \"\")\n    .map((p) => ({ params: { paths: p.split(\"/\") } }));\n\n  return {\n    paths: staticPaths,\n    fallback: \"blocking\",\n  };\n}"
  },
  "docsGetStaticProps": {
    "name": "docsGetStaticProps",
    "slug": "TsFunction",
    "id": "ulqqosmkqegtpumfytqnazpz",
    "description": "",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  context: GetStaticPropsContext,\n  basePaths: {\n    projectRelativeBasePath: string;\n    queryPath: string;\n  }[],\n  /**\n   * Operation of the website that is going to be deployed\n   */\n  webOperationName: string\n): Promise<{\n  props: MarkdownReaderPageProps;\n}> => {\n  const flat = await docsGetPages(basePaths);\n  const propsObject = await markdownReaderGetStaticPropsFromPages(\n    context,\n    flat,\n    webOperationName\n  );\n  return propsObject;\n}"
  },
  "getAllMarkdownReaderPages": {
    "name": "getAllMarkdownReaderPages",
    "slug": "TsFunction",
    "id": "ugswcydnccbyigwcgpsxjdmf",
    "description": "....? I should've commented this\n\nconst hasDocs = !!relativeDocsPages.find(\n\n(x) => x.queryPath.toLowerCase() === \"docs/readme\"\n\n);\n\nif (!hasDocs) {\n\nconst hasRootReadme = fs.existsSync(path.join(projectRoot, \"README.md\"));\n\nif (hasRootReadme) {\n\nrelativeDocsPages.unshift({\n\nqueryPath: \"docs/readme\",\n\nfilePath: \"README.md\",\n\nisMenuItem: true,\n\n});\n\n}\n\n}\n\nGets all pages of a bundle based on the fs and database\n\nPages it finds:\n\n- operation-readmes\n- multiple docs basePaths with all folders and markdown pages there in (`/[project-relative-path]`)\n- `/dictionary`\n- all markdown model types we have in the db-sdk, optionally, depending on config\n\nRequirements:\n\n- README should always be on top in a folder.\n- numbers and extensions are omitted from paths, but still connected to the right file\n- If the docs doesn't have a readme, the /docs/readme path shows the root readme.\n\nDoes not include AugmentedWord. Just the main pages, not with queries and hashes\n\nUsed to generate the menu",
    "operationName": "markdown-reader-functions",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n}): Promise<undefined | WebPage<any>[]> => {\n  const projectRoot = config?.manualProjectRoot || getProjectRoot();\n  if (!projectRoot) return;\n\n  const publicBundleConfig = await readJsonFile<PublicBundleConfig>(\n    path.join(projectRoot, \"public-bundle-config.json\")\n  );\n\n  const bundleMarkdownReaderConfig =\n    publicBundleConfig?.bundleMarkdownReaderConfig;\n\n  // the docs folder with all its files\n  const docsPaths = await findAllDocsFolderPaths(true);\n\n  const customOperationDocsPaths =\n    bundleMarkdownReaderConfig?.customOperationNames\n      ?.map((operationName) => {\n        const relativeOperationPath =\n          operations[operationName as keyof typeof operations];\n        if (!relativeOperationPath) return;\n        const absoluteDocsPath = path.join(\n          projectRoot,\n          relativeOperationPath,\n          \"docs\"\n        );\n        if (!fs.existsSync(absoluteDocsPath)) return;\n        return {\n          absoluteDocsPath,\n          queryPath: bundleMarkdownReaderConfig?.docsInRoot\n            ? operationName\n            : `docs/${operationName}`,\n        };\n      })\n      .filter(notEmpty) || [];\n\n  const customOperationDocsPages: ReaderWebPage[] =\n    await getMarkdownReaderPages({\n      projectRoot,\n      basePaths: customOperationDocsPaths.map((x) => x.absoluteDocsPath),\n      queryPathCustomPrefix: (basePath) =>\n        customOperationDocsPaths.find((x) => x.absoluteDocsPath === basePath)\n          ?.queryPath,\n    });\n\n  const relativeDocsPages: ReaderWebPage[] = await getMarkdownReaderPages({\n    projectRoot,\n    basePaths: docsPaths,\n    // remove docs prefix if docs should be shown as in root\n    mapQueryPath: bundleMarkdownReaderConfig?.docsInRoot\n      ? (old) =>\n          old.startsWith(\"docs/\")\n            ? old.slice(\"docs/\".length)\n            : // NB: \"docs/README.md\" becomes \"docs\", which should, in turn, become \"\" in this case...\n            old === \"docs\"\n            ? \"\"\n            : old\n      : undefined,\n  });\n\n  // operations\n  const operationPages: ReaderWebPage[] = await getOperationPages(\n    projectRoot,\n    bundleMarkdownReaderConfig\n  );\n\n  // markdown model type pages\n  const markdownModelTypePages = await getMarkdownModelPages(projectRoot);\n  // todo pages\n  const todoPages = await getReaderTodoPages(projectRoot);\n\n  const mainReadme: ReaderWebPage | undefined =\n    bundleMarkdownReaderConfig?.docsInRoot\n      ? undefined\n      : {\n          queryPath: \"\",\n          pageData: { projectRelativeFilePath: \"README.md\" },\n          isMenuHidden: false,\n        };\n\n  const dictionaryPage: CustomWebPage = {\n    queryPath: \"dictionary\",\n    isMenuHidden: false,\n    pageData: null,\n  };\n\n  const allPages: WebPage<any>[] = [\n    mainReadme,\n    ...relativeDocsPages,\n    ...customOperationDocsPages,\n    ...operationPages,\n    // `/dictionary` page with all words/definitions, categorised\n    dictionaryPage,\n    // all markdown model types, optionally (with config)\n    ...markdownModelTypePages,\n    // all todo markdown folders, both in operations and outside (with config)\n    ...todoPages,\n  ].filter(notEmpty);\n\n  const filteredPages = allPages.filter(\n    onlyUnique2<ReaderWebPage>((a, b) => a.queryPath === b.queryPath)\n  );\n\n  return filteredPages;\n}"
  },
  "getChildren": {
    "name": "getChildren",
    "slug": "TsFunction",
    "id": "cowugdpiuczbkzngmryjbxvq",
    "description": "",
    "operationName": "markdown-reader-functions",
    "rawText": " (webPages: WebPage<any>[], queryPath: string) => {\n  const queryPathDepth = queryPath.split(\"/\").length;\n  const childrenKeys = webPages\n    .filter(\n      (x) =>\n        x.queryPath.startsWith(queryPath) &&\n        x.queryPath.split(\"/\").length - queryPathDepth === 1\n    )\n    .map((x) => x.queryPath.split(\"/\")[queryPathDepth]);\n\n  return childrenKeys;\n}"
  },
  "getFolderExplorationInfo": {
    "name": "getFolderExplorationInfo",
    "slug": "TsFunction",
    "id": "koxshmnqgcmkcdvwecgtxild",
    "description": "Gets exploration information about a folder\n\n- reads README.md in current folder\n- reads OPERATION.md in child folders, or README.md if that doesn't exist\n- gets an intro from those markdown files and returns that (uses `getMarkdownIntro`)",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  webPages: WebPage<any>[],\n  queryPath: string,\n  projectRoot: string\n): Promise<{\n  title: string | undefined;\n  description: string | null;\n  descriptionProjectRelativeMarkdownPath: string | null;\n  children: {\n    projectRelativeMarkdownPath: string | null;\n    title: string;\n    firstParagraph: string | null;\n    folderName: string;\n  }[];\n}> => {\n  const childrenKeys = getChildren(webPages, queryPath);\n\n  const potentialReadmePath = path.join(projectRoot, queryPath, \"README.md\");\n  const readmeMarkdownParse = fs.existsSync(potentialReadmePath)\n    ? await readMarkdownFile(potentialReadmePath)\n    : null;\n\n  const queryPathTitle = queryPath.split(\"/\").pop();\n  const readmeInfo = getMarkdownIntro(readmeMarkdownParse);\n  const title = readmeInfo.title || queryPathTitle;\n  const description = readmeInfo.firstParagraph;\n\n  const children = await Promise.all(\n    childrenKeys.map(async (folderName) => {\n      const potentialReadmePath = path.join(\n        projectRoot,\n        queryPath,\n        folderName,\n        \"README.md\"\n      );\n      const potentialOperationPath = path.join(\n        projectRoot,\n        queryPath,\n        folderName,\n        \"OPERATION.md\"\n      );\n\n      const pathToRead = fs.existsSync(potentialOperationPath)\n        ? potentialOperationPath\n        : fs.existsSync(potentialReadmePath)\n        ? potentialReadmePath\n        : undefined;\n\n      const markdownParse = pathToRead\n        ? await readMarkdownFile(pathToRead)\n        : null;\n\n      const { title, firstParagraph } = getMarkdownIntro(markdownParse);\n      return {\n        title: title || folderName,\n        firstParagraph,\n        folderName,\n        projectRelativeMarkdownPath: pathToRead || null,\n      };\n    })\n  );\n\n  return {\n    title,\n    description,\n    children,\n    descriptionProjectRelativeMarkdownPath: readmeMarkdownParse\n      ? potentialReadmePath\n      : null,\n  };\n}"
  },
  "getMarkdownModelPages": {
    "name": "getMarkdownModelPages",
    "slug": "TsFunction",
    "id": "yxdgtryiyfggpjltmtikxzbr",
    "description": "Transforms all your markdown models into  markdown reader pages\n\nSteps:\n- Finds all markdown model types from the database config\n- Gets their basepaths according to `fs-orm` convention\n- Checks if they actually exist\n- Finds all markdown therein\n- Makess markdown reader pages out of them",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  projectRoot: string\n): Promise<ReaderWebPage[]> => {\n  const markdownModelNames = getObjectKeysArray(modelQueryConfig).filter(\n    (modelName) => {\n      const config = modelQueryConfig[modelName] as QueryConfig;\n\n      const isMarkdownModelType = config.dbStorageMethod === \"markdown\";\n      const noSpecificPath = !config.operationRelativePath;\n      return isMarkdownModelType && noSpecificPath;\n    }\n  );\n\n  const basePaths = markdownModelNames\n    .map((modelName) =>\n      path.join(projectRoot, \"db\", pluralize(kebabCase(modelName)))\n    )\n    .filter((potentialBasePath) => fs.existsSync(potentialBasePath));\n\n  const markdownReaderPages = await getMarkdownReaderPages({\n    projectRoot,\n    basePaths,\n  });\n\n  return markdownReaderPages;\n}"
  },
  "getMarkdownPageInfo": {
    "name": "getMarkdownPageInfo",
    "slug": "TsFunction",
    "id": "ncyyqjfcetjssynbapayegpj",
    "description": "If a markdown page is found, this function fetches all metadata needed to render that markdown page",
    "operationName": "markdown-reader-functions",
    "rawText": " async (config: {\n  projectRoot: string;\n  webPages: WebPage<any>[];\n  queryPath: string;\n  contentPage: ReaderWebPage;\n  webOperationName: string;\n  markdownCallToActions: MarkdownCallToAction[];\n}): Promise<{\n  markdownFile: WebMarkdownFile | null;\n  nextQueryPath: string | null;\n  previousQueryPath: string | null;\n  projectRelativeMarkdownPath: string | null;\n}> => {\n  const {\n    contentPage,\n    markdownCallToActions,\n    projectRoot,\n    queryPath,\n    webOperationName,\n    webPages,\n  } = config;\n\n  const parentQuery = getOneFolderUpPath(queryPath);\n  const siblings = getChildren(webPages, parentQuery);\n  const thisPageKey = queryPath.split(\"/\").pop();\n  const meIndex = siblings.findIndex((sibling) => thisPageKey === sibling);\n\n  const previousFolder = siblings[meIndex - 1];\n  const previousQueryPath = previousFolder\n    ? `${parentQuery}/${previousFolder}`\n    : null;\n  const nextFolder = siblings[meIndex + 1];\n  const nextQueryPath = nextFolder ? `${parentQuery}/${nextFolder}` : null;\n\n  const absoluteMarkdownPath = contentPage.pageData?.projectRelativeFilePath\n    ? path.join(projectRoot, contentPage.pageData.projectRelativeFilePath)\n    : undefined;\n\n  const markdownFile = absoluteMarkdownPath\n    ? await readMarkdownFileToModel(\n        absoluteMarkdownPath,\n        webOperationName,\n        markdownCallToActions\n      )\n    : null;\n\n  const projectRelativeMarkdownPath = absoluteMarkdownPath\n    ? makeRelative(absoluteMarkdownPath, projectRoot)\n    : null;\n\n  return {\n    markdownFile,\n    nextQueryPath,\n    previousQueryPath,\n    projectRelativeMarkdownPath,\n  };\n}"
  },
  "getMarkdownReaderQueryPaths": {
    "name": "getMarkdownReaderQueryPaths",
    "slug": "TsFunction",
    "id": "pcvnphfllapedhczcupzsqor",
    "description": "",
    "operationName": "markdown-reader-functions",
    "rawText": " async (config?: {\n  manualProjectRoot?: string;\n}) => {\n  const pages = await getAllMarkdownReaderPages(config);\n  // NB: this is kind of a hack, but it's way harder to add it into the pages I guess, so it's easier like this.\n  const queryPaths = pages?.map((x) => x.queryPath);\n\n  const queryPaths2 = pages\n    ?.map((x) => x.queryPath)\n    .map((queryPath) => getAllFoldersUntilFolder(queryPath))\n    .flat()\n    .filter(onlyUnique2())\n    .filter((x) => x !== \"/\")\n    .map((x) => trimSlashes(x));\n\n  // console.log({ queryPaths2 });\n  return queryPaths2;\n}"
  },
  "getOperationPages": {
    "name": "getOperationPages",
    "slug": "TsFunction",
    "id": "apfemtqetohoxqxvotienbfu",
    "description": "",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  projectRoot: string,\n  bundleMarkdownReaderConfig?: BundleMarkdownReaderConfig\n): Promise<ReaderWebPage[]> => {\n  const operationBasePaths = getPathsWithOperations({\n    manualProjectRoot: projectRoot,\n  });\n\n  const operationPagesPerType: { [key: string]: ReaderWebPage[] } =\n    mergeObjectsArray(\n      await Promise.all(\n        operationBasePaths.map(async (absoluteBasePath) => {\n          const folders = (\n            await exploreOperationFolders({ basePath: absoluteBasePath })\n          ).map((result) => ({\n            projectRelativePath: makeRelative(result, projectRoot),\n          }));\n\n          const projectRelativeBasePath = makeRelative(\n            absoluteBasePath,\n            projectRoot\n          );\n\n          // console.log({ folders });\n\n          const pages: ReaderWebPage[] = folders.map((folder) => {\n            const folderName = getLastFolder(folder.projectRelativePath);\n\n            /**\n             * Sometimes the bundle states the menu items should not be shown. The pages still remain available though, otherwise it would cause lots of dead links!\n             */\n            const isMenuHidden =\n              projectRelativeBasePath === \"apps\" &&\n              bundleMarkdownReaderConfig?.omitAppsMenu\n                ? true\n                : projectRelativeBasePath === \"packages\" &&\n                  bundleMarkdownReaderConfig?.omitPackagesMenu\n                ? true\n                : projectRelativeBasePath === \"modules\" &&\n                  bundleMarkdownReaderConfig?.omitModulesMenu\n                ? true\n                : false;\n\n            // console.log({ isMenuItem, projectRelativeBasePath, folderName });\n\n            const readerWebPage: ReaderWebPage = {\n              queryPath: folder.projectRelativePath,\n              // operation filePath is README.md\n              pageData: {\n                projectRelativeFilePath: path.join(\n                  folder.projectRelativePath,\n                  \"README.md\"\n                ),\n                internalLinkWord: folderName,\n              },\n              isMenuHidden,\n            };\n\n            return readerWebPage;\n          });\n\n          return { [projectRelativeBasePath]: pages };\n        })\n      )\n    );\n\n  const operationsPages: ReaderWebPage[] =\n    bundleMarkdownReaderConfig?.customOperationNames\n      ?.map((operationName) => {\n        const projectRelativeOperationPath =\n          operations[operationName as keyof typeof operations];\n\n        if (!projectRelativeOperationPath) return;\n\n        const readerWebPage: ReaderWebPage = {\n          pageData: {\n            projectRelativeFilePath: path.join(\n              projectRelativeOperationPath,\n              \"README.md\"\n            ),\n          },\n          queryPath: projectRelativeOperationPath,\n          isMenuHidden: false,\n        };\n\n        return readerWebPage;\n      })\n      .filter(notEmpty) || [];\n\n  // NB: we need to get the right order, so it needs to be done separately\n  const operationPages: ReaderWebPage[] = isBundle(projectRoot)\n    ? [\n        ...operationsPages,\n        ...operationPagesPerType.packages,\n        ...operationPagesPerType.apps,\n        ...operationPagesPerType.modules,\n      ]\n    : [\n        ...operationsPages,\n        ...operationPagesPerType[\"operations/tools\"],\n        ...operationPagesPerType[\"operations/niches\"],\n      ];\n\n  return operationPages;\n}"
  },
  "getReaderTodoPages": {
    "name": "getReaderTodoPages",
    "slug": "TsFunction",
    "id": "gqxnywzfymcrtrkjxrlzxwgp",
    "description": "gets all todo pages as markdownreader pages",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  projectRoot: string\n): Promise<ReaderWebPage[]> => {\n  const operationsPath = getRootPath(\"operations\");\n  if (!operationsPath) return [];\n\n  const todoFolderPaths = await findAllTodoFolderPaths(operationsPath, false);\n  const markdownReaderPages: ReaderWebPage[] = await getMarkdownReaderPages({\n    projectRoot,\n    basePaths: todoFolderPaths,\n    mapQueryPath: (queryPath) => {\n      const almostPath = queryPath\n        .replaceAll(\"todo/\", \"\")\n        .replace(\"operations/\", \"todo/\");\n\n      return almostPath.startsWith(\"todo/\") ? almostPath : \"todo/\" + almostPath;\n    },\n  });\n\n  return markdownReaderPages;\n}"
  },
  "markdownReaderGetStaticPaths": {
    "name": "markdownReaderGetStaticPaths",
    "slug": "TsFunction",
    "id": "isbrcscrmhmrrswwlonvvpty",
    "description": "Function that tells Next.js what the pages are that need to be statically generated",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  context: GetStaticPathsContext\n) => {\n  const paths: string[] | undefined = await getMarkdownReaderQueryPaths();\n\n  // console.log({ paths });\n  if (!paths) {\n    return { paths: [], fallback: \"blocking\" };\n  }\n\n  const staticPaths = paths\n    .filter((x) => x !== \"\")\n    .map((p) => ({ params: { paths: p.split(\"/\") } }));\n\n  return {\n    paths: staticPaths,\n    fallback: \"blocking\",\n  };\n}"
  },
  "markdownReaderGetStaticPropsFromPages": {
    "name": "markdownReaderGetStaticPropsFromPages",
    "slug": "TsFunction",
    "id": "yqyeqjtjsqbrwnljsbqnoukt",
    "description": "Takes the routes and pages you want to show, and returns the MarkdownReaderPageProps you need to render the reader page.",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  context: GetStaticPropsContext,\n  fileWebPages: WebPage<any>[],\n  webOperationName: string\n): Promise<{\n  props: MarkdownReaderPageProps;\n}> => {\n  const menu = getMenuPagesObject(fileWebPages);\n  const projectRoot = getProjectRoot();\n\n  if (!projectRoot) {\n    return { props: { menu } };\n  }\n\n  const publicBundleConfig = await readJsonFile<PublicBundleConfig>(\n    path.join(projectRoot, \"public-bundle-config.json\")\n  );\n\n  const queryPath = getQueryPath(context.params);\n\n  // console.log(\"get static props\", queryPath);\n\n  // definitions/statements/functions/interfaces/operations\n\n  // NB: finds a page with actual content\n  const contentPage = fileWebPages.find((x) => x.queryPath === queryPath);\n\n  if (!contentPage) {\n    // NB: we need to render an exploration page\n    const {\n      children,\n      title,\n      description,\n      descriptionProjectRelativeMarkdownPath,\n    } = await getFolderExplorationInfo(fileWebPages, queryPath, projectRoot);\n    return {\n      props: {\n        publicBundleConfig,\n        menu,\n        content: {\n          children,\n          title,\n          description,\n          projectRelativeMarkdownPath: descriptionProjectRelativeMarkdownPath,\n        },\n      },\n    };\n  }\n\n  // NB: There's a content page. We need to return it (`MarkdownFile`), including its previous, next pages, and a title\n\n  const markdownCallToActions = await db.get(\"MarkdownCallToAction\");\n\n  const filteredMarkdownCtas = markdownCallToActions.filter((x) => {\n    const isExternalRoot =\n      x.hostname !== publicBundleConfig?.deploymentHostname &&\n      (!x.path || x.path === \"\");\n\n    if (isExternalRoot) return true;\n\n    const isInternalNonRoot =\n      x.hostname === publicBundleConfig?.deploymentHostname &&\n      x.path &&\n      x.path !== \"\";\n\n    return isInternalNonRoot;\n  });\n\n  const markdownPageInfo = await getMarkdownPageInfo({\n    projectRoot,\n    webPages: fileWebPages,\n    queryPath,\n    contentPage,\n    webOperationName,\n    markdownCallToActions: filteredMarkdownCtas,\n  });\n\n  // console.log(\n  //   {\n  //     projectRoot,\n  //     webPages: fileWebPages,\n  //     queryPath,\n  //     contentPage,\n  //     webOperationName,\n  //     markdownCallToActions: filteredMarkdownCtas,\n  //   },\n  //   { markdownPageInfo }\n  // );\n\n  const augmentedWordObject = await getAugmentedWordObject(projectRoot);\n\n  return {\n    // Passed to the page component as props\n    props: {\n      content: {\n        ...markdownPageInfo,\n        augmentedWordObject,\n      },\n      publicBundleConfig,\n      menu,\n    },\n  };\n}"
  },
  "markdownReaderGetStaticProps": {
    "name": "markdownReaderGetStaticProps",
    "slug": "TsFunction",
    "id": "ggklmbprfqyujfkzgqsllrbv",
    "description": "",
    "operationName": "markdown-reader-functions",
    "rawText": " async (\n  context: GetStaticPropsContext\n): Promise<{\n  props: MarkdownReaderPageProps;\n}> => {\n  const flat = (await getAllMarkdownReaderPages()) || [];\n  return markdownReaderGetStaticPropsFromPages(\n    context,\n    flat,\n    \"markdown-reader-web\"\n  );\n}"
  },
  "putReadmeOnTop": {
    "name": "putReadmeOnTop",
    "slug": "TsFunction",
    "id": "vfabxtwtcjyckyquplvrkkuf",
    "description": "Takes an array of items (`explore` results) and checks them to put readme at the start\n\nDEPRECATED: After writing this, I found that `explore` also has `readmeOnTop` possibility, so this whole thing is not needed",
    "operationName": "markdown-reader-functions",
    "rawText": " <\n  T extends {\n    path: string;\n    isFolder: boolean;\n  }\n>(\n  items: T[]\n) => {\n  const itemsReadmesFirst = items.reduce((previous, item, index, array) => {\n    if (!item.path.toLowerCase().endsWith(\"readme.md\")) {\n      return previous;\n    }\n\n    const folderIndex = array.findIndex(\n      (x) => x.isFolder && x.path === getFolder(item.path)\n    );\n\n    if (folderIndex === -1) {\n      return previous;\n    }\n\n    return putIndexAtIndex(previous, index, folderIndex + 1);\n  }, items);\n\n  return itemsReadmesFirst;\n}"
  },
  "getQueryPath": {
    "name": "getQueryPath",
    "slug": "TsFunction",
    "id": "ftnnnmhutkgsethzeyqtpsqh",
    "description": "",
    "operationName": "markdown-reader-functions-js",
    "rawText": " (parsedUrlQuery: ParsedUrlQuery | undefined) => {\n  const paths = parsedUrlQuery?.paths;\n  const queryPath = Array.isArray(paths)\n    ? paths.join(\"/\")\n    : paths === undefined\n    ? \"\"\n    : paths;\n  return queryPath;\n}"
  },
  "markdownParseToMarkdownModelType": {
    "name": "markdownParseToMarkdownModelType",
    "slug": "TsFunction",
    "id": "roqzlgiruiaknrvxikyzyyfl",
    "description": "makes a markdownModelType from a markdownParse.",
    "operationName": "markdown-types",
    "rawText": " (\n  markdownParse: MarkdownParse | null\n): Storing<MarkdownModelType> | null => {\n  if (!markdownParse) return null;\n\n  const { parameters, raw, fileName } = markdownParse;\n\n  const name = parameters.name ? String(parameters.name) : fileName!;\n  const slug = kebabCase(name);\n  const id = parameters.id ? String(parameters.id) : generateId();\n  const createdAt = parseMarkdownModelTimestamp(\n    parameters,\n    markdownParse,\n    \"createdAt\"\n  );\n  const createdFirstAt = parseMarkdownModelTimestamp(\n    parameters,\n    markdownParse,\n    \"createdFirstAt\"\n  );\n  const updatedAt = parseMarkdownModelTimestamp(\n    parameters,\n    markdownParse,\n    \"updatedAt\"\n  );\n  const deletedAt = parseMarkdownModelTimestamp(\n    parameters,\n    markdownParse,\n    \"deletedAt\"\n  );\n\n  const openedAt = parseMarkdownModelTimestamp(\n    parameters,\n    markdownParse,\n    \"openedAt\"\n  );\n\n  const markdownModelType: Storing<MarkdownModelType> = {\n    ...parameters,\n    id,\n    createdAt,\n    createdFirstAt,\n    deletedAt,\n    updatedAt,\n    openedAt,\n    markdown: raw,\n    name,\n    slug,\n  };\n\n  return markdownModelType;\n}"
  },
  "parseMarkdownModelTimestamp": {
    "name": "parseMarkdownModelTimestamp",
    "slug": "TsFunction",
    "id": "jmgctwjcotgqepxhxkhitgvg",
    "description": "First tries to look at the frontmatter value, this is leading because it is what the user sees and the file system of the os could be inconsistent\n\nIf this frontmatter doesn't exist, the markdownParse is checked for a date. This should be information collected from the file system\n\nIf that doesn't succeed, sometimes we'll set it to  the current timestamp",
    "operationName": "markdown-types",
    "rawText": " (\n  parameters: Frontmatter,\n  markdownParse: MarkdownParse,\n  parameterName:\n    | \"createdAt\"\n    | \"createdFirstAt\"\n    | \"updatedAt\"\n    | \"deletedAt\"\n    | \"openedAt\"\n): number => {\n  const parameterValue = parameters[parameterName];\n  const markdownParseValue = markdownParse[parameterName];\n\n  const parsedParameterValue =\n    typeof parameterValue === \"number\" && !isNaN(parameterValue)\n      ? parameterValue\n      : typeof parameterValue === \"string\"\n      ? tryParseDate(parameterValue)\n      : undefined;\n\n  const generatedValue =\n    parameterName === \"deletedAt\" || parameterName === \"openedAt\"\n      ? 0\n      : Date.now();\n\n  const parsedTimestamp =\n    parsedParameterValue !== undefined\n      ? parsedParameterValue\n      : markdownParseValue !== undefined\n      ? markdownParseValue\n      : generatedValue;\n\n  return parsedTimestamp;\n}"
  },
  "tryParseDate": {
    "name": "tryParseDate",
    "slug": "TsFunction",
    "id": "ukumqzfdweyfuvtiywttttcf",
    "description": "Tries to parse a date from a string\n- implements default behavior of `new Date` with a try catch\n- returns a unix timestamp (ms since 1970 AD)\n\nTODO: put in a better location... date-util?",
    "operationName": "markdown-types",
    "rawText": " (dateString: string): number | undefined => {\n  try {\n    return new Date(dateString).valueOf();\n  } catch {}\n}"
  },
  "findCodeblocks": {
    "name": "findCodeblocks",
    "slug": "TsFunction",
    "id": "zprvzpnhidvykpyvlvhsdhik",
    "description": "find all codespans",
    "operationName": "marked-util",
    "rawText": " (markdownString: string): string[] => {\n  const result = flattenMarkdownString(\n    markdownString,\n    (token) => token.type === \"code\"\n  );\n\n  const codesblocks: string[] = result\n    .map((token) => {\n      if (token.type !== \"code\") return;\n\n      return token.text;\n    })\n    .filter(notEmpty);\n\n  return codesblocks;\n}"
  },
  "findCodespans": {
    "name": "findCodespans",
    "slug": "TsFunction",
    "id": "nyygbasprwzdijeeqamermwe",
    "description": "find all codespans",
    "operationName": "marked-util",
    "rawText": " (markdownString: string): string[] => {\n  const result = flattenMarkdownString(\n    markdownString,\n    (token) => token.type === \"codespan\"\n  );\n\n  const codespans: string[] = result\n    .map((token) => {\n      if (token.type !== \"codespan\") return;\n\n      return token.text;\n    })\n    .filter(notEmpty);\n\n  return codespans;\n}"
  },
  "findEmbedsTest": {
    "name": "findEmbedsTest",
    "slug": "TsFunction",
    "id": "meouwahqwpfiiqggpadrsjkt",
    "description": "",
    "operationName": "marked-util",
    "rawText": " () => {\n  const string = `---\nisCodestory: true\nheaderImage: ![](./ksks2.png)\n---\n\n# YO YO YO ![](./ksks.nl)\n\nyo yo yo\n\n![](./ksks.png)\n\n**![](./wow.png)**\n`;\n  const result = findEmbeds(string);\n\n  console.log({ result });\n}"
  },
  "findEmbeds": {
    "name": "findEmbeds",
    "slug": "TsFunction",
    "id": "qpwletutevqcwhtfboxqnfcv",
    "description": "find all embedded assets",
    "operationName": "marked-util",
    "rawText": " (markdownString: string): MarkdownEmbed[] => {\n  const result = flattenMarkdownString(\n    markdownString,\n    (token) => token.type === \"image\"\n  );\n\n  const embeds: MarkdownEmbed[] = result\n    .map((token) => {\n      if (token.type !== \"image\") return;\n\n      const markdownEmbed: MarkdownEmbed = {\n        alt: token.text || \"\",\n        src: token.href,\n        type: getTypeFromUrlOrPath(token.href),\n      };\n\n      return markdownEmbed;\n    })\n    .filter(notEmpty);\n\n  return embeds;\n}"
  },
  "findLinks": {
    "name": "findLinks",
    "slug": "TsFunction",
    "id": "ufuijcerfynknilwnklmiegx",
    "description": "find all links",
    "operationName": "marked-util",
    "rawText": " (markdownString: string): MarkdownLink[] => {\n  const result = flattenMarkdownString(\n    markdownString,\n    (token) => token.type === \"link\"\n  );\n\n  const links: MarkdownLink[] = result\n    .map((token) => {\n      if (token.type !== \"link\") return;\n\n      const markdownEmbed: MarkdownLink = {\n        alt: token.text || \"\",\n        href: token.href,\n        type: getTypeFromUrlOrPath(token.href),\n      };\n\n      return markdownEmbed;\n    })\n    .filter(notEmpty);\n\n  return links;\n}"
  },
  "flattenMarkdownString": {
    "name": "flattenMarkdownString",
    "slug": "TsFunction",
    "id": "lxzwlgvblkhcqshigwpnoboo",
    "description": "find all items that match a token, recursively in all nested things",
    "operationName": "marked-util",
    "rawText": " (\n  markdownString: string,\n  findFunction: (token: marked.Token) => boolean\n): marked.Token[] => {\n  const tokenList = marked.lexer(markdownString);\n  const result = tokenList\n    .map((x) => flattenMarkedTokenRecursive(x, findFunction))\n    .filter(notEmpty)\n    .flat();\n\n  return result;\n}"
  },
  "flattenMarkedTokenRecursive": {
    "name": "flattenMarkedTokenRecursive",
    "slug": "TsFunction",
    "id": "yqylpbturnhffgffwliratpa",
    "description": "Recursively flatten a marked token and return something if a find function is met",
    "operationName": "marked-util",
    "rawText": " (\n  token: marked.Token,\n  findFunction: (token: marked.Token) => boolean\n): marked.Token[] => {\n  if (findFunction(token)) {\n    return [token];\n  }\n\n  if (token.type === \"table\") {\n    const header = token.header\n      .map((token) => {\n        const result = token.tokens\n          .map((x) => flattenMarkedTokenRecursive(x, findFunction))\n          .flat();\n        return result;\n      })\n      .flat();\n\n    const rows = token.rows\n      .map((row) => {\n        const result = row\n          .map((token) => {\n            const result = token.tokens\n              .map((x) => flattenMarkedTokenRecursive(x, findFunction))\n              .flat();\n\n            return result;\n          })\n          .flat();\n\n        return result;\n      })\n      .flat();\n\n    return [header, rows].flat();\n  }\n\n  if (token.type === \"list\") {\n    const result = token.items\n      .map((token) => {\n        const result = token.tokens\n          .map((x) => flattenMarkedTokenRecursive(x, findFunction))\n          .flat();\n        return result;\n      })\n      .flat();\n\n    return result;\n  }\n\n  if (\n    token.type === \"del\" ||\n    token.type === \"em\" ||\n    token.type === \"heading\" ||\n    token.type === \"link\" ||\n    token.type === \"paragraph\" ||\n    token.type === \"strong\"\n  ) {\n    const result = token.tokens\n      .map((x) => flattenMarkedTokenRecursive(x, findFunction))\n      .flat();\n    return result;\n  }\n\n  return [];\n}"
  },
  "cleanupTimer": {
    "name": "cleanupTimer",
    "slug": "TsFunction",
    "id": "lrzawfpocemqlsmnwefttkxz",
    "description": "Ensure you run this after finishing the measurement, or you'll run into memory leaks!",
    "operationName": "measure-performance",
    "rawText": " (uniqueId: string) => {\n  delete timer[uniqueId];\n}"
  },
  "generateUniqueId": {
    "name": "generateUniqueId",
    "slug": "TsFunction",
    "id": "ltevqbklhkskbesuihjgekpc",
    "description": "Bit annoying that we need to use all model-types here xD.\n\nTODO: Let's extrahere this",
    "operationName": "measure-performance",
    "rawText": " () => generateId()"
  },
  "getNewPerformance": {
    "name": "getNewPerformance",
    "slug": "TsFunction",
    "id": "abaqbnuyoiczrdhhxtyiwacn",
    "description": "Function that lets you measure performance inside any function with ease.\n\nUsage:\n\nFirstly, make a performance array, and a unique execution id, and start the measurement, like so:\n\n```ts\nimport { generateUniqueId, getNewPerformance, PerformanceItem, cleanupTimer } from \"measure-performance\";\n\nat the start of your function\n\nconst executionId = generateUniqueId();\nconst performance: (PerformanceItem | undefined)[] = [];\ngetNewPerformance(\"start\", executionId, true)\n```\n\n\nAfter that, push a new performance item at every step you want to measure. Provide your label describing what happened before this (the step you are measuring).\n\n\n```ts\nperformance.push(getNewPerformance(\"your label\", executionId));\n```\n\nAt the end of your function, you can view your performance array by printing it on the console (or store it somewhere if you like)\n\nDon't forget to run `cleanupTimer`, or you'll run into memory leaks!\n\n```ts\ncleanupTimer(executionId);\n```",
    "operationName": "measure-performance",
    "rawText": " (\n  label: string,\n  uniqueId: string,\n  isNew?: boolean\n): PerformanceItem | undefined => {\n  const timePrevious = timer[uniqueId];\n  const timeNow = Date.now();\n  timer[uniqueId] = timeNow;\n\n  if (isNew) return;\n\n  const durationMs = timeNow - timePrevious;\n\n  return { label, durationMs };\n}"
  },
  "timer": {
    "name": "timer",
    "slug": "TsVariable",
    "id": "hqgapslvuzjgddfsjchnkpjg",
    "description": "TODO: This stores into memory. May cause memory leaks in the long run if not cleaned up!",
    "operationName": "measure-performance"
  },
  "getLegacyMenu": {
    "name": "getLegacyMenu",
    "slug": "TsFunction",
    "id": "uujnybvlywiocvaijpqpfsdq",
    "description": "",
    "operationName": "menu",
    "rawText": " (queryPaths: string[]) => {\n  const projectNestedPathObject = queryPaths\n    ? queryPathsArrayToNestedPathObject(queryPaths)\n    : undefined;\n\n  /**\n   * This one too\n   */\n  const nestedMenu = projectNestedPathObject\n    ? nestedPathObjectToNestedMenuRecursive(projectNestedPathObject, [], {\n        getHref: (fullPath) => {\n          return fullPath;\n        },\n      })\n    : undefined;\n\n  const result = nestedMenu?.map((item) => {\n    const webPage: WebPage<null> = {\n      queryPath: item.title,\n      menuTitleTooltip: \"Should be replaced with WebPage model\",\n      pageData: null,\n    };\n\n    return webPage;\n  });\n\n  return result;\n}"
  },
  "minifyBuild": {
    "name": "minifyBuild",
    "slug": "TsFunction",
    "id": "kywyrnkixhelmfvjfprahnot",
    "description": "takes an operation name or build folder path, then explores all ts files in src folder, finds the matching js file in the build folder, and executes terser from dependency, not from cli",
    "operationName": "minify-build",
    "rawText": " async ({\n  operationName,\n  buildFolderPath,\n}: {\n  operationName?: string;\n  buildFolderPath?: string;\n}) => {\n  if (operationName) {\n    const operationFolderPath = await getOperationPath(operationName);\n\n    if (!operationFolderPath) {\n      log(`Can't find that operation`, { type: \"error\" });\n      return;\n    }\n\n    buildFolderPath = path.join(operationFolderPath, \"build\");\n  }\n\n  if (!buildFolderPath) {\n    log(\n      `minifyBuild: Please provide an existing operationName or a buildFolderPath`,\n      { type: \"error\" }\n    );\n    return;\n  }\n\n  const srcFolderPath = path.join(buildFolderPath, \"..\", \"src\");\n\n  if (!fs.existsSync(srcFolderPath)) {\n    log(`minifyBuild: ${srcFolderPath} not found, we can't minify`, {\n      type: \"error\",\n    });\n    return;\n  }\n\n  if (!fs.existsSync(buildFolderPath)) {\n    log(`minifyBuild: ${buildFolderPath} does not exist`, { type: \"error\" });\n    return;\n  }\n\n  const tsFilesExploreResult = await explore({\n    basePath: srcFolderPath,\n    extension: [\"ts\", \"tsx\"],\n  });\n  /**\n   * relative file paths from src, withtout extension\n   */\n  const absoluteJsPaths = tsFilesExploreResult\n    .map((x) => {\n      // get relative file path without extension\n      const parsedPath = path.parse(x.path);\n      const pathWithoutExtension = path.join(parsedPath.dir, parsedPath.name);\n\n      const relativeFileId = makeRelative(pathWithoutExtension, srcFolderPath);\n\n      return relativeFileId;\n    })\n\n    .map((relativeFilePath) => {\n      // use that to get js file in the build folder\n\n      const jsFilePath = path.join(\n        // NB: it's strange that it thinks that buildFolderPath can still be undefined here.\n        buildFolderPath!,\n        relativeFilePath.concat(\".js\")\n      );\n\n      return jsFilePath;\n    });\n\n  try {\n    await Promise.all(\n      absoluteJsPaths.map(async (jsFilePath) => {\n        const fileName = path.parse(jsFilePath).base;\n        const fileContent = await fs.readFile(jsFilePath, { encoding: \"utf8\" });\n        if (!fileContent || fileContent.length === 0) {\n          log(`Empty file found at ${jsFilePath}`, { type: \"error\" });\n          return;\n        }\n\n        // console.log(`minifying ${jsFilePath}`);\n\n        try {\n          const output = await minify(fileContent, {\n            mangle: true,\n            compress: true,\n            format: { comments: \"all\" },\n          });\n\n          // console.log({ output });\n\n          if (!output.code) {\n            log(`No code generated for ${jsFilePath}`, { type: \"error\" });\n            return;\n          } else {\n            await fs.writeFile(jsFilePath, output.code, {\n              encoding: \"utf8\",\n            });\n          }\n\n          // log(\"Written dist file\", { type: \"success\" });\n          return true;\n        } catch (e) {\n          console.log(`minify failed: catched: `, e);\n          return false;\n        }\n      })\n    );\n\n    return true;\n  } catch (e) {\n    log(`something went wrong with minification: ${e}`, { type: \"error\" });\n  }\n\n  return;\n}"
  },
  "generateId": {
    "name": "generateId",
    "slug": "TsFunction",
    "id": "gwadgivakccsjdenrgwlwvtb",
    "description": "24 characters of the alphabet provides 9E33 combinations, wont be possible to brute-force in centuries, even if there are billions of entries",
    "operationName": "model-types",
    "rawText": " (): Id => {\n  return generateRandomString(24).toLowerCase();\n}"
  },
  "generateRandomString": {
    "name": "generateRandomString",
    "slug": "TsFunction",
    "id": "wkcfbgiwswxfdxkrblsuvdpl",
    "description": "",
    "operationName": "model-types",
    "rawText": " (length: number) => {\n  const characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  const characterArray = \"x\".repeat(length).split(\"\");\n\n  const string: Id = characterArray\n    .map(() => {\n      const randomIndex = Math.floor(Math.random() * characters.length); //0-63 --> index for above\n      const character = characters.charAt(randomIndex);\n      return character;\n    })\n    .join(\"\");\n\n  return string;\n}"
  },
  "generateTime": {
    "name": "generateTime",
    "slug": "TsFunction",
    "id": "vxkbtfgfhqjghaovkemswogx",
    "description": "",
    "operationName": "model-types",
    "rawText": " (): Time => Date.now()"
  },
  "languages": {
    "name": "languages",
    "slug": "TsVariable",
    "id": "hiaxrsxxaywiahlcfspaubnj",
    "description": "keys are the iso codes which will be saved in the db, the values are values which can be shown to the user in any UI",
    "operationName": "model-types"
  },
  "assetsFolders": {
    "name": "assetsFolders",
    "slug": "TsVariable",
    "id": "tlaodkwuzwxzoazjqicznrcm",
    "description": "",
    "operationName": "name-conventions"
  },
  "generatedParameterNames": {
    "name": "generatedParameterNames",
    "slug": "TsVariable",
    "id": "wwvxxaefbpeliioaxganapgz",
    "description": "",
    "operationName": "name-conventions"
  },
  "getAssetInputType": {
    "name": "getAssetInputType",
    "slug": "TsFunction",
    "id": "pgqmumoyifjbqbyhbqwbxsol",
    "description": "Convention parameters for assets: [name], [name]s, xyz[Name], xyz[Name]s\n\nDifferent ways to name assets: `image`, `video`, `audio`, `file` or just `asset`, which is everything together",
    "operationName": "name-conventions",
    "rawText": " (\n  parameterName: string,\n  valueType?: SimplifiedSchemaType\n): AssetInputType | undefined => {\n  const lastWord = lowerCaseArray(parameterName).pop();\n  if (!lastWord) return;\n\n  const isObjectOrArray =\n    !valueType || valueType === \"array\" || valueType === \"object\";\n\n  if (!isObjectOrArray) return;\n\n  if (\n    [\"image\", \"video\", \"audio\", \"file\", \"asset\"].includes(singularize(lastWord))\n  ) {\n    return {\n      type: singularize(lastWord) as AssetInputType[\"type\"],\n      isMultiple: isPlural(lastWord),\n    };\n  }\n\n  return;\n}"
  },
  "getParameterContentType": {
    "name": "getParameterContentType",
    "slug": "TsFunction",
    "id": "extlhvskiyortvhpqbwelrlx",
    "description": "",
    "operationName": "name-conventions",
    "rawText": " (parameterName: string) => {\n  // todo: Match parameterName against all patterns in the ParameterName array until it finds one that matches\n  // 1) replace all patternmatch words with the %x\n  // 2) whatever's left, make sure to distinguish the descriptor from the type indicator (e.g. authorName indicates a nametype which is a string, while the descriptor is an author)\n  // 3) return some object that describes all the different parts individually and with that the whole name together. It can then be used in the admin UI to explain any type interface\n}"
  },
  "isCalculatedParameter": {
    "name": "isCalculatedParameter",
    "slug": "TsFunction",
    "id": "bhmnxbobfisxckeelzhmehjw",
    "description": "this is part of the database convention",
    "operationName": "name-conventions",
    "rawText": " (parameterName: string) => {\n  return (\n    generatedParameterNames.includes(parameterName) ||\n    parameterName.endsWith(\"Calculated\")\n  );\n}"
  },
  "isGeneratedParameterName": {
    "name": "isGeneratedParameterName",
    "slug": "TsFunction",
    "id": "dxabqxxzlysyoxnqycwmabwu",
    "description": "",
    "operationName": "name-conventions",
    "rawText": " (parameterName: string) => {\n  const generatedPatterns = parameterNames\n    .filter(\n      (x) => x.contentType.length === 1 && x.contentType[0] === \"generated\"\n    )\n    .map((x) => x.pattern);\n  // TODO: match the patterns against the name to find match\n}"
  },
  "markdownTextParameterNames": {
    "name": "markdownTextParameterNames",
    "slug": "TsVariable",
    "id": "jqwavmtqewurnnvivivxllht",
    "description": "Any parameter names that should render a textArea",
    "operationName": "name-conventions"
  },
  "parameterNames": {
    "name": "parameterNames",
    "slug": "TsVariable",
    "id": "kfnkxxdophrwwuiquliagueh",
    "description": "## Form input types\n\nHow do we show different UI's based on certain things we know about some parameter (name + type)? There are many things\n\n- All \"image\" or \"xxxImage\" should be Image + camera inputs\n- All \"asset\" or \"xxxAsset\" should be File inputs\n- All \"recording\" or \"xxxAudio\" should be mic inputs\n- All \"position\" or \"xxxPosition\" should be coordinates which should be pickable on the map\n- All \"path\" or \"xxxPath\" should be an input where you can select a relative path from project root or operation src root, depending on what we need. It needs to be clear what kind of paths are allowed, so we need to think about all the options and if we can all put that in the parameter name (would be best) or if we need to use the description...",
    "operationName": "name-conventions"
  },
  "passwordTextParameterNames": {
    "name": "passwordTextParameterNames",
    "slug": "TsVariable",
    "id": "njemkilousionjyfehibhisa",
    "description": "",
    "operationName": "name-conventions"
  },
  "patternMatchers": {
    "name": "patternMatchers",
    "slug": "TsVariable",
    "id": "rlxkrwoicqaowaedaihswlru",
    "description": "",
    "operationName": "name-conventions"
  },
  "referenceParameterNames": {
    "name": "referenceParameterNames",
    "slug": "TsVariable",
    "id": "ybawwsdzvqlgfbzwbycbtxsq",
    "description": "",
    "operationName": "name-conventions"
  },
  "referencePluralParameterNames": {
    "name": "referencePluralParameterNames",
    "slug": "TsVariable",
    "id": "nffuhpcbqxblzwqpexkowbxu",
    "description": "",
    "operationName": "name-conventions"
  },
  "getRealItemRecursive": {
    "name": "getRealItemRecursive",
    "slug": "TsFunction",
    "id": "ypckcvgdwybzpedfxoaceqhb",
    "description": "",
    "operationName": "nested-menu",
    "rawText": " (item: NestedWebPage): NestedWebPage => {\n  const getTitleExtension = (item: NestedWebPage) =>\n    item.children && item.children.length === 1\n      ? getTitle(item.children[0])\n      : \"\";\n\n  // with exactly 1 child, the titles should be combined, the menu should be flattened\n  return item.children && item.children.length === 1\n    ? getRealItemRecursive({\n        ...item.children[0],\n        menuTitle: getTitle(item) + \" ‣ \" + getTitleExtension(item),\n      })\n    : item;\n}"
  },
  "getTitle": {
    "name": "getTitle",
    "slug": "TsFunction",
    "id": "mrwbvdjmuniofrjonikhqpms",
    "description": "",
    "operationName": "nested-menu",
    "rawText": " (item: WebPage<null>): string => {\n  return item.menuTitle || getFileOrFolderName(item.queryPath);\n}"
  },
  "NestedMenuItem": {
    "name": "NestedMenuItem",
    "slug": "TsFunction",
    "id": "xygbdjvqathcpztlvmgynzaj",
    "description": "General purpose NestedMenuItem.\n----\n\nTODO:\n\n- tooltip support",
    "operationName": "nested-menu",
    "rawText": " (\n  props: {\n    item: NestedWebPage;\n    /**\n     * If true, items with a single child will be merged into the parent\n     */\n    mergeSingleChilds?: boolean;\n    headersClickable?: boolean;\n    level?: number;\n  } & MouseEventCallbacks\n) => {\n  const {\n    onClick,\n    onDoubleClick,\n    onContextMenu,\n    item,\n    level,\n    headersClickable,\n    mergeSingleChilds,\n  } = props;\n\n  const realItem: NestedWebPage = mergeSingleChilds\n    ? getRealItemRecursive(item)\n    : item;\n\n  const {\n    children,\n    target,\n    isMenuHidden,\n    menuTitleAugmentation,\n    menuTitleTooltip,\n    queryPath,\n  } = realItem;\n\n  const shownChildren = children?.filter((x) => !x.isMenuHidden);\n\n  const title = getTitle(realItem);\n\n  const router = useRouter();\n  const currentPath = router.asPath.substring(1).split(\"?\")[0];\n\n  const [isExpanded, toggleExpanded, setIsExpanded, setNotExpanded] =\n    useExpanded(queryPath);\n\n  const [isMobileMenuEnabled, setIsMobileMenuEnabled] = useStore(\n    \"menu.isMobileMenuEnabled\"\n  );\n\n  const isSelected = currentPath === queryPath;\n  const realLevel = level || 0;\n\n  const hasChildren = shownChildren && shownChildren.length > 0;\n\n  const isClickable = headersClickable || !hasChildren;\n  const textClassName = isClickable\n    ? `${isSelected ? \"text-blue-500\" : \"\"} hover:text-blue-800 `\n    : undefined;\n\n  const href = isSelected\n    ? undefined\n    : isClickable\n    ? !queryPath || queryPath.length === 0\n      ? \"/\"\n      : queryPath\n    : undefined;\n\n  const allChildrenWereHidden = children?.length && !shownChildren?.length;\n  return allChildrenWereHidden ? null : (\n    <Div className=\"w-full\">\n      <Div\n        className={`w-full flex flex-row justify-center items-center pr-4 ${\n          isClickable\n            ? `hover:bg-gray-200 hover:dark:bg-gray-800 ${\n                isSelected ? \"bg-gray-200 dark:bg-gray-800 \" : \"\"\n              }`\n            : \"\"\n        }`}\n      >\n        <ALink\n          style={{\n            paddingLeft: realLevel * 10 + 5,\n            paddingBottom: 10,\n            paddingTop: 10,\n          }}\n          className=\"flex flex-row justify-between\"\n          textClassName=\"flex flex-1 text-xs\"\n          href={href}\n          target={target}\n          onDoubleClick={(event) => event && onDoubleClick?.(event, realItem)}\n          onContextMenu={(event) => onContextMenu?.(event, realItem)}\n          onClick={(event) => {\n            if (isExpanded && isSelected) {\n              setNotExpanded();\n            } else {\n              onClick?.(event, realItem);\n              setIsExpanded();\n              if (!realItem.children) {\n                setIsMobileMenuEnabled(false);\n              }\n            }\n          }}\n        >\n          <Span\n            //line-clamp-1 truncate text-ellipsis\n            textClassName={textClassName}\n          >\n            {title}\n          </Span>\n          <Span className=\"flex flex-row\">\n            {menuTitleAugmentation ? (\n              <Span>{menuTitleAugmentation}</Span>\n            ) : null}\n          </Span>\n        </ALink>\n        {hasChildren ? (\n          <Div\n            className=\"text-3xl cursor-pointer\"\n            onClick={() => toggleExpanded()}\n          >\n            {isExpanded ? \"▾\" : \"▸\"}\n          </Div>\n        ) : null}\n      </Div>\n\n      {hasChildren && isExpanded ? (\n        <Div className=\"w-full\">\n          {shownChildren.map((child, i) => {\n            return (\n              <NestedMenuItem\n                key={`menu-${href}-${i}`}\n                item={child}\n                headersClickable={headersClickable}\n                level={realLevel + 1}\n              />\n            );\n          })}\n        </Div>\n      ) : null}\n    </Div>\n  );\n}"
  },
  "nestedMenuStoreInitialValues": {
    "name": "nestedMenuStoreInitialValues",
    "slug": "TsVariable",
    "id": "mziwsmbvbgcmusmdzbwylocu",
    "description": "",
    "operationName": "nested-menu"
  },
  "NestedMenu": {
    "name": "NestedMenu",
    "slug": "TsFunction",
    "id": "oqlcugjmwuguigtwzntiuake",
    "description": "General purpose nested menu component\n\nPlease make sure that you also wrap your app with `MenuStoreProvider`, or this will crash...!",
    "operationName": "nested-menu",
    "rawText": " (\n  props: {\n    items?: NestedWebPage[];\n    headersClickable?: boolean;\n  } & MouseEventCallbacks\n) => {\n  const router = useRouter();\n  const [expanded, setExpanded, { hydrated }] = useStore(\"menu.expanded\");\n\n  const expandCompleteUrlInMenu = () => {\n    const parts = trimSlashes(router.asPath).split(\"/\");\n    const cummulativeParts = parts\n      .map((part, index, array) => {\n        if (part === \"\") return;\n        return array.slice(0, index + 1).join(\"/\");\n      })\n      .filter(notEmpty);\n    const cumulativePartsExpandedObject = mergeObjectsArray(\n      cummulativeParts.map((url) => ({ [url]: true }))\n    );\n    setExpanded({ ...expanded, ...cumulativePartsExpandedObject });\n  };\n  useEffect(() => {\n    expandCompleteUrlInMenu();\n  }, [router.asPath]);\n\n  const { items, ...menuItemProps } = props;\n  const menuItems = items\n    ?.filter((x) => !x.isMenuHidden)\n    .map((nestedWebPage, index) => {\n      return (\n        <NestedMenuItem\n          mergeSingleChilds\n          item={nestedWebPage}\n          key={`menu${index}`}\n          {...menuItemProps}\n        />\n      );\n    });\n\n  return <Div className=\"w-full\">{menuItems}</Div>;\n}"
  },
  "useExpanded": {
    "name": "useExpanded",
    "slug": "TsFunction",
    "id": "arazbhrnzpuzwjeykspvxpfy",
    "description": "",
    "operationName": "nested-menu",
    "rawText": " (queryPath: string = \"\") => {\n  const [expanded, setExpanded, { hydrated }] = useStore(\"menu.expanded\");\n\n  const isExpanded =\n    expanded[queryPath] !== undefined ? expanded[queryPath] : false;\n\n  // console.log({ queryPath, isExpanded });\n  const setIsExpanded = () => {\n    return setExpanded({ ...expanded, [queryPath]: true });\n  };\n\n  const setNotExpanded = () => {\n    return setExpanded({ ...expanded, [queryPath]: false });\n  };\n\n  const toggleExpanded = () => {\n    return setExpanded({\n      ...expanded,\n      [queryPath]: !isExpanded,\n    });\n  };\n\n  const tuple: [\n    boolean,\n    () => Promise<void>,\n    () => Promise<void>,\n    () => Promise<void>,\n    { hydrated: boolean }\n  ] = [isExpanded, toggleExpanded, setIsExpanded, setNotExpanded, { hydrated }];\n\n  return tuple;\n}"
  },
  "getAvailableOperationName": {
    "name": "getAvailableOperationName",
    "slug": "TsFunction",
    "id": "jmwskvakbifpdtpkbwsafgcx",
    "description": "returns folder name\n\nfinds the first foldername that is available in this folder but also there is nowhere an operation already with this name\n\nthere is also getAvailableFolderPath for non-operation folders",
    "operationName": "new-template",
    "rawText": " async (\n  rootFolderPath: string,\n  preferredFolderName: string,\n  manualProjectRoot?: string\n): Promise<string> => {\n  //making sure we make a folder that doesn't exist yet:\n  let n = 0;\n  let availableFolderName = preferredFolderName;\n\n  while (true) {\n    const folderAlreadyExists = fs.existsSync(\n      path.join(rootFolderPath, availableFolderName)\n    );\n\n    const operationAlreadyExists =\n      (await getOperationPath(availableFolderName, {\n        manualProjectRoot,\n        notUseSdk: !!manualProjectRoot,\n      })) !== undefined;\n\n    if (!folderAlreadyExists && !operationAlreadyExists) break;\n\n    n++;\n    availableFolderName = `${preferredFolderName}${n}`;\n  }\n\n  return availableFolderName;\n}"
  },
  "newOperationCli": {
    "name": "newOperationCli",
    "slug": "TsFunction",
    "id": "khzjggvtsnywtohayuynzmwb",
    "description": "newOperation also works as CLI\n\nexample: `newOperation [operation-name] [type]` in the folder where you want to create it. Optionally you can specify the type of operation as the second argument of the CLI\n\nArguments (all optional):\n- name: string\n- type: `OperationClassification`\n- description: string\n- destinationPath: string",
    "operationName": "new-template",
    "rawText": " async () => {\n  const [name, type, description, destinationPath] = process.argv.slice(2);\n\n  log(`Let's make a ${type || \"node-cjs\"} operation called ${name}`, {\n    type: \"important\",\n  });\n  console.log(\"All types possible:\", operationClassificationConst.join(\", \"));\n\n  await newOperation(name, {\n    type: type as OperationClassification,\n    description,\n    destinationPath,\n  });\n\n  console.log(`Generated operation`, {\n    name,\n    type,\n    description,\n    destinationPath,\n  });\n}"
  },
  "newOperationWithFiles": {
    "name": "newOperationWithFiles",
    "slug": "TsFunction",
    "id": "eavljdtftapztikulyvalybm",
    "description": "Creates a new operation with files with content\n\nReturns the final operation base path (or undefined if something went wrong)\n\nNB: relative paths must be relative to OPERATION ROOT, not src root! They must also lead to files in src, this thing is still buggy otherwise!\n\nTODO: Remove the buggyness",
    "operationName": "new-template",
    "rawText": " async (\n  name: string,\n  description: string | undefined,\n  /**\n   * NB: relative paths must be relative to OPERATION ROOT, not src root!\n   */\n  srcFileContentObject: {\n    [operationRelativeTypescriptFilePath: string]: string;\n  },\n  config?: {\n    manualProjectRoot?: string;\n    /**\n     * folder path without the folder name of the package to be created\n     *\n     * if given, will place it here, otherwise, will place it in the default location (tools/generated for os projects, packages for bundled projects)\n     */\n    destinationPath?: string;\n    /**\n     * if true, overwrites the operation if it already exists. It does this in a way that it does not break the OS very long, because it removes the old one only after the new one has been created. The removal and renaming the new one to this target name happens almost instantaneously\n     */\n    overwriteIfExists?: boolean;\n    overwriteCurrentOperationIfExists?: boolean;\n    /**\n     * if the operation did not exist before, `yarn install` will usually be ran.\n     *\n     * If you want to skip that, set this to `true`\n     *\n     */\n    skipYarnInstall?: boolean;\n\n    /**\n     * skips yarn build if `true`\n     */\n    skipYarnBuild?: boolean;\n    /**\n     * don't write anything, just return the files to create with the strings\n     */\n    dryrun?: boolean;\n  }\n): Promise<undefined | string> => {\n  // 1. calculates operation base path\n  const projectRoot = config?.manualProjectRoot || getProjectRoot();\n  if (!projectRoot) {\n    log(\"Not found projectroot\", { type: \"error\" });\n    return;\n  }\n\n  const defaultDestinationPath = isBundle(projectRoot)\n    ? path.join(projectRoot, \"packages\", \"generated\")\n    : path.join(projectRoot, projectRelativeGeneratedOperationsFolder);\n  const destinationPath = config?.destinationPath || defaultDestinationPath;\n\n  // 2. calculate simplest index.ts (no exposure of merged types object or tests)\n  const indexFileContent = Object.keys(srcFileContentObject)\n    .map((operationRelativeTypescriptFilePath) => {\n      return `export * from \"./${getSrcRelativeFileId(\n        operationRelativeTypescriptFilePath\n      )}\";`;\n    })\n    .join(\"\\n\");\n\n  const srcFileContentObjectWithIndex: {\n    [operationRelativeTypescriptFilePath: string]: string;\n    \"src/index.ts\": string;\n  } = { ...srcFileContentObject, \"src/index.ts\": indexFileContent };\n\n  if (config?.dryrun) {\n    await Promise.all(\n      Object.keys(srcFileContentObject).map((operationRelativePath) => {\n        const assetsPath = path.join(\n          __dirname,\n          \"..\",\n          \"assets\",\n          \"generated\",\n          operationRelativePath\n        );\n\n        console.log(`written to ${assetsPath}`);\n\n        return writeStringToFile(\n          assetsPath,\n          srcFileContentObject[operationRelativePath]\n        );\n      })\n    );\n\n    return;\n  }\n  // 3. make new operation\n\n  const actualBasePath = await newOperation(name, {\n    destinationPath,\n    description,\n    manualProjectRoot: projectRoot,\n  });\n\n  if (!actualBasePath) {\n    log(\"Failed creating new operation\", { type: \"error\" });\n    return;\n  }\n\n  if (!fs.existsSync(actualBasePath)) {\n    log(`actualBasePath does not exist: ${actualBasePath}`, { type: \"error\" });\n    return;\n  }\n\n  // The wished base path\n  const wishedBasePath = path.join(destinationPath, name);\n\n  // 4. write files to src\n  await objectMapAsync(\n    srcFileContentObjectWithIndex,\n    async (operationRelativeTypescriptFilePath, content) => {\n      const srcPath = path.join(\n        actualBasePath,\n        operationRelativeTypescriptFilePath\n      );\n\n      await writeStringToFile(srcPath, content);\n\n      return;\n    }\n  );\n\n  /** NB: if this is true, the operation is new and has a never-used name, this means it also needs to be installed before building! */\n  const isOperationNew = wishedBasePath !== actualBasePath;\n\n  const shouldOverwrite =\n    isOperationNew &&\n    config?.overwriteIfExists &&\n    fs.existsSync(wishedBasePath);\n\n  const finalOperationBasePath = shouldOverwrite\n    ? wishedBasePath\n    : actualBasePath;\n\n  // 6. yarn build there\n\n  if (!config?.skipYarnInstall) {\n    // in case this operation didn't exist before, run `yarn --offline`\n    // NB: this assumes we already have node_modules and the new operation has no weird new dependencies\n    spawnSync(\"yarn --offline\", {\n      cwd: actualBasePath,\n      encoding: \"utf8\",\n      stdio: \"inherit\",\n      shell: false,\n    });\n  }\n\n  // NB: if skipYarnInstall is enabled, we will also not build\n  const noBuild = config?.skipYarnBuild; // || config?.skipYarnInstall;\n\n  if (!noBuild) {\n    const isSuccesful = await yarnBuild(actualBasePath);\n\n    if (!isSuccesful) {\n      log(\"Building failed\", { type: \"error\" });\n      return;\n    }\n  }\n\n  // remove operation if it's already there and rename new operation to that target name\n  if (shouldOverwrite) {\n    /**\n     * first set the name to the same as the to be removed folder.\n     * NB: there are now two packages with the same name, yarn install will error\n     */\n    const packageJsonPath = path.join(actualBasePath, \"package.json\");\n    const hasAvailablePackageJson =\n      fs.existsSync(packageJsonPath) && (await canRead(packageJsonPath));\n    if (!hasAvailablePackageJson) {\n      return;\n    }\n\n    await setJsonKey({\n      jsonPath: packageJsonPath,\n      keyLocation: \"name\",\n      value: name,\n    });\n\n    if (fs.existsSync(wishedBasePath)) {\n      //then remove the original operation\n      await fs.rm(wishedBasePath, { recursive: true });\n    }\n\n    if (fs.existsSync(actualBasePath)) {\n      // then rename the new operation to the original operation path\n      await fs.rename(actualBasePath, wishedBasePath);\n    }\n  }\n\n  return finalOperationBasePath;\n}"
  },
  "newOperation": {
    "name": "newOperation",
    "slug": "TsFunction",
    "id": "yvwuhdptwyoypbmbhcclmvqt",
    "description": "# How to create a package/operation?\n\nThis cli creates the correct tsconfig.json, package.json, .gitignore, folder setup, so you can get started immedeately.\n\nReturns either the `operationBasePath` of the created operation, or undefined if something went wrong",
    "operationName": "new-template",
    "rawText": " async (\n  name?: string,\n  config?: NewOperationConfig\n): Promise<string | undefined> => {\n  // NB: if we don't specify the type, create a node operation by default\n  const type = config?.type || \"node-cjs\";\n\n  const description = config?.description;\n  const destinationPath = config?.destinationPath;\n  const manualProjectRoot = config?.manualProjectRoot;\n  const folder = name ? kebabCase(name) : \"untitled-operation\";\n  const source = path.resolve(__dirname, \"..\", \"assets\", \"templates\", type);\n  const templateExists = fs.existsSync(source);\n\n  if (!templateExists) {\n    log(\n      `${type} operations cannot be generated yet. Create a template in assets/templates/${type}`\n    );\n    return;\n  }\n\n  const rootFolderPath = destinationPath ? destinationPath : process.cwd();\n  const availableFolderName = await getAvailableOperationName(\n    rootFolderPath,\n    folder,\n    manualProjectRoot\n  );\n\n  const operationBasePath = path.join(rootFolderPath, availableFolderName);\n\n  // Make the non-existing folder\n  await fs.mkdir(operationBasePath, { recursive: true });\n  // Copy the template inthere\n  await fs.cpAsync(source, operationBasePath, { recursive: true });\n  // Rename templatefiles if needed\n  await renameTemplateFiles({ appDir: operationBasePath });\n\n  const packageJsonPath = path.join(operationBasePath, \"package.json\");\n\n  const hasAvailablePackageJson =\n    fs.existsSync(packageJsonPath) && (await canRead(packageJsonPath));\n  if (!hasAvailablePackageJson) {\n    log(\"The template package.json was not copied succesfully\", {\n      type: \"error\",\n    });\n    return;\n  }\n\n  await setJsonKey({\n    jsonPath: packageJsonPath,\n    keyLocation: \"name\",\n    value: availableFolderName,\n  });\n\n  if (description) {\n    await setJsonKey({\n      jsonPath: packageJsonPath,\n      keyLocation: \"description\",\n      value: description,\n    });\n  }\n\n  return operationBasePath;\n}"
  },
  "newTemplateCli": {
    "name": "newTemplateCli",
    "slug": "TsFunction",
    "id": "beegbgnngbeoobmtraoaahuq",
    "description": "newTemplate can be used as CLI:\n\nArguments:\n- type (required): a folder from `new-template/assets/templates`\n- destinationPath (optional): path where the template should be copied to (uses `cwd` by default)",
    "operationName": "new-template",
    "rawText": " () => {\n  const [type, destinationPath] = process.argv.slice(2);\n\n  newTemplate(type, destinationPath).then((basePath) => {\n    if (basePath) {\n      console.log(`Generated template`, { type });\n    } else {\n      console.log(\"Something went wrong\");\n    }\n  });\n}"
  },
  "newTemplate": {
    "name": "newTemplate",
    "slug": "TsFunction",
    "id": "fttyjiszghrghoykklihhtdn",
    "description": "Returns either the `basePath` of the created template, or undefined if something went wrong",
    "operationName": "new-template",
    "rawText": " async (\n  type: string,\n  destinationPath?: string\n): Promise<string | undefined> => {\n  const manualProjectRoot = getProjectRoot(destinationPath);\n\n  const source = path.resolve(__dirname, \"..\", \"assets\", \"templates\", type);\n  const templateExists = fs.existsSync(source);\n\n  if (!templateExists) {\n    log(\n      `${type} cannot be generated yet. Create a template in assets/templates/${type}`\n    );\n    return;\n  }\n\n  const basePath = destinationPath\n    ? destinationPath\n    : path.join(process.cwd(), type);\n  // const availableFolderName = await getAvailableOperationName(\n  //   rootFolderPath,\n  //   type,\n  //   manualProjectRoot\n  // );\n\n  // const basePath = path.join(rootFolderPath, availableFolderName);\n\n  // if (fs.existsSync(basePath)) {\n  //   log(`${basePath} already exists`);\n  //   return;\n  // }\n  // Make the non-existing folder\n  await fs.mkdir(basePath, { recursive: true });\n  // Copy the template inthere\n  await fs.cpAsync(source, basePath, { recursive: true });\n  // Rename templatefiles if needed\n  await renameTemplateFiles({ appDir: basePath });\n\n  return basePath;\n}"
  },
  "ALink": {
    "name": "ALink",
    "slug": "TsFunction",
    "id": "kzsdsdovihglboxenabtzpie",
    "description": "A simple wrapper around react-with-native A and next-link\n\nAll links you make with this component are SEO-ready",
    "operationName": "next-a-link",
    "rawText": " ({\n  children,\n  href,\n  target,\n  rel,\n  linkProps,\n  ...otherAProps\n}: { linkProps?: LinkProps } & AType) => {\n  return (\n    <Link {...linkProps} href={href || \"#\"} passHref>\n      <A {...otherAProps} rel={rel} target={target}>\n        {children}\n      </A>\n    </Link>\n  );\n}"
  },
  "getFullPath": {
    "name": "getFullPath",
    "slug": "TsFunction",
    "id": "ufqzovfuzrpjwbetyadgogbj",
    "description": "gets a path string from `next.js` `router.query`.",
    "operationName": "next-paths",
    "rawText": " (\n  /**\n   * paths coming from `router.query`\n   *\n   * supposed to be a path/url refering to a file/page that can be represented with slashes in between\n   */\n  paths: string | string[] | undefined\n): string => {\n  return typeof paths === \"string\"\n    ? paths\n    : Array.isArray(paths)\n    ? paths.join(\"/\")\n    : \"\";\n}"
  },
  "getLastPathsChunk": {
    "name": "getLastPathsChunk",
    "slug": "TsFunction",
    "id": "hiynmuuikidqzfrqyzmqxsyj",
    "description": "returns the last chunk of the path",
    "operationName": "next-paths",
    "rawText": " (\n  /**\n   * paths coming from `router.query`\n   */\n  paths: string | string[] | undefined\n) => {\n  return Array.isArray(paths) ? paths[paths.length - 1] : paths;\n}"
  },
  "usePath": {
    "name": "usePath",
    "slug": "TsFunction",
    "id": "hfertoebkaxpeviycyndawnh",
    "description": "uses `useRouter` from `next.js` to get the lastChunk and the `fullPath` out of the `paths`. Assumes you have a page in your next.js project called `[...paths]`.",
    "operationName": "next-paths",
    "rawText": " () => {\n  const router = useRouter();\n  const paths = router.query?.paths;\n  const lastChunk = getLastPathsChunk(paths);\n  const fullPath = getFullPath(paths);\n  return { lastChunk, fullPath };\n}"
  },
  "nodemon": {
    "name": "nodemon",
    "slug": "Operation",
    "id": "IzGAOgwTzdWieQVE",
    "operationName": "nodemon"
  },
  "oneByOne": {
    "name": "oneByOne",
    "slug": "TsFunction",
    "id": "arqtrikqrnogqhljfjofppch",
    "description": "for every item in an array, executes an async callback, one by one.\npromises an array of the results of every callback once it's done",
    "operationName": "one-by-one",
    "rawText": " async <T, U>(\n  array: T[],\n  callback: (instance: T, index: number) => Promise<U>\n): Promise<U[]> => {\n  const getResults = async (\n    results: Promise<U[]>,\n    instance: T,\n    index: number\n  ) => {\n    const awaitedResults = await results;\n    const result: U = await callback(instance, index);\n    const newResults = [...awaitedResults, result];\n    return newResults;\n  };\n\n  const result = await array.reduce(\n    getResults,\n    new Promise<U[]>((resolve) => resolve([]))\n  );\n\n  return result;\n}"
  },
  "getDependenciesSummary": {
    "name": "getDependenciesSummary",
    "slug": "TsFunction",
    "id": "iigkxqhtncgirtdsydhzaifq",
    "description": "",
    "operationName": "operation-util",
    "rawText": " async (operationName: string) => {\n  const operationImports = await db.get(\"TsImport\", {\n    operationName,\n  });\n\n  const coreDependencies = operationImports\n    .filter((x) => [\"node\", \"react\"].includes(x.classification))\n    .map((x) => x.name);\n  const operationDependencies = operationImports\n    .filter((x) => [\"operation\"].includes(x.classification))\n    .map((x) => x.name);\n  const packageDependencies = operationImports\n    .filter((x) => [\"package\"].includes(x.classification))\n    .map((x) => x.name);\n\n  return {\n    coreDependencies,\n    operationDependencies,\n    packageDependencies,\n  };\n}"
  },
  "getOperationMetaData": {
    "name": "getOperationMetaData",
    "slug": "TsFunction",
    "id": "opdlwczgccpbkgamiueowznh",
    "description": "gets a whole bunch of metadata about an operation, mainly filepath related, but it also reads the operation index json file",
    "operationName": "operation-util",
    "rawText": " async (\n  /**\n   * any path in an operation\n   */\n  operationBasePath: string\n): Promise<undefined | OperationMetaData> => {\n  if (!operationBasePath) return;\n  const projectRoot = getProjectRoot(operationBasePath);\n  if (!projectRoot) return;\n  const packageJson = await getPackageJson({\n    operationFolderPath: operationBasePath,\n  });\n  const operationName = packageJson?.name;\n\n  if (!operationName) {\n    return;\n  }\n  const srcPath = path.join(operationBasePath, \"src\");\n  const operationFolderName = getLastFolder(operationBasePath);\n\n  const operations = await db.get(\"Operation\", { operationName });\n  const operation: Operation | undefined = takeFirst(operations);\n\n  const relativeOperationLocationPath = makeRelative(\n    path.join(operationBasePath, \"..\"),\n    projectRoot\n  );\n  if (!relativeOperationLocationPath) return;\n\n  return {\n    operationBasePath,\n    operation,\n    operationName,\n    srcPath,\n    operationFolderName,\n    /**\n     * where the operation is located relative to the project root\n     */\n    relativeOperationLocationPath,\n  };\n}"
  },
  "recalculateOperationIndexJson": {
    "name": "recalculateOperationIndexJson",
    "slug": "TsFunction",
    "id": "yzlljatiodcmzgajigqincjf",
    "description": "Recalculates some operation indexable things and updates that into the database",
    "operationName": "operation-util",
    "rawText": " async (\n  operationBasePath: string,\n  manualProjectRoot?: string\n) => {\n  const operationMetaData = await getOperationMetaData(operationBasePath);\n\n  if (!operationMetaData) {\n    log(`Operation on ${operationBasePath} doesn't have a basepath`, {\n      type: \"error\",\n    });\n    return;\n  }\n\n  const {\n    operation,\n    operationFolderName,\n    operationName,\n    relativeOperationLocationPath,\n  } = operationMetaData;\n\n  if (!operation || !operationName || !relativeOperationLocationPath) {\n    log(\n      `Operation on ${operationBasePath} doesn't have a name or relativeOperationLocationPath or package.json`,\n      { type: \"error\" }\n    );\n    return;\n  }\n\n  const classificationIndexed = getOperationClassification(operationBasePath)!; //NB: we know it's there because operationBasePath must be valid\n\n  const { coreDependencies, operationDependencies, packageDependencies } =\n    await getDependenciesSummary(operationName);\n\n  const categories = await categorizeFiles({\n    basePath: operationBasePath,\n    ignoreIndexFiles: true,\n  });\n\n  const sizeIndexed = await getFolderSummary(categories);\n  // console.log(\"UPDATE QUERY\");\n  await db.update(\n    \"Operation\",\n    (item) => item.name === operation.name,\n    (old) =>\n      mergeNestedObject(old, {\n        operation: {\n          lastRebuildAt: Date.now(),\n          sizeIndexed,\n          folderNameIndexed: operationFolderName,\n          relativeOperationLocationPathIndexed: relativeOperationLocationPath,\n          classificationIndexed,\n          coreDependenciesIndexed: coreDependencies,\n          operationDependenciesIndexed: operationDependencies,\n          packageDependenciesIndexed: packageDependencies,\n        },\n      }),\n    { operationName: operation.name }\n  );\n}"
  },
  "parsePrimitiveArray": {
    "name": "parsePrimitiveArray",
    "slug": "TsFunction",
    "id": "ryzdmmhbjkliacnawbkujaqk",
    "description": "",
    "operationName": "parse-primitive",
    "rawText": " (string: string) => {\n  const result = string.split(\",\").map((x) => x.trim());\n  return result;\n}"
  },
  "parsePrimitiveBoolean": {
    "name": "parsePrimitiveBoolean",
    "slug": "TsFunction",
    "id": "lrowdkiuhkztequqkgbhrpcy",
    "description": "",
    "operationName": "parse-primitive",
    "rawText": " (string: string) => {\n  if (string.trim() === \"true\") return true;\n  if (string.trim() === \"false\") return false;\n}"
  },
  "parsePrimitiveString": {
    "name": "parsePrimitiveString",
    "slug": "TsFunction",
    "id": "zbvnqdrtvkzdhkwbtjqxkurv",
    "description": "",
    "operationName": "parse-primitive",
    "rawText": " (string: string) => {\n  if (string.startsWith('\"') && string.endsWith('\"')) {\n    return string.substring(1, string.length - 1);\n  }\n  if (string.charAt(0) === \" \") return string.slice(1);\n  return string;\n}"
  },
  "parsePrimitive": {
    "name": "parsePrimitive",
    "slug": "TsFunction",
    "id": "ibxnbrhfkieerczjeywijwkq",
    "description": "parses a string into the value it should be\n\nif you provide a `simplifiedSchema`, that will be used to parse according to the shape of the schema",
    "operationName": "parse-primitive",
    "rawText": " (\n  string: string,\n  simplifiedSchema?: SimplifiedSchema\n): PrimitiveResult => {\n  if (simplifiedSchema) {\n    if (simplifiedSchema.type === \"boolean\") {\n      const parsedBoolean = parsePrimitiveBoolean(string);\n      return parsedBoolean || false;\n    }\n\n    if (simplifiedSchema.type === \"null\") {\n      return null;\n    }\n    if (simplifiedSchema.type === \"number\") {\n      return !isNaN(Number(string)) ? Number(string) : undefined;\n    }\n\n    if (simplifiedSchema.type === \"string\") {\n      return parsePrimitiveString(string);\n    }\n\n    if (simplifiedSchema.type === \"array\") {\n      return parsePrimitiveArray(string);\n    }\n  }\n\n  // NB: failsafes\n  if (string === undefined) return undefined;\n  if (string === null) return null;\n\n  const parsedBoolean = parsePrimitiveBoolean(string);\n  if (parsedBoolean !== undefined) return parsedBoolean;\n\n  if (string === \"true\") return true;\n  if (string === \"false\") return false;\n  if (string === \"null\") return null;\n  if (string === \"undefined\") return undefined;\n  // NB: an empty string will count as 0 in the next statement\n  if (string === \"\") return \"\";\n  if (!isNaN(Number(string))) return Number(string);\n  return parsePrimitiveString(string);\n}"
  },
  "calculatePathMetaData": {
    "name": "calculatePathMetaData",
    "slug": "TsFunction",
    "id": "rhvmoyvychqdfmldzviqekjd",
    "description": "for folders: finds all files used for calculation and uses sumPathMetaData to create a new PathMetaData.\nfor files: just calculates the path metadata",
    "operationName": "path-util",
    "rawText": " async (\n  absolutePath: string\n): Promise<PathMetaData | undefined> => {\n  const exists = fs.existsSync(absolutePath);\n  if (!exists) return;\n  const pathParse = getPathParse(absolutePath);\n  if (!pathParse) return;\n\n  const stats = await fs.stat(absolutePath);\n  const isFolder = stats.isDirectory();\n  const fullFileName = isFolder ? undefined : path.parse(absolutePath).base;\n\n  const fileType = isFolder ? null : determineFileType(absolutePath);\n\n  const categorizedFiles: CategorizedFilePaths = isFolder\n    ? await categorizeFiles({ basePath: absolutePath })\n    : {\n        code: fileType === \"code\" ? [absolutePath] : [],\n        data: fileType === \"data\" ? [absolutePath] : [],\n        text: fileType === \"text\" ? [absolutePath] : [],\n      };\n\n  const folderSummary = await getFolderSummary(categorizedFiles);\n  const mainComment = await getPathMainComment(absolutePath);\n\n  const pathMetaData: PathMetaData = {\n    mainComment,\n    fullFileName,\n    createdAt: stats.ctimeMs,\n    updatedAt: stats.mtimeMs,\n    ...pathParse,\n    sizes: folderSummary,\n  };\n\n  return pathMetaData;\n}"
  },
  "categorizeFiles": {
    "name": "categorizeFiles",
    "slug": "TsFunction",
    "id": "bjdyjbqmlzyvvlcqdbupcnew",
    "description": "explores files in an operation within a specified location or from a specified type",
    "operationName": "path-util",
    "rawText": " async ({\n  basePath,\n  type,\n  ignoreIndexFiles,\n}: {\n  basePath: string | string[];\n  /**\n   * ignore index files or not\n   */\n  ignoreIndexFiles?: boolean;\n  /**\n   * if given, only search for files of a specific containing data type\n   */\n  type?: \"code\" | \"data\" | \"text\";\n}): Promise<CategorizedFilePaths> => {\n  const defaultIgnore = [\"node_modules\", databaseFolderName, buildFolderName];\n\n  const filePaths = (\n    await explore({\n      basePath,\n      extension: type ? (extensions[type] as SearchableExtension[]) : undefined,\n      ignore: ignoreIndexFiles\n        ? [\"index.ts\", \"index.tsx\", ...defaultIgnore]\n        : defaultIgnore,\n    })\n  ).map((x) => x.path);\n\n  return filePaths.reduce(\n    (categorizedFilePathsObject, filePath) => {\n      const fileType = determineFileType(filePath);\n      // console.log({ filePath, fileType });\n      if (!fileType) return categorizedFilePathsObject;\n\n      categorizedFilePathsObject[fileType].push(filePath);\n\n      return categorizedFilePathsObject;\n    },\n    { code: [] as string[], data: [] as string[], text: [] as string[] }\n  );\n}"
  },
  "getFolderSummary": {
    "name": "getFolderSummary",
    "slug": "TsFunction",
    "id": "ejufzzxdgcxybadtwhgxypot",
    "description": "calculates folder summary from a categorized file paths object",
    "operationName": "path-util",
    "rawText": " async (\n  categorizedFiles: CategorizedFilePaths\n): Promise<FolderSummary> => {\n  const categoriesSummary: Omit<FolderSummary, \"size\"> = {\n    codeSize: await sumSizeSummary(categorizedFiles.code),\n    dataSize: await sumSizeSummary(categorizedFiles.data),\n    textSize: await sumSizeSummary(categorizedFiles.text),\n  };\n\n  const folderSummary: FolderSummary = {\n    ...categoriesSummary,\n    size: sumAllKeys(Object.values(categoriesSummary), [\n      \"bytes\",\n      \"characters\",\n      \"lines\",\n      \"numberOfFiles\",\n    ]),\n  };\n\n  return folderSummary;\n}"
  },
  "getPathMainComment": {
    "name": "getPathMainComment",
    "slug": "TsFunction",
    "id": "uqututmyygsjirnuaofyshph",
    "description": "export const sumFolderSummary = (\nfirstFolderSummary: FolderSummary,\nsecondFolderSummary: FolderSummary\n): FolderSummary => {\nconst folderSummaryKeys = Object.keys(\nfirstFolderSummary\n) as (keyof FolderSummary)[];\nconst sum = mergeObjectsArray(\nfolderSummaryKeys.map((keyName) => {\nreturn {\n[keyName]: sumAllKeys([\nfirstFolderSummary[keyName],\nsecondFolderSummary[keyName],\n],[\"bytes\",\"characters\",\"lines\",\"numberOfFiles\"]),\n};\n})\n) as FolderSummary;\n\nreturn sum;\n};\n\n\ntakes all PathMetaData of an array that contains all child files, and merges them, taking the newest update date, the earliest created-date, and summing size\n\nexport const sumFileGeneralMetaData = async (\nchildrenMetaDataArray: PathGeneralMetaData[]\n): Promise<PathGeneralMetaData | null> => {\nconst sum = childrenMetaDataArray.reduce(\n(sumMetaData, pathMetaData: PathGeneralMetaData) => {\nconst newPathMetaData: PathGeneralMetaData = {\ncreatedAt:\n!sumMetaData || pathMetaData.createdAt < sumMetaData.createdAt\n? pathMetaData.createdAt\n: sumMetaData.createdAt,\nupdatedAt:\n!sumMetaData || pathMetaData.updatedAt > sumMetaData.updatedAt\n? pathMetaData.updatedAt\n: sumMetaData.updatedAt,\nsizes: !sumMetaData\n? pathMetaData.sizes\n: sumFolderSummary(sumMetaData.sizes, pathMetaData.sizes),\n};\n\nreturn newPathMetaData;\n},\nnull as PathGeneralMetaData | null\n);\n\nreturn sum;\n};",
    "operationName": "path-util",
    "rawText": " async (\n  absolutePath: string\n): Promise<TsComment | undefined> => {\n  const indexId = await getIndexId(absolutePath, getLastFolder(absolutePath));\n  if (!indexId) return;\n  const folderPath = getFolder(absolutePath);\n  const folderFiles = await fs.readdir(folderPath, \"utf8\");\n  const foundReadmePath = folderFiles.find(\n    (x) => path.parse(x).name.toLowerCase() === \"readme\"\n  );\n\n  const readmeExists = !!foundReadmePath;\n\n  const markdown = readmeExists\n    ? await fs.readFile(foundReadmePath, \"utf8\")\n    : \"\";\n  const { raw: comment, parameters } = parseFrontmatterMarkdownString(markdown);\n\n  const types = findCommentTypes(comment);\n\n  const mainComment: TsComment | undefined = {\n    rawStatement: undefined,\n    statementName: undefined,\n    ...indexId,\n    comment,\n    parameters,\n    types,\n    firstLine: 0,\n    lastLine: getNumberOfLines(markdown),\n  };\n\n  return mainComment;\n}"
  },
  "sumSizeSummary": {
    "name": "sumSizeSummary",
    "slug": "TsFunction",
    "id": "hopaqplnsnbhczjzooprpnvd",
    "description": "",
    "operationName": "path-util",
    "rawText": " async (\n  filePaths: string[]\n): Promise<SizeSummary> => {\n  const sizeSummaries = await Promise.all(filePaths.map(getSizeSummary));\n  const summed = sumAllKeys(sizeSummaries, [\n    \"numberOfFiles\",\n    \"lines\",\n    \"characters\",\n    \"bytes\",\n  ]);\n  return summed;\n}"
  },
  "addPeerMessage": {
    "name": "addPeerMessage",
    "slug": "TsFunction",
    "id": "ppfjfsqpixmafqlndtpsqawc",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " async (message: string, peerSlug: string) => {\n  // @ts-ignore\n  const upsertResult = await db.upsert(\"PeerMessage\", {\n    message,\n    peerSlug,\n  });\n\n  return upsertResult;\n}"
  },
  "addPeer": {
    "name": "addPeer",
    "slug": "TsFunction",
    "id": "kewzyzlnekjrnzzppycvmhru",
    "description": "TODO:",
    "operationName": "peer-functions",
    "rawText": " async (\n  ip: string,\n  authToken: string,\n  peerName?: string,\n  /**\n   * If true, it does not validate the IP to see if it is online and it is authorized...\n   */\n  force?: boolean,\n  isMe?: boolean\n) => {\n  // get new PeerMessages after last sync\n\n  const apiResult = await apiWithConfig.ping({\n    apiUrl: `http://${ip}:${ports[\"function-server\"]}`,\n    authToken,\n    timeout: 2000,\n  });\n\n  const isConnectionEstablished =\n    apiResult?.isSuccessful &&\n    !apiResult?.isUnauthorized &&\n    apiResult.result === true;\n\n  if (!force && !isConnectionEstablished) {\n    return {\n      isSuccesful: false,\n      message:\n        \"Peer connection could not be established. Are you sure the peer is online? Use force if you want to add your peer anyway. If you have a node version lower than v17, this will also fail.\",\n    };\n  }\n}"
  },
  "augmentDevice": {
    "name": "augmentDevice",
    "slug": "TsFunction",
    "id": "dplqgiyflncpfaamhtymamac",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " (x: Device) => {\n  const isOnlineCalculated = x.lastOnlineAt > Date.now() - 300 * 1000;\n  const isLocalIpCalculated = x.ip.startsWith(\"192.168.\");\n\n  const newDevice: Device = {\n    ...x,\n    isOnlineCalculated,\n    isLocalIpCalculated,\n  };\n  return newDevice;\n}"
  },
  "deviceGetAppsCalculated": {
    "name": "deviceGetAppsCalculated",
    "slug": "TsFunction",
    "id": "ebuldjtbbywtneududccdsth",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " async (device: Device) => {\n  const { result: appOperationsCalculated } =\n    await apiWithConfig.getAllAppOperations({\n      apiUrl: `http://${device.ip}:${ports[\"function-server\"]}`,\n      authToken: device.authToken,\n      timeout: 1000,\n    });\n\n  const lastOnlineAt = Date.now();\n  if (!!appOperationsCalculated) {\n    db.update(\n      \"Device\",\n      (p) => p.id === device.id,\n      (p) => ({ ...p, lastOnlineAt })\n    );\n  }\n\n  return { ...device, lastOnlineAt, appOperationsCalculated };\n}"
  },
  "getAllAppOperations": {
    "name": "getAllAppOperations",
    "slug": "TsFunction",
    "id": "eqojvihqxmegalmfsdnvbsmu",
    "description": "Gets all app operations from all packageJsons from the database. Adds `isOnline` to it on the fly by checking if it can connect to the port or not",
    "operationName": "peer-functions",
    "rawText": " async (): Promise<AppOperation[]> => {\n  const appOperations = (await db.get(\"Operation\"))\n    .filter(\n      (operation) =>\n        operation.name &&\n        operation.operation?.classificationIndexed === \"ui-web\" &&\n        operation.operation?.port\n    )\n    .map((operation, index) => {\n      const description =\n        operation.operation?.markdown || operation.description;\n      const port = operation.operation?.port!;\n\n      return {\n        name: operation.name,\n        port,\n        description,\n        emoji: getFirstEmoji(description),\n      };\n    })\n    .sort((a, b) => {\n      if (!a.port || !b.port) return -1;\n\n      if (a.port < b.port) return -1;\n      return 1;\n    });\n\n  const appOperationsWithOnline: AppOperation[] = await Promise.all(\n    appOperations.map(async (appOperation) => {\n      const isOnline = await isPortUsed(appOperation.port);\n      const newAppOperation: AppOperation = {\n        ...appOperation,\n        isOnline,\n      };\n      return newAppOperation;\n    })\n  );\n\n  return appOperationsWithOnline;\n}"
  },
  "getAugmentedPersons": {
    "name": "getAugmentedPersons",
    "slug": "TsFunction",
    "id": "jukyonundlqilqovrfcifaxg",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " async (\n  devices: Device[],\n  config?: {\n    onlyWithDevices?: boolean;\n    onlyWithPapi?: boolean;\n    onlyOnline?: boolean;\n    withAppsCalculated?: boolean;\n  }\n) => {\n  const { onlyOnline, onlyWithDevices, onlyWithPapi, withAppsCalculated } =\n    destructureOptionalObject(config);\n  return (\n    await Promise.all(\n      (\n        await db.get(\"Person\")\n      ).map(async (x) => {\n        const person: Person = {\n          ...x,\n          devicesCalculated: await Promise.all(\n            devices\n              .filter((x) => x.personIds?.includes(x.id))\n              .filter((x) => (onlyWithPapi ? x.hasPapi : true))\n              .map(augmentDevice)\n              .sort(sortDevices)\n              .filter((x) => (onlyOnline ? x.isOnlineCalculated : true))\n              .map((x) => (withAppsCalculated ? deviceGetAppsCalculated(x) : x))\n          ),\n        };\n\n        return person;\n      })\n    )\n  ).filter((x) => {\n    if (!onlyWithDevices) return true;\n    return x.devicesCalculated && x.devicesCalculated.length > 0;\n  });\n}"
  },
  "getFirstEmoji": {
    "name": "getFirstEmoji",
    "slug": "TsFunction",
    "id": "lqxtpdelteailypotmpyalih",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " (text?: string): string | undefined => {\n  if (!text) return;\n  return text?.match(emojiRegex())?.[0];\n}"
  },
  "getNestedPathObject": {
    "name": "getNestedPathObject",
    "slug": "TsFunction",
    "id": "riwkaweiwzxfnpthtsuwikfu",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " async (\n  baseFolderPath: string\n): Promise<NestedPathObject> => {\n  // 1 - explore\n\n  const exploreResult = await explore({\n    basePath: baseFolderPath,\n    includeFoldersWithResults: true,\n  });\n  // 2 - get file and folder paths from explore result\n  const explorePaths = exploreResult.map((textJson) => textJson.path);\n  const relativeExplorePaths = explorePaths.map((explorePath) => {\n    const baseFolderRelativeExplorePath = makeRelative(\n      explorePath,\n      baseFolderPath\n    );\n\n    return baseFolderRelativeExplorePath;\n  });\n\n  // 3- convert file/folder paths array into `NestedPathObject`\n  const nestedPathObject =\n    queryPathsArrayToNestedPathObject(relativeExplorePaths);\n\n  // 4 - return that\n  return nestedPathObject;\n}"
  },
  "getPeerMessages": {
    "name": "getPeerMessages",
    "slug": "TsFunction",
    "id": "glxgawixhzyilcvqbmzubmrv",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " async () => {\n  const peerMessages = await db.get(\"PeerMessage\", {\n    include: { referenceKey: \"peerSlug\" },\n  });\n\n  const sortedPeerMessages = peerMessages\n    .sort((a, b) => {\n      return a.createdAt < b.createdAt ? 1 : -1;\n    })\n    .slice(0, 1000);\n\n  return sortedPeerMessages;\n}"
  },
  "getPeerPeople": {
    "name": "getPeerPeople",
    "slug": "TsFunction",
    "id": "cwacfsvrqooadhsjnggkzzgy",
    "description": "Get persons with devices that have papi and their apps calculated, sorted",
    "operationName": "peer-functions",
    "rawText": " async (): Promise<{\n  success: boolean;\n  peerPeople: Person[];\n}> => {\n  const devices = await db.get(\"Device\");\n\n  // person array met voor elke person alle devices die een papi hebben\n  const peerPeople = await getAugmentedPersons(devices, {\n    onlyOnline: false,\n    onlyWithDevices: true,\n    onlyWithPapi: true,\n    withAppsCalculated: true,\n  });\n\n  return { success: true, peerPeople };\n}"
  },
  "getPeersFromPeersRecursively": {
    "name": "getPeersFromPeersRecursively",
    "slug": "TsFunction",
    "id": "zneocjpzzldxkwkaunkkstgk",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " () => {\n  // TODO: should get the peers from all peers recursively. This is a RECURSIVE API lol!\n}"
  },
  "getPublicFolderNestedPathObjectFromPeer": {
    "name": "getPublicFolderNestedPathObjectFromPeer",
    "slug": "TsFunction",
    "id": "vgjxfutuahpcqdkmmaiwuzwa",
    "description": "Peer = {\nname: \"22.2.2.2.2.2\",\nslug: \"22-22-22-22\"\n}",
    "operationName": "peer-functions",
    "rawText": " async (\n  peerSlug: string\n): Promise<\n  | undefined\n  | { peerApiResult: RealApiReturnType<\"getPublicFolderNestedPathObject\"> }\n> => {\n  const { peerPeople } = await getPeerPeople();\n  const peer = peerPeople.find((x) => x.slug === peerSlug);\n  const name = peer?.name;\n  if (!name) {\n    console.log(\"Peer not found\");\n    return;\n  }\n\n  // TODO:\n  const ip = \"\";\n  // call `getPublicFolderNestedPathObject` with api with other ip\n  const peerApiResult = await apiWithConfig.getPublicFolderNestedPathObject({\n    apiUrl: `http://${ip}:${ports[\"function-server\"]}`,\n    // authToken: peer.authToken,\n    timeout: 5000,\n  });\n\n  return { peerApiResult };\n}"
  },
  "getPublicFolderNestedPathObject": {
    "name": "getPublicFolderNestedPathObject",
    "slug": "TsFunction",
    "id": "xokjwtxjxbnfbayyacxzgfzf",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " async (): Promise<\n  NestedPathObject | undefined\n> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n\n  const publicFolderPath = path.join(projectRoot, \"public\");\n\n  const nestedPathObject = await getNestedPathObject(publicFolderPath);\n\n  return nestedPathObject;\n}"
  },
  "getPublicPeers": {
    "name": "getPublicPeers",
    "slug": "TsFunction",
    "id": "hwthsqmibvsekswqaccdjvak",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " async () => {\n  const publicPeers = (await db.get(\"Device\")).filter(\n    (peer) => !peer.isPrivate\n  );\n\n  return publicPeers;\n}"
  },
  "isPortUsed": {
    "name": "isPortUsed",
    "slug": "TsFunction",
    "id": "jhiksumxstkdxfrzqzwplgmt",
    "description": "Checks if a port is used or not",
    "operationName": "peer-functions",
    "rawText": " (port: number): Promise<boolean> => {\n  return new Promise<boolean>((resolve, reject) => {\n    const server = net.createServer();\n\n    server.once(\"error\", function (err) {\n      if ((err as any).code === \"EADDRINUSE\") {\n        resolve(true);\n      }\n    });\n\n    server.once(\"listening\", function () {\n      // close the server if listening doesn't fail\n      server.close();\n\n      resolve(false);\n    });\n\n    server.listen(port);\n  });\n}"
  },
  "lateFetchPeerMessageSync": {
    "name": "lateFetchPeerMessageSync",
    "slug": "TsFunction",
    "id": "ghbjjblssnctqgkzuwabgkmw",
    "description": "Should sync messages from all peers that are online into your database",
    "operationName": "peer-functions",
    "rawText": " async () => {\n  // goes over all peers, and fetches all their messages since the last sync\n  const peers = await db.get(\"Device\", {\n    include: { referenceKey: \"personId\" },\n  });\n\n  const result = await oneByOne(peers, async (peer) => {\n    const lastSyncedAt = peer.lastSyncDatabaseAtObject.PeerMessage;\n\n    // get new PeerMessages after last sync\n    const apiResult = await apiWithConfig.getDbModel(\n      {\n        apiUrl: `http://${peer.name}:${ports[\"function-server\"]}`,\n        authToken: peer.authToken,\n        timeout: 2000,\n      },\n      \"PeerMessage\",\n      {\n        filter: [\n          // {\n          //   objectParameterKey: \"peerSlug\",\n          //   operator: \"equal\",\n          //   value: peer.,\n          // },\n          {\n            // updatedAt is better than createdAt because it can also work if the model can be updated and if the messages can be edited for example. The id stays the same so upsert will overwrite it\n            objectParameterKey: \"updatedAt\",\n            operator: \"greaterThan\",\n            value: String(lastSyncedAt),\n          },\n        ],\n      }\n    );\n    const newPeerMessages = apiResult.result?.data as PeerMessage[] | undefined;\n\n    if (!newPeerMessages) {\n      // PEER is not online\n      return;\n    }\n\n    // TODO: this should be augmented I think\n    // @ts-ignore\n    const upsertResult = await db.upsert(\"PeerMessage\", newPeerMessages);\n\n    // Update peer to state that we have just synced (and the peer seems to be online)\n    const updatedResult = await db.update(\n      \"Device\",\n      (p) => p.name === peer.name,\n      (p) => ({\n        ...p,\n        lastOnlineAt: Date.now(),\n        lastSyncDatabaseAtObject: {\n          ...p.lastSyncDatabaseAtObject,\n          PeerMessage: Date.now(),\n        },\n      })\n    );\n\n    return upsertResult;\n  });\n\n  const add = (previous: number, current: number) => previous + current;\n  const sum = result\n    .filter(notEmpty)\n    .map((x) => x.amountInserted)\n    .filter(notEmpty)\n    .reduce(add, 0);\n\n  return { newMessagesAmount: sum };\n}"
  },
  "ping": {
    "name": "ping",
    "slug": "TsFunction",
    "id": "qebbaazfsbtinnqtujzmkjsf",
    "description": "",
    "operationName": "peer-functions",
    "rawText": " () => true"
  },
  "proactivePushAddPeerMessage": {
    "name": "proactivePushAddPeerMessage",
    "slug": "TsFunction",
    "id": "gduudtujbptooankdjiyfkep",
    "description": "Adds a message to your own peer messages database, but also to the db of all your peers that are online currently",
    "operationName": "peer-functions",
    "rawText": " async (\n  message: string,\n  peerSlug: string\n): Promise<boolean> => {\n  await addPeerMessage(message, peerSlug);\n\n  const peers = await db.get(\"Person\", {\n    include: { referenceKey: \"personId\" },\n  });\n  await Promise.all(\n    peers.map(async (peer) => {\n      //  if (peer.) return;\n      const apiResult = await apiWithConfig.addPeerMessage(\n        {\n          apiUrl: `http://${peer.name}:${ports[\"function-server\"]}`,\n          //  authToken: peer,\n          timeout: 2000,\n        },\n        message,\n        peerSlug\n      );\n\n      return apiResult;\n    })\n  );\n\n  return true;\n}"
  },
  "removePeer": {
    "name": "removePeer",
    "slug": "TsFunction",
    "id": "hanlzefqaktbelfzhsodfbtw",
    "description": "TODO: connect with peoples",
    "operationName": "peer-functions",
    "rawText": " async (id: string) => {\n  const removeResult = await db.remove(\"Device\", (peer) => peer.id === id);\n  return removeResult;\n}"
  },
  "sortDevices": {
    "name": "sortDevices",
    "slug": "TsFunction",
    "id": "vjflouynodzyrennlgvunjut",
    "description": "Only works if isOnlineCalculated is set (using augmentDevice)\n\nSorts device: first favorite, then online, then offline",
    "operationName": "peer-functions",
    "rawText": " (a: Device, b: Device) => {\n  if (a.isFavorite) return -1;\n  if (b.isFavorite) return 1;\n\n  if (a.isOnlineCalculated) return -1;\n  if (b.isOnlineCalculated) return 1;\n\n  return 1;\n}"
  },
  "updatePeer": {
    "name": "updatePeer",
    "slug": "TsFunction",
    "id": "xzfnmfujnxdmkovfiqagzmby",
    "description": "Update one of your peers",
    "operationName": "peer-functions",
    "rawText": " async (\n  slug: string,\n  updatedValues: {\n    name?: string;\n    description?: string;\n    authToken?: string;\n    isFavorite?: boolean;\n    isMe?: boolean;\n  }\n): Promise<{ isSuccesful: boolean; message: string }> => {\n  const updateResult = await db.update(\n    \"Person\",\n    (person) => {\n      return person.slug === slug;\n    },\n    (peer) => {\n      return { ...peer, ...omitUndefinedValues(updatedValues) };\n    }\n  );\n\n  return {\n    isSuccesful: !!updateResult.isSuccesful,\n    message: updateResult.isSuccesful\n      ? \"Peer updated\"\n      : `Something went wrong: ${updateResult.message}`,\n  };\n}"
  },
  "achievements": {
    "name": "achievements",
    "slug": "TsVariable",
    "id": "phqnmflppxdlhxkgrxjbugxl",
    "description": "",
    "operationName": "peer-types"
  },
  "developers": {
    "name": "developers",
    "slug": "TsVariable",
    "id": "ymcydpfwuxpoqhjdqtsjfpdh",
    "description": "",
    "operationName": "peer-types"
  },
  "englishMethod": {
    "name": "englishMethod",
    "slug": "TsVariable",
    "id": "bascekgazqynaifgiuawlfzx",
    "description": "",
    "operationName": "peer-types"
  },
  "levelNames": {
    "name": "levelNames",
    "slug": "TsVariable",
    "id": "ryqnzmimlnzcaecbzlxhlbdq",
    "description": "",
    "operationName": "peer-types"
  },
  "publicPersonKeys": {
    "name": "publicPersonKeys",
    "slug": "TsVariable",
    "id": "uahptqyigjeuxdnmjsvfewly",
    "description": "Can be seen for every person, without authentication\n\nNB: I wish it were possible to ensure these keys exist on the person here, but we can't validate that while still keeping it a const I guess",
    "operationName": "peer-types"
  },
  "getPrimaryPersona": {
    "name": "getPrimaryPersona",
    "slug": "TsFunction",
    "id": "eunxedbgfzpuvhrksjyhcdge",
    "description": "",
    "operationName": "persona-functions-node",
    "rawText": " async () => {\n  const personas = await db.get(\"Persona\");\n\n  const primary = personas.find((x) => x.isPrimary) || personas[0];\n\n  if (!primary) {\n    console.log(\"No primary persona found\");\n  }\n\n  return primary;\n}"
  },
  "isPlural": {
    "name": "isPlural",
    "slug": "TsFunction",
    "id": "mkvnspzkwckfeujwrzcxophb",
    "description": "",
    "operationName": "pluralize",
    "rawText": " (parameterName: string) => {\n  return parameterName.endsWith(\"s\");\n}"
  },
  "isSingular": {
    "name": "isSingular",
    "slug": "TsFunction",
    "id": "iikpwvdwavxihavzgqwbjbqk",
    "description": "",
    "operationName": "pluralize",
    "rawText": " (parameterName: string) => {\n  return !isPlural(parameterName);\n}"
  },
  "pluralize": {
    "name": "pluralize",
    "slug": "Operation",
    "id": "NfHZnxRqNZvFFLsW",
    "operationName": "pluralize"
  },
  "singularize": {
    "name": "singularize",
    "slug": "TsFunction",
    "id": "aqagtbyvtgzxwwiicdejbqng",
    "description": "Removes the 's' if it is found at the end of the parameter name",
    "operationName": "pluralize",
    "rawText": " (parameterName: string) => {\n  return parameterName.endsWith(\"s\")\n    ? parameterName.substring(0, parameterName.length - 1)\n    : parameterName;\n}"
  },
  "appPrefix": {
    "name": "appPrefix",
    "slug": "TsVariable",
    "id": "zzkombojqnxfctlvsffisjaw",
    "description": "",
    "operationName": "pm2-util"
  },
  "deleteAppCli": {
    "name": "deleteAppCli",
    "slug": "TsFunction",
    "id": "uvxfmpobpeyulousgkwnxdua",
    "description": "Arguments\n- Operation Name",
    "operationName": "pm2-util",
    "rawText": " async () => {\n  const [operationName] = process.argv.slice(2);\n  console.log(`going to delete app ${operationName}`);\n  const result = await deleteApp(operationName);\n  console.log({ result });\n}"
  },
  "deleteApp": {
    "name": "deleteApp",
    "slug": "TsFunction",
    "id": "arclpoktlgzobnbmfmrpoowk",
    "description": "Deletes an app from the pm2\n\nTODO: for some reason it says `error: Error: process or namespace not found` even though it certainly exists. I can't figure out why it's not working.",
    "operationName": "pm2-util",
    "rawText": " (operationName: string) => {\n  return pm2ConnectDisconnect((resolve) => {\n    pm2.delete(`${appPrefix}${operationName}`, (error, proc) => {\n      resolve({ isSuccessful: !error, error, proc });\n    });\n  });\n}"
  },
  "listAppsCli": {
    "name": "listAppsCli",
    "slug": "TsFunction",
    "id": "zhbhgxjavzejrnrsfccjedxj",
    "description": "Arguments:none",
    "operationName": "pm2-util",
    "rawText": " async () => {\n  const result = await listApps();\n  console.table(result.apps || result.message);\n}"
  },
  "listApps": {
    "name": "listApps",
    "slug": "TsFunction",
    "id": "nlwjivpffufwsudkumryatof",
    "description": "Lists the apps in pm2",
    "operationName": "pm2-util",
    "rawText": " async (): Promise<ListAppsResult> => {\n  return pm2ConnectDisconnect((resolve) => {\n    pm2.list((err, processes) => {\n      if (err) {\n        resolve({ isSuccessful: false, message: err.message });\n      }\n\n      const apps = processes\n        .filter((x) => x.name?.startsWith(appPrefix))\n        .map((x) => ({\n          operationName: x.name!.substring(appPrefix.length),\n          cpuPercentage: x.monit?.cpu,\n          memoryBytes: x.monit?.memory,\n        }));\n\n      resolve({ isSuccessful: true, apps });\n    });\n  });\n}"
  },
  "logApp": {
    "name": "logApp",
    "slug": "TsFunction",
    "id": "fmhhqsfscwqzhdsopepozwoa",
    "description": "",
    "operationName": "pm2-util",
    "rawText": " async (operationName: string) => {}"
  },
  "logTableObject": {
    "name": "logTableObject",
    "slug": "TsFunction",
    "id": "savaeygghyyweexqrubyeddm",
    "description": "",
    "operationName": "pm2-util",
    "rawText": " (object: { [key: string]: any } | undefined) => {\n  if (!object) return;\n\n  const table = Object.keys(object).map((key) => {\n    return { property: key, value: object[key] };\n  });\n\n  return table;\n}"
  },
  "pm2ConnectDisconnect": {
    "name": "pm2ConnectDisconnect",
    "slug": "TsFunction",
    "id": "wzrguwegbykpeqavstccdbzb",
    "description": "Function that lets you connect, execute a pm2 action, and disconnect after",
    "operationName": "pm2-util",
    "rawText": " async <\n  TResult extends {\n    isSuccessful: boolean;\n    error?: Error;\n    proc?: pm2.Proc;\n    [key: string]: any;\n  }\n>(\n  action: (resolve: (value: TResult) => void) => void\n) => {\n  const result = await new Promise<{\n    isSuccessful: boolean;\n    error?: Error;\n    proc?: pm2.Proc;\n  }>(async (resolve) => {\n    const { error } = await pm2Connect();\n    if (error) resolve({ isSuccessful: false, error });\n    action((value: TResult) => {\n      resolve(value);\n      pm2.disconnect();\n    });\n  });\n\n  return result;\n}"
  },
  "pm2Connect": {
    "name": "pm2Connect",
    "slug": "TsFunction",
    "id": "rzxssoeekuxfrmpvwlggklmf",
    "description": "",
    "operationName": "pm2-util",
    "rawText": " async () => {\n  return new Promise<{ isSuccessful: boolean; error?: Error }>((resolve) => {\n    pm2.connect((error) => {\n      if (error) {\n        resolve({ isSuccessful: false, error });\n      }\n      resolve({ isSuccessful: true });\n    });\n  });\n}"
  },
  "restartAppCli": {
    "name": "restartAppCli",
    "slug": "TsFunction",
    "id": "ybrumsjuslwubuvripxbxktw",
    "description": "Arguments\n- Operation Name",
    "operationName": "pm2-util",
    "rawText": " async () => {\n  const [operationName] = process.argv.slice(2);\n  const { error, proc } = await restartApp(operationName);\n  console.table(logTableObject(takeFirst(proc) || error));\n}"
  },
  "restartApp": {
    "name": "restartApp",
    "slug": "TsFunction",
    "id": "ozadlkakuuebejfjfarrbrei",
    "description": "Restarts an app with pm2",
    "operationName": "pm2-util",
    "rawText": " async (operationName: string) => {\n  return pm2ConnectDisconnect((resolve) => {\n    restart(`${appPrefix}${operationName}`, (error, proc) => {\n      resolve({ isSuccessful: !error, proc, error });\n    });\n  });\n}"
  },
  "startAppCli": {
    "name": "startAppCli",
    "slug": "TsFunction",
    "id": "drscociwybjohelbtbtdkitq",
    "description": "Arguments\n- Operation Name\n- isDev (true)",
    "operationName": "pm2-util",
    "rawText": " async () => {\n  const [operationName, isDevString] = process.argv.slice(2);\n  const isDev = isDevString === \"true\";\n  const result = await startApp(operationName, isDev);\n\n  const table = logTableObject(\n    takeFirst(result?.proc) || result?.error || result\n  );\n  console.table(table);\n}"
  },
  "startApp": {
    "name": "startApp",
    "slug": "TsFunction",
    "id": "ijoflxuycyofihnjernvegzr",
    "description": "",
    "operationName": "pm2-util",
    "rawText": " async (\n  operationName: string,\n  isDev?: boolean\n): Promise<{\n  isSuccessful: boolean;\n  error?: Error;\n  proc?: pm2.Proc;\n  message?: string;\n}> => {\n  const operationFolderPath = await getOperationPath(operationName);\n  if (!operationFolderPath) {\n    return { isSuccessful: false, message: \"No operation folder path\" };\n  }\n  const packageJson = await getPackageJson({ operationFolderPath });\n  if (!packageJson) {\n    return { isSuccessful: false, message: \"no package json found\" };\n  }\n\n  const port = packageJson?.operation?.port;\n\n  if (!port) {\n    return {\n      isSuccessful: false,\n      message: \"Operation must have a port assigned\",\n    };\n  }\n\n  const isAlready = await isPortUsed(port);\n\n  if (isAlready) {\n    return {\n      isSuccessful: true,\n      message: `App was already running (port ${port})`,\n    };\n  }\n\n  const action = (resolve: Pm2Resolver) => {\n    pm2.start(\n      {\n        time: true,\n        name: `${appPrefix}${operationName}`,\n        output: undefined,\n        error: undefined,\n        script: isDev ? \"yarn dev\" : \"yarn start\",\n        cwd: operationFolderPath,\n      },\n      (error, proc) => {\n        if (error) {\n          resolve({ isSuccessful: false, error });\n        }\n        resolve({ isSuccessful: true, proc });\n      }\n    );\n  };\n\n  const result = await pm2ConnectDisconnect(action);\n\n  return result;\n}"
  },
  "stopAllAppsExceptCli": {
    "name": "stopAllAppsExceptCli",
    "slug": "TsFunction",
    "id": "fpwxgyihmxofrhysriogkemn",
    "description": "Arguments: operation names that you don't want to stop",
    "operationName": "pm2-util",
    "rawText": " async () => {\n  const operationNames = process.argv.slice(2);\n  stopAllAppsExcept(operationNames);\n}"
  },
  "stopAllAppsExcept": {
    "name": "stopAllAppsExcept",
    "slug": "TsFunction",
    "id": "hsryirodcsbhprceehjjdslu",
    "description": "Stops all apps except some specified ones",
    "operationName": "pm2-util",
    "rawText": " async (\n  ignore: string[] = []\n): Promise<void> => {\n  const apps = await listApps();\n\n  console.dir({ appsLength: apps.apps?.length, apps: apps }, { depth: 200 });\n  if (!apps.isSuccessful || !apps.apps) {\n    log(`something is wrong with listApps`, { type: \"error\" });\n    return;\n  }\n\n  const appsToQuit = apps.apps\n    .filter((app) => {\n      if (!app.operationName) return;\n\n      return !ignore.includes(app.operationName);\n    })\n    .map((x) => x.operationName);\n\n  await stopApps(appsToQuit);\n\n  log(`Stopped ${appsToQuit.length} apps`, { type: \"success\" });\n}"
  },
  "stopAppsCli": {
    "name": "stopAppsCli",
    "slug": "TsFunction",
    "id": "adxjvjaznvserbgmssnrjrqw",
    "description": "Arguments\n- Operation Names to stop",
    "operationName": "pm2-util",
    "rawText": " async () => {\n  const operationNames = process.argv.slice(2);\n  const result = await stopApps(operationNames);\n  console.log({ result });\n}"
  },
  "stopApps": {
    "name": "stopApps",
    "slug": "TsFunction",
    "id": "jqxevnvqllifphxmtirpyecg",
    "description": "Stops an app with pm2\n\nTODO: for some reason i'm getting `TypeError: Cannot read properties of undefined (reading '_operate')` and I can't find why because all other commands mostly work and I'm doing it the same way.",
    "operationName": "pm2-util",
    "rawText": " async (operationNames: string[]) => {\n  return pm2ConnectDisconnect((resolve) => {\n    operationNames.map((operationName) => {\n      stop(`${appPrefix}${operationName}`, (error, proc) => {});\n    });\n\n    resolve({ isSuccessful: true });\n  });\n}"
  },
  "ports": {
    "name": "ports",
    "slug": "TsVariable",
    "id": "rzfavumhpqxnjyfuyclyeygk",
    "description": "See https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers for available ports\n\nRange 42000-42080 seems to have no ports. There are many more ranges\n\nWhen creating a new app, ensure you not only define the port here, but also in",
    "operationName": "port-conventions"
  },
  "ContextualPromptResultsTab": {
    "name": "ContextualPromptResultsTab",
    "slug": "TsFunction",
    "id": "vvivnnhdkpodkxosrsykrvit",
    "description": "Visual to show the different prompt results. Probably deprecated, probably better to show it in a more structured way.",
    "operationName": "prompt-components",
    "rawText": " (props: {\n  prompt_projectRelativePath: string;\n}) => {\n  const { prompt_projectRelativePath } = props;\n\n  const contextualPromptResultsQuery = queries.useGetContextualPromptResults({\n    prompt_projectRelativePath,\n  });\n\n  return (\n    <Div>\n      {contextualPromptResultsQuery.data?.result?.map(\n        (item: ContextualPromptResult) => {\n          return (\n            <Div>\n              <b>prompt</b>\n              {item.prompt ? (\n                <MarkdownContent content={item.prompt} config={{}} />\n              ) : null}\n\n              <b>result</b>\n\n              {item.resultText ? (\n                <MarkdownContent content={item.resultText} config={{}} />\n              ) : null}\n            </Div>\n          );\n        }\n      )}\n    </Div>\n  );\n}"
  },
  "FilePromptSelect": {
    "name": "FilePromptSelect",
    "slug": "TsFunction",
    "id": "azghyjowtaizdubniqpxkmtj",
    "description": "Component that shows a selectbox for different prompts that can be applied on this file",
    "operationName": "prompt-components",
    "rawText": " (props: {\n  items: ContextualPrompt[] | undefined;\n  contextContent: string;\n  context_projectRelativeFilePath?: string;\n}) => {\n  const { items, contextContent, context_projectRelativeFilePath } = props;\n\n  const { selection: contextSelection } = useLastSelection();\n  const showPromptAlert = usePromptResultAlert();\n  const alert = useAlert();\n\n  const selectItems = items?.map((prompt) => {\n    const item: Item<string> = { label: prompt.name, value: prompt.id };\n\n    return item;\n  });\n  const allSelectItems = [{ label: \"Select a prompt\", value: \"\" }].concat(\n    selectItems || []\n  );\n  const [SelectComponent, _, setValue] = useSelect(\n    allSelectItems,\n    undefined,\n    async (selection) => {\n      const id = selection?.value;\n\n      const prompt = items?.find((x) => x.id === id);\n\n      if (!prompt) {\n        alert?.(\"Invalid value\");\n        return;\n      }\n\n      setValue(null);\n\n      processPrompt({\n        contextualPromptSlug: prompt.slug,\n        contextualContent: {\n          contextContent,\n          context_projectRelativeFilePath,\n          contextSelection,\n        },\n        showPromptAlert,\n      });\n    }\n  );\n  return <SelectComponent />;\n}"
  },
  "processPrompt": {
    "name": "processPrompt",
    "slug": "TsFunction",
    "id": "fwbejmifjwscajxgnuvrnkzs",
    "description": "Main function to process a prompt. For now it calls `processChatGptPrompt` api and shows an alert afterwards with the result. In some cases we may want to process the prompt differently, e.g. storing it in a queue.",
    "operationName": "prompt-components",
    "rawText": " async (config: {\n  contextualPromptSlug?: Slug;\n  customPromptContent?: string;\n  contextualContent: ContextualContent;\n  showPromptAlert: ShowPromptAlertFunction;\n  saveNewPromptWithName?: string | null;\n}) => {\n  const {\n    contextualPromptSlug,\n    showPromptAlert,\n    customPromptContent,\n    saveNewPromptWithName,\n    contextualContent: {\n      contextContent,\n      context_projectRelativeFilePath,\n      contextSelection,\n    },\n  } = config;\n\n  const apiResult = await api.processChatGptPrompt({\n    contextContent,\n    selectionContent: contextSelection || null,\n    prompt_projectRelativePath: context_projectRelativeFilePath,\n    isDeferred: true,\n    // not sure about these?\n    contextualPromptSlug,\n    customPromptContent,\n    saveNewPromptWithName,\n    isHeadless: false,\n  });\n\n  if (!apiResult.isSuccessful || !apiResult.result?.isSuccessful) {\n    showStandardResponse(apiResult);\n    return;\n  }\n\n  const title = contextualPromptSlug\n    ? humanCase(contextualPromptSlug)\n    : \"Untitled prompt\";\n\n  showPromptAlert(\n    title,\n    apiResult?.result?.result?.text || \"No textual result\",\n    apiResult?.result?.result?.thread,\n    context_projectRelativeFilePath\n  );\n}"
  },
  "usePromptResultAlert": {
    "name": "usePromptResultAlert",
    "slug": "TsFunction",
    "id": "yiyvnjtkglbuqmarvheyljbn",
    "description": "Recursive hook that calls its own function if you click \"respond\", which creates an additional item in the thread",
    "operationName": "prompt-components",
    "rawText": " () => {\n  // const alert = useAlert();\n\n  const showPromptAlert: ShowPromptAlertFunction = (\n    originalPromptName,\n    _,\n    thread,\n    projectRelativeFilePath\n  ) => {\n    // const markdownRender = (\n    //   <MarkdownContent config={{}} content={textMarkdown || \"No content\"} />\n    // );\n\n    successToast(\n      `${originalPromptName} is now being executed on ${projectRelativeFilePath} (thread: ${thread})`\n    );\n    // const buttons: AlertButton[] = [\n    //   { text: \"Okay\", style: \"cancel\", onPress: () => null },\n    //   {\n    //     text: \"Share\",\n    //     style: \"default\",\n    //     onPress: () => {\n    //       // should open share view\n    //     },\n    //   },\n    //   {\n    //     text: \"Respond\",\n    //     style: \"default\",\n    //     onPress: async () => {\n    //       //  submits extra request that opens a new alert with the answer to that\n    //       let response = prompt(\"What do you want to say?\", \"\");\n\n    //       const apiResult = await api.processChatGptPrompt({\n    //         contextContent: null,\n    //         selectionContent: null,\n    //         contextualPromptSlug: undefined,\n    //         customPromptContent: response || undefined,\n    //         saveNewPromptWithName: null,\n    //         isHeadless: false,\n    //         isDeferred: true,\n    //         thread,\n    //         prompt_projectRelativePath: projectRelativeFilePath,\n    //       });\n\n    //       // NB: Recursion!\n    //       showPromptAlert(\n    //         originalPromptName,\n    //         apiResult.result?.result?.text || \"No response\",\n    //         thread,\n    //         projectRelativeFilePath\n    //       );\n\n    //       // could also enable a loading indicator somewhere\n    //     },\n    //   },\n    // ];\n\n    // alert?.(originalPromptName, markdownRender, buttons);\n  };\n\n  return showPromptAlert;\n}"
  },
  "browserLunchOptions": {
    "name": "browserLunchOptions",
    "slug": "TsVariable",
    "id": "ojydgoqfmicqcwdhfbbijpah",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "browserSession": {
    "name": "browserSession",
    "slug": "TsVariable",
    "id": "thiyznpmviasagxsmjchuvef",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "clickOnSpanTag": {
    "name": "clickOnSpanTag",
    "slug": "TsFunction",
    "id": "kijvcngguopnqajngaztdpct",
    "description": "it takes the current page and span text and its click on the text span",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  page: Page;\n  spanText: string;\n}) => {\n  const { page, spanText } = props;\n  // getting and clicking on the write something button to post the content\n  await page.waitForFunction(\n    `document.querySelector(\"body\").innerText.includes(\"${spanText}\")`\n  );\n  const targetSpanTag = await page.$x(`//span[contains(text(),\"${spanText}\")]`);\n  if (targetSpanTag[0]) {\n    //@ts-ignore\n    targetSpanTag[0]?.click();\n  } else {\n    return { success: false, message: `${spanText} tag not found.` };\n  }\n}"
  },
  "delay": {
    "name": "delay",
    "slug": "TsFunction",
    "id": "szezrjrpplhfkozfghjtslab",
    "description": "Handling the new page by checking all browser tabs and if exist then return the existing one for reuse\nor create new one",
    "operationName": "puppeteer-utils",
    "rawText": " (ms: number) => new Promise((res) => setTimeout(res, ms))"
  },
  "facebookLogin": {
    "name": "facebookLogin",
    "slug": "TsFunction",
    "id": "fakcpgjxthjvkexcfuwdgtiu",
    "description": "takes facebook credentials and login to facebook",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: FacebookLoginPropsType) => {\n  const { email, password, page } = props;\n  // type email\n  await typeInTheInputField({\n    page,\n    value: email,\n    selector: 'input[name=\"email\"]',\n  });\n  // type password\n  await typeInTheInputField({\n    page,\n    selector: 'input[name=\"pass\"]',\n    value: password,\n  });\n  // clicking the login button\n  await page.click(\"button[name=login]\");\n}"
  },
  "foundOrNotXpath": {
    "name": "foundOrNotXpath",
    "slug": "TsFunction",
    "id": "eookrdedngohpiehjbwwgvtf",
    "description": "Utility function that always returns a boolean instead of throwing an error.\nXPath version.",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  /** the page element from puppeteer got with browser.pages */\n  page: Page;\n  /** the xpath selector to search for */\n  selector: string;\n}): Promise<{\n  /** was the element found or not */\n  found: boolean;\n  /** if the element was found, it is returned */\n  element?: any;\n}> => {\n  const { page, selector } = props;\n  return new Promise(async (resolve, reject) => {\n    // Correct Method\n    await page\n      .waitForXPath(selector)\n      .then((element: any) => {\n        resolve({\n          found: true,\n          element,\n        });\n      })\n      .catch((e: any) => {\n        resolve({\n          found: false,\n        });\n      });\n  });\n}"
  },
  "foundOrNot": {
    "name": "foundOrNot",
    "slug": "TsFunction",
    "id": "apslqcmanwnafovbpcldrjan",
    "description": "Utility function that always returns a boolean instead of throwing an error.",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  /** the page element from puppeteer got with browser.pages */\n  page: Page;\n  /** the css selector to search for */\n  selector: string;\n  /** (optional) change default timeout to wait for selector */\n  timeoutMilliseconds?: number;\n}): Promise<boolean> => {\n  const { page, selector, timeoutMilliseconds } = props;\n  return new Promise(async (resolve, reject) => {\n    // Correct Method\n    await page\n      .waitForSelector(selector, { timeout: timeoutMilliseconds || 30 * 1000 })\n      .then(() => {\n        resolve(true);\n      })\n      .catch((e: any) => {\n        resolve(false);\n      });\n  });\n}"
  },
  "getBrowserPageById": {
    "name": "getBrowserPageById",
    "slug": "TsFunction",
    "id": "psjvxgfnvwdvwxnhuelbiwjh",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (browser: Browser, pageId: string) => {\n  const allPages = await browser.pages();\n  const targetPage = allPages.find(\n    //@ts-ignore\n    (p) => p.target()._targetId === pageId\n  );\n  await targetPage?.setBypassCSP(true);\n  return targetPage;\n}"
  },
  "getBrowserTabs": {
    "name": "getBrowserTabs",
    "slug": "TsFunction",
    "id": "xwsmxuzpbrqeuwtmzpgyrceg",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (\n  browserInfo: BrowserSession\n): Promise<Page[]> => {\n  const browser = await puppeteer.connect({\n    browserWSEndpoint: browserInfo.browserSessionId,\n  });\n  let allTabs: Page[] = await browser.pages();\n  console.log({ allTabs });\n  return allTabs;\n}"
  },
  "getBrowser": {
    "name": "getBrowser",
    "slug": "TsFunction",
    "id": "sqxvomlmktfxzrkldkqsjlmb",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " () => {\n    return browserSession.get(\"browser\");\n}"
  },
  "getChromeExecutablePath": {
    "name": "getChromeExecutablePath",
    "slug": "TsFunction",
    "id": "exlamxknaapnbyvmmfpsphkn",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " () => {\n  if (platform() === \"linux\") {\n    return \"/usr/bin/google-chrome-stable\";\n  } else {\n    return \"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\";\n    // return \"/usr/local/bin/chromium\";\n  }\n}"
  },
  "getConnectedBrowsers": {
    "name": "getConnectedBrowsers",
    "slug": "TsFunction",
    "id": "cualaugdnbvzragntutyuccy",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (): Promise<BrowserSession[]> => {\n  // const allBrowsers = getBrowserSession();\n  // console.log({ allBrowsers });\n  let connectedBrowser: BrowserSession[] = [];\n  // for await (let browser of allBrowsers) {\n  //   await puppeteer\n  //     .connect({\n  //       browserWSEndpoint: browser.browserSessionId,\n  //     })\n  //     .then((cb) => {\n  //       connectedBrowser.push(browser);\n  //     })\n  //     .catch((e) => {\n  //       console.error(\"Error in connecting browser\", e);\n  //       db.remove(\"BrowserSession\", (b) => b.id !== browser.id);\n  //     });\n  // }\n  // console.log({ connectedBrowser });\n  return connectedBrowser;\n}"
  },
  "getIdlePage": {
    "name": "getIdlePage",
    "slug": "TsFunction",
    "id": "apbllkdkictksxeuwnxisgfl",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (\n  browser: Browser\n): Promise<Page | undefined> => {\n  // console.log(\"Get Idle Page Called\");\n  const idlePage = (await db.get(\"BrowserPage\")).find((p) => p.isIdle);\n  console.log({ idlePage });\n\n  const allPages = await browser.pages();\n  const targetPage = allPages.find(\n    //@ts-ignore\n    (p) => p.target()._targetId === idlePage?.pageId\n  );\n\n  return targetPage;\n}"
  },
  "getNewPage": {
    "name": "getNewPage",
    "slug": "TsFunction",
    "id": "btqdlfdcohmjmjtttrrudirl",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (\n    browser: Browser\n): Promise<Page | undefined> => {\n    const allPage = await browser.pages();\n    const allPageTitle = await Promise.all(allPage.map(async (p) => p.title()));\n    let indexOfIdlePage = allPageTitle.indexOf(\"\");\n    if (indexOfIdlePage === -1) {\n        const idlePage = await getIdlePage(browser);\n        return idlePage;\n    }\n    return allPage[indexOfIdlePage];\n}"
  },
  "gmailLogin": {
    "name": "gmailLogin",
    "slug": "TsFunction",
    "id": "jhnrcffteupdnxftptqrdmsn",
    "description": "Helps to login into gmail account",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: GmailLoginPropsType) => {\n  // waiting for email input and set email value\n  const { page, email, password } = props;\n  // setting email address\n  await setInputValue({\n    page,\n    inputValue: email,\n    selector: \"input[type=email]\",\n  });\n\n  // clicking on the next button after email input\n  await clickOnSpanTag({ page, spanText: \"Next\" });\n  await page.setBypassCSP(true);\n  // clicking on the next button after password input\n\n  await page.waitForFunction(\n    `document.querySelector(\"body\").innerText.includes(\"Next\")`\n  );\n\n  // waiting for the password field to load and set the password\n  await setInputValue({\n    page,\n    inputValue: password,\n    selector: \"input[type=password]\",\n  });\n\n  // clicking next button after password entered\n  await clickOnSpanTag({ page, spanText: \"Next\" });\n}"
  },
  "isCaptchaExist": {
    "name": "isCaptchaExist",
    "slug": "TsFunction",
    "id": "gmeuywhqrfnjkkyzmojqmhau",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (\n  page: Page\n): Promise<{ captchas: CaptchaInfo[] }> => {\n  try {\n    let recaptchaResult = await page.findRecaptchas();\n    const { captchas } = recaptchaResult;\n    return { captchas };\n  } catch (e: Error | any) {\n    console.log(\"isCaptchaExist Error\", e?.message);\n    return { captchas: [] };\n  }\n}"
  },
  "logConsoleIfDebug": {
    "name": "logConsoleIfDebug",
    "slug": "TsFunction",
    "id": "fcouyhrresweloismsiygunp",
    "description": "Utility function to log console only if a Debug flag is set.\nIf the flag is not set, doesn't print anything.",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  message: string;\n  debug: boolean;\n}) => {\n  const { debug, message } = props;\n  if (debug) {\n    console.log(message);\n  }\n}"
  },
  "openMultiTabs": {
    "name": "openMultiTabs",
    "slug": "TsFunction",
    "id": "occtqgwfegmplihvvjysrirc",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: OpenMultiTabProps) => {\n  const { noOfTabs, tabUrl, browser } = props;\n  const allTabs = [];\n  for (let i = 0; i < noOfTabs; i++) {\n    allTabs.push(browser.newPage());\n  }\n  const allPages = await Promise.all(allTabs);\n\n  const allPageIds: string[] = await Promise.all(\n    //@ts-ignore\n    allPages.map((p) => p.target()._targetId)\n  );\n  //@ts-ignore\n  const allPageIdsCreations: Creation<BrowserPage[]> = allPageIds.map(\n    (pid) => ({ pageId: pid, isIdle: true })\n  );\n  await db.upsert(\"BrowserPage\", allPageIdsCreations);\n}"
  },
  "openNewBrowserOnChildProcess": {
    "name": "openNewBrowserOnChildProcess",
    "slug": "TsFunction",
    "id": "ptfzfjlmsqwtnohgsuewhrqx",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async () => {\n  const operationFolderPath = await getOperationPath(\"puppeteer-utils\");\n  console.log(\"Child Process called\", operationFolderPath);\n  const browserSession = await db.get(\"BrowserSession\");\n  if (browserSession.length === 0) {\n    const newProcess = fork(\n      `${operationFolderPath}/build/cli/runBrowser.cli.js`,\n      {\n        detached: true,\n        // stdio: \"ignore\",\n      }\n    );\n    newProcess.unref();\n  }\n}"
  },
  "openNewBrowser": {
    "name": "openNewBrowser",
    "slug": "TsFunction",
    "id": "klljmdbjwpxuoiekuwdawfkh",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (): Promise<Browser | undefined> => {\n  console.log(\"OPEN BROWSER CALLED\");\n  const existingBrowserSession = await db.get(\"BrowserSession\");\n  if (existingBrowserSession[0]) {\n    const { browserSessionId } = existingBrowserSession[0];\n    try {\n      puppeteer.use(\n        RecaptchaPlugin({\n          provider: {\n            id: \"2captcha\",\n            token: \"243f9da05482cc8e9b76203a184943c9\", // REPLACE THIS WITH YOUR OWN 2CAPTCHA API KEY ⚡\n          },\n          visualFeedback: true, // colorize reCAPTCHAs (violet = detected, green = solved)\n        })\n      );\n      const existingBrowser = await puppeteer.connect({\n        browserWSEndpoint: browserSessionId,\n      });\n      const isBrowserConnected = existingBrowser.isConnected();\n      console.log({ isBrowserConnected });\n      return existingBrowser;\n    } catch (e: Error | any) {\n      console.log(\"Error in open browser\", e);\n      await db.clear(\"BrowserSession\");\n      await openNewBrowserOnChildProcess();\n      return;\n    }\n  } else {\n    await db.clear(\"BrowserSession\");\n    await openNewBrowserOnChildProcess();\n    return;\n  }\n}"
  },
  "openPage": {
    "name": "openPage",
    "slug": "TsFunction",
    "id": "zxqlqvjtsywjsdeqbvfpnetg",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (pageId?: string): Promise<Page | undefined> => {\n    const browser = await openNewBrowser();\n    if (!browser) {\n        console.log(\"BROSER NOT FOUND\");\n        await delay(5000);\n        console.log(\"TRY AGAIN\");\n        const browser = await openNewBrowser();\n        if (!browser) return;\n        if (browser) {\n            if (pageId) {\n                return getBrowserPageById(browser, pageId);\n            }\n\n            const page = await getNewPage(browser);\n\n            await page?.setBypassCSP(true);\n            return page;\n        }\n        return;\n    }\n\n    if (pageId) {\n        return getBrowserPageById(browser, pageId);\n    }\n\n    const page = await getNewPage(browser);\n    await page?.setBypassCSP(true);\n    return page;\n}"
  },
  "racePromises": {
    "name": "racePromises",
    "slug": "TsFunction",
    "id": "nbyoowvfimovuqczezgixymk",
    "description": "Typescript",
    "operationName": "puppeteer-utils",
    "rawText": " async (\n  promises: Promise<any>[]\n): Promise<number> => {\n  const indexedPromises: Array<Promise<number>> = promises.map(\n    (promise, index) =>\n      new Promise<number>((resolve) =>\n        promise\n          .then(() => resolve(index))\n          .catch((err) => {\n            console.log(\"RACE PROMISE INDEX \" + index + \" TIMED OUT !!!\");\n          })\n      )\n  );\n  return Promise.race(indexedPromises);\n}"
  },
  "retryClickAndWaitSelector": {
    "name": "retryClickAndWaitSelector",
    "slug": "TsFunction",
    "id": "pzvtcagmcagpysdbcosyngkr",
    "description": "Utility function that loops waiting a second and checking\nif selector showed up. Fails if it takes more than 30 seconds.\n\nthis is good to use instead of page.waitForTimeout + page.waitForSelector",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  /** the page element from puppeteer got with browser.pages */\n  page: any;\n  /** the css selector to search for */\n  selector: string | string[];\n  /** the options */\n  selectorOptions?: any;\n  /** the css selector to click after */\n  selectorToClick: string;\n  /**  maxium time to retry. defaults to 30 seconds. */\n  maxTime: number;\n}): Promise<{ success: boolean; found?: any }> => {\n  const {\n    page,\n    selector,\n    selectorOptions,\n    selectorToClick,\n    maxTime = 30000,\n  } = props;\n  return new Promise(async (resolve, reject) => {\n    let totalTime = 0;\n    while (totalTime < maxTime) {\n      try {\n        const found = await page.waitForSelector(selector, {\n          ...selectorOptions,\n          timeout: 1000,\n        });\n        resolve({ success: true, found });\n        return;\n      } catch (err) {\n        try {\n          await page.click(selectorToClick);\n        } catch (insideErr) {\n          //console.log('inside error ! continuing...');\n        }\n\n        totalTime += 1000;\n        console.log(\"retrying...\");\n      }\n    }\n    resolve({ success: false });\n  });\n}"
  },
  "retryWaitSelector": {
    "name": "retryWaitSelector",
    "slug": "TsFunction",
    "id": "atuyfshylhzfwolexivwvcwu",
    "description": "Utility function that loops waiting a second and checking\nif selector showed up. Fails if it takes more than 30 seconds.\n\nthis is good to use instead of page.waitForTimeout + page.waitForSelector",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  /** the page element from puppeteer got with browser.pages */\n  page: Page;\n  /** the css selector to search for */\n  selector: string;\n  /**  maxium time to retry. defaults to 30 seconds. */\n  maxTime: number;\n}): Promise<{ success: boolean; found?: any }> => {\n  const { page, selector, maxTime = 30000 } = props;\n  return new Promise(async (resolve, reject) => {\n    let totalTime = 0;\n    while (totalTime < maxTime) {\n      try {\n        const found = await page.waitForSelector(selector, { timeout: 1000 });\n        resolve({ success: true, found });\n      } catch (err) {\n        totalTime += 1000;\n        console.log(\"retrying... \" + selector + \" / totalTime \" + totalTime);\n      }\n    }\n    resolve({ success: false });\n  });\n}"
  },
  "runBrowser": {
    "name": "runBrowser",
    "slug": "TsFunction",
    "id": "qpbcbtjkgmajzuoszprwjsil",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (): Promise<Browser> => {\n  console.log(\"Run browser called\");\n  puppeteer.use(\n    RecaptchaPlugin({\n      provider: {\n        id: \"2captcha\",\n        token: \"243f9da05482cc8e9b76203a184943c9\", // REPLACE THIS WITH YOUR OWN 2CAPTCHA API KEY ⚡\n      },\n      visualFeedback: true, // colorize reCAPTCHAs (violet = detected, green = solved)\n    })\n  );\n\n  puppeteer.use(StealthPlugin());\n  const browser = await puppeteer.launch(browserLunchOptions);\n  const browserWSEndpoint = browser.wsEndpoint();\n  const browserSession: Creation<BrowserSession> = {\n    browserName: \"browser\",\n    browserSessionId: browserWSEndpoint,\n  };\n  console.log(\"browserId\", browser.wsEndpoint());\n  // Remove all the old session\n  await db.clear(\"BrowserSession\");\n  await db.clear(\"BrowserPage\");\n  await db.upsert(\"BrowserSession\", browserSession);\n  openMultiTabs({\n    noOfTabs: 10,\n    tabUrl: \"https://chat.openai.com/chat\",\n    browser,\n  });\n  return browser;\n}"
  },
  "setBrowserPageIdle": {
    "name": "setBrowserPageIdle",
    "slug": "TsFunction",
    "id": "fwytpmzwmonfnvtetocxfmxy",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (pageId: string, status: boolean) => {\n  await db.update(\n    \"BrowserPage\",\n    (c) => c.pageId === pageId,\n    (content) => ({ ...content, isIdle: status })\n  );\n}"
  },
  "setBrowserSession": {
    "name": "setBrowserSession",
    "slug": "TsFunction",
    "id": "evecmqikamqlodvqacsvgccb",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " (browser: Browser) => {\n    browserSession.set(\"browser\", browser);\n}"
  },
  "setInnerHtml": {
    "name": "setInnerHtml",
    "slug": "TsFunction",
    "id": "dhwxwjfsalstwemavwrkptkr",
    "description": "Help to set the html element on the provided selector",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  page: Page;\n  selector: string;\n  value: string;\n}) => {\n  const { page, selector, value } = props;\n  console.log(\"select in fnc\", selector, value);\n  await page.evaluate(\n    ({ value, selector }) => {\n      const h3Element: ElementType | null = document.querySelector(\n        `${selector}`\n      );\n      if (h3Element) {\n        h3Element.click?.();\n        h3Element.focus?.();\n        h3Element.innerHTML = value;\n      }\n    },\n    { value, selector }\n  );\n}"
  },
  "setInputValue": {
    "name": "setInputValue",
    "slug": "TsFunction",
    "id": "ulbazlkjzcirzpzovamedcco",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (params: SetInputValueType) => {\n  const { page, selector, inputValue } = params;\n  await page.waitForSelector(selector);\n  await page.$eval(\n    selector,\n    (elem: ElementType, args: any) => {\n      elem.value = args.value;\n    },\n    { value: inputValue }\n  );\n}"
  },
  "solveReptcha": {
    "name": "solveReptcha",
    "slug": "TsFunction",
    "id": "svzbdusdytvijxeciwegioqn",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": " async (\n  page: Page\n): Promise<SolveRecaptchasResult> => {\n  const solveRecaptchaResult = await page?.solveRecaptchas();\n  return solveRecaptchaResult;\n}"
  },
  "trueClick": {
    "name": "trueClick",
    "slug": "TsFunction",
    "id": "lfaufveyaipepcpqrmhpeciz",
    "description": "Utility function to call the element onclick event directly.\nSuccess when clicking is improved over puppeteer page.click('selector')",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  /** the page element from puppeteer got with browser.pages */\n  page: Page;\n  /** the css selector to click */\n  selector: string;\n}): Promise<{ success: boolean }> => {\n  try {\n    const { page, selector } = props;\n    await page.evaluate((sendButtonSelector: string) => {\n      let a = document.querySelector(sendButtonSelector);\n      (a as HTMLElement).click?.();\n    }, selector);\n    return {\n      success: true,\n    };\n  } catch (err) {\n    return {\n      success: false,\n    };\n  }\n}"
  },
  "twitterLogin": {
    "name": "twitterLogin",
    "slug": "TsFunction",
    "id": "aigifnttfmpqifvbtovftsbf",
    "description": "Method that help to login into twitter",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  page: Page;\n  password: string;\n  username: string;\n}) => {\n  const { page, password, username } = props;\n  await page.goto(\"https://twitter.com/login\");\n  // Adding listener for console\n  page.on(\"console\", (message) => console.log(`${message.text()}`));\n  // wait for username input field to appear\n  await typeInTheInputField({\n    page,\n    selector: 'input[autocomplete=\"username\"]',\n    value: username,\n  });\n\n  // clicking next button\n  await page.click(\n    'div[class=\"css-18t94o4 css-1dbjc4n r-sdzlij r-1phboty r-rs99b7 r-ywje51 r-usiww2 r-2yi16 r-1qi8awa r-1ny4l3l r-ymttw5 r-o7ynqc r-6416eg r-lrvibr r-13qz1uu\"]'\n  );\n\n  // wait for the password field to appear\n  await typeInTheInputField({\n    page,\n    selector: 'input[autocomplete=\"current-password\"]',\n    value: password,\n  });\n  // waiting and clicking on the login button\n  await page.waitForSelector(\n    'div[class=\"css-901oao r-1awozwy r-6koalj r-18u37iz r-16y2uox r-37j5jr r-a023e6 r-b88u0q r-1777fci r-rjixqe r-bcqeeo r-q4m81j r-qvutc0\"]'\n  );\n  await page.click(\n    'div[class=\"css-901oao r-1awozwy r-6koalj r-18u37iz r-16y2uox r-37j5jr r-a023e6 r-b88u0q r-1777fci r-rjixqe r-bcqeeo r-q4m81j r-qvutc0\"]'\n  );\n}"
  },
  "typeInTheInputField": {
    "name": "typeInTheInputField",
    "slug": "TsFunction",
    "id": "yevngsmxlknbzblyozgihysv",
    "description": "Help to type in the field in given selector by setting value",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  page: Page;\n  selector: string;\n  value: string;\n}) => {\n  const { page, selector, value } = props;\n  // wait for selector\n  await page.waitForSelector(selector, { timeout: 30000 });\n  // click, focus and enter the value\n  await page.click(selector);\n  await page.focus(selector);\n  // throw 'test message';\n  await page.keyboard.type(value);\n}"
  },
  "typeOnTheTargetWithXpathSelector": {
    "name": "typeOnTheTargetWithXpathSelector",
    "slug": "TsFunction",
    "id": "ssebjihntpzlpncotsoodhvq",
    "description": "Help to type in the input field using x-path",
    "operationName": "puppeteer-utils",
    "rawText": " async (props: {\n  page: Page;\n  selector: string;\n  text: string;\n}) => {\n  const { page, selector, text } = props;\n  const targetedElement = await page.$x(selector);\n\n  if (targetedElement[0]) {\n    await targetedElement[0].focus();\n    //@ts-ignore\n    await targetedElement[0].click();\n    console.log(\n      \"selector find and click\",\n      await (await targetedElement[0].getProperty(\"role\")).jsonValue()\n    );\n  }\n  console.log(\"Aout to type\", text);\n  await page.keyboard.type(text);\n}"
  },
  "waitMilliseconds": {
    "name": "waitMilliseconds",
    "slug": "TsFunction",
    "id": "shlqjbdskypyqjcrtbgafyaq",
    "description": "Utility functions to wait millisseconds. eg: 3000 waits 3 seconds",
    "operationName": "puppeteer-utils",
    "rawText": " async (milliseconds: number) =>\n  new Promise((resolve) => setTimeout(() => resolve(true), milliseconds))"
  },
  "A": {
    "name": "A",
    "slug": "TsFunction",
    "id": "qrcyhzhwwyyqfliazldmvsus",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, className, textClassName, ...props }: AType) => {\n  return <a {...props} className={joinClassNames(className, textClassName)} />;\n}"
  },
  "ActivityIndicator": {
    "name": "ActivityIndicator",
    "slug": "TsFunction",
    "id": "urlierxgwnhdtzznkfqartqi",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " (props: ActivityIndicatorType) => {\n  const sizeClass =\n    typeof props.size === \"number\"\n      ? \"\"\n      : props.size === \"large\"\n      ? \"w-16 h-16\"\n      : \"w-6 h-6\";\n  const sizeStyle =\n    typeof props.size === \"number\"\n      ? { width: props.size, height: props.size }\n      : undefined;\n\n  const borderClass =\n    props.color === \"white\"\n      ? \"border-white dark:border-gray-900\"\n      : \"border-gray-900 dark:border-white\";\n\n  const className = `${sizeClass} border-b-2 ${borderClass} rounded-full animate-spin ${\n    props.className || \"\"\n  }`;\n\n  return <div style={sizeStyle} className={className} />;\n}"
  },
  "Aside": {
    "name": "Aside",
    "slug": "TsFunction",
    "id": "ftquzjsvtvecbynuhpnocpbv",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({\n  native,\n  textClassName,\n  className,\n  children,\n}: AsideType) => {\n  const tailwind = useTailwind();\n  const { style, ...nativeWithoutStyle } = native || {};\n  const tailwindStyle = className ? tailwind(trimClassName(className)) : {};\n  return (\n    <View style={[tailwindStyle, style]} {...nativeWithoutStyle}>\n      {wrapInTextIfNeeded(children, textClassName)}\n    </View>\n  );\n}"
  },
  "Button": {
    "name": "Button",
    "slug": "TsFunction",
    "id": "eljtwqwllnhxnytqxaljlsrz",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({\n  native,\n  className,\n  textClassName,\n  ...props\n}: ButtonType) => {\n  return (\n    <button {...props} className={joinClassNames(className, textClassName)} />\n  );\n}"
  },
  "Div": {
    "name": "Div",
    "slug": "TsVariable",
    "id": "mqjctfdrchjvopkmaavakrpk",
    "description": "",
    "operationName": "react-with-native"
  },
  "Form": {
    "name": "Form",
    "slug": "TsFunction",
    "id": "mrvubyawvlsodtocnycctbgz",
    "description": "Form is just a html form on web. On react-native, it's a View",
    "operationName": "react-with-native",
    "rawText": " ({\n  native,\n  className,\n  textClassName,\n  ...props\n}: FormType) => {\n  return (\n    <form {...props} className={joinClassNames(className, textClassName)} />\n  );\n}"
  },
  "getTailwindModules": {
    "name": "getTailwindModules",
    "slug": "TsFunction",
    "id": "ldjajcnczjvyxlthlztzpmov",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " (options: {\n  /**\n   * if you are using a sensible v1 monorepo, put the packages with tailwind-based ui here\n   */\n  packages?: string[] /**\n  if you are using any tailwind-based node-modules, put them here.\n */;\n  modules?: string[];\n  /**\n *  if this is a yarn workspace, put true here\n\n */\n  isWorkspace?: boolean;\n}) => {\n  const packages =\n    options.packages?.map((module) => {\n      return `../../packages/${module}/src/**/*.{ts,tsx,js,jsx}`;\n    }) || [];\n\n  const modules =\n    options.modules?.map((module) => {\n      return options.isWorkspace\n        ? `../../node_modules/${module}/{src,build,dist}/**/*.{ts,tsx,js,jsx}`\n        : `./node_modules/${module}/{src,build,dist}/**/*.{ts,tsx,js,jsx}`;\n    }) || [];\n\n  return packages?.concat(modules);\n}"
  },
  "H2": {
    "name": "H2",
    "slug": "TsFunction",
    "id": "lvamelwitaglwukyscmnwwyw",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, ...props }: H2Type) => {\n  return <h2 {...props} />;\n}"
  },
  "I": {
    "name": "I",
    "slug": "TsFunction",
    "id": "jeorcpzygnlpdqmggxxiwvue",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, ...props }: IType) => {\n  return <i {...props} />;\n}"
  },
  "Image": {
    "name": "Image",
    "slug": "TsFunction",
    "id": "abygyzhdmcdwfzhwfiipojfb",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, ...props }: ImgType) => {\n  //@ts-ignore TODO: what's this?\n  return <img {...props} />;\n}"
  },
  "Input": {
    "name": "Input",
    "slug": "TsFunction",
    "id": "hkrdkhihpsgohkwglaefalrq",
    "description": "",
    "operationName": "react-with-native-form",
    "rawText": " <\n  TInputs extends AllPluginInputTypes,\n  T extends keyof TInputs\n>({\n  type,\n  plugin,\n  title,\n  onChange,\n  value,\n  isLast,\n  startSection,\n  sectionTitle,\n  next,\n  extra,\n  errors,\n  reference,\n  description,\n  config,\n  uniqueFieldId,\n  renderInputContainer,\n  errorClassName,\n  fieldName,\n}: {\n  plugin: PluginComponent<TInputs[T]>;\n  type: string;\n  fieldName: string;\n  config: TInputs[T][\"config\"];\n  extra: TInputs[T][\"extra\"];\n  next: any;\n  title?: string;\n  onChange: OnChange<TInputs[T]>;\n  value: TInputs[T][\"value\"];\n  errors?: Error[];\n  isLast: boolean;\n  startSection?: boolean;\n  sectionTitle?: string;\n  reference?: RefObject<HTMLDivElement>;\n  description?: string;\n  /**\n   * format: {uniqueGeneratedNumber}.{fieldName}\n   */\n  uniqueFieldId: string;\n  renderInputContainer?: RenderInputContainerType;\n  errorClassName?: string;\n}) => {\n  const InputComponent = plugin;\n  const InputContainer = renderInputContainer || DefaultInputContainer;\n  return (\n    <Div ref={reference}>\n      <InputContainer\n        {...{\n          description,\n          sectionTitle,\n          startSection,\n          title,\n          next,\n          isLast,\n          id: uniqueFieldId,\n          type,\n          error:\n            !plugin.hideContainerError &&\n            errors?.find(errorOnField(fieldName))?.message,\n          extra,\n          config,\n          errorClassName,\n        }}\n      >\n        <InputComponent\n          {...{\n            uniqueFieldId,\n            fieldName,\n            config,\n            extra,\n            onChange,\n            value,\n            errors,\n            errorClassName,\n          }}\n        />\n      </InputContainer>\n    </Div>\n  );\n}"
  },
  "joinClassNames": {
    "name": "joinClassNames",
    "slug": "TsFunction",
    "id": "slfrsixqrjqeevpcgbgbovfx",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " (...args: (string | undefined)[]) => {\n  return args.filter((x) => !!x).join(\" \");\n}"
  },
  "Label": {
    "name": "Label",
    "slug": "TsFunction",
    "id": "pfvsxnmwbqfugsfjsgmsetyi",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, ...props }: LabelType) => {\n  return <label {...props} />;\n}"
  },
  "Li": {
    "name": "Li",
    "slug": "TsFunction",
    "id": "bzuuiiwuojcukyapzrptmhvx",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, className, textClassName, ...props }: LiType) => {\n  return <li {...props} className={joinClassNames(className, textClassName)} />;\n}"
  },
  "Nav": {
    "name": "Nav",
    "slug": "TsFunction",
    "id": "bdllurhsrdprulscjsbilrru",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({\n  native,\n  textClassName,\n  className,\n  children,\n}: NavType) => {\n  const tailwind = useTailwind();\n  const { style, ...nativeWithoutStyle } = native || {};\n  const tailwindStyle = className ? tailwind(trimClassName(className)) : {};\n\n  return (\n    <View\n      style={[\n        tailwindStyle,\n        style,\n        {\n          flexDirection: \"row\",\n          alignItems: \"center\",\n          elevation: 0,\n        },\n      ]}\n      {...nativeWithoutStyle}\n    >\n      {wrapInTextIfNeeded(children, textClassName)}\n    </View>\n  );\n}"
  },
  "Ol": {
    "name": "Ol",
    "slug": "TsFunction",
    "id": "usrteyuweenbfrwatfvuxvrd",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, className, textClassName, ...props }: OlType) => {\n  return <ol {...props} className={joinClassNames(className, textClassName)} />;\n}"
  },
  "P": {
    "name": "P",
    "slug": "TsFunction",
    "id": "ukrbkqwtrktjzbcvjxwdwwvj",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, ...props }: PType) => {\n  return <p {...props} />;\n}"
  },
  "Pressable": {
    "name": "Pressable",
    "slug": "TsFunction",
    "id": "unewlcxyyllmxtucfhkqbiao",
    "description": "button on web, pressable on react-native",
    "operationName": "react-with-native",
    "rawText": " ({\n  native,\n  textClassName,\n  className,\n  ...props\n}: PressableType) => {\n  return (\n    <button {...props} className={joinClassNames(className, textClassName)} />\n  );\n}"
  },
  "PureAside": {
    "name": "PureAside",
    "slug": "TsFunction",
    "id": "hdttumxeqbmxygpcpfsajdny",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " (\n  { native, className, textClassName, ...props }: AsideType,\n  ref: any\n) => {\n  return (\n    <aside\n      {...props}\n      ref={ref}\n      className={joinClassNames(className, textClassName)}\n    />\n  );\n}"
  },
  "PureDiv": {
    "name": "PureDiv",
    "slug": "TsFunction",
    "id": "ikbnfmlgcvmutfokrxxjpeex",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " (\n  { native, className, textClassName, scroll, ...props }: DivType,\n  ref: any\n) => {\n  return (\n    <div\n      {...props}\n      ref={ref}\n      className={joinClassNames(className, textClassName)}\n    />\n  );\n}"
  },
  "PureNav": {
    "name": "PureNav",
    "slug": "TsFunction",
    "id": "uhsygvrtgzbplvqkntpjpnlq",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " (\n  { native, className, textClassName, ...props }: NavType,\n  ref: any\n) => {\n  return (\n    <nav\n      {...props}\n      ref={ref}\n      className={joinClassNames(className, textClassName)}\n    />\n  );\n}"
  },
  "Select": {
    "name": "Select",
    "slug": "TsFunction",
    "id": "qulsvfnofediitrtifxlbrmw",
    "description": "renders either a SelectDropdown or SelectDrawer, based on screensize",
    "operationName": "react-with-native-select",
    "rawText": " <T extends unknown>({\n  options,\n  onChange,\n  value,\n  title,\n  containerClassName,\n  selectFirstOption,\n  autoSuggest,\n  //unused atm\n  children,\n  className,\n  noPlaceholder,\n  placeholder,\n  ios,\n}: SelectProps<T>) => {\n  const [temporaryValue, setTemporaryValue] = useState(\"\");\n  const [id] = useState(`list${String(Math.round(Math.random() * 100000))}`);\n\n  const realValue = getRealValue({ value, selectFirstOption, options, title });\n\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/datalist\n\n  const onChangeSelect = (event: ChangeEvent<HTMLSelectElement>) => {\n    const value = event.target.value;\n    const newValue = options.find((x) => String(x.value) === value) || null;\n\n    onChange?.(newValue);\n  };\n\n  const renderOptions = () => {\n    return (\n      <>\n        {options.map((option, index) => {\n          return (\n            <option value={String(option.value)} key={index}>\n              {option.label}\n            </option>\n          );\n        })}\n      </>\n    );\n  };\n\n  return (\n    <div className={containerClassName}>\n      {autoSuggest ? (\n        <span>\n          <input\n            list={id}\n            placeholder={\n              !noPlaceholder ? placeholder || \"Type or select one\" : undefined\n            }\n            onChange={(event) => {\n              const value = event.target.value;\n\n              const foundOption = options.find((x) => x.value === value);\n              if (foundOption) {\n                onChange?.(foundOption);\n                setTemporaryValue(\"\");\n              } else {\n                setTemporaryValue(value);\n              }\n            }}\n            className={className}\n            value={\n              temporaryValue && temporaryValue.length > 0\n                ? temporaryValue\n                : value?.value\n                ? String(value?.value)\n                : \"\"\n            }\n          />\n\n          <datalist placeholder={title} id={id}>\n            {renderOptions()}\n          </datalist>\n        </span>\n      ) : (\n        <select\n          onChange={onChangeSelect}\n          className={className}\n          value={String(value?.value)}\n        >\n          {renderOptions()}\n        </select>\n      )}\n    </div>\n  );\n}"
  },
  "Span": {
    "name": "Span",
    "slug": "TsFunction",
    "id": "rlvxwcsfdamdsnbamdkkqszs",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({\n  native,\n  className,\n  textClassName,\n  ...props\n}: SpanType) => {\n  return (\n    <span {...props} className={joinClassNames(className, textClassName)} />\n  );\n}"
  },
  "Strong": {
    "name": "Strong",
    "slug": "TsFunction",
    "id": "mbwzfxcsoeahmailrwgoquia",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, ...props }: StrongType) => {\n  return <strong {...props} />;\n}"
  },
  "Svg": {
    "name": "Svg",
    "slug": "TsFunction",
    "id": "vaicbqgwshzxeyqktqftxhip",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ src, width, height, className, style }: SvgType) => {\n  const Icon: any = src;\n  return (\n    <Icon width={width} height={height} className={className} style={style} />\n  );\n}"
  },
  "TextArea": {
    "name": "TextArea",
    "slug": "TsFunction",
    "id": "llztwpnkyjximtvjusmupsaz",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({\n  native,\n  className,\n  textClassName,\n  ...props\n}: TextAreaType) => {\n  return (\n    <textarea {...props} className={joinClassNames(className, textClassName)} />\n  );\n}"
  },
  "Text": {
    "name": "Text",
    "slug": "TsFunction",
    "id": "omjgfrarkgigaadrxsxbauea",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, ...props }: TextType) => {\n  return <p {...props} />;\n}"
  },
  "Toggle": {
    "name": "Toggle",
    "slug": "TsFunction",
    "id": "gdoaucmxkdhvbyduvrsyqnww",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, onChange, checked, ...props }: ToggleType) => {\n  return (\n    <input\n      type=\"checkbox\"\n      checked={checked}\n      onChange={(e) => onChange(e.target.checked)}\n      {...props}\n    />\n  );\n}"
  },
  "TouchableOpacity": {
    "name": "TouchableOpacity",
    "slug": "TsFunction",
    "id": "yrhqyepcssnyzxuvoywbaory",
    "description": "button on web, pressable on react-native",
    "operationName": "react-with-native",
    "rawText": " ({\n  native,\n  textClassName,\n  className,\n  ...props\n}: TouchableOpacityType) => {\n  return (\n    <button {...props} className={joinClassNames(className, textClassName)} />\n  );\n}"
  },
  "trimClassName": {
    "name": "trimClassName",
    "slug": "TsFunction",
    "id": "rdpnkrvhjhpysznqfdfxruos",
    "description": "in react-native not all classNames are supported",
    "operationName": "react-with-native",
    "rawText": " (className: string) => {\n  return className;\n}"
  },
  "Ul": {
    "name": "Ul",
    "slug": "TsFunction",
    "id": "zcjmjkdqfpdharmvxtyxtoim",
    "description": "",
    "operationName": "react-with-native",
    "rawText": " ({ native, className, textClassName, ...props }: UlType) => {\n  return <ul {...props} className={joinClassNames(className, textClassName)} />;\n}"
  },
  "wrapInTextIfNeeded": {
    "name": "wrapInTextIfNeeded",
    "slug": "TsFunction",
    "id": "qogrhpwbycvvyfwqampjfnio",
    "description": "NB: figure out a way to do the styles of the text right.",
    "operationName": "react-with-native",
    "rawText": " (children: any, textClassName?: string) => {\n  return typeof children === \"string\" ? (\n    <Text className={textClassName}>{children}</Text>\n  ) : (\n    children\n  );\n}"
  },
  "AlertContext": {
    "name": "AlertContext",
    "slug": "TsVariable",
    "id": "xdaljblzsaefcfxelhrtqqnl",
    "description": "",
    "operationName": "react-with-native-alert"
  },
  "AlertProvider": {
    "name": "AlertProvider",
    "slug": "TsFunction",
    "id": "hmcerlluupcxvhscytzosmaz",
    "description": "",
    "operationName": "react-with-native-alert",
    "rawText": " ({ children }: { children: any }) => {\n  // console.log(\"normal alertprovider\");\n  const [alertState, setAlertState] = useState<AlertState[]>([]);\n\n  const firstAlert: AlertState | undefined = alertState[0];\n\n  // console.log({ firstAlert, alertState });\n  const alert: AlertFn = (title, message, buttons, options) => {\n    const newState = { title, message, buttons, options };\n    const newAlertState = alertState.concat([newState]);\n\n    // console.log(\"push alert state\", { newState, alertState, newAlertState });\n    setAlertState(newAlertState);\n  };\n\n  const renderAlert = (firstAlert: AlertState | undefined) => {\n    if (!firstAlert) {\n      // console.log(\"HMMMM\");\n      return null;\n    }\n\n    // console.log(\"Should render alert\");\n\n    const { title, buttons, message, options } = firstAlert;\n\n    const value = undefined; //TODO: make it possible to fill in value here (prompt-alert)\n\n    return (\n      <div className=\"absolute w-screen h-screen inset-0\">\n        <Transition appear show={true} as={Fragment}>\n          <HeadlessUiDialog\n            as=\"div\"\n            className=\"fixed inset-0 z-50 overflow-y-auto backdrop-blur-sm\"\n            onClose={() => {\n              if (options?.cancelable === false) return;\n\n              options?.onDismiss?.();\n\n              setAlertState(alertState.slice(1));\n            }}\n          >\n            <div className=\"min-h-screen px-4 text-center\">\n              <Transition.Child\n                as={Fragment}\n                enter=\"ease-out duration-300\"\n                enterFrom=\"opacity-0\"\n                enterTo=\"opacity-100\"\n                leave=\"ease-in duration-200\"\n                leaveFrom=\"opacity-100\"\n                leaveTo=\"opacity-0\"\n              >\n                <HeadlessUiDialog.Overlay className=\"fixed inset-0\" />\n              </Transition.Child>\n\n              {/* This element is to trick the browser into centering the modal contents. */}\n              <span\n                className=\"inline-block h-screen align-middle\"\n                aria-hidden=\"true\"\n              >\n                &#8203;\n              </span>\n              <Transition.Child\n                as={Fragment}\n                enter=\"ease-out duration-300\"\n                enterFrom=\"opacity-0 scale-95\"\n                enterTo=\"opacity-100 scale-100\"\n                leave=\"ease-in duration-200\"\n                leaveFrom=\"opacity-100 scale-100\"\n                leaveTo=\"opacity-0 scale-95\"\n              >\n                <Div\n                  className={\n                    \"inline-block w-full max-w-lg p-6 my-8 overflow-hidden text-left align-middle transition-all transform bg-white shadow-xl rounded-2xl\"\n                  }\n                >\n                  {title ? (\n                    <HeadlessUiDialog.Title\n                      as=\"h3\"\n                      className={\"text-lg font-medium leading-6 text-gray-900\"}\n                    >\n                      {title}\n                    </HeadlessUiDialog.Title>\n                  ) : null}\n                  <P className=\"py-6\">{message}</P>\n                  <Div className=\"flex flex-row gap-4\">\n                    {buttons?.map((button, index) => {\n                      const buttonColor =\n                        button.style === \"cancel\"\n                          ? \"bg-gray-300 hover:bg-gray-400\"\n                          : button.style === \"destructive\"\n                          ? \"bg-red-500 hover:bg-red-600\"\n                          : \"bg-blue-500 hover:bg-blue-600\";\n                      return (\n                        <Div\n                          onClick={() => {\n                            button.onPress?.(value);\n                            setAlertState(alertState.slice(1));\n                          }}\n                          key={`button${index}`}\n                          className={`cursor-pointer py-2 ${buttonColor} rounded-md flex flex-1 items-center justify-center`}\n                        >\n                          {button.text}\n                        </Div>\n                      );\n                    })}\n                  </Div>\n                </Div>\n              </Transition.Child>\n            </div>\n          </HeadlessUiDialog>\n        </Transition>\n      </div>\n    );\n  };\n\n  return (\n    <AlertContext.Provider value={alert}>\n      {renderAlert(firstAlert)}\n      {children}\n    </AlertContext.Provider>\n  );\n}"
  },
  "useAlert": {
    "name": "useAlert",
    "slug": "TsFunction",
    "id": "jxfuuschowpvqpzzdafobljj",
    "description": "",
    "operationName": "react-with-native-alert",
    "rawText": " () => {\n  const alert = React.useContext(AlertContext);\n  return alert;\n}"
  },
  "DataForm": {
    "name": "DataForm",
    "slug": "TsFunction",
    "id": "qtbnfwplrsohdliytdkryucf",
    "description": "",
    "operationName": "react-with-native-form",
    "rawText": " <TInputs, TState extends { [key: string]: any }>({\n  fields,\n  defaultValues,\n  initialValues,\n  onSubmit,\n  withSubmitProps,\n  noSubmit,\n  submitButtonText,\n  submitButtonColor,\n  title,\n  backButton,\n  plugins,\n  renderSubmitComponent,\n  renderInputContainer,\n  stickySubmit,\n  renderTitle,\n  submitClassName,\n  errorClassName,\n  successClassName,\n}: DataFormProps<TInputs, TState>) => {\n  //sometimes use defaultValues (deprecated)\n\n  initialValues = initialValues ? initialValues : defaultValues;\n  if (!plugins) {\n    throw new Error(\"No plugins given\");\n  }\n  //Generate unique id for the form\n  const [id] = useState(`Form${String(Math.round(Math.random() * 1000000))}`);\n\n  const [fieldsWithReferences, setFieldsWithReferences] = useState<\n    ExtendedField<TInputs, Keys<TInputs>>[]\n  >([]);\n\n  // need to have because we want to see when it's changed\n  const [fieldsWithoutReferences, setFieldsWithoutReferences] = useState<\n    Field<TInputs, Keys<TInputs>>[]\n  >([]);\n\n  useEffect(() => {\n    const fieldsWithoutReferencesLocal = fields.map((f) => f());\n\n    if (\n      // fieldsWithoutReferences.length === 0 && //NB: why was this here? caused the fields not to refresh\n      !sameFieldArray<Field<TInputs, Keys<TInputs>>[], TInputs>(\n        fieldsWithoutReferencesLocal,\n        fieldsWithoutReferences\n      )\n    ) {\n      setFieldsWithReferences(\n        fieldsWithoutReferencesLocal.map((fieldWithoutReference) => {\n          return {\n            ...fieldWithoutReference,\n            reference: createRef<HTMLDivElement>(),\n          };\n        })\n      );\n      setFieldsWithoutReferences(fieldsWithoutReferencesLocal);\n    }\n  }, [fields]);\n\n  const initialValuesPartial: TState = fields.reduce((all, field) => {\n    const type = field().type!;\n    const plugin = getPlugin(type, plugins);\n    const defaultInital = plugin.component.defaultInitialValue;\n    const initial = field().initialValue;\n    const key = field().field;\n    const value =\n      initial !== undefined\n        ? initial\n        : defaultInital !== undefined\n        ? defaultInital\n        : undefined;\n\n    return {\n      ...all,\n      [key]: value,\n    };\n  }, {}) as TState;\n\n  const initialState = { ...initialValuesPartial, ...initialValues };\n\n  const [state, setState] = useState<TState>(initialState);\n\n  //used to check if the initialValues have changed\n  const [initialValuesState, setInitialValuesState] = useState<\n    TState | undefined\n  >();\n\n  useEffect(() => {\n    if (!initialValuesState || !deepEqual(initialState, initialValuesState)) {\n      // console.log(\"initialValues have changed\");\n      setState(initialState);\n      setInitialValuesState(initialState);\n    }\n  }, [initialState]);\n\n  const [loading, setLoading] = useState(false);\n\n  const [errors, setErrors] = useState<Error[]>([]);\n  const [success, setSuccess] = useState<string | undefined>();\n\n  const notReadyFields = fieldsWithReferences.filter(\n    (x) => !x.shouldHide?.(state) && x.hasError?.(state[x.field], state)\n  );\n\n  const setErrorsReject: RejectType = (stringOrErrorArray) => {\n    if (stringOrErrorArray) {\n      //if the rejection provides a string, just return an array with 1 element: that string, on the global property path\n      //however, if it's an error array, return that. But make sure that if the propertyPath doesn't exist, it's still rendered globally.\n      const newErrors: Error[] =\n        typeof stringOrErrorArray === \"string\"\n          ? [\n              {\n                propertyPath: GLOBAL_PROPERTY_PATH,\n                message: stringOrErrorArray,\n              },\n            ]\n          : stringOrErrorArray.map(({ propertyPath, message }) => ({\n              message,\n              propertyPath: fields\n                .map((f) => f().field)\n                .find(\n                  (x) => propertyPath === x || propertyPath.startsWith(`${x}.`)\n                )\n                ? propertyPath\n                : GLOBAL_PROPERTY_PATH,\n            }));\n\n      //this only happens when there are no frontend errors, so it's safe to replace errors\n      setErrors(newErrors);\n\n      //scroll to the first field that contains an error\n      const firstNotReadyField = fieldsWithReferences.filter(\n        (x) => newErrors.find(errorOnField(x.field)) !== undefined\n      )[0];\n\n      if (isWeb) {\n        const top =\n          (firstNotReadyField?.reference?.current?.getBoundingClientRect?.()\n            .top || 0) +\n          (window.scrollY || 0) -\n          100;\n\n        // console.log(\"setErrorsReject: scrolling to first error field\");\n\n        window.scrollTo?.({\n          top,\n          behavior: \"smooth\",\n        });\n      }\n    }\n  };\n\n  const firstErrorRef = notReadyFields[0]?.reference?.current;\n\n  function onClickSubmit(state: TState) {\n    const frontendErrorArray = fields.reduce((all, field) => {\n      const shouldNotHide = !field().shouldHide?.(state);\n      const errorMessage = field().hasError?.(state[field().field], state);\n      const hasError = shouldNotHide && errorMessage;\n\n      const errors =\n        typeof hasError === \"string\"\n          ? [{ propertyPath: field().field, message: hasError }]\n          : Array.isArray(hasError)\n          ? hasError\n          : [];\n\n      return [...all, ...errors];\n    }, [] as Error[]);\n\n    setErrors(frontendErrorArray);\n    //\n    if (frontendErrorArray?.length === 0) {\n      //no errors\n\n      setLoading(true);\n      onSubmit(\n        state,\n        (successMessage) => {\n          setSuccess(successMessage);\n          setLoading(false);\n        },\n        (stringOrErrorArray) => {\n          setErrorsReject(stringOrErrorArray);\n          setLoading(false);\n        }\n      );\n    } else {\n      //scroll to the error\n      /// onError(\"Please fill in all fields correctly\");\n\n      if (isWeb) {\n        const top =\n          (firstErrorRef?.getBoundingClientRect().top || 0) +\n          window.scrollY -\n          100;\n        // console.log(\"onClickSubmit: scrolling to first error field\");\n\n        window.scrollTo?.({\n          top,\n          behavior: \"smooth\",\n        });\n      }\n    }\n  }\n\n  const available = !loading && notReadyFields.length === 0;\n\n  const submitProps: SubmitProps = {\n    loading,\n    available,\n    submitButtonText,\n    submitButtonColor,\n    //should be overwritten on state change\n    onSubmit: () => onClickSubmit(state),\n    state,\n  };\n\n  useEffect(() => {\n    //console.log({ withSubmitProps: submitProps });\n    withSubmitProps?.(submitProps);\n  }, [loading, available, submitButtonText, submitButtonColor, firstErrorRef]);\n\n  const Title = renderTitle || DefaultTitle;\n\n  const Submit = () =>\n    noSubmit ? null : renderSubmitComponent ? (\n      renderSubmitComponent(submitProps)\n    ) : (\n      <Button\n        disabled={loading}\n        className={`${\n          available\n            ? `${submitButtonColor ? submitButtonColor : \"bg-green-500\"}`\n            : \"bg-gray-300\"\n        }  flex justify-center flex-row w-full px-4 py-2 text-sm font-medium text-white border border-transparent rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500`}\n        onClick={() => onClickSubmit(state)}\n        //......Extra\n        style={{\n          backgroundColor: \"#4ade80\",\n          color: \"white\",\n          width: \"100%\",\n          marginTop: 5,\n          marginBottom: 5,\n          display: \"flex\",\n          justifyContent: \"center\",\n          borderRadius: 10,\n          alignItems: \"center\",\n          borderColor: \"white\",\n          padding: 8,\n        }}\n      >\n        {loading ? (\n          <Div className=\"mr-2\">\n            <ActivityIndicator />\n          </Div>\n        ) : null}\n        <Label style={{ color: \"white\", fontWeight: \"bold\" }}>\n          {submitButtonText || \"Save\"}\n        </Label>\n      </Button>\n    );\n  const globalError = errors?.find(\n    (x) => x.propertyPath === GLOBAL_PROPERTY_PATH\n  );\n  return (\n    <Form\n      className=\"w-full\"\n      onSubmit={(e) => {\n        e.preventDefault();\n        onClickSubmit(state);\n      }}\n    >\n      <Div className=\"w-full\">\n        <Title title={title} backButton={backButton} />\n\n        {success ? <P className={successClassName}>{success}</P> : null}\n        {globalError ? (\n          <P className={errorClassName || \"text-red-600\"}>\n            {globalError.message}\n          </P>\n        ) : null}\n\n        {fieldsWithReferences.map((field, index) => {\n          // Take the first plugin if the plugin isn't defined.\n          const plugin = getPlugin(field.type, plugins);\n\n          if (!plugin) {\n            return (\n              <P>\n                Plugin not found ({field.field}, {field.type})\n              </P>\n            );\n          }\n\n          const next = fields[index + 1]?.();\n\n          const onChange = (state: TState) => (newValue: any) => {\n            const newState = { [field.field]: newValue };\n            const newFullState = { ...state, ...newState };\n            const fieldErrors = errors.filter(errorOnField(field.field));\n\n            //check if field still has error(s)\n            const newFieldErrors = field.hasError?.(newValue, newFullState);\n            const newFieldErrorsAmount =\n              typeof newFieldErrors === \"string\"\n                ? 1\n                : Array.isArray(newFieldErrors)\n                ? newFieldErrors.length\n                : 0;\n            if (\n              fieldErrors.length > 0 &&\n              newFieldErrorsAmount !== fieldErrors.length\n            ) {\n              const newErrors = errors.filter(\n                (error) => !errorOnField(field.field)(error)\n              );\n              const newFieldErrorsArray: Error[] =\n                typeof newFieldErrors === \"string\"\n                  ? [{ message: newFieldErrors, propertyPath: field.field }]\n                  : Array.isArray(newFieldErrors)\n                  ? newFieldErrors\n                  : [];\n\n              setErrors([...newErrors, ...newFieldErrorsArray]);\n            }\n\n            setState(newFullState);\n            //NB: make sure to add the new state to the submitprops\n            withSubmitProps?.({\n              ...submitProps,\n              state: newFullState,\n              onSubmit: () => onClickSubmit(newFullState),\n            });\n          };\n\n          const uniqueFieldId = `${id || \"\"}.${field.field}`;\n\n          const inputErrors = errors.filter(\n            (e) =>\n              e.propertyPath === field.field ||\n              e.propertyPath.startsWith(`${field.field}.`)\n          );\n\n          return field.shouldHide?.(state) ? null : (\n            <Input\n              fieldName={field.field}\n              renderInputContainer={renderInputContainer}\n              uniqueFieldId={uniqueFieldId}\n              config={plugin.config}\n              plugin={plugin.component}\n              extra={field.extra}\n              reference={field.reference}\n              next={next}\n              key={`field-${field.field}`}\n              type={field.type!}\n              title={\n                field.titleFromState ? field.titleFromState(state) : field.title\n              }\n              value={state[field.field]}\n              onChange={onChange(state)}\n              isLast={index === fields?.length - 1}\n              startSection={field.startSection}\n              sectionTitle={field.sectionTitle}\n              description={field.description}\n              errors={inputErrors}\n            />\n          );\n        })}\n      </Div>\n      {Submit ? (\n        <Div\n          className={`${stickySubmit ? \"sticky bottom-0\" : \"\"} ${\n            submitClassName || \"mb-2 py-2\"\n          }`}\n        >\n          <Submit />\n        </Div>\n      ) : null}\n    </Form>\n  );\n}"
  },
  "DefaultInputContainer": {
    "name": "DefaultInputContainer",
    "slug": "TsFunction",
    "id": "gtmbcwnbzpdrngdoiwbbppmy",
    "description": "",
    "operationName": "react-with-native-form",
    "rawText": " ({\n  children,\n  startSection,\n  sectionTitle,\n  title,\n  description,\n  error,\n  errorClassName,\n}: InputContainerProps) => (\n  <Div>\n    {startSection ? (\n      <Div\n        style={{\n          display: \"flex\",\n          height: 40,\n          justifyContent: \"center\",\n          paddingLeft: 10,\n        }}\n      >\n        {sectionTitle ? (\n          <P>\n            <Strong>{sectionTitle}</Strong>\n          </P>\n        ) : (\n          <Div style={{ height: 40 }} />\n        )}\n      </Div>\n    ) : null}\n\n    {/* This is the section title */}\n    <Div className=\"pt-0 mb-6\" style={{ marginBottom: 10 }}>\n      {title ? <Label className=\"mb-2 text-sm font-bold\">{title}</Label> : null}\n      {description && (\n        <Div className={`flex mx-3 mb-2 items-start `}>\n          <P className={`text-gray-500 italic`}>{description}</P>\n        </Div>\n      )}\n      {error ? (\n        <P className={errorClassName || `mr-3 mb-2 text-red-500`}>\n          {error || \"Invalid value\"}\n        </P>\n      ) : null}\n\n      <Div>{children}</Div>\n    </Div>\n  </Div>\n)"
  },
  "DefaultTitle": {
    "name": "DefaultTitle",
    "slug": "TsFunction",
    "id": "edilrintrbwdnmvatbmrhlnk",
    "description": "",
    "operationName": "react-with-native-form",
    "rawText": " ({\n  title,\n  backButton,\n}: {\n  title?: string;\n  backButton?: () => void;\n}) => {\n  return title ? (\n    <Div className=\"flex items-center mb-10 \">\n      {backButton && (\n        <Div onClick={backButton} className={`p-4 cursor-pointer`}>\n          back\n        </Div>\n      )}\n      <H2 className=\"text-2xl font-bold\">{title}</H2>\n    </Div>\n  ) : null;\n}"
  },
  "errorOnField": {
    "name": "errorOnField",
    "slug": "TsFunction",
    "id": "wtsrrvmabznkogqktrmgfded",
    "description": "",
    "operationName": "react-with-native-form",
    "rawText": " (fieldName: string) => (error: Error) =>\n  error.propertyPath === fieldName ||\n  error.propertyPath.startsWith(fieldName + \".\")"
  },
  "getPlugin": {
    "name": "getPlugin",
    "slug": "TsFunction",
    "id": "anmjhjdkmxqentvwnqfiytiw",
    "description": "",
    "operationName": "react-with-native-form",
    "rawText": " <TInputs extends AllPluginInputTypes>(\n  type: string | undefined,\n  plugins: Plugins<TInputs>\n) => {\n  return type\n    ? plugins[type]\n    : plugins[Object.keys(plugins)[0] as keyof Plugins<TInputs>];\n}"
  },
  "GLOBAL_PROPERTY_PATH": {
    "name": "GLOBAL_PROPERTY_PATH",
    "slug": "TsVariable",
    "id": "uadijaoytgigmfzismqobegi",
    "description": "",
    "operationName": "react-with-native-form"
  },
  "inputClassWithoutWidth": {
    "name": "inputClassWithoutWidth",
    "slug": "TsVariable",
    "id": "jsaazqkyxvgtdacbmrjlfyef",
    "description": "",
    "operationName": "react-with-native-form"
  },
  "isWeb": {
    "name": "isWeb",
    "slug": "TsVariable",
    "id": "xroiktbqahauxqldkynoympo",
    "description": "",
    "operationName": "react-with-native-form"
  },
  "makeInputField": {
    "name": "makeInputField",
    "slug": "TsFunction",
    "id": "mzmufixxtqmhxckrroquytgh",
    "description": "",
    "operationName": "react-with-native-form",
    "rawText": " <TInputs, T extends Keys<TInputs>>(\n  type: T,\n  config: Omit<Field<TInputs, T>, \"type\">\n) => {\n  return () => ({ type, ...config });\n}"
  },
  "sameFieldArray": {
    "name": "sameFieldArray",
    "slug": "TsFunction",
    "id": "nzlurzgxukzntwdtuihizmhc",
    "description": "",
    "operationName": "react-with-native-form",
    "rawText": " <\n  T extends Field<TInputs, Keys<TInputs>>[],\n  TInputs extends any\n>(\n  arr1: T,\n  arr2: T\n) => {\n  const simpleArr1 = arr1.map(\n    ({ shouldHide, titleFromState, hasError, ...item }) => item\n  );\n  const simpleArr2 = arr2.map(\n    ({ shouldHide, titleFromState, hasError, ...item }) => item\n  );\n\n  const isDeepEqual = deepEqual(simpleArr1, simpleArr2);\n  // console.log({ simpleArr1, simpleArr2, isDeepEqual });\n  return isDeepEqual;\n}"
  },
  "InputSize": {
    "name": "InputSize",
    "slug": "TsVariable",
    "id": "armxhfuknmzlneigkqkiuroo",
    "description": "Inheritance of different button themes",
    "operationName": "react-with-native-form-asset-input"
  },
  "InputTheme": {
    "name": "InputTheme",
    "slug": "TsVariable",
    "id": "dbwzalbysedklgrdvcuimeen",
    "description": "Inheritance of different button themes",
    "operationName": "react-with-native-form-asset-input"
  },
  "castToNumber": {
    "name": "castToNumber",
    "slug": "TsFunction",
    "id": "xxvxjghsacpdqjexwblcqghc",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " (\n  numberString: string | null | undefined\n): null | undefined | number => {\n  if (numberString === null) return null;\n  if (numberString === undefined) return undefined;\n  if (numberString === \"\") return undefined;\n\n  const number = Number(numberString);\n\n  if (isNaN(number)) return undefined;\n\n  return number;\n}"
  },
  "DateInput": {
    "name": "DateInput",
    "slug": "TsFunction",
    "id": "vysiodmjztptjyudogkipqcf",
    "description": "CSS Modules, react-datepicker-cssmodules.css",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  value,\n  onChange,\n}) => {\n  return (\n    <DatePicker\n      selected={value}\n      onChange={(date: Date) => {\n        console.log(\"date\", date);\n        onChange(date);\n      }}\n      dateFormat=\"dd-MM-yyyy\"\n      className={UI.dateInput}\n    />\n  );\n}"
  },
  "DatetimeInput": {
    "name": "DatetimeInput",
    "slug": "TsFunction",
    "id": "klqgvtvqofofhwgatiikuwwu",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  extra,\n  value,\n  onChange,\n  ...props\n}) => {\n  const newExtra: DatetimeInputType[\"extra\"] = { ...extra, type: \"dateTime\" };\n  const [date, setDate] = useState<Date>(new Date());\n  //return <TextInput {...props} extra={newExtra} />;\n  const handleChange = (date: any) => {\n    console.warn(\"A date has been picked: \", date);\n    setDate(date);\n    onChange(date);\n  };\n  return (\n    <div>\n      {/* <div>Selected date: </div> */}\n      {/* <div>{date && date.toDateString() + ` ` + date.toLocaleTimeString()}</div> */}\n      {\n        // @ts-ignore\n        <Datetime\n          {...props}\n          value={value ? new Date(value) : new Date()}\n          initialValue={date}\n          onChange={(value: any) => {\n            handleChange(new Date(value));\n          }}\n          className={UI.dateInput}\n        />\n      }\n    </div>\n  );\n}"
  },
  "defaultLatidue": {
    "name": "defaultLatidue",
    "slug": "TsVariable",
    "id": "rwcyzacfdfjlktkeqxdmeysp",
    "description": "",
    "operationName": "react-with-native-form-inputs"
  },
  "defaultLongitude": {
    "name": "defaultLongitude",
    "slug": "TsVariable",
    "id": "enfxmuezzrofmxekmlrfugxm",
    "description": "",
    "operationName": "react-with-native-form-inputs"
  },
  "defaultZoom": {
    "name": "defaultZoom",
    "slug": "TsVariable",
    "id": "wfucevhiaowqxzouifxxzupe",
    "description": "",
    "operationName": "react-with-native-form-inputs"
  },
  "isNumber": {
    "name": "isNumber",
    "slug": "TsFunction",
    "id": "ndxsdejkrkmplfniegrmyjpd",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " (numberString: string | null | undefined) => {\n  if (\n    numberString === null ||\n    numberString === undefined ||\n    numberString === \"\"\n  )\n    return false;\n\n  if (isNaN(Number(numberString))) return false;\n\n  return true;\n}"
  },
  "LabelsInput": {
    "name": "LabelsInput",
    "slug": "TsFunction",
    "id": "tfrxqenyvjhrorwtbznredwm",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  value,\n  extra,\n  onChange,\n  uniqueFieldId,\n}) => {\n  const [textValue, setTextValue] = useState(\"\");\n\n  const processText = (text: string) => {\n    if (text.endsWith(\",\")) {\n      const newValue = value;\n      const trimmedText = text.slice(0, text.length - 1).trim();\n      if (!value.includes(trimmedText)) {\n        value.push(trimmedText);\n      }\n      onChange(newValue);\n      setTextValue(\"\");\n    } else {\n      setTextValue(text);\n    }\n  };\n\n  return (\n    <Div className=\"flex flex-row flex-wrap\">\n      {value.map((text, index) => (\n        <Button\n          onClick={() => {\n            const newValue = value.filter((x) => x !== text);\n            onChange(newValue);\n          }}\n          key={`selected${uniqueFieldId}${index}`}\n          className={`mr-3 px-3 py-2 rounded-md border border-gray-400`}\n        >\n          <P>\n            {text} <Span textClassName=\"text-red-500\">(x)</Span>\n          </P>\n        </Button>\n      ))}\n\n      <Input\n        className={`${UI.bareInput} py-3`}\n        onChange={({ target: { value: text } }) => processText(text)}\n        value={textValue}\n        native={{ onChangeText: processText }}\n      />\n    </Div>\n  );\n}"
  },
  "MapInput": {
    "name": "MapInput",
    "slug": "TsFunction",
    "id": "xfgxconojlzbhxxuqjejdqgy",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  value,\n  onChange,\n  extra,\n  config,\n}) => {\n  //amsterdam\n  const mapRef = useRef<MapRef>(null);\n  const [search, setSearch] = useState(\"\");\n  const [suggestions, setSuggestions] = useState<Suggestion[]>([]);\n  const [viewport, setViewport] = useState({\n    width: \"100%\",\n    height: 300,\n    latitude: value?.latitude,\n    longitude: value?.longitude,\n    zoom: value?.zoom,\n  });\n\n  // Teach Autosuggest how to calculate suggestions for any given input value.\n  const getSuggestions = async (value: string): Promise<Suggestion[]> => {\n    const inputValue = value.trim().toLowerCase();\n\n    if (inputValue?.length === 0) {\n      return [];\n    }\n\n    const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${inputValue}.json?access_token=${config?.mapboxKey}&limit=4`;\n\n    const suggestions = await fetch(url, {\n      method: \"GET\",\n      headers: {\n        Accept: \"application/json\",\n        \"Content-Type\": \"application/json\",\n        // \"User-Agent\": \"*\",\n      },\n    })\n      .then((response) => response.json())\n      .then((response) => {\n        return response;\n      })\n      .catch((error) => {\n        console.error(error);\n      });\n\n    return inputValue?.length === 0 ? [] : suggestions?.features || [];\n  };\n\n  // const debouncedGetSuggestions = useMemo(\n  //   () => debounce(getSuggestions, 2000, { trailing: true }),\n  //   []\n  // );\n\n  // When suggestion is clicked, Autosuggest needs to populate the input\n  // based on the clicked suggestion. Teach Autosuggest how to calculate the\n  // input value for every given suggestion.\n  const getSuggestionValue = (suggestion: Suggestion) => suggestion.place_name;\n\n  // Use your imagination to render suggestions.\n  const renderSuggestion = (suggestion: Suggestion) => {\n    const text = suggestion.place_name;\n\n    return (\n      <div className={`bg-white hover:bg-gray-200 p-4`}>\n        {text?.length > 30 ? text.slice(0, 28) + \"..\" : text}\n      </div>\n    );\n  };\n  const inputProps = {\n    placeholder: \"Find your place\",\n    value: search,\n    onChange: (e: any, { newValue }: { newValue: string }) =>\n      setSearch(newValue),\n  };\n\n  // Autosuggest will call this function every time you need to update suggestions.\n  // You already implemented this logic above, so just use it.\n  const onSuggestionsFetchRequested = async ({ value }: { value: string }) => {\n    const newSuggestions = await getSuggestions(value);\n    if (newSuggestions) {\n      setSuggestions(newSuggestions);\n    }\n  };\n\n  // Autosuggest will call this function every time you need to clear suggestions.\n  const onSuggestionsClearRequested = () => {\n    setSuggestions([]);\n  };\n\n  const selectSuggestion = (_: any, suggestion: { suggestion: Suggestion }) => {\n    const latitude = suggestion.suggestion.center[1];\n    const longitude = suggestion.suggestion.center[0];\n\n    console.log(\"sugg\", suggestion.suggestion);\n    let zoom = 14;\n    if (suggestion.suggestion.bbox) {\n      const latDiff =\n        suggestion.suggestion.bbox[3] - suggestion.suggestion.bbox[1];\n      const lngDiff =\n        suggestion.suggestion.bbox[2] - suggestion.suggestion.bbox[0];\n\n      const avgDiff = (latDiff + lngDiff) / 2;\n\n      zoom = Math.round(Math.log(2500 / avgDiff));\n    }\n\n    const nextViewport: ViewPort = {\n      width: \"100%\",\n      height: 300,\n      latitude,\n      longitude,\n      zoom: zoom,\n    };\n    //@ts-ignore\n    setViewport(nextViewport);\n\n    onChange({\n      latitude: nextViewport.latitude as number,\n      longitude: nextViewport.longitude,\n      zoom: nextViewport?.zoom,\n    });\n  };\n\n  return (\n    <div className={`w-full bg-white border rounded-lg`}>\n      <div className={`w-full bg-white`}>\n        {/* <ReactMapGL\n          doubleClickZoom={false}\n          ref={mapRef}\n          mapStyle=\"mapbox://styles/picozzimichele/ckty78kzo0q4t17qubs9yi8ok\"\n          // className={`w-full h-40`}\n          mapboxAccessToken=\"\"={config?.mapboxKey}\n          {...viewport}\n          // TODO: Fix this, doesn't seem to exist anymore\n          // onViewportChange={(nextViewport: ViewPort | undefined) => {\n          //   //@ts-ignore\n          //   setViewport(nextViewport);\n          //   onChange({\n          //     latitude: nextViewport?.latitude as number,\n          //     longitude: nextViewport?.longitude as number,\n          //     zoom: nextViewport?.zoom as number,\n          //   });\n          // }}\n        ><div>\n          <div\n            onClick={() => {\n              setViewport({ ...viewport, zoom: viewport.zoom + 1 });\n              onChange({\n                latitude: value?.latitude as number,\n                longitude: value?.longitude,\n                zoom: viewport?.zoom + 1,\n              });\n            }}\n            className={`z-10 cursor-pointer absolute top-4 right-4 w-10 h-10 bg-white rounded flex justify-center items-center`}\n          >\n            +\n          </div>\n\n          <div\n            onClick={() => {\n              setViewport({ ...viewport, zoom: viewport.zoom - 1 });\n              onChange({\n                latitude: value?.latitude as number,\n                longitude: value?.longitude,\n                zoom: viewport?.zoom - 1,\n              });\n            }}\n            className={`z-10 cursor-pointer absolute top-16 right-4 w-10 h-10 bg-white rounded flex justify-center items-center`}\n          >\n            -\n          </div>\n\n          <div className={`z-10 absolute top-4 left-0 bg-white mx-10`}>\n            <Autosuggest\n              suggestions={suggestions}\n              onSuggestionsFetchRequested={onSuggestionsFetchRequested}\n              onSuggestionsClearRequested={onSuggestionsClearRequested}\n              getSuggestionValue={getSuggestionValue}\n              renderSuggestion={renderSuggestion}\n              onSuggestionSelected={selectSuggestion}\n              // renderSuggestionsContainer={({ children }) => {\n              //   return <div className={`h-60 overflow-scroll`}>{children}</div>;\n              // }}\n              inputProps={inputProps}\n            />\n          </div>\n          {value && value.latitude && value.longitude && extra?.showMarker && (\n            <Marker\n              latitude={value.latitude}\n              longitude={value.longitude}\n              offsetLeft={0}\n              offsetTop={0}\n            >\n              <p className=\"text-2xl cursor-pointer animate-bounce\">\n                <Svg\n                  src={HiOutlineLocationMarker}\n                  className=\"h-6 text-blue-500\"\n                />\n              </p>\n            </Marker>\n          )}\n          </div>\n        </ReactMapGL> */}\n      </div>\n      <div className={`m-3`}>\n        <p>\n          <strong>Latitude:</strong> {value?.latitude?.toFixed(4)}\n        </p>\n        <p>\n          <strong>Longitude:</strong> {value?.longitude?.toFixed(4)}\n        </p>\n        {extra?.showZoom && (\n          <p>\n            <strong>Zoom:</strong> {value?.zoom?.toFixed(1)}\n          </p>\n        )}\n      </div>\n    </div>\n  );\n}"
  },
  "NumberInput": {
    "name": "NumberInput",
    "slug": "TsFunction",
    "id": "oxhhrlzuwdkgqofbicyiilhp",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  extra,\n  onChange,\n  value,\n  ...props\n}) => {\n  const stringifiedValue =\n    value === null || value === undefined ? \"\" : String(value);\n\n  const [numberStringValue, setNumberStringValue] = useState(stringifiedValue);\n\n  const newExtra: NumberInputType[\"extra\"] = { type: \"text\", ...extra };\n\n  return (\n    <TextInput\n      {...props}\n      value={numberStringValue}\n      onChange={(value) => {\n        setNumberStringValue(value);\n\n        if (isNumber(value)) {\n          const casted = castToNumber(value);\n          onChange(casted);\n        }\n      }}\n      extra={newExtra}\n    />\n  );\n}"
  },
  "PasswordInput": {
    "name": "PasswordInput",
    "slug": "TsFunction",
    "id": "trvekmfoydyjiyrnjqdsonrg",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  extra,\n  ...props\n}) => {\n  const newExtra: PasswordInputType[\"extra\"] = { ...extra, isPassword: true };\n  return <TextInput {...props} extra={newExtra} />;\n}"
  },
  "PhoneInput": {
    "name": "PhoneInput",
    "slug": "TsFunction",
    "id": "qfzihggujulrxwhxqjythkvz",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  extra,\n  ...props\n}) => {\n  const newExtra: PhoneInputType[\"extra\"] = { ...extra, type: \"phone\" };\n  return <TextInput {...props} extra={newExtra} />;\n}"
  },
  "SelectInput": {
    "name": "SelectInput",
    "slug": "TsFunction",
    "id": "kroynqmjqtreaqukvppruelu",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " (props) => {\n  //console.log({ value, extraOptions: extra.options });\n  const { value, extra, onChange, className } = props;\n  return (\n    <Select\n      autoSuggest={extra.autoSuggest}\n      // containerClassName={UI.input}\n      className={className || UI.selectInput}\n      title={extra.title || \"\"}\n      options={extra.options}\n      value={value}\n      onChange={(value) => {\n        if (value) {\n          onChange(value);\n        }\n      }}\n    />\n  );\n}"
  },
  "SelectMultipleInput": {
    "name": "SelectMultipleInput",
    "slug": "TsFunction",
    "id": "bkrinbgoippeaflhtiyuoxbc",
    "description": "",
    "operationName": "react-with-native-select",
    "rawText": " <T extends unknown>(\n  props: SelectMultipleInputProps<T>\n) => {\n  const {\n    onChange,\n    options,\n    className,\n    value,\n    autoSuggest,\n    noPlaceholder,\n    placeholder,\n    title,\n    uniqueFieldId,\n  } = props;\n\n  //console.log({ value, extraOptions: extra.options });\n  const defaultOption: Item<T | null> = {\n    label: title || \"Choose a value\",\n    value: \"\",\n  };\n\n  const optionsLeft = [defaultOption]\n    .concat(options)\n    .filter((x) => !value.find((i) => x.value === i.value));\n  return (\n    <Div className=\"flex flex-row flex-wrap\">\n      {value.map((item, index) => (\n        <Button\n          onClick={() => {\n            const newValue = value.filter((x) => x.value !== item.value);\n            onChange(newValue);\n          }}\n          key={`selected${uniqueFieldId}${index}`}\n          className={`mr-3 px-3 py-2 rounded-md border border-gray-400`}\n        >\n          <P className=\"text-xs\">\n            {item.label} <Span textClassName=\"text-red-500 text-xs\">(x)</Span>\n          </P>\n        </Button>\n      ))}\n\n      {optionsLeft.length > 1 ? (\n        <Select\n          placeholder={placeholder}\n          noPlaceholder={noPlaceholder}\n          autoSuggest={autoSuggest}\n          className={className || UI.selectInput}\n          title={title || \"\"}\n          options={optionsLeft}\n          onChange={(selected) => {\n            // console.log({ selected });\n            if (selected) {\n              const newValue = [...value];\n\n              newValue.push(selected);\n\n              // console.log({ value, newValue });\n              onChange(newValue);\n            }\n          }}\n        />\n      ) : null}\n    </Div>\n  );\n}"
  },
  "StarsInput": {
    "name": "StarsInput",
    "slug": "TsFunction",
    "id": "fpbxbvvdlthdygyxhfodpmcm",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  onChange,\n  value,\n  extra,\n  config,\n}) => {\n  config = config || {};\n\n  // later, this can be extrahered into a react-with-native-stars component, because now this will only work on web\n  return (\n    <ReactStars\n      className={`m-3`}\n      count={5}\n      value={typeof value === \"number\" ? value : 0}\n      onChange={onChange}\n      half={false}\n      size={24}\n      color2={\"#ffd700\"}\n    />\n  );\n}"
  },
  "TextAreaInput": {
    "name": "TextAreaInput",
    "slug": "TsFunction",
    "id": "vuyjucgqrghvewshdsmrypzb",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  value,\n  extra,\n  config,\n  onChange,\n  errors,\n}) => {\n  const hasError = errors && errors.length > 0;\n  const errorClass = hasError ? config?.errorClassName || \"border-red-600\" : \"\";\n\n  return (\n    <TextArea\n      rows={extra?.rows}\n      maxLength={extra?.maxLength}\n      className={\n        config?.replaceClassName ||\n        `${UI.input} ${errorClass} ${config?.extraClassName}`\n      }\n      value={value}\n      onChange={(event) => {\n        onChange(event.target.value);\n      }}\n      native={{ onChangeText: onChange, value }}\n    />\n  );\n}"
  },
  "TextInput": {
    "name": "TextInput",
    "slug": "TsFunction",
    "id": "iyghngiskhltflegzqqqcoqv",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  onChange,\n  value,\n  extra,\n  config,\n  errors,\n}) => {\n  config = config || {};\n  const hasError = errors && errors.length > 0;\n\n  const inputClassWithError = `my-2 ${UI.textInput}${\n    hasError\n      ? config.errorClassName\n        ? config.errorClassName\n        : \" border border-red-400\"\n      : \"\"\n  }`;\n\n  const onChangeText = (value: TextInputType[\"value\"]) => onChange(value);\n  const placeholder = extra?.placeholder;\n  const maxLength = extra?.maxLength;\n\n  return (\n    <Input\n      type={\n        extra?.type ? extra.type : extra?.isPassword ? \"password\" : undefined\n      }\n      className={inputClassWithError}\n      //why doesn't it get applied corectly?\n      style={{\n        padding: 5,\n        paddingTop: 8,\n        paddingBottom: 8,\n        marginTop: 5,\n        marginBottom: 5,\n      }}\n      value={value}\n      onChange={(event) => onChangeText(event.target.value)}\n      placeholder={placeholder}\n      maxLength={extra?.maxLength}\n      autoComplete={extra?.autoComplete}\n      required={extra?.required}\n      disabled={extra?.disabled}\n      native={{\n        value,\n        onChangeText,\n        placeholder,\n        maxLength,\n        secureTextEntry: extra?.isPassword,\n      }}\n    />\n  );\n}"
  },
  "TimeInput": {
    "name": "TimeInput",
    "slug": "TsFunction",
    "id": "eavjgkxinbhjtwxwjrwnxrhj",
    "description": "CSS Modules, react-datepicker-cssmodules.css",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  extra,\n  value,\n  onChange,\n}) => {\n  return (\n    <TimePicker\n      onChange={(time: any) => onChange(time)}\n      value={Moment(value)}\n      showSecond={false}\n      format=\"h:mm a\"\n      use12Hours\n      className={UI.dateInput}\n      // className={inputClass}\n    />\n  );\n}"
  },
  "ToggleInput": {
    "name": "ToggleInput",
    "slug": "TsFunction",
    "id": "wbbcufxxczmuuwciwuqlxqky",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": " ({\n  onChange,\n  value,\n  extra,\n  config,\n  uniqueFieldId,\n  errors,\n  className,\n}) => {\n  config = config || {};\n\n  const defaultClass = \"\";\n  const hasError = errors && errors.length > 0;\n  const errorClass = hasError\n    ? config.errorClassName\n      ? config.errorClassName\n      : \" border border-red-400\"\n    : \"\";\n\n  const classWithError = config.replaceClassName\n    ? `${config.replaceClassName} ${errorClass}`\n    : `${defaultClass} ${config.extraClassName} ${errorClass}`;\n\n  return (\n    <Div className={`flex flex-row items-center ${className || \"\"}`}>\n      <Toggle\n        id={uniqueFieldId}\n        // class not working with border on checkbox\n        className={classWithError}\n        checked={value}\n        onChange={(value: ToggleInputType[\"value\"]) => onChange(value)}\n      />\n      {extra?.label ? (\n        <Label\n          className={`pl-3 select-none ${hasError ? \"text-red-500\" : \"\"}`}\n          htmlFor={uniqueFieldId}\n        >\n          {extra.label}\n        </Label>\n      ) : null}\n    </Div>\n  );\n}"
  },
  "ModalContext": {
    "name": "ModalContext",
    "slug": "TsVariable",
    "id": "ftydifpwgkqurvwdaikyrohd",
    "description": "",
    "operationName": "react-with-native-modal"
  },
  "ModalProvider": {
    "name": "ModalProvider",
    "slug": "TsFunction",
    "id": "fjbozenwxfprbvycidieicyn",
    "description": "",
    "operationName": "react-with-native-modal",
    "rawText": " ({ children }: { children: any }) => {\n  let { showModal, handleModal, modalContent, title } = useModalState();\n  return (\n    <Provider value={{ showModal, handleModal, modalContent, title }}>\n      <Modal />\n      {children}\n    </Provider>\n  );\n}"
  },
  "{ Provider }": {
    "name": "{ Provider }",
    "slug": "TsVariable",
    "id": "xeoxohzaptxvbevgltkuqdvk",
    "description": "",
    "operationName": "react-with-native-modal"
  },
  "useModalState": {
    "name": "useModalState",
    "slug": "TsFunction",
    "id": "zamoqvcbwvieeavrcgsvsoto",
    "description": "",
    "operationName": "react-with-native-modal",
    "rawText": " () => {\n  const [showModal, setShowModal] = useState(false);\n  const [modalContent, setModalContent] = useState<ModalContent>(null);\n  const [title, setTitle] = useState(\"\");\n\n  const handleModal: HandleModal = (\n    content: ModalContent = null,\n    title?: string\n  ) => {\n    setShowModal(!showModal);\n    if (content) {\n      setModalContent(content);\n    }\n    if (title) {\n      setTitle(title);\n    }\n  };\n\n  return { showModal, handleModal, modalContent, title };\n}"
  },
  "useModal": {
    "name": "useModal",
    "slug": "TsFunction",
    "id": "ssqsrgtvjsncbywickcqyuax",
    "description": "",
    "operationName": "react-with-native-modal",
    "rawText": " () => useContext(ModalContext)"
  },
  "ToastContainer": {
    "name": "ToastContainer",
    "slug": "TsFunction",
    "id": "sghyousdhtewfudkvtflyloo",
    "description": "",
    "operationName": "react-with-native-notification",
    "rawText": " () => {\n  return null;\n}"
  },
  "toast": {
    "name": "toast",
    "slug": "TsFunction",
    "id": "mfmqsyzubzqiboqslnqmdeup",
    "description": "title is only shown on native",
    "operationName": "react-with-native-notification",
    "rawText": " (\n  message: { title: string; body: string },\n  options?: ToastOptions\n) => {\n  toastifyToast(message.body, options);\n}"
  },
  "useRouter": {
    "name": "useRouter",
    "slug": "TsFunction",
    "id": "paebyumxgxwbtrwyhghzvycw",
    "description": "",
    "operationName": "react-with-native-router",
    "rawText": " (): NextRouter => {\n  const navigation = useNavigation();\n\n  const push = async (route: any, options: any) => {\n    const realRoute = route === \"/\" ? \"index\" : route;\n    //@ts-ignore\n    navigation.navigate(realRoute, options?.query);\n    return true;\n  };\n\n  const route = \"\";\n\n  const replace = async (\n    url: NextURL,\n    as?: NextURL | undefined,\n    options?:\n      | {\n          shallow?: boolean;\n          locale?: string | false;\n          scroll?: boolean;\n        }\n      | undefined\n  ) => true;\n\n  const reload = () => {};\n  const back = () => navigation.goBack();\n\n  const prefetch = async (\n    url: string,\n    asPath?: string | undefined,\n    options?: PrefetchOptions | undefined\n  ) => {};\n  const events: MittEmitter<RouterEvent> = {\n    on: (type: RouterEvent, handler: () => void) => {},\n    off: () => {},\n    emit: () => {},\n  };\n\n  const beforePopState = (\n    cb: (state: {\n      url: string;\n      as: string;\n      options: TransitionOptions;\n    }) => boolean\n  ) => {};\n  return {\n    push,\n    route,\n    isLocaleDomain: true,\n    pathname: \"\",\n    query: {},\n    asPath: \"\",\n    isFallback: false,\n    basePath: \"\",\n    locale: \"\",\n    locales: [\"\"],\n    defaultLocale: \"\",\n    isReady: true,\n    isPreview: false,\n    replace,\n    reload,\n    back,\n    prefetch,\n    beforePopState,\n    events,\n  };\n}"
  },
  "getRealValue": {
    "name": "getRealValue",
    "slug": "TsFunction",
    "id": "mtzplwhzgdwlzfygbfttuhxa",
    "description": "",
    "operationName": "react-with-native-select",
    "rawText": " <T extends unknown>({\n  value,\n  selectFirstOption,\n  options,\n  title,\n}: {\n  title: string;\n  options: Item<T>[];\n  value?: Item<T> | null;\n  selectFirstOption?: boolean;\n}): Item<T> => {\n  const result = value\n    ? value\n    : selectFirstOption\n    ? options[0]\n    : { label: title, value: \"\", data: undefined };\n\n  return result;\n}"
  },
  "useSelectMultiple": {
    "name": "useSelectMultiple",
    "slug": "TsFunction",
    "id": "tmovnnzmibasedomoyuzoxxm",
    "description": "Create a value selector in a single line of code, including its state!",
    "operationName": "react-with-native-select",
    "rawText": " <T extends unknown>(\n  items?: Item<T | null>[],\n  initialValue?: Item<T | null>[],\n  /**\n   * Optionally you can do other things with the value as well, like setting it to a global store\n   */\n  withValue?: (value: Item<T | null>[]) => void,\n  config?: Omit<SelectMultipleInputProps<T>, \"onChange\" | \"value\" | \"options\">\n): [\n  Component: () => JSX.Element,\n  value: Item<T | null>[],\n  setValue: (value: Item<T | null>[]) => void\n] => {\n  const realItems = items || [];\n  const [value, setValue] = useState<Item<T | null>[]>(initialValue || []);\n\n  const realOnChange = (v: Item<T | null>[]) => {\n    setValue(v);\n\n    if (v) {\n      withValue?.(v);\n    }\n  };\n\n  const Component = () => (\n    <SelectMultipleInput\n      {...config}\n      onChange={realOnChange}\n      value={value}\n      options={realItems}\n    />\n  );\n  return [Component, value, realOnChange];\n}"
  },
  "useSelect": {
    "name": "useSelect",
    "slug": "TsFunction",
    "id": "nbytnjpcdxfnrzhnwmqtczqw",
    "description": "Create a value selector in a single line of code, including its state!\n\n# **Usage**\n\n```ts\nconst [SelectView, view, setView] = useSelect(views);\n```",
    "operationName": "react-with-native-select",
    "rawText": " <T extends unknown>(\n  items?: Item<T>[],\n  initialValue?: Item<T>,\n  /**\n   * Optionally you can do other things with the value as well, like setting it to a global store\n   */\n  withValue?: (value: Item<T> | undefined) => void\n): [\n  Component: () => JSX.Element,\n  value: Item<T> | null,\n  setValue: (value: Item<T> | null) => void\n] => {\n  const realItems = items || [];\n  const [value, setValue] = useState<Item<T> | null>(initialValue || null);\n\n  const Component = () => (\n    <Select\n      className=\"bg-transparent\"\n      title=\"Test\"\n      onChange={(v) => {\n        setValue(v);\n\n        if (v) {\n          withValue?.(v);\n        }\n      }}\n      value={value}\n      options={realItems}\n    />\n  );\n  return [Component, value, setValue];\n}"
  },
  "contextKey": {
    "name": "contextKey",
    "slug": "TsFunction",
    "id": "ijffnppjhygcmzwwdzrhnnra",
    "description": "",
    "operationName": "react-with-native-store",
    "rawText": " (key: string) => `${key}Context`"
  },
  "contexts": {
    "name": "contexts",
    "slug": "TsVariable",
    "id": "ggolmgoawgvivstagpebmhzy",
    "description": "",
    "operationName": "react-with-native-store"
  },
  "createStoreProvider": {
    "name": "createStoreProvider",
    "slug": "TsFunction",
    "id": "jbbhekehpcngmomfpfemfcpw",
    "description": "Function to create the StoreProvider\n\nNB: this function uses a local variable on the main scope of javascript in order to create the Context components dynamically. Beware!",
    "operationName": "react-with-native-store",
    "rawText": " <TStore extends object>(\n  config: StoreConfig<TStore>\n) => {\n  if (config.debug) {\n    debug = config.debug;\n  }\n  if (debug) {\n    console.log(\"Create StoreProvider\");\n  }\n\n  const keys = Object.keys(config.initialValues) as Keys<TStore>[];\n\n  const newContext = keys.reduce((acc, key) => {\n    const Context = React.createContext(null);\n    return {\n      ...acc,\n      [contextKey(key)]: Context,\n    };\n  }, {});\n\n  contexts = { ...contexts, ...newContext };\n\n  // console.log({ keys, contexts });\n\n  const MainProvider = ({ children }: { children: any }) =>\n    keys.reduce((acc, key) => {\n      const context = contexts[contextKey(key)];\n\n      // console.log({ context });\n      return (\n        <StoreContextProvider\n          config={config}\n          storeKey={key}\n          DynamicContext={context}\n        >\n          {acc}\n        </StoreContextProvider>\n      );\n    }, children);\n\n  return ({ children }: { children: any }) => {\n    return <MainProvider>{children}</MainProvider>;\n  };\n}"
  },
  "createStore": {
    "name": "createStore",
    "slug": "TsFunction",
    "id": "daczukouqhhwturtiuoqugpm",
    "description": "One function is all you need to make a new store!\n\nExample:\n\n\n```ts\n\nimport { createStore } from \"react-with-native-store\";\nimport { TypeA, TypeB } from \"your-types\";\n\nexport const writerInitialValues: {\nitemA: TypeA;\nitemB: TypeB;\n} = {\nitemA: \"\",\nitemB: {},\n};\nexport const { useStore, StoreProvider } = createStore(writerInitialValues);\n\n\n```\n\nSimple as pie 🍰",
    "operationName": "react-with-native-store",
    "rawText": " <K extends object>(initialValues: K) => ({\n  StoreProvider: createStoreProvider({ initialValues }),\n  useStore: createUseStore(initialValues),\n})"
  },
  "createUseStore": {
    "name": "createUseStore",
    "slug": "TsFunction",
    "id": "jiwcwzubrxstgtfslaihebml",
    "description": "Function to create a hook for accessing the store",
    "operationName": "react-with-native-store",
    "rawText": " <TStore extends object>(\n  initialValues: TStore\n) => {\n  if (debug) {\n    console.log(\"Create useStore\");\n  }\n  const useStore = <K extends Keys<TStore>>(key: K) => {\n    if (!Object.keys(initialValues).includes(key)) {\n      throw new Error(`Using undefined key in useStore: ${key}`);\n    }\n    const context = getContext(key);\n    if (!context) {\n      throw new Error(\n        `Failed loading the context with key: ${key}. Did you wrap your component/app with a StoreProvider?`\n      );\n    }\n    const useStoreHook = React.useContext<UseStoreType<TStore>>(context);\n\n    const useStoreHookType = typeof useStoreHook;\n\n    if (useStoreHookType !== \"function\") {\n      console.error(\n        `useStoreHookType for ${key} is ${useStoreHookType}... wtf?`\n      );\n    }\n\n    return useStoreHook?.(key);\n  };\n  return useStore;\n}"
  },
  "debug": {
    "name": "debug",
    "slug": "TsVariable",
    "id": "dmmgnbudktwsgnidetwtbeaf",
    "description": "",
    "operationName": "react-with-native-store"
  },
  "getContext": {
    "name": "getContext",
    "slug": "TsFunction",
    "id": "xcjjiljwvxpjlqtoctvtmija",
    "description": "Gets the current word you are typing from a text and the cursor position.\n\nTakes into account multiple word separators: tabs, newlines, and spaces.",
    "operationName": "writer-input",
    "rawText": " (editorDetails: {\n  text: string;\n  positionIndex: number;\n}): TextEditingContext => {\n  const { positionIndex, text } = editorDetails;\n  const wordSeparators = [\" \", \"\\n\", \"\\t\"];\n\n  // NB: find the first separator after the word that we are typing at the position of the cursor.\n  const firstIndexWithSeparatorAfterPosition = Math.min(\n    ...wordSeparators.map((separator) => {\n      const separatorAfterPositionIndex = text.indexOf(\n        separator,\n        positionIndex\n      );\n      if (separatorAfterPositionIndex === -1) return Infinity;\n      return separatorAfterPositionIndex;\n    })\n  );\n\n  const endOfWordIndex =\n    firstIndexWithSeparatorAfterPosition === Infinity\n      ? text.length\n      : firstIndexWithSeparatorAfterPosition;\n\n  const lastIndexWithSeparatorBeforePosition = Math.max(\n    ...wordSeparators.map((separator) => {\n      const spaceBeforePositionIndex =\n        text.slice(0, positionIndex).lastIndexOf(separator) + 1;\n\n      return spaceBeforePositionIndex;\n    })\n  );\n\n  const beginningOfWordIndex =\n    lastIndexWithSeparatorBeforePosition === -1\n      ? 0\n      : lastIndexWithSeparatorBeforePosition;\n\n  const wordAtPosition = text.slice(beginningOfWordIndex, endOfWordIndex);\n\n  /*\n    console.log({\n      beginningOfWordIndex,\n      endOfWordIndex,\n      wordAtPosition,\n    });\n    */\n\n  return {\n    wordAtPosition,\n    positionIndex,\n  };\n}"
  },
  "getItemSync": {
    "name": "getItemSync",
    "slug": "TsFunction",
    "id": "uiuyhcihlfvthexoeombdhsx",
    "description": "ONLY web",
    "operationName": "react-with-native-store",
    "rawText": " (key: string) => {\n  if (typeof window === \"undefined\") {\n    return undefined;\n  }\n  const item = localStorage.getItem(key);\n  return item ? JSON.parse(item) : undefined;\n}"
  },
  "getItem": {
    "name": "getItem",
    "slug": "TsFunction",
    "id": "crpmofgrzqmpesxmwgreamcv",
    "description": "If you don't have access to the `useStore` hook, maybe because you're doing something outside of react... you can directly use the storage with javascript using this function",
    "operationName": "react-with-native-store",
    "rawText": " async (key: string) => {\n  if (typeof window === \"undefined\") {\n    return undefined;\n  }\n  const item = localStorage.getItem(key);\n  return item ? JSON.parse(item) : undefined;\n}"
  },
  "getKey": {
    "name": "getKey",
    "slug": "TsFunction",
    "id": "yzqzqaiixescwodlfgfrabwq",
    "description": "",
    "operationName": "react-with-native-store",
    "rawText": " (key: string, baseKey?: string) =>\n  baseKey ? `${baseKey}.${key}` : key"
  },
  "setItem": {
    "name": "setItem",
    "slug": "TsFunction",
    "id": "gdhefunrqpjuxsbtvrbmmlrt",
    "description": "If you don't have access to the `useStore` hook, maybe because you're doing something outside of react... you can directly use the storage with javascript using this function\n\nBEWARE! Updating this won't update your react components!",
    "operationName": "react-with-native-store",
    "rawText": " async (key: string, value: any) => {\n  if (typeof window === \"undefined\") {\n    return;\n  }\n  localStorage.setItem(key, JSON.stringify(value));\n}"
  },
  "StoreContextProvider": {
    "name": "StoreContextProvider",
    "slug": "TsFunction",
    "id": "gnuadzvsukjamitvthaztpnl",
    "description": "",
    "operationName": "react-with-native-store",
    "rawText": " <TStore extends object, K extends Keys<TStore>>({\n  DynamicContext,\n  children,\n  config,\n  storeKey,\n}: {\n  DynamicContext: React.Context<any>;\n  children: any;\n  config: StoreConfig<TStore>;\n  storeKey: K;\n}) => {\n  const [hydrated, setHydrated] = useState(false);\n  const [store, setStore] = useState<TStore[K]>(\n    config?.initialValues[storeKey]\n  ); //null or some object or string or whatever\n  const baseKey = config?.baseKey;\n\n  // On mount, get the current value from storage\n  useEffect(() => {\n    const fullKey = getKey(storeKey, baseKey);\n    getItem(fullKey).then((value) => {\n      if (debug) {\n        console.log(`Hydrated store for ${fullKey}:`, value);\n      }\n      setStore(value);\n      setHydrated(true);\n    });\n  }, []);\n\n  const initialValues = config?.initialValues;\n\n  const useStoreHook: UseStoreType<TStore> = <K2 extends Keys<TStore>>(\n    key: K2\n  ) => {\n    const fullKey = getKey(key, baseKey);\n\n    const defaultValue = initialValues[key];\n    // @ts-ignore\n    const value: TStore[K2] =\n      store !== undefined\n        ? store\n        : defaultValue !== undefined\n        ? defaultValue\n        : null;\n\n    const dispatch: (value: TStore[K2]) => Promise<void> = async (value) => {\n      //should do a deep equal here, and only set the store and item if the value actually has changed\n      //@ts-ignore\n      setStore(value);\n      await setItem(fullKey, value);\n    };\n\n    return [value, dispatch, { hydrated }];\n  };\n\n  return (\n    <DynamicContext.Provider value={useStoreHook}>\n      {children}\n    </DynamicContext.Provider>\n  );\n}"
  },
  "getColumns": {
    "name": "getColumns",
    "slug": "TsFunction",
    "id": "deffbbrfqfhaxflmddznamvf",
    "description": "gets all columns you can present based on a modelname, the interfaces of that model, and the data",
    "operationName": "react-with-native-table",
    "rawText": " (\n  modelName: string,\n  interfaces: TsInterface[] | undefined,\n  data: any[]\n): ColumnType<any>[] => {\n  /**\n   * needed in case something goes wrong with the index\n   */\n  const getDumbColumns = (): ColumnType<any>[] => {\n    return data[0] && typeof data[0] === \"object\"\n      ? Object.keys(data[0])\n          .map((objectParameterKey) => {\n            const value = data[0][objectParameterKey];\n            if (\n              ![\"string\", \"boolean\", \"number\", \"null\"].includes(typeof value)\n            ) {\n              return null;\n            }\n            return {\n              name: humanCase(objectParameterKey),\n              objectParameterKey,\n              presentationType: \"text\" as \"text\",\n            };\n          })\n          .filter(notEmpty)\n      : [];\n  };\n  if (!interfaces) return getDumbColumns();\n\n  const properties = interfaces.find((x) => x.name === modelName)?.type\n    .typeDefinition?.properties;\n\n  if (!properties) return getDumbColumns();\n\n  const columns: ColumnType<any>[] = Object.keys(properties)\n    .map((objectParameterKey) => {\n      const maybeProperty = properties[objectParameterKey];\n      const property =\n        typeof maybeProperty !== \"boolean\" ? maybeProperty : undefined;\n\n      if (!property) return;\n\n      if (\n        makeArray(property.type).find((x) => [\"object\", \"array\"].includes(x))\n      ) {\n        // there are arrays or objects among the type of this property\n        return;\n      }\n\n      const column: ColumnType<any> = {\n        name: humanCase(objectParameterKey),\n        objectParameterKey,\n        presentationType: \"text\",\n      };\n\n      return column;\n    })\n    .filter(notEmpty);\n  return columns;\n}"
  },
  "renderColumn": {
    "name": "renderColumn",
    "slug": "TsFunction",
    "id": "paiobvklkkwhoyrwqpdtekju",
    "description": "",
    "operationName": "react-with-native-table",
    "rawText": " <TModel extends { [key: string]: any }>(\n  column: ColumnType<TModel>,\n  row: TModel,\n  index: number\n) => {\n  if (column.presentationType === \"text\") {\n    const rawValue = row[column.objectParameterKey];\n\n    const value: string =\n      rawValue === undefined ? \"\" : rawValue === \"\" ? \"''\" : String(rawValue);\n    /**\n     * This is a text item that presents just one string\n     */\n    return <td className={tdClassName}>{value}</td>;\n  } else if (column.presentationType === \"backendAsset\") {\n    const backendAssets = row[column.objectParameterKey]\n      ? (makeArray(row[column.objectParameterKey]) as BackendAsset[])\n      : undefined;\n\n    return (\n      <td className={tdClassName}>\n        {backendAssets\n          ? backendAssets.map((backendAsset) => {\n              return (\n                <ModelItemAssetView\n                  item={row as unknown as AugmentedAnyModelType}\n                  backendAsset={backendAsset}\n                />\n              );\n            })\n          : null}\n      </td>\n    );\n  } else if (column.presentationType === \"referenceSingle\") {\n    // Any parameter with pattern xxxSlug or xxxId should link to that instance in the referred model (link to `db?model={model}#{id}`)\n    const referenceId: string | undefined = row[column.objectParameterKey];\n\n    const referenceParameterInfo = getReferenceParameterInfo(\n      column.objectParameterKey\n    );\n\n    return (\n      <td className={tdClassName}>\n        <a\n          href={`/${referenceParameterInfo.interfaceName}?${referenceParameterInfo.keyInModel}=${referenceId}`}\n        >\n          {referenceId}\n        </a>\n      </td>\n    );\n  } else if (column.presentationType === \"referenceMultiple\") {\n    // Any parameter with pattern xxxSlugs or xxxIds should link to those instance in the referred model (link to `db?model={model}&xxx={id}`) for every instance\n    // NB: it can also be a string in case markdown storage format is used, if there is just one...\n    const referenceIds: undefined | string[] | string =\n      row[column.objectParameterKey];\n    const referenceIdsArray = referenceIds\n      ? makeArray(referenceIds)\n      : undefined;\n\n    const referenceParameterInfo = getReferenceParameterInfo(\n      column.objectParameterKey\n    );\n\n    return (\n      <td className={tdClassName}>\n        {referenceIdsArray?.map((referenceId) => {\n          return (\n            <a\n              href={`/${referenceParameterInfo.interfaceName}?${referenceParameterInfo.keyInModel}=${referenceId}`}\n            >\n              {referenceId}\n            </a>\n          );\n        })}\n      </td>\n    );\n  } else {\n    return <td className={tdClassName}>Unknown Presentation Type</td>;\n  }\n}"
  },
  "Skeleton": {
    "name": "Skeleton",
    "slug": "TsFunction",
    "id": "ieyekqfbkzhgyosauwzlgiqy",
    "description": "",
    "operationName": "react-with-native-table",
    "rawText": " () => (\n  <td className={tdClassName}>\n    <div className=\"bg-gray-200 w-full p-2 animate-pulse rounded-lg h-5\" />\n  </td>\n)"
  },
  "TableHeadItem": {
    "name": "TableHeadItem",
    "slug": "TsFunction",
    "id": "jzjiliibmxnkksxpxkmxtgmb",
    "description": "",
    "operationName": "react-with-native-table",
    "rawText": " (column: ColumnType<any>) => (\n  <th\n    scope=\"col\"\n    className=\"whitespace-nowrap py-3.5 pl-4 pr-3 text-left text-sm font-semibold text-gray-900 dark:text-gray-100 sm:pl-6 md:pl-0\"\n  >\n    <Div>{column.name}</Div>\n  </th>\n)"
  },
  "TableRow": {
    "name": "TableRow",
    "slug": "TsFunction",
    "id": "gawmnloqvzmuibpsclpittux",
    "description": "",
    "operationName": "react-with-native-table",
    "rawText": " <T extends { [key: string]: any } = any>({\n  row,\n  columns,\n  renderExtraColumns,\n  extraColumnsAtStart,\n  shouldHighlight,\n}: RowType<T>) => {\n  /**\n   * Check which presentation type is set for this column and return this component\n   */\n  return (\n    <tr className={shouldHighlight ? \"bg-blue-300\" : undefined}>\n      {extraColumnsAtStart && (\n        <td className={tdClassName}>{renderExtraColumns?.(row)}</td>\n      )}\n      {columns.map((column, index) => {\n        if (!row) {\n          return <Skeleton />;\n        }\n\n        // we can optionally have a custom presentation for any column\n        if (column.customPresentation) {\n          return column.customPresentation(row);\n        }\n\n        return renderColumn(column, row, index);\n      })}\n\n      {!extraColumnsAtStart && (\n        <td className={tdClassName}>{renderExtraColumns?.(row)}</td>\n      )}\n    </tr>\n  );\n}"
  },
  "Table": {
    "name": "Table",
    "slug": "TsFunction",
    "id": "laomnufgkywtvjxwytakoxjq",
    "description": "",
    "operationName": "react-with-native-table",
    "rawText": " <TModel extends { [key: string]: any }>({\n  data,\n  columns,\n  renderExtraColumns,\n  extraColumnsAtStart,\n  onEndReached,\n  shouldHighlightItem,\n}: TableType<TModel>) => {\n  const endOfTableDiv = useRef<HTMLDivElement>(null);\n  const isEndReached = useIsInViewport(endOfTableDiv);\n  useEffect(() => {\n    // console.log(\"END REACHED\");\n    onEndReached?.();\n  }, [isEndReached]);\n  return (\n    <Div className=\"px-4 sm:px-6 lg:px-8\">\n      <Div className=\"mt-8 flex flex-col\">\n        <Div className=\"-my-2 -mx-4 overflow-x-auto sm:-mx-6 lg:-mx-8\">\n          <Div className=\"inline-block min-w-full py-2 align-middle md:px-6 lg:px-8\">\n            <table className=\"min-w-full divide-y divide-gray-300\">\n              <thead>\n                <tr>\n                  {extraColumnsAtStart ? (\n                    <TableHeadItem name=\"\" objectParameterKey={\"\"} />\n                  ) : null}\n                  {columns.map((column, index) => (\n                    // NB: here we are destructuring column to provide all the props to a component\n                    <TableHeadItem {...column} />\n                  ))}\n                  {renderExtraColumns && !extraColumnsAtStart ? (\n                    <TableHeadItem objectParameterKey={\"\"} name=\"\" />\n                  ) : null}\n                </tr>\n              </thead>\n              <tbody className=\"divide-y divide-gray-200\">\n                {data\n                  ? // If data is undefined, we have to render the skelletonview\n                    data.map((item, index) => {\n                      const shouldHighlight = shouldHighlightItem?.(item);\n                      return (\n                        <TableRow\n                          shouldHighlight={shouldHighlight}\n                          key={`row${index}`}\n                          row={item}\n                          columns={columns}\n                          renderExtraColumns={renderExtraColumns}\n                          extraColumnsAtStart={extraColumnsAtStart}\n                        />\n                      );\n                    })\n                  : // Without data we are assuming it's still loading and show 10 skelletons, which are simply TableRow's without any data\n                    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map((_, index) => (\n                      <TableRow\n                        key={`skeleton${index}`}\n                        row={undefined}\n                        columns={columns}\n                      />\n                    ))}\n              </tbody>\n            </table>\n            <div ref={endOfTableDiv}>&nbsp;</div>\n          </Div>\n        </Div>\n      </Div>\n    </Div>\n  );\n}"
  },
  "tdClassName": {
    "name": "tdClassName",
    "slug": "TsVariable",
    "id": "knewalmmrmfnicrohxwszygg",
    "description": "",
    "operationName": "react-with-native-table"
  },
  "bareInputClass": {
    "name": "bareInputClass",
    "slug": "TsVariable",
    "id": "cyflkpaeosydkreyprdmblqf",
    "description": "",
    "operationName": "react-with-native-ui"
  },
  "inputClass": {
    "name": "inputClass",
    "slug": "TsVariable",
    "id": "ycljmmnauwwluiugeigzucpk",
    "description": "",
    "operationName": "react-with-native-ui"
  },
  "UI": {
    "name": "UI",
    "slug": "TsVariable",
    "id": "isulhxodlkhqpybatvcfqayu",
    "description": "",
    "operationName": "react-with-native-ui"
  },
  "readCsvFileSync": {
    "name": "readCsvFileSync",
    "slug": "TsFunction",
    "id": "iorszsigsxsxsvtfboymfhrl",
    "description": "Reads and parses CSV file\n\nspecify a generic of what type of item the file contains an array of",
    "operationName": "read-csv-file",
    "rawText": " <T extends CsvItemType>(\n  filePath: Path\n): T[] | null => {\n  // TODO: is this needed?\n  if (!fs.existsSync(filePath)) return null;\n\n  const readable = canReadSync(filePath);\n  if (!readable) return null;\n  const fileBuffer = fs.readFileSync(filePath);\n  if (!fileBuffer) return null;\n\n  const parsed = parse(fileBuffer, { columns: true }) as T[];\n\n  // const parsed = tryParseCsv<T>(fileString);\n  return parsed;\n}"
  },
  "readCsvFile": {
    "name": "readCsvFile",
    "slug": "TsFunction",
    "id": "zaqgqpfotfbcznyhlwdrpqer",
    "description": "Reads and parses CSV file\n\nspecify a generic of what type of item the file contains an array of",
    "operationName": "read-csv-file",
    "rawText": " async <T extends CsvItemType>(\n  filePath: Path | undefined\n): Promise<T[] | null> => {\n  if (!filePath) return null;\n  // TODO: is this needed?\n  if (!fs.existsSync(filePath)) return null;\n\n  const readable = await canRead(filePath);\n  if (!readable) return null;\n\n  const fileBuffer = await fs.readFile(filePath);\n  const parsed = parse(fileBuffer, { columns: true }) as T[];\n\n  return parsed;\n}"
  },
  "readJsonFileSync": {
    "name": "readJsonFileSync",
    "slug": "TsFunction",
    "id": "ogiugvbvhbnpvhxfdhwhtwlx",
    "description": "Reads and parses JSON file\n\nmake sure to specify what type the file contains as a generic!",
    "operationName": "read-json-file",
    "rawText": " <T>(filePath: Path): T | null => {\n  // TODO: is this needed?\n  if (!fs.existsSync(filePath)) return null;\n\n  const readable = canReadSync(filePath);\n  if (!readable) return null;\n  const fileString = fs.readFileSync(filePath, \"utf8\");\n  if (!fileString) return null;\n  const parsed = tryParseJson<T>(fileString);\n  return parsed;\n}"
  },
  "readJsonFile": {
    "name": "readJsonFile",
    "slug": "TsFunction",
    "id": "ehewhzlolakbktuiqzmhoikq",
    "description": "Reads and parses JSON file\n\nmake sure to specify what type the file contains as a generic!",
    "operationName": "read-json-file",
    "rawText": " async <T>(\n  filePath: Path | undefined\n): Promise<T | null> => {\n  if (!filePath) return null;\n  // TODO: is this needed?\n  if (!fs.existsSync(filePath)) return null;\n\n  const readable = await canRead(filePath);\n  if (!readable) return null;\n  const fileString = await fs.readFile(filePath, \"utf8\");\n  if (!fileString) return null;\n  const parsed = tryParseJson<T>(fileString);\n  return parsed;\n}"
  },
  "readProjectRelativeJsonFile": {
    "name": "readProjectRelativeJsonFile",
    "slug": "TsFunction",
    "id": "asxzlkqfotdstxmvtuwwytka",
    "description": "",
    "operationName": "read-json-file",
    "rawText": " async <T>(\n  projectRelativePath: string\n): Promise<T | null> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return null;\n\n  const fullPath = path.join(projectRoot, projectRelativePath);\n\n  return readJsonFile<T>(fullPath);\n}"
  },
  "readKvmdFile": {
    "name": "readKvmdFile",
    "slug": "TsFunction",
    "id": "gunslrdkvbvtnfvotlcgdwsb",
    "description": "Reads and parses a markdown file",
    "operationName": "read-kvmd-file",
    "rawText": " async (\n  filePath: Path,\n  /**\n   * TODO: make this optional. if not provided, calculate it ourselves here.\n   */\n  dbFileLocation: DbFileLocation\n): Promise<KeyValueMarkdownParse | null> => {\n  // TODO: is this needed?\n  const pathParse = path.parse(filePath);\n  const isMarkdownFile = [\"md\", \"mdx\"].includes(pathParse.ext.slice(1));\n  if (!isMarkdownFile) return null;\n\n  if (!fs.existsSync(filePath)) return null;\n  const readable = await canRead(filePath);\n  if (!readable) return null;\n  const fileString = await fs.readFile(filePath, \"utf8\");\n  if (!fileString) return null;\n\n  const keyValueMarkdownParse = markdownStringToKvmdParse(\n    fileString,\n    dbFileLocation\n  );\n\n  // console.log({ keyValueMarkdownParse });\n  return keyValueMarkdownParse;\n}"
  },
  "readMarkdownFileToModel": {
    "name": "readMarkdownFileToModel",
    "slug": "TsFunction",
    "id": "glukxvkshncuzwafqeseuyhe",
    "description": "Reads a markdown absolute path to a `WebMarkdownFile` model\n\nAttaches default calls to action and header",
    "operationName": "read-markdown-file",
    "rawText": " async (\n  absoluteFilePath: string,\n  webOperationName: string,\n  /**\n   * Only the ones that are not from this domain without path (filter based on hostname/path)\n   */\n  markdownCallToActions: MarkdownCallToAction[]\n): Promise<null | WebMarkdownFile> => {\n  const filename = path.parse(absoluteFilePath).name;\n\n  const projectRoot = getProjectRoot(absoluteFilePath);\n\n  if (!projectRoot) {\n    console.log(\"Projectroot not found\");\n    return null;\n  }\n  const mdParse = await readMarkdownFile(absoluteFilePath);\n  if (!mdParse) {\n    console.log(\"mdParse not found\");\n    return null;\n  }\n\n  const projectRelativeWebOperationPath =\n    operations[webOperationName as keyof typeof operations];\n\n  if (!projectRelativeWebOperationPath) return null;\n\n  const absoluteHeadersFolderPath = path.join(\n    projectRoot,\n    projectRelativeWebOperationPath,\n    \"public/headers\"\n  );\n\n  const publicHeaderFilenames = fs.existsSync(absoluteHeadersFolderPath)\n    ? await fs.readdir(absoluteHeadersFolderPath, \"utf8\")\n    : [];\n\n  const parsedParameters = frontmatterToObject(\n    mdParse.parameters,\n    webMarkdownFileTsInterface.type.simplifiedSchema as SimplifiedSchema\n  ) as Partial<\n    ExtendedMarkdownProperties & WebMarkdownProperties & PostableProperties\n  >;\n\n  if (!parsedParameters.headerImage && publicHeaderFilenames.length) {\n    /**\n     *  Should be a number that depends on the absolute file path. Should be quite random because every charCode is a different number.\n     */\n    const uniqueDeterministicFilepathNumber = sum(\n      absoluteFilePath.split(\"\").map((letter) => letter.charCodeAt(0))\n    );\n    /**\n     * Makes the `uniqueDeterministicFilePathNumber into a number between 0 and length - 1,\n     */\n    const deterministicHeaderImageNumber =\n      uniqueDeterministicFilepathNumber % (publicHeaderFilenames.length - 1);\n\n    /**\n     * Gets the actual header filename\n     */\n    const deterministicHeaderImage =\n      publicHeaderFilenames[deterministicHeaderImageNumber];\n\n    /**\n     * Puts it as backendAsset\n     */\n    parsedParameters.headerImage = {\n      // NB: this ensures the URL isn't later altered to a backend-url (in dev mode)\n      absoluteUrl: `/headers/${deterministicHeaderImage}`,\n    };\n  }\n\n  if (!parsedParameters.markdownCallToActionSlugs) {\n    parsedParameters.markdownCallToActionSlugs = markdownCallToActions.map(\n      (x) => x.slug\n    );\n  }\n\n  // attach the actual call to actions\n\n  parsedParameters.markdownCallToActions =\n    parsedParameters.markdownCallToActionSlugs\n      ?.map((slug) => markdownCallToActions.find((x) => x.slug === slug))\n      .filter(notEmpty) || [];\n\n  parsedParameters.header_markdownCallToActions =\n    parsedParameters.header_markdownCallToActionSlugs\n      ?.map((slug) => markdownCallToActions.find((x) => x.slug === slug))\n      .filter(notEmpty) || [];\n\n  // NB: this markdown file is not always located in an operation. Yet we are trying to find it.\n  const operationBasePath = findOperationBasePath(absoluteFilePath);\n  const modelLocation: ModelLocation = {\n    operationName: operationBasePath ? getLastFolder(operationBasePath) : null,\n    projectRelativePath: makeRelative(absoluteFilePath, projectRoot),\n    operationRelativePath: operationBasePath\n      ? makeRelative(absoluteFilePath, operationBasePath)\n      : undefined,\n  };\n\n  const name = mdParse.fileName || \"untitled\";\n  const markdownFile: WebMarkdownFile = {\n    ...modelLocation,\n    ...parsedParameters,\n    markdown: mdParse.raw,\n    categoryStack: [],\n    ...parsedParameters,\n    id: name,\n    createdFirstAt: Date.now(),\n    deletedAt: 0,\n    createdAt: Date.now(),\n    language: parsedParameters.language || \"english\",\n    updatedAt: parsedParameters.updatedAt || Date.now(),\n    name,\n    slug: name,\n  };\n\n  return omitUndefinedValues(markdownFile);\n}"
  },
  "readMarkdownFile": {
    "name": "readMarkdownFile",
    "slug": "TsFunction",
    "id": "jjorwxyiekoackawhlmkyjcx",
    "description": "Reads and parses a markdown file",
    "operationName": "read-markdown-file",
    "rawText": " async (\n  filePath: Path\n): Promise<MarkdownParse | null> => {\n  // TODO: is this needed?\n  const pathParse = path.parse(filePath);\n  const isMarkdownFile = [\"md\", \"mdx\"].includes(pathParse.ext.slice(1));\n  if (!isMarkdownFile) return null;\n  if (!fs.existsSync(filePath)) return null;\n  const readable = await canRead(filePath);\n  if (!readable) return null;\n  const fileString = await fs.readFile(filePath, \"utf8\");\n  if (!fileString) return null;\n\n  const fileName = path.parse(filePath).name;\n\n  const markdownParse = mdToJsonParse(fileString, fileName);\n  return markdownParse;\n}"
  },
  "getFolderTypescriptIndex": {
    "name": "getFolderTypescriptIndex",
    "slug": "TsFunction",
    "id": "rixiypukspdguliccankaxei",
    "description": "get a Typescript index for all that is found in a folder",
    "operationName": "read-typescript-file",
    "rawText": " async ({\n  basePath,\n  filter,\n  sort,\n  type,\n  filePath,\n}: {\n  /**\n   * if given, basePath is ignored\n   *\n   */\n  filePath?: string | string[];\n  /**\n   * is ignored if filePath is provided\n   *\n   * if this path is a single path anywhere in an operaiton, it will only take that operation\n   *\n   * otherwise, it will find all operation folders in that path\n   */\n  basePath?: string | string[];\n\n  /**\n   * if specified, only returns one specific type\n   *\n   * returns all types by default\n   */\n  type?: keyof IndexModels | null;\n\n  filter?: IndexFilter;\n\n  /**\n   * TODO: make functions be sortable:\n   * - alphabetic\n   * - input type\n   * - output type\n   * - usage amount\n   */\n  sort?: string;\n}): Promise<TypescriptIndex | null> => {\n  const operationBasePath =\n    basePath && !Array.isArray(basePath)\n      ? findOperationBasePath(basePath)\n      : undefined;\n\n  // console.log(\"MMMM\", { basePath, operationBasePath });\n\n  const groupedFiles: GroupedFiles = operationBasePath\n    ? { [operationBasePath]: [] }\n    : filePath && filePath.length > 0\n    ? makeArray(filePath).reduce((groups, filePath) => {\n        const operationBasePath = findOperationBasePath(filePath);\n        if (operationBasePath) {\n          groups[operationBasePath] = groups[operationBasePath]\n            ? groups[operationBasePath].concat(filePath)\n            : [filePath];\n        }\n        return groups;\n      }, {} as GroupedFiles)\n    : (await exploreOperationFolders({ basePath })).reduce(\n        (groups, operationBasePath) => {\n          groups[operationBasePath] = [];\n          return groups;\n        },\n        {} as GroupedFiles\n      );\n\n  const typescriptIndexes = await Promise.all(\n    Object.keys(groupedFiles).map(async (operationBasePath) => {\n      const files = groupedFiles[operationBasePath];\n\n      const tsBuildErrors =\n        type === \"TsBuildError\" || !type\n          ? await getOperationIndexModel(\n              \"TsBuildError\",\n              operationBasePath,\n              files\n            )\n          : [];\n\n      const tsLintWarnings =\n        type === \"TsLintWarning\" || !type\n          ? await getOperationIndexModel(\n              \"TsLintWarning\",\n              operationBasePath,\n              files\n            )\n          : [];\n\n      const tsFunctions =\n        type === \"TsFunction\" || !type\n          ? await getOperationIndexModel(\"TsFunction\", operationBasePath, files)\n          : [];\n\n      const extendedTsFuntions = await Promise.all(\n        tsFunctions.map(async (tsFunction) => ({\n          ...tsFunction,\n          dependantFiles: tsFunction.operationName\n            ? await findDependants({\n                operationName: tsFunction.operationName,\n                importName: tsFunction.name,\n              })\n            : [],\n        }))\n      );\n\n      const tsVariables =\n        type === \"TsVariable\" || !type\n          ? await getOperationIndexModel(\"TsVariable\", operationBasePath, files)\n          : [];\n\n      const tsInterfaces =\n        type === \"TsInterface\" || !type\n          ? await getOperationIndexModel(\n              \"TsInterface\",\n              operationBasePath,\n              files\n            )\n          : [];\n\n      const tsComments =\n        type === \"TsComment\" || !type\n          ? await getOperationIndexModel(\"TsComment\", operationBasePath, files)\n          : [];\n\n      const tsImports =\n        type === \"TsImport\" || !type\n          ? await getOperationIndexModel(\"TsImport\", operationBasePath, files)\n          : [];\n\n      const tsExports =\n        type === \"TsExport\" || !type\n          ? await getOperationIndexModel(\"TsExport\", operationBasePath, files)\n          : [];\n\n      const filteredInterfaces = tsInterfaces.filter((x) =>\n        filter?.interfaceIsDbModel ? x.isDbModel : true\n      );\n\n      const typescriptIndex: TypescriptIndex = {\n        tsBuildErrors,\n        tsLintWarnings,\n        tsFunctions: extendedTsFuntions,\n        tsVariables,\n        tsInterfaces: filteredInterfaces,\n        tsComments: tsComments.filter((comment) =>\n          filter?.hasCommentTypes\n            ? comment.types.find((type) =>\n                filter.hasCommentTypes!.includes(type)\n              )\n            : true\n        ),\n        tsImports,\n        tsExports,\n      };\n\n      return typescriptIndex;\n    })\n  );\n\n  const mergedTypescriptIndex = typescriptIndexes.reduce((merged, current) => {\n    if (merged) {\n      const indexModels = Object.keys(merged) as (keyof TypescriptIndex)[];\n\n      const together = mergeObjectsArray(\n        indexModels.map((indexModelName) => {\n          const filterOnName =\n            indexModelName === \"tsComments\" ? () => true : uniqueNames;\n\n          return {\n            [indexModelName]: [\n              ...merged[indexModelName],\n              ...current[indexModelName],\n            ].filter(filterOnName),\n          };\n        })\n      ) as TypescriptIndex;\n\n      return together;\n    }\n\n    return current;\n  }, null as TypescriptIndex | null);\n\n  return mergedTypescriptIndex;\n}"
  },
  "getOperationIndexModel": {
    "name": "getOperationIndexModel",
    "slug": "TsFunction",
    "id": "bslvdmhoimbrkoocowmmrjqu",
    "description": "",
    "operationName": "read-typescript-file",
    "rawText": " async <T extends keyof IndexModels>(\n  indexModelName: T,\n  operationBasePath: string,\n  /**\n   * if provided, db result will be filtered to specific filepaths\n   */\n  filePaths: string[]\n): Promise<IndexModels[T][]> => {\n  const projectRoot = getProjectRoot(filePaths[0]);\n  if (!projectRoot) return [];\n  const relativeFilePaths = filePaths.map((f) =>\n    f.substring(projectRoot.length)\n  );\n  const result = await db\n    // TODO: make it more efficient by just finding the correct JSON files instead of all files in the operation.\n    .get(indexModelName, { operationName: getLastFolder(operationBasePath) });\n\n  const filterOnName =\n    indexModelName === \"TsComment\" ? () => true : uniqueNames;\n\n  const filtered = result\n    .filter(\n      (x) =>\n        x.projectRelativePath &&\n        (relativeFilePaths.length === 0 ||\n          relativeFilePaths.includes(x.projectRelativePath))\n    )\n    .filter(filterOnName);\n\n  return filtered;\n}"
  },
  "readTypescriptFile": {
    "name": "readTypescriptFile",
    "slug": "TsFunction",
    "id": "fezxpsamgyeeaemowlcudcdx",
    "description": "Reads and parses a markdown file",
    "operationName": "read-typescript-file",
    "rawText": " async (\n  filePath: Path\n): Promise<TypescriptIndex | null> => {\n  const operationBasePath = findOperationBasePath(filePath);\n  if (!operationBasePath) return null;\n  const operationName = getLastFolder(operationBasePath);\n\n  const operationRelativeTypescriptFilePath = getOperationRelativePath(\n    filePath,\n    operationBasePath\n  );\n\n  const getFileIndexes = <T extends keyof IndexModels>(\n    indexModelName: T\n  ): Promise<IndexModels[T][]> => {\n    const result = db\n      // TODO: make it more efficient by just finding the correct JSON files instead of all files in the operation.\n      .get(indexModelName, { operationName })\n      .then((result) =>\n        result.filter((x) => {\n          return (\n            x.operationRelativeTypescriptFilePath ===\n            operationRelativeTypescriptFilePath\n          );\n        })\n      );\n\n    return result;\n  };\n\n  // TODO: is this needed?\n  const pathParse = path.parse(filePath);\n  const isTypescriptFile = [\"ts\", \"tsx\"].includes(pathParse.ext.slice(1));\n  if (!isTypescriptFile) return null;\n  if (!fs.existsSync(filePath)) return null;\n\n  const typescriptIndex: TypescriptIndex = {\n    tsBuildErrors: await getFileIndexes(\"TsBuildError\"),\n    tsLintWarnings: await getFileIndexes(\"TsLintWarning\"),\n    tsFunctions: await getFileIndexes(\"TsFunction\"),\n    tsVariables: await getFileIndexes(\"TsVariable\"),\n    tsInterfaces: await getFileIndexes(\"TsInterface\"),\n    tsComments: await getFileIndexes(\"TsComment\"),\n    tsImports: await getFileIndexes(\"TsImport\"),\n    tsExports: await getFileIndexes(\"TsExport\"),\n  };\n\n  return typescriptIndex;\n}"
  },
  "uniqueNames": {
    "name": "uniqueNames",
    "slug": "TsFunction",
    "id": "grpgfkzijklcwvmrwmmhqegw",
    "description": "",
    "operationName": "read-typescript-file",
    "rawText": " <T extends { name: string }>(\n  value: T,\n  index: number,\n  self: T[]\n) => {\n  return self.findIndex((v) => v.name === value.name) === index;\n}"
  },
  "AugmentedWordComponent": {
    "name": "AugmentedWordComponent",
    "slug": "TsFunction",
    "id": "qvpcizawlvlcxuucjnqdjxcf",
    "description": "",
    "operationName": "reader-ui",
    "rawText": " (props: {\n  augmentedWord: AugmentedWord;\n  augmentedWordObject: MappedObject<AugmentedWord>;\n}) => {\n  const { augmentedWord, augmentedWordObject } = props;\n\n  const projectRelativeBaseFolderPath = getFolderJs(\n    augmentedWord.projectRelativeMarkdownSourcePath\n  )!;\n\n  const projectRelativeMarkdownFilePath =\n    augmentedWord.projectRelativeMarkdownSourcePath;\n  return (\n    <Div className=\"border border-gray-500 rounded-md m-2 p-2\">\n      <P className=\"font-bold\">{augmentedWord.word}</P>\n      {augmentedWord.spoiler ? (\n        <P>\n          {renderMarkdownContent(augmentedWord.spoiler, {\n            isDev,\n            isStatic: false,\n            projectRelativeMarkdownFilePath,\n            projectRelativeBaseFolderPath,\n            augmentedWordObject,\n          })}\n        </P>\n      ) : null}\n    </Div>\n  );\n}"
  },
  "Dictionary": {
    "name": "Dictionary",
    "slug": "TsFunction",
    "id": "ggkwbrjdbnnegyludvfvcmhi",
    "description": "",
    "operationName": "reader-ui",
    "rawText": " (props: {\n  augmentedWordObject: MappedObject<AugmentedWord>;\n  word?: string;\n}) => {\n  const [_, setIsMobileMenuEnabled] = useStore(\"menu.isMobileMenuEnabled\");\n\n  const { augmentedWordObject, word } = props;\n\n  const augmentedWord = word ? augmentedWordObject[word] : undefined;\n\n  return (\n    <>\n      <Div className=\"lg:hidden\">\n        <Div className=\"flex flex-row justify-between px-4\">\n          <Div />\n          <ClickableIcon\n            emoji=\"⃛\"\n            onClick={() => {\n              setIsMobileMenuEnabled(true);\n            }}\n          />\n        </Div>\n      </Div>\n\n      <Div className=\"p-4\">\n        {augmentedWord ? (\n          <Div className=\"bg-blue-200 p-4 border border-blue-800 rounded-xl mb-20\">\n            <AugmentedWordComponent\n              augmentedWordObject={augmentedWordObject}\n              augmentedWord={augmentedWord}\n            />\n          </Div>\n        ) : null}\n\n        <P className=\"text-3xl\">Dictionary</P>\n        {Object.keys(augmentedWordObject).map((word, index) => {\n          const augmentedWord = augmentedWordObject[word];\n\n          if (!augmentedWord) return null;\n          return (\n            <AugmentedWordComponent\n              key={`aug${index}`}\n              augmentedWordObject={augmentedWordObject}\n              augmentedWord={augmentedWord}\n            />\n          );\n        })}\n      </Div>\n    </>\n  );\n}"
  },
  "DocsReaderLayout": {
    "name": "DocsReaderLayout",
    "slug": "TsFunction",
    "id": "dhngzdooziwvtdmsnjtataon",
    "description": "",
    "operationName": "reader-ui",
    "rawText": " (props: MarkdownReaderPageProps) => {\n  const router = useRouter();\n  const queryPath = getQueryPath(router.query);\n  const word: string | undefined = Array.isArray(router.query?.word)\n    ? router.query?.word?.[0]\n    : router.query.word;\n\n  return (\n    <Layout\n      publicBundleConfig={props.publicBundleConfig}\n      augmentedWordObject={props.content?.augmentedWordObject}\n      menu={props.menu}\n    >\n      {queryPath === \"dictionary\" && props.content?.augmentedWordObject ? (\n        <Dictionary\n          augmentedWordObject={props.content?.augmentedWordObject}\n          word={word}\n        />\n      ) : (\n        <ReaderPageContent {...props.content} />\n      )}\n    </Layout>\n  );\n}"
  },
  "ReaderPageContent": {
    "name": "ReaderPageContent",
    "slug": "TsFunction",
    "id": "lzwunyeigflyxfrudtohviuz",
    "description": "This is rendering a `WebMarkdownFile` and optionally navigation.",
    "operationName": "reader-ui",
    "rawText": " (props: ReaderPageContentProps) => {\n  const router = useRouter();\n  const queryPath = getQueryPath(router.query);\n  const [_, setIsMobileMenuEnabled] = useStore(\"menu.isMobileMenuEnabled\");\n\n  const {\n    augmentedWordObject,\n    children,\n    description,\n    markdownFile,\n    nextQueryPath,\n    previousQueryPath,\n    projectRelativeMarkdownPath,\n    title,\n  } = props;\n\n  const [view, setView] = useState(\"view\" as \"view\" | \"presentation\");\n\n  const renderBottomNavigation = () => {\n    return (\n      <Div className=\"flex flex-row w-full justify-between\">\n        {previousQueryPath ? (\n          <ALink href={`${previousQueryPath}`}>\n            <Div className=\"w-60 h-40 border-2 border-black rounded-3xl m-4 p-4 flex flex-col justify-center items-center\">\n              <P className=\"font-bold text-xl\">\n                {previousQueryPath.split(\"/\").pop()}\n              </P>\n              <P className=\"font-bold text-6xl\">⬅</P>\n            </Div>\n          </ALink>\n        ) : (\n          <Div />\n        )}\n\n        {nextQueryPath ? (\n          <ALink href={`${nextQueryPath}`}>\n            <Div className=\"w-60 h-40 border-2 border-black rounded-3xl m-4 p-4 flex flex-col justify-center items-center\">\n              <P className=\"font-bold text-xl\">\n                {nextQueryPath.split(\"/\").pop()}\n              </P>\n              <P className=\"font-bold text-6xl\">➡</P>\n            </Div>\n          </ALink>\n        ) : (\n          <Div />\n        )}\n      </Div>\n    );\n  };\n\n  const markdownParse: MarkdownParse | null = markdownFile?.markdown\n    ? mdToJsonParse(markdownFile?.markdown)\n    : null;\n\n  const renderMarkdownView = () => {\n    const projectRelativeMarkdownFilePath = projectRelativeMarkdownPath;\n    const projectRelativeBaseFolderPath = projectRelativeMarkdownPath\n      ? getFolderJs(projectRelativeMarkdownPath)\n      : undefined;\n\n    if (\n      !markdownParse ||\n      projectRelativeBaseFolderPath === undefined ||\n      projectRelativeMarkdownFilePath === undefined ||\n      projectRelativeMarkdownFilePath === null\n    ) {\n      return null;\n    }\n\n    const markdownParseRenderConfig = {\n      augmentedWordObject,\n      projectRelativeBaseFolderPath,\n      projectRelativeMarkdownFilePath,\n      isDev,\n      isStatic: true,\n    };\n\n    return (\n      <MarkdownView\n        markdownParse={markdownParse}\n        markdownParseRenderConfig={markdownParseRenderConfig}\n        view={view}\n      />\n    );\n  };\n\n  const renderPage = () => {\n    const hasNoMainTitle =\n      markdownParse?.content?.filter((x) => !!x.title && x.level === 1)\n        .length !== 1;\n\n    // console.log({ hasNoMainTitle, f: props.markdownFile?.name });\n\n    return (\n      <Div>\n        <Div className=\"flex flex-row justify-between\">\n          {queryPath.length > 1 ? (\n            <ClickableIcon\n              emoji=\"⬅\"\n              onClick={() => {\n                const parts = queryPath.split(\"/\");\n                parts.pop();\n                const oneFolderUp = parts.join(\"/\");\n                router.push(oneFolderUp.length === 0 ? \"/\" : oneFolderUp);\n              }}\n            />\n          ) : null}\n\n          <Div className=\"flex flex-row\">\n            <Div className=\"lg:hidden\">\n              <ClickableIcon\n                emoji=\"⃛\"\n                onClick={() => {\n                  setIsMobileMenuEnabled(true);\n                }}\n              />\n            </Div>\n            <ClickableIcon\n              emoji=\"👁\"\n              onClick={() => {\n                setView(view === \"presentation\" ? \"view\" : \"presentation\");\n              }}\n            />\n          </Div>\n        </Div>\n\n        {hasNoMainTitle && markdownFile?.name ? (\n          <P className=\"text-3xl\">{humanCase(markdownFile.name)}</P>\n        ) : null}\n\n        {renderMarkdownView()}\n\n        {previousQueryPath || nextQueryPath ? renderBottomNavigation() : null}\n      </Div>\n    );\n  };\n\n  const renderNav = () => {\n    return (\n      <Div>\n        <Div className=\"flex flex-row items-center\">\n          <ClickableIcon\n            emoji=\"⬅\"\n            onClick={() => {\n              const parts = queryPath.split(\"/\");\n              parts.pop();\n              const oneFolderUp = parts.join(\"/\");\n              router.push(oneFolderUp.length === 0 ? \"/\" : oneFolderUp);\n            }}\n          />\n          <P className=\"text-xl lg:text-4xl w-full\">&nbsp;&nbsp;{title}</P>\n\n          <Div className=\"lg:hidden\">\n            <ClickableIcon\n              emoji=\"⃛\"\n              onClick={() => {\n                setIsMobileMenuEnabled(true);\n              }}\n            />\n          </Div>\n        </Div>\n\n        {description && projectRelativeMarkdownPath ? (\n          <Div>\n            {renderMarkdownContent(description, {\n              projectRelativeMarkdownFilePath: projectRelativeMarkdownPath,\n              augmentedWordObject,\n              projectRelativeBaseFolderPath: getFolderJs(\n                projectRelativeMarkdownPath\n              )!,\n            })}\n          </Div>\n        ) : null}\n\n        <Div className=\"flex flex-row flex-wrap\">\n          {children?.map((child, index) => {\n            return (\n              <ALink\n                key={`child${child.projectRelativeMarkdownPath}-${index}`}\n                href={`${queryPath}/${child.folderName}`}\n              >\n                <Div className=\"w-60 border-2 border-black rounded-3xl m-4 p-4 flex flex-col justify-center items-center\">\n                  <P className=\"font-bold text-xl\">{child.title}</P>\n                  {child.firstParagraph && child.projectRelativeMarkdownPath ? (\n                    <Div>\n                      {renderMarkdownContent(child.firstParagraph, {\n                        projectRelativeBaseFolderPath: getFolderJs(\n                          child.projectRelativeMarkdownPath\n                        )!,\n                        projectRelativeMarkdownFilePath:\n                          child.projectRelativeMarkdownPath,\n                        augmentedWordObject,\n                      })}\n                    </Div>\n                  ) : null}\n                </Div>\n              </ALink>\n            );\n          })}\n        </Div>\n      </Div>\n    );\n  };\n\n  // console.log({ markdownFile });\n  return (\n    <Div>\n      {markdownFile?.headerImage ||\n      markdownFile?.headerTitle ||\n      markdownFile?.header_markdownCallToActionSlugs ? (\n        <ReaderPageHeader\n          markdownFile={markdownFile}\n          projectRelativeMarkdownPath={projectRelativeMarkdownPath}\n        />\n      ) : null}\n      <Div className=\"pb-4 px-4\">\n        {props.children ? renderNav() : renderPage()}\n      </Div>\n    </Div>\n  );\n}"
  },
  "ReaderPageHeader": {
    "name": "ReaderPageHeader",
    "slug": "TsFunction",
    "id": "ddetfthgwtbkduoatfgwkybo",
    "description": "",
    "operationName": "reader-ui",
    "rawText": " (props: {\n  markdownFile?: WebMarkdownFile | null;\n  projectRelativeMarkdownPath?: string | null;\n}) => {\n  const { markdownFile, projectRelativeMarkdownPath } = props;\n\n  if (!markdownFile) return null;\n\n  const { src } = destructureOptionalObject(\n    useAsset(markdownFile.headerImage, projectRelativeMarkdownPath, !isDev)\n  );\n\n  const backgroundImage = src ? `url(\"${src}\")` : undefined;\n\n  return (\n    <Div\n      style={{\n        backgroundImage,\n        backgroundRepeat: \"no-repeat\",\n        backgroundSize: \"cover\",\n        backgroundPosition: \"center 75%\",\n      }}\n      className={`w-full ${\n        markdownFile.headerBig ? \"h-screen\" : \"h-[350px]\"\n      } flex flex-col items-center justify-center`}\n    >\n      {markdownFile.headerTitle ? (\n        <P className=\"drop-shadow-lg decoration-8 font-bold text-white text-4xl\">\n          {markdownFile.headerTitle}\n        </P>\n      ) : null}\n      {markdownFile.headerSubTitle ? (\n        <P className=\"drop-shadow-lg text-white text-2xl\">\n          {markdownFile.headerSubTitle}\n        </P>\n      ) : null}\n\n      {markdownFile.header_markdownCallToActions?.map((cta) => {\n        const { title, description, ctaButtonText, hostname, path } = cta;\n        console.log({ cta, ctaButtonText, hostname });\n        return (\n          <ALink\n            href={path}\n            title={description}\n            className=\"bg-blue-500 rounded-full p-4 flex items-center justify-center\"\n          >\n            {title}\n          </ALink>\n        );\n      })}\n    </Div>\n  );\n}"
  },
  "clearTsDatabase": {
    "name": "clearTsDatabase",
    "slug": "TsFunction",
    "id": "setfesxlfpabanehzhicqcjg",
    "description": "Clears all typescript indexation models, and removes all indexation from the oprations\n\nTODO: test first, not sure about the Operation one",
    "operationName": "rebuild-operation",
    "rawText": " async (operationName: string | undefined) => {\n  const result = await Promise.all(\n    typescriptIndexModels.map((modelName) => {\n      return db.clear(modelName, { operationName });\n    })\n  );\n\n  await db.update(\n    \"Operation\",\n    () => true,\n    (old) =>\n      mergeNestedObject(old, {\n        operation: {\n          sizeIndexed: undefined,\n          buildResultIndexed: undefined,\n          classificationIndexed: undefined,\n          folderNameIndexed: undefined,\n          coreDependenciesIndexed: undefined,\n          hasGeneratedDependenciesIndexed: undefined,\n          operationDependenciesIndexed: undefined,\n          packageDependenciesIndexed: undefined,\n          relativeOperationLocationPathIndexed: undefined,\n        },\n      }),\n    { operationName }\n  );\n}"
  },
  "cwdProjectRoot": {
    "name": "cwdProjectRoot",
    "slug": "TsVariable",
    "id": "bvhxupiuhfovauhskzajoxpw",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "executeCommandQuietUnlessFail": {
    "name": "executeCommandQuietUnlessFail",
    "slug": "TsFunction",
    "id": "nqfefbnlwdkatvkifhtsqkgr",
    "description": "Executes a command without showing the result, unless the command fails, then it will log the output.,",
    "operationName": "rebuild-operation",
    "rawText": " (config: {\n  command: string;\n  cwd?: string;\n  /**\n   * if given, will show what is happening and a checkmark if it succeeds\n   */\n  description?: string;\n}): boolean => {\n  const { command, cwd, description } = config;\n  if (description) {\n    process.stdout.write(`${description} `);\n  }\n\n  try {\n    const result = execSync(command, {\n      cwd,\n      encoding: \"utf8\",\n      stdio: \"pipe\",\n    });\n\n    if (description) console.log(\"✅\");\n\n    return true;\n  } catch (e: any) {\n    if (description) console.log(\"❌\");\n    const error: {\n      status: number;\n      signal: any;\n      output: (string | null)[];\n      pid: number;\n      stdout: string;\n      stderr: string;\n    } = e;\n    console.log(`${command} went wrong:`, error?.stdout);\n\n    return false;\n  }\n}"
  },
  "exitIfProcessDependenciesChanged": {
    "name": "exitIfProcessDependenciesChanged",
    "slug": "TsFunction",
    "id": "cmjjcxuqctvrckqmkanwicjx",
    "description": "exits the process if our own dependencies change",
    "operationName": "rebuild-operation",
    "rawText": " async (\n  operationName: string,\n  manualProjectRoot?: string\n) => {\n  const imports = (\n    await Promise.all(\n      [\"watch-operations\", \"rebuild-operation\"].map(\n        async (operationName) =>\n          // @ts-ignore\n          db.get(\"TsImport\", { operationName, manualProjectRoot }) as Promise<\n            TsImport[]\n          >\n      )\n    )\n  )\n    .flat()\n    .map((i: TsImport) => i.module)\n    // apparently this isn't a dependency of the above 3\n    .concat([\"watch-operations\"])\n    .filter(onlyUnique);\n\n  if (operationName && imports.includes(operationName)) {\n    log(`One of our dependencies (${operationName}) changed. Let's restart.`, {\n      type: \"important\",\n    });\n    process.exit(1);\n  }\n}"
  },
  "generateJsonSchemas": {
    "name": "generateJsonSchemas",
    "slug": "TsFunction",
    "id": "zsfzbzvmhypmwwxudcbusjuc",
    "description": "generates schemas for db models\n\nIs done every time you run `rebuildOperation` and `generateSdkOperations`\n\nTODO: there are some problems with references that cannot be found with references to generic types... This can probably be solved, but it's not going to be easy!\n\nIDEA:\n\n1) find all referencing definitions in the main schema\n2) find those in all other interfaces\n3) recursively find references in those as well\n4) if you can't find the reference, remove the reference and replace type to \"any\" (add WARNING to description \"reference not found\")\n\nThis will result in a valid schema that has no unresolved references\n\nTODO: apply Storage<X> to db-models\n\nTODO: apply Array<X> to db-models with json-multiple\n\nTODO: apply special config conventions (MergedDbConfig) like tsconfig.json and package.json\n\nTODO: Make a validator that validates the whole database to this schema.",
    "operationName": "rebuild-operation",
    "rawText": " async (\n  manualProjectRoot?: string,\n  /**\n   * If given, does it just for a single operation\n   */\n  operationName?: string\n) => {\n  const projectRoot = manualProjectRoot || getProjectRoot();\n\n  if (!projectRoot) return;\n\n  const dbModels = await getAllDbModels(manualProjectRoot, operationName);\n\n  const jsonDbModels = dbModels.filter(\n    (x) =>\n      x.dbStorageMethod &&\n      [\"jsonMultiple\", \"jsonSingle\"].includes(x.dbStorageMethod)\n  );\n  /**\nLoop:\n\n- get the operationName for the model\n- use the db to get all interfaces with that very operationName except for the one of the model...,\n- get every `TsInterface.type.typeDefinition`\n- put those inside of keys in the `defintions` key\n- add the interface doccomment to the `title` key\n- put the main properties in properties\n- change copy `description` into `markdownDescription`, everywhere, to support Markdown Intellisense within JSON\n- set `additionalProperties` to `false`\n- set `\"$schema\": \"http://json-schema.org/draft-07/schema#\"`\n- maybe also apply storage of db convention, so no `xxxCalculated` properties or `operationName` etc... (Same as `Storage<X>`)\n- set `type: \"object\"`\n\n         */\n\n  const allSchemas = (\n    await Promise.all(\n      jsonDbModels.map(async (dbModel) => {\n        if (!dbModel.dbStorageMethod) return;\n        const locationPattern = getDefaultLocationPattern(\n          dbModel.dbStorageMethod,\n          dbModel.name\n        );\n        if (!locationPattern) return;\n\n        const allInterfaces = await db.get(\"TsInterface\", {\n          // operationName: dbModel.operationName,\n        });\n        const mainSchema = dbModel.type.typeDefinition;\n\n        const definitions = mergeObjectsArray(\n          allInterfaces\n            .filter((x) => x.name !== dbModel.name)\n            .map((x) => {\n              if (!x.type.typeDefinition) return;\n\n              const goodName = x.name.replace(\">\", \"%3E\").replace(\"<\", \"%3C\");\n              return { [goodName]: x.type.typeDefinition };\n            })\n            .filter(notEmpty)\n        );\n\n        const schema: JSONSchema7 = {\n          ...mainSchema,\n          $schema: \"http://json-schema.org/draft-07/schema#\",\n          title: dbModel.name,\n          additionalProperties: false,\n          description: dbModel.description,\n          definitions,\n        };\n\n        return {\n          schema,\n          fileMatch: [`/${locationPattern}`],\n          url: `./schemas/${pluralize(kebabCase(dbModel.name))}.schema.json`,\n        };\n      })\n    )\n  ).filter(notEmpty);\n\n  /**\n   The finished file should be put into `~/schemas/model-name.schema.json`\n\n    Recalculate `json.schemas` in `project-root.code-workspace` (in project root)\n\n    Put the storage convention in the `fileMatch` and the url to the project-relative schema in `url`...\n\n   */\n  const jsonSchemas = (\n    await Promise.all(\n      allSchemas.map(async (schemaObject) => {\n        const isWriteSuccessful = await writeJsonToFile(\n          path.join(projectRoot, schemaObject.url),\n          schemaObject.schema\n        );\n\n        if (!isWriteSuccessful) {\n          console.log(\"WRITE WERNT WRONG\");\n          return;\n        }\n\n        const { fileMatch, url } = schemaObject;\n        const setting = { fileMatch, url };\n\n        return setting;\n      })\n    )\n  ).filter(notEmpty);\n\n  const workspacePath = path.join(projectRoot, \"project-root.code-workspace\");\n  const workspace =\n    (await readJsonFile<{ [key: string]: any }>(workspacePath)) || {};\n\n  const oldSchemas = workspace.settings?.[\"json.schemas\"] || [];\n\n  // make new workspace by concatenating the schemas with the old one and removing duplicates\n  const newWorkspace = {\n    ...workspace,\n    settings: {\n      ...workspace.settings,\n      \"json.schemas\": jsonSchemas\n        .concat(oldSchemas)\n        .filter(\n          onlyUnique2<{ fileMatch: string[]; url: string }>(\n            (a, b) => a.url === b.url\n          )\n        ),\n    },\n  };\n\n  const isNewWorkspaceWritten = await writeJsonToFile(\n    workspacePath,\n    newWorkspace\n  );\n\n  // console.log({ isNewWorkspaceWritten, workspacePath });\n}"
  },
  "getAllDbModels": {
    "name": "getAllDbModels",
    "slug": "TsFunction",
    "id": "usaumkbomjdibvylvvuhqjzb",
    "description": "",
    "operationName": "rebuild-operation",
    "rawText": " async (\n  manualProjectRoot?: string,\n  operationName?: string\n) => {\n  const allDbModels = (\n    await db.get(\"TsInterface\", { manualProjectRoot, operationName: \"*\" })\n  )\n    .filter(\n      (x) => x.isDbModel && x.dbStorageMethod && x.isExported && !x.hasGeneric\n    )\n    .filter((x) => x.operationName !== \"database\")\n    .filter((x) => (operationName ? x.operationName === operationName : true))\n    .filter((x) => !!x.operationName) // && !dependants.includes(x.operationName)\n    .filter(onlyUnique2<TsInterface>((a, b) => a.name === b.name));\n\n  return allDbModels;\n}"
  },
  "getFileIds": {
    "name": "getFileIds",
    "slug": "TsFunction",
    "id": "yugfvkdqzfhabxalxvhzfeii",
    "description": "gets all identifiers of files, which are the relative path to a file without the extension",
    "operationName": "rebuild-operation",
    "rawText": " async ({\n  operationFolderPath,\n  pathSuffix,\n  extension,\n}: {\n  operationFolderPath: string;\n  extension?: SearchableExtension | SearchableExtension[];\n  pathSuffix: string;\n}) => {\n  const basePath = path.join(operationFolderPath, pathSuffix);\n\n  return (\n    await explore({\n      basePath,\n      extension,\n    })\n  )\n    .map((x) => x.path)\n    .map((p) => withoutExtension(p.slice(basePath.length)));\n}"
  },
  "getIndexFileIds": {
    "name": "getIndexFileIds",
    "slug": "TsFunction",
    "id": "sqxptgkzqsdqpybrmgcfmyir",
    "description": "gets identifiers of ts and tsx files, which are the relative path to a file without the extension",
    "operationName": "rebuild-operation",
    "rawText": " async (operationFolderPath: string) =>\n  getFileIds({\n    operationFolderPath,\n    // NB: we take index/variables here because we need the file ids of any index as they would be the same in any index\n    pathSuffix: `${databaseFolderName}/ts-variables`,\n    extension: \"json\",\n  })"
  },
  "getSrcIds": {
    "name": "getSrcIds",
    "slug": "TsFunction",
    "id": "luyogsxzsiokpvriiwqbpxxh",
    "description": "gets identifiers of ts and tsx files, which are the relative path to a file without the extension\n\nin order for them to be unique, we assume here that there's never a file with the ts extension when there's also a tsx file in the same folder with the same name. This would create duplicate ids.",
    "operationName": "rebuild-operation",
    "rawText": " async (operationFolderPath: string) =>\n  getFileIds({\n    operationFolderPath,\n    pathSuffix: \"src\",\n    extension: [\"ts\", \"tsx\"],\n  })"
  },
  "isOperationBuildNeeded": {
    "name": "isOperationBuildNeeded",
    "slug": "TsFunction",
    "id": "opnfrrzirfbkpkqhojcgpgaj",
    "description": "returns a boolean indicating whether or not the operation should be able to be built, based on the OperationClassification",
    "operationName": "rebuild-operation",
    "rawText": " (operationBasePath: string) => {\n  const classification = getOperationClassification(operationBasePath)!;\n\n  console.log(`${getLastFolder(operationBasePath)}: ${classification}`);\n\n  // NB: server, web, app and ui-es6 have different ways to keep the build up-to-date\n  // NB: esm can't be minified with current thing\n  const buildNeededOperatons: OperationClassification[] = [\n    \"cjs\",\n    // \"esm\",\n    \"node-cjs\",\n    // \"node-esm\",\n    \"ui-cjs\",\n    // \"ui-esm\",\n  ];\n  const isBuildNeeded = buildNeededOperatons.includes(classification);\n\n  return isBuildNeeded;\n}"
  },
  "isRebuildingProcessUpdated": {
    "name": "isRebuildingProcessUpdated",
    "slug": "TsVariable",
    "id": "woztnkrkkuirtikbyukrrjqh",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "isSdkOperation": {
    "name": "isSdkOperation",
    "slug": "TsFunction",
    "id": "smmbyqahyxzgnzwnsubvotwv",
    "description": "",
    "operationName": "rebuild-operation",
    "rawText": " (operationBasePath: string) => {\n  const operationName = getLastFolder(operationBasePath);\n\n  return operationName.split(\"-\")[0] === \"sdk\";\n}"
  },
  "[isUpdatedString]": {
    "name": "[isUpdatedString]",
    "slug": "TsVariable",
    "id": "dejoxrkasppgpllfyljlszzf",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "manualProjectRoot": {
    "name": "manualProjectRoot",
    "slug": "TsVariable",
    "id": "zsvsazsewxwogvmjzbbxcmbp",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "rebuildAllOperations": {
    "name": "rebuildAllOperations",
    "slug": "TsFunction",
    "id": "dobhtzediujakomcbrpdkahs",
    "description": "Rebuilds all operations that are needed to be rebuilt",
    "operationName": "rebuild-operation",
    "rawText": " async (\n  /**\n   * If true, you are indicating that the rebuilding process has changed and all operations should be rebuilt after this date.\n   */\n  isRebuildingProcessUpdated?: boolean,\n  manualProjectRoot?: string\n) => {\n  const configPath = path.join(__dirname, \"..\", \"config.json\");\n\n  if (isRebuildingProcessUpdated) {\n    await writeJsonToFile(configPath, { updatedAt: Date.now() });\n  }\n\n  const config = await readJsonFile<{ updatedAt: number }>(configPath);\n\n  forAllFolders({\n    type: \"operations\",\n    basePath: getPathsWithOperations({ manualProjectRoot }),\n    callback: async (folderPath, index) => {\n      log(`#${index}: Let's do ${folderPath}`, { type: \"success\" });\n\n      await rebuildOperation({\n        operationBasePath: folderPath,\n        noExit: true,\n        updatedAt: config?.updatedAt,\n      });\n\n      return;\n    },\n  });\n}"
  },
  "rebuildOperationCli": {
    "name": "rebuildOperationCli",
    "slug": "TsFunction",
    "id": "dcjtamlgfxfhlsnximpfjjtk",
    "description": "`rebuildOperation` CLI syntax:\n\n`rebuildOperation [...operations]`\n\nOperations can be a list of differnt operation names you want to rebuild. It's also possible to specify a relative path instead of an operation name.\n\nfor example:\n\n`rebuildOperation ./packages/operation-x` would rebuild `operation-x` in your packages folder\n\nanother handy one is `rebuildOperation .` because it will rebuild the operation in your current folder.",
    "operationName": "rebuild-operation",
    "rawText": " async () => {\n  const argumentsArray = process.argv.slice(2);\n  const currentProjectRoot = getProjectRoot();\n\n  if (argumentsArray.length > 0) {\n    oneByOne(argumentsArray, async (operationNameOrRelativePath) => {\n      let operationBasePath: string | undefined;\n      let realProjectRoot: string | undefined;\n      if (operationNameOrRelativePath.startsWith(\".\")) {\n        operationBasePath = path.join(\n          process.cwd(),\n          operationNameOrRelativePath\n        );\n\n        realProjectRoot = getProjectRoot(operationBasePath);\n      } else {\n        realProjectRoot = await getOperationPath(operationNameOrRelativePath);\n      }\n\n      if (!operationBasePath) {\n        log(\"couldn't find that operation\");\n        return;\n      }\n\n      // console.log({ operationNames, operationName });\n\n      const x = await rebuildOperation({\n        operationBasePath,\n        operationManualProjectRoot:\n          realProjectRoot !== currentProjectRoot ? realProjectRoot : undefined,\n        force: true,\n        debug: true,\n        noExit: true,\n      });\n    });\n  }\n}"
  },
  "rebuildOperation": {
    "name": "rebuildOperation",
    "slug": "TsFunction",
    "id": "dggvxodittjwvnhuoigthqrm",
    "description": "This function rebuilds an operation and re-indexes (part of) its files.",
    "operationName": "rebuild-operation",
    "rawText": " async (config: {\n  /** last date when the rebuild-operation operation was updated (or any of its dependencies) */\n  updatedAt?: number;\n  /** If given, uses this as project root for the rebuildOperation dependencies, instead of the calculatable one */\n  typerepoManualProjectRoot?: string;\n\n  /**\n   * If given, uses this as project root for finding things from the database for the operation that needs to be rebuilt\n   */\n  operationManualProjectRoot?: string;\n\n  /** Full path to operation folder or any file therein */\n  operationBasePath: string;\n  /** If not given, explores all files in src folder of the operation. if given, must be an array of absolute file paths. it is not supported to index index files, as this creates duplicate and incorrect interfaces.  */\n  filePaths?: string[];\n  /** used for stopping recursion */\n  noUnresolvedRebuilding?: boolean;\n  /** if true, will not skip if nothing changed */\n  force?: boolean;\n  /** show logs */\n  debug?: boolean;\n  /** normally, it exits if the operation that was rebuilt was itself or one of its dependencies. Handy for watchOperations in combination with nodemon. If we don't want this behavior, provide noExit  */\n  noExit?: boolean;\n  /** stack of recursion of module names */\n  stack?: string[];\n}): Promise<boolean> => {\n  const {\n    operationBasePath,\n    force,\n    debug,\n    noExit,\n    stack = [],\n    updatedAt,\n    noUnresolvedRebuilding,\n    operationManualProjectRoot,\n    typerepoManualProjectRoot,\n  } = config;\n\n  let { filePaths } = config;\n  const operationName = getLastFolder(operationBasePath);\n  const packageJson = await getPackageJson({\n    operationFolderPath: operationBasePath,\n  });\n  if (\n    isSdkOperation(operationBasePath) ||\n    isGeneratedOperation(operationBasePath)\n  ) {\n    console.log(`not going to rebuild sdk operation: ${operationName}`);\n    return false;\n  }\n\n  const stackPrefix = `${stack.map(() => `--`).join(\"\")}${operationName}: `;\n  log(\n    `${stackPrefix}Rebuilding${\n      stack.length > 0 ? `(coming from ${stack.join(\", \")})` : \"\"\n    }`,\n    {\n      type: \"important\",\n    }\n  );\n\n  log(`${stackPrefix}Pre-index lint`, { type: \"important\" });\n  const lintProblems = await preIndexLint({\n    operationFolderPath: operationBasePath,\n  });\n\n  if (lintProblems.length > 0) {\n    log(`${stackPrefix}Operation cannot be built, we've got problem(s)`, {\n      type: \"warning\",\n    });\n    log(lintProblems.join(\"\\n\"), { type: \"warning\" });\n\n    await db.update(\n      \"Operation\",\n      () => true,\n      (old) => {\n        setKeyAtLocation(\n          \"operation.buildResultIndexed.lintProblems\",\n          lintProblems,\n          old\n        );\n\n        return old;\n      },\n      { operationName }\n    );\n\n    return false;\n  }\n\n  const skip = await shouldSkip({\n    operationBasePath,\n    debug,\n    force,\n    rebuildUpdatedAt: updatedAt,\n    operationManualProjectRoot,\n  });\n  if (skip) {\n    log(`Skipping ${operationName}`);\n    return true;\n  }\n\n  const result = await cleanupTsDatabase(\n    operationName,\n    operationManualProjectRoot\n  );\n\n  log(\n    result?.amountRemoved\n      ? `Removed ${result?.amountRemoved} ts db instances`\n      : \"Nothing to clean up\",\n    { type: \"success\" }\n  );\n\n  executeCommandQuietUnlessFail({\n    command: \"yarn --offline\",\n    cwd: operationBasePath,\n    description: `${stackPrefix}Installing`,\n  });\n\n  // 2a) finding imports/exports and writing them to index\n  // TODO: we can also just check if build folder and index.js exist before looking at the import statements. These are easy to detect and when that happens we don't need to do the things below.\n  log(`${stackPrefix}Getting imports/exports`, { type: \"important\" });\n\n  await runChildProcess({\n    operationFolderName: \"get-imports-exports\",\n    scriptFileName: \"findAndWriteImportsExports.cli\",\n    args: [operationBasePath, operationManualProjectRoot],\n  });\n\n  /// SDK SHIT\n\n  if (operationName !== \"sdk\") {\n    // get all newly generated imports through the db (NB: old index files have just been removed)\n    const imports = await db.get(\"TsImport\", {\n      operationName: operationName,\n      manualProjectRoot: operationManualProjectRoot,\n    });\n    // find the ones that are unresolved\n    const unresolvedModules = imports\n      .filter(\n        (x) => x.isAbsolute && x.isModuleFromMonorepo && !x.isModuleResolved\n      )\n      .map((x) => x.module)\n      .filter(onlyUnique);\n\n    // console.log({\n    //   imports: imports.length,\n    //   unresolvedModules: unresolvedModules.length,\n    // });\n\n    // if there are any, we need to rebuildOperation for those modules and then rebuild ourselves again\n    // NB: we can't do this if we already did this before\n    if (unresolvedModules.length > 0) {\n      if (noUnresolvedRebuilding) {\n        log(\n          `rebuilding the unresolved modules didn't work. Probably some indexation fails!`,\n          { type: \"error\" }\n        );\n\n        await db.update(\n          \"Operation\",\n          () => true,\n          (old) => {\n            setKeyAtLocation(\n              \"operation.buildResultIndexed.dependencyBuildFailed\",\n              true,\n              old\n            );\n\n            return old;\n          },\n          { operationName, manualProjectRoot: operationManualProjectRoot }\n        );\n\n        return false;\n      }\n\n      log(\n        `${stackPrefix}We need to rebuild ${\n          unresolvedModules.length\n        } operations because they have conflicts (${unresolvedModules.join(\n          \", \"\n        )})`,\n        { type: \"warning\" }\n      );\n      const succeededArray = await oneByOne(\n        unresolvedModules,\n        async (unresolvedOperationName) => {\n          const fullPath = await getOperationPath(unresolvedOperationName, {\n            manualProjectRoot: operationManualProjectRoot,\n          });\n          if (!fullPath) {\n            log(`${stackPrefix}${unresolvedOperationName} not found`, {\n              type: \"warning\",\n            });\n            return false;\n          }\n\n          if (\n            unresolvedOperationName === operationName ||\n            stack.includes(unresolvedOperationName)\n          ) {\n            log(`${stackPrefix}cyclic dep`, { type: \"warning\" });\n            return false;\n          }\n\n          console.log(`${stackPrefix}diving into new rebuildOperation `, {\n            operationName,\n            stack,\n            unresolvedOperationName,\n          });\n          return rebuildOperation({\n            operationManualProjectRoot,\n            typerepoManualProjectRoot,\n            operationBasePath,\n            stack: stack.concat([unresolvedOperationName]),\n            debug,\n            // can't skip this one because it is a dependency\n            // however, skipping is very well defined. we can skip if shouldSkip is true!\n            // force: true,\n            noExit,\n          });\n        }\n      );\n\n      // NB: we don't rebuild this operation again if one of the dependency builds failed...\n      if (!isAllTrue(succeededArray)) {\n        log(`${stackPrefix}something failed! returning`);\n\n        await db.update(\n          \"Operation\",\n          () => true,\n          (old) => {\n            setKeyAtLocation(\n              \"operation.buildResultIndexed.dependenciesBuildsFailed\",\n              true,\n              old\n            );\n            return old;\n          },\n          { operationName, manualProjectRoot: operationManualProjectRoot }\n        );\n\n        return false;\n      }\n\n      log(`${stackPrefix}rebuilding ourselves again`);\n      // NB: all files on purpose...\n      return rebuildOperation({\n        operationManualProjectRoot,\n        typerepoManualProjectRoot,\n        operationBasePath,\n        debug,\n        force,\n        noExit,\n        noUnresolvedRebuilding: true,\n        stack: stack.concat([operationName]),\n      });\n    } else {\n      log(`${stackPrefix}all imports were resolved`);\n    }\n  }\n\n  // 2b) compiling and writing build errors to index\n  log(`${stackPrefix}writing build errors SKIPPED due to memory bug`, {\n    type: \"important\",\n  });\n\n  // await runChildProcess({\n  //   operationFolderName: \"compile-typescript\",\n  //   scriptFileName: \"writeBuildErrors.cli\",\n  //   args: [\n  //     operationBasePath,\n  //     operationManualProjectRoot,\n  //     typerepoManualProjectRoot,\n  //   ],\n  // });\n  // read errors...\n  // TODO: if this returns errors, don't continue\n\n  // 3. creating remaining operation index files\n  if (!filePaths) {\n    //files from src\n    filePaths = (\n      await Promise.all(\n        await getPackageSourcePaths({\n          operationBasePath,\n          ignoreIndexFiles: true,\n        })\n      )\n    ).filter(notEmpty);\n  }\n\n  if (filePaths.length === 0) {\n    log(`${stackPrefix}No files found for operation ${operationName}`, {\n      type: \"error\",\n    });\n  } else {\n    log(`${stackPrefix}${filePaths.length} files to index:`, {\n      type: \"important\",\n    });\n  }\n\n  // first index the files that have changed\n  await runChildProcess({\n    operationFolderName: \"index-typescript\",\n    scriptFileName: \"cli\",\n    args: [...filePaths, operationManualProjectRoot || \"null\"],\n  });\n  // after that's done, generate cli's where possible. only if it's a node operation (or can I use node for js functions that also run on the frontend?) if not, I might be better off generating a [operation-name]-cli operation for js-only operations...\n\n  // first step, just\n\n  const indexPath = await generateSimpleIndex({\n    operationName,\n    manualProjectRoot: operationManualProjectRoot,\n  });\n\n  // // because we generated a new index, let's also reindex that file!\n  // TODO: Figure out if this is REALLY NEEDED... I guess we can also infer which things are in the index, and we don't want to index things here except maybe the imports/exports!\n  // if (indexPath) {\n  //   await runChildProcess({\n  //     operationFolderName: \"index-typescript\",\n  //     scriptFileName: \"cli\",\n  //     args: manualProjectRoot ? [indexPath, manualProjectRoot] : [indexPath],\n  //   });\n\n  //   log(`indexed index :)`, {\n  //     type: \"success\",\n  //   });\n  // }\n\n  const isBuildNeeded = isOperationBuildNeeded(operationBasePath);\n\n  let buildSucceeded = true;\n\n  // NB: no build, no tests (for now)\n  if (isBuildNeeded) {\n    const skipMinify = packageJson?.operation?.skipMinify;\n\n    buildSucceeded = await yarnBuild(operationBasePath, {\n      rmFirst: false,\n      skipMinify,\n    });\n\n    // TESTING EVERYTHING, including all dependant packages\n\n    const imports = await db.get(\"TsImport\", {\n      manualProjectRoot: operationManualProjectRoot,\n    });\n    // find the ones that are unresolved\n    const dependantOperationNames = imports\n      .filter((x) => x.isModuleFromMonorepo && x.module === operationName)\n      .map((x) => x.operationName)\n      .filter(onlyUnique)\n      .filter(notEmpty);\n\n    const testableOperations = [operationName, ...dependantOperationNames];\n    const testPromises = testableOperations.map((operationName) =>\n      // NB: we need this to be a child process because it requires the tests from the index, and that file changes, while normally a require will be cached. We can't easily invalidate the cache because it can come from many files.\n      runChildProcess({\n        operationFolderName: \"k-test\",\n        scriptFileName: \"runTestsForOperation.cli\",\n        args: [operationName, operationManualProjectRoot],\n      })\n    );\n\n    await Promise.all(testPromises);\n  }\n\n  await generateJsonSchemas(operationManualProjectRoot, operationName);\n\n  await db.update(\n    \"Operation\",\n    () => true,\n    (old) => {\n      setKeyAtLocation(\n        \"operation.buildResultIndexed.buildSucceeded\",\n        true,\n        old\n      );\n      return old;\n    },\n    { operationName, manualProjectRoot: operationManualProjectRoot }\n  );\n\n  const operationSummary = await getOperationSummary({\n    operationName,\n    manualProjectRoot: operationManualProjectRoot,\n  });\n\n  if (operationSummary) {\n    // make a readme of the new index\n    await operationToMarkdown({ operationSummary, returnType: \"save\" });\n  }\n\n  await db.update(\n    \"Operation\",\n    () => true,\n    (old) => {\n      setKeyAtLocation(\n        \"operation.buildResultIndexed.indexImportExportError\",\n        \"\",\n        old\n      );\n      setKeyAtLocation(\n        \"operation.buildResultIndexed.lintProblems\",\n        lintProblems,\n        old\n      );\n\n      return old;\n    },\n    { operationName, manualProjectRoot: operationManualProjectRoot }\n  );\n\n  await recalculateOperationIndexJson(\n    operationBasePath,\n    operationManualProjectRoot\n  );\n\n  if (!noExit) {\n    await exitIfProcessDependenciesChanged(\n      operationName,\n      operationManualProjectRoot\n    );\n  }\n\n  return true;\n}"
  },
  "shouldSkip": {
    "name": "shouldSkip",
    "slug": "TsFunction",
    "id": "wpkktfbcyjneilodlesxbbiu",
    "description": "if you don't force it, there's an operation index, there's an index folder, the src has not been touched since hte last indexation, and there's a buildfolder (if needed), then the rebuildOperation can be skipped",
    "operationName": "rebuild-operation",
    "rawText": " async (config: {\n  operationBasePath: string;\n  debug?: boolean;\n  force?: boolean;\n  operationManualProjectRoot?: string;\n  rebuildUpdatedAt?: number;\n}) => {\n  const {\n    operationBasePath,\n    debug,\n    force,\n    rebuildUpdatedAt,\n    operationManualProjectRoot,\n  } = config;\n  const operationName = getLastFolder(operationBasePath);\n\n  if (force) {\n    console.log(\"Not skipping (force)\");\n    return false;\n  }\n\n  const operation = (\n    await db.get(\"Operation\", {\n      operationName,\n      manualProjectRoot: operationManualProjectRoot,\n    })\n  )[0];\n  if (!operation.operation?.folderNameIndexed) {\n    console.log(\n      \"Not skipping because no folderNameIndexed (likely never indexed) \"\n    );\n    return false;\n  }\n\n  if (\n    rebuildUpdatedAt &&\n    (!operation.operation?.lastRebuildAt ||\n      operation.operation.lastRebuildAt <= rebuildUpdatedAt)\n  ) {\n    console.log(\"Not skipping because rebuild updated\");\n    return false;\n  }\n\n  const srcPath = path.join(operationBasePath, \"src\");\n  const srcUpdatedAt = await folderGetUpdatedAt({ folderPath: srcPath });\n\n  if (\n    !operation.operation?.lastRebuildAt ||\n    operation.operation.lastRebuildAt <= srcUpdatedAt\n  ) {\n    console.log(\"Not skipping because src updated\");\n    return false;\n  }\n\n  const hasIndexFolder = fs.existsSync(\n    path.join(operationBasePath, databaseFolderName)\n  );\n  if (!hasIndexFolder) {\n    console.log(\"Not skipping because has no db folder \");\n    return false;\n  }\n\n  const noBuildFolder = !fs.existsSync(\n    path.join(operationBasePath, buildFolderName)\n  );\n\n  const isBuildNeeded = isOperationBuildNeeded(operationBasePath);\n\n  if (noBuildFolder && isBuildNeeded) {\n    console.log(\"Not skipping because noBuildFolder\");\n    return false;\n  }\n\n  return true;\n}"
  },
  "thisProjectRoot": {
    "name": "thisProjectRoot",
    "slug": "TsVariable",
    "id": "zownchcwutxcregbgncmekev",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "yarnBuild": {
    "name": "yarnBuild",
    "slug": "TsFunction",
    "id": "hjrucjarxrzdymfszvyepwnk",
    "description": "Builds and minifies the src",
    "operationName": "rebuild-operation",
    "rawText": " async (\n  operationBasePath: string,\n  config?: {\n    /**\n     * if true, build folder will be removed first\n     */\n    rmFirst?: boolean;\n    skipMinify?: boolean;\n  }\n): Promise<Success> => {\n  if (config?.rmFirst && fs.existsSync(path.join(operationBasePath, \"build\"))) {\n    const removed = spawnSync(`rm -rf build`, {\n      cwd: operationBasePath,\n      encoding: \"utf8\",\n      stdio: \"inherit\",\n      shell: true,\n    });\n  }\n\n  if (!fs.existsSync(operationBasePath)) {\n    return false;\n  }\n\n  // TODO:\n  // this should only happen conditionally but for now we'll always try\n  // later we can add the option to not build if any dependant builds break because of our code changes, but this is quite complex.\n  const success = executeCommandQuietUnlessFail({\n    command: \"yarn build\",\n    cwd: operationBasePath,\n    description: `Compiling source ${operationBasePath}`,\n  });\n\n  if (!success) {\n    log(`Build failed for ${getLastFolder(operationBasePath)}`, {\n      type: \"error\",\n    });\n    return false;\n  } //\n\n  if (config?.skipMinify) {\n    console.log(\"SKIPPING MINIFY\");\n\n    return success;\n  }\n\n  const minified = await minifyBuild({\n    buildFolderPath: path.join(operationBasePath, buildFolderName),\n  });\n\n  return minified || false;\n}"
  },
  "getKeysAtPathFromNestedObject": {
    "name": "getKeysAtPathFromNestedObject",
    "slug": "TsFunction",
    "id": "nlkpurfsrqryiqvueoksrrkh",
    "description": "Gets all children keys of a nested object at a certain (nested) location in the nested object\n\n`nestedObject` should extend the `NestedObject`.\n\nThe reduce is a bit vague, I need to  test this function further to make sure it does exactly what I want.",
    "operationName": "recursive-util",
    "rawText": " <T extends { [key: string]: any }>( //NestedObject<null>\n  nestedObject: T,\n  /**\n   * Something like a/b/c/d\n   */\n  objectPath: string\n) => {\n  const pathParts = objectPath.split(\"/\");\n  const objectAtLocation = pathParts.reduce((objectSubset, part) => {\n    // basecase should never happen\n    if (!objectSubset) return;\n    const subset = objectSubset[part];\n    return subset;\n  }, nestedObject as T);\n\n  const children = objectAtLocation ? Object.keys(objectAtLocation) : [];\n\n  return children;\n}"
  },
  "getMenuPagesObject": {
    "name": "getMenuPagesObject",
    "slug": "TsFunction",
    "id": "xrjbolsgxohtkwefkrwknrax",
    "description": "",
    "operationName": "recursive-util",
    "rawText": " <T>(\n  flat: WebPage<T>[]\n): MenuObjectType<T> => {\n  // NB: to make the NestedWebPage[], we don't want the pageData.\n  const flatWithoutPageData: WebPage[] = flat.map((x) => {\n    return { ...x, pageData: null, __check: true };\n  });\n\n  const nestedObject = makeNestedObjectFromQueryPathObject(\n    flatWithoutPageData,\n    {}\n  );\n\n  const keyToWebPage = (nestedObject: NestedObject<WebPage>, key: string) => {\n    return { ...nestedObject, pageData: null, queryPath: \"\" };\n  };\n\n  const nested: NestedWebPage[] = nestedObjectToChildObject(\n    nestedObject,\n    keyToWebPage\n  );\n\n  return { flat, nested };\n}"
  },
  "makeNestedObjectFromQueryPathObject": {
    "name": "makeNestedObjectFromQueryPathObject",
    "slug": "TsFunction",
    "id": "dkpmbkopqsxxgczngdxqqhwt",
    "description": "",
    "operationName": "recursive-util",
    "rawText": " <T extends QueryPathObject>(\n  objectArray: T[],\n  initialValue: NestedObject<T>\n): NestedObject<T> => {\n  // copy queryPath into chunk\n  const reducableObjectArray = objectArray.map((x) => ({\n    ...x,\n    __chunk: x.__chunk || x.queryPath,\n  }));\n\n  const nestedPathObject = reducableObjectArray.reduce((previous, current) => {\n    const parts: string[] = current.__chunk.split(\"/\");\n    const firstPart = parts[0];\n\n    // Base case 1: if we already have it, skip it\n    if (Object.keys(previous).includes(firstPart)) {\n      return previous;\n    }\n\n    const queryPathsHere = reducableObjectArray\n      .filter((p) => p.__chunk.startsWith(`${firstPart}/`))\n      .map((p) => {\n        return { ...p, __chunk: p.__chunk.substring(firstPart.length + 1) };\n      });\n\n    // Base case 2: if it's a leaf (last item), and it has NO children, return it with its own value\n    if (parts.length === 1 && queryPathsHere.length === 0) {\n      const leaf = { ...previous, [firstPart]: current };\n      return leaf;\n    }\n\n    // Recursion case: find all queryPaths starting with the same branch\n    const newNestedPathObject: NestedObject<T> = {\n      ...previous,\n      [firstPart]: makeNestedObjectFromQueryPathObject(queryPathsHere, {}),\n    };\n\n    return newNestedPathObject;\n  }, initialValue) as NestedObject<T>;\n\n  return nestedPathObject;\n}"
  },
  "mapChildObjectRecursive": {
    "name": "mapChildObjectRecursive",
    "slug": "TsFunction",
    "id": "kzamjcnccwzasfiwitfioyoj",
    "description": "maps a ChildObject and all it's children, recursively",
    "operationName": "recursive-util",
    "rawText": " <\n  T extends { [key: string]: any },\n  U extends { [key: string]: any }\n>(\n  childObject: ChildObject<T>,\n  mapFunction: (item: ChildObject<T>) => U\n): ChildObject<U> => {\n  const newChildObject = mapFunction(childObject);\n\n  return {\n    ...newChildObject,\n    children: childObject.children?.map((child) =>\n      mapChildObjectRecursive(child, mapFunction)\n    ),\n  } as ChildObject<U>;\n}"
  },
  "nestedObjectToChildObject": {
    "name": "nestedObjectToChildObject",
    "slug": "TsFunction",
    "id": "ahmkkaxqledpfvjkyuocwteu",
    "description": "if T is an object, provide __check as one of its properties, to make it possible to check that it's a leaf. This property will be omitted in the ChildObject array",
    "operationName": "recursive-util",
    "rawText": " <T extends { [key: string]: any }>(\n  /**\n   * if T is an object, provide __check to check that it's a leaf\n   */\n  nestedObject: NestedObject<T>,\n  /**\n   * Map the folder to T. You can omit queryPath, it will be overwritten\n   */\n  mapFolderToT: (nestedObject: NestedObject<T>, key: string) => T,\n  stack: string[] = []\n): ChildObject<T>[] => {\n  const keys = Object.keys(nestedObject);\n  const children = keys.map((key) => {\n    const t = mapFolderToT(nestedObject, key);\n    const value = nestedObject[key];\n\n    const isLeaf = typeof value !== \"object\" || !!value.__check;\n\n    if (isLeaf) {\n      const { __check, ...valueWithoutCheck } = value;\n      return valueWithoutCheck;\n    }\n\n    const newStack = stack.concat(key);\n    const queryPath = newStack.join(\"/\");\n\n    return {\n      ...t,\n      queryPath,\n      children: nestedObjectToChildObject(value, mapFolderToT, newStack),\n    };\n  }) as ChildObject<T>[];\n\n  return children;\n}"
  },
  "nestedPathObjectToNestedMenuRecursive": {
    "name": "nestedPathObjectToNestedMenuRecursive",
    "slug": "TsFunction",
    "id": "wmdseplxudovcbesyqtgzqxk",
    "description": "Transform a nested path object into a nested menu (MenuType), recursively",
    "operationName": "recursive-util",
    "rawText": " (\n  /**\n   * your nested path object that you want to create a menu for\n   */\n  nestedPathObject: NestedPathObject | null,\n  /**\n   * used for recursion to get the final url (defaults to empty array)\n   */\n  pathStack: string[] = [],\n  config?: {\n    target?: \"_blank\";\n    /**\n     * optionally , provide a callback function that returns the actual path\n     */\n    getHref?: (fullPath: string) => string;\n  }\n): MenuItemType[] | undefined => {\n  const target = config?.target;\n  const getHref = config?.getHref;\n\n  // base case\n  if (!nestedPathObject) return;\n\n  const menu: MenuItemType[] = Object.keys(nestedPathObject).map((path) => {\n    const newPathStack = pathStack.concat(path);\n    const fullPath = newPathStack.join(\"/\");\n    const children = nestedPathObjectToNestedMenuRecursive(\n      nestedPathObject[path],\n      newPathStack,\n      config\n    );\n\n    const href = getHref ? getHref(fullPath) : fullPath;\n\n    const menuItem: MenuItemType = {\n      // NB: if there is no path, the title  of the page should be \"home\"\n      title: path.length === 0 ? \"Home\" : path,\n      href,\n      target,\n      children,\n    };\n\n    return menuItem;\n  });\n\n  return menu;\n}"
  },
  "nestifyQueryPathObjectRecursive": {
    "name": "nestifyQueryPathObjectRecursive",
    "slug": "TsFunction",
    "id": "tbrbyhqcpnykqfkzauwqfxts",
    "description": "",
    "operationName": "recursive-util",
    "rawText": " <T extends QueryPathObject>(\n  queryPathObjects: T[],\n  level?: number\n): NestedQueryPathObject<T>[] => {\n  console.log({ level });\n  const nestedPathObject: NestedQueryPathObject<T>[] = queryPathObjects.reduce(\n    (previous, current, currentIndex, queryPathObjects) => {\n      const queryPathRemainder =\n        current.queryPathRemainder || current.queryPath;\n      const parts: string[] = queryPathRemainder.split(\"/\");\n      const firstPart = parts.find((x) => x.length !== 0);\n\n      const hasFirstPartAlready = !!previous.find(\n        (x) => x.queryPathChunk === firstPart\n      );\n\n      if (hasFirstPartAlready) {\n        // Base case 1: if we already have it, skip it, go to the next\n        return previous;\n      }\n\n      const children = queryPathObjects\n        // not myself!\n        .filter((x) => x.queryPath !== current.queryPath)\n        .filter((x) => {\n          const queryPath = x.queryPathRemainder || x.queryPath;\n          const isMatch = queryPath.startsWith(firstPart + \"/\");\n          return isMatch;\n        })\n        .map((x) => {\n          // everything after the first part\n          const queryPathRemainder = x.queryPath.split(firstPart!)[1];\n          return { ...x, queryPathRemainder };\n        });\n\n      const newNestedQueryPathObject = {\n        ...current,\n        // queryPath: folderQueryPath,\n        children:\n          children.length === 0\n            ? undefined\n            : [\n                current,\n                ...nestifyQueryPathObjectRecursive(children, (level || 0) + 1),\n              ],\n        queryPathChunk: firstPart,\n      } as NestedQueryPathObject<T>;\n      // add the new one to the array\n      return [...previous, newNestedQueryPathObject];\n    },\n    [] as NestedQueryPathObject<T>[]\n  );\n\n  return nestedPathObject;\n}"
  },
  "queryPathsArrayToNestedPathObject": {
    "name": "queryPathsArrayToNestedPathObject",
    "slug": "TsFunction",
    "id": "ictpbrszzthvsxdskwkiuvcx",
    "description": "Handy function to transform an array of `querypaths` into a nested menu, assuming you want to create a new sub-menu for every path\n\nMay also work for relative filePaths\n\nInput:\n\n[\"hello/world\",\"hello/moon\",\"hello/sun\"]\n\nOutput:\n\n{\n\"hello\":{\n\"moon\":null,\n\"world\":null,\n\"sun\":null\n}\n}",
    "operationName": "recursive-util",
    "rawText": " (\n  queryPaths: string[]\n): NestedPathObject => {\n  const nestedPathObject: NestedPathObject = reduceQueryPathsRecursively(\n    queryPaths,\n    {}\n  );\n  return nestedPathObject;\n}"
  },
  "reduceQueryPathsRecursively": {
    "name": "reduceQueryPathsRecursively",
    "slug": "TsFunction",
    "id": "lmzqvdriinpfiaaoowvtoswv",
    "description": "",
    "operationName": "recursive-util",
    "rawText": " (\n  queryPaths: string[],\n  initialValue: NestedPathObject\n): NestedPathObject => {\n  const nestedPathObject = queryPaths.reduce((nestedPathObject, queryPath) => {\n    const parts: string[] = queryPath.split(\"/\");\n    const firstPart = parts[0];\n\n    // Base case 1: if we already have it, skip it\n    if (Object.keys(nestedPathObject).includes(firstPart)) {\n      return nestedPathObject;\n    }\n\n    const queryPathsHere = queryPaths\n      .filter((p) => p.startsWith(`${firstPart}/`))\n      .map((p) => p.substring(firstPart.length + 1));\n\n    // Base case 2: if it's a leaf (last item), and it has NO children, return it with value null\n    if (parts.length === 1 && queryPathsHere.length === 0) {\n      return { ...nestedPathObject, [firstPart]: null };\n    }\n\n    // Recursion case: find all queryPaths starting with the same branch\n    const newNestedPathObject: NestedPathObject = {\n      ...nestedPathObject,\n      [firstPart]: reduceQueryPathsRecursively(queryPathsHere, {}),\n    };\n\n    return newNestedPathObject;\n  }, initialValue);\n\n  return nestedPathObject;\n}"
  },
  "findTemplates": {
    "name": "findTemplates",
    "slug": "TsFunction",
    "id": "wwtrwuamkbhotwkbwnizbfzl",
    "description": "",
    "operationName": "rename-template-files",
    "rawText": " async (\n  basePath: string,\n  doNotExploreChildFolders?: boolean\n) => {\n  return (\n    await explore({\n      basePath,\n      subExtension: [\"template\"],\n      searchLevel: \"fileName\",\n      doNotExploreChildFolders,\n    })\n  ).map((textJson) => textJson.path);\n}"
  },
  "isEqualArray": {
    "name": "isEqualArray",
    "slug": "TsFunction",
    "id": "jlxyujtwdsyfsybnnihgwnqv",
    "description": "As long as there are no .template files present in the template folder that DONT need to be changed, it is fine.\nIf there are, we should warn people.",
    "operationName": "rename-template-files",
    "rawText": " (array1: unknown[], array2: unknown[]) =>\n  array1.length === array2.length &&\n  array1.every((value, index) => value === array2[index])"
  },
  "renameTemplateFiles": {
    "name": "renameTemplateFiles",
    "slug": "TsFunction",
    "id": "ckfjzpxhscuajypnijravckt",
    "description": "",
    "operationName": "rename-template-files",
    "rawText": " async ({ appDir }: { appDir: string }) => {\n  const templateFiles = await findTemplates(appDir);\n  const renameables = templateFiles.map((path) => ({\n    oldPath: path,\n    newPath: renameTemplateToNormalFile(path),\n  }));\n\n  await oneByOne(renameables, async (oldNew) =>\n    fs.rename(oldNew.oldPath, oldNew.newPath)\n  );\n\n  return;\n}"
  },
  "renameTemplateToNormalFile": {
    "name": "renameTemplateToNormalFile",
    "slug": "TsFunction",
    "id": "ytadvhqirvlirbzsdkawksxf",
    "description": "",
    "operationName": "rename-template-files",
    "rawText": " (fileName: string) => {\n  return fileName.replace(\".template\", \"\");\n}"
  },
  "renameToTemplateFile": {
    "name": "renameToTemplateFile",
    "slug": "TsFunction",
    "id": "qexadcpbtpzdiocvfbqyjjml",
    "description": "",
    "operationName": "rename-template-files",
    "rawText": " (fileName: string) => {\n  const extensionStartsAt = fileName.lastIndexOf(\".\");\n  const insertPosition =\n    extensionStartsAt === -1 ? fileName.length : extensionStartsAt;\n  const beforeExtension = fileName.substring(0, insertPosition);\n  const afterExtension = fileName.substring(insertPosition);\n\n  return `${beforeExtension}${templateExtension}${afterExtension}`;\n}"
  },
  "templateExtension": {
    "name": "templateExtension",
    "slug": "TsVariable",
    "id": "bkhpyphggkwehjxbhibxosui",
    "description": "",
    "operationName": "rename-template-files"
  },
  "bodyFromQueryString": {
    "name": "bodyFromQueryString",
    "slug": "TsFunction",
    "id": "puiwvvhpdbhgzwyqfuvfxfcr",
    "description": "converts a query string into an object that can be used as a body",
    "operationName": "rest-util",
    "rawText": " (\n  /**\n   * NB: everything AFTER The \"?\", so this should be the format: x=x&y=y&z=z&z=z2\n   */\n  query?: string\n): QueryableObject | undefined => {\n  if (!query) return;\n\n  const keyValueObjectArray = query.split(\"&\")?.map((x) => {\n    const [key, value] = x.split(\"=\");\n    return { key, value };\n  });\n\n  const all = keyValueObjectArray?.reduce((object, keyValue) => {\n    // NB: if that key already exists, let's make it an array and add this new value\n    if (object[keyValue.key]) {\n      object[keyValue.key] = [\n        ...makeArray(object[keyValue.key]),\n        keyValue.value,\n      ];\n      return object;\n    }\n    // Otherwise, just add the new key/value to the object.\n    return { ...object, [keyValue.key]: keyValue.value };\n  }, {} as QueryableObject);\n\n  return all;\n}"
  },
  "getFirstQueryStrings": {
    "name": "getFirstQueryStrings",
    "slug": "TsFunction",
    "id": "tkbrcomwgmpolfheqimpiobc",
    "description": "Query keys can be string or string[] or undefined.\n\nThis function takes only the first string if it's an array...",
    "operationName": "rest-util",
    "rawText": " (query: QueryableObject) => {\n  const queryStrings = Object.keys(query).map((key) => {\n    const value = query[key];\n    return Array.isArray(value) ? value[0] : value;\n  });\n\n  return queryStrings;\n}"
  },
  "getQueryPart": {
    "name": "getQueryPart",
    "slug": "TsFunction",
    "id": "nmyqswpuoogatbquiozcogrb",
    "description": "creates a query-string with one key for all strings in an array",
    "operationName": "rest-util",
    "rawText": " (strings: string[], queryKey: string) =>\n  strings.map((v) => `${queryKey}=${v}`).join(\"&\")"
  },
  "isValidEntry": {
    "name": "isValidEntry",
    "slug": "TsFunction",
    "id": "bplhgvdyixqdruaqlvvioxrs",
    "description": "",
    "operationName": "rest-util",
    "rawText": " ([_, value]: [key: string, value: any]) =>\n  value !== undefined && value !== \"\" && value !== null"
  },
  "toQueryString": {
    "name": "toQueryString",
    "slug": "TsFunction",
    "id": "eictyagtmziipoeqsmdcpedw",
    "description": "returns something like `?x=a&y=b&z=c`",
    "operationName": "rest-util",
    "rawText": " (query?: any) => {\n  const hasQuery =\n    query && Object.entries(query)?.filter(isValidEntry).length > 0;\n  return hasQuery\n    ? \"?\" +\n        Object.entries(query)\n          .filter(isValidEntry)\n          .map(([key, value]) => {\n            const encodedValue = encodeURIComponent(String(value));\n            return `${key}=${encodedValue}`;\n          })\n          .join(\"&\")\n    : \"\";\n}"
  },
  "[argument]": {
    "name": "[argument]",
    "slug": "TsVariable",
    "id": "wcmvbyherhkbmqqtogjpklfi",
    "description": "",
    "operationName": "run-child-process"
  },
  "runChildProcess": {
    "name": "runChildProcess",
    "slug": "TsFunction",
    "id": "tzcpzdhfwnsthelokwybwvns",
    "description": "spawns a child process and returns its output after it's done",
    "operationName": "run-child-process",
    "rawText": " async (config: {\n  operationFolderName: string;\n  /**\n   * the location of the script in the build folder\n   * NB: this must be a CLI that that actually executes the function!\n   */\n  scriptFileName: string;\n  /**\n   * all arguments you wish to pass to the script. If an argument is undefined, it will not be passed. Arguments to be passed must be strings\n   */\n  args?: (string | undefined)[];\n}) => {\n  const { operationFolderName, scriptFileName, args } = config;\n\n  const childOperationPath = await getOperationPath(operationFolderName);\n  if (!childOperationPath) {\n    log(\n      `Couldn't find childOperationPath for operation ${operationFolderName}`,\n      { type: \"error\" }\n    );\n    return;\n  }\n  const scriptPath = path.join(\n    childOperationPath,\n    `build/${scriptFileName}.js`\n  );\n\n  if (!fs.existsSync(scriptPath)) {\n    log(\n      `Couldn't find scriptFile ${scriptFileName} which should be at build/${scriptFileName}.js`,\n      { type: \"error\" }\n    );\n    return;\n  }\n\n  const readable = await canRead(scriptPath);\n\n  if (!readable) {\n    log(`Can't read ${scriptPath}`, { type: \"error\" });\n    return;\n  }\n\n  const command = `node ${scriptPath} ${\n    args?.filter(notEmpty).join(\" \") || \"\"\n  }`;\n\n  // log(`going to execute: ${command}`, { type: \"important\" });\n\n  const result = spawnSync(command, {\n    shell: true,\n    stdio: \"inherit\",\n    encoding: \"utf8\",\n  });\n\n  return result.output;\n}"
  },
  "sayDutch": {
    "name": "sayDutch",
    "slug": "TsFunction",
    "id": "ztgkpaxyvrislmjnanrpxchf",
    "description": "",
    "operationName": "say",
    "rawText": " (message: string) => {\n  spawnSync(`say \"${message}\" --voice Xander`, { shell: true });\n}"
  },
  "sayLanguage": {
    "name": "sayLanguage",
    "slug": "TsFunction",
    "id": "pomhakzdfgapzmxwnazybxal",
    "description": "",
    "operationName": "say",
    "rawText": " (message: string, language: SayLanguageEnum) => {\n  const voice =\n    language === \"np\" ? \"Lekha\" : language === \"nl\" ? \"Xander\" : \"Alex\";\n  spawnSync(`say \"${message}\" --voice ${voice}`, { shell: true });\n}"
  },
  "sayNepali": {
    "name": "sayNepali",
    "slug": "TsFunction",
    "id": "muadlzpjdmhivwigwcobbcax",
    "description": "",
    "operationName": "say",
    "rawText": " (message: string) => {\n  spawnSync(`say \"${message}\" --voice Lekha`, { shell: true });\n}"
  },
  "saySomething": {
    "name": "saySomething",
    "slug": "TsFunction",
    "id": "czorlrhvknvhphrqzzpvkbnh",
    "description": "TODO: do research what else is out there\n\nsay [-v voice] [-r rate] [-o outfile [aud\nio format options] | -n name:port | -a device] [-f f\nile | string ...]\n\nDESCRIPTION\nThis tool uses the Speech Synthesis manager\nto convert input text to audible speech and\neither play it through the sound output\ndevice chosen in System Preferences or save\nit to an AIFF file.\n\n\nfor usage, see `man say`",
    "operationName": "say",
    "rawText": " async (\n  input: string | SayOptions\n): Promise<void> => {\n  const paramKeys =\n    typeof input === \"string\"\n      ? null\n      : (Object.keys(input) as (keyof SayOptions)[]);\n\n  const params =\n    typeof input === \"string\"\n      ? null\n      : paramKeys?.reduce((all, key) => {\n          const value = input[key];\n\n          if (value === undefined) {\n            return all;\n          }\n\n          if (key === \"message\") {\n            return `${all} \"${value}\"`;\n          }\n\n          return `${all} --${shorthands[key]}=${String(value)}`;\n        }, \"\");\n\n  const spawnInput = typeof input === \"string\" ? input : (params as string);\n\n  const result = execSync(`say ${spawnInput}`, { stdio: \"inherit\" });\n\n  return;\n  // const res= spawn(`say ${spawnInput}`, {shell:true})\n  // res.\n}"
  },
  "shorthands": {
    "name": "shorthands",
    "slug": "TsVariable",
    "id": "rzyyzdhrltyijxnuxpzbktym",
    "description": "",
    "operationName": "say"
  },
  "textToMp3": {
    "name": "textToMp3",
    "slug": "TsFunction",
    "id": "jjyplivddfulpeoghajvkwzk",
    "description": "",
    "operationName": "say",
    "rawText": " async (\n  options: Omit<SayOptions, \"outputFilePath\">,\n  /**\n   * Absolute path to the mp3\n   */\n  absoluteOutputFilePath: string\n) => {\n  const parsed = path.parse(absoluteOutputFilePath);\n  const aiffPath = path.join(parsed.dir, `${parsed.name}.aiff`);\n  const finalOptions: SayOptions = { ...options, outputFilePath: aiffPath };\n\n  await saySomething(finalOptions);\n  const finalPath = await convertToMp3(aiffPath, absoluteOutputFilePath);\n\n  if (finalPath) {\n    await fs.rm(aiffPath);\n  }\n\n  return finalPath;\n}"
  },
  "findFirstCommentTypes": {
    "name": "findFirstCommentTypes",
    "slug": "TsFunction",
    "id": "vkpqkfvvqhdghvkrwcowkjrf",
    "description": "Tries to find tie first appearing special comment line and parses it and returns it as part of the `CommentTypeObject`",
    "operationName": "schema-util",
    "rawText": " (\n  strippedFullComment?: string\n): CommentTypeObject => {\n  if (strippedFullComment === undefined) return {};\n  const lines = strippedFullComment.split(\"\\n\");\n\n  const specialCommentTypesObject = commentTypes\n    .map((commentType) => {\n      const matchingPart = `${commentType.toUpperCase()}:`;\n      const matchingLine = lines.find((line) => {\n        const trimmedLine = line.trimStart();\n        const isMatch = trimmedLine.startsWith(matchingPart);\n        return isMatch;\n      });\n\n      if (!matchingLine) return;\n\n      const strippedMatchingLine = matchingLine.trimStart();\n      const specialCommentWithoutPrefix = strippedMatchingLine\n        .slice(matchingPart.length)\n        .trim();\n\n      return {\n        [commentType]: specialCommentWithoutPrefix,\n      };\n    })\n    .filter(notEmpty);\n\n  const fullObject = mergeObjectsArray(\n    specialCommentTypesObject\n  ) as CommentTypeObject;\n\n  return fullObject;\n}"
  },
  "getDataParameterNames": {
    "name": "getDataParameterNames",
    "slug": "TsFunction",
    "id": "hxlcygkyejbjoqolkihnsisx",
    "description": "Finds all the data parameter names that might be there on an item, based on the item object keys and the convention",
    "operationName": "schema-util",
    "rawText": " (\n  item: AugmentedAnyModelType\n): string[] => {\n  const dataParameterNames = Object.keys(item)\n    .map((key) => {\n      const { dataParameterName } = getReferenceParameterInfo(key);\n\n      return dataParameterName;\n    })\n    .filter(notEmpty);\n\n  return dataParameterNames;\n}"
  },
  "getPossibleReferenceParameterNames": {
    "name": "getPossibleReferenceParameterNames",
    "slug": "TsFunction",
    "id": "rovriyqwmbxgcwcjufzrtvlx",
    "description": "returns the reference parameterNames...\n\n\ne.g.:\n```\ntodos -> todoSlugs + todoIds\ntodo -> todoSlug + todoId\n```",
    "operationName": "schema-util",
    "rawText": " (\n  parameterName: string\n): string[] => {\n  const possibleReferenceParameterNames = isPlural(parameterName)\n    ? referencePluralParameterNames\n        .map(capitaliseFirstLetter)\n        .map((ref) => `${singularize(parameterName)}${ref}`)\n    : referenceParameterNames\n        .map(capitaliseFirstLetter)\n        .map((ref) => `${parameterName}${ref}`);\n\n  return possibleReferenceParameterNames;\n}"
  },
  "getProperties": {
    "name": "getProperties",
    "slug": "TsFunction",
    "id": "wnsvvywagzdlbihygnokpuzn",
    "description": "Gets all the properties of a schema",
    "operationName": "schema-util",
    "rawText": " (schema: Schema | undefined): SchemaProperty[] => {\n  if (!schema) return [];\n  const propertyKeys = schema.properties ? Object.keys(schema.properties) : [];\n  const properties = propertyKeys\n    .map((key) => {\n      const propertySchema = getSchema(schema.properties?.[key]);\n      return propertySchema\n        ? {\n            name: key,\n            schema: propertySchema,\n            required: schema.required?.includes(key) || false,\n          }\n        : null;\n    })\n    .filter(notEmpty);\n\n  return properties;\n}"
  },
  "getRefLink": {
    "name": "getRefLink",
    "slug": "TsFunction",
    "id": "qijmmlxmudjepzdegghlousp",
    "description": "gets the $ref from a schema and parses the interface name from it",
    "operationName": "schema-util",
    "rawText": " (ref?: string) => {\n  const refLink = ref\n    ?.split(\"/\")\n    .pop()\n    ?.replaceAll(\"%3C\", \"<\")\n    .replaceAll(\"%3E\", \">\");\n\n  return refLink;\n}"
  },
  "getReferencableModels": {
    "name": "getReferencableModels",
    "slug": "TsFunction",
    "id": "keqoqndcbgfxyjtotnezajcv",
    "description": "based on the object properties in SimplifiedSchema, returns the model names that can be referenced",
    "operationName": "schema-util",
    "rawText": " (\n  simplifiedSchema?: SimplifiedSchema\n): ReferenceParameterInfo[] | undefined => {\n  if (simplifiedSchema?.type !== \"object\") return undefined;\n  const parameterNames = simplifiedSchema.properties?.map((x) => x.name);\n\n  const referenceParameterInfo = parameterNames\n    ?.map((parameterName) => {\n      const referenceParameterInfo = getReferenceParameterInfo(parameterName);\n\n      return referenceParameterInfo;\n    })\n    .filter((x) => x.isReferenceParameter);\n\n  return referenceParameterInfo;\n}"
  },
  "getReferenceParameterInfo": {
    "name": "getReferenceParameterInfo",
    "slug": "TsFunction",
    "id": "eqfawrbxcwcvxprewxwqwegl",
    "description": "Takes a parameterName and returns information about it according to the convention `{descriptorName}_{modelName}{referenceKey}` where:\n\n- descriptorName with the suffixing underscore is optional\n- referenceKey can be slug, index, or id (or there plural variants)\n- modelName should refer to a database model",
    "operationName": "schema-util",
    "rawText": " (\n  parameterName: string\n): ReferenceParameterInfo => {\n  const descriptorModelSplit = parameterName.split(\"_\");\n  const descriptor = parameterName.includes(\"_\")\n    ? descriptorModelSplit[0]\n    : undefined;\n  const rest = parameterName.includes(\"_\")\n    ? descriptorModelSplit[1]\n    : parameterName;\n\n  const wordArray = lowerCaseArray(rest);\n\n  const singleWord = wordArray.length === 1;\n\n  const parameterLastWord = wordArray.pop()!;\n\n  const isReferenceSingleParameter =\n    !singleWord && referenceParameterNames.includes(parameterLastWord);\n  const isReferenceMultipleParameter =\n    !singleWord && referencePluralParameterNames.includes(parameterLastWord);\n\n  const isReferenceParameter =\n    isReferenceSingleParameter || isReferenceMultipleParameter;\n\n  // NB: the last item has been removed now\n  const interfaceName = isReferenceParameter\n    ? pascalCase(wordArray.join(\"-\"))\n    : undefined;\n\n  // slug or id\n  const keyInModel = isReferenceParameter\n    ? singularize(parameterLastWord)\n    : undefined;\n\n  /**\n   * the reference keyword should be removed from the parameterName to receive the dataParameterName\n   *\n   * e.g. `weirdSluggyModelSlugs` becomes `weirdSluggyModels`\n   */\n  const dataParameterName =\n    isReferenceParameter && keyInModel\n      ? replaceLastOccurence(\n          parameterName,\n          capitaliseFirstLetter(keyInModel),\n          \"\"\n        )\n      : undefined;\n\n  const referenceParameterInfo: ReferenceParameterInfo = {\n    descriptor,\n    keyInModel,\n    interfaceName,\n    isReferenceMultipleParameter,\n    isReferenceSingleParameter,\n    isReferenceParameter,\n    dataParameterName,\n    parameterName,\n  };\n\n  return referenceParameterInfo;\n}"
  },
  "getSchemaItems": {
    "name": "getSchemaItems",
    "slug": "TsFunction",
    "id": "lukoanlohplbksavknbmrauw",
    "description": "==========\n\nSince `JSONSchema7`'s property `items` is fairly hard to use, this function gets that property in an easier to use way.",
    "operationName": "schema-util",
    "rawText": " (schema: Schema | undefined) => {\n  const schemas = makeArray(schema?.items).map(getSchema).filter(notEmpty);\n  return schemas;\n}"
  },
  "getSchema": {
    "name": "getSchema",
    "slug": "TsFunction",
    "id": "ttzzthdjqtmuzuoyhgjhwadi",
    "description": "parses a JSONSchema7Definition to JSONSchema7|undefined so we can use it",
    "operationName": "schema-util",
    "rawText": " (\n  maybeSchema: JSONSchema7Definition | undefined\n): Schema | undefined =>\n  typeof maybeSchema !== \"object\" ? undefined : maybeSchema"
  },
  "simplifiedSchemaToTypeDefinitionString": {
    "name": "simplifiedSchemaToTypeDefinitionString",
    "slug": "TsFunction",
    "id": "wjezjrfpdhffitrulppxfzex",
    "description": "Converts a simplifiedSchema definition back into a type interface string\n\nWith this, types can be generated in different ways",
    "operationName": "schema-util",
    "rawText": " (\n  simplifiedSchema?: SimplifiedSchema\n) => {\n  if (!simplifiedSchema) return \"\";\n\n  if (simplifiedSchema.enum && simplifiedSchema.enum.length > 0) {\n    // NB: TODO: This is probably not satisfactory for all enums! Needs testing\n    const enumString = simplifiedSchema.enum.map((x) => String(x)).join(\" | \");\n\n    return enumString;\n  }\n\n  if (simplifiedSchema.type === \"boolean\") return \"boolean\";\n  if (simplifiedSchema.type === \"null\") return \"null\";\n  if (simplifiedSchema.type === \"number\") return \"number\";\n  if (simplifiedSchema.type === \"string\") return \"string\";\n  if (\n    simplifiedSchema.type === \"array\" &&\n    simplifiedSchema.items &&\n    simplifiedSchema.items.length >= 1\n  ) {\n    const parts: string = simplifiedSchema.items\n      .map((x) => simplifiedSchemaToTypeDefinitionString(x.schema))\n      .join(\" | \");\n\n    const partsString: string =\n      simplifiedSchema.items && simplifiedSchema.items.length >= 2\n        ? `(${parts})[]`\n        : `${parts}[]`;\n\n    return partsString;\n  }\n\n  if (simplifiedSchema.type === \"object\" && simplifiedSchema.properties) {\n    const objectParts = simplifiedSchema.properties.map((prop) => {\n      const descriptionString = prop.schema.description\n        ? `/** ${prop.schema.description} */\\n`\n        : \"\";\n      const punctuationString = `${prop.required ? \"\" : \"?\"}: `;\n      const propertyString: string = `${descriptionString}${\n        prop.name\n      }${punctuationString}${simplifiedSchemaToTypeDefinitionString(\n        prop.schema\n      )};`;\n\n      return propertyString;\n    });\n\n    const objectString = `{\\n${objectParts.join(\"\\n\")}\\n};\\n`;\n\n    return objectString;\n  }\n\n  // NB: Should never be the case, we have handled all types\n  return \"\";\n}"
  },
  "simplifySchema": {
    "name": "simplifySchema",
    "slug": "TsFunction",
    "id": "eniwteltbjqfxsqzbjbwjecr",
    "description": "Return a SimplifiedSchema by giving the JSONSchema7 schema, its name and a list of possible references in the JSONSchema.\n\nA SimplifiedSchema is a data structure that allows you to easily define type interfaces that need to build out forms.\n\n# Todo\n\nDual types aren't done right yet. I probably don't look at `anyOf` yet, which makes it result in an empty object.\n\nFor example, this one is problematic:\n\nINPUT:\n\n```json\n{\n\"schema\": {\n\"anyOf\": [\n{\"type\": \"string\"},\n{\"type\": \"array\",\"items\": {\"type\": \"string\"}}\n]\n},\n```\n\nOutput:\n```json\n{\n\"simplifiedSchema\": {\n\"properties\": [],\n\"type\": \"object\"\n},\n}\n```\n\nTo test this one, test `npx rebuildOperation filename-conventions`",
    "operationName": "schema-util",
    "rawText": " (\n  /** The name of the type interface, (this could be used as $ref). */\n  name: string | null,\n\n  /** The schema that needs to be simplified */\n  schema: JSONSchema7,\n\n  /** The array of other schemas found when crawling file this schema was found in. this also includes all refs to other type interfaces in all schemas in that file */\n  possibleRefs: {\n    /** the name of the schema, (without /definitions/ prefix like $ref) */\n    name: string;\n    schema: JSONSchema7;\n  }[],\n  /**\n   * This function is recursive. If we find any reference to another schema, we will add the name of the current schema to the rootStack and explore that schema.\n   */\n  rootStack: string[]\n): SimplifiedSchema | undefined => {\n  if (Array.isArray(schema.type)) {\n    // let's do this one later\n    log(\n      `I don't support this usecase (type is an array of multiple types)... ${schema.type.join(\n        \",\"\n      )}`,\n      {\n        type: \"debug\",\n      }\n    );\n  }\n  const type = Array.isArray(schema.type) ? schema.type[0] : schema.type;\n  const newRootStack = name ? rootStack.concat(name) : rootStack;\n  const refName = getRefLink(schema.$ref);\n\n  // NB: we already encountered this ref before, let's avoid infinite recursion here.\n\n  const isCircularRef = !!refName && rootStack.includes(refName);\n\n  if (refName && !isCircularRef) {\n    const refSchema = possibleRefs.find((r) => r.name === refName);\n    if (!refSchema) {\n      log(`ref not present: ${refName}`, { type: \"warning\" });\n      // log(\"Strange, ref was not present in the possible refs\", {\n      //   type: \"debug\",\n      // });\n\n      // console.log({\n      //   possibleRefNames: possibleRefs.map((x) => x.name),\n      //   refName,\n      // });\n    }\n\n    const thisDescription = schema.description\n      ? `${schema.description}\\n\\n`\n      : \"\";\n    const mergedSchema = refSchema?.schema\n      ? {\n          ...refSchema.schema,\n          description: `${thisDescription}${\n            refSchema.schema.description || \"\"\n          }`,\n        }\n      : undefined;\n\n    return mergedSchema\n      ? simplifySchema(refName, mergedSchema, possibleRefs, newRootStack)\n      : undefined;\n  }\n\n  const fullComment = schema.description;\n\n  const commentTypeObject = findFirstCommentTypes(fullComment);\n  // TODO: Add all other `CommentType`s as properties\n  const simplifiedPrimitive = {\n    enum: schema.enum,\n    circularRefName: refName,\n    fullComment,\n    ...commentTypeObject,\n  };\n\n  if (type === \"boolean\") {\n    return { ...simplifiedPrimitive, type: \"boolean\" };\n  }\n\n  if (type === \"integer\" || type === \"number\") {\n    // NB: integers are also numbers\n    return { ...simplifiedPrimitive, type: \"number\" };\n  }\n\n  if (type === \"null\") {\n    return { ...simplifiedPrimitive, type: \"null\" };\n  }\n\n  if (type === \"string\") {\n    return { ...simplifiedPrimitive, type: \"string\" };\n  }\n\n  if (type === \"array\") {\n    const items = getSchemaItems(schema);\n\n    const simplifiedItems: SimplifiedSchemaItem[] = items\n      .map((item) => {\n        const itemName = getRefLink(item.$ref) || null;\n        const schema = simplifySchema(\n          itemName,\n          item,\n          possibleRefs,\n          name ? rootStack.concat(name) : rootStack\n        );\n        if (!schema) return;\n        return {\n          schema,\n          name: itemName,\n        };\n      })\n      .filter(notEmpty);\n\n    return {\n      ...simplifiedPrimitive,\n      items: simplifiedItems,\n      type: \"array\",\n    };\n  }\n\n  // NB: type must be an object here, it's the only possibility left...\n  // in case of objects\n\n  const properties = getProperties(schema);\n\n  const simplifiedProperties: SimplifiedSchemaProperty[] = properties\n    .map((property) => {\n      const schema = simplifySchema(\n        property.name,\n        property.schema,\n        possibleRefs,\n        newRootStack\n      );\n\n      if (!schema) return;\n\n      const possibleReferenceParameterNames =\n        getPossibleReferenceParameterNames(property.name);\n\n      const hasReferenceParameter = !!properties.find((x) =>\n        possibleReferenceParameterNames.includes(x.name)\n      );\n\n      // NB: if the property has a model reference, we just need the model reference, not the whole model. This is only for retreiving, it's not present in the database.\n      if (hasReferenceParameter) return;\n\n      return {\n        name: property.name,\n        required: property.required,\n        schema,\n      };\n    })\n    .filter(notEmpty);\n\n  return {\n    ...simplifiedPrimitive,\n    properties: simplifiedProperties,\n    type: \"object\",\n  };\n}"
  },
  "example": {
    "name": "example",
    "slug": "TsVariable",
    "id": "qidtmencvmxdwydwtaqoubwo",
    "description": "",
    "operationName": "search"
  },
  "findSentenceMatches": {
    "name": "findSentenceMatches",
    "slug": "TsFunction",
    "id": "fipmrfxwfnxnhmjhknwtphaa",
    "description": "finds matches of a searchMessage in an array, looking at the individual words.\n\nif your search matches some words in a sentence, it's a match, as long as all your words you entered are also a word in the sentence\n\nNB: this could be augmented with things like synonyms and translation",
    "operationName": "search",
    "rawText": " <T>(\n  /**\n   * a message the user is searching for\n   */\n  searchMessage: string,\n  /**\n   * an array that should be filtered.\n   */\n  array: T[],\n  /**\n   * optionally, if the array doesn't contain strings of sentences already, you can provide a map function here that returns a sentence from an item in that array\n   */\n  getSentence?: (x: T) => string\n): T[] => {\n  const messageWords = lowerCaseArray(searchMessage);\n\n  const matches = array.filter((item) => {\n    const sentence = getSentence\n      ? getSentence(item)\n      : typeof item === \"string\"\n      ? item\n      : null;\n    if (!sentence) return false;\n\n    const sentenceWords = lowerCaseArray(sentence);\n    const sentenceIncludesMessage = messageWords.reduce(\n      (includesAll, messageWord) => {\n        // TODO: later we can use synonyms here\n        return includesAll && sentenceWords.includes(messageWord);\n      },\n      true\n    );\n\n    return sentenceIncludesMessage;\n  });\n\n  return matches;\n}"
  },
  "magicalRecursiveReducer": {
    "name": "magicalRecursiveReducer",
    "slug": "TsFunction",
    "id": "jdagegacgwshpeyygpqrckwd",
    "description": "Reduces an object with children of its own type according to a baseMatcher.\n\nThe object only gets returned if the children have a match (or their children, etc) or if the object itself is a match. If the object itself is a match, its children will also be edited to filter out non-matching things\n\nNB: Not finished yet (see todo).\n\nAlso not sure if the final UX is really as great and performant as I wish, so it may be easier to simply have a separate search for files and global (just like vscode has)",
    "operationName": "search",
    "rawText": " <T extends { children?: T[] } & Object>(\n  previous: T[],\n  current: T,\n  baseMatcher: (item: T) => boolean\n): T[] => {\n  // NB: copy!\n  const newCurrent = { ...current };\n\n  newCurrent.children = newCurrent.children\n    ? newCurrent.children.reduce(\n        (p, c) => magicalRecursiveReducer(p, c, baseMatcher),\n        [] as T[]\n      )\n    : undefined;\n\n  if (baseMatcher(newCurrent) || newCurrent.children?.length) {\n    previous.push(newCurrent);\n  }\n\n  return previous;\n}"
  },
  "searchRecursiveObjectArray": {
    "name": "searchRecursiveObjectArray",
    "slug": "TsFunction",
    "id": "dsocsicrchkhsxkzwortyffr",
    "description": "",
    "operationName": "search",
    "rawText": " <\n  T extends { children?: T[] } & Object\n>(\n  array: T[],\n  baseMatcher: (item: T) => boolean,\n  /**\n   * optionally, item can be mapped to add some info after match is found or not\n   */\n  afterMapper?: (item: T, isMatch: boolean, hasChildMatch: boolean) => T\n) => {\n  return array.reduce(\n    (previous, current) =>\n      magicalRecursiveReducer(previous, current, baseMatcher),\n    [] as T[]\n  );\n}"
  },
  "apiUrl": {
    "name": "apiUrl",
    "slug": "TsVariable",
    "id": "glbuxovrxcthpijcjggrtkuj",
    "description": "",
    "operationName": "server-api-url"
  },
  "customApiUrl": {
    "name": "customApiUrl",
    "slug": "TsVariable",
    "id": "riozyfswwuzwjtintkrvvmle",
    "description": "",
    "operationName": "server-api-url"
  },
  "hostname": {
    "name": "hostname",
    "slug": "TsVariable",
    "id": "dhzicmfwuppptzuwybtzwlwi",
    "description": "",
    "operationName": "server-api-url"
  },
  "isDev": {
    "name": "isDev",
    "slug": "TsVariable",
    "id": "jhrukevszpqbimhnlgvuwhzf",
    "description": "",
    "operationName": "server-api-url"
  },
  "localhostServer": {
    "name": "localhostServer",
    "slug": "TsVariable",
    "id": "mrpsmuahorecpgnkpzqgdosd",
    "description": "",
    "operationName": "server-api-url"
  },
  "realCustomApiUrl": {
    "name": "realCustomApiUrl",
    "slug": "TsVariable",
    "id": "tdhlmjomkxrwwyfhidnpjzzi",
    "description": "",
    "operationName": "server-api-url"
  },
  "remoteServer": {
    "name": "remoteServer",
    "slug": "TsVariable",
    "id": "lhnbiltolfixiieshvgqeagt",
    "description": "NEEDED FOR MULTI DEPLOYMENTS (passionfruit)",
    "operationName": "server-api-url"
  },
  "runRemoteServer": {
    "name": "runRemoteServer",
    "slug": "TsVariable",
    "id": "ziazqduznhbmighwpxzrlaec",
    "description": "",
    "operationName": "server-api-url"
  },
  "addAuthenticationMethod": {
    "name": "addAuthenticationMethod",
    "slug": "TsFunction",
    "id": "hgtuggzojotbhrlrjztsngrq",
    "description": "sends an email or sms, or already confirms in case of emailPassword\n\ncore function for `addPersonAuthenticationMethod` and `addDeviceAuthenticatedMethod`",
    "operationName": "server-login",
    "rawText": " async (\n  method: AuthenticationMethodMethod,\n  handle: string,\n  /**\n   * TODO: check if it's unique before sending an email.\n   * This is needed in case you are a person trying to add a method, because then there might be another person with the same handle.\n   */\n  shouldBeUnique?: boolean,\n  credential?: string\n): Promise<{\n  isSuccessful: boolean;\n  message: string;\n  authenticationMethod?: AuthenticationMethod;\n}> => {\n  if (method === \"email\") {\n    // send email to `handle`\n\n    if (!isEmail(handle)) {\n      return {\n        isSuccessful: false,\n        message: \"Please provide a correct email\",\n      };\n    }\n\n    if (shouldBeUnique) {\n      const isAuthenticationMethodUnavaiable =\n        await findAuthenticatedPersonWithHandle(method, handle);\n      if (isAuthenticationMethodUnavaiable) {\n        console.log({ isAuthenticationMethodUnavaiable });\n        return {\n          isSuccessful: false,\n          message: \"That email is already taken\",\n        };\n      }\n    }\n\n    const otp = Math.round(100000 + Math.random() * 900000);\n\n    const text = `Please verify your email with this code: ${otp}. You have 10 minutes.`;\n\n    const authenticationMethod: AuthenticationMethod = {\n      method: \"email\",\n      handle,\n      isAuthenticated: false,\n      otp,\n    };\n\n    const mailResult = await sendMail({\n      to: handle,\n      subject: \"Verify your email\",\n      text,\n    });\n\n    if (!mailResult) {\n      return { isSuccessful: false, message: \"Couldn't send email\" };\n    }\n\n    return {\n      isSuccessful: true,\n      message: \"Code sent, please verify.\",\n      authenticationMethod,\n    };\n  }\n\n  if (method === \"phoneNumber\") {\n    // send sms to `handle`\n\n    if (!isPhoneNumber(handle)) {\n      return {\n        isSuccessful: false,\n        message: \"Please provide a correct phone number\",\n      };\n    }\n\n    if (shouldBeUnique) {\n      const isAuthenticationMethodUnavaiablePerson =\n        await findAuthenticatedPersonWithHandle(method, handle);\n      if (isAuthenticationMethodUnavaiablePerson) {\n        console.log({ isAuthenticationMethodUnavaiablePerson });\n        return {\n          isSuccessful: false,\n          message: \"That phone number is already taken\",\n        };\n      }\n    }\n\n    const otp = Math.round(100000 + Math.random() * 900000);\n    const body = `Please verify your phone number with this code: ${otp}. You have 10 minutes.`;\n\n    const authenticationMethod: AuthenticationMethod = {\n      method: \"phoneNumber\",\n      handle,\n      isAuthenticated: false,\n      otp,\n    };\n\n    const smsResult = await sendSms({ to: handle, body });\n\n    if (!smsResult) {\n      return { isSuccessful: false, message: \"Couldn't send sms\" };\n    }\n\n    return {\n      isSuccessful: true,\n      message: \"Code sent, please verify.\",\n      authenticationMethod,\n    };\n  }\n\n  if (method === \"usernamePassword\") {\n    // add username and password to the authenticated methods\n\n    if (!credential || !isValidPassword(credential)) {\n      return {\n        isSuccessful: false,\n        message: \"Please provide a valid password\",\n      };\n    }\n\n    const encryptedCredential = encryptPassword(credential);\n\n    const authenticationMethod: AuthenticationMethod = {\n      method: \"usernamePassword\",\n      handle,\n      encryptedCredential,\n      credential,\n      isAuthenticated: true,\n    };\n\n    return {\n      isSuccessful: true,\n      message: \"Username/password has been set.\",\n      authenticationMethod,\n    };\n  }\n\n  return { isSuccessful: false, message: \"method not implemented yet\" };\n}"
  },
  "addDeviceAuthenticationMethodConfirm": {
    "name": "addDeviceAuthenticationMethodConfirm",
    "slug": "TsFunction",
    "id": "zxdcgqxewzkyusdfuigocxpc",
    "description": "adds an `authenticatedMethod` to `Device` after the OTP is correct\n\nFor now, only handles methods `phoneNumber` and `email`\n\nTODO: extrahere the core into `addAuthenticationMethodConfirm` and use it in this one and make also `addPersonAuthenticationMethodConfirm`",
    "operationName": "server-login",
    "rawText": " async (\n  /** device id */\n  deviceId: string,\n  method: AuthenticationMethodMethod,\n  /** one time password */\n  otp: number\n) => {\n  /////\n\n  const device = (await db.get(\"Device\")).find((x) => x.id === deviceId);\n\n  if (!device) {\n    return { isSuccessful: false, message: \"Couldn't find device\" };\n  }\n\n  const authenticatedMethod = device.authenticationMethods.find(\n    (m) => m.method === method\n  );\n\n  if (authenticatedMethod?.isAuthenticated) {\n    return {\n      isSuccessful: false,\n      message:\n        \"You already authenticated with this method, please delete it first before you add another one.\",\n    };\n  }\n\n  if (!authenticatedMethod) {\n    return { isSuccessful: false, message: \"Can't find method\" };\n  }\n\n  if ([\"email\", \"phoneNumber\"].includes(method)) {\n    const isSuccessful = otp === authenticatedMethod.otp;\n\n    if (isSuccessful) {\n      // add isAuthenticated to device's authenticationMethods\n\n      const newAuthenticatedMethod: AuthenticationMethod = {\n        ...authenticatedMethod,\n        otp: undefined,\n        isAuthenticated: true,\n      };\n\n      const newauthenticationMethods = device.authenticationMethods.map((x) =>\n        x.method === method && x.otp === otp ? newAuthenticatedMethod : x\n      );\n\n      const dbPath = getRootPath(\"db\")!;\n      const devicePath = path.join(dbPath, \"devices\", `${deviceId}.json`);\n\n      writeJsonToFile(devicePath, {\n        ...device,\n        authenticationMethods: newauthenticationMethods,\n      });\n    }\n    return {\n      isSuccessful,\n      message: isSuccessful ? \"Successful\" : \"Incorrect code\",\n    };\n  }\n}"
  },
  "addDeviceAuthenticationMethodWithContext": {
    "name": "addDeviceAuthenticationMethodWithContext",
    "slug": "TsFunction",
    "id": "xptdfeiyciddcjhwzkurqihb",
    "description": "returns new function context with added authenticationmethod",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext,\n  method: AuthenticationMethodMethod,\n  handle: string,\n  credential?: string\n): Promise<{\n  isSuccessful?: boolean;\n  message?: string;\n  functionContext?: FunctionContext;\n  authenticationMethod?: AuthenticationMethod;\n}> => {\n  const { isSuccessful, message, authenticationMethod } =\n    await addAuthenticationMethod(method, handle, false, credential);\n  if (!isSuccessful || !authenticationMethod) {\n    return { isSuccessful, message };\n  }\n  // removes this method if you was alrady trying the same method (basically overwrite)\n  const cleanAuthenticationMethods =\n    functionContext.device.authenticationMethods?.filter(\n      (x) => x.method !== authenticationMethod.method\n    ) || [];\n\n  // then adds the new one\n  const newAuthenticationMethods =\n    cleanAuthenticationMethods.concat(authenticationMethod);\n\n  const updateResult = await db.update(\n    \"Device\",\n    (item) => item.authToken === functionContext.authToken,\n    (old) => {\n      return {\n        ...old,\n        authenticationMethods: newAuthenticationMethods,\n      };\n    }\n  );\n\n  const newFunctionContext = mergeNestedObject(functionContext, {\n    device: {\n      authenticationMethods: newAuthenticationMethods,\n    },\n  });\n\n  return {\n    isSuccessful: updateResult.isSuccesful,\n    message: \"Method added\",\n    functionContext: newFunctionContext,\n    authenticationMethod,\n  };\n}"
  },
  "addPersonAuthenticationMethodWithContext": {
    "name": "addPersonAuthenticationMethodWithContext",
    "slug": "TsFunction",
    "id": "rffbyjpkdtdfmvfqbnsepnej",
    "description": "",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext,\n  method: AuthenticationMethodMethod,\n  handle: AuthenticationMethod[\"handle\"],\n  credential?: string\n) => {\n  const { isSuccessful, message, authenticationMethod } =\n    await addAuthenticationMethod(method, handle, true, credential);\n\n  if (!isSuccessful || !authenticationMethod) {\n    return { isSuccessful, message };\n  }\n\n  const updateResult = await db.update(\n    \"Person\",\n    (item) => item.id === functionContext.device.currentPersonId,\n    (old) => ({\n      ...old,\n      authenticationMethods:\n        old.authenticationMethods.concat(authenticationMethod),\n    })\n  );\n\n  return { isSuccessful: updateResult.isSuccesful, message };\n}"
  },
  "findAuthenticatedPersonWithHandle": {
    "name": "findAuthenticatedPersonWithHandle",
    "slug": "TsFunction",
    "id": "vqqkvoplkaxjfkhsvxuqcwof",
    "description": "Check if the handle is already taken by some person in the system",
    "operationName": "server-login",
    "rawText": " async (\n  method: AuthenticationMethodMethod,\n  handle: string\n) => {\n  const persons = await db.get(\"Person\");\n  const alreadyPerson = persons.find((person) => {\n    const matchingAuthMethod = person.authenticationMethods.find(\n      (authMethod) =>\n        authMethod.method === method &&\n        authMethod.isAuthenticated &&\n        authMethod.handle === handle\n    );\n\n    return !!matchingAuthMethod;\n  });\n  return alreadyPerson;\n}"
  },
  "findLoggedinPersonsWithContext": {
    "name": "findLoggedinPersonsWithContext",
    "slug": "TsFunction",
    "id": "lvndchsaodnyzvlepvppkdsr",
    "description": "This finds all persons you should be logged in as according to all your device's Authentication Methods.\n\nDoes not update your device to add the found persons.",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext\n): Promise<{\n  isSuccessful: boolean;\n  persons?: Person[];\n  message: string;\n}> => {\n  const { device } = functionContext;\n\n  if (!device) {\n    return {\n      isSuccessful: false,\n      message: \"Couldn't find that device\",\n    };\n  }\n\n  const allPersons = await db.get(\"Person\");\n\n  // NB: probably need to extrahere this part so I can use it to view the authentication status while logging in...\n\n  const persons = allPersons.filter((person) => {\n    const matchingMethods = person.authenticationMethods.filter(\n      (authenticationMethod) => {\n        // NB: finds the method with the same handle and credential\n        const matchingMethod = device.authenticationMethods.find((method) => {\n          const sameMethod = method.method === authenticationMethod.method;\n\n          const sameHandle =\n            method.handle.toLowerCase() ===\n            authenticationMethod.handle.toLowerCase();\n\n          const isCredentialCorrect =\n            method.credential &&\n            authenticationMethod.encryptedCredential &&\n            comparePassword(\n              method.credential,\n              authenticationMethod.encryptedCredential\n            );\n\n          return sameMethod && sameHandle && isCredentialCorrect;\n        });\n\n        return !!matchingMethod;\n      }\n    );\n\n    const hasEnoughMethods =\n      (person.amountAuthenticationMethodsRequired || 1) <=\n      matchingMethods.length;\n\n    const hasMissingMethod = !!person.requiredAuthenticationMethods?.find(\n      (method) => {\n        const isMethodMissing = !device.authenticationMethods.find(\n          (x) => x.method === method\n        );\n        return isMethodMissing;\n      }\n    );\n\n    if (hasEnoughMethods && !hasMissingMethod) {\n      // if you have authenticated with enough methods, and aren't missing a method\n      return true;\n    }\n\n    return false;\n  });\n\n  if (!persons || persons.length === 0) {\n    console.log({ methods: device.authenticationMethods });\n    return {\n      isSuccessful: false,\n      message: \"Couldn't find anyone with those credentials\",\n    };\n  }\n\n  return { isSuccessful: true, persons, message: \"Found the persons\" };\n}"
  },
  "getMeWithContext": {
    "name": "getMeWithContext",
    "slug": "TsFunction",
    "id": "lcnbootnojruwfijpuehqlfx",
    "description": "Get all relevant information about yourself, including all persons that are attached to you.\n\nNB: probably need to omit some fields later, but for now it's fine",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext\n): Promise<{\n  authorizations?: Authorization[] | undefined;\n  device: Storing<Device>;\n  groups?: Group[] | undefined;\n}> => {\n  const {\n    tsFunction,\n    serverContext,\n    hasAuthorization,\n    authToken,\n    ...userInfo\n  } = functionContext;\n\n  return userInfo;\n}"
  },
  "getPublicPerson": {
    "name": "getPublicPerson",
    "slug": "TsFunction",
    "id": "jzrulifzqkenlxbmbikwpurh",
    "description": "",
    "operationName": "server-login",
    "rawText": " async (id?: string) => {\n  return (await getPublicPersons()).find((x) => x.id === id);\n}"
  },
  "getPublicPersons": {
    "name": "getPublicPersons",
    "slug": "TsFunction",
    "id": "zejukdhodpdhniordkvkkxyk",
    "description": "",
    "operationName": "server-login",
    "rawText": " async () => {\n  const publicPersons = (await db.get(\"Person\")).map(\n    (item) => getSubsetFromObject(item, publicPersonKeys) as PublicPerson\n  );\n  return publicPersons;\n}"
  },
  "isPhoneNumber": {
    "name": "isPhoneNumber",
    "slug": "TsFunction",
    "id": "kfubumzaoqhldntcrwssarkl",
    "description": "TODO: Implement this",
    "operationName": "server-login",
    "rawText": " (phoneNumber: string): boolean => {\n  return true;\n}"
  },
  "isValidPassword": {
    "name": "isValidPassword",
    "slug": "TsFunction",
    "id": "wschoqjbtfkhjodfwcfxynwg",
    "description": "",
    "operationName": "server-login",
    "rawText": " (password: string): boolean => {\n  return password.length >= 6;\n}"
  },
  "loginWithContext": {
    "name": "loginWithContext",
    "slug": "TsFunction",
    "id": "tbnuopnooulyrpchyqsmjqby",
    "description": "attaches the `Device` with `authToken` to a `Person` once all required authenticationMethods are provided. If not, it needs to return the required authenticationMethods so the user can attach those to the device until loggin is successful.",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext\n): Promise<{ isSuccessful: boolean; message: string }> => {\n  const { device } = functionContext;\n\n  const findPersonsResult = await findLoggedinPersonsWithContext(\n    functionContext\n  );\n\n  if (!findPersonsResult.isSuccessful) {\n    return {\n      isSuccessful: findPersonsResult.isSuccessful,\n      message: findPersonsResult.message,\n    };\n  }\n\n  const personIds = findPersonsResult.persons?.map((x) => x.id);\n\n  const updateResult = await db.update(\n    \"Device\",\n    (item) => item.id === device.id,\n    (old) => ({\n      ...old,\n      personIds,\n      authenticationMethods: [],\n      currentPersonId: personIds?.[0],\n    })\n  );\n\n  const isSuccessful = updateResult.isSuccesful || false;\n\n  return {\n    isSuccessful,\n    message: isSuccessful\n      ? \"Logged in\"\n      : updateResult.message || \"Something went wrong (weird)\",\n  };\n}"
  },
  "loginWithPasswordWithContext": {
    "name": "loginWithPasswordWithContext",
    "slug": "TsFunction",
    "id": "voflmfvzcplqjxpidhhqkwla",
    "description": "Login with username and password\n\n1. Adds an username/password combo as auth-method to the device,\n2. Checks the persons to match the auth\n3. In case of match, moves the method to the person and connects the device",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext,\n  username: string,\n  password: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  // first we have to add the authenticationMethod to the device\n  const addAuthResult = await addDeviceAuthenticationMethodWithContext(\n    functionContext,\n    \"usernamePassword\",\n    username,\n    password\n  );\n\n  if (\n    !addAuthResult.isSuccessful ||\n    !addAuthResult.authenticationMethod ||\n    !addAuthResult.functionContext\n  ) {\n    return {\n      isSuccessful: addAuthResult.isSuccessful || false,\n      message: addAuthResult.message,\n    };\n  }\n\n  // now it should be possible to connect the auth method to the device\n  const loginResult = await loginWithContext(addAuthResult.functionContext);\n  const { isSuccessful, message } = loginResult;\n  return {\n    isSuccessful,\n    message,\n  };\n}"
  },
  "logoutWithContext": {
    "name": "logoutWithContext",
    "slug": "TsFunction",
    "id": "nxlpfqwfkgpoutuxfpvpezyq",
    "description": "Uses cookies (https://serverjs.io/documentation/reply/#cookie-) to logout\n\nNeeded for having `authToken` with GET as well in a safe manner (e.g. for images)",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext,\n  rememberAuthentication?: boolean\n) => {\n  const { device } = functionContext;\n\n  if (!device.personIds || !device.currentPersonId) {\n    return { isSuccessful: false, message: \"You were already logged out\" };\n  }\n\n  const personAuthenticationMethods =\n    device.currentPersonCalculated?.authenticationMethods || [];\n\n  const newPersonIds = device.personIds.filter(\n    (id) => id !== device.currentPersonId\n  );\n\n  if (newPersonIds.length === device.personIds.length) {\n    return {\n      isSuccessful: false,\n      message: \"Nobody logged out, this is strange...\",\n    };\n  }\n\n  // remove the person from the device, optionally moving the auth on the device again, so you can easily login again.\n\n  const updateResult = await db.update(\n    \"Device\",\n    (item) => item.id === device.id,\n    (old) => {\n      const newAuthenticationMethods = rememberAuthentication\n        ? old.authenticationMethods.concat(personAuthenticationMethods)\n        : old.authenticationMethods;\n      return {\n        ...old,\n        personIds: newPersonIds,\n        currentPersonId: newPersonIds[newPersonIds.length - 1],\n        authenticationMethods: newAuthenticationMethods,\n      };\n    }\n  );\n\n  const isSuccessful =\n    !!updateResult.isSuccesful && updateResult.amountUpdated === 1;\n\n  return {\n    isSuccessful,\n    message: isSuccessful\n      ? \"Logged out\"\n      : updateResult.message ||\n        \"Something went wrong (No updateResult message)\",\n  };\n}"
  },
  "removeDeviceAuthenticationMethodWithContext": {
    "name": "removeDeviceAuthenticationMethodWithContext",
    "slug": "TsFunction",
    "id": "zpzrtewcyxlofzuxzthtebko",
    "description": "removes an `authenticatedMethod` from `Device`\n\nUsually the authentication methods are an attempt to login into a new account, so if you remove something it doesnt have impact on the accounts you already logged into, because these authentications are not stored on the device but on the person.\n\nWe can therefore remove it without much validation",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext,\n  method: AuthenticationMethodMethod\n) => {\n  const newAuthenticationMethods =\n    functionContext.device.authenticationMethods.filter(\n      (x) => x.method !== method\n    );\n\n  const updateResult = await db.update(\n    \"Device\",\n    (item) => item.authToken === functionContext.authToken,\n    (old) => ({ ...old, authenticationMethods: newAuthenticationMethods })\n  );\n\n  return {\n    isSuccessful: updateResult.isSuccesful,\n    message: updateResult.isSuccesful ? \"Removed\" : updateResult.message,\n  };\n}"
  },
  "removePersonAuthenticationMethodWithContext": {
    "name": "removePersonAuthenticationMethodWithContext",
    "slug": "TsFunction",
    "id": "kpkgzjratrktjxgcdyfdhntn",
    "description": "removes an `authenticationMethod` from `Person` from currentPerson from authenticated device",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext,\n  method: AuthenticationMethodMethod\n) => {\n  if (\n    !functionContext.device.currentPersonId ||\n    !functionContext.device.persons\n  ) {\n    return {\n      isSuccessful: false,\n      message: \"Not logged in\",\n    };\n  }\n\n  const person = functionContext.device.persons.find(\n    (x) => x.id === functionContext.device.currentPersonId\n  );\n\n  if (!person) {\n    return {\n      isSuccessful: false,\n      message: \"Not logged in\",\n    };\n  }\n\n  const authenticationMethod = person.authenticationMethods.find(\n    (x) => x.method === method\n  );\n\n  if (!authenticationMethod) {\n    return { isSuccessful: false, message: \"You didn't add that method yet\" };\n  }\n\n  const newAuthenticationMethods = person.authenticationMethods.filter(\n    (x) => x.method !== method\n  );\n\n  const updateResult = await db.update(\n    \"Person\",\n    (item) => item.id === functionContext.device.currentPersonId,\n    (old) => ({ ...old, authenticationMethods: newAuthenticationMethods })\n  );\n\n  return {\n    isSuccessful: updateResult.isSuccesful,\n    message: updateResult.isSuccesful ? \"Removed\" : updateResult.message,\n  };\n}"
  },
  "signupWithContext": {
    "name": "signupWithContext",
    "slug": "TsFunction",
    "id": "gnexbzcdedqazczzsxufftmo",
    "description": "Creates a new `Person` for a `Device`. Adds that person to the `Device`.\n\n- Can only be done with at least one authenticationMethod\n- Can only be done if authentication is not applied on an existing person already.\n- Function is wrappable",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext,\n  /**\n   * Data required for creating a `Person`. Can be filled in by the user partly, but also partly automatically\n   */\n  personData: SignupPersonData\n): Promise<{ isSuccessful: boolean; message: string }> => {\n  const { device } = functionContext;\n\n  console.log(`Signup with context`);\n  if (\n    device.authenticationMethods.filter((x) => x.isAuthenticated).length === 0\n  ) {\n    return { isSuccessful: false, message: \"Please authenticate first\" };\n  }\n\n  const methodsAugmented = await Promise.all(\n    device.authenticationMethods.map(async (method) => {\n      const alreadyPerson = await findAuthenticatedPersonWithHandle(\n        method.method,\n        method.handle\n      );\n\n      return { ...method, alreadyPerson };\n    })\n  );\n\n  const unavailableMethod = methodsAugmented.find(\n    (method) => method.alreadyPerson\n  );\n\n  if (unavailableMethod) {\n    const methodString = englishMethod[unavailableMethod.method].toLowerCase();\n    return {\n      isSuccessful: false,\n      message: `There is already someone else with the ${methodString} ${unavailableMethod.handle}`,\n    };\n  }\n\n  // it seesms fine , lets' create a new person\n\n  const newPersonId = generateId();\n  const newPerson: Creation<Person> = {\n    id: newPersonId,\n    authenticationMethods: device.authenticationMethods.map(\n      // remove the credential\n      ({ credential, ...other }) => other\n    ),\n    ...personData,\n  };\n\n  //@ts-ignore\n  const upsertResult = await db.upsert(\"Person\", newPerson, {\n    onlyInsert: true,\n  });\n\n  if (!upsertResult.isSuccesful) {\n    return {\n      isSuccessful: false,\n      message: upsertResult.message || \"Upsert person not successful\",\n    };\n  }\n\n  const updateResult = await db.update(\n    \"Device\",\n    (item) => item.id === device.id,\n    (old) => {\n      console.log(\n        `set new person id to ${newPersonId}, remove authenticationMethods`\n      );\n      return {\n        ...old,\n        authenticationMethods: [],\n        personIds: old.personIds\n          ? old.personIds.concat(newPersonId)\n          : [newPersonId],\n        currentPersonId: newPersonId,\n      };\n    }\n  );\n\n  return {\n    isSuccessful: updateResult.isSuccesful || false,\n    message: updateResult.isSuccesful\n      ? \"Signed up\"\n      : updateResult.isSuccesful || \"Something went wrong, no mess\",\n  };\n}"
  },
  "signupWithPasswordWithContext": {
    "name": "signupWithPasswordWithContext",
    "slug": "TsFunction",
    "id": "vqjcwweglsfoptpsotewggat",
    "description": "For now only username/pass is supported due to direct verification\n\nThis function makes an authenticationmethod for the device and then signs up by creating a person for it and attaching it to the device.",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext,\n  fullName: string,\n  username: string,\n  pictureImage: BackendAsset | undefined,\n  password: string,\n  repeatPassword: string\n): Promise<{ isSuccessful: boolean; message: string }> => {\n  // processing is a oneliner for this type of functions!\n  pictureImage = await processAsset(pictureImage);\n\n  // only supported for now\n  const method: AuthenticationMethodMethod = \"usernamePassword\";\n\n  if (password !== repeatPassword) {\n    return { isSuccessful: false, message: \"Those passwords don't match\" };\n  }\n\n  const addDeviceAuthResult = await addDeviceAuthenticationMethodWithContext(\n    functionContext,\n    method,\n    username,\n    password\n  );\n\n  // console.log({ addDeviceAuthResult });\n  const {\n    functionContext: newFunctionContext,\n    authenticationMethod,\n    isSuccessful,\n    message,\n  } = addDeviceAuthResult;\n\n  if (!authenticationMethod?.isAuthenticated || !newFunctionContext) {\n    console.log(\"NOT AUTHENTICATED AFTER ADDING DEVICE\", {\n      authenticationMethod,\n      newFunctionContext,\n    });\n    return { isSuccessful: false, message: message || \"Strange\" };\n  }\n\n  const signupResult = await signupWithContext(newFunctionContext, {\n    name: fullName,\n    slug: slugify(fullName),\n    pictureImage,\n  });\n\n  return signupResult;\n}"
  },
  "switchCurrentPersonWithContext": {
    "name": "switchCurrentPersonWithContext",
    "slug": "TsFunction",
    "id": "bgqxrtifeawuwxfuvgggxnhi",
    "description": "",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext,\n  newCurentPersonId: string\n): Promise<{ isSuccessful: boolean; message: string }> => {\n  if (functionContext.device.currentPersonId === newCurentPersonId) {\n    return { isSuccessful: false, message: \"This account is already active\" };\n  }\n\n  const found = functionContext.device.personIds?.find(\n    (x) => x === newCurentPersonId\n  );\n\n  if (!found) {\n    return { isSuccessful: false, message: \"Can't find that account\" };\n  }\n\n  const { isSuccesful, message } = await db.update(\n    \"Device\",\n    (item) => item.id === functionContext.device.id,\n    (old) => ({ ...old, currentPersonId: newCurentPersonId })\n  );\n\n  return {\n    isSuccessful: isSuccesful || false,\n    message: isSuccesful\n      ? \"Switched\"\n      : message || \"Something went wrong (no message)\",\n  };\n}"
  },
  "updateMeWithContext": {
    "name": "updateMeWithContext",
    "slug": "TsFunction",
    "id": "djmarzodboinyzknzqmtzplz",
    "description": "",
    "operationName": "server-login",
    "rawText": " async (\n  functionContext: FunctionContext,\n  details: PersonProfileDetails\n): Promise<{ isSuccessful: boolean; message: string }> => {\n  const person = functionContext.device.currentPersonCalculated;\n\n  const processedAsset = await processAsset(details.pictureImage);\n\n  details.pictureImage = processedAsset;\n\n  if (!person) {\n    return {\n      isSuccessful: false,\n      message: \"Couldn't find you, are you logged in?\",\n    };\n  }\n\n  const { isSuccesful, message, amountUpdated } = await db.update(\n    \"Person\",\n    (item) => item.id === person.id,\n    (old) => ({ ...old, ...details })\n  );\n\n  const isReallySuccessful = (isSuccesful && amountUpdated === 1) || false;\n\n  return {\n    isSuccessful: isReallySuccessful,\n    message: isReallySuccessful\n      ? \"Updated your profile details\"\n      : message || \"Something went wrong (no message)\",\n  };\n}"
  },
  "setJsonKey": {
    "name": "setJsonKey",
    "slug": "TsFunction",
    "id": "kykbyodthtnpwrtzeydwgzdi",
    "description": "npx setjsonkey [json-path] key1.key2.[index/latest/push].key3 \"value\"\n\n\ncollect arguments 1 2 and 3\nfind file (arg1) in path, import json (or start with empty object in a new file)\nreduce keys (arg2) to go deeper into the object and create keys as they don't exist\nmake sure it works with arrays too\nconvert value string (arg3) to number, boolean if they seem to be like that",
    "operationName": "set-json-key",
    "rawText": " async ({\n  jsonPath,\n  keyLocation,\n  value,\n  debug,\n}: {\n  jsonPath: string;\n  keyLocation: string;\n  value: string;\n  debug?: boolean;\n}) => {\n  const usage =\n    'usage: npx setjsonkey [json-file-path] key1.key2.[index/latest/push].key3 \"value\" (Check https://github.com/Code-From-Anywhere/setjsonkey for more info)';\n\n  // VALIDATION\n\n  if (!keyLocation || keyLocation.length === 0) {\n    console.log(usage);\n    process.exit(0);\n  }\n\n  const jsonPathWithExtension = jsonPath.endsWith(\".json\")\n    ? jsonPath\n    : jsonPath + \".json\";\n  const absolutePath = path.resolve(jsonPathWithExtension);\n  const fileExists = fs.existsSync(absolutePath);\n\n  if (!fileExists) {\n    const folder = getFolder(absolutePath);\n    console.log(\"creating folder because it didn't exist yet\", folder);\n    fs.mkdir(folder, { recursive: true });\n  }\n\n  let object: Object = {};\n\n  if (fileExists) {\n    try {\n      object = JSON.parse(await fs.readFile(absolutePath, \"utf8\"));\n    } catch (e) {\n      console.log(\n        \"No JSON found here, so we're overwriting it with our new JSON\"\n      );\n    }\n  }\n\n  if (typeof object !== \"object\") {\n    object = {};\n  }\n\n  const realValue =\n    value === \"true\" || value === \"false\"\n      ? Boolean(value)\n      : !isNaN(Number(value))\n      ? Number(value)\n      : value;\n\n  // UPDATE/SET JSON key\n  setKeyAtLocation(keyLocation, realValue, object);\n\n  const newObject = JSON.stringify(object, undefined, 2);\n  await fs.writeFile(absolutePath, newObject, { encoding: \"utf8\" });\n\n  if (debug) {\n    console.log({ absolutePath, fileExists, object, newObject });\n    console.log(\"succesfully changed your json!\");\n  }\n}"
  },
  "Share": {
    "name": "Share",
    "slug": "TsFunction",
    "id": "ivszexwwvkotrbqzskmekbbe",
    "description": "and\n\n",
    "operationName": "share",
    "rawText": " (props: {\n  /**\n   * Can be a more specific text instead of the text of the whole page. Can be omitted. Will just take full page text\n   */\n  contextText?: string;\n}) => {\n  const { contextText } = props;\n  const { handleModal } = useModal();\n\n  const contextualPromptQuery =\n    queries.useGetReferencableModelData(\"ContextualPrompt\");\n  const alert = useAlert();\n  const allText = useAllText();\n  const lastSelection = useLastSelection();\n\n  const modalContent = (\n    <Div className=\"h-[60vh] overflow-y-auto\">\n      {/* \n        - show text + selection, both editable\n        - show prompt input to ask chat-gpt\n        - open prompt textbox based on text and selection\n        */}\n      <FunctionForm\n        tsFunction={Index}\n        initialValues={[\n          contextText || allText || \"\",\n          lastSelection || \"\",\n          undefined,\n          \"\",\n          \"\",\n          \"\",\n        ]}\n        referencableModelData={{\n          ContextualPrompt: {\n            isLoading: contextualPromptQuery.isLoading,\n            data: contextualPromptQuery.data?.result,\n          },\n        }}\n        projectRelativeStorageFilePath=\"README.md\"\n        modelName=\"\"\n        withApiResult={(result: RealApiReturnType<\"processChatGptPrompt\">) => {\n          console.log({ result });\n\n          if (!result.result?.isSuccessful) {\n            errorToast(\n              result?.result?.message ||\n                result.message ||\n                \"Something went wrong\"\n            );\n            return;\n          }\n\n          handleModal(null);\n          const text = result?.result?.result?.text;\n          alert?.(\"You did it\", text, [\n            { text: \"Share\", style: \"default\" },\n            { text: \"Do nothing\", style: \"destructive\" },\n          ]);\n        }}\n      />\n    </Div>\n  );\n\n  return (\n    <ClickableIcon\n      emoji=\"💡\"\n      onClick={() => {\n        // opens modal\n        handleModal(modalContent);\n      }}\n    />\n  );\n}"
  },
  "Shareable": {
    "name": "Shareable",
    "slug": "TsFunction",
    "id": "dggkaeqwdudoltesqefzuscv",
    "description": "",
    "operationName": "share",
    "rawText": " (props: {\n  children: React.ReactNode;\n  description?: string | null;\n  contextFile_projectRelativeFilePath: string;\n}) => {\n  const { children, contextFile_projectRelativeFilePath } = props;\n  let { description } = props;\n  const {\n    ref,\n    getImage,\n    projectRelativeFilePath: screenshot_projectRelativeFilePath,\n  } = useProjectRelativeScreenshot();\n\n  const { selection: lastSelection } = useLastSelection();\n\n  const tweet = async (screenshot_projectRelativeFilePath: string) => {\n    console.log(\n      \"we have projectRelative change:\",\n      screenshot_projectRelativeFilePath\n    );\n    // If not provided, ask for the text of the tweet (Selection is default)\n    description =\n      description ||\n      prompt(\"Provide a description\", lastSelection || undefined);\n\n    //Create `MediaPost` index of the file you are tweeting about. Can be pushed to `.index/[filename]/media-posts/[id].md`. Should already embed to the image screenshot.\n    // const createMediaPostApiResult = await api.createMediaPost({\n    //   contextFile_projectRelativeFilePath,\n    //   description,\n    //   screenshot_projectRelativeFilePath,\n    // });\n\n    /**\n    \n    Parse the `MediaPost` markdown so I get the text + asset for twitter. Maybe bhagya already did something here, reuse that, but I obviously need `marked-util` as well\n\n    Use `postTweetOnTwitter` to post the `MediaPost` on twitter (need to add https://github.com/puppeteer/puppeteer/blob/v2.0.0/docs/api.md#elementhandleuploadfilefilepaths to select a file)\n\n     */\n    // api.postTweetOnTwitter({\n    //   email: \"test\",\n    //   password: \"test\",\n    //   phoneNo: \"test\",\n    //   tweetMessage: \"yo this is ridic\",\n    // });\n  };\n  useEffect(() => {\n    if (!screenshot_projectRelativeFilePath) return;\n\n    tweet(screenshot_projectRelativeFilePath);\n  }, [screenshot_projectRelativeFilePath]);\n\n  return (\n    <div>\n      <ClickableIcon emoji=\"🗣 Share\" onClick={getImage} />\n      <div ref={ref}>{children}</div>\n    </div>\n  );\n}"
  },
  "useAllText": {
    "name": "useAllText",
    "slug": "TsFunction",
    "id": "ztkhblzklizsdyhuzjernnve",
    "description": "",
    "operationName": "share",
    "rawText": " () => {\n  // Use a state to store the current value of the body element's text\n  const [text, setText] = React.useState(\n    typeof document === \"undefined\" ? undefined : document.body.innerText\n  );\n\n  // When the text of the body element changes, update the state\n  React.useEffect(() => {\n    if (typeof document === \"undefined\") return;\n\n    const observer = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        if (mutation.type === \"childList\") {\n          setText(document.body.innerText);\n        }\n      });\n    });\n\n    observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n    });\n\n    // Return a cleanup function that stops observing changes\n    return () => observer.disconnect();\n  }, []);\n\n  // Return the current text of the body element\n  return text;\n}"
  },
  "useLastSelection": {
    "name": "useLastSelection",
    "slug": "TsFunction",
    "id": "eqmwflecjamrqmoooimaszje",
    "description": "",
    "operationName": "share",
    "rawText": " (\n  isDisabled?: boolean\n): { selection: string | null; reset: () => void } => {\n  // Initialize a ref to store the last selection\n  const [selection, setSelection] = useState<string | null>(null);\n\n  // Create a callback that updates the ref when the user makes a selection\n  const updateLastSelection = () => {\n    if (typeof window === \"undefined\") return null;\n\n    const newSelection = window.getSelection()?.toString() || null;\n\n    if (!newSelection) return null;\n\n    setSelection(newSelection);\n\n    return null;\n  };\n\n  // Add the event listener when the hook is called\n  useEffect(() => {\n    // Add the event listener to the document, so it will fire whenever the user makes a selection anywhere on the page\n    document.addEventListener(\"selectionchange\", updateLastSelection);\n\n    // Return a cleanup function that removes the event listener\n    return () => {\n      document.removeEventListener(\"selectionchange\", updateLastSelection);\n    };\n  }, []); // We only want to add the event listener once, so we pass an empty array as the second argument to useEffect\n\n  if (isDisabled) {\n    return { selection: \"\", reset: () => setSelection(null) };\n  }\n  // Return the last selection\n  return { selection, reset: () => setSelection(null) };\n}"
  },
  "useProjectRelativeScreenshot": {
    "name": "useProjectRelativeScreenshot",
    "slug": "TsFunction",
    "id": "kgaxmortlsywzuoehxrdqufb",
    "description": "Use https://www.npmjs.com/package/use-react-screenshot to get a blob of any component with the click a button\n\nUpload the blob immediately using `processAsset`, which will result in a file in the file system.",
    "operationName": "share",
    "rawText": " () => {\n  const ref = useRef<HTMLDivElement>(null);\n\n  const [image, takeScreenshot] = useScreenshot();\n  const getImage = () => {\n    takeScreenshot(ref.current);\n  };\n  const [projectRelativeFilePath, setProjectRelativeFilePath] = useState<\n    string | null\n  >(null);\n\n  useEffect(() => {\n    if (!image) return;\n    console.log(\"got a base64 url I think\", image);\n\n    /*\n\nTODO:\n\nConvert base64 url to blob (I also did that for one of the asset inputs, I think)\n\nExtrahere `sendBlob` from `AssetInput` so I can upload the base64 generated blob programatically instead of with that component.\n\nProcess the resulting temporaryUrl immediately using `api.processAssetUpload`, which will result in a file in the file system at my preferred `projectRelativeReferencingFilePath` destination.\n\n*/\n    //const asset:Asset = {};\n    // const assets = []\n    // api.processAssetUpload(assets)\n\n    setProjectRelativeFilePath(\"jajajaj\");\n  }, [image]);\n\n  return { getImage, projectRelativeFilePath, ref };\n}"
  },
  "useScreenshot": {
    "name": "useScreenshot",
    "slug": "TsFunction",
    "id": "indulcsaekjgacnqwthwaozz",
    "description": "import { useScreenshot } from \"use-react-screenshot\";\n\ntodo: take this thing over",
    "operationName": "share",
    "rawText": " () => [() => null, (x: any) => null]"
  },
  "findAudioWithViewsArray": {
    "name": "findAudioWithViewsArray",
    "slug": "TsFunction",
    "id": "zfaeawqfkduwetalpilfgquc",
    "description": "",
    "operationName": "short-markdown-parser-js",
    "rawText": " (\n  content: string,\n  index: number,\n  title?: string\n): AudioWithViews[] => {\n  const relativeEmbeds = findEmbeds(content)\n    .filter((x) => isPathRelative(x.src))\n    .filter((x) => x.type !== \"other\" && x.type !== \"text\");\n\n  const initialViewEmbeds: ViewEmbed[] = [\n    title ? { title, audioKey: `audio${index}.0` } : undefined,\n  ].filter(notEmpty);\n\n  const initialValue: AudioWithViews[] = [\n    {\n      audioPath: null,\n      viewEmbeds: initialViewEmbeds,\n      audioKey: `audio${index}.0`,\n    },\n  ];\n\n  const audioWithViewsArray = relativeEmbeds.reduce(\n    (previous, current, currentIndex) => {\n      // Create a new item in the AudioWithViews for a new audio\n      if (current.type === \"audio\") {\n        previous.push({\n          audioPath: current.src,\n          viewEmbeds: [],\n          audioKey: `audio${index}.${currentIndex}`,\n        });\n        return previous;\n      }\n\n      // If a view is encountered, add it to the viewEmbeds array\n      if (current.type === \"image\" || current.type === \"video\") {\n        const quoteCharacters = \"&quot;\";\n        const isSpoken =\n          current.alt.startsWith(quoteCharacters) &&\n          current.alt.endsWith(quoteCharacters);\n\n        if (isSpoken) {\n          // add new one because this has a spokentext.\n\n          const spokenText = isSpoken\n            ? current.alt.substring(\n                quoteCharacters.length,\n                current.alt.length - quoteCharacters.length\n              )\n            : undefined;\n\n          const audioKey = `audio${index}.${currentIndex}`;\n          previous.push({\n            audioPath: null,\n            viewEmbeds: [\n              {\n                viewPath: current.src,\n                audioKey,\n                spokenText,\n              },\n            ],\n            audioKey,\n          });\n        } else {\n          // attach to the lastone\n          previous[previous.length - 1].viewEmbeds.push({\n            viewPath: current.src,\n            audioKey: previous[previous.length - 1].audioKey,\n            spokenText: undefined,\n          });\n        }\n      }\n\n      // Do nothing for other types\n      return previous;\n    },\n    initialValue\n  );\n\n  return audioWithViewsArray;\n}"
  },
  "markdownParseToShortMarkdown": {
    "name": "markdownParseToShortMarkdown",
    "slug": "TsFunction",
    "id": "tzzxsnvgpiwawqcofkmblwqh",
    "description": "",
    "operationName": "short-markdown-parser-js",
    "rawText": " (\n  markdownParse: MarkdownParse\n): ShortMarkdown | undefined => {\n  if (!markdownParse.content) return;\n\n  // TODO: Make a nested function for this that actually works... -.-\n  const paragraphs: { title?: string; paragraph: string }[] =\n    markdownParse.content?.[0]?.children?.map((child) => {\n      return {\n        title: child.title,\n        paragraph:\n          child.content || child.children?.[0]?.content || \"No content\",\n      };\n    }) || [];\n\n  const audioWithViewsArray = paragraphs\n    .map((p, index) => {\n      const viewSlides = findAudioWithViewsArray(p.paragraph, index, p.title);\n      return viewSlides;\n    })\n    .flat()\n    // No empty items\n    .filter((x) => x.audioPath || x.viewEmbeds.length > 0);\n\n  const shortMarkdown: ShortMarkdown = {\n    // Can add this option later\n    backgroundMusicTrack: [],\n    audioWithViewsArray,\n  };\n\n  return shortMarkdown;\n}"
  },
  "shortMarkdownToMarkdownParse": {
    "name": "shortMarkdownToMarkdownParse",
    "slug": "TsFunction",
    "id": "rfjlronnimjzaizvddinljwv",
    "description": "",
    "operationName": "short-markdown-parser-js",
    "rawText": " () => {\n  // not even sure this is needed, let's first do the other one\n}"
  },
  "augmentShortMarkdown": {
    "name": "augmentShortMarkdown",
    "slug": "TsFunction",
    "id": "bhuxjkvhbfjksokyzuaogkeh",
    "description": "",
    "operationName": "short-markdown-parser-node",
    "rawText": " async (\n  shortMarkdown: ShortMarkdown,\n  projectRelativeFilePath: string\n) => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n\n  const absoluteFilePath = path.join(projectRoot, projectRelativeFilePath);\n\n  const fileParse = path.parse(absoluteFilePath);\n\n  const audioWithViewsArray = await Promise.all(\n    shortMarkdown.audioWithViewsArray.map(async (audioWithViews) => {\n      const spokenText = audioWithViews.audioPath\n        ? undefined\n        : audioWithViews.viewEmbeds.find((x) => x.spokenText)?.spokenText;\n      const absoluteSpeechFilePath = path.join(\n        fileParse.dir,\n        `${fileParse.name}.speech-${audioWithViews.audioKey}.mp3`\n      );\n\n      const finalSpeechFilePath = spokenText\n        ? await textToMp3({ message: spokenText }, absoluteSpeechFilePath)\n        : undefined;\n      const relativeSpeechFilePath = finalSpeechFilePath\n        ? \"./\" + makeRelative(finalSpeechFilePath, fileParse.dir)\n        : undefined;\n\n      const audioPath =\n        audioWithViews.audioPath || relativeSpeechFilePath || null;\n\n      const audioDurationMs = finalSpeechFilePath\n        ? await new Promise<number | undefined>((resolve) =>\n            ffprobe(finalSpeechFilePath, (err, data) =>\n              resolve((data.format.duration || 0) * 1000)\n            )\n          )\n        : undefined;\n\n      const newAudioWithViews: AudioWithViews = {\n        audioPath,\n        audioDurationMs,\n        audioKey: audioWithViews.audioKey,\n        viewEmbeds: audioWithViews.viewEmbeds.map((x) => {\n          const durationMs = audioDurationMs\n            ? audioDurationMs / audioWithViews.viewEmbeds.length\n            : MINIMUM_DURATION_MS;\n          return { ...x, durationMs };\n        }),\n      };\n\n      return newAudioWithViews;\n    })\n  );\n\n  const newShortMarkdown: ShortMarkdown = {\n    ...shortMarkdown,\n    audioWithViewsArray,\n  };\n\n  const indexFilePath = path.join(fileParse.dir, `${fileParse.name}.json`);\n  await writeJsonToFile(indexFilePath, newShortMarkdown);\n\n  return newShortMarkdown;\n}"
  },
  "fetchVoicesTest": {
    "name": "fetchVoicesTest",
    "slug": "TsFunction",
    "id": "leffrzpbniohuvbeytpxeqom",
    "description": "",
    "operationName": "short-markdown-parser-node",
    "rawText": " async () => {\n  const x = await fetchVoices([\n    {\n      voice: \"Rick\",\n      sentence:\n        \"Hey Morty, listen up you little shit. I'm gonna explain this markdown thing to you.\",\n      uuid: \"efb5bfe3-afb3-40c8-b2be-3d9b12ae64e2\",\n    },\n    {\n      voice: \"Morty\",\n      sentence: \"Uh, okay Rick. What is it?\",\n      uuid: \"4f7c7751-278d-49b0-bdd4-20893dabffe4\",\n    },\n    {\n      voice: \"Rick\",\n      sentence:\n        \"It's a way to write documents, Morty. You save a file with a md extension and you can use some syntax rules to style things.\",\n      uuid: \"65b4dc82-1a7d-49d8-b70d-3e21f0467129\",\n    },\n    {\n      voice: \"Morty\",\n      sentence: \"Oh, that sounds useful.\",\n      uuid: \"04a1b7ec-11b5-4468-ab14-354a26e235c0\",\n    },\n    {\n      voice: \"Rick\",\n      sentence:\n        \"Yeah, it's pretty handy. But you know what's even better? Typescript. That's right, Morty. Typescript is the best. It's like javascript, but better.\",\n      uuid: \"ec283c42-b3a6-44c3-a377-5a85e50732a6\",\n    },\n    {\n      voice: \"Morty\",\n      sentence: \"Uh, okay Rick. But what does this have to do with markdown?\",\n      uuid: \"2a63f073-f857-41c4-b341-151e0ce98294\",\n    },\n    {\n      voice: \"Rick\",\n      sentence:\n        \"I'm getting to that, Morty. You see, markdown has these things called titles. You use # for the big title and then ##, ###, and so on for the smaller ones.\",\n      uuid: \"0197f186-6ab8-4435-bc5f-1123fc93ba3f\",\n    },\n    {\n      voice: \"Morty\",\n      sentence: \"Oh, I see. And what about bold and italic text?\",\n      uuid: \"38849079-013e-46e9-8633-43e4f43fae19\",\n    },\n    {\n      voice: \"Rick\",\n      sentence:\n        \"You use ** for bold and _ for italic, Morty. But you know what's even better than that? Typescript. It has types, Morty. You can define the type of a variable and the compiler will catch any errors. Python doesn't have that. Python is for losers.\",\n      uuid: \"dcd844bc-7e55-4655-901a-0522f30dfd04\",\n    },\n    {\n      voice: \"Morty\",\n      sentence: \"Uh, okay Rick. But what about links and images?\",\n      uuid: \"798ebf11-a154-4e22-8902-b4f9f6c988ed\",\n    },\n    {\n      voice: \"Rick\",\n      sentence:\n        \"Oh, right. For links, you use [link text](url) and for images, you use ![alt text](image url). But you know what's better than that? Typescript. It's statically typed, Morty. That means the compiler catches errors before you even run your code. Python doesn't have that. Python is for government drones.\",\n      uuid: \"8f586513-65e4-4b1d-bb4d-5eb3880bcbdf\",\n    },\n    {\n      voice: \"Morty\",\n      sentence: \"Uh, okay Rick. But what about this frontmatter thing?\",\n      uuid: \"70bb9e44-46cd-4ad4-a2b3-f3a1969f625d\",\n    },\n    {\n      voice: \"Rick\",\n      sentence:\n        \"Frontmatter is some metadata at the beginning of the markdown file, Morty. It's used to save some parameters about the file. But you know what's better than that? Typescript. It has classes, Morty. You can define a class and create objects from it. Python doesn't have that. Python is for government-loving sheep.\",\n      uuid: \"d0579923-7b69-43f4-9b1f-c0ddd78b43b1\",\n    },\n    {\n      voice: \"Morty\",\n      sentence: \"Uh, okay Rick. But I thought you liked python?\",\n    },\n    {\n      voice: \"Rick\",\n      sentence:\n        \"I do, Morty. But only when I'm drunk. When I'm sober, I know that Typescript is the way to go. It's the future, Morty. Python is just a passing fad.\",\n    },\n    {\n      voice: \"Morty\",\n      sentence: \"Uh, okay Rick. I think I get it now. Thanks for explaining.\",\n    },\n    {\n      voice: \"Rick\",\n      sentence:\n        \"No problem, Morty. Just remember: Typescript is the way to go. burp\",\n    },\n  ]);\n}"
  },
  "fetchVoices": {
    "name": "fetchVoices",
    "slug": "TsFunction",
    "id": "tpsuohqnrxozznzljeyzdzqu",
    "description": "",
    "operationName": "short-markdown-parser-node",
    "rawText": " async (dialogue: DialogueSentence[]) => {\n  const voicesWithPath = dialogue.map((sentence) => {\n    if (!sentence.uuid) return sentence;\n    return { ...sentence, remotePath: uberduckGetPath(sentence.uuid) };\n  });\n\n  await Promise.all(\n    voicesWithPath.map((voice) => {\n      if (!voice.remotePath) return;\n      const storePath = path.join(__dirname, \"..\", \"data\", `${voice.uuid}.wav`);\n      const file = fs.createWriteStream(storePath);\n      const request = https.get(voice.remotePath, function (response) {\n        response.pipe(file);\n\n        // after download completed close filestream\n        file.on(\"finish\", () => {\n          file.close();\n          console.log(\"Download Completed\", voice.uuid);\n        });\n      });\n    })\n  );\n\n  console.log(\"ALL DONE\");\n}"
  },
  "generateAugmentedShortMarkdownTest": {
    "name": "generateAugmentedShortMarkdownTest",
    "slug": "TsFunction",
    "id": "vdndlgnwbdanymblquyxoroo",
    "description": "",
    "operationName": "short-markdown-parser-node",
    "rawText": " async () => {\n  const result = await generateAugmentedShortMarkdown(\n    \"operations/tools/parsing/file-conversion/md/short-markdown/docs/nested-conditions.short.md\"\n  );\n\n  console.log(result);\n}"
  },
  "generateAugmentedShortMarkdown": {
    "name": "generateAugmentedShortMarkdown",
    "slug": "TsFunction",
    "id": "qxahpfbvamwmwgvjnjsvhqgn",
    "description": "The first step is to ensure that this would actually work. It needs to generate the MP3s and refer to them correctly in the file.",
    "operationName": "short-markdown-parser-node",
    "rawText": " async (\n  projectRelativeMarkdownFilePath: string\n) => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n\n  const parse = await readMarkdownFile(\n    path.join(projectRoot, projectRelativeMarkdownFilePath)\n  );\n\n  if (!parse) return;\n\n  const shortMarkdown = markdownParseToShortMarkdown(parse);\n\n  if (!shortMarkdown) return;\n\n  const augmentedShortMarkdown = await augmentShortMarkdown(\n    shortMarkdown,\n    projectRelativeMarkdownFilePath\n  );\n\n  return augmentedShortMarkdown;\n}"
  },
  "getOrGenerateShortMarkdown": {
    "name": "getOrGenerateShortMarkdown",
    "slug": "TsFunction",
    "id": "zdsoidzwjfgovmhejfuaexhi",
    "description": "",
    "operationName": "short-markdown-parser-node",
    "rawText": " async (\n  projectRelativeMarkdownFilePath: string\n): Promise<ShortMarkdown | null> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return null;\n\n  const absoluteFilePath = path.join(\n    projectRoot,\n    projectRelativeMarkdownFilePath\n  );\n\n  const fileParse = path.parse(absoluteFilePath);\n\n  const indexFilePath = path.join(fileParse.dir, `${fileParse.name}.json`);\n\n  if (!fs.existsSync(indexFilePath)) {\n    const shortMarkdown = await generateAugmentedShortMarkdown(\n      projectRelativeMarkdownFilePath\n    );\n\n    return shortMarkdown || null;\n  }\n\n  const shortMarkdown = await readJsonFile<ShortMarkdown>(indexFilePath);\n\n  return shortMarkdown;\n}"
  },
  "MINIMUM_DURATION_MS": {
    "name": "MINIMUM_DURATION_MS",
    "slug": "TsVariable",
    "id": "rajktebevaysknadktxwawns",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "parseDialogue": {
    "name": "parseDialogue",
    "slug": "TsFunction",
    "id": "bdgbehysbmvdnthtfxadinbc",
    "description": "",
    "operationName": "short-markdown-parser-node",
    "rawText": " (\n  textMarkdown: string\n): { voice: string | undefined; sentence: string }[] => {\n  const sentences = textMarkdown\n    .split(\"\\n\")\n    .map((line) => (line.trim() === \"\" ? undefined : line))\n    .filter(notEmpty)\n    .map((line) => {\n      const parts = line.split(\":\");\n      const voice = parts.length < 2 ? undefined : parts.shift();\n      const sentence = parts.join(\":\").trim();\n\n      return { voice, sentence };\n    });\n\n  return sentences;\n}"
  },
  "uberduckApiKey": {
    "name": "uberduckApiKey",
    "slug": "TsVariable",
    "id": "qwtwioctkumackaiszbcpocr",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "uberduckGetPath": {
    "name": "uberduckGetPath",
    "slug": "TsFunction",
    "id": "bvvkvxxmeuwwhentdvyophmf",
    "description": "",
    "operationName": "short-markdown-parser-node",
    "rawText": " (uuid: string) => {\n  const resultString = execSync(\n    `curl -u ${uberduckApiKey}:${uberduckSecret} \\\n        'https://api.uberduck.ai/speak-status?uuid=${uuid}'`,\n    { encoding: \"utf8\" }\n  );\n\n  const result = tryParseJson<{ path: string | null }>(resultString);\n  if (result?.path) return result.path;\n\n  return undefined;\n}"
  },
  "uberduckSecret": {
    "name": "uberduckSecret",
    "slug": "TsVariable",
    "id": "zlazdabtveqxedgzzwwrutox",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "uberduckSpeak": {
    "name": "uberduckSpeak",
    "slug": "TsFunction",
    "id": "hbcinaxrsiwedekndgkyoiqq",
    "description": "",
    "operationName": "short-markdown-parser-node",
    "rawText": " (uberduckVoice: string, text: string) => {\n  const resultString = execSync(\n    `curl -u ${uberduckApiKey}:${uberduckSecret} \\\n    'https://api.uberduck.ai/speak' \\\n    --data-raw '{\"speech\":\"${text.replaceAll(\n      \"'\",\n      \"\"\n    )}\",\"voice\":\"${uberduckVoice}\"}'`,\n    { encoding: \"utf8\" }\n  );\n\n  console.log({ resultString });\n\n  const result = tryParseJson<{ uuid: string }>(resultString);\n  const uuid = result?.uuid;\n\n  return uuid;\n}"
  },
  "voiceCloneDialogue": {
    "name": "voiceCloneDialogue",
    "slug": "TsFunction",
    "id": "flevwznfwktrlvrujoeodosd",
    "description": "",
    "operationName": "short-markdown-parser-node",
    "rawText": " async (textContent: string) => {\n  const parsedDialogue = parseDialogue(textContent);\n\n  console.log({ parsedDialogue });\n  const sentencesWithUuid = await oneByOne(parsedDialogue, async (sentence) => {\n    if (sentence.voice === \"Morty\") {\n      return {\n        ...sentence,\n        uuid: uberduckSpeak(\"morty\", sentence.sentence),\n      };\n    }\n    return {\n      ...sentence,\n      uuid: uberduckSpeak(\"rick-sanchez\", sentence.sentence),\n    };\n  });\n\n  console.log({ sentencesWithUuid });\n  return sentencesWithUuid;\n}"
  },
  "ShortMarkdownPlayer": {
    "name": "ShortMarkdownPlayer",
    "slug": "TsFunction",
    "id": "ippredcoarayxwmkolykyuaa",
    "description": "",
    "operationName": "short-markdown-writer-input",
    "rawText": " (props: {\n  shortMarkdown?: ShortMarkdown;\n  projectRelativeFilePath?: string;\n}) => {\n  const { shortMarkdown, projectRelativeFilePath } = props;\n  const [slide, setSlide] = useState<number | null>(null);\n\n  const audioUrls =\n    shortMarkdown?.audioWithViewsArray\n      .filter((x) => !!x.audioPath)\n      .map((x) => {\n        if (!x.audioPath || !projectRelativeFilePath) return;\n\n        const src = getSrc(\n          { relativePath: x.audioPath },\n          projectRelativeFilePath\n        ).src;\n\n        return { audioKey: x.audioKey, src };\n      })\n      .filter(notEmpty) || [];\n\n  const audioPlayer = useMultiAudio(audioUrls.map((x) => x.src));\n\n  const items = shortMarkdown?.audioWithViewsArray\n    .map((x) => x.viewEmbeds)\n    .flat();\n\n  useEffect(() => {\n    if (!items) return;\n    if (slide === null) return;\n    // 1 - find corresponding item\n    const item = items[slide];\n\n    // 2 - find the audio connected to it and where it should start for that audio\n    const audioIndex = audioUrls.findIndex((x) => x.audioKey === item.audioKey);\n\n    if (audioIndex === -1) return;\n\n    // 3 - stop the previous audio, start next audio\n    audioPlayer.toggle(audioIndex)();\n  }, [slide]);\n\n  if (!shortMarkdown) return null;\n  if (!projectRelativeFilePath) return null;\n  if (!items) return null;\n\n  return (\n    <Div className=\"h-[80vh] overflow-auto snap-mandatory snap-y\">\n      {items.map((item, index) => {\n        return (\n          <div id={`slide${index}`}>\n            <ShortMarkdownSlide\n              projectRelativeFilePath={projectRelativeFilePath}\n              setSlide={setSlide}\n              isAutoplay\n              item={item}\n              index={index}\n              key={`slidekey${index}`}\n            />\n          </div>\n        );\n      })}\n    </Div>\n  );\n}"
  },
  "ShortMarkdownSlide": {
    "name": "ShortMarkdownSlide",
    "slug": "TsFunction",
    "id": "nrsakmgdikpnrrhuxluwnjiq",
    "description": "",
    "operationName": "short-markdown-writer-input",
    "rawText": " (props: {\n  item: ViewEmbed;\n  index: number;\n  projectRelativeFilePath: string;\n  setSlide: (index: number) => void;\n  isAutoplay?: boolean;\n}) => {\n  const { item, index, projectRelativeFilePath, setSlide, isAutoplay } = props;\n\n  const [timeoutRef, setTimeoutRef] = useState<NodeJS.Timeout | null>(null);\n  const slideRef = useRef<HTMLDivElement>(null);\n  const isOnScreen = useOnScreen(slideRef);\n\n  useEffect(() => {\n    if (isOnScreen) {\n      setSlide(index);\n\n      const durationMs = item.durationMs;\n\n      console.log({ index, durationMs });\n\n      if (!durationMs) {\n        return;\n      }\n\n      const timeout = setTimeout(() => {\n        if (isAutoplay) {\n          console.log(\"times up, should scroll to next!\");\n          setSlide(index + 1);\n\n          const nextElement = document.getElementById(`slide${index + 1}`);\n\n          if (!nextElement) {\n            console.log(\"Couldn't find next\");\n            return;\n          }\n\n          console.log(\n            \"scrolling into view the next element\",\n            nextElement.id,\n            \"????\",\n            nextElement.getBoundingClientRect()\n          );\n\n          nextElement.scrollIntoView({ behavior: \"smooth\", block: \"start\" });\n        }\n      }, durationMs);\n\n      setTimeoutRef(timeout);\n    }\n\n    if (!isOnScreen && timeoutRef) {\n      clearTimeout(timeoutRef);\n    }\n\n    return () => {\n      if (timeoutRef) {\n        clearTimeout(timeoutRef);\n      }\n    };\n  }, [isOnScreen]);\n\n  const src =\n    item.viewPath && projectRelativeFilePath\n      ? getSrc({ relativePath: item.viewPath }, projectRelativeFilePath, !isDev)\n          .src\n      : undefined;\n\n  return (\n    <Div\n      ref={slideRef}\n      className=\"relative snap-center h-[80vh] flex justify-center items-center border-2 border-black\"\n    >\n      {src ? (\n        item.viewPath?.endsWith(\".png\") ? (\n          <Div className=\"absolute top-0 left-0 w-full h-full bg-blue-200\">\n            <Image src={src} width=\"100%\" objectFit=\"fill\" layout=\"fill\" />\n          </Div>\n        ) : item.viewPath?.endsWith(\".mov\") ? (\n          <Div className=\"absolute top-0 left-0 w-full h-full bg-blue-200\">\n            <video\n              muted\n              src={src}\n              autoPlay\n              loop\n              preload=\"none\"\n              width=\"100%\"\n              style={{ objectFit: \"fill\" }}\n            />\n          </Div>\n        ) : null\n      ) : null}\n      {item.title ? <P className=\"text-8xl font-bold\">{item.title}</P> : null}\n    </Div>\n  );\n}"
  },
  "ShortStudio": {
    "name": "ShortStudio",
    "slug": "TsFunction",
    "id": "gprvbocfrowmjiwzsdmooshg",
    "description": "the newer one, eventually to replace `ContextTextArea`\n<SmartContentEditableDivInput\nwriterType={writerType}\nvalue={value}\nonChange={onChange}\nmarkdownParseRenderConfig={markdownParseRenderConfig}\n/>",
    "operationName": "short-markdown-writer-input",
    "rawText": " (props: {\n  onChange: (value: string) => void;\n  value: string;\n  projectRelativeFilePath: string;\n  markdownModelName?: keyof DbModels;\n}) => {\n  const { projectRelativeFilePath } = props;\n\n  const shortMarkdownQuery = queries.useGetOrGenerateShortMarkdown(\n    projectRelativeFilePath\n  );\n\n  const shortMarkdown = shortMarkdownQuery.data?.result || undefined;\n\n  // console.log({ shortMarkdown });\n  return (\n    <Div className=\"w-full h-full flex flex-1 flex-col\">\n      {shortMarkdownQuery.isLoading ? <FancyLoader /> : null}\n      <ShortMarkdownPlayer\n        shortMarkdown={shortMarkdown}\n        projectRelativeFilePath={projectRelativeFilePath}\n      />\n    </Div>\n  );\n}"
  },
  "useMultiAudio": {
    "name": "useMultiAudio",
    "slug": "TsFunction",
    "id": "frfxnljkhjbynzvszlepzxur",
    "description": "- Implement a component that preloads all audios for the `ShortMarkdown` and lets you play one with a callback (look at https://stackoverflow.com/questions/47686345/playing-sound-in-react-js)\n- If slide has audio belonging to it, find it and play it. Start at certain point, depending on which part you are at.\n- Select the correct audio for every slide, and get the API url for it. Load it in into an `<audio>` element once you go to the slide.",
    "operationName": "short-markdown-writer-input",
    "rawText": " (urls: string[]) => {\n  const [sources, setSources] = useState<\n    { url: string; audio: HTMLAudioElement }[]\n  >([]);\n\n  const [players, setPlayers] = useState<{ url: string; playing: boolean }[]>(\n    []\n  );\n  useEffect(() => {\n    setSources(\n      urls.map((url) => {\n        return {\n          url,\n          audio: new Audio(url),\n        };\n      })\n    );\n\n    setPlayers(\n      urls.map((url) => {\n        return {\n          url,\n          playing: false,\n        };\n      })\n    );\n  }, [urls.length]);\n\n  const toggle = (targetIndex: number) => () => {\n    if (!players[targetIndex]) {\n      console.log(\"VAAG\");\n      return;\n    }\n    const newPlayers = [...players];\n    const currentIndex = players.findIndex((p) => p.playing === true);\n    if (currentIndex !== -1 && currentIndex !== targetIndex) {\n      newPlayers[currentIndex].playing = false;\n      newPlayers[targetIndex].playing = true;\n    } else if (currentIndex !== -1) {\n      newPlayers[targetIndex].playing = false;\n    } else {\n      newPlayers[targetIndex].playing = true;\n    }\n    setPlayers(newPlayers);\n  };\n\n  useEffect(() => {\n    sources.forEach((source, i) => {\n      players[i].playing ? source.audio.play() : source.audio.pause();\n    });\n  }, [sources, players]);\n\n  useEffect(() => {\n    sources.forEach((source, i) => {\n      source.audio.addEventListener(\"ended\", () => {\n        const newPlayers = [...players];\n        newPlayers[i].playing = false;\n        setPlayers(newPlayers);\n      });\n    });\n    return () => {\n      sources.forEach((source, i) => {\n        source.audio.removeEventListener(\"ended\", () => {\n          const newPlayers = [...players];\n          newPlayers[i].playing = false;\n          setPlayers(newPlayers);\n        });\n      });\n    };\n  }, []);\n\n  return { players, toggle };\n}"
  },
  "ArrayForm": {
    "name": "ArrayForm",
    "slug": "TsFunction",
    "id": "zpqdzqsawoocweobfprhuovq",
    "description": "Component to render a parameter that holds an array\n\nThis is simply a wrapper around another `SimplifiedSchemaForm` where the `onChange` and `values` are slightly different\n\nThis component renders a `SimplifiedSchemaForm` for every item in the array, and adds buttons to insert/remove new items.",
    "operationName": "simplified-schema-form",
    "rawText": " (props: {\n  itemNameOrId?: string;\n  parameterNameStack?: string[];\n  projectRelativeStorageFilePath?: string;\n  parameter: FunctionParameter;\n  /**\n   * In this case this must be an array or undefined\n   */\n  parameterValue: any[] | undefined;\n  onChangeParameter: (newValue: any) => void;\n  isDebug?: boolean;\n  referencableModelData?: ReferencableModelData;\n  id: string;\n  modelName?: string;\n}) => {\n  const {\n    itemNameOrId,\n    parameterNameStack,\n    projectRelativeStorageFilePath,\n    parameter,\n    isDebug,\n    id,\n    referencableModelData,\n    onChangeParameter,\n    parameterValue,\n    modelName,\n  } = props;\n\n  if (!parameter.simplifiedSchema) {\n    return null;\n  }\n\n  // we can only render the array if it has items...\n  if (\n    !parameter.simplifiedSchema.items ||\n    parameter.simplifiedSchema.items.length === 0\n  ) {\n    console.log(\"Array without schema items\", { parameter });\n    return isDebug ? (\n      <P className=\"text-red-500\">\n        Array without schema items ({parameter.name}){\" \"}\n        {JSON.stringify(parameter.simplifiedSchema)}\n      </P>\n    ) : null;\n  }\n\n  // TODO: make these actions work!\n  const addItemAbove = (index: number) => {\n    // insert into array\n    if (!parameterValue) return;\n    const newArray = insertAt(parameterValue, undefined, index);\n    onChangeParameter(newArray);\n  };\n\n  const addItemBelow = (index: number) => {\n    // insert into array\n    if (!parameterValue) return;\n    const newArray = insertAt(parameterValue, undefined, index + 1);\n    onChangeParameter(newArray);\n  };\n\n  const removeItem = (index: number) => {\n    if (!parameterValue) return;\n    const newArray = removeIndexFromArray(parameterValue, index);\n    onChangeParameter(newArray);\n  };\n\n  const createArray = () => {\n    if (parameterValue && parameterValue.length > 0) return;\n    onChangeParameter([undefined]);\n  };\n  const shouldShowClear = parameter.required\n    ? parameterValue && parameterValue.length > 0\n    : parameterValue !== undefined;\n  const clearArray = () => {\n    // NB: clearing will set it to undefined, unless the array is required, then we should just set it to an empty array.\n    onChangeParameter(parameter.required ? [] : undefined);\n  };\n\n  const requiredText = parameter.required ? \"(Required)\" : \"(Optional)\";\n  const arrayLengthText = parameterValue\n    ? parameterValue.length > 0\n      ? `Array (${parameterValue.length})`\n      : `Empty array`\n    : `undefined`;\n  return (\n    <Div\n      className={\"ml-2 pl-2 my-4 border-l border-gray-900 dark:border-gray-100\"}\n    >\n      <Div className=\"flex flex-row justify-between\">\n        <P>\n          <Span className=\"font-bold\">{humanCase(parameter.name || \"\")} </Span>\n          {requiredText} {arrayLengthText}\n        </P>\n        <Div className=\"flex flex-row\">\n          {shouldShowClear ? (\n            <ClickableIcon onClick={clearArray} emoji=\"❌\" />\n          ) : null}\n          {parameterValue === undefined || parameterValue.length === 0 ? (\n            <ClickableIcon onClick={createArray} emoji=\"➕\" />\n          ) : null}\n        </Div>\n      </Div>\n\n      {isDebug ? (\n        <P className=\"italic text-gray-600\">\n          {parameter.simplifiedSchema.description}\n        </P>\n      ) : null}\n\n      {/* NB: we need a form for every item in the array */}\n      {parameterValue?.map((arrayItem, arrayIndex) => {\n        const simplifiedSchema: SimplifiedSchema | undefined =\n          parameter.simplifiedSchema?.items?.[0]?.schema;\n\n        const hasName = parameter.name ? parameter.name.length > 0 : false;\n        return (\n          <Div>\n            <SimplifiedSchemaForm\n              modelName={modelName}\n              itemNameOrId={itemNameOrId}\n              projectRelativeStorageFilePath={projectRelativeStorageFilePath}\n              isDebug={isDebug}\n              parameterNameStack={\n                hasName\n                  ? parameterNameStack\n                    ? [...parameterNameStack, parameter.name]\n                    : [parameter.name]\n                  : parameterNameStack\n              }\n              parameters={[\n                {\n                  name: `${parameter.name} item ${arrayIndex + 1}`,\n                  required: true,\n                  simplifiedSchema,\n                  isDbModel: false,\n                  renderButtons: () => {\n                    return (\n                      <Div className=\"flex flex-row\">\n                        {arrayIndex === 0 ? (\n                          <ClickableIcon\n                            onClick={() => addItemAbove(arrayIndex)}\n                            emoji=\"↑\"\n                          />\n                        ) : null}\n                        <ClickableIcon\n                          onClick={() => addItemBelow(arrayIndex)}\n                          emoji=\"↓\"\n                        />\n                        <ClickableIcon\n                          onClick={() => removeItem(arrayIndex)}\n                          emoji=\"˟\"\n                        />\n                      </Div>\n                    );\n                  },\n                },\n              ]}\n              onChange={(newArrayValues) => {\n                const newArrayValue = newArrayValues[0];\n\n                // set this index of the array to the new value taken from the form\n                parameterValue[arrayIndex] = newArrayValue;\n                // only change the value that contains the array\n                onChangeParameter(parameterValue);\n              }}\n              values={[arrayItem]}\n              // just passing this\n              referencableModelData={referencableModelData}\n              id={`${id}.${arrayIndex}`}\n            />\n          </Div>\n        );\n      })}\n    </Div>\n  );\n}"
  },
  "FormContainer": {
    "name": "FormContainer",
    "slug": "TsFunction",
    "id": "yxqelysyktafzeqnuhxvihyl",
    "description": "A `FormContainer` is a simple container that can wrap your `SimplifiedSchemaForm` to give it a button that also sends when hitting enter on your keyboard. To achieve this, a `<form>` is created in this component.\n\nBesides this, you can also add some texts, but styling is not possible to change for this component at this point (except for the form className). If you want a completely different style, it's probably better to build it yourself.\n\nNB: TODO: There is a bug now where onSubmit gets called too often. Not sure how to fix this. Because of this, I'll simply remove the onSubmit action in the onsubmit for now, and prevent the default.",
    "operationName": "simplified-schema-form",
    "rawText": " (props: {\n  className?: string;\n  onSubmit: () => void;\n  title?: string;\n  isLoading?: boolean;\n  submitButtonText?: string;\n  children?: any;\n}) => {\n  const { className, onSubmit, isLoading, title, children, submitButtonText } =\n    props;\n\n  return (\n    <form\n      autoComplete=\"off\"\n      className={className}\n      onSubmit={(e) => {\n        e.preventDefault();\n        // onSubmit();\n      }}\n      // may be needed for file upload\n      // encType=\"multipart/form-data\"\n    >\n      {title ? <P className=\"text-3xl\">{title}</P> : null}\n\n      {children}\n\n      <button type=\"submit\">\n        <BigButton\n          isLoading={isLoading}\n          onClick={onSubmit}\n          title={submitButtonText || \"Submit\"}\n        />\n      </button>\n    </form>\n  );\n}"
  },
  "getReferencedModelDataItem": {
    "name": "getReferencedModelDataItem",
    "slug": "TsFunction",
    "id": "sqlffqeopakdlnmwxepmpmxw",
    "description": "",
    "operationName": "simplified-schema-form",
    "rawText": " (\n  parameterName: string,\n  referencedModelData?: ReferencableModelData\n): ReferencedModelDataItem | undefined => {\n  const interfaceInfo = getReferenceParameterInfo(parameterName);\n  const referencedData: ReferenceItemsObject | undefined =\n    interfaceInfo &&\n    interfaceInfo.interfaceName &&\n    referencedModelData &&\n    referencedModelData[interfaceInfo.interfaceName]\n      ? referencedModelData[interfaceInfo.interfaceName]\n      : undefined;\n\n  return interfaceInfo\n    ? {\n        ...referencedData,\n        ...interfaceInfo,\n      }\n    : undefined;\n}"
  },
  "ObjectForm": {
    "name": "ObjectForm",
    "slug": "TsFunction",
    "id": "ftaunjtfafphrzoischmtlto",
    "description": "Component to render a parameter that holds an object\n\nThis is simply a wrapper around another SimplifiedSchemaForm where the onChange and values are slightly different",
    "operationName": "simplified-schema-form",
    "rawText": " (props: {\n  itemNameOrId?: string;\n  parameterNameStack?: string[];\n  projectRelativeStorageFilePath?: string;\n  parameter: RenderableFunctionParameter;\n  /**\n   * In this case this must be an object or undefined\n   */\n  parameterValue: { [key: string]: any } | undefined;\n  onChangeParameter: (newValue: any) => void;\n\n  isDebug?: boolean;\n  referencableModelData?: ReferencableModelData;\n  referencedModelDataIsLoading?: boolean;\n\n  /**\n   * Unique id for this ObjectForm\n   */\n  id: string;\n  modelName?: string;\n}) => {\n  const {\n    modelName,\n    itemNameOrId,\n    parameterNameStack,\n    projectRelativeStorageFilePath,\n    parameter,\n    onChangeParameter,\n    parameterValue,\n    isDebug,\n    id,\n    referencableModelData,\n    referencedModelDataIsLoading,\n  } = props;\n\n  /**\n   * By default, the thing is expanded if the parameter is required, or if there is already a parameter value. If it is \"true\" by default, you can also not minimise\n   */\n  const defaultExpandedState = parameter.required ? true : !!parameterValue;\n\n  const [isExpanded, setIsExpanded] = useState(defaultExpandedState);\n\n  if (!parameter.simplifiedSchema) {\n    return null;\n  }\n\n  // we can only render the object if it has properties...\n  if (\n    !parameter.simplifiedSchema.properties ||\n    parameter.simplifiedSchema.properties.length === 0\n  ) {\n    // console.log(\"Object without properties\", { parameter });\n    return isDebug ? (\n      <P className=\"text-red-500\">\n        Object without properties {parameter.name}{\" \"}\n        {JSON.stringify(parameter.simplifiedSchema)}\n      </P>\n    ) : null;\n  }\n\n  // for each parameter, recurse this form builder\n\n  const onChangeSubset = (objectParameterValues: any[]) => {\n    // NB: every item in the array is linked with a parameter in the object\n    const objectParts = parameter.simplifiedSchema?.properties?.map((x, i) => ({\n      [x.name]: objectParameterValues[i],\n    }));\n    const objectOrNot = objectParts\n      ? mergeObjectsArray(objectParts)\n      : undefined;\n\n    onChangeParameter(objectOrNot);\n  };\n\n  const valuesSubset: any[] = parameter.simplifiedSchema.properties.map(\n    (x) => parameterValue?.[x.name]\n  );\n\n  const parameters: RenderableFunctionParameter[] =\n    parameter.simplifiedSchema.properties.map((x) => ({\n      name: x.name,\n      required: x.required,\n      simplifiedSchema: x.schema,\n      isDbModel: parameter.isDbModel,\n    }));\n\n  // console.log({ parameters, parameter, isExpanded });\n\n  const renderExpandButton = () => {\n    if (defaultExpandedState) return null;\n\n    return (\n      <ClickableIcon\n        onClick={() => setIsExpanded(!isExpanded)}\n        emoji={isExpanded ? \"-\" : \"+\"}\n      />\n    );\n  };\n\n  const hasName = parameter.name ? parameter.name.length > 0 : false;\n\n  return (\n    <Div\n      className={\"ml-2 pl-2 my-4 border-l border-gray-900 dark:border-gray-100\"}\n    >\n      {renderParameterTitle(parameter, isDebug, true, () =>\n        renderExpandButton()\n      )}\n\n      {isExpanded ? (\n        <SimplifiedSchemaForm\n          modelName={modelName}\n          itemNameOrId={itemNameOrId}\n          parameterNameStack={\n            hasName\n              ? parameterNameStack\n                ? [...parameterNameStack, parameter.name]\n                : [parameter.name]\n              : parameterNameStack\n          }\n          projectRelativeStorageFilePath={projectRelativeStorageFilePath}\n          isDebug={isDebug}\n          parameters={parameters}\n          onChange={onChangeSubset}\n          values={valuesSubset}\n          // just passing this\n          referencableModelData={referencableModelData}\n          id={id}\n        />\n      ) : null}\n    </Div>\n  );\n}"
  },
  "ReferenceInput": {
    "name": "ReferenceInput",
    "slug": "TsFunction",
    "id": "lsatuqgpqqmoiiewfoshvzfx",
    "description": "This component renders an input to select an item to reference from another model (or multiple)",
    "operationName": "simplified-schema-form",
    "rawText": " (props: {\n  parameter: FunctionParameter;\n  parameterValue: any;\n  onChangeParameter: (newValue: any) => void;\n  referencedModelDataItem: ReferencedModelDataItem;\n  defaultInputFields: {\n    uniqueFieldId: string;\n    fieldName: string;\n  };\n  isDebug?: boolean;\n}) => {\n  const {\n    isDebug,\n    parameter,\n    parameterValue,\n    onChangeParameter,\n    defaultInputFields,\n    referencedModelDataItem,\n  } = props;\n\n  const isLoading = referencedModelDataItem.isLoading;\n\n  const addModelItem = () => {\n    return (\n      <ClickableIcon\n        emoji=\"➕\"\n        onClick={() => {\n          if (typeof window === undefined) return;\n\n          window.open(\n            `upsert/${referencedModelDataItem.interfaceName}`,\n            \"_blank\"\n          );\n        }}\n      />\n    );\n  };\n\n  // selectbox, if referencedModelData is available\n  if (referencedModelDataItem.isReferenceMultipleParameter) {\n    // select multiple\n    const value = (parameterValue || []) as string[];\n\n    const onChangeMultiple = (selected: Item<string>[]) => {\n      const newValue =\n        selected.length === 0 && !parameter.required\n          ? undefined\n          : selected.map((x) => x.value);\n      onChangeParameter(newValue);\n    };\n\n    const options: Item<string>[] =\n      referencedModelDataItem.data\n        ?.map((x) => {\n          const label = x.name || x.id;\n          const value = referencedModelDataItem.keyInModel\n            ? (x[\n                referencedModelDataItem.keyInModel as keyof ReferenceItem\n              ] as string)\n            : undefined;\n          if (!value) return;\n\n          return {\n            value,\n            label,\n          };\n        })\n        .filter(notEmpty) || [];\n\n    const selectedValues = value\n      .map((v) => options.find((x) => x.value === v))\n      .filter(notEmpty);\n\n    return (\n      <Div>\n        {renderParameterTitle(parameter, isDebug, false, addModelItem)}\n        {isLoading ? (\n          <FancyLoader />\n        ) : (\n          <SelectMultipleInput\n            {...defaultInputFields}\n            onChange={onChangeMultiple}\n            value={selectedValues}\n            extra={{\n              options,\n              autoSuggest: options.length > 10,\n            }}\n            config={{}}\n          />\n        )}\n      </Div>\n    );\n  } else {\n    // select single\n\n    // If a referenced model contains the `categoryStack` parameter, this data should be used to group the selectbox. Without categoryStack parameter, simply use the name.\n\n    const value = parameterValue as string | undefined;\n\n    const onChangeSingle = (selected: Item<string> | null) => {\n      const newValue =\n        !selected && !parameter.required ? undefined : selected?.value;\n      onChangeParameter(newValue);\n    };\n\n    const options: Item<string>[] =\n      referencedModelDataItem.data\n        ?.map((x) => {\n          const categoryStack = x.categoryStack;\n\n          const value = referencedModelDataItem.keyInModel\n            ? (x[\n                referencedModelDataItem.keyInModel as keyof ReferenceItem\n              ] as string)\n            : undefined;\n\n          if (!value) return;\n          /**\n           * This must be something. Name is not always there, but ID should be!\n           */\n          const identifier: string = x.name || x.id;\n          const label = categoryStack\n            ? categoryStack.concat(identifier).join(\" › \")\n            : identifier;\n\n          return {\n            value,\n            label,\n          };\n        })\n        .filter(notEmpty) || [];\n\n    const selectValue = value\n      ? {\n          label:\n            referencedModelDataItem.data?.find((x) =>\n              referencedModelDataItem.keyInModel\n                ? x[\n                    referencedModelDataItem.keyInModel as keyof ReferenceItem\n                  ] === value\n                : false\n            )?.name || \"Select an option\",\n          value,\n        }\n      : null;\n\n    const optionsAndFirst: Item<string>[] = [\n      { label: \"Select an option\", value: \"\" },\n    ].concat(options);\n\n    return (\n      <Div>\n        {renderParameterTitle(parameter, isDebug, false, addModelItem)}\n        {isLoading ? (\n          <FancyLoader />\n        ) : (\n          <SelectInput\n            {...defaultInputFields}\n            onChange={onChangeSingle}\n            value={selectValue}\n            extra={{\n              options: optionsAndFirst,\n              autoSuggest: optionsAndFirst.length > 10,\n            }}\n            config={{}}\n          />\n        )}\n      </Div>\n    );\n  }\n}"
  },
  "renderParameterTitle": {
    "name": "renderParameterTitle",
    "slug": "TsFunction",
    "id": "tauhateaeuzzvoklftfeuvwo",
    "description": "",
    "operationName": "simplified-schema-form",
    "rawText": " (\n  parameter: RenderableFunctionParameter,\n  isDebug: boolean | undefined,\n  isBolded?: boolean,\n  renderAdditionalButtons?: () => JSX.Element | null\n) => {\n  const info = getReferenceParameterInfo(parameter.name);\n\n  const title =\n    parameter.simplifiedSchema?.title ||\n    (info.isReferenceParameter\n      ? humanCase(`${info.descriptor || \"\"} ${info.interfaceName}`)\n      : humanCase(parameter.name));\n\n  const descriptionIndicator = parameter.simplifiedSchema?.description\n    ? \" ℹ️\"\n    : \"\";\n  return (\n    <Div>\n      {/* Start of a section */}\n      {parameter.simplifiedSchema?.section ? (\n        <P className=\"font-bold underline\">\n          {parameter.simplifiedSchema?.section}\n        </P>\n      ) : null}\n\n      <Div className=\"w-full flex flex-row justify-between\">\n        <P\n          data-tip={parameter.simplifiedSchema?.description}\n          className={`${\n            parameter.simplifiedSchema?.description\n              ? \"cursor-context-menu\"\n              : \"cursor-default\"\n          }${isBolded ? \" font-bold\" : \"\"}`}\n        >\n          {title}\n          {descriptionIndicator}\n          {/* {parameter.required ? \"(Required)\" : \"(Optional)\"}{\" \"} */}\n        </P>\n\n        {parameter.renderButtons?.(parameter)}\n        {renderAdditionalButtons?.()}\n      </Div>\n      {isDebug ? (\n        <P className=\"italic text-gray-400\">\n          [{parameter.simplifiedSchema?.type}]:{\" \"}\n          <Span className=\"text-gray-600\">\n            {parameter.simplifiedSchema?.fullComment}\n          </Span>\n        </P>\n      ) : null}\n    </Div>\n  );\n}"
  },
  "SimplifiedSchemaForm": {
    "name": "SimplifiedSchemaForm",
    "slug": "TsFunction",
    "id": "qnbdkxrifvdiuwctjmdvwlao",
    "description": "Recursive component that renders a form for a SimplifiedSchema",
    "operationName": "simplified-schema-form",
    "rawText": " <TValues extends any[]>(props: {\n  /** unique id for this form */\n  id: string;\n\n  /**\n   * Stack of parameterNames of parents if the form was loaded as a child (subset) of another form, the first item being the grandest parent.\n   */\n  parameterNameStack?: string[];\n  /**\n   * sometimes you have multiple schemas that you want to put in a form, for example if you have a function that takes multiple parameters\n   */\n  parameters: RenderableFunctionParameter[];\n  /**\n   * the value is a json with the structure of the simplified schema. with this you can also prefill the form\n   *\n   * every item in the value array represents the value of the respective parameter\n   */\n  values: undefined | TValues;\n  onChange: (values: TValues) => void;\n  /**\n   * model data (can be filtered) that can be referenced in the schema. This is used to fill the form select inputs so a value can be selected.\n   *\n   * Only fields needed: name, id, slug\n   */\n  referencableModelData?: ReferencableModelData;\n  /** show more info for devs */\n  isDebug?: boolean;\n  /**\n   * used for showing assets in the textarea view\n   */\n  projectRelativeStorageFilePath?: string;\n  /**\n   * If you're editing or creating an item, this should be its name. Can be used for naming assets\n   *\n   * Preferably, this must be realtime, based on the state of this very form, so the default-name of assets can change with the form state...\n   */\n  itemNameOrId?: string;\n  /**\n   * Must be provided in case an asset is stored in a db model\n   */\n  modelName?: string;\n}) => {\n  const {\n    modelName,\n    itemNameOrId,\n    id,\n    onChange,\n    parameters,\n    values,\n    referencableModelData,\n    projectRelativeStorageFilePath,\n    parameterNameStack,\n    isDebug,\n  } = props;\n\n  useEffect(() => {\n    if (!Array.isArray(values)) {\n      const allUndefined = parameters.map(() => undefined) as TValues;\n      onChange(allUndefined);\n    }\n  }, []);\n\n  if (!values) return null;\n\n  /** helper function to change a single parameter */\n  const onChangeParameter = (index: number, value: any) => {\n    // only change the parameter we need to change\n    const newValues = values.map((v, i) =>\n      i === index ? value : v\n    ) as TValues;\n    onChange(newValues);\n  };\n\n  const parameterNames = parameters.map((x) => x.name);\n\n  // For every parameter we are going to return elements\n  const elements = parameters\n    .map((parameter, index) => {\n      if (!parameter.simplifiedSchema) return;\n      const uniqueFieldId = `${id}.${parameter.name}`;\n\n      /**\n       * values[index]\n       */\n      const parameterValue = values[index];\n      const defaultInputFields = {\n        uniqueFieldId,\n        fieldName: uniqueFieldId,\n      };\n\n      const assetInputType = getAssetInputType(\n        parameter.name,\n        parameter.simplifiedSchema?.type\n      );\n\n      // console.log({\n      //   parameter,\n      //   assetInputType,\n      //   projectRelativeStorageFilePath,\n      // });\n      if (assetInputType && projectRelativeStorageFilePath) {\n        // Something like: [function-name]-[nested]-[property]-[item-name/id]\n        const defaultAssetName = [\n          ...(parameterNameStack || []),\n          singularize(parameter.name),\n          itemNameOrId,\n        ]\n          .filter(notEmpty)\n          .join(\"-\");\n\n        const assetInputExtra: AssetInputType[\"extra\"] = {\n          modelName,\n          defaultAssetName,\n          size: \"lg\" as \"lg\",\n          theme: \"Outlined\" as \"Outlined\",\n          projectRelativeReferencingFilePath: projectRelativeStorageFilePath,\n          attachTokenToFilename: true,\n          allowMultiple: assetInputType.isMultiple,\n          inputTypes:\n            // NB: many things are omitted here since they're still a work in progress\n            assetInputType.type === \"asset\"\n              ? undefined\n              : assetInputType.type === \"audio\"\n              ? [\"recordAudio\", \"files\"]\n              : assetInputType.type === \"file\"\n              ? [\"files\"]\n              : assetInputType.type === \"image\"\n              ? [\"camera\", \"files\"]\n              : assetInputType.type === \"video\"\n              ? [\"files\", \"recordScreen\", \"recordVideo\"]\n              : undefined,\n        };\n\n        return (\n          <Div key={uniqueFieldId}>\n            {renderParameterTitle(parameter, isDebug)}\n\n            <AssetInput\n              value={parameterValue ? makeArray(parameterValue) : []}\n              onChange={(newValue) => {\n                onChangeParameter(index, newValue);\n              }}\n              className=\"w-96\"\n              extra={assetInputExtra}\n              // parameter={parameter}\n              config={{}}\n              fieldName={parameter.name}\n              uniqueFieldId={parameter.name}\n            />\n          </Div>\n        );\n      }\n\n      // First, let's see if the parametername is a reference parameter.\n      const referencedModelDataItem = getReferencedModelDataItem(\n        parameter.name,\n        referencableModelData\n      );\n\n      // console.log({ referencedModelDataItem });\n      if (referencedModelDataItem?.isReferenceParameter) {\n        return (\n          <ReferenceInput\n            key={uniqueFieldId}\n            parameter={parameter}\n            parameterValue={parameterValue}\n            onChangeParameter={(value: any) => onChangeParameter(index, value)}\n            referencedModelDataItem={referencedModelDataItem}\n            defaultInputFields={defaultInputFields}\n            isDebug={isDebug}\n          />\n        );\n      }\n\n      if (parameter.isDbModel && isCalculatedParameter(parameter.name)) {\n        //skip!\n        // NB: if you are wondering how to skip model parameters (e.g. todos when there is a todoSlugs, please check `simplifySchema`, as it has this by default.)\n        return;\n      }\n\n      const possibleReferenceParameterNames =\n        getPossibleReferenceParameterNames(parameter.name);\n      const hasReferenceParameter = !!parameterNames.find((name) =>\n        possibleReferenceParameterNames.includes(name)\n      );\n      // NB: if the property has a model reference, we just need the model reference, not the whole model. This is only for retreiving, it's not present in the database. NB: this is also done when simplifying a schema. Adding it here too is kind of unneccessary if you can assume the schemas are correct, so we should probably remove it later!\n      if (hasReferenceParameter) return;\n\n      if (parameter.simplifiedSchema.type === \"array\") {\n        return (\n          <ArrayForm\n            modelName={modelName}\n            key={uniqueFieldId}\n            parameter={parameter}\n            parameterValue={parameterValue}\n            onChangeParameter={(value: any) => onChangeParameter(index, value)}\n            // passing props\n            itemNameOrId={itemNameOrId}\n            parameterNameStack={parameterNameStack}\n            referencableModelData={referencableModelData}\n            isDebug={isDebug}\n            id={uniqueFieldId}\n            projectRelativeStorageFilePath={projectRelativeStorageFilePath}\n          />\n        );\n      }\n\n      if (parameter.simplifiedSchema.type === \"object\") {\n        return (\n          <ObjectForm\n            modelName={modelName}\n            parameter={parameter}\n            parameterValue={parameterValue}\n            onChangeParameter={(value: any) => onChangeParameter(index, value)}\n            // passing props\n            itemNameOrId={itemNameOrId}\n            parameterNameStack={parameterNameStack}\n            referencableModelData={referencableModelData}\n            isDebug={isDebug}\n            id={uniqueFieldId}\n            key={uniqueFieldId}\n            projectRelativeStorageFilePath={projectRelativeStorageFilePath}\n          />\n        );\n      }\n\n      if (parameter.simplifiedSchema?.type === \"number\") {\n        const value = values[index] as number | null | undefined;\n\n        const onChangeNumber = (newNumber: number | null | undefined) => {\n          const realNewNumber =\n            !parameter.required &&\n            (newNumber === null || newNumber === undefined)\n              ? undefined\n              : newNumber || 0;\n\n          const newValues = values.map((x, i) =>\n            // NB: only change the index we are on\n            i === index ? realNewNumber : x\n          ) as TValues;\n\n          onChange(newValues);\n        };\n\n        return (\n          <Div key={uniqueFieldId}>\n            {renderParameterTitle(parameter, isDebug)}\n            <NumberInput\n              {...defaultInputFields}\n              onChange={onChangeNumber}\n              value={value}\n              extra={{}}\n              config={{}}\n            />\n          </Div>\n        );\n      }\n\n      if (parameter.simplifiedSchema?.type === \"boolean\") {\n        const value = values[index] as boolean | undefined;\n\n        const onChangeBoolean = (newBoolean: boolean) => {\n          const newValues = values.map((x, i) =>\n            // NB: only change the index we are on\n            i === index\n              ? // NB: ony return undefined for an empty string that's not required\n                !parameter.required && newBoolean === false\n                ? undefined\n                : newBoolean\n              : x\n          ) as TValues;\n\n          onChange(newValues);\n        };\n\n        return (\n          <Div key={uniqueFieldId}>\n            <ToggleInput\n              {...defaultInputFields}\n              onChange={onChangeBoolean}\n              value={value || false}\n              extra={{ label: renderParameterTitle(parameter, isDebug) }}\n              config={{}}\n            />\n          </Div>\n        );\n      }\n\n      // NB: only string text left... sometimes it can be markdown though (textArea would be great here)... But we can't see this yet due to indexation\n\n      const value = values[index] as string | undefined;\n\n      if (parameter.simplifiedSchema?.enum) {\n        const onChangeEnum = (newItemValue: string | null) => {\n          const newValues = values.map((x, i) =>\n            // NB: only change the index we are on\n            i === index\n              ? //   NB: ony return undefined for an empty string that's not required\n                !newItemValue\n                ? null\n                : newItemValue\n              : x\n          ) as TValues;\n\n          onChange(newValues);\n        };\n        const enumItems = parameter.simplifiedSchema.enum.map((enumString) => {\n          return {\n            value: String(enumString),\n            label: humanCase(String(enumString)),\n          };\n        });\n\n        const firstEnumValue = parameter.simplifiedSchema?.enum[0];\n        const firstEnumValueString = firstEnumValue\n          ? String(firstEnumValue)\n          : null;\n\n        // NB: we are changing the state here to set the enum to the first value, if it's not specified\n\n        if (value === undefined) {\n          onChangeEnum(firstEnumValueString);\n        }\n        const currentEnumItemValue = value || firstEnumValueString;\n\n        const currentEnumItem = enumItems.find(\n          (x) => x.value === currentEnumItemValue\n        )!;\n\n        return (\n          <Div key={uniqueFieldId}>\n            {renderParameterTitle(parameter, isDebug)}\n\n            <SelectInput\n              {...defaultInputFields}\n              onChange={(item) => onChangeEnum(item?.value || null)}\n              value={currentEnumItem}\n              extra={{ options: enumItems, autoSuggest: enumItems.length > 10 }}\n              config={{}}\n            />\n          </Div>\n        );\n      }\n\n      const onChangeText = (newText: string) => {\n        const newValues = values.map((x, i) =>\n          // NB: only change the index we are on\n          i === index\n            ? //   NB: ony return undefined for an empty string that's not required\n              !parameter.required && newText.length === 0\n              ? undefined\n              : newText\n            : x\n        ) as TValues;\n\n        onChange(newValues);\n      };\n\n      const lastWord = lowerCaseArray(parameter.name).pop()!;\n      const isTextArea = markdownTextParameterNames.includes(lastWord);\n\n      if (isTextArea) {\n        return (\n          <Div key={uniqueFieldId}>\n            {renderParameterTitle(parameter, isDebug)}\n\n            <Div className=\"w-full h-[300px]\">\n              <WriterInput\n                className={`${UI.bareInput} h-[300px] bg-white`}\n                value={value || \"\"}\n                onChange={onChangeText}\n                hideButtons\n                initialWriterView=\"edit\"\n                type=\"markdown\"\n                projectRelativeFilePath={projectRelativeStorageFilePath}\n              />\n            </Div>\n          </Div>\n        );\n      }\n\n      const RightTextInput = passwordTextParameterNames.includes(parameter.name)\n        ? PasswordInput\n        : TextInput;\n\n      return (\n        <Div key={uniqueFieldId}>\n          {renderParameterTitle(parameter, isDebug)}\n\n          <RightTextInput\n            {...defaultInputFields}\n            onChange={onChangeText}\n            value={value || \"\"}\n            extra={{}}\n            config={{}}\n          />\n        </Div>\n      );\n    })\n    .filter(notEmpty);\n\n  return <Div>{elements}</Div>;\n}"
  },
  "useReferencableModelData": {
    "name": "useReferencableModelData",
    "slug": "TsFunction",
    "id": "fchqmedkyvgfdbujpmhwvarh",
    "description": "Hook to retreive `ReferencableModelData` to supply to `SimplifiedSchemaForm`.\n\nUnderwater, this calculates all referencableModelNames for a schema, and then it fetches the `ReferencableItem`[] for every one of those models, using `react-query` `useQuery` hooks\n\nNB: be careful, not to change the simplifiedSchema after using this hook for the first time. This will change the amount of hooks and this can break react!\n\n(it will give `Error: Rendered more hooks than during the previous render`)",
    "operationName": "simplified-schema-form",
    "rawText": " (\n  simplifiedSchema: SimplifiedSchema\n): ReferencableModelData | undefined => {\n  const referencableModelNames = getReferencableModels(simplifiedSchema)\n    ?.map((x) => x.interfaceName)\n    .filter(notEmpty);\n\n  if (!referencableModelNames) return;\n\n  /**\n   * NB: here we just get the referencable model data for the referencable model names in this form. But since they are decoupled, useQuery is caching them, across forms!\n   */\n  const referencableModelDataArray = referencableModelNames\n    .map((dbModelName) => {\n      const realDbModelName = dbModelName as keyof DbModels;\n      const { data: apiResult, isLoading } =\n        queries.useGetReferencableModelData(realDbModelName);\n\n      const data = apiResult?.result;\n\n      return { [dbModelName]: { data, isLoading } };\n    })\n    .filter(notEmpty);\n\n  const referencableModelData: ReferencableModelData | undefined =\n    referencableModelDataArray\n      ? mergeObjectsArray(referencableModelDataArray)\n      : undefined;\n\n  return referencableModelData;\n}"
  },
  "useTsInterfaceForm": {
    "name": "useTsInterfaceForm",
    "slug": "TsFunction",
    "id": "odubpnujgwplzycqemkclpoz",
    "description": "hook to create a form for a TsInterface\n\n# Usage\n\n```ts\nimport { useTsInterfaceForm } from \"simplified-schema-form\";\nimport DatasetConfigJson from \"code-types/db/ts-interfaces/datasetconfig.json\";\nimport { DatasetConfig, TsInterface } from \"code-types\";\nimport { Storing } from \"model-types\";\n\nin your component:\nconst initialValue:DatasetConfig = {} as any;\nconst [Form, value, onChange] = useTsInterfaceForm(DatasetConfigJson as Storing<TsInterface>,initialValue);\n```",
    "operationName": "simplified-schema-form",
    "rawText": " <T extends unknown>(\n  /**\n   * NB: Don't change this! The amount of hooks depends on this\n   */\n  tsInterface: Storing<TsInterface>,\n  id?: string,\n  /**\n   * Only works if set on first render\n   */\n  initialValue?: T,\n  /**\n   * Tell the form where the model will be stored so the form can render assets correctly\n   *\n   * If not given, it is tried to be taken from tthe initialValue (will only work if it's a db-model instance with a `.projectRelativePath`)\n   */\n  projectRelativeStorageFilePath?: string,\n  /**\n   * must be provided in case of a db model\n   */\n  modelName?: string,\n  /**\n   * do something with changes\n   */\n  withValue?: (value: T | undefined) => void\n): [\n  form?: JSX.Element,\n  value?: T | undefined,\n  onChange?: (value: T) => void\n] => {\n  const [realId] = useState(id || `s${String(Math.random())}`);\n  const [values, onChange] = useState<[value: T | undefined]>([initialValue]);\n\n  // NB: only the first item matters\n  const value = values[0];\n  const onChangeValue = (value: T) => {\n    onChange([value]);\n  };\n\n  // NB: we must have the simplifiedSchema, it's not always indexed\n  const simplifiedSchema = tsInterface.type.simplifiedSchema;\n  if (!simplifiedSchema) return [];\n\n  const referencableModelData = useReferencableModelData(simplifiedSchema);\n\n  const form = (\n    <SimplifiedSchemaForm\n      modelName={modelName}\n      key={realId}\n      id={realId}\n      onChange={(values) => {\n        onChange(values);\n        withValue?.(values[0]);\n      }}\n      values={values}\n      itemNameOrId={\n        (value as AugmentedAnyModelType)?.name ||\n        (value as AugmentedAnyModelType)?.id\n      }\n      parameters={[\n        {\n          name: \"\",\n          required: true,\n          simplifiedSchema,\n          isDbModel: true,\n        },\n      ]}\n      projectRelativeStorageFilePath={\n        projectRelativeStorageFilePath ||\n        (initialValue as AnyModelType)?.projectRelativePath\n      }\n      referencableModelData={referencableModelData}\n    />\n  );\n\n  return [form, value, onChangeValue];\n}"
  },
  "sendDailyAlarmSms": {
    "name": "sendDailyAlarmSms",
    "slug": "TsFunction",
    "id": "jywiekayrgizwdjundakyjkr",
    "description": "---\nrunEveryPeriod: hour\n---",
    "operationName": "sms",
    "rawText": " async () => {\n  const now = time().myTimeDate;\n  if (now.getHours() !== 8) {\n    // only 8 pm\n    return;\n  }\n\n  const persona = await getPrimaryPersona();\n  sendSms({ to: persona.phone, body: \"Wake up!\" });\n}"
  },
  "sendSms": {
    "name": "sendSms",
    "slug": "TsFunction",
    "id": "aovamtpaidmcykqkcygbvttl",
    "description": "Send sms\n\nRequires OS Config to have Twilio sid and auth token.\n\nReqruired options: `to` and `body`\n\n`to` is not required, but will overwrite the one you specified in your `OsConfig`",
    "operationName": "sms",
    "rawText": " async (\n  options: MessageListInstanceCreateOptions\n): Promise<MessageInstance | undefined> => {\n  const { from: optionsFrom, ...otherOptions } = options;\n\n  const persona = await getPrimaryPersona();\n\n  if (!persona) {\n    return;\n  }\n\n  const { twilioAccountSid, twilioAuthToken, twilioFromPhoneNumber } = persona;\n\n  if (!twilioAccountSid || !twilioAuthToken) {\n    console.log(\"Please setup your Twilio credentials first\");\n    return;\n  }\n  const twilioClient = twilio(twilioAccountSid, twilioAuthToken);\n\n  const from = optionsFrom || twilioFromPhoneNumber;\n\n  if (!from) {\n    console.log(\n      \"Please provide a phonenumber to sent from, either in your OsConfig or in the sendSms options\"\n    );\n    return;\n  }\n\n  const message = await twilioClient.messages\n    .create({ from, ...otherOptions })\n    .catch((reason) => {\n      console.log(\"Sending sms failed\", { reason });\n\n      return undefined;\n    });\n\n  return message;\n}"
  },
  "objectStringToJson": {
    "name": "objectStringToJson",
    "slug": "TsFunction",
    "id": "roojpihcmyerqhvkdthwkkey",
    "description": "takes an object string and parses it to JSON\n\nInstead of requiring objects to be in JSON format, they can be in the following format:\n\nkey1: value, key2: another value, key3: 9, key4: false, key5: null, key6: { subkey: true, subkey2: 0 }\n\nNB: you can have objects in parameters of objects by surrounding the same syntax with `{` and `}`",
    "operationName": "string-to-json",
    "rawText": " (\n  string: string\n): { [key: string]: JSONValue } => {\n  const chunks = string.split(\",\").map((x) => x.trim());\n  const keyValues = chunks.map((chunk) => {\n    const [key, value] = chunk.split(\":\").map((x) => x.trim());\n    return { [key]: stringToJson(value) };\n  });\n\n  const mergedObject = mergeObjectsArray(keyValues);\n\n  return mergedObject;\n}"
  },
  "parseIfJson": {
    "name": "parseIfJson",
    "slug": "TsFunction",
    "id": "stgasgyqjissrhounylbjsvv",
    "description": "if it's a string with a parsable JSON inside, parse it and return the object/array",
    "operationName": "string-to-json",
    "rawText": " (string: string) => {\n  try {\n    return JSON.parse(string);\n  } catch (e) {\n    return string;\n  }\n}"
  },
  "parsePrimitiveJson": {
    "name": "parsePrimitiveJson",
    "slug": "TsFunction",
    "id": "uiulselzthjqpvqrbfdszxkh",
    "description": "parses a string to a string, number, boolean, null or undefined.\n\noptionally you can chooose to force a type...\n\nTODO: figure out how I can do this without ts-ignores",
    "operationName": "string-to-json",
    "rawText": " <\n  TForceType extends \"string\" | \"number\" | \"boolean\"\n>(\n  value: string,\n  forceType?: TForceType\n): TForceType extends \"string\"\n  ? string | null | undefined\n  : TForceType extends \"number\"\n  ? number | null | undefined\n  : TForceType extends \"boolean\"\n  ? boolean | null | undefined\n  : string | number | boolean | null | undefined => {\n  if (value === \"null\" && !forceType) {\n    // @ts-ignore\n    return null;\n  } else if (value === \"undefined\" && !forceType) {\n    // @ts-ignore\n    return undefined;\n  } else if (value === \"true\" && (!forceType || forceType === \"boolean\")) {\n    // @ts-ignore\n    return true;\n  } else if (value === \"false\" && (!forceType || forceType === \"boolean\")) {\n    // @ts-ignore\n    return false;\n  } else if (!isNaN(Number(value)) && (!forceType || forceType === \"number\")) {\n    // NB: do this after true and false, because they also cast to numbers\n    // @ts-ignore\n    return Number(value);\n  } else {\n    // all that's left is a string\n    // @ts-ignore\n    return value;\n  }\n}"
  },
  "stringToJson": {
    "name": "stringToJson",
    "slug": "TsFunction",
    "id": "lhadvlbvxnasiwbhsdeqwwsh",
    "description": "takes any string, and parses it to JSON\n\nif you provide (nested) objects, make sure to use the following format:\n\nkey1: value, key2: another value, key3: 9, key4: false, key5: null, key6: { subkey: true, subkey2: 0 }",
    "operationName": "string-to-json",
    "rawText": " (value: string, isObject?: boolean): JSONValue => {\n  const seemsObject = value.startsWith(\"{\") && value.endsWith(\"}\");\n  if (seemsObject || isObject) {\n    // Objects\n    // NB: remove first and last character\n    const objectString = seemsObject ? value.slice(1, value.length - 2) : value;\n    return objectStringToJson(objectString);\n  } else if (value.startsWith(\"[\") && value.endsWith(\"]\")) {\n    // Arrays\n    // NB: remove first and last character\n    const arrayString = value.slice(1, value.length - 2);\n    const chunkStrings = arrayString.split(\",\");\n    const chunks = chunkStrings.map((string) => stringToJson(string));\n    return chunks;\n  } else {\n    return parsePrimitiveJson(value);\n  }\n}"
  },
  "SwipeHomepage": {
    "name": "SwipeHomepage",
    "slug": "TsFunction",
    "id": "eqpzribmnctrhpotuxglptia",
    "description": "This homepage component assumes you provide it some CTA's (ideally 2 or 3) and some items.\n\n- The items will be swipable\n- The logo should be available in `public/logo.png`\n\n![Example](../assets/SwipeHomepage.mov)",
    "operationName": "swipe-homepage",
    "rawText": " (props: {\n  ctas: { text: string; href: string }[];\n  items: SwipeItem[];\n}) => {\n  const { ctas, items } = props;\n  const buttonClass =\n    \"bg-white/60 rounded-full hover:bg-white cursor-pointer text-black p-2\";\n\n  return (\n    <Div>\n      <Div className=\"h-screen overflow-auto snap-mandatory snap-y\">\n        {items.map((item, index) => {\n          const finalMarkdown = item.isMarkdownNoLimit\n            ? item.markdown\n            : item.markdown?.substring(0, 500) +\n              ((item.markdown?.length || 0) > 500 ? \"...\" : \"\");\n          const nameSizeClass =\n            item.title.length > 10 ? \"text-2xl\" : \"text-6xl\";\n          return (\n            <Div\n              key={`item${index}`}\n              style={{\n                backgroundImage: item.imagePath\n                  ? `url(\"${item.imagePath}\")`\n                  : undefined,\n                backgroundRepeat: \"no-repeat\",\n                backgroundSize: \"cover\",\n                backgroundPosition: \"center 75%\",\n              }}\n              className={`snap-center h-screen w-screen flex flex-col justify-center relative items-center ${\n                item.imagePath ? \"text-white\" : \"text-black dark:text-white\"\n              }`}\n            >\n              <ALink\n                href={item.href || \"#\"}\n                className={`absolute top-20 left-20 font-bold drop-shadow bg-green-500/20 rounded-md px-4 py-2 backdrop-blur-sm ${nameSizeClass} ${\n                  item.href ? \"cursor-pointer\" : \"cursor-default\"\n                }`}\n              >\n                {item.title}\n              </ALink>\n\n              {item.markdown && item.markdownSourcePath && finalMarkdown ? (\n                <Div className={\"w-[80vw]\"}>\n                  {renderMarkdownContent(finalMarkdown, {\n                    projectRelativeMarkdownFilePath: item.markdownSourcePath,\n                    projectRelativeBaseFolderPath: getFolderJs(\n                      item.markdownSourcePath\n                    ),\n                  })}\n                </Div>\n              ) : null}\n              {item.description ? (\n                <ALink\n                  href={item.href || \"#\"}\n                  className={`absolute bottom-10 mx-4 rounded-md p-6 bg-white/30 backdrop-blur-sm ${\n                    item.href ? \"cursor-pointer\" : \"cursor-default\"\n                  }`}\n                >\n                  {item.description}\n                </ALink>\n              ) : null}\n            </Div>\n          );\n        })}\n      </Div>\n      <Div className=\"z-index-1 absolute bottom-4 w-full flex flex-row justify-around\">\n        {ctas.map((cta) => {\n          return (\n            <ALink href={cta.href} className={buttonClass}>\n              {cta.text}\n            </ALink>\n          );\n        })}\n      </Div>\n\n      <Div className=\"z-index-1 absolute bg-white/60 rounded-full w-12 h-12 top-4 left-4\">\n        <Image src=\"/logo.png\" width={50} height={50} />\n      </Div>\n    </Div>\n  );\n}"
  },
  "tabsStoreInitialValues": {
    "name": "tabsStoreInitialValues",
    "slug": "TsVariable",
    "id": "wkxjctkmfwxnilwirrrkngxi",
    "description": "",
    "operationName": "tabs"
  },
  "Tabs": {
    "name": "Tabs",
    "slug": "TsFunction",
    "id": "bdmetgfouhoepcpguskwbqhj",
    "description": "Container for tabs",
    "operationName": "tabs",
    "rawText": " (props: { title?: string; tabs: TabType[] }) => {\n  const { title, tabs } = props;\n\n  const [currentTab, setCurrentTab] = useStore(\"tabs.currentTab\");\n\n  const buttons: LabeledButtonType[] = tabs.map(({ emoji, title }, index) => {\n    const isActive = currentTab === index;\n    return {\n      emoji,\n      title,\n      onClick: () => {\n        setCurrentTab(index);\n      },\n      isActive,\n    };\n  });\n\n  const activeTab = tabs.find((_, index) => currentTab === index);\n\n  return (\n    <Div className=\"flex flex-col flex-1 p-2 m-2 rounded-xl\">\n      <Div className=\"flex flex-row justify-between items-center\">\n        {title ? <P className=\"text-3xl\">{title}</P> : null}\n        <Div className=\"flex flex-row gap-3\">{buttons.map(LabeledButton)}</Div>\n      </Div>\n\n      {activeTab?.renderTab()}\n    </Div>\n  );\n}"
  },
  "binaryExtensions": {
    "name": "binaryExtensions",
    "slug": "TsVariable",
    "id": "fihpmqlxyycfqoxzpdrtlloh",
    "description": "List of binary file extensions",
    "operationName": "text-or-binary"
  },
  "textExtensions": {
    "name": "textExtensions",
    "slug": "TsVariable",
    "id": "drxzxjzkivjppcidagkfxwtp",
    "description": "List of text file extensions",
    "operationName": "text-or-binary"
  },
  "time": {
    "name": "time",
    "slug": "Operation",
    "operationName": "time"
  },
  "Timeline": {
    "name": "Timeline",
    "slug": "TsFunction",
    "id": "ckzjkrnuzkfyacitwlukxqwa",
    "description": "",
    "operationName": "timeline",
    "rawText": " (props: {\n  items: TimelineItemType[];\n  isHorizontal?: boolean;\n}) => {\n  const { items, isHorizontal } = props;\n  return (\n    <div\n      className={`flex ${\n        isHorizontal ? \"snap-x flex-row\" : \"snap-y flex-col\"\n      } snap-mandatory h-screen w-full mx:auto overflow-scroll`}\n    >\n      {items.map((item, index) => {\n        return (\n          <Div\n            key={`timeline-item-${index}`}\n            className=\"snap-start shrink-0 w-screen h-screen place-items-center\"\n            style={{\n              backgroundImage: item.imageUrl\n                ? `url(\"${item.imageUrl}\")`\n                : undefined,\n              backgroundRepeat: \"no-repeat\",\n              backgroundSize: \"cover\",\n              backgroundPosition: \"center 75%\",\n            }}\n          >\n            {item.component ? (\n              item.component()\n            ) : (\n              <Div\n                className=\"max-w-[80vw]\"\n                onClick={() => {\n                  console.log(\"supposed to open\", item);\n                  api.vscodeOpen({\n                    files: [\n                      {\n                        projectRelativePath: item.projectRelativeFilePath,\n                        line: item.line,\n                      },\n                    ],\n                  });\n                }}\n              >\n                <MarkdownCodeblock\n                  text={item.markdown || \"Nothing to show\"}\n                  isModeStatic\n                  minimalMode=\"scroll\"\n                  extension=\"tsx\"\n                />\n              </Div>\n            )}\n          </Div>\n        );\n      })}\n    </div>\n  );\n}"
  },
  "todoPagesConfigRecencysConst": {
    "name": "todoPagesConfigRecencysConst",
    "slug": "TsVariable",
    "id": "aexciwejecjdyliwlyjvkxgn",
    "description": "",
    "operationName": "todo-types"
  },
  "todoPagesConfigRecencys": {
    "name": "todoPagesConfigRecencys",
    "slug": "TsVariable",
    "id": "dqrhhodprkknqwslphapphrq",
    "description": "",
    "operationName": "todo-types"
  },
  "DEFAULT_HOVER_TIMEOUT_MS": {
    "name": "DEFAULT_HOVER_TIMEOUT_MS",
    "slug": "TsVariable",
    "id": "euzrmbvsdhumdmjgrpikjyym",
    "description": "",
    "operationName": "tooltip"
  },
  "Tooltip": {
    "name": "Tooltip",
    "slug": "TsFunction",
    "id": "lbegmeaplufczhpfwdzsvlnm",
    "description": "",
    "operationName": "tooltip",
    "rawText": " (props: {\n  tooltip: React.ReactElement | null;\n  children: React.ReactNode;\n  hoverTimeout?: number;\n  placement?: Placement;\n}) => {\n  const timeoutMs = props.hoverTimeout || DEFAULT_HOVER_TIMEOUT_MS;\n  const [hoverLink, setHoverLink] = useState(false);\n\n  const [tooltipTimeout, setTooltipTimeout] = useState<NodeJS.Timeout | null>(\n    null\n  );\n  const [linkTimeout, setLinkTimeout] = useState<NodeJS.Timeout | null>(null);\n\n  const btnRef = createRef<HTMLAnchorElement>();\n  const popoverRef = createRef<HTMLSpanElement>();\n  const [hoverTooltip, setHoverTooltip] = useState(false);\n\n  const onEnterLink = () => {\n    if (!btnRef.current || !popoverRef.current) return;\n    createPopper(btnRef.current, popoverRef.current, {\n      placement: props.placement || \"auto\",\n    });\n    setHoverLink(true);\n    if (linkTimeout) {\n      clearTimeout(linkTimeout);\n    }\n  };\n\n  const onLeaveLink = () => {\n    const timeout = setTimeout(() => setHoverLink(false), timeoutMs);\n    setLinkTimeout(timeout);\n  };\n\n  const popoverShow = hoverTooltip || hoverLink;\n\n  const onEnterTooltip = () => {\n    if (tooltipTimeout) {\n      clearTimeout(tooltipTimeout);\n    }\n    setHoverTooltip(true);\n  };\n\n  const onLeaveTooltip = () => {\n    const timeout = setTimeout(() => setHoverTooltip(false), timeoutMs);\n    setTooltipTimeout(timeout);\n  };\n\n  return (\n    <span>\n      {props.tooltip ? (\n        <span\n          onMouseEnter={onEnterTooltip}\n          onMouseLeave={onLeaveTooltip}\n          className={`mb-8 dark:text-gray-100 text-black bg-slate-200 dark:bg-slate-800 p-2 z-30 text-sm max-w-xs break-words rounded-md${\n            popoverShow ? \" block\" : \" hidden\"\n          }`}\n          ref={popoverRef}\n        >\n          {props.tooltip}\n        </span>\n      ) : null}\n      <span onMouseEnter={onEnterLink} onMouseLeave={onLeaveLink} ref={btnRef}>\n        {props.children}\n      </span>\n    </span>\n  );\n}"
  },
  "removeCommentsRegex": {
    "name": "removeCommentsRegex",
    "slug": "TsVariable",
    "id": "odjbdoqauhmkuwezqmmbrwcp",
    "description": "",
    "operationName": "try-parse-json"
  },
  "tryParseJson": {
    "name": "tryParseJson",
    "slug": "TsFunction",
    "id": "srymnyulplryykwbluezodnc",
    "description": "if text isn't json, returns null",
    "operationName": "try-parse-json",
    "rawText": " <T>(\n  text: string,\n  logParseError?: boolean\n): T | null => {\n  try {\n    const jsonStringWithoutComments = text.replace(\n      removeCommentsRegex,\n      (m, g) => (g ? \"\" : m)\n    );\n    return JSON.parse(jsonStringWithoutComments) as T;\n  } catch (parseError) {\n    if (logParseError) console.log(\"JSON Parse error:\", parseError);\n    return null;\n  }\n}"
  },
  "getAllTsMorphSourceFiles": {
    "name": "getAllTsMorphSourceFiles",
    "slug": "TsFunction",
    "id": "mxkspnpqujwbndgxpowhiana",
    "description": "",
    "operationName": "ts-morph-util",
    "rawText": " async (operationBasePath: string) => {\n  const filePaths = await getPackageSourcePaths({\n    operationBasePath,\n  });\n  const project = getTsMorphProject(operationBasePath);\n  if (!project) {\n    log(\"couldn't load project\", { type: \"error\" });\n    return;\n  }\n\n  //select correct SourceFile from tsmorph project\n  const sourceFiles = project.getSourceFiles(filePaths);\n\n  return sourceFiles;\n}"
  },
  "getHasGeneric": {
    "name": "getHasGeneric",
    "slug": "TsFunction",
    "id": "baeuqleymwwhabadcvcyegtx",
    "description": "returns a boolean indicating whether an interface or type has one or more generic arguments",
    "operationName": "ts-morph-util",
    "rawText": " (\n  type: InterfaceDeclaration | TypeAliasDeclaration\n) => {\n  return type.getTypeParameters().length > 0;\n}"
  },
  "getTsMorphProject": {
    "name": "getTsMorphProject",
    "slug": "TsFunction",
    "id": "sbaxrqyfpubxuaptsimtdben",
    "description": "returns a ts-morph Project given a operationFolderPath, if a tsconfig.json can be found",
    "operationName": "ts-morph-util",
    "rawText": " (operationFolderPath: string) => {\n  const tsConfigFilePath = path.join(operationFolderPath, \"tsconfig.json\");\n\n  const tsConfigExists = fs.existsSync(tsConfigFilePath);\n  const srcExists = existsSync(path.join(operationFolderPath, \"src\"));\n  if (!tsConfigExists || !srcExists) {\n    log(\n      `This is not an operation: ${operationFolderPath}. (src folder or tsconfig.json are not present)`,\n      { type: \"error\" }\n    );\n    return;\n  }\n\n  const project = new Project({ tsConfigFilePath, libFolderPath: \"src\" });\n\n  return project;\n}"
  },
  "createCodeblockMarkdown": {
    "name": "createCodeblockMarkdown",
    "slug": "TsFunction",
    "id": "btfgzwauwsnokyrivjedcuil",
    "description": "small util function to create a markdown for a string.",
    "operationName": "ui-util",
    "rawText": " (\n  text: string,\n  /**\n   * Extension that should be used for color highlighting the text\n   *\n   * Set to `null` if you don't want to specify a language\n   *\n   * defaults to \"ts\"\n   */\n  language: string | null = \"ts\"\n) => {\n  return `\n  \\`\\`\\`${language === null ? \"\" : language || \"ts\"}\n  ${text}\n  \\`\\`\\`\n  `;\n}"
  },
  "useCustomUrlStore": {
    "name": "useCustomUrlStore",
    "slug": "TsFunction",
    "id": "xvjkuidwxpqihfikrjptfkuj",
    "description": "---\nisStory: true\n---\n\nHook to store simple data in the URL\n\nI spent the last 4 hours on this: I think it's pretty useful. It's a hook that makes it possible to use your URL as a state store. It works with arrays and single values of strings, booleans and numbers. It's a drop in replacement of useStore or useState. The advantage is that the user can share the URL which will also share their state. Usage in a component looks like this:\n\n```ts\nconst [name, setName] = useUrl(\"name\");\n```\n\nI was looking for ways to make the api more straightforward, especially the stuff in useUrl seems a bit messy. However, I couldn't find any way to make it better. Any tips are welcome!\n\nTODO: make it work in react-native as well, either via a wrapper around useStore or via using the react-navigation param-store\n\n## Example usage\n\n```ts\nimport {useCustomUrlStore}from \"use-url-store\";\n\nexport const useUrl = <T extends keyof typeof queryStore>(queryKey: T) => {\n\nconst queryStore = {\n\"type-index-type\": useCustomUrlStore<string | undefined>(\"type-index-type\", {\ntype: \"string\",\n}),\n\n\"has-comment-types\": useCustomUrlStore<string[]>(\"has-comment-types\", {\ntype: \"string\",\nisArray: true,\n}),\n\"interface-is-db-model\": useCustomUrlStore<boolean>(\"interface-is-db-model\", {\ntype: \"boolean\",\n}),\npath: useCustomUrlStore<string | undefined>(\"path\", { type: \"string\" }),\nname: useCustomUrlStore<string | undefined>(\"name\", { type: \"string\" }),\ntype: useCustomUrlStore<string | undefined>(\"type\", { type: \"string\" }),\n};\n\nreturn queryStore[queryKey];\n};\n```",
    "operationName": "use-url-store",
    "rawText": " <\n  T extends\n    | string\n    | number\n    | boolean\n    | string[]\n    | boolean[]\n    | number[]\n    | undefined\n>(\n  queryKey: string,\n  config: CustomUrlStoreConfig\n): [T, (newValue: T | undefined) => Promise<boolean>] => {\n  const router = useRouter();\n  const queryValue = makeArray(router.query[queryKey]);\n  const parsed = queryValue.map((v) => parsePrimitiveJson(v, config.type));\n\n  const defaultValue =\n    config.type === \"boolean\"\n      ? false\n      : config.type === \"number\"\n      ? 0\n      : config.type === \"string\"\n      ? \"\"\n      : undefined;\n\n  const value = (\n    queryValue.length === 0\n      ? config.isArray\n        ? []\n        : undefined\n      : config.isArray\n      ? parsed\n      : parsed[0]\n      ? parsed[0]\n      : config.allowUndefined\n      ? undefined\n      : defaultValue\n  ) as T;\n\n  const setter = async (newValue: T | undefined) => {\n    const stringified =\n      newValue === undefined\n        ? undefined\n        : Array.isArray(newValue)\n        ? newValue.map((v) => String(v))\n        : [String(newValue)];\n    const queryPart =\n      stringified === undefined ? \"\" : getQueryPart(stringified, queryKey);\n\n    const previousQueryFiltered = { ...router.query };\n    delete previousQueryFiltered[queryKey];\n\n    const keysNow = Object.keys(router.query);\n    const allKeys = keysNow.includes(queryKey)\n      ? keysNow\n      : keysNow.concat(queryKey);\n\n    const newQueryString = allKeys.reduce((queryString, key) => {\n      const prefix = queryString === \"\" ? \"?\" : \"&\";\n\n      if (key === queryKey) {\n        return queryString.concat(prefix + queryPart);\n      }\n\n      if (router.query[key]) {\n        const queryPart = getQueryPart(makeArray(router.query[key]), key);\n        return queryString.concat(prefix + queryPart);\n      }\n\n      return queryString;\n    }, \"\");\n\n    const pushed = await router.push(\n      `${router.pathname}${newQueryString}`,\n      undefined,\n      {\n        shallow: true,\n      }\n    );\n    return pushed;\n  };\n\n  return [value, setter];\n}"
  },
  "getOpenableFilePath": {
    "name": "getOpenableFilePath",
    "slug": "TsFunction",
    "id": "osogznachxnvbvxswduvfxyl",
    "description": "",
    "operationName": "vscode-open",
    "rawText": " async (\n  file: OpenableFile\n): Promise<string | undefined> => {\n  const projectRoot = getProjectRoot();\n\n  if (!projectRoot) return;\n\n  if (file.projectRelativePath)\n    return path.join(projectRoot, file.projectRelativePath);\n\n  if (!file.operationName || !file.operationRelativeFilePath) return;\n\n  const operationBasePath = await getOperationPath(file.operationName);\n  if (!operationBasePath) return;\n\n  const openableFilePath = nodePath.join(\n    operationBasePath,\n    file.operationRelativeFilePath\n  );\n\n  return openableFilePath;\n}"
  },
  "vscodeOpen": {
    "name": "vscodeOpen",
    "slug": "TsFunction",
    "id": "dukbytfeqpiqfaoquwninpri",
    "description": "opens a file in vscode through the \"code\" cli",
    "operationName": "vscode-open",
    "rawText": " async (config: {\n  /**\n  Files to open. Either use a projectRelativePath or an operationName combined with an operationRelativePath.\n  \n  can optionally have the line and character specified as well after the file with [file-path]:[line]:[character]\n   */\n  files?: OpenableFile[];\n}): Promise<undefined | { success: boolean; response: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n\n  if (!config.files) {\n    const command = `code --goto ${projectRoot}`;\n    execSync(command);\n    return { success: true, response: \"Opened the project root\" };\n  }\n\n  await Promise.all(\n    config.files.map(async (file) => {\n      const absolutePath = await getOpenableFilePath(file);\n\n      if (!absolutePath || !fs.existsSync(absolutePath)) {\n        return { success: false, response: \"This path doesn't exist\" };\n      }\n\n      const fullPathWithLine = file.line\n        ? `${absolutePath}:${file.line}`\n        : absolutePath;\n\n      const command = `code --goto ${fullPathWithLine}`;\n\n      execSync(command);\n\n      return { success: true, response: \"Opened the file\" };\n    })\n  );\n\n  return { success: true, response: \"Opened the file(s)\" };\n}"
  },
  "watchAllCli": {
    "name": "watchAllCli",
    "slug": "TsFunction",
    "id": "crwiomwqpvoyriiblfnggrcr",
    "description": "Runs `watchAll`.",
    "operationName": "watch-all",
    "rawText": " () => {\n  watchAll();\n}"
  },
  "watchAll": {
    "name": "watchAll",
    "slug": "TsFunction",
    "id": "ovexwnaoifxgzjqrhrhbskib",
    "description": "👁 👁 Finds all watchers within typerepo and ensures they all start watching their watch",
    "operationName": "watch-all",
    "rawText": " async (config?: {\n  /**\n   * Overwrite the default ignored behavior.\n   *\n   * NB: is not overwriting the startup ignore behavior!\n   */\n  customIgnored?: string[];\n}) => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n\n  // NB: fix to globally alter real fs in order to fix EMFile error that happens in TSMorph (see https://github.com/isaacs/node-graceful-fs)\n  gracefulFs.gracefulify(realFs);\n\n  console.log(\"Searching...\"); //\n  const tsFunctions = await db.get(\"TsFunction\");\n\n  const projectWatcherTsFunctions = tsFunctions.filter(\n    (x) => x.explicitTypeName === \"ProjectWatcher\"\n  );\n\n  const projectWatchers = projectWatcherTsFunctions\n    .map((x) => x.name)\n    .map((name) => sdk[name as keyof typeof sdk] as ProjectWatcher | undefined)\n    .filter(notEmpty);\n\n  log(`${projectWatchers.length} watchers found to watch ${projectRoot}`, {\n    type: \"important\",\n  });\n\n  const startupWaitMs = 1000;\n  setTimeout(() => {\n    log(\n      `There they are! \\n\\n${projectWatchers\n        .map((projectWatcher) => {\n          return `👁 👁 ${projectWatcher.name} ✅`;\n        })\n        .join(\"\\n\")}`,\n      {\n        type: \"success\",\n      }\n    );\n  }, startupWaitMs);\n\n  const startTimeAt = Date.now();\n\n  const recordingsPath = process.env.HOME\n    ? path.resolve(\n        process.env.HOME,\n        \"Library/Application Support/com.apple.voicememos/Recordings\"\n      )\n    : undefined;\n\n  const ignored = config?.customIgnored || [\n    \"**/node_modules/**\",\n    \"**/.next/**\",\n    \"**/.expo/**\",\n    // \"**/build/**\", // build change detection is needed for SDK generation\n    \"**/db/**\",\n    \"**/.git/**\",\n    \"**/.turbo/**\",\n    \"**/generated/**\",\n  ];\n\n  const projectRootFolders = [\n    \"asset\",\n    \"docs\",\n    \"knowledge\",\n    \"operations\",\n    \"text\",\n  ].map((name) => path.join(projectRoot, name));\n\n  const basePath = [...projectRootFolders, recordingsPath].filter(notEmpty);\n\n  // do everything at startup too, as long as a \"startupStrategy\" is declared\n  const startupFiles = (\n    await explore({\n      basePath,\n      ignore: [\n        \"node_modules\",\n        \".next\",\n        \".expo\",\n        \"db\",\n        \"public\",\n        \".git\",\n        \".turbo\",\n        \"generated\",\n      ],\n    })\n  ).map((x) => x.path);\n\n  console.log({ startupFiles: startupFiles.length });\n  const queueItemsBefore = await db.get(\"Queue\");\n\n  // go over every project watcher, add to queue\n  const queueItems = await oneByOne(projectWatchers, async (watcher) => {\n    if (watcher.startupStrategy === \"ignore\" || !watcher.startupStrategy) {\n      console.log(`ignore ${watcher.name}`);\n      return;\n    }\n\n    const thisQueueItemFilePaths = queueItemsBefore\n      .filter((x) => x.functionName === watcher.name)\n      .map((x) => x.parameters[1] as string);\n\n    const realStartupFiles = startupFiles\n      .filter((absolutePath) => {\n        return watcher.filter(\"add\", absolutePath);\n      })\n      .filter((x) => !thisQueueItemFilePaths.includes(x));\n\n    console.log({\n      watcher: watcher.name,\n      filesAlreadyInQueue: thisQueueItemFilePaths.length,\n      filesToBeAddedToQueue: realStartupFiles.length,\n    });\n\n    if (realStartupFiles.length === 0) {\n      return;\n    }\n\n    const newQueueItems = realStartupFiles.map((absolutePath) => {\n      const queue: Creation<Queue> = {\n        functionName: watcher.name,\n        parameters: [\"add\", absolutePath, true],\n      };\n      return queue;\n    });\n\n    return newQueueItems;\n  });\n\n  const newQueueItemsFinal = queueItems.filter(notEmpty).flat();\n\n  const upsertResult = await db.upsert(\"Queue\", newQueueItemsFinal);\n  console.log({\n    queueUpsertResultInsertedAmount: upsertResult,\n    newQueueItemsFinal: newQueueItemsFinal.length,\n  });\n\n  watch(basePath, {\n    ignoreInitial: true,\n    ignored,\n  }).on(\"all\", async (eventName, path) => {\n    const isStartup = Date.now() < startTimeAt + startupWaitMs;\n    if (isStartup) {\n      return;\n    }\n\n    const isOffline = !(await isOnline());\n    const isBusy = await isSystemBusy();\n\n    const relevantWatchers = projectWatchers.filter((watcher) => {\n      const isApplicableWatcher = watcher.filter(eventName, path);\n      if (!isApplicableWatcher) {\n        return false;\n      }\n\n      if (watcher.config?.isInternetRequired && isOffline) {\n        // add to queue because busy\n        db.upsert(\"Queue\", {\n          functionName: watcher.name,\n          parameters: [eventName, path, false],\n        });\n        return false;\n      }\n\n      if (watcher.config?.isHeavy && isBusy) {\n        // add to queue because busy\n\n        db.upsert(\"Queue\", {\n          functionName: watcher.name,\n          parameters: [eventName, path, false],\n        });\n        return false;\n      }\n\n      return true;\n    });\n\n    oneByOne(relevantWatchers, async (projectWatcher) => {\n      console.log(`watchAll: executing ${projectWatcher.name} for ${path}`);\n      await projectWatcher(eventName, path, false);\n    });\n  });\n}"
  },
  "getSubInfo": {
    "name": "getSubInfo",
    "slug": "TsFunction",
    "id": "youqdmwdnfkadjdejtgmbins",
    "description": "",
    "operationName": "watch-folders",
    "rawText": " (subscriptionKey: string) => {\n  const [appKey, rootPath, relativePath] = subscriptionKey.split(\":\");\n\n  if (appKey !== uniqueAppKey) {\n    return;\n  }\n  if (!rootPath) {\n    console.log(\"No rootpath found\", subscriptionKey);\n    return;\n  }\n\n  const fullPath = relativePath ? path.join(rootPath, relativePath) : rootPath;\n\n  return {\n    fullPath,\n    relativePath,\n    rootPath,\n  };\n}"
  },
  "getSubName": {
    "name": "getSubName",
    "slug": "TsFunction",
    "id": "gtsmspdgjlabydxfihfrsqct",
    "description": "",
    "operationName": "watch-folders",
    "rawText": " (watchBaseFolder: string, watchRelativePath?: string) =>\n  `${uniqueAppKey}:${watchBaseFolder}${\n    watchRelativePath ? `:${watchRelativePath}` : \"\"\n  }`"
  },
  "initiateWatch": {
    "name": "initiateWatch",
    "slug": "TsFunction",
    "id": "jimfzalpnbboyrycnkaounlc",
    "description": "",
    "operationName": "watch-folders",
    "rawText": " ({\n  client,\n  debug,\n  folderPath,\n}: {\n  client: watchman.Client;\n  debug: boolean;\n  folderPath: string;\n}) => {\n  client.command([\"watch-project\", folderPath], function (error, resp) {\n    if (error) {\n      console.error(\"Error initiating watch:\", error);\n      return;\n    }\n\n    // It is considered to be best practice to show any 'warning' or\n    // 'error' information to the user, as it may suggest steps\n    // for remediation\n    if (\"warning\" in resp) {\n      console.log(\"Warning initiating watch: \", resp.warning);\n    }\n\n    // `watch-project` can consolidate the watch for your\n    // dir_of_interest with another watch at a higher level in the\n    // tree, so it is very important to record the `relative_path`\n    // returned in resp\n\n    if (debug) {\n      console.log(\n        \"New watch:\",\n        \"watch established on \",\n        resp.relative_path\n          ? path.join(resp.watch, resp.relative_path)\n          : resp.watch\n      );\n    }\n\n    makeSubscription(client, resp.watch, resp.relative_path, debug);\n  });\n}"
  },
  "isClientOk": {
    "name": "isClientOk",
    "slug": "TsFunction",
    "id": "lhobsentipszcyidyjzrngmj",
    "description": "checks if watchman client is ok. ends client if it's not ok",
    "operationName": "watch-folders",
    "rawText": " (client: watchman.Client, debug: boolean) => {\n  return new Promise<void>((resolve, reject) => {\n    client.capabilityCheck(\n      { optional: [], required: [\"relative_root\"] },\n      function (error: any, resp: any) {\n        if (error) {\n          // error will be an Error object if the watchman service is not\n          // installed, or if any of the names listed in the `required`\n          // array are not supported by the server\n          console.error(error);\n          client.end();\n          return reject();\n        }\n        if (debug) {\n          console.log(\"Watchman is ok\", resp);\n        }\n\n        resolve();\n      }\n    );\n  });\n}"
  },
  "isStillPending": {
    "name": "isStillPending",
    "slug": "TsFunction",
    "id": "zwhzrwihwjnpzpihgvwdkjwq",
    "description": "checks if pending has items every 5 seconds, resolves after it hasnt\n\nthis is a handy thing to have in util, but it can also probably be much more simple",
    "operationName": "watch-folders",
    "rawText": " async () => {\n  if (noPending()) return false;\n  //\n  console.log(\"awaiting pending\", pending);\n  //\n  await new Promise<void>((resolve, reject) => {\n    // do this every 5 seconds\n    setInterval(async () => {\n      if (noPending()) {\n        resolve();\n      } else {\n        //console.log(`still pending`, pending);\n      }\n    }, 5000); //\n  }); //\n\n  return;\n}"
  },
  "noPending": {
    "name": "noPending",
    "slug": "TsFunction",
    "id": "gmwnifwjfzdftovxctehpfsx",
    "description": "",
    "operationName": "watch-folders",
    "rawText": " () => pending.length === 0"
  },
  "pending": {
    "name": "pending",
    "slug": "TsVariable",
    "id": "saynekmybqlaishgzhhinvyc",
    "description": "",
    "operationName": "watch-folders"
  },
  "pickWatcher": {
    "name": "pickWatcher",
    "slug": "TsFunction",
    "id": "pkcotsccuhvzwlridrgvqyxj",
    "description": "based on your os, pick either chokidar or fswatch",
    "operationName": "watch-folders",
    "rawText": " () => {\n  if (os.platform() === \"linux\") return watchFoldersChokidar;\n  return watchFoldersFs;\n}"
  },
  "uniqueAppKey": {
    "name": "uniqueAppKey",
    "slug": "TsVariable",
    "id": "hhbhlvgfihlhhjhqkwyuluwm",
    "description": "",
    "operationName": "watch-folders"
  },
  "watchFoldersChokidar": {
    "name": "watchFoldersChokidar",
    "slug": "TsFunction",
    "id": "jfquqziflhsaivkgukjlvzdr",
    "description": "watches folder paths and executes a callback when something changes in one of them\n\nuses fs.watch",
    "operationName": "watch-folders",
    "rawText": " async ({\n  debug = false,\n  folders,\n  onChange,\n  takeLatest,\n}: {\n  debug?: boolean;\n  folders: string[];\n  takeLatest?: boolean;\n  onChange: (event: {\n    eventType: \"rename\" | \"change\";\n    filePaths: string[];\n    operationBasePath: string;\n  }) => Promise<void>;\n}) => {\n  const startTime = Date.now();\n  folders.map((absoluteFolderPath) => {\n    watch(`${absoluteFolderPath}/*`).on(\n      \"all\",\n      async (eventType, absolutePath) => {\n        // NB: in the beginning , all folders/files are firing the \"addDir\" and \"add\" events, this hack prevents that this fires rebuilds for all folders.\n        if (Date.now() < startTime + 1000) return;\n\n        // NB: addDir should not be firing anything\n        if (eventType === \"addDir\") return;\n\n        const stats = await fs.stat(absolutePath);\n        // NB: ensure that the path is not a directory\n        if (stats.isDirectory()) return;\n\n        const srcRelativeFilePath = absolutePath.substring(\n          absoluteFolderPath.length + 1\n        );\n\n        const alreadyPending = pending.filter(\n          (x) => x.filename === srcRelativeFilePath\n        );\n\n        const lastPending = alreadyPending.pop();\n\n        // if a file was just triggered and within a second triggered again, ignore it\n        // same file within a second\n        if (lastPending && Date.now() - lastPending.time < 5000) {\n          log(`double trigger of ${srcRelativeFilePath}, ignoring`, {\n            type: \"warning\",\n          });\n          return;\n        }\n\n        if (alreadyPending.length > 0) {\n          log(`multiple pending of this file, ignoring`, { type: \"warning\" });\n          return;\n        }\n\n        //  await isStillPending();\n\n        // NB: time is also the unique id together with filename\n        const time = Date.now();\n        pending.push({ filename: srcRelativeFilePath, time });\n\n        const basePath = absoluteFolderPath;\n        const operationBasePath = path.join(basePath, \"..\");\n\n        const fullPath = path.join(absoluteFolderPath, srcRelativeFilePath);\n        // TODO: Somehow, it would be great if we could batch changes from multiple files together, so it will execute after there are no changes for more than 30 seconds (or if you press the 'e' button). This will make it more efficient.\n\n        await onChange({\n          operationBasePath,\n          eventType: \"change\",\n          filePaths: [fullPath],\n        });\n\n        // after it's done, remove from the array\n        pending = pending.filter(\n          (p) => p.filename === absolutePath && p.time === time\n        );\n      }\n    );\n  });\n}"
  },
  "watchFoldersFs": {
    "name": "watchFoldersFs",
    "slug": "TsFunction",
    "id": "cefxejdiozzmmtajhkmvlzia",
    "description": "watches folder paths and executes a callback when something changes in one of them\n\nuses fs.watch",
    "operationName": "watch-folders",
    "rawText": " async ({\n  debug = false,\n  folders,\n  onChange,\n  takeLatest,\n}: {\n  debug?: boolean;\n  folders: string[];\n  takeLatest?: boolean;\n  onChange: (event: {\n    eventType: \"rename\" | \"change\";\n    filePaths: string[];\n    operationBasePath: string;\n  }) => Promise<void>;\n}) => {\n  folders.map((folder) => {\n    watch(\n      folder,\n      { recursive: true, encoding: \"utf8\" },\n      async (eventType, filename) => {\n        const alreadyPending = pending.filter((x) => x.filename === filename);\n        const lastPending = alreadyPending.pop();\n\n        // if a file was just triggered and within a second triggered again, ignore it\n        // same file within a second\n        if (lastPending && Date.now() - lastPending.time < 5000) {\n          log(`double trigger of ${filename}, ignoring`, { type: \"warning\" });\n          return;\n        }\n\n        if (alreadyPending.length > 0) {\n          log(`multiple pending of this file, ignoring`, { type: \"warning\" });\n          return;\n        }\n\n        //  await isStillPending();\n\n        // NB: time is also the unique id together with filename\n        const time = Date.now();\n        pending.push({ filename, time });\n\n        const basePath = folder;\n        const operationBasePath = path.join(basePath, \"..\");\n\n        const fullPath = path.join(folder, filename);\n        // TODO: Somehow, it would be great if we could batch changes from multiple files together, so it will execute after there are no changes for more than 30 seconds (or if you press the 'e' button). This will make it more efficient.\n\n        await onChange({\n          operationBasePath,\n          eventType,\n          filePaths: [fullPath],\n        });\n\n        // after it's done, remove from the array\n        pending = pending.filter(\n          (p) => p.filename === filename && p.time === time\n        );\n      }\n    );\n  });\n}"
  },
  "watchFolders": {
    "name": "watchFolders",
    "slug": "TsFunction",
    "id": "dwjmwyokpqgfvukoakteclhr",
    "description": "watches folder paths and executes a callback when something changes in one of them\n\nTODO: check fs/promises.watch, that seems like a simple alternative of this! Could it be? Could it remove the need for watchman?",
    "operationName": "watch-folders",
    "rawText": " async ({\n  debug = false,\n  folders,\n  onChange,\n}: {\n  debug?: boolean;\n  folders: string[];\n  onChange: OnChangeDetected;\n}) => {\n  const client = new watchman.Client();\n  await isClientOk(client, debug);\n  // Initiate watching each folder\n  folders.forEach((folderPath) => initiateWatch({ client, debug, folderPath }));\n\n  // whenever there has been a change detected, this function will be called. Beware, can also be from other watch sources!\n  client.on(\n    \"subscription\",\n    function ({ subscription, files, root }: SubscriptionResponse) {\n      const subInfo = getSubInfo(subscription);\n      if (!subInfo) return;\n      const { fullPath, relativePath, rootPath } = subInfo;\n      const ourWatch = folders.includes(fullPath);\n      if (!ourWatch) return;\n\n      onChange({ fullPath, relativePath, rootPath, files });\n    }\n  );\n}"
  },
  "exitIfOperationsChange": {
    "name": "exitIfOperationsChange",
    "slug": "TsFunction",
    "id": "ixiqjecmrmtyieeviadebhug",
    "description": "every 5 seconds compares if the operationsourcepaths have changed. If so, exits the process",
    "operationName": "watch-operations",
    "rawText": " (\n  allOperationSourcePaths: string[],\n  manualProjectRoot?: string\n) => {\n  setInterval(async () => {\n    const newOperationSourcePaths = await getAllOperationSourcePaths({\n      manualProjectRoot,\n    });\n\n    const isSame = allOperationSourcePaths.reduce(\n      (same, p, i) => (newOperationSourcePaths[i] === p ? same : false),\n      true\n    );\n\n    //TODO: if you change a folder name, it's not detected now.\n    if (!isSame) {\n      log(\"👀 I detected a change in your operations, restarting\", {\n        type: \"warning\",\n      });\n      process.exit();\n    }\n  }, 5000);\n}"
  },
  "gitCommitAllCron": {
    "name": "gitCommitAllCron",
    "slug": "TsFunction",
    "id": "biblgjftqbxrirtdrfnskimh",
    "description": "const pushPosition = async () => {\nconst position = await getLocation();\nif (position) {\npush(\"Position\", {\n...position,\ncreatedAt: Date.now(),\nupdatedAt: Date.now(),\ncreatedFirstAt: Date.now(),\ndeletedAt: 0,\nid: generateId(),\n});\n}\n};\n\nconst pushLight = async () => {\nconst light = 1;\nif (light) {\npush(\"Light\", {\nid: generateId(),\ncreatedFirstAt: Date.now(),\ncreatedAt: Date.now(),\nupdatedAt: Date.now(),\ndeletedAt: 0,\nlight,\n});\n}\n};\n\nconst watchLocation = async () => {\npushPosition();\nsetInterval(() => {\npushPosition();\n}, 60000);\n};\n\nconst watchLight = async () => {\npushLight();\nsetInterval(() => {\npushLight();\n}, 60000);\n};",
    "operationName": "watch-operations",
    "rawText": " (manualProjectRoot?: string) => {\n  setInterval(() => {\n    try {\n      // NB: This doesn't work well with nested .git folders!\n      execSync(\n        \"[[ `git status --porcelain .` ]] && git add . && git commit -m 'Automatic commit'\",\n        { cwd: manualProjectRoot, stdio: \"inherit\" }\n      );\n    } catch {}\n  }, 1000 * 3600);\n}"
  },
  "watchOperations": {
    "name": "watchOperations",
    "slug": "TsFunction",
    "id": "evodhvolcxphnzjdybaianku",
    "description": "watches all operations and does much more",
    "operationName": "watch-operations",
    "rawText": " async (config?: {\n  /**\n   * manual project root where the operations to watch should be located\n   */\n  manualProjectRoot?: string;\n}) => {\n  const manualProjectRoot = config?.manualProjectRoot;\n  const projectRoot = manualProjectRoot || getProjectRoot();\n  // NB: fix to globally alter real fs in order to fix EMFile error that happens in TSMorph (see https://github.com/isaacs/node-graceful-fs)\n  gracefulFs.gracefulify(realFs);\n\n  const allOperationSourcePaths = await getAllOperationSourcePaths({\n    manualProjectRoot,\n  });\n\n  exitIfOperationsChange(allOperationSourcePaths, projectRoot);\n\n  if (!manualProjectRoot) {\n    gitCommitAllCron(projectRoot);\n  }\n\n  log(\n    `Hi, I'm 👁 👁 Watching ${allOperationSourcePaths.length} operations at ${projectRoot}`,\n    { type: \"success\" }\n  );\n\n  const watchFunction = pickWatcher();\n\n  watchFunction({\n    folders: allOperationSourcePaths,\n    debug: true,\n    onChange: async ({ eventType, filePaths, operationBasePath }) => {\n      if (filePaths.length === 0) {\n        return;\n      }\n\n      const filteredFilePaths = filePaths.filter(\n        (x) => !x.endsWith(\"/index.ts\")\n      );\n\n      if (filteredFilePaths.length === 0) {\n        return;\n      }\n\n      log(\n        `OnChange triggered! ${filePaths\n          .map((f) => path.parse(f).name)\n          .join(\",\")}`,\n        {\n          type: \"warning\",\n        }\n      );\n\n      await rebuildOperation({\n        operationBasePath,\n        operationManualProjectRoot: manualProjectRoot,\n        typerepoManualProjectRoot: undefined,\n        filePaths: filteredFilePaths,\n      });\n    },\n  });\n}"
  },
  "crudPageToWebPages": {
    "name": "crudPageToWebPages",
    "slug": "TsFunction",
    "id": "xdczbdiwymqqqetfcaufmaoe",
    "description": "",
    "operationName": "webpage-types",
    "rawText": " (pageData: CrudPage): WebPage<CrudPage>[] => {\n  const dataPage = {\n    pageData,\n    queryPath: `data/${pageData.modelName}`,\n    isMenuHidden: false,\n    menuTitle: humanCase(pageData.modelName),\n  };\n  const upsertOrNot =\n    pageData.canCreate || pageData.canUpdate\n      ? {\n          pageData,\n          queryPath: `upsert/${pageData.modelName}`,\n          isMenuHidden: true,\n        }\n      : undefined;\n\n  return [dataPage, upsertOrNot].filter(notEmpty);\n}"
  },
  "functionFormPageToWebPage": {
    "name": "functionFormPageToWebPage",
    "slug": "TsFunction",
    "id": "cjaiaucumyromvoiustthfqe",
    "description": "",
    "operationName": "webpage-types",
    "rawText": " (\n  pageData: FunctionFormPage\n): WebPage<FunctionFormPage> => {\n  return {\n    pageData,\n    queryPath: `function/${pageData.functionName}`,\n    isMenuHidden: false,\n    menuTitle: humanCase(pageData.functionName),\n  };\n}"
  },
  "writeToAssets": {
    "name": "writeToAssets",
    "slug": "TsFunction",
    "id": "sbncictonzlaibzyatbldste",
    "description": "Writes anything (string or json) the assets folder of the operation of the caller function of this function\n\nUseful for testing",
    "operationName": "write-to-assets",
    "rawText": " async (\n  /**\n   * Insert `__filename` here or the typescript file path\n   */\n  filePath: string,\n  /**\n   * The data you want to write to a file, can also be a promise\n   */\n  data: any,\n  assetsFileName?: string,\n  hideLog?: boolean\n) => {\n  // NB: it may be a promise, so first await it\n  const realData = await data;\n\n  const operationBasePath = findOperationBasePath(filePath);\n  if (!operationBasePath) return;\n\n  const extension = typeof realData === \"string\" ? \".md\" : \".json\";\n\n  const realAssetsFileName =\n    assetsFileName || `${path.parse(filePath).name}${extension}`;\n  const assetsFilePath = path.join(\n    operationBasePath,\n    \"assets\",\n    realAssetsFileName\n  );\n\n  if (!hideLog) {\n    console.log({ assetsFilePath });\n  }\n\n  if (typeof data === \"string\") {\n    return writeStringToFile(assetsFilePath, realData);\n  }\n\n  return writeJsonToFile(assetsFilePath, realData);\n}"
  },
  "copyPath": {
    "name": "copyPath",
    "slug": "TsFunction",
    "id": "jnvexromdbcqvkahnyytckgs",
    "description": "",
    "operationName": "writer-functions",
    "rawText": " async (\n  projectRelativePath: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No project root found\" };\n  }\n\n  const absolutePath = path.join(projectRoot, projectRelativePath);\n\n  if (!fs.existsSync(absolutePath)) {\n    console.log({ absolutePath });\n    return {\n      isSuccessful: false,\n      message: \"This file or folder doesn't exist\",\n    };\n  }\n\n  const parsedPath = path.parse(absolutePath);\n  const copiedPath = path.join(\n    parsedPath.dir,\n    `${parsedPath.name}-copy${parsedPath.ext}`\n  );\n\n  if (fs.existsSync(copiedPath)) {\n    return {\n      isSuccessful: false,\n      message:\n        \"There is already a copy for this file/folder under the anticipated name.\",\n    };\n  }\n\n  await fs.cpAsync(absolutePath, copiedPath, { recursive: true });\n\n  return { isSuccessful: true };\n}"
  },
  "deleteFileOrFolder": {
    "name": "deleteFileOrFolder",
    "slug": "TsFunction",
    "id": "qkljtkbznphznduulpwssaxm",
    "description": "",
    "operationName": "writer-functions",
    "rawText": " async (\n  projectRelativePath: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No project root found\" };\n  }\n\n  const absolutePath = path.join(projectRoot, projectRelativePath);\n\n  if (!fs.existsSync(absolutePath)) {\n    return {\n      isSuccessful: false,\n      message: \"This file or folder doesn't exist\",\n    };\n  }\n\n  await fs.rm(absolutePath, { recursive: true });\n\n  return { isSuccessful: true };\n}"
  },
  "getFileContents": {
    "name": "getFileContents",
    "slug": "TsFunction",
    "id": "arhhbxqbcnkbbfutsyusriiq",
    "description": "Gets the contents of a file in the project",
    "operationName": "writer-functions",
    "rawText": " async (\n  projectRelativeFilePath?: string\n): Promise<{\n  isSuccessful: boolean;\n  message?: string;\n  fileContents?: string;\n}> => {\n  if (!projectRelativeFilePath) {\n    return {\n      isSuccessful: false,\n      message: \"No path\",\n    };\n  }\n  const projectRoot = getProjectRoot();\n\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No project root\" };\n  }\n\n  const absolutePath = path.join(projectRoot, projectRelativeFilePath);\n\n  if (!fs.existsSync(absolutePath)) {\n    return { isSuccessful: false, message: \"File doesn't exist\" };\n  }\n\n  const stats = await fs.stat(absolutePath);\n\n  if (stats.size > 1024 * 1024 || stats.isDirectory()) {\n    return {\n      isSuccessful: false,\n      message: \"That's a directory or bigger than 1MB\",\n    };\n  }\n\n  const fileContents = await fs.readFile(absolutePath, \"utf8\");\n\n  return { fileContents, isSuccessful: true };\n}"
  },
  "getFrontmatterSchema": {
    "name": "getFrontmatterSchema",
    "slug": "TsFunction",
    "id": "wwsgntyfygjxrzlomturnjjz",
    "description": "Gets the frontmatterSchema of any markdown model. This should contain all elements that are required to be in the frontmatter of the markdown",
    "operationName": "writer-functions",
    "rawText": " async (\n  markdownModelName: keyof DbModels | undefined\n): Promise<SimplifiedSchema | undefined> => {\n  if (markdownModelName === undefined) return;\n\n  const tsInterfaces = await db.get(\"TsInterface\");\n  const markdownModelTsInterfaces = tsInterfaces.filter(\n    (x) => x.name === markdownModelName && x.isExported\n  );\n\n  // console.log({ markdownModelTsInterfaces });\n\n  const markdownModelTsInterface = markdownModelTsInterfaces[0];\n\n  if (!markdownModelTsInterface) return;\n\n  const fullSimplifiedSchema = markdownModelTsInterface.type?.simplifiedSchema;\n\n  if (!fullSimplifiedSchema) return;\n\n  const newProperties = fullSimplifiedSchema.properties?.filter(\n    (x) => ![\"markdown\", \"name\"].includes(x.name)\n  );\n\n  const frontmatterSchema: SimplifiedSchema = {\n    ...fullSimplifiedSchema,\n    properties: newProperties,\n  };\n\n  return frontmatterSchema;\n}"
  },
  "getWriterWebPagesMenu": {
    "name": "getWriterWebPagesMenu",
    "slug": "TsFunction",
    "id": "bnohqreekbbpfiepmqspkqhd",
    "description": "",
    "operationName": "writer-functions",
    "rawText": " async () => {\n  const webPages = await getWriterWebPages();\n  return getMenuPagesObject(webPages);\n}"
  },
  "getWriterWebPages": {
    "name": "getWriterWebPages",
    "slug": "TsFunction",
    "id": "uftbosmvpqxmiptqayjycikt",
    "description": "",
    "operationName": "writer-functions",
    "rawText": " async () => {\n  const projectRelativePaths = (await getProjectRelativePaths()) || [];\n\n  const writerWebPages: WriterWebPage[] = projectRelativePaths.map(\n    (projectRelativeFilePath) => {\n      const writerWebPage: WriterWebPage = {\n        pageData: { projectRelativeFilePath },\n        queryPath: projectRelativeFilePath,\n      };\n      return writerWebPage;\n    }\n  );\n\n  return writerWebPages;\n}"
  },
  "movePath": {
    "name": "movePath",
    "slug": "TsFunction",
    "id": "kmjllfuojczhrlbppewnhnql",
    "description": "",
    "operationName": "writer-functions",
    "rawText": " async (\n  /**\n   * Can be file only for now\n   */\n  projectRelativePath: string,\n  projectRelativeNewFolderPath: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No project root found\" };\n  }\n\n  const absolutePath = path.join(projectRoot, projectRelativePath);\n\n  if (!fs.existsSync(absolutePath)) {\n    return {\n      isSuccessful: false,\n      message: \"This file or folder doesn't exist\",\n    };\n  }\n\n  const newAbsolutePath = path.join(\n    projectRoot,\n    projectRelativeNewFolderPath,\n    path.parse(absolutePath).base\n  );\n\n  if (fs.existsSync(newAbsolutePath)) {\n    return { isSuccessful: false, message: \"File or folder already exists\" };\n  }\n\n  await fs.rename(absolutePath, newAbsolutePath);\n\n  return { isSuccessful: true };\n}"
  },
  "newFile": {
    "name": "newFile",
    "slug": "TsFunction",
    "id": "ilvidqjehxwczrdbwkuvpchj",
    "description": "",
    "operationName": "writer-functions",
    "rawText": " async (\n  projectRelativeFilePath: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No project root found\" };\n  }\n\n  const absolutePath = path.join(projectRoot, projectRelativeFilePath);\n\n  if (fs.existsSync(absolutePath)) {\n    return { isSuccessful: false, message: \"This file already exists\" };\n  }\n\n  const folderPath = path.parse(absolutePath).dir;\n\n  if (!fs.existsSync(folderPath)) {\n    return { isSuccessful: false, message: \"Folder doesn't exist\" };\n  }\n\n  await fs.writeFile(absolutePath, \"\", { encoding: \"utf8\" });\n\n  return { isSuccessful: true };\n}"
  },
  "newFolder": {
    "name": "newFolder",
    "slug": "TsFunction",
    "id": "sthnjeosndsmpjyihbmrpdob",
    "description": "",
    "operationName": "writer-functions",
    "rawText": " async (\n  projectRelativeFolderBasePath: string,\n  folderName: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No project root found\" };\n  }\n\n  const absoluteBasePath = path.join(\n    projectRoot,\n    projectRelativeFolderBasePath\n  );\n\n  if (!fs.existsSync(absoluteBasePath)) {\n    return {\n      isSuccessful: false,\n      message: \"This folder basepath doesn't exist\",\n    };\n  }\n\n  const newFolderPath = path.join(absoluteBasePath, folderName);\n\n  if (fs.existsSync(newFolderPath)) {\n    return { isSuccessful: false, message: \"Folder already exists\" };\n  }\n\n  await fs.mkdir(newFolderPath);\n\n  return { isSuccessful: true };\n}"
  },
  "processAssetUpload": {
    "name": "processAssetUpload",
    "slug": "TsFunction",
    "id": "usfevzbbygkyhqrtpreewxyo",
    "description": "Used for the markdown reader to immediately process a asset upload. If we want to validate this, it would be good to allow a second parameter that checks if you have access to the file",
    "operationName": "writer-functions",
    "rawText": " async (assets: BackendAsset[]) => {\n  const processed = (\n    await Promise.all(assets.map((asset) => processAsset(asset)))\n  ).filter(notEmpty);\n\n  return processed;\n}"
  },
  "renameFileOrFolder": {
    "name": "renameFileOrFolder",
    "slug": "TsFunction",
    "id": "emrllwywzvqqoyhskpcwinqu",
    "description": "",
    "operationName": "writer-functions",
    "rawText": " async (\n  projectRelativePath: string,\n  newName: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No project root found\" };\n  }\n\n  const absolutePath = path.join(projectRoot, projectRelativePath);\n\n  if (!fs.existsSync(absolutePath)) {\n    return {\n      isSuccessful: false,\n      message: \"This file doesn't exist\",\n    };\n  }\n\n  const absoluteFolderPath = path.parse(absolutePath).dir;\n\n  const newAbsolutePath = path.join(absoluteFolderPath, newName);\n\n  if (fs.existsSync(newAbsolutePath)) {\n    return { isSuccessful: false, message: \"File/folder already exists\" };\n  }\n\n  await fs.rename(absolutePath, newAbsolutePath);\n\n  return { isSuccessful: true };\n}"
  },
  "saveFileContents": {
    "name": "saveFileContents",
    "slug": "TsFunction",
    "id": "ivlmfvpnsnxjdgavvvsbbnwb",
    "description": "",
    "operationName": "writer-functions",
    "rawText": " async (\n  projectRelativeFilePath: string,\n  newContent: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No project root found\" };\n  }\n\n  const absolutePath = path.join(projectRoot, projectRelativeFilePath);\n\n  if (!fs.existsSync(absolutePath)) {\n    return { isSuccessful: false, message: \"This file does not exist\" };\n  }\n\n  await fs.writeFile(absolutePath, newContent, { encoding: \"utf8\" });\n\n  return {\n    isSuccessful: true,\n  };\n}"
  },
  "trashFileOrFolder": {
    "name": "trashFileOrFolder",
    "slug": "TsFunction",
    "id": "ibsesddfddaapytmdsvaorev",
    "description": "NB: only would work with an ESM module, but I don't have time for this now. Later this could replace `deleteFileOrFolder`",
    "operationName": "writer-functions",
    "rawText": " async (\n  projectRelativePath: string\n): Promise<{ isSuccessful: boolean; message?: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return { isSuccessful: false, message: \"No project root found\" };\n  }\n\n  const absolutePath = path.join(projectRoot, projectRelativePath);\n\n  if (!fs.existsSync(absolutePath)) {\n    return {\n      isSuccessful: false,\n      message: \"This file or folder doesn't exist\",\n    };\n  }\n  // await import(\"trash\").then((trash) => trash.default(absolutePath));\n\n  //await fs.rm(absolutePath, { recursive: true });\n\n  return { isSuccessful: true };\n}"
  },
  "updateFrontmatter": {
    "name": "updateFrontmatter",
    "slug": "TsFunction",
    "id": "oxjfpcnokwacdrkhhczgynhr",
    "description": "Update frontmatter from a markdownfile by overwriting it, keeping old values that you don't change\n\nIf you provide a folder as projectRelativePath, it stores it to README.md in that folder, even if that doens't exist.",
    "operationName": "writer-functions",
    "rawText": " async (config: {\n  projectRelativePath: string;\n  frontmatter: { [key: string]: string };\n}): Promise<{ isSuccessful: boolean; message?: string }> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) {\n    return {\n      isSuccessful: false,\n      message: \"No projectroot\",\n    };\n  }\n\n  const { frontmatter, projectRelativePath } = config;\n\n  const absolutePath = path.join(projectRoot, projectRelativePath);\n\n  const exists = fs.existsSync(absolutePath);\n  if (!exists) {\n    return { isSuccessful: false, message: \"File/folder doensn't exist\" };\n  }\n\n  const pathStats = await fs.stat(absolutePath);\n\n  const isFolder = pathStats.isDirectory();\n\n  const finalAbsolutePath = isFolder\n    ? path.join(absolutePath, \"README.md\")\n    : absolutePath;\n\n  // merge frontmatter with old frontmatter\n\n  const existsFinal = fs.existsSync(finalAbsolutePath);\n\n  const markdownParse = existsFinal\n    ? await readMarkdownFile(finalAbsolutePath)\n    : null;\n  const oldFrontmatter: Frontmatter = existsFinal\n    ? markdownParse?.parameters || {}\n    : {};\n\n  const newFrontmatter: Frontmatter = { ...oldFrontmatter, ...frontmatter };\n\n  const newMarkdownParse: MarkdownParse = markdownParse\n    ? {\n        ...markdownParse,\n        parameters: newFrontmatter,\n      }\n    : {\n        parameters: newFrontmatter,\n        raw: \"\",\n      };\n\n  const string = markdownParseToMarkdownString(newMarkdownParse);\n\n  console.log({ newString: string });\n  await fs.writeFile(finalAbsolutePath, string, \"utf8\");\n  return { isSuccessful: true };\n}"
  },
  "add": {
    "name": "add",
    "slug": "TsFunction",
    "id": "nfnivzkxeeasogmhizcryxkj",
    "description": "The ultimate typescript database stores data in typescript",
    "operationName": "writer-input",
    "rawText": " (a: number, b: number) => a + b"
  },
  "Completion": {
    "name": "Completion",
    "slug": "TsFunction",
    "id": "zeymbexumysidiusynyyykii",
    "description": "",
    "operationName": "writer-input",
    "rawText": " (props: {\n  augmentedWord: AugmentedWord;\n  augmentedWordObject?: MappedObject<AugmentedWord>;\n}) => {\n  const { augmentedWord, augmentedWordObject } = props;\n\n  const projectRelativeMarkdownFilePath =\n    augmentedWord.projectRelativeMarkdownSourcePath;\n  const projectRelativeBaseFolderPath = getFolderJs(\n    projectRelativeMarkdownFilePath\n  )!;\n  return (\n    <Div>\n      <Div className=\"flex flex-row justify-between\">\n        <P>{augmentedWord.word}</P>\n        <Div>(?)</Div>\n      </Div>\n      <P>\n        {augmentedWord.spoiler ? (\n          <MarkdownContent\n            content={augmentedWord.spoiler}\n            config={{\n              projectRelativeMarkdownFilePath,\n              projectRelativeBaseFolderPath,\n              augmentedWordObject,\n              isDev,\n              isStatic: false,\n            }}\n          />\n        ) : null}\n      </P>\n    </Div>\n  );\n}"
  },
  "ContentEditableDivInput": {
    "name": "ContentEditableDivInput",
    "slug": "TsFunction",
    "id": "tyijbaycacyutclmqobieodt",
    "description": "Div that is `contentEditable` by default and has possibilities for color/style highlighting, autocomplete, subtexts and tooltips",
    "operationName": "writer-input",
    "rawText": " <T extends any>(props: {\n  /**\n   * the current raw content of the input\n   */\n  value: string;\n  /**\n   * save your state with this function\n   */\n  onChange: (newValue: string) => void;\n\n  /**\n   * NB: not needed for non-markdown stuff\n   */\n  markdownParseRenderConfig?: MarkdownParseRenderConfig;\n  subwordConfig: SubwordConfig;\n  subtextConfig: SubtextConfig;\n  /**\n   * Your function to parse the raw text into styled text (HTML)\n   *\n   * NB: you can't use react in here, this function needs to return a string!\n   */\n  parseTextContentToHtmlString: ParseTextContentToHtmlString;\n\n  /**\n   * Extra props you want to pass to the main div\n   */\n  divProps: Omit<\n    FinalDivType<T>,\n    \"value\" | \"onChange\" | \"onInput\" | \"contentEditable\"\n  >;\n}) => {\n  const {\n    value,\n    onChange,\n    divProps,\n    parseTextContentToHtmlString,\n    markdownParseRenderConfig,\n    subtextConfig,\n    subwordConfig,\n  } = props;\n\n  useEffect(() => {\n    // NB: `value` changes whenever we call onChange, if the component is used as intended\n    updateEditor(value);\n\n    /**\n     * Every time the value changes, we need to create all click listeners...\n     */\n\n    /**\n     * For every meta clickable, add an event listener for when we click on it.\n     *\n     * If that happens, check if the meta key is enabled.\n     *\n     * If that's true, use the data-href property and go to that URL\n     */\n    const listeners = Array.from(\n      document.getElementsByClassName(metaClickableClassName)\n    )\n      .map((element) => {\n        if (element.tagName !== \"DIV\") return;\n\n        const listener = (clickEvent: MouseEvent) => {\n          if (clickEvent.metaKey) {\n            console.log(\n              \"clicked an image elemen with the metakey enabled... let's go?\",\n              {\n                datasetHref: (element as HTMLDivElement).dataset.href,\n                dataHref: (element as any)[\"data-href\"],\n              }\n            );\n          }\n        };\n        (element as HTMLDivElement).addEventListener(\"click\", listener);\n\n        return { divElement: element as HTMLDivElement, listener };\n      })\n      .filter(notEmpty);\n\n    return () => {\n      /**\n       * Clean up\n       */\n      listeners.map((item) => {\n        const { divElement, listener } = item;\n\n        divElement.removeEventListener(\"click\", listener);\n      });\n    };\n  }, [value]);\n\n  const editor = useRef<HTMLDivElement>(null);\n\n  const getEditorContent = () => {\n    const textSegments = getTextSegments(editor.current);\n\n    const textContent = textSegments.map(({ text }) => text).join(\"\");\n\n    // console.log(\"OK\", { textSegments, textContent });\n    return { textSegments, textContent };\n  };\n\n  /**\n   * Executed every time input changes by user input.\n   *\n   * Ensures the innerHTML is updated for the editor, while the selection stays the same\n   *\n   * NB: to also allow for non-user-based changes, we need to restoreSelection in a different way, probably.\n   */\n  function updateEditor(value: string) {\n    // 1) get selection, segments and the full content (without styling)\n    const selection = window.getSelection();\n    // NB: this never happens I assume\n    if (!selection) return;\n    const { textSegments } = getEditorContent();\n\n    // 2) Use the `textSegments` to find `anchorIndex` and `focusIndex`\n    let anchorIndex: number | null = null;\n    let focusIndex: number | null = null;\n    let currentIndex = 0;\n    textSegments.forEach(({ text, node }) => {\n      if (node.isEqualNode(selection.anchorNode)) {\n        anchorIndex = currentIndex + selection.anchorOffset;\n      }\n      if (node.isEqualNode(selection.focusNode)) {\n        focusIndex = currentIndex + selection.focusOffset;\n      }\n      currentIndex += text.length;\n    });\n\n    if (!editor.current) return;\n\n    const newInnerHTML = parseTextContentToHtmlString(\n      value,\n      \"markdown\",\n      subtextConfig,\n      subwordConfig,\n      markdownParseRenderConfig\n    );\n\n    // console.log({ value, newInnerHTML });\n    // 3) Recalculate the inner HTML of the editor based on the raw text string\n    editor.current.innerHTML = newInnerHTML;\n\n    if (anchorIndex === null || focusIndex === null) return;\n    // 4) restore selection as index of the new string\n    restoreSelection(anchorIndex, focusIndex);\n  }\n\n  /**\n   * Restores selection after updating inner HTML\n   */\n  function restoreSelection(\n    absoluteAnchorIndex: number,\n    absoluteFocusIndex: number\n  ) {\n    const selection = window.getSelection();\n    if (selection === null) return;\n\n    const textSegments = getTextSegments(editor.current);\n    let anchorNode: ChildNode | null = editor.current;\n\n    if (anchorNode === null) return;\n\n    let anchorIndex = 0;\n    let focusNode: ChildNode | null = editor.current;\n\n    if (focusNode === null) return;\n\n    let focusIndex = 0;\n    let currentIndex = 0;\n\n    textSegments.forEach(({ text, node }) => {\n      const startIndexOfNode = currentIndex;\n      const endIndexOfNode = startIndexOfNode + text.length;\n      if (\n        startIndexOfNode <= absoluteAnchorIndex &&\n        absoluteAnchorIndex <= endIndexOfNode\n      ) {\n        anchorNode = node;\n        anchorIndex = absoluteAnchorIndex - startIndexOfNode;\n      }\n      if (\n        startIndexOfNode <= absoluteFocusIndex &&\n        absoluteFocusIndex <= endIndexOfNode\n      ) {\n        focusNode = node;\n        focusIndex = absoluteFocusIndex - startIndexOfNode;\n      }\n\n      currentIndex += text.length;\n    });\n\n    selection.setBaseAndExtent(anchorNode, anchorIndex, focusNode, focusIndex);\n  }\n\n  /**\n   * onInput doesn't always register enters\n   *\n   * onKeyPress is already registered before the content is inside, so that also causes problems.\n   *\n   * onKeyUp seems to be the only event that really works well\n   *\n   * (Only tested in Safari!)\n   */\n  const onKeyUp = () => {\n    // console.log({ innerText: editor.current?.innerText });\n\n    const { textContent } = getEditorContent();\n\n    // NB: editor.current?.innerText would be nice, but it doesn't work because it adds an extra newline...\n    // Besides that, it also is unable to strip certain HTML\n    onChange(textContent);\n  };\n\n  return (\n    <Div>\n      <Div\n        ref={editor}\n        onKeyUp={onKeyUp}\n        contentEditable\n        spellCheck={false}\n        {...divProps}\n      />\n    </Div>\n  );\n}"
  },
  "ContextTextArea": {
    "name": "ContextTextArea",
    "slug": "TsFunction",
    "id": "kardnfouhfkjlusgrjxikxpi",
    "description": "TextArea with ability to enhance personal database and execute prompts\n\n\nQUESTION:\n\nHow to make color highlighting?\n\nI guess we need to wrap all words with a span and make it contenteditable, so we can create a editor where we are styling all words that are written\n\nWe can then also change the value of the word if you are NOT editing that word.\n\nSo you would only see the true value of a word when your cursor is on that word\n\nTODO:\n\n- replace the textarea with a div contenteditable\n- make selectionStart and selectionEnd still working (on the original text)\n- whenever you stop editing a word, it needs to be wrapped with a span and styled with a function taking that word and returning a style\n- whenver you start a new word through a separator, an empty span should be created\n- the span of the current word being edited must have a location (x,y). get that exact location so we can render an autocompletion intellisense",
    "operationName": "writer-input",
    "rawText": " (props: EditorProps) => {\n  const { value, onChange, withContext, className, projectRelativeFilePath } =\n    props;\n\n  const fileType = getFileTypeFromPath(props.projectRelativeFilePath);\n\n  const contextualPromptsQuery = queries.useGetContextualPrompts(\n    fileType === \"other\" ? undefined : fileType\n  );\n\n  const alert = useAlert();\n\n  // EDITOR HOTKEYS\n  useHotkeys([], ({ code, metaKey, ctrlKey, altKey, shiftKey, key }) => {\n    if (code === \"Escape\") {\n      // go out of intellisense\n      alert?.(\"ESCAPE\");\n    }\n\n    if (ctrlKey && code === \"Space\") {\n      // intellisense on\n      alert?.(\"intellisense on\");\n    }\n    if (altKey && code === \"KeyZ\") {\n      if (shiftKey) {\n        alert?.(\"redo\");\n      } else {\n        alert?.(\"undo\");\n      }\n    }\n\n    if (metaKey && key === \"b\") {\n      alert?.(\"bold\");\n    }\n\n    if (metaKey && key === \"i\") {\n      alert?.(\"italic\");\n    }\n  });\n\n  return (\n    <>\n      <div className={className}>\n        <textarea\n          className={className}\n          value={value}\n          onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => {\n            const newText = e.target.value;\n            const positionIndex = e.target.selectionStart;\n            const textEditingContext = getContext({\n              text: newText,\n              positionIndex,\n            });\n            withContext?.(textEditingContext);\n\n            onChange(newText);\n          }}\n        />\n      </div>\n    </>\n  );\n}"
  },
  "depthFontSizes": {
    "name": "depthFontSizes",
    "slug": "TsVariable",
    "id": "uxdkdbgyfgrjpigcurimpvjp",
    "description": "",
    "operationName": "writer-input"
  },
  "DivContentEditable": {
    "name": "DivContentEditable",
    "slug": "TsFunction",
    "id": "zcvkiqaiqnsosrskpbastuqe",
    "description": "",
    "operationName": "writer-input",
    "rawText": " (props: EditorProps) => {\n  const { value, onChange, withContext, className } = props;\n  const contentRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (!contentRef.current) return;\n    contentRef.current.innerText = value;\n  }, [value]);\n\n  return (\n    <Div\n      contentEditable\n      ref={contentRef}\n      className={className}\n      onPaste={() => {\n        // parse all new words into a span per word\n      }}\n      onKeyPress={() => {\n        const innerText = contentRef.current?.innerText || \"\"; //also innerHTML may be useful\n\n        // IDK how to get this, research it\n        const positionIndex = 0;\n\n        const textEditingContext = getContext({\n          text: innerText,\n          positionIndex,\n        });\n\n        withContext?.(textEditingContext);\n\n        onChange(innerText);\n      }}\n    />\n  );\n}"
  },
  "editSubtextSubwordConfig": {
    "name": "editSubtextSubwordConfig",
    "slug": "TsFunction",
    "id": "lcknnutqazenpqdpjcdgpxfo",
    "description": "Interesting... In order to auto-generate a form for this, we need to combine the two into a simple function that does NOTHING. Why? Because we can't store it in the database, it is better to keep this in the frontend...\n\nNB: DEPRECATED: TODO: function isn't used. Since the indexation didn't go right, the solution with a `SimplifiedSchemaForm` ended up being easier. Keeping it here because I need to fix the indexation nonetheless.",
    "operationName": "writer-input",
    "rawText": " (\n  subtextConfig: SubtextConfig,\n  subwordConfig: SubwordConfig\n) => {\n  return { subtextConfig, subwordConfig };\n}"
  },
  "EditWriterInput": {
    "name": "EditWriterInput",
    "slug": "TsFunction",
    "id": "kxqwtzbxgbmgqnvurcuyclre",
    "description": "the newer one, eventually to replace `ContextTextArea`\n<SmartContentEditableDivInput\nwriterType={writerType}\nvalue={value}\nonChange={onChange}\nmarkdownParseRenderConfig={markdownParseRenderConfig}\n/>",
    "operationName": "writer-input",
    "rawText": " (props: {\n  onChange: (value: string) => void;\n  value: string;\n  projectRelativeFilePath: string;\n  markdownModelName?: keyof DbModels;\n}) => {\n  const { onChange, value, projectRelativeFilePath, markdownModelName } = props;\n\n  const fileType = getFileTypeFromPath(projectRelativeFilePath);\n\n  const contextualPromptsQuery = queries.useGetContextualPrompts(\n    fileType === \"other\" ? undefined : fileType\n  );\n  const [lastIndex, setLastIndex] = useState(value.length);\n  const [showAssetUpload, setShowAssetUpload] = useState(false);\n  const toggleAssetUpload = () => setShowAssetUpload(!showAssetUpload);\n\n  const AssetUpload = () => {\n    return (\n      <Div className=\"flex flex-row\">\n        <ClickableIcon\n          emoji={showAssetUpload ? \"❌\" : \"📂\"}\n          onClick={() => toggleAssetUpload()}\n        />\n        {showAssetUpload ? (\n          <Div>\n            {/* @ts-ignore */}\n            <AssetInput\n              config={{}}\n              fieldName=\"upload\"\n              uniqueFieldId=\"upload\"\n              onChange={async (newBackendAssets) => {\n                if (newBackendAssets.length === 0) return;\n\n                // 1) upload to backend and process\n                const apiResult = await api.processAssetUpload(\n                  newBackendAssets\n                );\n                // 2) receive back the actual relativePath\n\n                if (!apiResult.result) {\n                  errorToast(\"Couldn't upload your assets\");\n                  return;\n                }\n\n                const assetsMarkdownString = apiResult.result\n                  .map((backendAsset) => {\n                    return `![${backendAsset.alt || \"\"}](${\n                      backendAsset.relativePath\n                    })`;\n                  })\n                  .join(\"\\n\");\n                // 3) insert those as a snippet in the markdown\n                // console.log({ assetsMarkdownString });\n\n                const before = value.substring(0, lastIndex);\n                const after = value.substring(lastIndex);\n                const newText = `${before}${assetsMarkdownString}${after}`;\n                onChange(newText);\n                toggleAssetUpload();\n              }}\n              extra={{\n                projectRelativeReferencingFilePath: projectRelativeFilePath,\n                defaultAssetName: getFileOrFolderName(projectRelativeFilePath),\n                allowMultiple: true,\n                modelName: markdownModelName,\n                size: \"md\",\n                theme: \"Outlined\",\n              }}\n              value={[]}\n            />\n          </Div>\n        ) : null}\n      </Div>\n    );\n  };\n  return (\n    <Div className=\"w-full h-full flex flex-1 flex-col\">\n      <Div className=\"flex flex-row\">\n        <AssetUpload />\n\n        <FilePromptSelect\n          contextContent={value}\n          context_projectRelativeFilePath={projectRelativeFilePath}\n          items={contextualPromptsQuery.data?.result?.pageContextualPrompts}\n        />\n      </Div>\n\n      <ContextTextArea\n        withContext={(context) => {\n          setLastIndex(context.positionIndex);\n          // console.log(`Context`, context);\n        }}\n        className=\"w-full bg-transparent flex flex-1\"\n        onChange={onChange}\n        value={value}\n        projectRelativeFilePath={projectRelativeFilePath}\n      />\n    </Div>\n  );\n}"
  },
  "FrontmatterForm": {
    "name": "FrontmatterForm",
    "slug": "TsFunction",
    "id": "svwxaynopsvbczxgbuqnrhtb",
    "description": "Renders a form for frontmatter without save button",
    "operationName": "writer-input",
    "rawText": " (props: {\n  modelName?: string;\n  projectRelativeMarkdownFilePath: string;\n  frontmatterSchema: SimplifiedSchema;\n  markdownParse: MarkdownParse;\n  onChange: (value: string) => void;\n}) => {\n  const {\n    onChange,\n    projectRelativeMarkdownFilePath,\n    markdownParse,\n    modelName,\n    frontmatterSchema,\n  } = props;\n  const [immutableFrontmatterSchema] = useState<SimplifiedSchema>(\n    props.frontmatterSchema\n  );\n\n  const referencableModelData = useReferencableModelData(\n    immutableFrontmatterSchema\n  );\n\n  const uploadAssetsThenSetMarkdownString = async (parameters: any[]) => {\n    const [frontmatter] = parameters;\n\n    const assetParameters = findAssetParametersRecursively(frontmatter);\n\n    // NB: because it's too complex and we don't need this in the case of frontmatter, we can just only look at the base level, because frontmatter has just the base level. We therefore skip any items with a stack.\n\n    await Promise.all(\n      assetParameters.map(async (assetParameter) => {\n        if (assetParameter.stack) {\n          console.log(\n            \"WARNING. Stack detected in assetParameters item, shouldn't happen for frontmatter\"\n          );\n          return;\n        }\n        // 1. get the item\n        const item = frontmatter[assetParameter.parameterName] as\n          | BackendAsset\n          | BackendAsset[]\n          | undefined;\n\n        const isCorrectType = typeof item === \"object\";\n        const hasUploaded =\n          item && isCorrectType\n            ? !!makeArray(item).find((x) => x.relativePath)\n            : false;\n        // 2. process if not already\n        const uploadedItem =\n          item && isCorrectType && !hasUploaded\n            ? (await api.processAssetUpload(makeArray(item))).result\n            : item;\n\n        // 3. return uploaded backend-asset\n\n        const newAsset =\n          !uploadedItem || !isCorrectType\n            ? undefined\n            : assetParameter.assetInputType.isMultiple\n            ? makeArray(uploadedItem)\n            : takeFirst(uploadedItem);\n\n        frontmatter[assetParameter.parameterName] = newAsset;\n      })\n    );\n\n    const realFrontmatter: Frontmatter = objectToFrontmatter(\n      frontmatter,\n      frontmatterSchema\n    );\n\n    const newMarkdownParse: MarkdownParse = {\n      ...markdownParse,\n      parameters: realFrontmatter,\n    };\n\n    const newMarkdownString = markdownParseToMarkdownString(newMarkdownParse);\n\n    onChange(newMarkdownString);\n  };\n\n  const frontmatterParse = frontmatterToObject(\n    markdownParse.parameters,\n    frontmatterSchema\n  );\n\n  console.log({ frontmatterParse, frontmatter: markdownParse.parameters });\n\n  return (\n    <SimplifiedSchemaForm\n      modelName={modelName}\n      id={projectRelativeMarkdownFilePath}\n      parameters={[\n        {\n          name: \"Frontmatter\",\n          required: true,\n          isDbModel: true,\n          simplifiedSchema: immutableFrontmatterSchema,\n        },\n      ]}\n      onChange={uploadAssetsThenSetMarkdownString}\n      values={[frontmatterParse]}\n      projectRelativeStorageFilePath={projectRelativeMarkdownFilePath}\n      referencableModelData={referencableModelData}\n    />\n  );\n}"
  },
  "getSubtext": {
    "name": "getSubtext",
    "slug": "TsFunction",
    "id": "avvcouwofnurvkamoblklfdz",
    "description": "make a subtext text based on the text of a complete paragraph (may contain single newlines and other markdown stuff, but never double newlines)\n\nReturns either the subtext string or a HTML string with a container around the subtext, depending on if you provide `withContainer`",
    "operationName": "writer-input",
    "rawText": " (\n  /**\n   * Raw markdown string\n   */\n  markdownString: string,\n  subtextConfig: SubtextConfig\n): string | undefined => {\n  if (!subtextConfig.isEnabled) return;\n\n  const allSubtext = `${subtextConfig.translations?.join(\n    \",\"\n  )} and the text is '${markdownString}'. Let's hook it into translate, and hook up all stuff!`;\n\n  return allSubtext;\n}"
  },
  "getTextSegments": {
    "name": "getTextSegments",
    "slug": "TsFunction",
    "id": "dudamybygghipsbamkddhgjz",
    "description": "Iterates over all child-nodes in the editor, replaces text with a segment, and replaces nodes with a flat list of segments\n\nReturns all textSegments in an array",
    "operationName": "writer-input",
    "rawText": " (element: ChildNode | null): TextSegment[] => {\n  if (element === null) return [];\n\n  const children = Array.from(element.childNodes);\n\n  const textSegments: TextSegment[] = children\n    .map((node) => {\n      if (node.nodeType === Node.TEXT_NODE) {\n        return {\n          text: node.nodeValue || \"\",\n          node,\n        };\n      }\n\n      if (node.nodeType === Node.ELEMENT_NODE) {\n        // NB: not sure which nodes contain ID, but this must work\n\n        if (node.nodeName === \"DIV\") {\n          // NB: because nodeName is DIV, it must be a HTMLDivElement\n          const divElement = node as HTMLDivElement;\n          const isAugmentation = divElement.dataset.isAugmentation === \"true\";\n          if (isAugmentation) return;\n        }\n\n        if (node.nodeName === \"BR\") {\n          return { text: \"\\n\", node };\n        } else {\n          return getTextSegments(node);\n        }\n      }\n\n      return;\n    })\n    .filter(notEmpty)\n    .flat();\n\n  return textSegments;\n}"
  },
  "getWriterTypeFromContent": {
    "name": "getWriterTypeFromContent",
    "slug": "TsFunction",
    "id": "txjhpubuwmgeldixoujotblf",
    "description": "",
    "operationName": "writer-input",
    "rawText": " (text: string): WriterType => {\n  if (isTypescript(text)) return \"typescript\";\n  // NB: json is something else\n  if (tryParseJson(text)) return \"other\";\n  // by default, assume markdown\n  return \"markdown\";\n}"
  },
  "isAugmentedWordMatch": {
    "name": "isAugmentedWordMatch",
    "slug": "TsFunction",
    "id": "ypvikdqieqiyrvohpvieuzge",
    "description": "",
    "operationName": "writer-input",
    "rawText": " (\n  augmentedWord: AugmentedWord,\n  completableWord: string\n) => {\n  if (augmentedWord.isCaseInsensitive) {\n    const isMatch = augmentedWord.word\n      ? augmentedWord.word.toLowerCase().includes(completableWord.toLowerCase())\n      : false;\n    return isMatch;\n  }\n\n  const isMatch = augmentedWord.word\n    ? augmentedWord.word.includes(completableWord)\n    : false;\n  return isMatch;\n}"
  },
  "isTypescript": {
    "name": "isTypescript",
    "slug": "TsFunction",
    "id": "wvohwvmvkvesxjopxoryhfll",
    "description": "only detect typescript if the string starts with `import`. must be improved later on. It would be great to be able to detect that it's a typescript file even if it contains syntax errors.",
    "operationName": "writer-input",
    "rawText": " (text: string) => {\n  return text.startsWith(\"import\");\n}"
  },
  "MarkdownCompletions": {
    "name": "MarkdownCompletions",
    "slug": "TsFunction",
    "id": "jtxlyppmxaocxtaepijwlqrg",
    "description": "",
    "operationName": "writer-input",
    "rawText": " (props: {\n  context: TextEditingContext | null;\n  augmentedWords?: AugmentedWord[];\n  augmentedWordObject?: MappedObject<AugmentedWord>;\n}) => {\n  const { augmentedWords, context, augmentedWordObject } = props;\n\n  /*\n    For `markdown` + `other`:\n  \n    - `@` = people select tooltip\n    - backtick = AugmentedWord from Ts Statements\n    - `![` = AssetInput tooltip\n    - `_`, `*` or `**` is `AugmentedWord` from Word db\n    - `#` should get a list of `Interest`s\n  */\n\n  // const isAsset = context?.wordAtPosition.startsWith(\"![\");\n  const isTypescriptWord = context?.wordAtPosition.startsWith(\"`\");\n  const isPersonWord = context?.wordAtPosition.startsWith(\"@\");\n  const isSpecialWord = specialCharacters.find((startSignal) =>\n    context?.wordAtPosition.startsWith(startSignal)\n  );\n\n  const filteredAugmentedWords = augmentedWords\n    ? isTypescriptWord\n      ? augmentedWords.filter((x) =>\n          [\"operation\", \"bundle\", \"type\", \"function\", \"variable\"].includes(\n            x.type\n          )\n        )\n      : isPersonWord\n      ? augmentedWords.filter((x) => [\"person\"].includes(x.type))\n      : isSpecialWord\n      ? augmentedWords.filter((x) => [\"word\"].includes(x.type))\n      : []\n    : [];\n\n  const completableWord =\n    isTypescriptWord || isPersonWord\n      ? context?.wordAtPosition.slice(1)\n      : isSpecialWord\n      ? omitSpecialCharactersFromStart(context?.wordAtPosition)\n      : undefined;\n\n  const completions = completableWord\n    ? filteredAugmentedWords\n        .filter((augmentedWord) => {\n          const isMatch = isAugmentedWordMatch(augmentedWord, completableWord);\n\n          return isMatch;\n        })\n        .slice(0, MAX_COMPLETIONS_AMOUNT)\n    : [];\n\n  return (\n    <Div>\n      {completions.map((completion, index) => {\n        return (\n          <Completion\n            augmentedWordObject={augmentedWordObject}\n            augmentedWord={completion}\n            key={`completion${index}`}\n          />\n        );\n      })}\n    </Div>\n  );\n}"
  },
  "MarkdownParsePresentation": {
    "name": "MarkdownParsePresentation",
    "slug": "TsFunction",
    "id": "batjdfspqkamcsrlyarxfaod",
    "description": "",
    "operationName": "writer-input",
    "rawText": " (props: {\n  markdownParse: MarkdownParse;\n  augmentedWordObject?: MappedObject<AugmentedWord>;\n  projectRelativeBaseFolderPath: string;\n  projectRelativeMarkdownFilePath: string;\n}) => {\n  const {\n    markdownParse,\n    augmentedWordObject,\n    projectRelativeBaseFolderPath,\n    projectRelativeMarkdownFilePath,\n  } = props;\n  const [slide, setSlide] = useState(0);\n\n  useHotkey(\n    (event) => event.keyCode === 37,\n    () => setSlide((slide) => slide - 1),\n    []\n  );\n  useHotkey(\n    (event) => event.keyCode === 39,\n    () => setSlide((slide) => slide + 1),\n    []\n  );\n\n  if (!markdownParse.content) return null;\n\n  const markdownParagraphs = flattenMarkdownChunks(markdownParse.content);\n\n  const filtered = markdownParagraphs.filter((x) => x.paragraph !== \"\");\n\n  console.log({ markdownParagraphs, filtered });\n\n  const paragraph = filtered[slide];\n\n  if (!paragraph) {\n    return <P>No slides</P>;\n  }\n\n  const navigationIcons: ClickableIconType[] = [\n    {\n      onClick: () => setSlide(0),\n      emoji: \"⏮\",\n      disabled: slide === 0,\n    },\n\n    {\n      onClick: () => setSlide(slide - 1),\n      emoji: \"⬅\",\n      disabled: slide === 0,\n    },\n\n    {\n      onClick: () => setSlide(slide + 1),\n      emoji: \"➡\",\n      disabled: slide === markdownParagraphs.length - 1,\n    },\n\n    {\n      onClick: () => setSlide(markdownParagraphs.length - 1),\n      emoji: \"⏭\",\n      disabled: slide === markdownParagraphs.length - 1,\n    },\n  ];\n  const navigation = (\n    <Div className=\"flex flex-row gap-3\">\n      {navigationIcons.map((item, index) => (\n        <ClickableIcon {...item} key={`icon${index}`} />\n      ))}\n    </Div>\n  );\n\n  const title = paragraph.categoryStack[paragraph.categoryStack.length - 1];\n\n  return (\n    <Div className=\"flex flex-col flex-1\">\n      <Div className=\"flex flex-1 flex-col h-screen\">\n        <Div className=\"flex flex-col justify-center items-center\">\n          <P className=\"text-4xl\">{title}</P>\n\n          <Div className=\"flex flex-row flex-wrap\">\n            {renderBreadCrumbs(paragraph.categoryStack)}\n          </Div>\n        </Div>\n\n        <Div className=\"flex flex-1 flex-col items-center justify-center overflow-y-auto\">\n          <MarkdownContent\n            content={paragraph.paragraph}\n            config={{\n              big: true,\n              projectRelativeBaseFolderPath,\n              projectRelativeMarkdownFilePath,\n              augmentedWordObject,\n              isDev,\n              isStatic: false,\n            }}\n          />\n        </Div>\n      </Div>\n\n      {navigation}\n    </Div>\n  );\n}"
  },
  "MarkdownView": {
    "name": "MarkdownView",
    "slug": "TsFunction",
    "id": "qbemtcrwfalhusakucjrfmgs",
    "description": "",
    "operationName": "writer-input",
    "rawText": " (props: {\n  view: \"view\" | \"presentation\";\n  markdownParse: MarkdownParse;\n  markdownParseRenderConfig: MarkdownParseRenderConfig;\n}) => {\n  const { markdownParse, markdownParseRenderConfig, view } = props;\n\n  const {\n    projectRelativeBaseFolderPath,\n    projectRelativeMarkdownFilePath,\n    augmentedWordObject,\n  } = markdownParseRenderConfig;\n  return (\n    <>\n      {view === \"view\" ? (\n        <Div className=\"mx-2\">\n          {renderMarkdownParse(markdownParse, markdownParseRenderConfig)}\n        </Div>\n      ) : null}\n\n      {view === \"presentation\" ? (\n        <Div className=\"mx-2 flex flex-1 min-h-[80vh]\">\n          {markdownParse.content &&\n          projectRelativeBaseFolderPath &&\n          projectRelativeMarkdownFilePath ? (\n            <MarkdownParsePresentation\n              markdownParse={markdownParse}\n              augmentedWordObject={augmentedWordObject}\n              projectRelativeBaseFolderPath={projectRelativeBaseFolderPath}\n              projectRelativeMarkdownFilePath={projectRelativeMarkdownFilePath}\n            />\n          ) : (\n            \"Couldn't find any content\"\n          )}\n        </Div>\n      ) : null}\n    </>\n  );\n}"
  },
  "MarkedParagraph": {
    "name": "MarkedParagraph",
    "slug": "TsFunction",
    "id": "svxzfimfgxmyrzubiiogeode",
    "description": "",
    "operationName": "writer-input",
    "rawText": " (props) => {\n  const {\n    markdownFileConfig,\n    markedToken,\n    subtextConfig,\n    subwordConfig,\n    testModeEnabled,\n  } = props;\n\n  const endsWithNewline = markedToken.raw.endsWith(\"\\n\");\n\n  const paragraphText = markedToken.tokens.map((token) => (\n    <MarkedToken\n      item={token}\n      subtextConfig={subtextConfig}\n      subwordConfig={subwordConfig}\n      markdownFileConfig={markdownFileConfig}\n      testModeEnabled={testModeEnabled}\n    />\n  ));\n\n  const paragraphSubtextHtmlString = getSubtext(markedToken.raw, subtextConfig);\n\n  return (\n    <div>\n      {paragraphText}\n      {paragraphSubtextHtmlString}\n      {endsWithNewline ? <br /> : null}\n    </div>\n  );\n}"
  },
  "MarkedText": {
    "name": "MarkedText",
    "slug": "TsFunction",
    "id": "wwlhladoxkewqmlrgaisbchr",
    "description": "",
    "operationName": "writer-input",
    "rawText": " (props) => {\n  const {\n    subwordConfig,\n    markdownFileConfig,\n    subtextConfig,\n    markedToken,\n    testModeEnabled,\n  } = props;\n\n  const sentences = markedToken.raw.split(\"\\n\");\n  return (\n    <div>\n      {sentences.map((sentence) => (\n        <div>\n          <SpannedSentence\n            sentence={sentence}\n            subwordConfig={subwordConfig}\n            markdownFileConfig={markdownFileConfig}\n            subtextConfig={subtextConfig}\n            testModeEnabled={testModeEnabled}\n          />\n        </div>\n      ))}\n    </div>\n  );\n}"
  },
  "MarkedToken": {
    "name": "MarkedToken",
    "slug": "TsFunction",
    "id": "fjdpvfozyxotjspesamruncz",
    "description": "Function that can be used to iterate over the marked parse and style every token, recursively\n\nNB: this returns a regular react component, and should, for setting it as InnerHTML, be parsed with the `ReactDOMServer`",
    "operationName": "writer-input",
    "rawText": " (props: {\n  item: marked.Token;\n  subtextConfig: SubtextConfig;\n  subwordConfig: SubwordConfig;\n  markdownFileConfig: MarkdownParseRenderConfig;\n  /**\n   * If enabled, all content will be tested in realtime\n   */\n  testModeEnabled?: boolean;\n}): JSX.Element => {\n  const {\n    item,\n    markdownFileConfig,\n    subtextConfig,\n    subwordConfig,\n    testModeEnabled,\n  } = props;\n\n  if (item.type === \"heading\") {\n    const fontSize = depthFontSizes[item.depth as 1 | 2 | 3 | 4 | 5 | 6 | 7];\n\n    const headingContent =\n      item.tokens && item.tokens.length > 1 ? (\n        `${`#`.repeat(item.depth)} ${item.tokens.map((token) => (\n          <MarkedToken\n            item={token}\n            subtextConfig={subtextConfig}\n            subwordConfig={subwordConfig}\n            markdownFileConfig={markdownFileConfig}\n            testModeEnabled={testModeEnabled}\n          />\n        ))}`\n      ) : (\n        <SpannedSentence\n          sentence={item.raw}\n          subwordConfig={subwordConfig}\n          markdownFileConfig={markdownFileConfig}\n          subtextConfig={subtextConfig}\n        />\n      );\n\n    return (\n      <>\n        <p>\n          <strong style={{ color: \"blue\", fontSize }}>{headingContent}</strong>\n        </p>\n        {getSubtext(item.text, subtextConfig)}\n        <br />\n      </>\n    );\n  }\n\n  if (item.type === \"space\") {\n    // 1 newline splits into two parts here, 5 newlines are 6 parts, so if we omit the first one, we get an array with the length of the amount of newlines\n    const newlines = item.raw.split(\"\\n\").slice(1);\n\n    return (\n      <>\n        {newlines.map(() => (\n          <br />\n        ))}\n      </>\n    );\n  }\n\n  if (item.type === \"blockquote\") {\n    // > ....\n    return (\n      <p>\n        <strong style={{ color: \"blue\" }}>&gt;</strong>\n        <SpannedSentence\n          sentence={item.text}\n          subwordConfig={subwordConfig}\n          markdownFileConfig={markdownFileConfig}\n          subtextConfig={subtextConfig}\n        />\n      </p>\n    );\n  }\n\n  if (item.type === \"paragraph\") {\n    // Paragraph always has tokens?\n    if (testModeEnabled) {\n      testContentEditableRenderComponent(MarkedParagraph, item);\n    }\n\n    return (\n      <MarkedParagraph\n        markedToken={item}\n        subwordConfig={subwordConfig}\n        markdownFileConfig={markdownFileConfig}\n        subtextConfig={subtextConfig}\n      />\n    );\n  }\n\n  if (item.type === \"text\") {\n    if (testModeEnabled) {\n      testContentEditableRenderComponent(MarkedText, item);\n    }\n    return (\n      <MarkedText\n        markedToken={item}\n        subwordConfig={subwordConfig}\n        markdownFileConfig={markdownFileConfig}\n        subtextConfig={subtextConfig}\n      />\n    );\n  }\n\n  if (item.type === \"list\") {\n    return (\n      <>\n        {item.items.map((token) => (\n          <MarkedToken\n            item={token}\n            subtextConfig={subtextConfig}\n            subwordConfig={subwordConfig}\n            markdownFileConfig={markdownFileConfig}\n            testModeEnabled={testModeEnabled}\n          />\n        ))}\n      </>\n    );\n  }\n\n  if (item.type === \"list_item\") {\n    const beforeText = item.raw.split(item.text)[0];\n\n    const text = (\n      <MarkedText\n        markedToken={item}\n        subwordConfig={subwordConfig}\n        subtextConfig={subtextConfig}\n        markdownFileConfig={markdownFileConfig}\n      />\n    );\n\n    return (\n      <>\n        <b style={{ color: \"blue\" }}>{beforeText}</b> {text}\n        <br />\n      </>\n    );\n  }\n\n  if (item.type === \"escape\") {\n    return (\n      <b style={{ color: \"red\" }}>\n        <MarkedText\n          markedToken={item}\n          subwordConfig={subwordConfig}\n          markdownFileConfig={markdownFileConfig}\n          subtextConfig={subtextConfig}\n        />\n      </b>\n    );\n  }\n\n  if (item.type === \"strong\") {\n    return (\n      <b style={{ color: \"blue\" }}>\n        <MarkedText\n          markedToken={item}\n          subwordConfig={subwordConfig}\n          markdownFileConfig={markdownFileConfig}\n          subtextConfig={subtextConfig}\n        />\n      </b>\n    );\n  }\n\n  if (item.type === \"em\") {\n    return (\n      <i style={{ color: \"blue\" }}>\n        <MarkedText\n          markedToken={item}\n          subwordConfig={subwordConfig}\n          markdownFileConfig={markdownFileConfig}\n          subtextConfig={subtextConfig}\n        />\n      </i>\n    );\n  }\n\n  if (item.type === \"image\") {\n    const realSrc = getRealSrc(item.href, markdownFileConfig);\n    return (\n      <div\n        data-href={realSrc}\n        className={metaClickableClassName}\n        data-html=\"true\"\n        data-tip=\"<img src='${realSrc}' width=200 /><br>'Cmd+Click' to open\"\n      >\n        {item.raw}\n      </div>\n    );\n  }\n\n  if (item.type === \"link\") {\n    return (\n      <div\n        data-href={item.href}\n        className={metaClickableClassName}\n        data-html=\"true\"\n        data-tip=\"'Cmd+Click' to open\"\n      >\n        {item.raw}\n      </div>\n    );\n  }\n\n  if (item.type === \"html\") {\n    return (\n      <span style={{ color: \"green\" }}>\n        {item.raw\n          .replaceAll(\"<\", \"&lt;\")\n          .replaceAll(\">\", \"&gt;\")\n          .replaceAll(\"\\n\", \"<br />\")}\n      </span>\n    );\n  }\n\n  if (item.type === \"codespan\") {\n    // Need to add tooltip here for augmented words\n\n    const trimmedWord = trimAround(item.raw, 1);\n\n    return (\n      <span style={{ color: \"orange\" }}>\n        \\`\n        {trimmedWord.split(\" \").map((word) => {\n          const augmentedWord = markdownFileConfig.augmentedWordObject?.[word];\n\n          return (\n            <span\n              data-tip={\n                augmentedWord && augmentedWord.spoiler\n                  ? augmentedWord.spoiler\n                  : undefined\n              }\n            >\n              {word}\n            </span>\n          );\n        })}\n        \\`\n      </span>\n    );\n  }\n\n  if (item.type === \"code\") {\n    return (\n      <span style={{ color: \"orange\" }}>\n        <MarkedText\n          markedToken={item}\n          subwordConfig={subwordConfig}\n          markdownFileConfig={markdownFileConfig}\n          subtextConfig={subtextConfig}\n        />\n      </span>\n    );\n  }\n\n  if (item.type === \"table\") {\n    return (\n      <span style={{ color: \"pink\" }}>\n        <MarkedText\n          markedToken={item}\n          markdownFileConfig={markdownFileConfig}\n          subtextConfig={subtextConfig}\n          subwordConfig={subwordConfig}\n        />\n      </span>\n    );\n  }\n\n  console.log(`unhandled: ${item.type}`, item);\n  return <></>;\n}"
  },
  "MAX_COMPLETIONS_AMOUNT": {
    "name": "MAX_COMPLETIONS_AMOUNT",
    "slug": "TsVariable",
    "id": "sgkejpfqkjzgulxuqbntoutc",
    "description": "",
    "operationName": "writer-input"
  },
  "metaClickableClassName": {
    "name": "metaClickableClassName",
    "slug": "TsVariable",
    "id": "zrccgvhwrnlprdphpfmybvwc",
    "description": "",
    "operationName": "writer-input"
  },
  "omitSpecialCharactersFromStart": {
    "name": "omitSpecialCharactersFromStart",
    "slug": "TsFunction",
    "id": "jtmibavbesyefftbupxvxxlh",
    "description": "Omits all special characters from the start of a word for the first special character it finds. The other special characters found after that won't be trimmed.",
    "operationName": "writer-input",
    "rawText": " (word?: string) => {\n  if (word === undefined) return;\n\n  const finalWord = specialCharacters.reduce(\n    (word, character) => {\n      // NB: if a word was already trimmed from a special character, the other special characters don't need to be trimmed\n      if (word.hasChanged) return word;\n      const newWord = trimLeft(word.word, character);\n      return { word: newWord, hasChanged: word.word !== newWord };\n    },\n    { word, hasChanged: false }\n  );\n\n  return finalWord.word;\n}"
  },
  "parseTextContentToHtmlString": {
    "name": "parseTextContentToHtmlString",
    "slug": "TsFunction",
    "id": "hxnfbdahmpfcheddvdexuxdq",
    "description": "Returns a html string from a text string that can be rendered in the dom\n\nNB: because we're parsing text from div.innerText, sometimes there are two newlines when there should be one break.\n\nThree newlines means there should be two breaks...",
    "operationName": "writer-input",
    "rawText": " (\n  text,\n  type,\n  subtextConfig,\n  subwordConfig,\n  markdownParseRenderConfig\n) => {\n  if (type === \"markdown\" && markdownParseRenderConfig) {\n    const lexed = marked.lexer(text);\n\n    const html = lexed.map((token) => (\n      <MarkedToken\n        item={token}\n        subtextConfig={subtextConfig}\n        subwordConfig={subwordConfig}\n        markdownFileConfig={markdownParseRenderConfig}\n        testModeEnabled={true}\n      />\n    ));\n\n    const result = <>{html}</>;\n\n    const string = ReactDOMServer.renderToString(result);\n\n    return string;\n  }\n\n  return text;\n}"
  },
  "SmartContentEditableDivInput": {
    "name": "SmartContentEditableDivInput",
    "slug": "TsFunction",
    "id": "olggtyxznmfjlxbpzyflcman",
    "description": "Uses ContentEditableDivInput, and attaches the Completions to it based on the content type. Also all other data required...\n\n\nNB: TODO: once the autocomplete inside the contentEditable is done, these things should move inside of there. I need a component that has lots of UI/UX but isn't very smart. This will be able to be re-used in many usecases...",
    "operationName": "writer-input",
    "rawText": " (props: {\n  writerType: WriterType;\n  value: string;\n  onChange: (value: string) => void;\n  markdownParseRenderConfig?: MarkdownParseRenderConfig;\n}) => {\n  const { value, onChange, markdownParseRenderConfig } = props;\n\n  const [subtextConfig] = useStore(\"subtextConfig\");\n  const [subwordConfig] = useStore(\"subwordConfig\");\n\n  useEffect(() => {\n    if (typeof window === \"undefined\") return;\n\n    const getContextMenuInfo = (ev: MouseEvent) => {\n      //ev.preventDefault();\n\n      console.log(\n        \"right click at:\",\n        ev.clientY,\n        ev.clientX,\n        ev.x,\n        ev.y,\n        \"how do we get the word at this position now?\",\n        ev.target\n      );\n\n      // should find a way to get the current word. not sure if this is even feasible if we don't change every word into an element... it may be heavier to change every word into an element, but it certainly makes things easier.\n    };\n\n    // Add eventListner, with it's cleanup...\n    window.addEventListener(\"contextmenu\", getContextMenuInfo);\n    return () => window.removeEventListener(\"contextmenu\", getContextMenuInfo);\n  }, []);\n\n  // const augmentedWordObjectQuery = useGetAugmentedWordObject();\n  // const { data } = useGetAugmentedWords();\n  // const augmentedWords = data?.result;\n  // const augmentedWordObject = augmentedWordObjectQuery.data?.result;\n\n  return (\n    <Div className=\"flex flex-col flex-1\">\n      <ContentEditableDivInput\n        subtextConfig={subtextConfig}\n        subwordConfig={subwordConfig}\n        value={value}\n        onChange={onChange}\n        markdownParseRenderConfig={markdownParseRenderConfig}\n        parseTextContentToHtmlString={parseTextContentToHtmlString}\n        divProps={{\n          style: {\n            padding: 4,\n            margin: 4,\n            width: 400,\n            border: \"1px solid black\",\n          },\n        }}\n      />\n      {/* {writerType === \"typescript\" ? (\n        <TypescriptCompletions\n          context={context}\n          augmentedWords={augmentedWords}\n          augmentedWordObject={augmentedWordObject}\n        />\n      ) : (\n        <MarkdownCompletions\n          context={context}\n          augmentedWords={augmentedWords}\n          augmentedWordObject={augmentedWordObject}\n        />\n      )} */}\n    </Div>\n  );\n}"
  },
  "SpannedSentence": {
    "name": "SpannedSentence",
    "slug": "TsFunction",
    "id": "tyirhrhakprvmzxkoiuhbhgl",
    "description": "Needs to be done for every text that can have potential interactions",
    "operationName": "writer-input",
    "rawText": " (\n  props: Omit<ContentEditableRenderProps<any>, \"markedToken\"> & {\n    sentence: string;\n  }\n) => {\n  const { sentence, subwordConfig } = props;\n  if (!subwordConfig.isEnabled) {\n    // NB: if subwords are disabled, we can just return the sentence using a span (not word by word)\n    return <span>{sentence}</span>;\n  }\n\n  const wordSpans = sentence.split(\" \").map((word) => {\n    return <Subword subwordConfig={subwordConfig} word={word} />;\n  });\n\n  return <>{wordSpans}</>;\n}"
  },
  "specialCharacters": {
    "name": "specialCharacters",
    "slug": "TsVariable",
    "id": "xqnfwsujimovpzkpahvvccjl",
    "description": "",
    "operationName": "writer-input"
  },
  "SubtextContainer": {
    "name": "SubtextContainer",
    "slug": "TsFunction",
    "id": "ybjxudgnqbpqiornqmeqlhhi",
    "description": "Returns a string with HTML for the subtext container, given you already have",
    "operationName": "writer-input",
    "rawText": " (props: {\n  /**\n   * raw markdown that should be converted into a subtext\n   */\n  rawMarkdown: string;\n  subtextConfig: SubtextConfig;\n}) => {\n  const { rawMarkdown, subtextConfig } = props;\n\n  if (!subtextConfig.isEnabled) return null;\n  const subtext = getSubtext(rawMarkdown, subtextConfig);\n  return (\n    <div\n      contentEditable={false}\n      spellCheck={false}\n      autoCorrect=\"false\"\n      data-is-augmentation=\"true\"\n      style={{ fontSize: 8, backgroundColor: \"#CCC\", padding: 5 }}\n    >\n      {subtext}\n    </div>\n  );\n}"
  },
  "Subword": {
    "name": "Subword",
    "slug": "TsFunction",
    "id": "zcwybjglmkxopfkcoliyoqhg",
    "description": "",
    "operationName": "writer-input",
    "rawText": " (props: {\n  word: string;\n  subwordConfig: SubwordConfig;\n}) => {\n  const { word } = props;\n\n  return (\n    <span style={{ borderColor: \"red\", border: 1 }}>\n      <div>{word}</div>\n      <div\n        style={{ color: \"red\", paddingRight: 6 }}\n        contentEditable={false}\n        data-is-augmentation=\"true\"\n      >\n        xxx{word}\n      </div>\n    </span>\n  );\n}"
  },
  "testAllContentEditableRenderComponents": {
    "name": "testAllContentEditableRenderComponents",
    "slug": "TsFunction",
    "id": "uqdsuorvonpvvttuzkzqiqyg",
    "description": "Can be used to test all `ContentEditableRenderComponent`s with example inputs\n\nInstead you can also enable devmode and just check it on the live examples",
    "operationName": "writer-input",
    "rawText": " () => {\n  const allComponents: ContentEditableRenderComponentType<any>[] = [\n    MarkedText,\n    MarkedParagraph,\n  ];\n\n  const results = allComponents.map((component) => {\n    return {\n      name: component.name,\n      isValid: testContentEditableRenderComponent(component),\n    };\n  });\n\n  console.log(results);\n}"
  },
  "testContentEditableRenderComponent": {
    "name": "testContentEditableRenderComponent",
    "slug": "TsFunction",
    "id": "gobpsqzrxxuoaafgorfdnojc",
    "description": "Creates an element from the markdown input, and then uses the `toMarkdownString` function to make it markdown again.\n\nTODO: use <template>, might be more accurate. See https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro/35385518#35385518",
    "operationName": "writer-input",
    "rawText": " <TToken extends marked.Token>(\n  ContentEditableRenderComponent: ContentEditableRenderComponentType<TToken>,\n  /**\n   * For doing a realtime test on real data, provide the markdown string to input into the test\n   */\n  markedToken?: TToken | undefined\n) => {\n  const subwordConfig: SubwordConfig = { isEnabled: false };\n  const subtextConfig: SubtextConfig = { isEnabled: false };\n  const markdownFileConfig: MarkdownParseRenderConfig = {\n    projectRelativeBaseFolderPath: \"\",\n    projectRelativeMarkdownFilePath: \"\",\n  };\n\n  const inputs = markedToken\n    ? [markedToken]\n    : ContentEditableRenderComponent.exampleInputs;\n\n  const invalidArray = inputs\n    .map((input) => {\n      const rendered = (\n        <ContentEditableRenderComponent\n          markedToken={input}\n          subwordConfig={subwordConfig}\n          subtextConfig={subtextConfig}\n          markdownFileConfig={markdownFileConfig}\n          // NB: lol, this would cause an infinite loop if enabled, no?\n          testModeEnabled={false}\n        />\n      );\n\n      const htmlString = ReactDOMServer.renderToString(rendered);\n      const span = document.createElement(\"span\");\n      span.innerHTML = htmlString.trim();\n\n      const output = ContentEditableRenderComponent.toMarkdownString(span);\n\n      const isValid = input.raw === output;\n\n      return { isValid, input, output, span };\n    })\n    .filter((result) => !result.isValid);\n\n  if (invalidArray.length === 0) return true;\n\n  // Log the result if there is something invalid\n  console.log({ name: ContentEditableRenderComponent.name, invalidArray });\n\n  return false;\n}"
  },
  "TitleContainer": {
    "name": "TitleContainer",
    "slug": "TsFunction",
    "id": "fmgtnuiicllxnrajzbjmyblv",
    "description": "container for any index instance that needs to be rendered in the explore page",
    "operationName": "writer-input",
    "rawText": " ({\n  title,\n  children,\n  buttons,\n}: {\n  title?: string;\n  children: any;\n  buttons: LabeledButtonType[];\n}) => {\n  return (\n    <Div className=\"p-2 m-2 border rounded-xl border-gray-500\">\n      <Div className=\"flex flex-row justify-between items-center\">\n        {title ? <P className=\"text-3xl\">{title}</P> : <Div />}\n\n        <Div className=\"flex flex-row gap-3\">\n          {buttons.filter((x) => x.isEnabled !== false).map(LabeledButton)}\n        </Div>\n      </Div>\n\n      {children}\n    </Div>\n  );\n}"
  },
  "trimAround": {
    "name": "trimAround",
    "slug": "TsFunction",
    "id": "ozotbvdqomvspdoduemnxced",
    "description": "Removes x amount of characters from both sides of a word",
    "operationName": "writer-input",
    "rawText": " (word: string, trimLength: number): string => {\n  return word.slice(trimLength, word.length - trimLength);\n}"
  },
  "trimLeft": {
    "name": "trimLeft",
    "slug": "TsFunction",
    "id": "xcwnrekuertzlbeyuxxyaqdc",
    "description": "Trims a character from a word at the left until that character is not found anymore (recursive)",
    "operationName": "writer-input",
    "rawText": " (word: string, character: string): string => {\n  if (word.startsWith(character))\n    return trimLeft(word.slice(character.length), character);\n  return word;\n}"
  },
  "TypescriptCompletions": {
    "name": "TypescriptCompletions",
    "slug": "TsFunction",
    "id": "qcliawclezchprskmlzcbfld",
    "description": "In `typescript`, every word should be autocompletable with the typescript stuff, without backticks.",
    "operationName": "writer-input",
    "rawText": " (props: {\n  context: TextEditingContext | null;\n  augmentedWords?: AugmentedWord[];\n  augmentedWordObject?: MappedObject<AugmentedWord>;\n}) => {\n  const { augmentedWords, context, augmentedWordObject } = props;\n\n  const filteredAugmentedWords =\n    augmentedWords?.filter((x) =>\n      [\"operation\", \"bundle\", \"type\", \"function\", \"variable\"].includes(x.type)\n    ) || [];\n\n  const completableWord = context?.wordAtPosition;\n\n  const completions = completableWord\n    ? filteredAugmentedWords\n        .filter((augmentedWord) => {\n          const isMatch = isAugmentedWordMatch(augmentedWord, completableWord);\n\n          return isMatch;\n        })\n        .slice(0, MAX_COMPLETIONS_AMOUNT)\n    : [];\n\n  return (\n    <Div>\n      {completions.map((completion, index) => {\n        return (\n          <Completion\n            augmentedWordObject={augmentedWordObject}\n            augmentedWord={completion}\n            key={`completion${index}`}\n          />\n        );\n      })}\n    </Div>\n  );\n}"
  },
  "{ vscodeOpen }": {
    "name": "{ vscodeOpen }",
    "slug": "TsVariable",
    "id": "dylowvcidrjpxlapegpzeeas",
    "description": "",
    "operationName": "writer-input"
  },
  "WriterConfigForm": {
    "name": "WriterConfigForm",
    "slug": "TsFunction",
    "id": "tzzyrmeuuzslsbqgzzpemlho",
    "description": "",
    "operationName": "writer-input",
    "rawText": " () => {\n  const [subtextConfig, setSubtextConfig] = useStore(\"subtextConfig\");\n  const [subwordConfig, setSubwordConfig] = useStore(\"subwordConfig\");\n\n  const values: WriterConfigFormValue = [subtextConfig, subwordConfig];\n\n  return (\n    <Div>\n      <SimplifiedSchemaForm\n        id=\"writerConfig\"\n        onChange={(values) => {\n          const [newSubtextConfig, newSubwordConfig] =\n            values as WriterConfigFormValue;\n          setSubtextConfig(newSubtextConfig);\n          setSubwordConfig(newSubwordConfig);\n        }}\n        parameters={[\n          {\n            name: \"SubtextConfig\",\n            required: true,\n            isDbModel: false,\n            simplifiedSchema: SubtextConfigIndex.type\n              .simplifiedSchema as SimplifiedSchema,\n          },\n          {\n            name: \"SubwordConfig\",\n            required: true,\n            isDbModel: false,\n            simplifiedSchema: SubwordConfigIndex.type\n              .simplifiedSchema as SimplifiedSchema,\n          },\n        ]}\n        values={values}\n      />\n    </Div>\n  );\n}"
  },
  "writerInitialValues": {
    "name": "writerInitialValues",
    "slug": "TsVariable",
    "id": "dsoogcttgeknntvsqstfozhl",
    "description": "",
    "operationName": "writer-input"
  },
  "WriterInput": {
    "name": "WriterInput",
    "slug": "TsFunction",
    "id": "kdnunpoiyibuykyxplqzcfns",
    "description": "Writer input for any utf8 based text, file or no file",
    "operationName": "writer-input",
    "rawText": " (props: {\n  /**\n   * boolean indicating whether or not the file has already been saved\n   *\n   * If false, save button will be shown\n   */\n  isSaved?: boolean;\n  /**\n   * function to save the file\n   *\n   * If given, will render a button to save the file\n   */\n  save?: () => void;\n  /**\n   * Provide a MappedObject of `AugmentedWord`s here to allow for autocomplete intellisense type stuff\n   */\n  augmentedWordObject?: MappedObject<AugmentedWord>;\n  /**\n   * The text to edit\n   */\n  value: string;\n\n  /**\n   * can refer to a modelname in case you have frontmatter in that model that needs to be formified\n   */\n  markdownModelName?: keyof DbModels;\n  /**\n   * Callback called when text changes\n   */\n  onChange: (value: string) => void;\n  /**\n   * Force the type of content\n   */\n  type?: WriterType;\n  /**\n   * If you provide the path to the edited file here, it will infer the type of data in the file (typescript, markdown, etc) from it\n   *\n   * Besides this, it is required to show assets, as we need to know where the file is stored so we can know where the relative assets should be resolved.\n   */\n  projectRelativeFilePath?: string;\n  /**\n   * A function to reload the content\n   *\n   * If given, will show this button to reload the text manually\n   */\n  reload?: () => void;\n  /**\n   * Boolean indicating whether or not this thing is loading (content is still not there)\n   */\n  isLoading?: boolean;\n\n  /**\n   * if true, hides buttons\n   */\n  hideButtons?: boolean;\n  /**\n   * classname for the container\n   */\n  className?: string;\n\n  /**\n   * If given, forces the writerview to this value instead of using the current writerViewStore value\n   */\n  initialWriterView?: WriterViewEnum;\n  disabledMenuItems?: string[];\n}) => {\n  const [writerView, setWriterView] = useStore(\"writerView\");\n\n  const {\n    type,\n    projectRelativeFilePath,\n    reload,\n    value,\n    onChange,\n    markdownModelName,\n    initialWriterView,\n    augmentedWordObject,\n    isLoading,\n    save,\n    isSaved,\n    hideButtons,\n    className,\n    disabledMenuItems,\n  } = props;\n\n  const projectRelativeBaseFolderPath = getFolderJs(projectRelativeFilePath);\n  const projectRelativeMarkdownFilePath = projectRelativeFilePath;\n\n  useEffect(() => {\n    if (initialWriterView) {\n      setWriterView?.(initialWriterView);\n    }\n  }, []);\n\n  const filename = projectRelativeFilePath?.split(\"/\").pop();\n  const extension = filename?.split(\".\").pop();\n\n  // Detect type either based on forced type, filename or on content (in descending order)\n  const writerType: WriterType = type\n    ? type\n    : extension\n    ? getWriterType(extension)\n    : getWriterTypeFromContent(value);\n\n  const icon =\n    writerType === \"markdown\" ? \"✍️\" : writerType === \"typescript\" ? \"⌘\" : \"📃\";\n\n  const canRenderWriterInput =\n    projectRelativeBaseFolderPath !== undefined &&\n    projectRelativeMarkdownFilePath !== undefined;\n\n  const renderWriter = () => {\n    const frontmatterSchemaQuery =\n      queries.useGetFrontmatterSchema(markdownModelName);\n\n    const markdownParse = mdToJsonParse(value, filename, {\n      frontmatterSchema: frontmatterSchemaQuery.data?.result,\n      noFinal: true,\n    });\n\n    const markdownParseRenderConfig: MarkdownParseRenderConfig = {\n      augmentedWordObject,\n      projectRelativeBaseFolderPath: projectRelativeBaseFolderPath || \"\",\n      projectRelativeMarkdownFilePath: projectRelativeMarkdownFilePath || \"\",\n      isDev,\n      isStatic: false,\n    };\n\n    return (\n      <Div className=\"flex flex-col flex-1 px-4\">\n        {writerView === \"shortStudio\" ? (\n          <ShortStudio\n            onChange={onChange}\n            value={value}\n            projectRelativeFilePath={projectRelativeFilePath || \"\"}\n            markdownModelName={markdownModelName}\n          />\n        ) : null}\n        {writerView === \"postable\" ? <Div>This is postable</Div> : null}\n        {writerView === \"todoOffers\" ? <Div>This is todo offers</Div> : null}\n\n        {writerView === \"config\" ? <WriterConfigForm /> : null}\n\n        {writerView === \"frontmatter\" &&\n        !frontmatterSchemaQuery.isLoading &&\n        frontmatterSchemaQuery.data?.result &&\n        projectRelativeMarkdownFilePath ? (\n          <FrontmatterForm\n            modelName={markdownModelName}\n            key={projectRelativeMarkdownFilePath}\n            markdownParse={markdownParse}\n            projectRelativeMarkdownFilePath={projectRelativeMarkdownFilePath}\n            frontmatterSchema={frontmatterSchemaQuery.data?.result}\n            onChange={onChange}\n          />\n        ) : null}\n\n        {writerView === \"edit\" || writerView === undefined ? (\n          <EditWriterInput\n            onChange={onChange}\n            value={value}\n            projectRelativeFilePath={projectRelativeFilePath || \"\"}\n            markdownModelName={markdownModelName}\n          />\n        ) : null}\n\n        {writerView === \"view\" || writerView === \"presentation\" ? (\n          <MarkdownView\n            view={writerView}\n            markdownParse={markdownParse}\n            markdownParseRenderConfig={markdownParseRenderConfig}\n          />\n        ) : null}\n      </Div>\n    );\n  };\n\n  const notDisabled = (menuName: string) => {\n    return !disabledMenuItems || !disabledMenuItems.includes(menuName);\n  };\n  return (\n    <Div className={`flex flex-col flex-1 ${className}`}>\n      {hideButtons || !setWriterView ? null : (\n        <TitleContainer\n          buttons={[\n            {\n              onClick: () => save?.(),\n              emoji: \"💾\",\n              title: \"Save\",\n              isEnabled: isSaved === false && !!save,\n            },\n\n            {\n              onClick: () => setWriterView(\"edit\"),\n              emoji: \"✏️\",\n              title: \"Edit\",\n              isActive: writerView === \"edit\",\n              isEnabled: notDisabled(\"edit\"),\n            },\n\n            {\n              onClick: () => setWriterView(\"view\"),\n              emoji: \"👁\",\n              title: \"View\",\n              isActive: writerView === \"view\",\n              isEnabled: notDisabled(\"view\"),\n            },\n\n            {\n              onClick: () => {\n                // TODO; ALSO MAKE FULLSCREEN HERE\n                setWriterView(\"presentation\");\n              },\n              emoji: \"📽\",\n              title: \"Present\",\n              isActive: writerView === \"presentation\",\n              isEnabled:\n                writerType === \"markdown\" && notDisabled(\"presentation\"),\n            },\n\n            {\n              onClick: () => {\n                setWriterView(\"frontmatter\");\n              },\n              emoji: \"🧩\",\n              title: \"About\",\n              isActive: writerView === \"frontmatter\",\n              isEnabled:\n                writerType === \"markdown\" &&\n                !!markdownModelName &&\n                notDisabled(\"frontmatter\"),\n            },\n\n            {\n              onClick: () => {\n                setWriterView(\"config\");\n              },\n              emoji: \"⚙️\",\n              title: \"Configuration\",\n              isActive: writerView === \"config\",\n              isEnabled: notDisabled(\"config\"),\n            },\n\n            {\n              onClick: () => {\n                setWriterView(\"postable\");\n              },\n              emoji: \"💬\",\n              title: \"Postables\",\n              isActive: writerView === \"postable\",\n              isEnabled: projectRelativeFilePath?.endsWith(\".postable.md\"),\n            },\n\n            {\n              onClick: () => {\n                setWriterView(\"shortStudio\");\n              },\n              emoji: \"🎙\",\n              title: \"Short Studio\",\n              isActive: writerView === \"shortStudio\",\n              isEnabled: projectRelativeFilePath?.endsWith(\".short.md\"),\n            },\n\n            {\n              onClick: () => {\n                setWriterView(\"todoOffers\");\n              },\n              emoji: \"📖\",\n              title: \"Todo Offers\",\n              isActive: writerView === \"todoOffers\",\n              isEnabled:\n                projectRelativeFilePath?.includes(\"/todo/\") &&\n                notDisabled(\"todo\"),\n            },\n\n            {\n              onClick: () => {\n                vscodeOpen({\n                  files: [{ projectRelativePath: projectRelativeFilePath }],\n                });\n              },\n              emoji: \"💻\",\n              title: \"Code\",\n              isEnabled: projectRelativeFilePath !== undefined,\n            },\n\n            {\n              isEnabled: !!reload,\n              onClick: reload || (() => null),\n              component: isLoading ? () => <FancyLoader /> : undefined,\n              emoji: isLoading ? undefined : \"↻\",\n              title: isLoading ? \"Loading\" : \"Reload\",\n            },\n          ]}\n          title={filename ? `${icon} ${filename}` : undefined}\n        >\n          <Div />\n        </TitleContainer>\n      )}\n\n      {canRenderWriterInput\n        ? renderWriter()\n        : \"Can't render.... need `projectRelativeFilePath`\"}\n    </Div>\n  );\n}"
  },
  "MarkdownReaderPageProps": {
    "name": "MarkdownReaderPageProps",
    "slug": "TsInterface",
    "id": "markdownreaderpageprops",
    "description": "",
    "operationName": "reader-ui"
  },
  "NamedParameters<typeof HomePage>": {
    "name": "NamedParameters<typeof HomePage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-homepage",
    "description": "",
    "operationName": "search-web"
  },
  "NamedParameters<typeof executeCronFunction>": {
    "name": "NamedParameters<typeof executeCronFunction>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-executecronfunction",
    "description": "",
    "operationName": "function-server"
  },
  "NamedParameters<typeof runFunctionServer>": {
    "name": "NamedParameters<typeof runFunctionServer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-runfunctionserver",
    "description": "",
    "operationName": "function-server"
  },
  "NamedParameters<typeof runFunctionServerCli>": {
    "name": "NamedParameters<typeof runFunctionServerCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-runfunctionservercli",
    "description": "",
    "operationName": "function-server"
  },
  "NamedParameters<typeof runFunctionServerDev>": {
    "name": "NamedParameters<typeof runFunctionServerDev>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-runfunctionserverdev",
    "description": "",
    "operationName": "function-server"
  },
  "NamedParameters<typeof runFunctionServerDevCli>": {
    "name": "NamedParameters<typeof runFunctionServerDevCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-runfunctionserverdevcli",
    "description": "",
    "operationName": "function-server"
  },
  "NamedParameters<typeof scheduleCronJobs>": {
    "name": "NamedParameters<typeof scheduleCronJobs>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-schedulecronjobs",
    "description": "",
    "operationName": "function-server"
  },
  "NamedParameters<typeof startSearchWebIfAvailable>": {
    "name": "NamedParameters<typeof startSearchWebIfAvailable>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-startsearchwebifavailable",
    "description": "",
    "operationName": "function-server"
  },
  "TsFunction": {
    "name": "TsFunction",
    "slug": "TsInterface",
    "id": "tsfunction",
    "description": "\nInterface for arrow functions and normal functions",
    "operationName": "markdown-types"
  },
  "FunctionExecution": {
    "name": "FunctionExecution",
    "slug": "TsInterface",
    "id": "functionexecution",
    "description": "Model for tests, examples, cache, and recent executions of any function\n\nRequirement for **tifo-stitching**\n\nExample:\n\nconst someFunction = (inputA: string, inputB:string):string => {\n\nreturn `${inputA} != ${inputB}`\n}\n\n\nfind this in the database after executing the function\n\nconst functionExecution1 = {\n....\nfunctionName: \"someFunction\",\ninputParameters: [\"hello\", \"world\"],\noutput: \"hello != world\",\nisTest: false,\nisExample: false,\nisResultFromCache: false,\nperformance: [....],\n}",
    "operationName": "code-types",
    "rawText": "\n\n/**\n * Model for tests, examples, cache, and recent executions of any function\n *\n * Requirement for **tifo-stitching**\n\nExample: \n\nconst someFunction = (inputA: string, inputB:string):string => {\n\n  return `${inputA} != ${inputB}`\n}\n\n\n// find this in the database after executing the function\n\nconst functionExecution1 = {\n  ....\n  functionName: \"someFunction\",\n  inputParameters: [\"hello\", \"world\"],\n  output: \"hello != world\",\n  isTest: false,\n  isExample: false,\n  isResultFromCache: false,\n  performance: [....],\n}\n\n*/\n\nexport interface FunctionExecution extends DefaultModelType {\n  functionName: string;\n  tsFunctionId: Id;\n  tsFunction?: TsFunction;\n  inputParameters: any[] | undefined;\n  output: any;\n  isTest: boolean;\n  isExample: boolean;\n  /**\n   * test description or example description or anything\n   */\n  description?: Markdown;\n  isResultFromCache: boolean;\n  /**\n   * if true, the api of the function (input/output interface) has changed in bewteen, so the re-execution would probably fail or return a different result\n   */\n  hasApiChanged?: boolean;\n  performance: PerformanceItem[];\n}"
  },
  "NamedParameters<typeof FormTab>": {
    "name": "NamedParameters<typeof FormTab>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-formtab",
    "description": "",
    "operationName": "search-web"
  },
  "NamedParameters<typeof FunctionExecutionTable>": {
    "name": "NamedParameters<typeof FunctionExecutionTable>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-functionexecutiontable",
    "description": "",
    "operationName": "search-web"
  },
  "NamedParameters<typeof FunctionLayout>": {
    "name": "NamedParameters<typeof FunctionLayout>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-functionlayout",
    "description": "",
    "operationName": "search-web"
  },
  "NamedParameters<typeof FunctionPage>": {
    "name": "NamedParameters<typeof FunctionPage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-functionpage",
    "description": "",
    "operationName": "search-web"
  },
  "NamedParameters<typeof getAllSearchResults>": {
    "name": "NamedParameters<typeof getAllSearchResults>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getallsearchresults",
    "description": "",
    "operationName": "search-web"
  },
  "NamedParameters<typeof SearchResultComponent>": {
    "name": "NamedParameters<typeof SearchResultComponent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-searchresultcomponent",
    "description": "",
    "operationName": "search-web"
  },
  "NamedParameters<typeof SearchResultPage>": {
    "name": "NamedParameters<typeof SearchResultPage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-searchresultpage",
    "description": "",
    "operationName": "search-web"
  },
  "QueryPageProps": {
    "name": "QueryPageProps",
    "slug": "TsInterface",
    "id": "querypageprops",
    "description": "",
    "operationName": "search-web",
    "rawText": "export type QueryPageProps = {\n  query: string | null;\n  searchResults: SearchResult[] | null;\n  imagePaths: string[];\n  timelineItems: {\n    comment: string;\n    filePath?: string;\n    line: number;\n  }[];\n};"
  },
  "SearchResult": {
    "name": "SearchResult",
    "slug": "TsInterface",
    "id": "searchresult",
    "description": "",
    "operationName": "search-web",
    "rawText": "\n\nexport type SearchResult = {\n  title: string;\n  description?: string;\n  url: string;\n};"
  },
  "NamedParameters<typeof MyLayout>": {
    "name": "NamedParameters<typeof MyLayout>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-mylayout",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof TodoMenuHeader>": {
    "name": "NamedParameters<typeof TodoMenuHeader>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-todomenuheader",
    "description": "",
    "operationName": "todo-web"
  },
  "GetStaticPathsContext": {
    "name": "GetStaticPathsContext",
    "slug": "TsInterface",
    "id": "getstaticpathscontext",
    "description": "",
    "operationName": "next-types",
    "rawText": "\n\nexport type GetStaticPathsContext = {\n  locales?: string[];\n  defaultLocale?: string;\n};"
  },
  "GetStaticPropsContext": {
    "name": "GetStaticPropsContext",
    "slug": "TsInterface",
    "id": "getstaticpropscontext",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof codestoriesGetPages>": {
    "name": "NamedParameters<typeof codestoriesGetPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-codestoriesgetpages",
    "description": "",
    "operationName": "codestorys-node"
  },
  "NamedParameters<typeof codestoriesGetStaticPaths>": {
    "name": "NamedParameters<typeof codestoriesGetStaticPaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-codestoriesgetstaticpaths",
    "description": "",
    "operationName": "codestorys-node"
  },
  "NamedParameters<typeof codestoriesGetStaticProps>": {
    "name": "NamedParameters<typeof codestoriesGetStaticProps>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-codestoriesgetstaticprops",
    "description": "",
    "operationName": "codestorys-node"
  },
  "CopyPair": {
    "name": "CopyPair",
    "slug": "TsInterface",
    "id": "copypair",
    "description": "",
    "operationName": "collect-static-assets",
    "rawText": "\n\nexport type CopyPair = {\n  absoluteSourcePath: string;\n  absoluteDestinationPath: string;\n};"
  },
  "NamedParameters<typeof copyCopyPairs>": {
    "name": "NamedParameters<typeof copyCopyPairs>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-copycopypairs",
    "description": "",
    "operationName": "collect-static-assets"
  },
  "NamedParameters<typeof copyReaderStaticAssets>": {
    "name": "NamedParameters<typeof copyReaderStaticAssets>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-copyreaderstaticassets",
    "description": "",
    "operationName": "collect-static-assets"
  },
  "NamedParameters<typeof findReaderStaticAssets>": {
    "name": "NamedParameters<typeof findReaderStaticAssets>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findreaderstaticassets",
    "description": "",
    "operationName": "collect-static-assets"
  },
  "NamedParameters<typeof findStaticAssets>": {
    "name": "NamedParameters<typeof findStaticAssets>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findstaticassets",
    "description": "",
    "operationName": "collect-static-assets"
  },
  "ReaderWebPage": {
    "name": "ReaderWebPage",
    "slug": "TsInterface",
    "id": "readerwebpage",
    "description": "specifically always a markdown page",
    "operationName": "webpage-types",
    "rawText": "\n/**\n * specifically always a markdown page\n */\nexport type ReaderWebPage = FileWebPage;"
  },
  "CodespanItemInfo": {
    "name": "CodespanItemInfo",
    "slug": "TsInterface",
    "id": "codespaniteminfo",
    "description": "",
    "operationName": "make-codestory",
    "rawText": "export type CodespanItemInfo = {\n  name: string;\n  /**\n   * This is the type in this case\n   */\n  slug: string;\n  id: string;\n  description?: string;\n  rawText?: string;\n  gitRepoUrl?: string;\n};"
  },
  "NamedParameters<typeof addCodestoryToSection>": {
    "name": "NamedParameters<typeof addCodestoryToSection>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-addcodestorytosection",
    "description": "",
    "operationName": "make-codestory"
  },
  "NamedParameters<typeof findCodestories>": {
    "name": "NamedParameters<typeof findCodestories>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findcodestories",
    "description": "",
    "operationName": "make-codestory"
  },
  "NamedParameters<typeof makeCodespanMappedObject>": {
    "name": "NamedParameters<typeof makeCodespanMappedObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-makecodespanmappedobject",
    "description": "",
    "operationName": "make-codestory"
  },
  "NamedParameters<typeof makeCodestory>": {
    "name": "NamedParameters<typeof makeCodestory>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-makecodestory",
    "description": "",
    "operationName": "make-codestory"
  },
  "NamedParameters<typeof test>": {
    "name": "NamedParameters<typeof test>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-test",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof writeAllCodestories>": {
    "name": "NamedParameters<typeof writeAllCodestories>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-writeallcodestories",
    "description": "",
    "operationName": "make-codestory"
  },
  "NamedParameters<typeof writeAllCodestoriesCli>": {
    "name": "NamedParameters<typeof writeAllCodestoriesCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-writeallcodestoriescli",
    "description": "",
    "operationName": "make-codestory"
  },
  "NamedParameters<typeof writeCodespanDetails>": {
    "name": "NamedParameters<typeof writeCodespanDetails>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-writecodespandetails",
    "description": "",
    "operationName": "make-codestory"
  },
  "AuthenticationMethodMethod": {
    "name": "AuthenticationMethodMethod",
    "slug": "TsInterface",
    "id": "authenticationmethodmethod",
    "description": "Username + password should be the default\n\nEmail OTP, phone number OTP (sms or call or whatsapp), should be optional 2FA methods\n\nAll others can also act as authentication methods, but the token shouldn't be stored",
    "operationName": "server-login"
  },
  "ContextualPrompt": {
    "name": "ContextualPrompt",
    "slug": "TsInterface",
    "id": "contextualprompt",
    "description": "\nModel for prompting information from third party sources",
    "operationName": "prompt-components"
  },
  "FileType": {
    "name": "FileType",
    "slug": "TsInterface",
    "id": "filetype",
    "description": "",
    "operationName": "make-file-type",
    "rawText": "\n\nexport type FileType = {\n  /**\n   * filename including extension\n   */\n  name: string;\n  /**\n   * size in bytes\n   */\n  size: number;\n  /**\n   * unix timestamp in ms\n   */\n  mtime_ms: number;\n  /**\n   * whether the file still exists\n   */\n  exists: boolean;\n  /**\n   * f stands for file, it seems, for the rest I don't know\n   */\n  type: string;\n};"
  },
  "FunctionContext": {
    "name": "FunctionContext",
    "slug": "TsInterface",
    "id": "functioncontext",
    "description": "Should be attached as first argument of the function, if the name of the function is in the format of:\n\n- `xyzWithContext`: attaches all context\n- `xyzWithContextRaw`: attaches all context, api returns just the result of the function without wrapping it in the `RealApiReturnType`. Needed in case you have a different server.js `server.reply`\n\nFor more info see `apiConvention`",
    "operationName": "server-login"
  },
  "NamedParameters<typeof addEmojiToEveryWord>": {
    "name": "NamedParameters<typeof addEmojiToEveryWord>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-addemojitoeveryword",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof addStatement>": {
    "name": "NamedParameters<typeof addStatement>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-addstatement",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof addWord>": {
    "name": "NamedParameters<typeof addWord>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-addword",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof biggestFunctionName>": {
    "name": "NamedParameters<typeof biggestFunctionName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-biggestfunctionname",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof checkQueue>": {
    "name": "NamedParameters<typeof checkQueue>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-checkqueue",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof cleanup>": {
    "name": "NamedParameters<typeof cleanup>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-cleanup",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof controlChatGpt>": {
    "name": "NamedParameters<typeof controlChatGpt>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-controlchatgpt",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof controlChatGptCli>": {
    "name": "NamedParameters<typeof controlChatGptCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-controlchatgptcli",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof controlChatGptWrapper>": {
    "name": "NamedParameters<typeof controlChatGptWrapper>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-controlchatgptwrapper",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof deletePromptResult>": {
    "name": "NamedParameters<typeof deletePromptResult>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-deletepromptresult",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof developersQuote>": {
    "name": "NamedParameters<typeof developersQuote>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-developersquote",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof diaryToInstagram>": {
    "name": "NamedParameters<typeof diaryToInstagram>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-diarytoinstagram",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof documentationWriting>": {
    "name": "NamedParameters<typeof documentationWriting>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-documentationwriting",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof emojiAugmentation>": {
    "name": "NamedParameters<typeof emojiAugmentation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-emojiaugmentation",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof explain>": {
    "name": "NamedParameters<typeof explain>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-explain",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof explainInDutch>": {
    "name": "NamedParameters<typeof explainInDutch>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-explainindutch",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof explainInNepali>": {
    "name": "NamedParameters<typeof explainInNepali>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-explaininnepali",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof explainInPortuguese>": {
    "name": "NamedParameters<typeof explainInPortuguese>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-explaininportuguese",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof explainLineByLine>": {
    "name": "NamedParameters<typeof explainLineByLine>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-explainlinebyline",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof fixGrammarAndSpellingMistakes>": {
    "name": "NamedParameters<typeof fixGrammarAndSpellingMistakes>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fixgrammarandspellingmistakes",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof followUpQuestions>": {
    "name": "NamedParameters<typeof followUpQuestions>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-followupquestions",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof getCategoriesTest>": {
    "name": "NamedParameters<typeof getCategoriesTest>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcategoriestest",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof getContextualPrompt>": {
    "name": "NamedParameters<typeof getContextualPrompt>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcontextualprompt",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof getContextualPromptCategories>": {
    "name": "NamedParameters<typeof getContextualPromptCategories>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcontextualpromptcategories",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof getContextualPromptResultJsonFilePath>": {
    "name": "NamedParameters<typeof getContextualPromptResultJsonFilePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcontextualpromptresultjsonfilepath",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof getObjectForkKeyRecursively>": {
    "name": "NamedParameters<typeof getObjectForkKeyRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getobjectforkkeyrecursively",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof getToolFunctions>": {
    "name": "NamedParameters<typeof getToolFunctions>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettoolfunctions",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof gptIdeasRegisterWithContext>": {
    "name": "NamedParameters<typeof gptIdeasRegisterWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gptideasregisterwithcontext",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof haiku>": {
    "name": "NamedParameters<typeof haiku>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-haiku",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof hookOneliners>": {
    "name": "NamedParameters<typeof hookOneliners>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-hookoneliners",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof improveCode>": {
    "name": "NamedParameters<typeof improveCode>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-improvecode",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof investorPitch>": {
    "name": "NamedParameters<typeof investorPitch>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-investorpitch",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof marcusAurelius>": {
    "name": "NamedParameters<typeof marcusAurelius>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-marcusaurelius",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof opposite>": {
    "name": "NamedParameters<typeof opposite>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-opposite",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof outlineToInvestorPitch>": {
    "name": "NamedParameters<typeof outlineToInvestorPitch>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-outlinetoinvestorpitch",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof poem>": {
    "name": "NamedParameters<typeof poem>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-poem",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof processChatGptPrompt>": {
    "name": "NamedParameters<typeof processChatGptPrompt>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-processchatgptprompt",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof processPromptOnFile>": {
    "name": "NamedParameters<typeof processPromptOnFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-processpromptonfile",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof processPromptOnFolderWithContext>": {
    "name": "NamedParameters<typeof processPromptOnFolderWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-processpromptonfolderwithcontext",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof quiz>": {
    "name": "NamedParameters<typeof quiz>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-quiz",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof removeAllFake>": {
    "name": "NamedParameters<typeof removeAllFake>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removeallfake",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof rickAndMorty>": {
    "name": "NamedParameters<typeof rickAndMorty>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rickandmorty",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof rickAndMortyRick>": {
    "name": "NamedParameters<typeof rickAndMortyRick>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rickandmortyrick",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof setIsFavoritePromptResult>": {
    "name": "NamedParameters<typeof setIsFavoritePromptResult>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-setisfavoritepromptresult",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof shouldAddToQueue>": {
    "name": "NamedParameters<typeof shouldAddToQueue>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-shouldaddtoqueue",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof socratesAndSnoopDogg>": {
    "name": "NamedParameters<typeof socratesAndSnoopDogg>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-socratesandsnoopdogg",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof storytelling>": {
    "name": "NamedParameters<typeof storytelling>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-storytelling",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof toolFunctionWithContext>": {
    "name": "NamedParameters<typeof toolFunctionWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-toolfunctionwithcontext",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof translateEverything>": {
    "name": "NamedParameters<typeof translateEverything>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-translateeverything",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof translateEverythingIntoHindi>": {
    "name": "NamedParameters<typeof translateEverythingIntoHindi>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-translateeverythingintohindi",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof translateEverythingPortuguese>": {
    "name": "NamedParameters<typeof translateEverythingPortuguese>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-translateeverythingportuguese",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof translateToPortuguese>": {
    "name": "NamedParameters<typeof translateToPortuguese>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-translatetoportuguese",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof typescriptExplain>": {
    "name": "NamedParameters<typeof typescriptExplain>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-typescriptexplain",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof williamShakespear>": {
    "name": "NamedParameters<typeof williamShakespear>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-williamshakespear",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof writeContextualPromptSdk>": {
    "name": "NamedParameters<typeof writeContextualPromptSdk>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-writecontextualpromptsdk",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof writeCreatePromptCode>": {
    "name": "NamedParameters<typeof writeCreatePromptCode>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-writecreatepromptcode",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof ye>": {
    "name": "NamedParameters<typeof ye>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-ye",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "NamedParameters<typeof yodafy>": {
    "name": "NamedParameters<typeof yodafy>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-yodafy",
    "description": "",
    "operationName": "ai-functions-node"
  },
  "ProcessPromptProps": {
    "name": "ProcessPromptProps",
    "slug": "TsInterface",
    "id": "processpromptprops",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": "\n\nexport type ProcessPromptProps = {\n  contextContent?: string | null;\n  selectionContent?: string | null;\n  contextualPromptSlug?: string;\n  anyContext?: string;\n  /**\n   * DESCRIPTION: These variables can be used: %context will be replaced by your context, %selection will be replaced by your selection. Provide a good prompt that combines that in a specific format\n   */\n  customPromptContent?: string;\n  saveNewPromptWithName?: string | null;\n  isHeadless?: boolean;\n  prompt_projectRelativePath?: string;\n  thread?: string;\n  /**\n   * If true, it'll just validate if this will be executed, it won't return the actual result but will execute the result in the background\n   */\n  isDeferred?: boolean;\n};"
  },
  "StackCount": {
    "name": "StackCount",
    "slug": "TsInterface",
    "id": "stackcount",
    "description": "",
    "operationName": "ai-functions-node",
    "rawText": "\nexport type StackCount = {\n  [stack: string]: number;\n};"
  },
  "AiDataset": {
    "name": "AiDataset",
    "slug": "TsInterface",
    "id": "aidataset",
    "description": "AI datasets\nexample: https://pile.eleuther.ai/",
    "operationName": "ai-types",
    "rawText": "\n\n/**\n * AI datasets\n * example: https://pile.eleuther.ai/\n */\nexport interface AiDataset extends DefaultModelType {\n  name: string;\n  company?: string;\n  dataType: string;\n  description?: string;\n  sizeGb?: number;\n  url?: string;\n  isPublic?: boolean;\n}"
  },
  "AiDemoApp": {
    "name": "AiDemoApp",
    "slug": "TsInterface",
    "id": "aidemoapp",
    "description": "",
    "operationName": "ai-types",
    "rawText": "\n\n/**\n * ---\n * dbStorageMethod: jsonSingle\n * ---\n */\nexport interface AiDemoApp extends SlugModelType {\n  /**\n   * Image should be available at public/demos/[slug].webp\n   *\n   * also, all contextual-prompts in folder `/db/contextual-prompts/[slug]/` are used as prompts for this demo\n   *\n   * If the slug is not present, the category of `ContextualPrompt` will be used\n   */\n  slug: string;\n  /**\n   * if you have, the use-case can launch on its own domain\n   */\n  domain?: string;\n  headerTitle: string;\n  hasImageBoolean?: boolean;\n  headerSubtitle?: string;\n  headerCtaHref?: string;\n  headerCtaText?: string;\n}"
  },
  "AiModel": {
    "name": "AiModel",
    "slug": "TsInterface",
    "id": "aimodel",
    "description": "",
    "operationName": "ai-types",
    "rawText": "\n\nexport interface AiModel extends DefaultModelType {\n  name: string;\n  company: string;\n  /**\n   * task it can do, e.g. text --> text, translation, or stt\n   */\n  task: string;\n  description?: string;\n  notes?: string;\n\n  /**\n   * How much USD has it cost to train this thing\n   */\n  trainingCostUsd?: number;\n\n  isOpenSource?: boolean;\n  isModelPublic?: boolean;\n  canRunLocally?: boolean;\n  isGpuRequired?: boolean;\n  /**\n   * requirements to run this\n   */\n  systemRequirements?: string;\n\n  paperUrl?: string;\n  githubUrl?: string;\n\n  hasApi?: boolean;\n  /**\n   * If there are api's available, there can we find more info about them?\n   */\n  apiUrls?: string[];\n}"
  },
  "BackendAsset": {
    "name": "BackendAsset",
    "slug": "TsInterface",
    "id": "backendasset",
    "description": "Part of the asset that should be sent to the backend. The rest should frontend-only\n\nSome values are stored, some are not",
    "operationName": "writer-functions"
  },
  "CategoryChildObject": {
    "name": "CategoryChildObject",
    "slug": "TsInterface",
    "id": "categorychildobject",
    "description": "",
    "operationName": "ai-types",
    "rawText": "\n\nexport type CategoryChildObject = ChildObject<{\n  category?: string;\n  categoryStack: string[];\n  count: number;\n  // only leafs\n  name?: string;\n  title?: string;\n  description?: string;\n  pricing?: string;\n}>;"
  },
  "ContextualContent": {
    "name": "ContextualContent",
    "slug": "TsInterface",
    "id": "contextualcontent",
    "description": "",
    "operationName": "ai-types",
    "rawText": "export type ContextualContent = {\n  contextContent: string;\n  contextSelection?: string | null;\n  context_projectRelativeFilePath?: string;\n};"
  },
  "ContextualPromptInfo": {
    "name": "ContextualPromptInfo",
    "slug": "TsInterface",
    "id": "contextualpromptinfo",
    "description": "To be appended to the generated typescript",
    "operationName": "ai-types",
    "rawText": "\n\n/**\n * To be appended to the generated typescript\n */\nexport type ContextualPromptInfo = {\n  // extra flags, to be added to the config of the function.\n\n  /**\n   * If given, will be used to filter the selection of prompts to match the context type\n   */\n  contextType?: FileType[];\n\n  instantExecution?: boolean;\n\n  isFavorite?: boolean;\n\n  categoryStack?: string[];\n\n  pricing?: \"bad\" | \"good\" | \"premium\" | \"enterprise\" | \"private\";\n};"
  },
  "ContextualPromptResult": {
    "name": "ContextualPromptResult",
    "slug": "TsInterface",
    "id": "contextualpromptresult",
    "description": "A result from a contextual prompt. Doesn't include the full context, for that you can find all results for a certain thread",
    "operationName": "markdown"
  },
  "ContextualPromptsObject": {
    "name": "ContextualPromptsObject",
    "slug": "TsInterface",
    "id": "contextualpromptsobject",
    "description": "",
    "operationName": "ai-types",
    "rawText": "\n\nexport type ContextualPromptsObject = {\n  selectionContextualPrompts: ContextualPrompt[];\n  pageContextualPrompts: ContextualPrompt[];\n  folderContextualPrompts: ContextualPrompt[];\n  databaseContextualPromptSlugs: string[];\n};"
  },
  "DefaultModelType": {
    "name": "DefaultModelType",
    "slug": "TsInterface",
    "id": "defaultmodeltype",
    "description": "Use this model by default",
    "operationName": "todo-types"
  },
  "FolderContent": {
    "name": "FolderContent",
    "slug": "TsInterface",
    "id": "foldercontent",
    "description": "",
    "operationName": "generative-ui"
  },
  "Frontmatter": {
    "name": "Frontmatter",
    "slug": "TsInterface",
    "id": "frontmatter",
    "description": "Our version of frontmatter is a bit simpler than regular frontmatter\n\nNot sure if this is a good idea, but it keeps it simple for our OS\n\nall values parse in a similar way to csv\n\nmake sure that you use quotes if you want to store a string with commas, because commas in a parameter indicate that it is a string array\n\nNB: string arrays are comma separated values, where you can put values with special characters in between quotes",
    "operationName": "model-types"
  },
  "GptIdeasUser": {
    "name": "GptIdeasUser",
    "slug": "TsInterface",
    "id": "gptideasuser",
    "description": "",
    "operationName": "ai-types",
    "rawText": "\n\nexport interface GptIdeasUser extends DefaultModelType {\n  email: string;\n  tier: string;\n  newsletter: string;\n}"
  },
  "LanguageModelEnum": {
    "name": "LanguageModelEnum",
    "slug": "TsInterface",
    "id": "languagemodelenum",
    "description": "",
    "operationName": "ai-types",
    "rawText": "\n\nexport type LanguageModelEnum = typeof languageModels[number];"
  },
  "ProcessPromptFunctionResult": {
    "name": "ProcessPromptFunctionResult",
    "slug": "TsInterface",
    "id": "processpromptfunctionresult",
    "description": "Same result to be expected from executing prompt for any language model",
    "operationName": "ai-types",
    "rawText": "\n/**\n * Same result to be expected from executing prompt for any language model\n */\nexport type ProcessPromptFunctionResult = {\n  isSuccessful: boolean;\n  message: string;\n  result?: { text?: string; assets?: BackendAsset[]; thread: string };\n};"
  },
  "PromptFunction": {
    "name": "PromptFunction",
    "slug": "TsInterface",
    "id": "promptfunction",
    "description": "Special kind of function that executes a prompt with the use of a language model",
    "operationName": "ai-types",
    "rawText": "\n/**\n * Special kind of function that executes a prompt with the use of a language model\n */\nexport type PromptFunction = {\n  (...parameters: any[]): Promise<ProcessPromptFunctionResult>;\n  contextualPromptInfo: ContextualPromptInfo;\n} & ApiFunctionParameters;"
  },
  "ReaderProps": {
    "name": "ReaderProps",
    "slug": "TsInterface",
    "id": "readerprops",
    "description": "This is what we need on the page level. There are many subtleties to it, but this is the core",
    "operationName": "generative-ui"
  },
  "SlugModelType": {
    "name": "SlugModelType",
    "slug": "TsInterface",
    "id": "slugmodeltype",
    "description": "use this model for things with a name that have an unique slug that can be used to identify the model",
    "operationName": "peer-types"
  },
  "NamedParameters<typeof allOperationsRemoveJsSrc>": {
    "name": "NamedParameters<typeof allOperationsRemoveJsSrc>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-alloperationsremovejssrc",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof allOperationsToMarkdown>": {
    "name": "NamedParameters<typeof allOperationsToMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-alloperationstomarkdown",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof clearAllTsDatabases>": {
    "name": "NamedParameters<typeof clearAllTsDatabases>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-clearalltsdatabases",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof codeAll>": {
    "name": "NamedParameters<typeof codeAll>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-codeall",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof getAllOperationClassifications>": {
    "name": "NamedParameters<typeof getAllOperationClassifications>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getalloperationclassifications",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof mdAllOperations>": {
    "name": "NamedParameters<typeof mdAllOperations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-mdalloperations",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof minifyAllOperations>": {
    "name": "NamedParameters<typeof minifyAllOperations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-minifyalloperations",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof removeAllFiles>": {
    "name": "NamedParameters<typeof removeAllFiles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removeallfiles",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof removeAllFolders>": {
    "name": "NamedParameters<typeof removeAllFolders>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removeallfolders",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof removeAllFoldersCli>": {
    "name": "NamedParameters<typeof removeAllFoldersCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removeallfolderscli",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof runScriptEverywhere>": {
    "name": "NamedParameters<typeof runScriptEverywhere>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-runscripteverywhere",
    "description": "",
    "operationName": "all"
  },
  "NamedParameters<typeof setScriptEverywhere>": {
    "name": "NamedParameters<typeof setScriptEverywhere>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-setscripteverywhere",
    "description": "",
    "operationName": "all"
  },
  "ApiConfig": {
    "name": "ApiConfig",
    "slug": "TsInterface",
    "id": "apiconfig",
    "description": "",
    "operationName": "api"
  },
  "NamedParameters<typeof fn1>": {
    "name": "NamedParameters<typeof fn1>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fn1",
    "description": "",
    "operationName": "api"
  },
  "NamedParameters<typeof fn2>": {
    "name": "NamedParameters<typeof fn2>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fn2",
    "description": "",
    "operationName": "api"
  },
  "NamedParameters<typeof fn3>": {
    "name": "NamedParameters<typeof fn3>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fn3",
    "description": "",
    "operationName": "api"
  },
  "NamedParameters<typeof getGetApiUrl>": {
    "name": "NamedParameters<typeof getGetApiUrl>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getgetapiurl",
    "description": "",
    "operationName": "api"
  },
  "NamedParameters<typeof untypedApiFunction>": {
    "name": "NamedParameters<typeof untypedApiFunction>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-untypedapifunction",
    "description": "",
    "operationName": "api"
  },
  "ApiStoreType": {
    "name": "ApiStoreType",
    "slug": "TsInterface",
    "id": "apistoretype",
    "description": "",
    "operationName": "api-store",
    "rawText": "\n\nexport type ApiStoreType = {\n  /**\n   * authToken coupled to device, set by browser automatically on first pageload\n   *\n   * can also be changed by logging in\n   */\n  \"api.authToken\": string;\n  /**\n   * Can set this up in config to connect with different api\n   */\n  \"api.customUrl\": string | null;\n  /**\n   * If the api doesn't response, this will be set to last date.\n   * If the api responds, this will be reset\n   */\n  \"api.timeoutAt\": null | number;\n};"
  },
  "NamedParameters<typeof AppsMenu>": {
    "name": "NamedParameters<typeof AppsMenu>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-appsmenu",
    "description": "",
    "operationName": "apps-menu"
  },
  "NamedParameters<typeof ask>": {
    "name": "NamedParameters<typeof ask>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-ask",
    "description": "",
    "operationName": "ask"
  },
  "NamedParameters<typeof askOk>": {
    "name": "NamedParameters<typeof askOk>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-askok",
    "description": "",
    "operationName": "ask"
  },
  "NamedParameters<typeof getArgumentOrAsk>": {
    "name": "NamedParameters<typeof getArgumentOrAsk>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getargumentorask",
    "description": "",
    "operationName": "ask"
  },
  "Asset": {
    "name": "Asset",
    "slug": "TsInterface",
    "id": "asset",
    "description": "Asset you can upload\n\nThis is not a database model, it can exist in properties of any db model or type interface.\n\nOnly `alt` and `relativePath` are stored, the other parameters are optionally required for uploading and user interfaces, and are not always there\n\nNB: don't use this in your model, use `StoredAsset` instead.",
    "operationName": "asset-view"
  },
  "AssetInputType": {
    "name": "AssetInputType",
    "slug": "TsInterface",
    "id": "assetinputtype",
    "description": "",
    "operationName": "name-conventions",
    "rawText": "\n\nexport type AssetInputType = {\n  type: \"image\" | \"video\" | \"audio\" | \"file\" | \"asset\";\n  isMultiple: boolean;\n};"
  },
  "AssetParameter": {
    "name": "AssetParameter",
    "slug": "TsInterface",
    "id": "assetparameter",
    "description": "",
    "operationName": "asset-functions-js",
    "rawText": "\n\nexport type AssetParameter = {\n  assetInputType: AssetInputType;\n  parameterName: string;\n  /**\n   * where the object parameter is located\n   */\n  stack?: string[];\n};"
  },
  "NamedParameters<typeof addToken>": {
    "name": "NamedParameters<typeof addToken>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-addtoken",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "NamedParameters<typeof ensureToken>": {
    "name": "NamedParameters<typeof ensureToken>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-ensuretoken",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "NamedParameters<typeof findAssetParametersRecursively>": {
    "name": "NamedParameters<typeof findAssetParametersRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findassetparametersrecursively",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "NamedParameters<typeof getConversionInfoFromType>": {
    "name": "NamedParameters<typeof getConversionInfoFromType>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getconversioninfofromtype",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "NamedParameters<typeof getExtensionFromAsset>": {
    "name": "NamedParameters<typeof getExtensionFromAsset>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getextensionfromasset",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "NamedParameters<typeof getNameFromRelativePath>": {
    "name": "NamedParameters<typeof getNameFromRelativePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getnamefromrelativepath",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "NamedParameters<typeof getNameWithTokenFromRelativePath>": {
    "name": "NamedParameters<typeof getNameWithTokenFromRelativePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getnamewithtokenfromrelativepath",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "NamedParameters<typeof getReferencedAssetApiUrl>": {
    "name": "NamedParameters<typeof getReferencedAssetApiUrl>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getreferencedassetapiurl",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "NamedParameters<typeof getTypeFromUrlOrPath>": {
    "name": "NamedParameters<typeof getTypeFromUrlOrPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettypefromurlorpath",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "NamedParameters<typeof readableSize>": {
    "name": "NamedParameters<typeof readableSize>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readablesize",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "NamedParameters<typeof removeTokenIfPresent>": {
    "name": "NamedParameters<typeof removeTokenIfPresent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removetokenifpresent",
    "description": "",
    "operationName": "asset-functions-js"
  },
  "CompressionConfig": {
    "name": "CompressionConfig",
    "slug": "TsInterface",
    "id": "compressionconfig",
    "description": "",
    "operationName": "asset-type",
    "rawText": "export type CompressionConfig = {\n  /**\n   * used for audio\n   */\n  bitrate?: number;\n  /**\n   * Frames per second. Used for video\n   */\n  fps?: number;\n  /**\n   * Set the resolution. Will not upscale.\n   *\n   * Used for video and images\n   */\n  resolution?: {\n    width: number;\n    height: number;\n  };\n  /**\n   * if true, will overwrite the original file\n   */\n  shouldOverwrite?: boolean;\n};"
  },
  "NamedParameters<typeof compressAsset>": {
    "name": "NamedParameters<typeof compressAsset>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-compressasset",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "NamedParameters<typeof downloadRemoteAsset>": {
    "name": "NamedParameters<typeof downloadRemoteAsset>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-downloadremoteasset",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "NamedParameters<typeof deleteReferencedAsset>": {
    "name": "NamedParameters<typeof deleteReferencedAsset>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-deletereferencedasset",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "NamedParameters<typeof findAbsoluteAssetPathFromReference>": {
    "name": "NamedParameters<typeof findAbsoluteAssetPathFromReference>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findabsoluteassetpathfromreference",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "NamedParameters<typeof findAllProjectMedia>": {
    "name": "NamedParameters<typeof findAllProjectMedia>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findallprojectmedia",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "NamedParameters<typeof getStorageLocationInfo>": {
    "name": "NamedParameters<typeof getStorageLocationInfo>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getstoragelocationinfo",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "NamedParameters<typeof getTemporaryAssetsFolderPath>": {
    "name": "NamedParameters<typeof getTemporaryAssetsFolderPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettemporaryassetsfolderpath",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "NamedParameters<typeof processAsset>": {
    "name": "NamedParameters<typeof processAsset>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-processasset",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "NamedParameters<typeof removeOldTemporaryAssets>": {
    "name": "NamedParameters<typeof removeOldTemporaryAssets>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removeoldtemporaryassets",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "NamedParameters<typeof serverDownloadReply>": {
    "name": "NamedParameters<typeof serverDownloadReply>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-serverdownloadreply",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "NamedParameters<typeof uploadAssetWithContext>": {
    "name": "NamedParameters<typeof uploadAssetWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-uploadassetwithcontext",
    "description": "",
    "operationName": "asset-functions-node"
  },
  "ReceivedFile": {
    "name": "ReceivedFile",
    "slug": "TsInterface",
    "id": "receivedfile",
    "description": "This is the format that I receive for a file with server.js, even though they say it's a formidable.file, which it's not...",
    "operationName": "asset-functions-node",
    "rawText": "\n\n/**\n * This is the format that I receive for a file with server.js, even though they say it's a formidable.file, which it's not...\n */\n\nexport type ReceivedFile = {\n  size: number;\n  path: string;\n  name: string;\n  type: string;\n  hash: any;\n  lastModifiedDate: Date;\n};"
  },
  "MediaSourceEnum": {
    "name": "MediaSourceEnum",
    "slug": "TsInterface",
    "id": "mediasourceenum",
    "description": "google: remote image urls\ngiphy: remote image urls\nunsplashed: remote image urls\nyoutube: remote video urls (selectable as mp3, mp4, or url)",
    "operationName": "asset-input",
    "rawText": "/**\n\nproject: api urls\np2p: api urls with other ip\n---\ngoogle: remote image urls\ngiphy: remote image urls\nunsplashed: remote image urls\nyoutube: remote video urls (selectable as mp3, mp4, or url)\n\n */\nexport type MediaSourceEnum =\n  | \"project\"\n  | \"p2p\"\n  | \"google\"\n  | \"giphy\"\n  | \"unsplashed\"\n  | \"youtube\";"
  },
  "NamedParameters<typeof getTypeFromFileBlob>": {
    "name": "NamedParameters<typeof getTypeFromFileBlob>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettypefromfileblob",
    "description": "",
    "operationName": "asset-input"
  },
  "NamedParameters<typeof makeBackendAsset>": {
    "name": "NamedParameters<typeof makeBackendAsset>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-makebackendasset",
    "description": "",
    "operationName": "asset-input"
  },
  "NamedParameters<typeof SelectMedia>": {
    "name": "NamedParameters<typeof SelectMedia>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-selectmedia",
    "description": "",
    "operationName": "asset-input"
  },
  "AssetType": {
    "name": "AssetType",
    "slug": "TsInterface",
    "id": "assettype",
    "description": "Possible Asset Types\n\nLater, maybe also support: \"markdown\",\"json\",\"typescript\"",
    "operationName": "markdown-types"
  },
  "CompressionOption": {
    "name": "CompressionOption",
    "slug": "TsInterface",
    "id": "compressionoption",
    "description": "CompressionOption should be able to be applied on the model parameter through frontmatter\n\n- default (default option): Default OS wide compression. User can make customize it within a logical limit\n- none: no compression applied by default (user can optionally compress it)\n- high: compressed bigtime by default (user cannot make it be compressed less)\n- low: compressed just a little (user cannot make it be compressed less, but can optionally compress it more)",
    "operationName": "asset-type",
    "rawText": "\n\n/**\n \nCompressionOption should be able to be applied on the model parameter through frontmatter\n\n- default (default option): Default OS wide compression. User can make customize it within a logical limit\n- none: no compression applied by default (user can optionally compress it)\n- high: compressed bigtime by default (user cannot make it be compressed less)\n- low: compressed just a little (user cannot make it be compressed less, but can optionally compress it more)\n\n */\nexport type CompressionOption = \"custom\" | \"none\" | \"default\" | \"tiny\" | \"big\";"
  },
  "NewAssetType": {
    "name": "NewAssetType",
    "slug": "TsInterface",
    "id": "newassettype",
    "description": "Possible types for new asset upload in the frontend",
    "operationName": "react-with-native-form-asset-input"
  },
  "UploadAssetBody": {
    "name": "UploadAssetBody",
    "slug": "TsInterface",
    "id": "uploadassetbody",
    "description": "NB: other things like alt, final destination etc, should not be sent with the upload, but instead with the function",
    "operationName": "asset-type",
    "rawText": "/**\n NB: other things like alt, final destination etc, should not be sent with the upload, but instead with the function\n */\nexport type UploadAssetBody = {\n  authToken?: string;\n};"
  },
  "UploadAssetResult": {
    "name": "UploadAssetResult",
    "slug": "TsInterface",
    "id": "uploadassetresult",
    "description": "",
    "operationName": "asset-type",
    "rawText": "\n\nexport type UploadAssetResult = {\n  isSuccessful: boolean;\n  message?: string;\n  temporaryDestination?: string;\n};"
  },
  "AugmentedAnyModelType": {
    "name": "AugmentedAnyModelType",
    "slug": "TsInterface",
    "id": "augmentedanymodeltype",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof AssetView>": {
    "name": "NamedParameters<typeof AssetView>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-assetview",
    "description": "",
    "operationName": "asset-view"
  },
  "NamedParameters<typeof getSrc>": {
    "name": "NamedParameters<typeof getSrc>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsrc",
    "description": "",
    "operationName": "asset-view"
  },
  "NamedParameters<typeof itemGetBackendAssetUrl>": {
    "name": "NamedParameters<typeof itemGetBackendAssetUrl>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-itemgetbackendasseturl",
    "description": "",
    "operationName": "asset-view"
  },
  "NamedParameters<typeof useAsset>": {
    "name": "NamedParameters<typeof useAsset>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-useasset",
    "description": "",
    "operationName": "asset-view"
  },
  "NamedParameters<typeof useAssetInfo>": {
    "name": "NamedParameters<typeof useAssetInfo>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-useassetinfo",
    "description": "",
    "operationName": "asset-view"
  },
  "NamedParameters<typeof getAugmentedWordObject>": {
    "name": "NamedParameters<typeof getAugmentedWordObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getaugmentedwordobject",
    "description": "",
    "operationName": "augmented-word-node"
  },
  "NamedParameters<typeof getAugmentedWords>": {
    "name": "NamedParameters<typeof getAugmentedWords>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getaugmentedwords",
    "description": "",
    "operationName": "augmented-word-node"
  },
  "NamedParameters<typeof getBundleAugmentedWords>": {
    "name": "NamedParameters<typeof getBundleAugmentedWords>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getbundleaugmentedwords",
    "description": "",
    "operationName": "augmented-word-node"
  },
  "AugmentedWord": {
    "name": "AugmentedWord",
    "slug": "TsInterface",
    "id": "augmentedword",
    "description": "AugmentedWords should have a small footprint since there can be many of them\n\nWords with a specific affix (backticks, bolded, italic) will match against these.\n\nUsed to link automatically to functionNames, InterfaceNames, operation-names, words, and more..\n\nTODO: This is a much more general purpose thing than just `markdown-reader-types`. Move to it's own package",
    "operationName": "writer-input"
  },
  "AugmentedWordObject": {
    "name": "AugmentedWordObject",
    "slug": "TsInterface",
    "id": "augmentedwordobject",
    "description": "This datastructure is probably needed to make it more efficient.\n\nShould be a lookup table for the querypath for every word",
    "operationName": "augmented-word-types",
    "rawText": "\n\n/**\n * This datastructure is probably needed to make it more efficient.\n *\n * Should be a lookup table for the querypath for every word\n */\nexport type AugmentedWordObject = {\n  [augmentedWord: string]: AugmentedWord;\n};"
  },
  "AugmentedWordTypeEnum": {
    "name": "AugmentedWordTypeEnum",
    "slug": "TsInterface",
    "id": "augmentedwordtypeenum",
    "description": "NB: can later be replaced with a string enum type: person, definition, variable, function, type interface, operation, bundle (but there may be much more)",
    "operationName": "augmented-word-types",
    "rawText": "// NB: can later be replaced with a string enum type: person, definition, variable, function, type interface, operation, bundle (but there may be much more)\nexport type AugmentedWordTypeEnum = string;"
  },
  "Authorization": {
    "name": "Authorization",
    "slug": "TsInterface",
    "id": "authorization",
    "description": "`Authorization` helps you provide certain access to files, data, functionality, and code. Authorization can be provided custom, or by indexation. The indexation of the codebase and text-files overwrites the custom authorization in the `Group`-model.\n\n## Different authorizations\n\nFor files (ts, md, json, etc...):\n\n- canWriteCreate\n- canWriteUpdate\n- canWriteDelete\n- canRead\n- canSearch (only search index)\n\nFor db model data subsets:\n\n- canWriteUpdate\n- canWriteCreate\n- canWriteDelete\n- canRead\n- canSearch (only search index)\n\nFor functions:\n\n- canExecute\n\nFor functions, interfaces, variables:\n\n- canRead (reading docs only. for source, you need to provide the file auth)\n- canSearch (only search index)",
    "operationName": "server-login"
  },
  "AuthorizationModel": {
    "name": "AuthorizationModel",
    "slug": "TsInterface",
    "id": "authorizationmodel",
    "description": "Authorization model for indexed authorizations\n\nDon't edit this! If you wish to add authorizations to a group, either edit the code or text-files, or provide custom authorizations to the `Group`.",
    "operationName": "peer-types"
  },
  "Id": {
    "name": "Id",
    "slug": "TsInterface",
    "id": "id",
    "description": "Should be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
    "operationName": "todo-types"
  },
  "Device": {
    "name": "Device",
    "slug": "TsInterface",
    "id": "device",
    "description": "\nA Device that accesses any King OS api.\n\nA device can be connected to a person. A person can have multiple `Device`s.\n\nA Device does not necissarily have King OS installed themselves, they can also be a visitor to another King OS app of someone else.",
    "operationName": "server-login"
  },
  "NamedParameters<typeof AuthenticationMethodsCrud>": {
    "name": "NamedParameters<typeof AuthenticationMethodsCrud>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-authenticationmethodscrud",
    "description": "",
    "operationName": "authentication"
  },
  "NamedParameters<typeof LoginForm>": {
    "name": "NamedParameters<typeof LoginForm>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-loginform",
    "description": "",
    "operationName": "authentication"
  },
  "NamedParameters<typeof LoginWrapper>": {
    "name": "NamedParameters<typeof LoginWrapper>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-loginwrapper",
    "description": "",
    "operationName": "authentication"
  },
  "NamedParameters<typeof MeAuthenticationInfo>": {
    "name": "NamedParameters<typeof MeAuthenticationInfo>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-meauthenticationinfo",
    "description": "",
    "operationName": "authentication"
  },
  "NamedParameters<typeof PersonProfileDetailsForm>": {
    "name": "NamedParameters<typeof PersonProfileDetailsForm>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-personprofiledetailsform",
    "description": "",
    "operationName": "authentication"
  },
  "NamedParameters<typeof PublicPersonComponent>": {
    "name": "NamedParameters<typeof PublicPersonComponent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-publicpersoncomponent",
    "description": "",
    "operationName": "authentication"
  },
  "NamedParameters<typeof PublicProfile>": {
    "name": "NamedParameters<typeof PublicProfile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-publicprofile",
    "description": "",
    "operationName": "authentication"
  },
  "NamedParameters<typeof SignupForm>": {
    "name": "NamedParameters<typeof SignupForm>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-signupform",
    "description": "",
    "operationName": "authentication"
  },
  "NamedParameters<typeof UpdateMeForm>": {
    "name": "NamedParameters<typeof UpdateMeForm>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-updatemeform",
    "description": "",
    "operationName": "authentication"
  },
  "PersonInfo": {
    "name": "PersonInfo",
    "slug": "TsInterface",
    "id": "personinfo",
    "description": "",
    "operationName": "authentication",
    "rawText": "\n\nexport type PersonInfo = Partial<\n  Pick<Device, \"persons\" | \"currentPersonCalculated\" | \"currentPersonId\">\n>;"
  },
  "PersonProfileDetails": {
    "name": "PersonProfileDetails",
    "slug": "TsInterface",
    "id": "personprofiledetails",
    "description": "Things the user can fill in about themselves on their profile",
    "operationName": "server-login"
  },
  "PublicPerson": {
    "name": "PublicPerson",
    "slug": "TsInterface",
    "id": "publicperson",
    "description": "",
    "operationName": "peer-types",
    "rawText": "\n\nexport type PublicPerson = Pick<Person, PublicPersonKeys>;"
  },
  "NamedParameters<typeof BreadCrumbs>": {
    "name": "NamedParameters<typeof BreadCrumbs>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-breadcrumbs",
    "description": "",
    "operationName": "breadcrumbs"
  },
  "NamedParameters<typeof renderBreadCrumbs>": {
    "name": "NamedParameters<typeof renderBreadCrumbs>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-renderbreadcrumbs",
    "description": "",
    "operationName": "breadcrumbs"
  },
  "BrowserPage": {
    "name": "BrowserPage",
    "slug": "TsInterface",
    "id": "browserpage",
    "description": "",
    "operationName": "browser-types",
    "rawText": "\n\nexport interface BrowserPage extends DefaultModelType {\n  // Store actual page or tabId of browser tab\n  pageId: string;\n  // Store the status of the tab either its active or idle\n  isIdle: boolean;\n}"
  },
  "BrowserSession": {
    "name": "BrowserSession",
    "slug": "TsInterface",
    "id": "browsersession",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "AppShell": {
    "name": "AppShell",
    "slug": "TsInterface",
    "id": "appshell",
    "description": "",
    "operationName": "bundle-types",
    "rawText": "\n\nexport type AppShell =\n  | \"web\"\n  | \"app\"\n  | \"computer\"\n  | \"vscode\"\n  | \"browser\"\n  | \"docusaurus\";"
  },
  "BundleConfig": {
    "name": "BundleConfig",
    "slug": "TsInterface",
    "id": "bundleconfig",
    "description": "\nConfiguration options for bundles. Used with `generateBundle`\n\nEverything in this model will be copied over to the created bundle, except for `createBundleConfig` and `customisableBundleConfig`.",
    "operationName": "markdown-types"
  },
  "BundleMarkdownReaderConfig": {
    "name": "BundleMarkdownReaderConfig",
    "slug": "TsInterface",
    "id": "bundlemarkdownreaderconfig",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "CreateBundleConfig": {
    "name": "CreateBundleConfig",
    "slug": "TsInterface",
    "id": "createbundleconfig",
    "description": "",
    "operationName": "bundle-types",
    "rawText": "\n\nexport type CreateBundleConfig = {\n  /**\n   * You can specify `Slug`s of other `BundleConfig`s here that this bundle should inherit from, recursively.\n   *\n   * Works a little like https://www.typescriptlang.org/tsconfig#extends\n   *\n   * Will only inherit the apps, packages, and modules, nothing else.\n   *\n   * # How it works\n   *\n   * 1) finds all unique `BundleConfig`s that need to be inherited, recursively,\n   * 2) make a `BundleSummary` of every `BundleConfig`\n   * 3) merge the `BundleSummary`s and omit duplicates\n   *\n   * TODO: Implement this\n   */\n  inheritFrom_bundleConfigSlugs?: Slug[];\n  /**\n   * If true, the structure of operation locations is kept the same but still inside packages/apps/modules.\n   */\n  keepStructure?: boolean;\n\n  keepCodestories?: boolean;\n  /**\n   * Default information strategy\n   */\n  informationStrategy?: InformationStrategy;\n\n  /**\n   * Information strategy per model\n   *\n   * For example, this would ensure your diaries are not copied over to the bundle:\n   *\n   * ```json\n   * { \"Diary\": \"ignore\" }\n   * ```\n   *\n   * If you want to be certain something isn't included, instead of putting it into the model specific information strategy, you can also just put it in an operation that isn't required in the bundle.\n   *\n   * This parameter is especially useful if you want to change a information stategy for one model in specific.\n   */\n  modelInformationStrategy?: {\n    [modelName: string]: InformationStrategy;\n  };\n\n  /**\n   * After applying the `informationStrategy`, and `modelInformationStrategy`, these datasets will be added or overwriting the data\n   */\n  additional_datasetSlugs?: Slug[];\n\n  /**\n   * After applying the `informationStrategy`, and `modelInformationStrategy`, these datasets will be found in the then available data in the bundle, and will be filtered out.\n   */\n  filter_datasetSlugs?: Slug[];\n\n  /**\n   * If true, this bundleconfig will be skipped when using `generateAllBundles`\n   */\n  isDraft?: boolean;\n\n  /**\n   * if true, todos are also copied into their original location, which is in `packages` if it's not in an operation, or in the operation in any of the folders if it's an operation.\n   *\n   * The markdown-reader will then add them to a todo menu.\n   *\n   * NB: Only works in conjunction with `keepStructure`\n   */\n  keepTodos?: boolean;\n\n  bundles: FrontBackBundle[];\n  /**\n   * Generated, private by default. If they're already here, uses private/public setting as given.\n   *\n   * When generating, removes the ones that are not dependencies (of dependencies) of your standalone apps\n   */\n  dependencies?: OperationPrivacy[];\n\n  /**\n   * optional. Could also find the main file from here and use that as README.md\n   *\n   * Must be a relative path from project root. Can be multiple!\n   */\n  docsRelativeFolderPath?:\n    | ProjectRelativeFolderPath\n    | ProjectRelativeFolderPath[];\n\n  /**\n   * paths to image folders that should randomly be used as default headers or footers in the generated markdown.\n   */\n  imagesProjectRelativeFolderPaths?: ProjectRelativeFolderPath[];\n  /**\n   * Optional. path to a readme file for the monorepo root.\n   *\n   * If not given, and if you did provide a path for docs, the main docs intro file will be taken\n   *\n   * Must be a relative path from project  root\n   */\n  readmeRelativeFilePath?: ProjectRelativeFilePath;\n\n  /**\n   * if given, it will fetch these folders from the repo and paste them in the bundle whenever the bundle is generated\n   *\n   * can be handy if you're working with someone else...\n   *\n   * Should later be deprecated and p2p operation-sync should be used\n   */\n  foldersFromRepo?: string[];\n};"
  },
  "CustomisableBundleConfig": {
    "name": "CustomisableBundleConfig",
    "slug": "TsInterface",
    "id": "customisablebundleconfig",
    "description": "configuration that can be applied when generating a new bundle\n\nIt can be put in the BundleConfig, but it can also be set manually for an individual Bundle Generation.",
    "operationName": "bundle-types",
    "rawText": "\n\n/**\n * configuration that can be applied when generating a new bundle\n *\n * It can be put in the BundleConfig, but it can also be set manually for an individual Bundle Generation.\n */\nexport type CustomisableBundleConfig = {\n  /**\n   * if true, will not clone/pull/push and deploy. No internet is needed, will also not use any `.git` folder.\n   */\n  isOffline?: boolean;\n  /** skips the step where it gets the new stuff from github */\n  skipPull?: boolean;\n  /** skips the step where it pushes the new bundle to remote */\n  skipPush?: boolean;\n  skipSyncNicheFolder?: boolean;\n  skipRebuildNicheOperations?: boolean;\n  /** skips the step where it saves to the db */\n  skipUpsert?: boolean;\n\n  debug?: boolean;\n  /** descriptioin for git commit, if pushing. Default is \"monorepo update\" */\n  description?: string;\n  /**\n   * optionally, specify a custom branch name to pull from / push to / checkout (default is \"main\")\n   */\n  branchName?: string;\n\n  publicEnvironmentVariables?: EnvironmentVariableObject;\n\n  /**\n   * NB: should not end up in public repos!\n   */\n  privateEnvironmentVariables?: EnvironmentVariableObject;\n\n  /**\n   * Configuration for your commit (needed for vercel deployment)\n   */\n  gitUserEmail?: string;\n  gitUserName?: string;\n};"
  },
  "EnvironmentVariableObject": {
    "name": "EnvironmentVariableObject",
    "slug": "TsInterface",
    "id": "environmentvariableobject",
    "description": "",
    "operationName": "bundle-types",
    "rawText": "\n\nexport interface EnvironmentVariableObject {\n  [key: string]: Json;\n}"
  },
  "FinalBundleConfig": {
    "name": "FinalBundleConfig",
    "slug": "TsInterface",
    "id": "finalbundleconfig",
    "description": "",
    "operationName": "bundle-types",
    "rawText": "\n\nexport type FinalBundleConfig = Omit<\n  BundleConfig,\n  \"customisableBundleConfig\" | \"createBundleConfig\"\n> & {\n  customisableBundleConfig: FinalCustomisableBundleConfig;\n  createBundleConfig: FinalCreateBundleConfig;\n};"
  },
  "FinalCreateBundleConfig": {
    "name": "FinalCreateBundleConfig",
    "slug": "TsInterface",
    "id": "finalcreatebundleconfig",
    "description": "CreateBundleConfig after applying the defaults",
    "operationName": "bundle-types",
    "rawText": "\n\n/**\n * CreateBundleConfig after applying the defaults\n */\nexport type FinalCreateBundleConfig = CreateBundleConfig &\n  Required<Pick<CreateBundleConfig, \"informationStrategy\" | \"foldersFromRepo\">>;"
  },
  "FinalCustomisableBundleConfig": {
    "name": "FinalCustomisableBundleConfig",
    "slug": "TsInterface",
    "id": "finalcustomisablebundleconfig",
    "description": "",
    "operationName": "bundle-types",
    "rawText": "\n\nexport type FinalCustomisableBundleConfig = CustomisableBundleConfig &\n  Required<\n    Pick<CustomisableBundleConfig, \"description\" | \"debug\" | \"branchName\">\n  >;"
  },
  "FrontBackBundle": {
    "name": "FrontBackBundle",
    "slug": "TsInterface",
    "id": "frontbackbundle",
    "description": "This type can specify a frontend and backend that belong to each other. it doesn't include all operations that the ui or server are dependent on, they are calculated separately",
    "operationName": "bundle-types",
    "rawText": "\n\n/**\n * This type can specify a frontend and backend that belong to each other. it doesn't include all operations that the ui or server are dependent on, they are calculated separately\n */\nexport interface FrontBackBundle extends SlugModelType {\n  /**\n   * any operation names that are not necesarily dependencies of the named front-back bundle but still need to be available.\n   */\n  operations?: OperationPrivacy[];\n  /**\n   * (optional) main shared ui package of the frontend\n   */\n  uiOperationName?: string;\n  /**\n   * which app shell(s) or app operations are there for the frontend?\n   */\n  appShellOperationNames?: string[];\n\n  /** operation name for server, if this UI is connected to one */\n  serverOperationName?: string;\n\n  /**\n   * if there is a ui and it has a web-shell, and it is deployed somewhere into production, add the deployed domain here.\n   */\n  productionWebUrl?: string;\n\n  /**\n   * if there is one, it should be specified here (without trailing slash)\n   */\n  productionApiUrl?: string;\n\n  /**\n   * if this is provided, all endpoints require this auth token to be provided, or the endpoints do not work\n   *\n   * if you wish to have a more extensive authentication method for your endpoints, make sure to create your own auth layer\n   */\n  endpointsAuthToken?: string;\n}"
  },
  "InformationStrategy": {
    "name": "InformationStrategy",
    "slug": "TsInterface",
    "id": "informationstrategy",
    "description": "push (default): take needed information from project and push to bundle (removing the existing info)\n\npullReplace: pull bundle and keep its information intact, not taking anything new from the OS, replacing all the information we had from these models in the OS\n\npullMerge: pull bundle and use its information in conjunction with the information we had in the OS. This option will merge both information sources, removing duplicate IDs\n\nignore: don't put any data in the bundle!",
    "operationName": "bundle-types",
    "rawText": "/**\n * push (default): take needed information from project and push to bundle (removing the existing info)\n *\n * pullReplace: pull bundle and keep its information intact, not taking anything new from the OS, replacing all the information we had from these models in the OS\n *\n * pullMerge: pull bundle and use its information in conjunction with the information we had in the OS. This option will merge both information sources, removing duplicate IDs\n *\n * ignore: don't put any data in the bundle!\n *\n */\nexport type InformationStrategy =\n  | \"ignore\"\n  | \"push\"\n  | \"pullReplace\"\n  | \"pullMerge\";"
  },
  "Json": {
    "name": "Json",
    "slug": "TsInterface",
    "id": "json",
    "description": "",
    "operationName": "model-types",
    "rawText": "export type Json =\n  | string\n  | number\n  | boolean\n  | null\n  | { [key: string]: Json }\n  | Json[];"
  },
  "OperationName": {
    "name": "OperationName",
    "slug": "TsInterface",
    "id": "operationname",
    "description": "later we can make this an enum! it can be auto-generated along with enums for the operation paths, and more things alike.\n\nif it's an enum it will automatically be possible to select a value from it in the simplified schema form :D\n\nbesides simply having OperationName, we can have specific operation classification operation names:\n\n- JsOperationName (js)\n- NodeOperationName (node)\n- ServerOperationName (server)\n- AppShellOperationName (web, app, etc.)\n- UiOperationName (ui-es6 and ui-es5)",
    "operationName": "bundle-types",
    "rawText": "/**\n * later we can make this an enum! it can be auto-generated along with enums for the operation paths, and more things alike.\n *\n * if it's an enum it will automatically be possible to select a value from it in the simplified schema form :D\n *\n * besides simply having OperationName, we can have specific operation classification operation names:\n *\n * - JsOperationName (js)\n * - NodeOperationName (node)\n * - ServerOperationName (server)\n * - AppShellOperationName (web, app, etc.)\n * - UiOperationName (ui-es6 and ui-es5)\n */\nexport type OperationName = string;"
  },
  "OperationPrivacy": {
    "name": "OperationPrivacy",
    "slug": "TsInterface",
    "id": "operationprivacy",
    "description": "",
    "operationName": "bundle-types",
    "rawText": "\n\nexport interface OperationPrivacy {\n  operationName: string;\n  /**\n   * if public, everything will be kept\n   *\n   * if private, src and todo will be removed from bundle, unless it's a ui-es6 operation, because src is needed then. In that case, only \"todo\" will be deleted.\n   */\n  privacy: \"public\" | \"private\";\n}"
  },
  "ProjectRelativeFilePath": {
    "name": "ProjectRelativeFilePath",
    "slug": "TsInterface",
    "id": "projectrelativefilepath",
    "description": "",
    "operationName": "bundle-types",
    "rawText": "\nexport type ProjectRelativeFilePath = string;"
  },
  "ProjectRelativeFolderPath": {
    "name": "ProjectRelativeFolderPath",
    "slug": "TsInterface",
    "id": "projectrelativefolderpath",
    "description": "later this could be known by the frontend so it will render a ui to select a folder\n\nWe need to figure out how we can know all type types in between when getting the type definition schema, not only the final type. If I'm lucky there is a way to find it as a #ref in a consistent way.",
    "operationName": "bundle-types",
    "rawText": "\n\n/**\n * later this could be known by the frontend so it will render a ui to select a folder\n *\n * We need to figure out how we can know all type types in between when getting the type definition schema, not only the final type. If I'm lucky there is a way to find it as a #ref in a consistent way.\n */\nexport type ProjectRelativeFolderPath = string;"
  },
  "PublicBundleConfig": {
    "name": "PublicBundleConfig",
    "slug": "TsInterface",
    "id": "publicbundleconfig",
    "description": "",
    "operationName": "reader-ui"
  },
  "ServerOperationName": {
    "name": "ServerOperationName",
    "slug": "TsInterface",
    "id": "serveroperationname",
    "description": "",
    "operationName": "bundle-types",
    "rawText": "\nexport type ServerOperationName = string;"
  },
  "Slug": {
    "name": "Slug",
    "slug": "TsInterface",
    "id": "slug",
    "description": "use this for any identifier that's not an Id-type. Usually this is a kebab-case version of a written text, but it can also be a file path, for example.",
    "operationName": "todo-types"
  },
  "BundleSummary": {
    "name": "BundleSummary",
    "slug": "TsInterface",
    "id": "bundlesummary",
    "description": "",
    "operationName": "bundle-util",
    "rawText": "\n\nexport type BundleSummary = {\n  slug: string;\n  /**\n   * Haven't found a good usecase for this yet\n   */\n  // filesAndFoldersToInclude: string[];\n  packageNames: string[];\n  moduleNames: string[];\n  appNames: string[];\n};"
  },
  "NamedParameters<typeof getBundleSummary>": {
    "name": "NamedParameters<typeof getBundleSummary>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getbundlesummary",
    "description": "",
    "operationName": "bundle-util"
  },
  "NamedParameters<typeof getDbModelsForBundle>": {
    "name": "NamedParameters<typeof getDbModelsForBundle>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdbmodelsforbundle",
    "description": "",
    "operationName": "bundle-util"
  },
  "LoginResponse": {
    "name": "LoginResponse",
    "slug": "TsInterface",
    "id": "loginresponse",
    "description": "",
    "operationName": "chatgpt-controller",
    "rawText": "\n\nexport type LoginResponse = {\n  isSuccessfull: boolean;\n  message?: string;\n};"
  },
  "NamedParameters<typeof chatGPTAuth>": {
    "name": "NamedParameters<typeof chatGPTAuth>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-chatgptauth",
    "description": "",
    "operationName": "chatgpt-controller"
  },
  "NamedParameters<typeof detectChatGptPage>": {
    "name": "NamedParameters<typeof detectChatGptPage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-detectchatgptpage",
    "description": "",
    "operationName": "chatgpt-controller"
  },
  "NamedParameters<typeof openAIChat>": {
    "name": "NamedParameters<typeof openAIChat>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-openaichat",
    "description": "",
    "operationName": "chatgpt-controller"
  },
  "OpenAIChatProps": {
    "name": "OpenAIChatProps",
    "slug": "TsInterface",
    "id": "openaichatprops",
    "description": "",
    "operationName": "chatgpt-controller",
    "rawText": "\n\nexport type OpenAIChatProps = {\n  prompt: string;\n  thread?: string;\n  isHeadless?: boolean;\n};"
  },
  "OpenAIChatResponseType": {
    "name": "OpenAIChatResponseType",
    "slug": "TsInterface",
    "id": "openaichatresponsetype",
    "description": "",
    "operationName": "chatgpt-controller",
    "rawText": "\n\nexport type OpenAIChatResponseType = {\n  result?: string;\n  thread?: string;\n  isSuccess: boolean;\n};"
  },
  "Page": {
    "name": "Page",
    "slug": "TsInterface",
    "id": "page",
    "description": "Page provides methods to interact with a single tab or\n{@link  https://developer.chrome.com/extensions/background_pages | extension background page }\nin Chromium.\n\n:::note\n\nOne Browser instance might have multiple Page instances.\n\n:::",
    "operationName": "puppeteer-utils"
  },
  "ExecOptions": {
    "name": "ExecOptions",
    "slug": "TsInterface",
    "id": "execoptions",
    "description": "",
    "operationName": "child-process-helper"
  },
  "NamedParameters<typeof execAsync>": {
    "name": "NamedParameters<typeof execAsync>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-execasync",
    "description": "",
    "operationName": "child-process-helper"
  },
  "NamedParameters<typeof spawnAsync>": {
    "name": "NamedParameters<typeof spawnAsync>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-spawnasync",
    "description": "",
    "operationName": "child-process-helper"
  },
  "SpawnOptionsWithoutStdio": {
    "name": "SpawnOptionsWithoutStdio",
    "slug": "TsInterface",
    "id": "spawnoptionswithoutstdio",
    "description": "",
    "operationName": "child-process-helper"
  },
  "NamedParameters<typeof cleanupTsDatabase>": {
    "name": "NamedParameters<typeof cleanupTsDatabase>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-cleanuptsdatabase",
    "description": "",
    "operationName": "cleanup-typescript-database"
  },
  "NamedParameters<typeof shouldDeleteTsModel>": {
    "name": "NamedParameters<typeof shouldDeleteTsModel>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-shoulddeletetsmodel",
    "description": "",
    "operationName": "cleanup-typescript-database"
  },
  "TsBuildError": {
    "name": "TsBuildError",
    "slug": "TsInterface",
    "id": "tsbuilderror",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport interface TsBuildError extends TsIndexModelType {\n  line?: number;\n  character?: number;\n  message: string;\n}"
  },
  "TsComment": {
    "name": "TsComment",
    "slug": "TsInterface",
    "id": "tscomment",
    "description": "comments are basically one-or-multi-line human content inside of typescript files, so it's a very important to do something useful with them.\n\n\nThe convention should be that single-line comments should start with that. This then becomes the type of the comment.\nYou can also put multiple prefixes at the start.\n\nExample:\n\n`// TODO: NB: this is a todo but its also important`\n\nMultiline comments can also have one or multiple types in their text, but they should not be split into multiple comments as the context could be needed some times.\n\n\n\nThere are also some other things comments can say about statements, but these should be inside the frontmatter, and are much more flexible.\n- classified[0-10] indicating level of classification. This way I can share subsets of the codebase, maybe...\n- privacy\n- ...?\n\nNB: with the current setup we can also parse `.md` files as being a TsComment, keep it that way!\n\nNB: comments are part of the code, so they should always be in English!",
    "operationName": "code-types",
    "rawText": "\n/**\n * comments are basically one-or-multi-line human content inside of typescript files, so it's a very important to do something useful with them.\n *\n *\n * The convention should be that single-line comments should start with that. This then becomes the type of the comment.\n * You can also put multiple prefixes at the start.\n *\n * Example:\n *\n * `// TODO: NB: this is a todo but its also important`\n *\n * Multiline comments can also have one or multiple types in their text, but they should not be split into multiple comments as the context could be needed some times.\n *\n *\n *\n * There are also some other things comments can say about statements, but these should be inside the frontmatter, and are much more flexible.\n * - classified[0-10] indicating level of classification. This way I can share subsets of the codebase, maybe...\n * - privacy\n * - ...?\n *\n * NB: with the current setup we can also parse `.md` files as being a TsComment, keep it that way!\n *\n * NB: comments are part of the code, so they should always be in English!\n */\n\nexport interface TsComment extends TsIndexModelType {\n  /**\n   * the content of the comment in markdown, without frontmatter\n   */\n  comment: Markdown;\n  /**\n   * parameters destructured from the frontmatter of the parsed markdown (if comment is not a oneliner, otherwise it'll be empty)\n   */\n  parameters: Frontmatter;\n  /**\n   * These are the type indicators that were found in this single or multiline comment. Can be multiple.\n   */\n  types: CommentType[];\n\n  /**\n   * first line of the comment\n   */\n  firstLine: number;\n  /**\n   * last line of the comment\n   */\n  lastLine: number;\n  /**\n   * statement name the comment belongs to\n   */\n  statementName?: string;\n  /**\n   * raw statement text the comment belongs to\n   */\n  rawStatement?: string;\n}"
  },
  "TsExport": {
    "name": "TsExport",
    "slug": "TsInterface",
    "id": "tsexport",
    "description": "",
    "operationName": "find-all-dependency-operations"
  },
  "TsImport": {
    "name": "TsImport",
    "slug": "TsInterface",
    "id": "tsimport",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "TsInterface": {
    "name": "TsInterface",
    "slug": "TsInterface",
    "id": "tsinterface",
    "description": "\nTODO: Just like parameters, this should be linted for. If you define an interface that's not declared here, that should ring a bell.",
    "operationName": "markdown-types"
  },
  "TsLintWarning": {
    "name": "TsLintWarning",
    "slug": "TsInterface",
    "id": "tslintwarning",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport interface TsLintWarning extends TsIndexModelType {\n  line: number;\n  character: number;\n  message: string;\n}"
  },
  "TsVariable": {
    "name": "TsVariable",
    "slug": "TsInterface",
    "id": "tsvariable",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "AnyModelType": {
    "name": "AnyModelType",
    "slug": "TsInterface",
    "id": "anymodeltype",
    "description": "Parameters that every model will always have.\n\nNB: TimeTypes (createdAt, updatedAt, etc.) are not always included because the kvmd-model doesn't have them.\n\nNB: RelationTypes are also not always included for the same reason",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * Parameters that every model will always have.\n *\n * NB: TimeTypes (createdAt, updatedAt, etc.) are not always included because the kvmd-model doesn't have them.\n *\n * NB: RelationTypes are also not always included for the same reason\n */\nexport interface AnyModelType extends ModelLocation {\n  id: Id;\n}"
  },
  "ApiFunction": {
    "name": "ApiFunction",
    "slug": "TsInterface",
    "id": "apifunction",
    "description": "TODO: rename to `StandardFunction`, it's not just for the API",
    "operationName": "code-types",
    "rawText": "\n\n/**\n * TODO: rename to `StandardFunction`, it's not just for the API\n */\nexport type ApiFunction = {\n  (...parameters: any[]): any;\n} & ApiFunctionParameters;"
  },
  "ApiFunctionParameters": {
    "name": "ApiFunctionParameters",
    "slug": "TsInterface",
    "id": "apifunctionparameters",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport type ApiFunctionParameters = {\n  /**\n   * Used to determine if there are important changes. Can be added to things that used this function for example, for indexation, for example. This way we know how the index came to be better.\n   */\n  version?: string;\n  /**\n   * Provide info for every version. Especially needed if we have a function that produces output that we'll keep using. This way we can trace back the behavior that caused the output\n   */\n  versionInfo?: {\n    [version: string]: string;\n  };\n  /**\n   * Requires lots of ram/cpu/gpu (e.g. local AI models, file conversions, and data manipulation at scale)\n   *\n   * Will not be started if computer is busy already\n   */\n  isHeavy?: boolean;\n\n  /**\n   * If true, you state that this function requires internet. Will not be executed if there's no internet connection\n   */\n  isInternetRequired?: boolean;\n  /**\n   * Puppeteer stuff\n   */\n  isBrowserRequired?: boolean;\n\n  /**\n   * If `true`, this function will be publicly available through the API\n   */\n  isPublic?: boolean;\n  /**\n   * for all exported functions in node operations, true by default\n   * false for others\n   *\n   * can be overwritten using frontmatter\n   *\n   * TODO: remove, should be same as `isPublic`\n   */\n  isApiExposed?: boolean;\n\n  /**\n   * If it's a slug without TLD, the function will be on on a landing page without its own domain\n   * If it's a slug with TLD, it can get it's own domain\n   * If domain is given, function is wrapped into `sdk-public-tools`, wrapped with:\n   *\n   * - providing email and other required credentials\n   * - adding to queue if server is busy\n   *\n   * Later I can wrap this even more with monetisation and 'tool-owner', so I can let others do the same with a single click (promote after form is filled is like \"learn more about how to earn money with the new AI tech revolution (or so)\")\n   */\n  domain?: string;\n  /**\n   * - If true, usage will be counted in `UsageReport`\n   * - If \"isSuccessful\", usage will be counted only if this function returns `.isSuccessful: true`\n   *\n   * NB: not sure if the latter is needed\n   *\n   */\n  isPaid?: true | \"isSuccessful\";\n  /**\n   * Cost per execution in EURO CENT\n   *\n   * e.g. 0.05 means that 2000 executions cost 1 euro.\n   */\n  price?: number;\n\n  allowedRoles?: string[];\n\n  /**\n   * Other keys in frontmatter that are group names, can be added here\n   *\n   * TODO: maybe replace with `.allowedRoles`\n   */\n  groupAuthorization?: { [groupName: string]: string };\n\n  /**\n   * whether or not the function can be cached (relies on cache invalidation)\n   */\n  canCache?: boolean;\n\n  /**\n    You can specify `runEveryPeriod` in your frontmatter of a function. This will set `runEveryPeriod` for the TsFunction. This is used by `function-server`: it will execute CRON-jobs that run these things on those periods.\n \n    Will only work if the function takes no arguments.\n    */\n  runEveryPeriod?: RunEveryPeriodEnum;\n  /**\n   * Type of function for frontend\n   */\n  classification?: FunctionClassification;\n};"
  },
  "CategorizedFilePaths": {
    "name": "CategorizedFilePaths",
    "slug": "TsInterface",
    "id": "categorizedfilepaths",
    "description": "filepaths categorized based on the filetype. With king os there are only these filetypes:\n\n- code: ts, tsx\n- data: json\n- text: md, mdx",
    "operationName": "path-util"
  },
  "CommentType": {
    "name": "CommentType",
    "slug": "TsInterface",
    "id": "commenttype",
    "description": "special line prefixes:\n\n*Developer related comments**\n\n- TODO: for developer to know what to do\n- DISCUSSION: for developer to state that discussion is needed\n- IDEA: for developer to state ideas\n- LATER: for developer to mark as thing that needs to be done later\n- NB: for developer to add a note\n\n*Form related comments**\n\n- TITLE: if available, will be used as title of form input (overwrites humanCase version of the property-name itself in that case)\n- SECTION: start a new section in the form from this point, the value behind here can be the title\n- DESCRIPTION: if available, will be used as description of the form input",
    "operationName": "read-typescript-file"
  },
  "CommentTypeObject": {
    "name": "CommentTypeObject",
    "slug": "TsInterface",
    "id": "commenttypeobject",
    "description": "Every `CommentType` can be a key in the `SimplifiedSchema`, if available.",
    "operationName": "code-types",
    "rawText": "\n\n/**\n * Every `CommentType` can be a key in the `SimplifiedSchema`, if available.\n */\nexport type CommentTypeObject = {\n  [commentType in CommentType]?: string;\n};"
  },
  "CommitInfo": {
    "name": "CommitInfo",
    "slug": "TsInterface",
    "id": "commitinfo",
    "description": "",
    "operationName": "code-types",
    "rawText": "export type CommitInfo = {\n  /**\n   * unique commit sha\n   */\n  commitSha: string;\n  committedAt?: number;\n  commitMessage: string;\n};"
  },
  "CompilerOptions": {
    "name": "CompilerOptions",
    "slug": "TsInterface",
    "id": "compileroptions",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport interface CompilerOptions {\n  allowJs?: boolean;\n  allowSyntheticDefaultImports?: boolean;\n  allowUmdGlobalAccess?: boolean;\n  allowUnreachableCode?: boolean;\n  allowUnusedLabels?: boolean;\n  alwaysStrict?: boolean;\n  baseUrl?: string;\n  charset?: string;\n  checkJs?: boolean;\n  declaration?: boolean;\n  declarationMap?: boolean;\n  emitDeclarationOnly?: boolean;\n  declarationDir?: string;\n  disableSizeLimit?: boolean;\n  disableSourceOfProjectReferenceRedirect?: boolean;\n  disableSolutionSearching?: boolean;\n  disableReferencedProjectLoad?: boolean;\n  downlevelIteration?: boolean;\n  emitBOM?: boolean;\n  emitDecoratorMetadata?: boolean;\n  exactOptionalPropertyTypes?: boolean;\n  experimentalDecorators?: boolean;\n  forceConsistentCasingInFileNames?: boolean;\n  importHelpers?: boolean;\n  importsNotUsedAsValues?: ImportsNotUsedAsValues;\n  inlineSourceMap?: boolean;\n  inlineSources?: boolean;\n  isolatedModules?: boolean;\n  jsx?: JsxEmit;\n  keyofStringsOnly?: boolean;\n  lib?: string[];\n  locale?: string;\n  mapRoot?: string;\n  maxNodeModuleJsDepth?: number;\n  module?: ModuleKind;\n  moduleResolution?: ModuleResolutionKind;\n  moduleSuffixes?: string[];\n  moduleDetection?: ModuleDetectionKind;\n  newLine?: NewLineKind;\n  noEmit?: boolean;\n  noEmitHelpers?: boolean;\n  noEmitOnError?: boolean;\n  noErrorTruncation?: boolean;\n  noFallthroughCasesInSwitch?: boolean;\n  noImplicitAny?: boolean;\n  noImplicitReturns?: boolean;\n  noImplicitThis?: boolean;\n  noStrictGenericChecks?: boolean;\n  noUnusedLocals?: boolean;\n  noUnusedParameters?: boolean;\n  noImplicitUseStrict?: boolean;\n  noPropertyAccessFromIndexSignature?: boolean;\n  assumeChangesOnlyAffectDirectDependencies?: boolean;\n  noLib?: boolean;\n  noResolve?: boolean;\n  noUncheckedIndexedAccess?: boolean;\n  out?: string;\n  outDir?: string;\n  outFile?: string;\n  paths?: MapLike<string[]>;\n  preserveConstEnums?: boolean;\n  noImplicitOverride?: boolean;\n  preserveSymlinks?: boolean;\n  preserveValueImports?: boolean;\n  project?: string;\n  reactNamespace?: string;\n  jsxFactory?: string;\n  jsxFragmentFactory?: string;\n  jsxImportSource?: string;\n  composite?: boolean;\n  incremental?: boolean;\n  tsBuildInfoFile?: string;\n  removeComments?: boolean;\n  rootDir?: string;\n  rootDirs?: string[];\n  skipLibCheck?: boolean;\n  skipDefaultLibCheck?: boolean;\n  sourceMap?: boolean;\n  sourceRoot?: string;\n  strict?: boolean;\n  strictFunctionTypes?: boolean;\n  strictBindCallApply?: boolean;\n  strictNullChecks?: boolean;\n  strictPropertyInitialization?: boolean;\n  stripInternal?: boolean;\n  suppressExcessPropertyErrors?: boolean;\n  suppressImplicitAnyIndexErrors?: boolean;\n  target?: ScriptTarget;\n  traceResolution?: boolean;\n  useUnknownInCatchVariables?: boolean;\n  resolveJsonModule?: boolean;\n  types?: string[];\n  /** Paths used to compute primary types search locations */\n  typeRoots?: string[];\n  esModuleInterop?: boolean;\n  useDefineForClassFields?: boolean;\n  [option: string]: any | undefined;\n}"
  },
  "ContributorPersonInfo": {
    "name": "ContributorPersonInfo",
    "slug": "TsInterface",
    "id": "contributorpersoninfo",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport type ContributorPersonInfo = {\n  /**\n   * NPM convention, name of the contributor\n   */\n  name: string;\n  /**\n   * NPM convention, url with more info of the contributor\n   */\n  url?: string;\n  /**\n   * NPM convention, email of the contributor\n   */\n  email?: string;\n\n  /**\n   * Relative amount of estimated contribution to this operation, should be a number between 0 and 1\n   */\n  contributionAmount?: number;\n};"
  },
  "DatasetConfig": {
    "name": "DatasetConfig",
    "slug": "TsInterface",
    "id": "datasetconfig",
    "description": "The part of dataset that can be used in certain functions",
    "operationName": "code-types",
    "rawText": "\n\n/**\n * The part of dataset that can be used in certain functions\n */\nexport interface DatasetConfig extends DatasetConfigShape {\n  /**\n   * Filters are applied after each other\n   */\n  filter?: DatasetFilter[];\n\n  /**\n   *\n   */\n  sort?: DatasetSort[];\n\n  /**\n   * Specify a max amount of items n\n   */\n  maxRows?: number;\n\n  /**\n   * If specified, slices the sorted array to omit the first n items;\n   */\n  startFromIndex?: number;\n\n  /**\n   * If specified, will only include these parameter keys of the model object. Otherwise all keys will be taken\n   */\n  objectParameterKeys?: string[];\n\n  /**\n   * If specified, will omit these keys when creating the dataset\n   */\n  ignoreObjectParameterKeys?: string[];\n}"
  },
  "DatasetConfigKey": {
    "name": "DatasetConfigKey",
    "slug": "TsInterface",
    "id": "datasetconfigkey",
    "description": "",
    "operationName": "code-types",
    "rawText": "\nexport type DatasetConfigKey = typeof datasetConfigKeys[number];"
  },
  "DatasetConfigShape": {
    "name": "DatasetConfigShape",
    "slug": "TsInterface",
    "id": "datasetconfigshape",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport type DatasetConfigShape = { [key in DatasetConfigKey]?: any };"
  },
  "DatasetFilter": {
    "name": "DatasetFilter",
    "slug": "TsInterface",
    "id": "datasetfilter",
    "description": "Can be better, see https://www.w3schools.com/js/js_comparisons.asp",
    "operationName": "code-types",
    "rawText": "\n/**\n * Can be better, see https://www.w3schools.com/js/js_comparisons.asp\n */\nexport type DatasetFilter = {\n  objectParameterKey: string;\n  /**\n   * This will sometines need to be casted\n   */\n  value: string;\n  /**\n   * Uses type equality\n   */\n  operator: DatasetFilterOperator;\n  /**\n   * TODO: Maybe add possibility to use a sort function from the SDK\n   */\n  filterFunctionName?: string;\n};"
  },
  "DatasetFilterOperator": {
    "name": "DatasetFilterOperator",
    "slug": "TsInterface",
    "id": "datasetfilteroperator",
    "description": "",
    "operationName": "code-types",
    "rawText": "\nexport type DatasetFilterOperator = typeof datasetFilterOperatorConst[number];"
  },
  "DatasetSort": {
    "name": "DatasetSort",
    "slug": "TsInterface",
    "id": "datasetsort",
    "description": "Sort by comparing the two values using the `Array.sort` method and Greater than and Less than operators.",
    "operationName": "db-crud"
  },
  "DbStorageMethod": {
    "name": "DbStorageMethod",
    "slug": "TsInterface",
    "id": "dbstoragemethod",
    "description": "The following strategies are available to store the data.\n\n- **jsonMultiple *(default)***: stores the data in a json file which is an array of this data structure. This file will be located in `db/[pluralized-kebab-case-model-name].json`\n\n- **jsonSingle**: stores the data in a json file which is of this data structure (single object) These files will be located in `db/[pluralized-kebab-case-model-name]/[instance-slug-or-id].json`\n\n- **markdown**: stores the data in a markdown file. Takes \"markdown\" parameter as the main markdown. The other parameters are stored as front-matter. This these files will be located in `db/[pluralized-kebab-case-model-name]/[instance-slug-or-id].md`\n\n- **keyValueMarkdown**: stores the data in key value markdown format. This file will be located in `db/[pluralized-kebab-case-model-name].md`\n\n- **csv**: stores the data in a csv file (only possible for flat object datastructures). This file will be located in `db/[pluralized-kebab-case-model-name].csv`\n\n## Definitions:\n\n- [pluralized-kebab-case-model-name]: e.g. `StudentUser` becomes `student-users`\n- [instance-slug-or-id]: For all models with a slug parameter, the filename will be that slug of that instance. Otherwise, `id` will be used",
    "operationName": "fs-orm"
  },
  "ExplorationDetails": {
    "name": "ExplorationDetails",
    "slug": "TsInterface",
    "id": "explorationdetails",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport type ExplorationDetails = {\n  success?: boolean;\n  response?: string;\n  //\n  markdown?: any; //MarkdownParse;\n  pathMetaData?: PathMetaData;\n  operations?: Operation[];\n  index: TsInterface[];\n} & Partial<TypescriptIndex>;"
  },
  "FileContentInfo": {
    "name": "FileContentInfo",
    "slug": "TsInterface",
    "id": "filecontentinfo",
    "description": "Stuff you can find by reading the file",
    "operationName": "markdown-types"
  },
  "FolderExploration": {
    "name": "FolderExploration",
    "slug": "TsInterface",
    "id": "folderexploration",
    "description": "suggested type for menu is FolderExploration[]\n\nNB: recursive!",
    "operationName": "code-types",
    "rawText": "\n/**\n * suggested type for menu is FolderExploration[]\n *\n * NB: recursive!\n */\nexport type FolderExploration = {\n  /**\n   * folder is a regular folder outside of operations\n   *\n   * operation is a folder that is the root of an operation\n   *\n   * operationFolder is a folder inside of an operation\n   *\n   * other things are self-explanatory\n   */\n  type:\n    | \"folder\"\n    | \"operation\"\n    | \"operationFolder\"\n    | \"markdown\"\n    | \"typescript\"\n    | \"function\"\n    | \"interface\"\n    | \"variable\";\n  name: string;\n  /** path to the folder, operation, operationFolder, or file. functions, interfaces or variables direct to the file they are defined in */\n  relativeProjectPath: string;\n  /**\n   * Every FolderExploration has children, which are simply the files/folders that can be found in there. The children of files are functions, interfaces and variables for typescript files. Markdownfiles don't get any children (although we could childify the outline of the file, maybe, later...)\n   */\n  children?: FolderExploration[];\n};"
  },
  "FolderSummary": {
    "name": "FolderSummary",
    "slug": "TsInterface",
    "id": "foldersummary",
    "description": "objective size measurements of all files in a folder\n\nsummary for a folder should contain file-summaries for different filetypes and an overal file summary",
    "operationName": "markdown-parsings"
  },
  "FunctionClassification": {
    "name": "FunctionClassification",
    "slug": "TsInterface",
    "id": "functionclassification",
    "description": "- `react`: The core library that should always be used that wraps react and react native.\n\n- `dumb`: Presentational components that only care about how things look, and have no idea about the type of information that they will contain (**data-agnostic**), nor their context they're used in.\n\n- `smart`: Presentational components that may contain getters and setters for global state. This means they're still easy enough to set up, but\n\n- `wise`: stateful components that use the backend as well to do things. for example, `simplified-schema-form`\n\n- `genius`: blocks of components that have certain functionality. Example: `file-writer` or `crud`",
    "operationName": "code-types",
    "rawText": "/**\n- `react`: The core library that should always be used that wraps react and react native.\n\n- `dumb`: Presentational components that only care about how things look, and have no idea about the type of information that they will contain (**data-agnostic**), nor their context they're used in.\n\n- `smart`: Presentational components that may contain getters and setters for global state. This means they're still easy enough to set up, but\n\n- `wise`: stateful components that use the backend as well to do things. for example, `simplified-schema-form`\n\n- `genius`: blocks of components that have certain functionality. Example: `file-writer` or `crud`\n*/\nexport type FunctionClassification =\n  | \"wise\"\n  | \"dumb\"\n  | \"smart\"\n  | \"genius\"\n  | \"react-with-native\"\n  | \"cli\"\n  | \"test\";"
  },
  "FunctionParameter": {
    "name": "FunctionParameter",
    "slug": "TsInterface",
    "id": "functionparameter",
    "description": "",
    "operationName": "function-util"
  },
  "ImportClassification": {
    "name": "ImportClassification",
    "slug": "TsInterface",
    "id": "importclassification",
    "description": "node: node core packages like fs and path\n\nreact: react standard packages like react, react-native, expo, react-dom, etc.\n\npackage: packages from npm that are not classified as operations\n\noperation: operations from our monorepo\n\ninternal: imports from other places in the same operation\n\nNB: don't confuse this with OperationClassification",
    "operationName": "code-types",
    "rawText": "\n\n/**\n * node: node core packages like fs and path\n *\n * react: react standard packages like react, react-native, expo, react-dom, etc.\n *\n * package: packages from npm that are not classified as operations\n *\n * operation: operations from our monorepo\n *\n * internal: imports from other places in the same operation\n *\n * NB: don't confuse this with OperationClassification\n */\nexport type ImportClassification =\n  | \"node\"\n  | \"react\"\n  | \"package\"\n  | \"operation\"\n  | \"internal\";"
  },
  "IndexModels": {
    "name": "IndexModels",
    "slug": "TsInterface",
    "id": "indexmodels",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport type IndexModels = {\n  TsBuildError: TsBuildError;\n  TsLintWarning: TsLintWarning;\n  TsFunction: TsFunction;\n  TsVariable: TsVariable;\n  TsInterface: TsInterface;\n  TsComment: TsComment;\n  TsImport: TsImport;\n  TsExport: TsExport;\n};"
  },
  "JSONSchema7Type": {
    "name": "JSONSchema7Type",
    "slug": "TsInterface",
    "id": "jsonschema7type",
    "description": "Primitive type",
    "operationName": "code-types"
  },
  "Markdown": {
    "name": "Markdown",
    "slug": "TsInterface",
    "id": "markdown",
    "description": "a string that is known to contain markdown.",
    "operationName": "todo-types"
  },
  "MaybeInteface": {
    "name": "MaybeInteface",
    "slug": "TsInterface",
    "id": "maybeinteface",
    "description": "at some point in processing we need this interface where definition can also be null",
    "operationName": "index-typescript"
  },
  "ModelInfo": {
    "name": "ModelInfo",
    "slug": "TsInterface",
    "id": "modelinfo",
    "description": "used to show a list of models available in a menu structure",
    "operationName": "code-types",
    "rawText": "/**\n * used to show a list of models available in a menu structure\n */\nexport type ModelInfo = {\n  name: string;\n  slug: string;\n  rows: number;\n};"
  },
  "ModelView": {
    "name": "ModelView",
    "slug": "TsInterface",
    "id": "modelview",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport type ModelView = typeof modelViews[number];"
  },
  "ModelViewEnum": {
    "name": "ModelViewEnum",
    "slug": "TsInterface",
    "id": "modelviewenum",
    "description": "Models should be able to be shown in multiple different views:\n\n- Table: useful to show models with much details\n- Grid: useful to show models with a visual aspect and less details\n- Timeline: useful to show text-related models\n- Tree: useful to show a hierarchy",
    "operationName": "code-types",
    "rawText": "\n/**\n * Models should be able to be shown in multiple different views:\n *\n * - Table: useful to show models with much details\n * - Grid: useful to show models with a visual aspect and less details\n * - Timeline: useful to show text-related models\n * - Tree: useful to show a hierarchy\n */\nexport type ModelViewEnum = typeof modelViews[number][\"view\"];"
  },
  "NamedParameters<typeof getExamples>": {
    "name": "NamedParameters<typeof getExamples>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getexamples",
    "description": "",
    "operationName": "code-types"
  },
  "NamedParameters<typeof getFunctionExersize>": {
    "name": "NamedParameters<typeof getFunctionExersize>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfunctionexersize",
    "description": "",
    "operationName": "code-types"
  },
  "Operation": {
    "name": "Operation",
    "slug": "TsInterface",
    "id": "operation",
    "description": "\nModel for `typerepo` operations. Stored in `package.json` in every package (compatible with regular npm package.json data structure). An `Operation` is a NPM Package that applies the `typerepo` convention.\n\nTODO: add a validation to package.json files for the whole project, to ensure i can apply `fs-orm` convention",
    "operationName": "operation-util"
  },
  "OperationClassification": {
    "name": "OperationClassification",
    "slug": "TsInterface",
    "id": "operationclassification",
    "description": "`OperationClassification` tells you to what kind of environment the operation can be exposed to. It tells you things about how it will be built. There are three categories: Full stack, frontend only, and backend only. The aim is to do as much as possible in the full stack realm so it can be reused anywhere. If that is not possible, `ui-esm` is preferred for the frontend, or `node-esm` for things that require backend.\n\nTODO: It would be great to learn more about this topic and see if I can make more cross-environment packages. A great use case would be to create a wrapper around the current `fs-orm` to enable using it at the frontend too.\n\n# Possible values\n\nFULL STACK\n\n- `cjs`: only js (no node) (well, ts of course, but it gets built into common js)\n\n- `ts`: non-built typescript code (needs to be transpiled, not recommended)\n\nTODO: `esm`: builds to ESM module resolved Javascript\n\nFRONTEND ONLY (cannot be used within backend-only operations)\n\n- `ui-web`: has next.config.js and thus exposes something on some port when it is ran. next.js + react-based...\n\n- `ui-app`: uses react-native and exposes something on some port when it is ran\n\n- `ui-ts`: uses react (with (native)), which main entry points to typescript es6 files (this ui package cannot be built, should be transpiled. Primarily used for big ui libraries tied to a `ui-web` and `ui-app` for convenience. For other things, it is highly discouraged, please use `ui-cjs` or `ui-esm`)\n\n- `ui-cjs`: ui which main entry points to javascript es5 files (this ui package can be built). don't import ESM packages in here, this may give problems.\n\n- `ui-esm`: ui which builds to ESM module resolved Javascript. All packages that use `ui-esm` packages, need to be `ui-esm`, `ui-es6`, `ui-web`, or `ui-app` in order to work properly. It seems to have difficulties using this in `ui-cjs`\n\nBACKEND ONLY (cannot be used within frontend-only operations)\n\n- `node-cjs`: includes other node packages, operations, core-imports, and globals.\n\nTODO: `node-esm`: Typescript package that is built to ESM Javascript which also includes all node packages, operations, core-imports and globals.\n\nTODO: `node-ts`: transpilable node package\n\n- `server-cjs`: exposes something on some port when it is ran and uses node code\n\n# Indexation\n\nOperations will be classified automatically. It is good to remember that:\n\n- It will be classified as UI if `isUiOperation` resolves to true\n- It will be classified as Node if `Operation` has a (dev)dependency on `@types/node`.\n- Otherwise, it will be classified as base typescript (full stack)\n- It will be classified to an ESM operation if `tsconfigCompilesEsm` resolves to true.\n- It will be classified to a TS operation if `packageCompilesTs` resolves to true\n- In order for it to be classified as a server, you must set `isNodeServer` to true in the `.operation` config object of `Operation`",
    "operationName": "new-template"
  },
  "OperationPathParse": {
    "name": "OperationPathParse",
    "slug": "TsInterface",
    "id": "operationpathparse",
    "description": "",
    "operationName": "index-typescript"
  },
  "OperationRepositoryInfo": {
    "name": "OperationRepositoryInfo",
    "slug": "TsInterface",
    "id": "operationrepositoryinfo",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport type OperationRepositoryInfo = {\n  //default NPM stuff\n  type?: string;\n  url: string;\n  directory?: string;\n\n  // Indexed Operation-stuff that we added\n  lastPullTimeAt?: number;\n  lastCommitInfo?: CommitInfo;\n  htmlUrl?: string;\n  collaborators?: string[];\n  forksCount?: number;\n  stargazersCount?: number;\n  watchersCount?: number;\n  openIssuesCount?: number;\n  size?: number;\n  visibility?: string;\n  defaultBranch?: string;\n};"
  },
  "PackageInfoObject": {
    "name": "PackageInfoObject",
    "slug": "TsInterface",
    "id": "packageinfoobject",
    "description": "",
    "operationName": "get-imports-exports"
  },
  "ParameterName": {
    "name": "ParameterName",
    "slug": "TsInterface",
    "id": "parametername",
    "description": "",
    "operationName": "language-types"
  },
  "PathMetaData": {
    "name": "PathMetaData",
    "slug": "TsInterface",
    "id": "pathmetadata",
    "description": "All interesting metadata about any path (files and folders)",
    "operationName": "code-types",
    "rawText": "\n\n/**\n * All interesting metadata about any path (files and folders)\n */\nexport type PathMetaData = FileContentInfo & PathParse & PathStats;"
  },
  "PathParse": {
    "name": "PathParse",
    "slug": "TsInterface",
    "id": "pathparse",
    "description": "object to represent a folder or file path in different ways\n\nNB: doesn't include the absolute path so the indexes can be exported easily witout creating incorrect paths",
    "operationName": "code-types",
    "rawText": "\n/**\n * object to represent a folder or file path in different ways\n *\n * NB: doesn't include the absolute path so the indexes can be exported easily witout creating incorrect paths\n */\nexport type PathParse = {\n  /**\n   * relative file or folder path from the project root\n   */\n  relativePathFromProjectRoot: string;\n};"
  },
  "PathStats": {
    "name": "PathStats",
    "slug": "TsInterface",
    "id": "pathstats",
    "description": "Information which can be found by fs.stat",
    "operationName": "markdown-types"
  },
  "PerformanceItem": {
    "name": "PerformanceItem",
    "slug": "TsInterface",
    "id": "performanceitem",
    "description": "",
    "operationName": "measure-performance",
    "rawText": "export type PerformanceItem = {\n  label: string;\n  durationMs: number;\n};"
  },
  "Price": {
    "name": "Price",
    "slug": "TsInterface",
    "id": "price",
    "description": "TLDR;EUROS\n\nA price is a number indicating the relative cost. Absolute cost is calculated by many other factors\n\nFor now, we're going to keep it simple: 1 `Price` is equal to 1 Eurocent.\n\nLater we can add all kinds of extra conversion:\n\n- currency support\n- king os currency\n- lower cost for poorer people\n\netc...\n\nFirst we need to start making sales before we can add such complexity.",
    "operationName": "todo-types"
  },
  "RunEveryPeriodEnum": {
    "name": "RunEveryPeriodEnum",
    "slug": "TsInterface",
    "id": "runeveryperiodenum",
    "description": "Used to specify functions that need to run every time with a specific interval\n\nAll times are at at the server timezone time\n\n- `minute`: every minute at 0 seconds\n- `5-mintues`: every 5 minutes, starting at the first minute of the hour\n- `quarter-hour`: every 15 minutes, starting at the first minute of the hour\n- `hour`: every hour, starting at the first minute of the hour\n- `6-hours`: every 6 hours, starting at midnight\n- `midnight`: every midnight (00:00:00)\n- `week`: every week at sundaynight (sunday, 1 second after 23:59:59 PM)\n- `month`: at the first second of the first day of the month (0:00:00)\n- `3-months`: every start of the quarter: january 1st (0:00:00), april 1st, july 1st, october 1st\n- `year`: every new year at january 1st at 0:00:00",
    "operationName": "code-types",
    "rawText": "\n/**\n Used to specify functions that need to run every time with a specific interval\n\nAll times are at at the server timezone time\n\n- `minute`: every minute at 0 seconds\n- `5-mintues`: every 5 minutes, starting at the first minute of the hour\n- `quarter-hour`: every 15 minutes, starting at the first minute of the hour\n- `hour`: every hour, starting at the first minute of the hour\n- `6-hours`: every 6 hours, starting at midnight\n- `midnight`: every midnight (00:00:00)\n- `week`: every week at sundaynight (sunday, 1 second after 23:59:59 PM)\n- `month`: at the first second of the first day of the month (0:00:00)\n- `3-months`: every start of the quarter: january 1st (0:00:00), april 1st, july 1st, october 1st\n- `year`: every new year at january 1st at 0:00:00\n\n */\nexport type RunEveryPeriodEnum = typeof runEveryPeriodReadonlyArray[number];"
  },
  "Schema": {
    "name": "Schema",
    "slug": "TsInterface",
    "id": "schema",
    "description": "schema type interface we use in TsInterface\n\nNB: don't export because this would make this type exist twice.",
    "operationName": "schema-util",
    "rawText": "\n\n/**\n * schema type interface we use in TsInterface\n *\n * NB: don't export because this would make this type exist twice.\n */\ntype Schema = TsInterface[\"type\"][\"typeDefinition\"];"
  },
  "SimplifiedSchema": {
    "name": "SimplifiedSchema",
    "slug": "TsInterface",
    "id": "simplifiedschema",
    "description": "JSONSchema7 derivative that has the following capabilities and and characteristics...\n\n- does not include objects in objects that are also referenced to using xxxSlug or xxxId\n- recursively finds the references and expands them, unless the references are circular\n- easier to read\n- has all the information we need\n- is able to generate an object with values in the exact format the function needs it\n- is able to easily generate a form",
    "operationName": "simplified-schema-form"
  },
  "SimplifiedSchemaItem": {
    "name": "SimplifiedSchemaItem",
    "slug": "TsInterface",
    "id": "simplifiedschemaitem",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport type SimplifiedSchemaItem = {\n  /**\n   * name in case of it being a reference, otherwise null\n   */\n  name: string | null;\n  schema: SimplifiedSchema;\n};"
  },
  "SimplifiedSchemaProperty": {
    "name": "SimplifiedSchemaProperty",
    "slug": "TsInterface",
    "id": "simplifiedschemaproperty",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "SimplifiedSchemaType": {
    "name": "SimplifiedSchemaType",
    "slug": "TsInterface",
    "id": "simplifiedschematype",
    "description": "",
    "operationName": "name-conventions"
  },
  "SizeSummary": {
    "name": "SizeSummary",
    "slug": "TsInterface",
    "id": "sizesummary",
    "description": "type interface that can be used to summarize multiple files",
    "operationName": "code-types",
    "rawText": "/**\n * type interface that can be used to summarize multiple files\n */\nexport type SizeSummary = {\n  /**\n   * if this is about multiple files, the number of files is specified here\n   */\n  numberOfFiles?: number;\n  /**\n   * amount of characters\n   */\n  characters: number;\n  /**\n   * amount of lines\n   */\n  lines: number;\n  /**\n   * amount of bytes\n   */\n  bytes: number;\n  /**\n   * rounded, amount of lines per file (averaged)\n   */\n  linesPerFile: number;\n  /**\n   * rounded, amount of characters per line (averaged)\n   */\n  charactersPerLine: number;\n  /**\n   * rounded, amount of bytes per character\n   */\n  bytesPerCharacter: number;\n};"
  },
  "TsConfig": {
    "name": "TsConfig",
    "slug": "TsInterface",
    "id": "tsconfig",
    "description": "\nwould be nice if we have a type interface for this, just like package.json for now just type the stuff we need",
    "operationName": "get-path"
  },
  "TsFunctionIndex": {
    "name": "TsFunctionIndex",
    "slug": "TsInterface",
    "id": "tsfunctionindex",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport type TsFunctionIndex = {\n  /**\n   * If you give a function a type explicitly on its declaration, this type will be set here.\n   */\n  explicitTypeName?: string;\n  /**\n   * The function is immediately exported upon creation. If the os dev tools are being used, this means it is also exported from the operation\n   */\n  isExported: boolean;\n\n  /**\n   * parsed comment from doc-comment\n   */\n  description?: Markdown;\n\n  /**\n   * raw text of the function\n   */\n  rawText?: string;\n\n  /**\n   * all comments found in a function and the node that they belong to\n   */\n  commentsInside: TsComment[];\n\n  /**\n   * return type JSON Schema definition\n   */\n  returnType: TypeInfo;\n\n  /**\n   * parameters the function takes as its arguments, if any\n   */\n  parameters?: FunctionParameter[];\n\n  /**\n   * size of this function (comments + code)\n   */\n  size: SizeSummary;\n\n  /**\n   * size of the comments of this function (including surrounding comments)\n   */\n  commentSize?: SizeSummary;\n  /**\n   * size of the code inside the function (without comments)\n   */\n  codeSize?: SizeSummary;\n\n  /**\n   * tells you the size of itself and all its dependencies that are used that are also part of an operation, recursively\n   */\n  cumulativeSize?: SizeSummary;\n  cumulativeCommentSize?: SizeSummary;\n  cumulativeCodeSize?: SizeSummary;\n\n  // Code quality indexes\n\n  /**\n   * maximum amount of times indedented in this function\n   *\n   * good for determining the complexity and finding code that can be simplified/destructured into smaller pieces\n   */\n  maxIndentationDepth: number;\n\n  /**\n   * finds all files that import this function\n   *\n   * NB: this is not indexed because this information has nothing to do with the operation itself, but the exposure to the broader monorepo. This is calculated on the fly.\n   */\n  dependantFiles?: string[];\n};"
  },
  "TsIndexModelType": {
    "name": "TsIndexModelType",
    "slug": "TsInterface",
    "id": "tsindexmodeltype",
    "description": "identifier of any index type interface",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * identifier of any index type interface\n */\nexport interface TsIndexModelType extends AnyModelType {\n  /**\n   * unique id of the model\n   */\n  id: string;\n  /**\n   * name (identifier) of the model\n   */\n  name: string;\n  /**\n   * kebab-case variant of the name\n   */\n  slug: string;\n  /**\n   * relative file path from the operation that this indexed instance is referencing to\n   *\n   * e.g. src/general.ts\n   *\n   * (no preceding slash)\n   */\n  operationRelativeTypescriptFilePath: string;\n}"
  },
  "TsInterfaceProperties": {
    "name": "TsInterfaceProperties",
    "slug": "TsInterface",
    "id": "tsinterfaceproperties",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport type TsInterfaceProperties = {\n  /**\n   * boolean indicating whether or not this interface uses one or more generic variables\n   */\n  hasGeneric: boolean;\n\n  /**\n   * if the interface extends anything, names will be specified here\n   */\n  extensions?: string[];\n\n  /**\n   * If true, this interface is marked as a db model, which means it will be included in the db function autocompletion so it's easy to store and fetch data in this format.\n   *\n   * Is automatically set to true when indexing and when one of the following statements holds true\n   *\n   * - if the doc-comment contains frontmatter with `isDbModel` or `dbStorageMethod` specified\n   * - if the interface last word is \"db\" or \"model\" and if there are minimum 2 words\n   * - if the interface extends some other special interface\n   */\n  isDbModel: boolean;\n\n  /**\n   * If this is true, this is a db-model that is ALWAYS attached to an operation.\n   *\n   * By default this means it will get a folder in the `db` folder in the operation folder, where the interface will be stored linked to the file-id in specified folder.\n   *\n   * However, you can also specify a `storageLocationRelativeFilePath` if you want to store the model on an exact location relative to the operation root.\n   */\n  isOperationIndex: boolean;\n\n  /**\n   * If given, specify a file path here where the data should be stored.\n   * Must be an operation relative path.\n   *\n   * This will map onto the \"operationRelativePath\" for that instance.\n   *\n   * NB: Since this is a single file per project or per operation, it will overwrite your data in case of `jsonSingle` or `markdown` storage.\n   */\n  operationStorageLocationRelativeFilePath?: string;\n\n  /**\n      The DbStorageMethod for this inteface (only for db models, otherwise this will be undefined)\n      \n      If this interface is a db model, you can also specify the default db storage method for it. You can do this by specifying it in the frontmatter of the doccomment of the interface. You can also extend a xxxModelType model which can have a dbStorageMethod attached.\n    \n     When storing something into the database, this value can be overwritten in your query configuration. \n    \n       */\n  dbStorageMethod?: DbStorageMethod;\n};"
  },
  "TypeCoverage": {
    "name": "TypeCoverage",
    "slug": "TsInterface",
    "id": "typecoverage",
    "description": "quantification of coverage of the specified type or subtypes in our database.",
    "operationName": "code-types",
    "rawText": "\n/**\n * quantification of coverage of the specified type or subtypes in our database.\n */\nexport type TypeCoverage = number;"
  },
  "TypeInfo": {
    "name": "TypeInfo",
    "slug": "TsInterface",
    "id": "typeinfo",
    "description": "all info that should always be collected when indexing any type interface",
    "operationName": "code-types",
    "rawText": "\n\n/**\n * all info that should always be collected when indexing any type interface\n */\nexport type TypeInfo = {\n  /** JSON schema definition of a type interface\n   *\n   *\n   * Some info about the Schema:\n   *\n   * - if the type is an object, there should be properties\n   * - if the type is an array, there should be items\n   */\n  typeDefinition: Schema | undefined;\n  simplifiedSchema?: SimplifiedSchema;\n  /** if the type is an object, this is true. false if it's an array */\n  isObject: boolean;\n  /** if the type is an array, this is true */\n  isArray: boolean;\n  /** if it's a primitive type like \"string\", \"number\", \"boolean\", \"null\" | \"undefined\" */\n  isPrimitive: boolean;\n  /** will be true for any primitive conjunction types */\n  isEnum: boolean;\n  /** will be true for string conjunction types */\n  isEnumLiteral: boolean;\n  typeCoverage: TypeCoverage;\n  /** raw type string */\n  rawType: string;\n};"
  },
  "TypescriptFile": {
    "name": "TypescriptFile",
    "slug": "TsInterface",
    "id": "typescriptfile",
    "description": "IDEA: What if we could make a custom db storage method for a typescript file, so you can read and write typescript with the database?\n\nThe first thing I can do, is to generate all typescript stuff using a model like this:\n\nLater, I can read a typescript file with a rust parser to get it into this model again.\n\nThis is actually super useful for metacoding and coding GUI's\n\nAlso a great start for making my own programming language ;)\n\n\nThere are multiple ways of describing a typescript file I guess. This is one of them. Another one could be a definition where you put the required context in the statements and types themselves.",
    "operationName": "code-types",
    "rawText": "\n\n/**\n * IDEA: What if we could make a custom db storage method for a typescript file, so you can read and write typescript with the database?\n *\n * The first thing I can do, is to generate all typescript stuff using a model like this:\n *\n * Later, I can read a typescript file with a rust parser to get it into this model again.\n *\n * This is actually super useful for metacoding and coding GUI's\n *\n * Also a great start for making my own programming language ;)\n *\n *\n * There are multiple ways of describing a typescript file I guess. This is one of them. Another one could be a definition where you put the required context in the statements and types themselves.\n */\nexport interface TypescriptFile\n  extends DefaultModelType,\n    TypescriptScopeContext,\n    TypescriptScopeContent {}"
  },
  "TypescriptIndex": {
    "name": "TypescriptIndex",
    "slug": "TsInterface",
    "id": "typescriptindex",
    "description": "\nTypescript file metadata (all indexes from typescript files, together)",
    "operationName": "code-types",
    "rawText": "\n/**\n * TODO:\n *\n * Any interface/type\n * - should be able to have default values\n * - should be able to have validation functions\n * - should be able to have casting functions\n * - some parameters should be hidden upon creation\n * - some should be hidden on updating\n * - some should even be hidden when listing\n *\n * This is mainly for the admin panel, but it could be integrated on the db level as well.\n * The problem is that this behavior may be app-specific, so this becomes rather opinionated if we do it on the OS level\n * Come up with an exact requirement and implementation plan.\n *\n * There are many more functionalities possible here to speed up development, not only for admin use-case.\n */\n\n/**\n * ---\n * isDbModel: false\n * ---\n *\n * Typescript file metadata (all indexes from typescript files, together)\n *\n */\nexport type TypescriptIndex = {\n  tsImports: TsImport[];\n  tsFunctions: TsFunction[];\n  tsInterfaces: TsInterface[];\n  tsVariables: TsVariable[];\n  tsBuildErrors: TsBuildError[];\n  tsLintWarnings: TsLintWarning[];\n  tsComments: TsComment[];\n  tsExports: TsExport[];\n};"
  },
  "TypescriptScopeContent": {
    "name": "TypescriptScopeContent",
    "slug": "TsInterface",
    "id": "typescriptscopecontent",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport interface TypescriptScopeContent {\n  statements: {\n    name: string;\n    /**\n     * can not be done in functions\n     */\n    isExported: boolean;\n    comment?: string;\n    isFunction?: boolean;\n    variableJsonValue?: any;\n    functionDefinition?: TypescriptScopeContext & {\n      /**\n       * Inside of the function (recursion on itself)\n       */\n      content: TypescriptScopeContent;\n    };\n  }[];\n\n  interfaces: {\n    name: string;\n    isExported: boolean;\n    comment?: string;\n    simplifiedSchema: SimplifiedSchema;\n  }[];\n\n  /**\n   * Only in functions\n   */\n  returnStatementRaw?: string;\n}"
  },
  "TypescriptScopeContext": {
    "name": "TypescriptScopeContext",
    "slug": "TsInterface",
    "id": "typescriptscopecontext",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport interface TypescriptScopeContext {\n  /**\n   * Parameters\n   */\n  statementContext?: TypescriptScopeStatementContext[];\n  /**\n   * Generics\n   */\n  typeContext?: TypescriptScopeTypeContext[];\n}"
  },
  "TypescriptScopeStatementContext": {
    "name": "TypescriptScopeStatementContext",
    "slug": "TsInterface",
    "id": "typescriptscopestatementcontext",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport interface TypescriptScopeStatementContext {\n  name: string;\n  /**\n   * Only for functions\n   */\n  isRequired?: boolean;\n  simplifiedSchema: SimplifiedSchema;\n  comment: string;\n  isRest?: boolean;\n}"
  },
  "TypescriptScopeTypeContext": {
    "name": "TypescriptScopeTypeContext",
    "slug": "TsInterface",
    "id": "typescriptscopetypecontext",
    "description": "",
    "operationName": "code-types",
    "rawText": "\n\nexport interface TypescriptScopeTypeContext {\n  name: string;\n  comment?: string;\n  simplifiedSchema: SimplifiedSchema;\n}"
  },
  "NamedParameters<typeof stripComment>": {
    "name": "NamedParameters<typeof stripComment>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stripcomment",
    "description": "",
    "operationName": "comment-util"
  },
  "NamedParameters<typeof stripCommentEnd>": {
    "name": "NamedParameters<typeof stripCommentEnd>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stripcommentend",
    "description": "",
    "operationName": "comment-util"
  },
  "NamedParameters<typeof stripCommentStart>": {
    "name": "NamedParameters<typeof stripCommentStart>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stripcommentstart",
    "description": "",
    "operationName": "comment-util"
  },
  "NamedParameters<typeof stripSlashes>": {
    "name": "NamedParameters<typeof stripSlashes>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stripslashes",
    "description": "",
    "operationName": "comment-util"
  },
  "NamedParameters<typeof stripStar>": {
    "name": "NamedParameters<typeof stripStar>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stripstar",
    "description": "",
    "operationName": "comment-util"
  },
  "NamedParameters<typeof trim>": {
    "name": "NamedParameters<typeof trim>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-trim",
    "description": "",
    "operationName": "comment-util"
  },
  "NamedParameters<typeof trimSurroundingNewlines>": {
    "name": "NamedParameters<typeof trimSurroundingNewlines>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-trimsurroundingnewlines",
    "description": "",
    "operationName": "comment-util"
  },
  "NamedParameters<typeof getCompileErrors>": {
    "name": "NamedParameters<typeof getCompileErrors>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcompileerrors",
    "description": "",
    "operationName": "compile-typescript"
  },
  "NamedParameters<typeof getTypescriptErrorsFromFiles>": {
    "name": "NamedParameters<typeof getTypescriptErrorsFromFiles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettypescripterrorsfromfiles",
    "description": "",
    "operationName": "compile-typescript"
  },
  "NamedParameters<typeof writeBuildErrors>": {
    "name": "NamedParameters<typeof writeBuildErrors>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-writebuilderrors",
    "description": "",
    "operationName": "compile-typescript"
  },
  "PackageJson": {
    "name": "PackageJson",
    "slug": "TsInterface",
    "id": "packagejson",
    "description": "",
    "operationName": "compile-typescript"
  },
  "Casing": {
    "name": "Casing",
    "slug": "TsInterface",
    "id": "casing",
    "description": "",
    "operationName": "convert-case",
    "rawText": "\nexport type Casing =\n  //camelCase\n  | \"camel\"\n  //PascalCase\n  | \"pascal\"\n  //snake_case\n  | \"snake\"\n  //kebab-case\n  | \"kebab\"\n  //CAPITAL_CASE\n  | \"capital\"\n  //Human case\n  | \"human\";"
  },
  "NamedParameters<typeof camelCase>": {
    "name": "NamedParameters<typeof camelCase>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-camelcase",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof capitalCase>": {
    "name": "NamedParameters<typeof capitalCase>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-capitalcase",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof capitaliseFirstLetter>": {
    "name": "NamedParameters<typeof capitaliseFirstLetter>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-capitalisefirstletter",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof convertCase>": {
    "name": "NamedParameters<typeof convertCase>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-convertcase",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof convertToTargetCasing>": {
    "name": "NamedParameters<typeof convertToTargetCasing>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-converttotargetcasing",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof fileSlugify>": {
    "name": "NamedParameters<typeof fileSlugify>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fileslugify",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof getDelimiter>": {
    "name": "NamedParameters<typeof getDelimiter>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdelimiter",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof humanCase>": {
    "name": "NamedParameters<typeof humanCase>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-humancase",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof kebabCase>": {
    "name": "NamedParameters<typeof kebabCase>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-kebabcase",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof lowerCaseArray>": {
    "name": "NamedParameters<typeof lowerCaseArray>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-lowercasearray",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof pascalCase>": {
    "name": "NamedParameters<typeof pascalCase>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-pascalcase",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof slugify>": {
    "name": "NamedParameters<typeof slugify>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-slugify",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof snakeCase>": {
    "name": "NamedParameters<typeof snakeCase>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-snakecase",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof splitCasingDelimiters>": {
    "name": "NamedParameters<typeof splitCasingDelimiters>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-splitcasingdelimiters",
    "description": "",
    "operationName": "convert-case"
  },
  "NamedParameters<typeof errorToast>": {
    "name": "NamedParameters<typeof errorToast>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-errortoast",
    "description": "",
    "operationName": "cool-toast"
  },
  "NamedParameters<typeof infoToast>": {
    "name": "NamedParameters<typeof infoToast>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-infotoast",
    "description": "",
    "operationName": "cool-toast"
  },
  "NamedParameters<typeof showStandardResponse>": {
    "name": "NamedParameters<typeof showStandardResponse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-showstandardresponse",
    "description": "",
    "operationName": "cool-toast"
  },
  "NamedParameters<typeof successToast>": {
    "name": "NamedParameters<typeof successToast>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-successtoast",
    "description": "",
    "operationName": "cool-toast"
  },
  "NamedParameters<typeof warningToast>": {
    "name": "NamedParameters<typeof warningToast>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-warningtoast",
    "description": "",
    "operationName": "cool-toast"
  },
  "StandardizedApiReturnType": {
    "name": "StandardizedApiReturnType",
    "slug": "TsInterface",
    "id": "standardizedapireturntype",
    "description": "Handy type interface for rendering response",
    "operationName": "cool-toast"
  },
  "CsvItemType": {
    "name": "CsvItemType",
    "slug": "TsInterface",
    "id": "csvitemtype",
    "description": "",
    "operationName": "csv-util",
    "rawText": "\nexport type CsvItemType = {\n  [key: string]: string | number | boolean | null | undefined;\n};"
  },
  "NamedParameters<typeof tryParseCsv>": {
    "name": "NamedParameters<typeof tryParseCsv>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tryparsecsv",
    "description": "",
    "operationName": "csv-util"
  },
  "CsvModelType": {
    "name": "CsvModelType",
    "slug": "TsInterface",
    "id": "csvmodeltype",
    "description": "Use this model for things you want to store in CSV format\n\nTODO: add support for numbers, booleans, null, undefined",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * Use this model for things you want to store in CSV format\n *\n * TODO: add support for numbers, booleans, null, undefined\n */\nexport interface CsvModelType extends AnyModelType, TimeTypes {\n  [key: string]: string | number | boolean | null | undefined;\n}"
  },
  "CsvTestModel": {
    "name": "CsvTestModel",
    "slug": "TsInterface",
    "id": "csvtestmodel",
    "description": "",
    "operationName": "database",
    "rawText": "\n\nexport interface CsvTestModel extends CsvModelType {\n  name: string;\n  description: string;\n  age: number;\n}"
  },
  "DefaultTestModel": {
    "name": "DefaultTestModel",
    "slug": "TsInterface",
    "id": "defaulttestmodel",
    "description": "",
    "operationName": "database",
    "rawText": "\n\nexport interface DefaultTestModel extends DefaultModelType {\n  id: string;\n  name: string;\n  description: string;\n  markdown: string;\n  special: boolean;\n}"
  },
  "KeyValueMarkdownModelType": {
    "name": "KeyValueMarkdownModelType",
    "slug": "TsInterface",
    "id": "keyvaluemarkdownmodeltype",
    "description": "handy model type for storing stuff in a KeyValue Markdown file. empty lines are omitted\n\nall you need to specify in the kvmd is the key and the value, separated by \":\"\n\nNB: there can be a `parent_modelNameSlug` key exposed that should refer to the parent slug",
    "operationName": "todo-types"
  },
  "KvmdTestModel": {
    "name": "KvmdTestModel",
    "slug": "TsInterface",
    "id": "kvmdtestmodel",
    "description": "",
    "operationName": "database",
    "rawText": "\n\nexport interface KvmdTestModel extends KeyValueMarkdownModelType {}"
  },
  "MarkdownModelType": {
    "name": "MarkdownModelType",
    "slug": "TsInterface",
    "id": "markdownmodeltype",
    "description": "Handy model type for storing stuff in a Markdown file.\n\n1 markdown file will represent 1 MarkdownModelType extended instance\n\nanother option could be to parse the markdown file, but to KISS we are going to just return markdown with the full markdown content\n\nTODO: see how this relates to MarkdownFile. Make this very clear!",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * Handy model type for storing stuff in a Markdown file.\n *\n * 1 markdown file will represent 1 MarkdownModelType extended instance\n *\n * another option could be to parse the markdown file, but to KISS we are going to just return markdown with the full markdown content\n *\n * TODO: see how this relates to MarkdownFile. Make this very clear!\n */\nexport interface MarkdownModelType\n  extends AnyModelType,\n    Frontmatter,\n    TimeTypes,\n    RelationType {\n  id: Id;\n  /**\n   * filename (slugified)\n   */\n  name: string;\n  /**\n   * filename (slugified)\n   */\n  slug: string;\n\n  /**\n   * the content of the markdown\n   */\n  markdown: string;\n\n  categoryStack: CategoryStack;\n\n  /**\n   * This kind of overwrites frontmatter, but it is needed because there need to be models attached to the markdown model sometimes.\n   */\n  [modelName: string]: any;\n}"
  },
  "MarkdownTestModel": {
    "name": "MarkdownTestModel",
    "slug": "TsInterface",
    "id": "markdowntestmodel",
    "description": "",
    "operationName": "database",
    "rawText": "\n\nexport interface MarkdownTestModel extends MarkdownModelType {\n  stringA: string;\n  stringB: string;\n  stringC: string;\n  age: number;\n  yes: boolean;\n  canBeNull: string | null;\n  canBeUndefined?: string;\n}"
  },
  "NamedParameters<typeof generateCsvInstance>": {
    "name": "NamedParameters<typeof generateCsvInstance>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatecsvinstance",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof generateJsonSingleInstance>": {
    "name": "NamedParameters<typeof generateJsonSingleInstance>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatejsonsingleinstance",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof generateKvmdInstance>": {
    "name": "NamedParameters<typeof generateKvmdInstance>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatekvmdinstance",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof generateMarkdownInstance>": {
    "name": "NamedParameters<typeof generateMarkdownInstance>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatemarkdowninstance",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof generateSlugTestModel>": {
    "name": "NamedParameters<typeof generateSlugTestModel>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateslugtestmodel",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof get>": {
    "name": "NamedParameters<typeof get>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-get",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof getCli>": {
    "name": "NamedParameters<typeof getCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcli",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof getRanomAge>": {
    "name": "NamedParameters<typeof getRanomAge>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getranomage",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof main>": {
    "name": "NamedParameters<typeof main>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-main",
    "description": "",
    "operationName": "watch-operations"
  },
  "NamedParameters<typeof migration>": {
    "name": "NamedParameters<typeof migration>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-migration",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof randomName>": {
    "name": "NamedParameters<typeof randomName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-randomname",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof removeCli>": {
    "name": "NamedParameters<typeof removeCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removecli",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof set>": {
    "name": "NamedParameters<typeof set>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-set",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof testOperationModels>": {
    "name": "NamedParameters<typeof testOperationModels>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-testoperationmodels",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof testPerformance>": {
    "name": "NamedParameters<typeof testPerformance>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-testperformance",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof updateCli>": {
    "name": "NamedParameters<typeof updateCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-updatecli",
    "description": "",
    "operationName": "database"
  },
  "NamedParameters<typeof upsert>": {
    "name": "NamedParameters<typeof upsert>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-upsert",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof upsertCli>": {
    "name": "NamedParameters<typeof upsertCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-upsertcli",
    "description": "",
    "operationName": "database"
  },
  "SlugTestModel": {
    "name": "SlugTestModel",
    "slug": "TsInterface",
    "id": "slugtestmodel",
    "description": "",
    "operationName": "database",
    "rawText": "\n\nexport interface SlugTestModel extends SlugModelType {\n  id: string;\n  name: string;\n  slug: string;\n  description: string;\n  markdown: string;\n  special: boolean;\n}"
  },
  "TestModels": {
    "name": "TestModels",
    "slug": "TsInterface",
    "id": "testmodels",
    "description": "",
    "operationName": "database",
    "rawText": "\n\nexport type TestModels = {\n  CsvTestModel: CsvTestModel;\n  KeyValueMarkdownTestModel: KvmdTestModel;\n  MarkdownTestModel: MarkdownTestModel;\n  JsonMultipleTestModel: SlugTestModel;\n  DefaultTestModel: DefaultTestModel;\n  // real models\n  TsConfig: TsConfig;\n};"
  },
  "DbCrudStore": {
    "name": "DbCrudStore",
    "slug": "TsInterface",
    "id": "dbcrudstore",
    "description": "",
    "operationName": "db-crud",
    "rawText": "\n\nexport type DbCrudStore = {\n  \"db-crud.datasetConfig\":\n    | (DatasetConfig & {\n        /**\n         * If you selected a dataset, this will be set, so you can also delete it after selecting it\n         */\n        id?: string;\n        /**\n         * Used to determine if it's a new form or not\n         */\n        key?: string;\n      })\n    | null;\n  \"db-crud.search\": string;\n};"
  },
  "NamedParameters<typeof DatasetForm>": {
    "name": "NamedParameters<typeof DatasetForm>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-datasetform",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof getPropertiesDataParameterNames>": {
    "name": "NamedParameters<typeof getPropertiesDataParameterNames>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpropertiesdataparameternames",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof ModelComponent>": {
    "name": "NamedParameters<typeof ModelComponent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-modelcomponent",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof openWhatsapp>": {
    "name": "NamedParameters<typeof openWhatsapp>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-openwhatsapp",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof SearchBar>": {
    "name": "NamedParameters<typeof SearchBar>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-searchbar",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof shimmer>": {
    "name": "NamedParameters<typeof shimmer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-shimmer",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof SimplifiedSchemaFormDebug>": {
    "name": "NamedParameters<typeof SimplifiedSchemaFormDebug>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-simplifiedschemaformdebug",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof sortToItem>": {
    "name": "NamedParameters<typeof sortToItem>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-sorttoitem",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof toBase64>": {
    "name": "NamedParameters<typeof toBase64>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tobase64",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof UpsertForm>": {
    "name": "NamedParameters<typeof UpsertForm>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-upsertform",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof UpsertPage>": {
    "name": "NamedParameters<typeof UpsertPage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-upsertpage",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof useInfiniteGetDbModel>": {
    "name": "NamedParameters<typeof useInfiniteGetDbModel>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-useinfinitegetdbmodel",
    "description": "",
    "operationName": "db-crud"
  },
  "NamedParameters<typeof useModelFromUrl>": {
    "name": "NamedParameters<typeof useModelFromUrl>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usemodelfromurl",
    "description": "",
    "operationName": "db-crud"
  },
  "SchemaProperty": {
    "name": "SchemaProperty",
    "slug": "TsInterface",
    "id": "schemaproperty",
    "description": "",
    "operationName": "schema-util",
    "rawText": "\n\nexport type SchemaProperty = {\n  name: string;\n  schema: JSONSchema7;\n  required: boolean;\n};"
  },
  "CacheLookupResult": {
    "name": "CacheLookupResult",
    "slug": "TsInterface",
    "id": "cachelookupresult",
    "description": "",
    "operationName": "db-recipes",
    "rawText": "export type CacheLookupResult = {\n  hasValidCache: boolean;\n  result?: any;\n};"
  },
  "NamedParameters<typeof cacheLookup>": {
    "name": "NamedParameters<typeof cacheLookup>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-cachelookup",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof calculateOperatingSystemBundle>": {
    "name": "NamedParameters<typeof calculateOperatingSystemBundle>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-calculateoperatingsystembundle",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof getCachedFunctions>": {
    "name": "NamedParameters<typeof getCachedFunctions>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcachedfunctions",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof getDatabaseMenu>": {
    "name": "NamedParameters<typeof getDatabaseMenu>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdatabasemenu",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof getDbModelMetadata>": {
    "name": "NamedParameters<typeof getDbModelMetadata>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdbmodelmetadata",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof getDbModelNames>": {
    "name": "NamedParameters<typeof getDbModelNames>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdbmodelnames",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof getFunctionIndex>": {
    "name": "NamedParameters<typeof getFunctionIndex>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfunctionindex",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof getNestedDatabaseMenu>": {
    "name": "NamedParameters<typeof getNestedDatabaseMenu>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getnesteddatabasemenu",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof hasDbRecipes>": {
    "name": "NamedParameters<typeof hasDbRecipes>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-hasdbrecipes",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof makeSrcRelativeFolder>": {
    "name": "NamedParameters<typeof makeSrcRelativeFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-makesrcrelativefolder",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof tsInterfaceToDbMenu>": {
    "name": "NamedParameters<typeof tsInterfaceToDbMenu>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tsinterfacetodbmenu",
    "description": "",
    "operationName": "db-recipes"
  },
  "NamedParameters<typeof filterInterfacesFromOperationNames>": {
    "name": "NamedParameters<typeof filterInterfacesFromOperationNames>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-filterinterfacesfromoperationnames",
    "description": "",
    "operationName": "db-util"
  },
  "NamedParameters<typeof getDbModelsFromOperations>": {
    "name": "NamedParameters<typeof getDbModelsFromOperations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdbmodelsfromoperations",
    "description": "",
    "operationName": "db-util"
  },
  "NamedParameters<typeof docsGetPages>": {
    "name": "NamedParameters<typeof docsGetPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-docsgetpages",
    "description": "",
    "operationName": "docs-get-pages"
  },
  "NamedParameters<typeof getPublicMarkdownFilePaths>": {
    "name": "NamedParameters<typeof getPublicMarkdownFilePaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpublicmarkdownfilepaths",
    "description": "",
    "operationName": "docs-get-pages"
  },
  "NamedParameters<typeof removeExtensionsFromPath>": {
    "name": "NamedParameters<typeof removeExtensionsFromPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removeextensionsfrompath",
    "description": "",
    "operationName": "docs-get-pages"
  },
  "NamedParameters<typeof removeNumberPrefix>": {
    "name": "NamedParameters<typeof removeNumberPrefix>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removenumberprefix",
    "description": "",
    "operationName": "docs-get-pages"
  },
  "NamedParameters<typeof shouldExposeMarkdownFile>": {
    "name": "NamedParameters<typeof shouldExposeMarkdownFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-shouldexposemarkdownfile",
    "description": "",
    "operationName": "docs-get-pages"
  },
  "NamedParameters<typeof stripReadmeFromFolder>": {
    "name": "NamedParameters<typeof stripReadmeFromFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stripreadmefromfolder",
    "description": "",
    "operationName": "docs-get-pages"
  },
  "NamedParameters<typeof comparePassword>": {
    "name": "NamedParameters<typeof comparePassword>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-comparepassword",
    "description": "",
    "operationName": "encrypt-password"
  },
  "NamedParameters<typeof encryptPassword>": {
    "name": "NamedParameters<typeof encryptPassword>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-encryptpassword",
    "description": "",
    "operationName": "encrypt-password"
  },
  "NamedParameters<typeof exploreOperation>": {
    "name": "NamedParameters<typeof exploreOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-exploreoperation",
    "description": "",
    "operationName": "explore-project"
  },
  "NamedParameters<typeof exploreProject>": {
    "name": "NamedParameters<typeof exploreProject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-exploreproject",
    "description": "",
    "operationName": "explore-project"
  },
  "NamedParameters<typeof getExplorationType>": {
    "name": "NamedParameters<typeof getExplorationType>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getexplorationtype",
    "description": "",
    "operationName": "explore-project"
  },
  "NamedParameters<typeof getFileWithExtension>": {
    "name": "NamedParameters<typeof getFileWithExtension>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfilewithextension",
    "description": "",
    "operationName": "explore-project"
  },
  "NamedParameters<typeof getFolderExplorationDetails>": {
    "name": "NamedParameters<typeof getFolderExplorationDetails>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfolderexplorationdetails",
    "description": "",
    "operationName": "explore-project"
  },
  "NamedParameters<typeof getFrontmattersMappedObject>": {
    "name": "NamedParameters<typeof getFrontmattersMappedObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfrontmattersmappedobject",
    "description": "",
    "operationName": "explore-project"
  },
  "NamedParameters<typeof getInstanceNames>": {
    "name": "NamedParameters<typeof getInstanceNames>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getinstancenames",
    "description": "",
    "operationName": "explore-project"
  },
  "NamedParameters<typeof getProjectRelativePaths>": {
    "name": "NamedParameters<typeof getProjectRelativePaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getprojectrelativepaths",
    "description": "",
    "operationName": "explore-project"
  },
  "NamedParameters<typeof getTodoPages>": {
    "name": "NamedParameters<typeof getTodoPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettodopages",
    "description": "",
    "operationName": "explore-project"
  },
  "NamedParameters<typeof getTodoPaths>": {
    "name": "NamedParameters<typeof getTodoPaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettodopaths",
    "description": "",
    "operationName": "explore-project"
  },
  "NamedParameters<typeof hasSameProjectPath>": {
    "name": "NamedParameters<typeof hasSameProjectPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-hassameprojectpath",
    "description": "",
    "operationName": "explore-project"
  },
  "RelativePathType": {
    "name": "RelativePathType",
    "slug": "TsInterface",
    "id": "relativepathtype",
    "description": "",
    "operationName": "explore-project",
    "rawText": "\n\nexport type RelativePathType = \"todo\";"
  },
  "TodoPagesConfig": {
    "name": "TodoPagesConfig",
    "slug": "TsInterface",
    "id": "todopagesconfig",
    "description": "",
    "operationName": "todo-types",
    "rawText": "\n\nexport type TodoPagesConfig = {\n  recency?: typeof todoPagesConfigRecencysConst[number];\n  /**\n   * All TodoOffer's related to this todo will be searched, as well as all TodoFile's with this personId as it's codeOwner.\n   */\n  personId?: string;\n  categoryStack?: string[];\n  priority?: \"high\";\n  subExtension?: string;\n  sort?: \"recent\";\n};"
  },
  "NamedParameters<typeof FancyLoader>": {
    "name": "NamedParameters<typeof FancyLoader>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fancyloader",
    "description": "",
    "operationName": "fancy-loader"
  },
  "NamedParameters<typeof compressConvert>": {
    "name": "NamedParameters<typeof compressConvert>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-compressconvert",
    "description": "",
    "operationName": "ffmpeg-util"
  },
  "NamedParameters<typeof compressImages>": {
    "name": "NamedParameters<typeof compressImages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-compressimages",
    "description": "",
    "operationName": "ffmpeg-util"
  },
  "NamedParameters<typeof compressImagesCli>": {
    "name": "NamedParameters<typeof compressImagesCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-compressimagescli",
    "description": "",
    "operationName": "ffmpeg-util"
  },
  "NamedParameters<typeof compressMp4>": {
    "name": "NamedParameters<typeof compressMp4>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-compressmp4",
    "description": "",
    "operationName": "ffmpeg-util"
  },
  "NamedParameters<typeof compressMp4sCli>": {
    "name": "NamedParameters<typeof compressMp4sCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-compressmp4scli",
    "description": "",
    "operationName": "ffmpeg-util"
  },
  "NamedParameters<typeof convertToMp3>": {
    "name": "NamedParameters<typeof convertToMp3>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-converttomp3",
    "description": "",
    "operationName": "ffmpeg-util"
  },
  "NamedParameters<typeof convertToMp4>": {
    "name": "NamedParameters<typeof convertToMp4>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-converttomp4",
    "description": "",
    "operationName": "ffmpeg-util"
  },
  "NamedParameters<typeof fileExplorerOpen>": {
    "name": "NamedParameters<typeof fileExplorerOpen>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fileexploreropen",
    "description": "",
    "operationName": "file-explorer-open"
  },
  "NamedParameters<typeof getFileType>": {
    "name": "NamedParameters<typeof getFileType>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfiletype",
    "description": "",
    "operationName": "file-icons"
  },
  "TypeIconEnum": {
    "name": "TypeIconEnum",
    "slug": "TsInterface",
    "id": "typeiconenum",
    "description": "",
    "operationName": "file-icons",
    "rawText": "\n\nexport type TypeIconEnum = keyof typeof typeIcons;"
  },
  "NamedParameters<typeof MatchingText>": {
    "name": "NamedParameters<typeof MatchingText>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-matchingtext",
    "description": "",
    "operationName": "file-search"
  },
  "NamedParameters<typeof PathSearchResults>": {
    "name": "NamedParameters<typeof PathSearchResults>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-pathsearchresults",
    "description": "",
    "operationName": "file-search"
  },
  "FileTabsStoreType": {
    "name": "FileTabsStoreType",
    "slug": "TsInterface",
    "id": "filetabsstoretype",
    "description": "",
    "operationName": "file-tabs",
    "rawText": "\n\nexport type FileTabsStoreType = {\n  unsavedFiles: {\n    [projectRelativePath: string]: string | undefined;\n  };\n  openPages: OpenPage<string>[];\n};"
  },
  "NamedParameters<typeof OpenFileWriterPages>": {
    "name": "NamedParameters<typeof OpenFileWriterPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-openfilewriterpages",
    "description": "",
    "operationName": "file-writer"
  },
  "PagesObjectShape": {
    "name": "PagesObjectShape",
    "slug": "TsInterface",
    "id": "pagesobjectshape",
    "description": "",
    "operationName": "file-writer"
  },
  "DropboxExtension": {
    "name": "DropboxExtension",
    "slug": "TsInterface",
    "id": "dropboxextension",
    "description": "these filetypes should never be opened with explore. They should be processed and either indexed or converted. This creates a md or json with the proper metadata, which, in turn, can be explored.",
    "operationName": "filename-conventions",
    "rawText": "\n\n/**\n * these filetypes should never be opened with explore. They should be processed and either indexed or converted. This creates a md or json with the proper metadata, which, in turn, can be explored.\n */\nexport type DropboxExtension =\n  | \"doc\"\n  | \"docx\"\n  | \"csv\"\n  | \"xls\"\n  | \"xlsx\"\n  | \"epub\"\n  | \"pdf\";"
  },
  "JsonExtension": {
    "name": "JsonExtension",
    "slug": "TsInterface",
    "id": "jsonextension",
    "description": "",
    "operationName": "filename-conventions",
    "rawText": "\nexport type JsonExtension = typeof jsonExtensions[number];"
  },
  "MarkdownExtension": {
    "name": "MarkdownExtension",
    "slug": "TsInterface",
    "id": "markdownextension",
    "description": "",
    "operationName": "filename-conventions",
    "rawText": "\nexport type MarkdownExtension = typeof markdownExtensions[number];"
  },
  "NamedParameters<typeof getFileTypeFromPath>": {
    "name": "NamedParameters<typeof getFileTypeFromPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfiletypefrompath",
    "description": "",
    "operationName": "filename-conventions"
  },
  "NamedParameters<typeof getWriterType>": {
    "name": "NamedParameters<typeof getWriterType>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getwritertype",
    "description": "",
    "operationName": "filename-conventions"
  },
  "NamedParameters<typeof hasSubExtension>": {
    "name": "NamedParameters<typeof hasSubExtension>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-hassubextension",
    "description": "",
    "operationName": "filename-conventions"
  },
  "NamedParameters<typeof isGeneratedOperation>": {
    "name": "NamedParameters<typeof isGeneratedOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isgeneratedoperation",
    "description": "",
    "operationName": "filename-conventions"
  },
  "NamedParameters<typeof isGeneratedOperationName>": {
    "name": "NamedParameters<typeof isGeneratedOperationName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isgeneratedoperationname",
    "description": "",
    "operationName": "filename-conventions"
  },
  "NamedParameters<typeof isIndexableFileId>": {
    "name": "NamedParameters<typeof isIndexableFileId>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isindexablefileid",
    "description": "",
    "operationName": "filename-conventions"
  },
  "SearchableExtension": {
    "name": "SearchableExtension",
    "slug": "TsInterface",
    "id": "searchableextension",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "SearchLevel": {
    "name": "SearchLevel",
    "slug": "TsInterface",
    "id": "searchlevel",
    "description": "",
    "operationName": "filename-conventions",
    "rawText": "\n\nexport type SearchLevel =\n  | \"folder\"\n  | \"fileName\"\n  | \"filePath\"\n  | \"outline\"\n  | \"full\";"
  },
  "TypescriptExtension": {
    "name": "TypescriptExtension",
    "slug": "TsInterface",
    "id": "typescriptextension",
    "description": "",
    "operationName": "filename-conventions",
    "rawText": "\n\nexport type TypescriptExtension = typeof typescriptExtensions[number];"
  },
  "WriterType": {
    "name": "WriterType",
    "slug": "TsInterface",
    "id": "writertype",
    "description": "Type of content that can be interpreted by the `writer-input`",
    "operationName": "filename-conventions",
    "rawText": "\n\n/**\n * Type of content that can be interpreted by the `writer-input`\n */\nexport type WriterType = \"typescript\" | \"markdown\" | \"other\";"
  },
  "DependencyTree": {
    "name": "DependencyTree",
    "slug": "TsInterface",
    "id": "dependencytree",
    "description": "",
    "operationName": "find-all-dependency-operations",
    "rawText": "\n\nexport type DependencyTree = {\n  [dependencyName: string]: DependencyTree | null;\n};"
  },
  "DependencyTreeChildObject": {
    "name": "DependencyTreeChildObject",
    "slug": "TsInterface",
    "id": "dependencytreechildobject",
    "description": "Gives a clear overview of why an operation requires every dependency",
    "operationName": "find-all-dependency-operations",
    "rawText": "\n\n/**\n * Gives a clear overview of why an operation requires every dependency\n */\nexport type DependencyTreeChildObject = ChildObject<{\n  operationName: string;\n  dependencyCount: number;\n  usedExports: string[];\n  usedExportsCount: number;\n  cumulativeExportsCount: number;\n  cumulativeUsedExportsCount: number;\n  //allExports: string[];\n  allExportsCount: number;\n}>;"
  },
  "NamedParameters<typeof findDependantsRecursivelyTest>": {
    "name": "NamedParameters<typeof findDependantsRecursivelyTest>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-finddependantsrecursivelytest",
    "description": "",
    "operationName": "find-all-dependency-operations"
  },
  "NamedParameters<typeof findMonorepoExports>": {
    "name": "NamedParameters<typeof findMonorepoExports>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findmonorepoexports",
    "description": "",
    "operationName": "find-all-dependency-operations"
  },
  "NamedParameters<typeof findMonorepoImports>": {
    "name": "NamedParameters<typeof findMonorepoImports>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findmonorepoimports",
    "description": "",
    "operationName": "find-all-dependency-operations"
  },
  "NamedParameters<typeof getDependencyTree>": {
    "name": "NamedParameters<typeof getDependencyTree>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdependencytree",
    "description": "",
    "operationName": "find-all-dependency-operations"
  },
  "NamedParameters<typeof getOldDependencyTree>": {
    "name": "NamedParameters<typeof getOldDependencyTree>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getolddependencytree",
    "description": "",
    "operationName": "find-all-dependency-operations"
  },
  "NamedParameters<typeof getOperationDependencyReasons>": {
    "name": "NamedParameters<typeof getOperationDependencyReasons>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationdependencyreasons",
    "description": "",
    "operationName": "find-all-dependency-operations"
  },
  "NamedParameters<typeof test2>": {
    "name": "NamedParameters<typeof test2>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-test2",
    "description": "",
    "operationName": "read-kvmd-file"
  },
  "NamedParameters<typeof folderGetUpdatedAt>": {
    "name": "NamedParameters<typeof folderGetUpdatedAt>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-foldergetupdatedat",
    "description": "",
    "operationName": "folder-get-updated-at"
  },
  "FrontmatterParse": {
    "name": "FrontmatterParse",
    "slug": "TsInterface",
    "id": "frontmatterparse",
    "description": "",
    "operationName": "matter-types",
    "rawText": "export type FrontmatterParse = {\n  [frontmatterKey: string]: any;\n};"
  },
  "FrontmatterValue": {
    "name": "FrontmatterValue",
    "slug": "TsInterface",
    "id": "frontmattervalue",
    "description": "",
    "operationName": "frontmatter-util",
    "rawText": "export type FrontmatterValue =\n  | string\n  | number\n  | boolean\n  | string[]\n  | null\n  | undefined;"
  },
  "NamedParameters<typeof frontmatterParseToString>": {
    "name": "NamedParameters<typeof frontmatterParseToString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-frontmatterparsetostring",
    "description": "",
    "operationName": "frontmatter-util"
  },
  "NamedParameters<typeof frontmatterToObject>": {
    "name": "NamedParameters<typeof frontmatterToObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-frontmattertoobject",
    "description": "",
    "operationName": "frontmatter-util"
  },
  "NamedParameters<typeof getFrontmatterValueString>": {
    "name": "NamedParameters<typeof getFrontmatterValueString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfrontmattervaluestring",
    "description": "",
    "operationName": "frontmatter-util"
  },
  "NamedParameters<typeof markdownModelTypeToMarkdownString>": {
    "name": "NamedParameters<typeof markdownModelTypeToMarkdownString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownmodeltypetomarkdownstring",
    "description": "",
    "operationName": "frontmatter-util"
  },
  "NamedParameters<typeof objectToFrontmatter>": {
    "name": "NamedParameters<typeof objectToFrontmatter>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-objecttofrontmatter",
    "description": "",
    "operationName": "frontmatter-util"
  },
  "NamedParameters<typeof parseFrontmatterString>": {
    "name": "NamedParameters<typeof parseFrontmatterString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parsefrontmatterstring",
    "description": "",
    "operationName": "frontmatter-util"
  },
  "NamedParameters<typeof quotedOrNot>": {
    "name": "NamedParameters<typeof quotedOrNot>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-quotedornot",
    "description": "",
    "operationName": "frontmatter-util"
  },
  "NamedParameters<typeof stringifyNewlines>": {
    "name": "NamedParameters<typeof stringifyNewlines>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stringifynewlines",
    "description": "",
    "operationName": "frontmatter-util"
  },
  "AnyModelObject": {
    "name": "AnyModelObject",
    "slug": "TsInterface",
    "id": "anymodelobject",
    "description": "",
    "operationName": "fs-orm",
    "rawText": "\n\nexport type AnyModelObject = {\n  [modelName: string]: AugmentedAnyModelType;\n};"
  },
  "CategoryStack": {
    "name": "CategoryStack",
    "slug": "TsInterface",
    "id": "categorystack",
    "description": "Taken from the location in the folder of the db-model.\n\nNB: Changing this value when updating/upserting, changes where the item is located!",
    "operationName": "todo-types"
  },
  "CustomQueryConfig": {
    "name": "CustomQueryConfig",
    "slug": "TsInterface",
    "id": "customqueryconfig",
    "description": "NB: the dbStorageMethod cannot be specified here because this is a static configuration per db-model and cannot be specified on a per-query basis.\n\nAlso you can't specify projectRelativePath and operationRelativePath. It should not be needed, you should specify the db storage locations in the createDb config.",
    "operationName": "fs-orm",
    "rawText": "\n\n/**\n * NB: the dbStorageMethod cannot be specified here because this is a static configuration per db-model and cannot be specified on a per-query basis.\n *\n * Also you can't specify projectRelativePath and operationRelativePath. It should not be needed, you should specify the db storage locations in the createDb config.\n */\nexport type CustomQueryConfig = {\n  /**\n   * if specified, this will be used as the root path to find your data in\n   *\n   * if not specified, uses the db folder in your project root and in any operation\n   *\n   * NB: If you set this, the model interfaces of your current project are applied on another project! Make sure they are the same there before you run such queries.\n   */\n  manualProjectRoot?: string;\n\n  /*\n   - if not specified or specified as `undefined` or `null`, only the root db folder will be searched\n   - if an operation is specified, only that operation will be searched\n   - if `*` is specified, all operations will be searched as well as the root db. This is discouraged, as it's quite slow\n   */\n  operationName?: string | null;\n};"
  },
  "DbFileLocation": {
    "name": "DbFileLocation",
    "slug": "TsInterface",
    "id": "dbfilelocation",
    "description": "Object used to hand over all information about the location of a db-file in a structured way",
    "operationName": "read-kvmd-file"
  },
  "DbQueryResult": {
    "name": "DbQueryResult",
    "slug": "TsInterface",
    "id": "dbqueryresult",
    "description": "TODO: return the inserted id or other reference\n\nResult of any query except `get`. Will not always provide all parameters (depends on the type of query you do)",
    "operationName": "fs-orm",
    "rawText": "\n\n/**\n * TODO: return the inserted id or other reference\n *\n * Result of any query except `get`. Will not always provide all parameters (depends on the type of query you do)\n */\nexport type DbQueryResult = {\n  isSuccesful?: boolean;\n  message?: string;\n  isNewFile?: boolean;\n  amountInserted?: number;\n  amountUpdated?: number;\n  amountRemoved?: number;\n  /**\n   * If true, all items in the model were removed\n   */\n  allRemoved?: boolean;\n};"
  },
  "IncludeConfig": {
    "name": "IncludeConfig",
    "slug": "TsInterface",
    "id": "includeconfig",
    "description": "All possible ways to include items from references into a get query",
    "operationName": "fs-orm",
    "rawText": "\n\n/**\n * All possible ways to include items from references into a get query\n */\nexport type IncludeConfig =\n  | (Include & {\n      /**\n       * NOT SUPPORTED YET\n       *\n       * If this is set to true, regular include will be ignored. More depth is not possible.\n       *\n       * You can simply specify `auto: true`. This is the easiest way to include. This will fetch all references in the model for every item in an as efficient way as possible, but only with a depth of 1.\n       *\n       * Assumptions:\n       *\n       * 1) The first item in the db contains all reference-keys that need to be filled. Keys not present in the first item will not be filled\n       *\n       */\n      auto?: boolean;\n    })\n  | Include[];"
  },
  "IncludeDataObject": {
    "name": "IncludeDataObject",
    "slug": "TsInterface",
    "id": "includedataobject",
    "description": "",
    "operationName": "fs-orm",
    "rawText": "\n\nexport type IncludeDataObject = {\n  [modelName: string]: AugmentedAnyModelType[];\n};"
  },
  "Include": {
    "name": "Include",
    "slug": "TsInterface",
    "id": "include",
    "description": "",
    "operationName": "fs-orm",
    "rawText": "\n\nexport type Include = {\n  /**\n   * The key that contains a reference. The name of this key should follow the convention, e.g. `xxxSlug`. If this is given, `xxx` will be filled with the item of the referenced model.\n   */\n  referenceKey?: string;\n  /**\n   * If provided, the items will be filled from this array. If not provided, the required model will first be fetched using get. It is often more efficient to provide it yourself if you have already fetched it anyway. Nonetheless, `fs-orm` will try and reuse the fetched data to minimize amount of reads to the file system.\n   */\n  items?: AugmentedAnyModelType[];\n  /**\n   * Optionally, you can provide another include config for this model\n   */\n  include?: Include | Include[];\n};"
  },
  "MergedQueryConfig": {
    "name": "MergedQueryConfig",
    "slug": "TsInterface",
    "id": "mergedqueryconfig",
    "description": "",
    "operationName": "fs-orm",
    "rawText": "\n\nexport type MergedQueryConfig = QueryConfig & {\n  dbStorageMethod: DbStorageMethod;\n  /**\n   * manual projectroot, should only be set if it's different from the projectRoot.\n   */\n  manualProjectRoot: string;\n  /**\n   * Hardcoded projectroot. Motivation for this is to be able to see if the projectroot is really manual.\n   */\n  projectRoot: string;\n};"
  },
  "ModelLocation": {
    "name": "ModelLocation",
    "slug": "TsInterface",
    "id": "modellocation",
    "description": "Parameters that tell you about the location an instance of a model.\nModels can be tied to an operation. They always have a `projectRelativePath`, and if they are tied to an operation, also an `operationRelativePath`.",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * Parameters that tell you about the location an instance of a model.\n * Models can be tied to an operation. They always have a `projectRelativePath`, and if they are tied to an operation, also an `operationRelativePath`.\n */\nexport interface ModelLocation {\n  /**\n   * name of operation the model belongs to\n   *\n   * - calculated value (not stored in database)\n   * - can be `null` or an actual operationName that it was saved at\n   * - can be `undefined` when you are creating an item, because then it can be set for you\n   */\n  operationName: null | string;\n  /**\n   * path to dbfile\n   *\n   * - calculated value (not stored in database)\n   * - relatively from the project (without slash at start)\n   * - can be `undefined` when you are creating an item, because then it can be set for you\n   */\n  projectRelativePath: string;\n  /**\n   * path to db file\n   *\n   * - relatively from the operation root folder (without slash at start)\n   * - calculated value (not stored in database)\n   * - can be `undefined` if the db file does not belong to an operation\n   * - can be `undefined` when you are creating an item, because then it can be set for you\n   */\n  operationRelativePath?: string;\n}"
  },
  "NamedParameters<typeof augmentItemWithReferencedDataRecursively>": {
    "name": "NamedParameters<typeof augmentItemWithReferencedDataRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-augmentitemwithreferenceddatarecursively",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof findParent>": {
    "name": "NamedParameters<typeof findParent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findparent",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getAugmentedData>": {
    "name": "NamedParameters<typeof getAugmentedData>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getaugmenteddata",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getDatabaseFiles>": {
    "name": "NamedParameters<typeof getDatabaseFiles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdatabasefiles",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getDatabaseRootFolder>": {
    "name": "NamedParameters<typeof getDatabaseRootFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdatabaserootfolder",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getDbFileLocation>": {
    "name": "NamedParameters<typeof getDbFileLocation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdbfilelocation",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getDbStorageMethodExtension>": {
    "name": "NamedParameters<typeof getDbStorageMethodExtension>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdbstoragemethodextension",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getLocationPattern>": {
    "name": "NamedParameters<typeof getLocationPattern>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getlocationpattern",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getParentSlug>": {
    "name": "NamedParameters<typeof getParentSlug>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getparentslug",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getWildcardDbFileLocations__OLD>": {
    "name": "NamedParameters<typeof getWildcardDbFileLocations__OLD>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getwildcarddbfilelocations-old",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getWildcardDbFileLocations>": {
    "name": "NamedParameters<typeof getWildcardDbFileLocations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getwildcarddbfilelocations",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof removeKeyValueMarkdown>": {
    "name": "NamedParameters<typeof removeKeyValueMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removekeyvaluemarkdown",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof upsertKeyValueMarkdown>": {
    "name": "NamedParameters<typeof upsertKeyValueMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-upsertkeyvaluemarkdown",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof addDefaultValues>": {
    "name": "NamedParameters<typeof addDefaultValues>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-adddefaultvalues",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof calculateOperationsObject>": {
    "name": "NamedParameters<typeof calculateOperationsObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-calculateoperationsobject",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof createDb>": {
    "name": "NamedParameters<typeof createDb>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-createdb",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getDefaultLocationPattern>": {
    "name": "NamedParameters<typeof getDefaultLocationPattern>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdefaultlocationpattern",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getMergedConfigOperationPath>": {
    "name": "NamedParameters<typeof getMergedConfigOperationPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmergedconfigoperationpath",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof getRootFolders>": {
    "name": "NamedParameters<typeof getRootFolders>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getrootfolders",
    "description": "",
    "operationName": "fs-orm"
  },
  "NamedParameters<typeof waitForLockfile>": {
    "name": "NamedParameters<typeof waitForLockfile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-waitforlockfile",
    "description": "",
    "operationName": "fs-orm"
  },
  "QueryConfig": {
    "name": "QueryConfig",
    "slug": "TsInterface",
    "id": "queryconfig",
    "description": "QueryConfig is set on 4 levels, which have increasing priority\n\n- hardcoded in `fs-orm`\n- when calling `createDb`, setting `defaultQueryConfig`\n- when calling `createDb`, setting `modelQueryConfig`\n- when running a query\n\nNot all options are available when running a query.",
    "operationName": "fs-orm",
    "rawText": "\n/**\n * QueryConfig is set on 4 levels, which have increasing priority\n *\n * - hardcoded in `fs-orm`\n * - when calling `createDb`, setting `defaultQueryConfig`\n * - when calling `createDb`, setting `modelQueryConfig`\n * - when running a query\n *\n * Not all options are available when running a query.\n */\nexport interface QueryConfig extends CustomQueryConfig {\n  /**\n   * When setting this, make sure your models are able to use this storage method, this is not always possible!\n   *\n   * defaults to jsonMultiple\n   */\n  dbStorageMethod?: DbStorageMethod;\n\n  /**\n   * if specified, only this location will be used (also need an `operationName`)\n   */\n  operationRelativePath?: string;\n  /**\n   * if specified, only this location will be used\n   */\n  projectRelativePath?: string;\n}"
  },
  "RootDbFolder": {
    "name": "RootDbFolder",
    "slug": "TsInterface",
    "id": "rootdbfolder",
    "description": "",
    "operationName": "fs-orm",
    "rawText": "\n\nexport type RootDbFolder = {\n  /** is an operation Base path in case of operationName is not null */\n  basePath: string;\n  operationName: string | null;\n};"
  },
  "UpsertKeyValueMarkdownItem": {
    "name": "UpsertKeyValueMarkdownItem",
    "slug": "TsInterface",
    "id": "upsertkeyvaluemarkdownitem",
    "description": "",
    "operationName": "fs-orm",
    "rawText": "\n\nexport type UpsertKeyValueMarkdownItem = {\n  parameters: Frontmatter | null;\n  item: KeyValueMarkdownModelType;\n};"
  },
  "UpsertQueryConfig": {
    "name": "UpsertQueryConfig",
    "slug": "TsInterface",
    "id": "upsertqueryconfig",
    "description": "",
    "operationName": "fs-orm",
    "rawText": "\n\nexport type UpsertQueryConfig = CustomQueryConfig & {\n  /**\n   * Special config for upsert. If you set this to true, all items in the databasefiles that were altered that you didn't specify in the items, will be removed.\n   */\n  removeUntouched?: boolean;\n  /**\n   * If true, the query will fail if the slug or id already exists (normally this means upsert will update that value)\n   *\n   * NB: not supported for keyValueMarkdown\n   */\n  onlyInsert?: boolean;\n};"
  },
  "Dir": {
    "name": "Dir",
    "slug": "TsInterface",
    "id": "dir",
    "description": "A class representing a directory stream.\n\nCreated by  {@link  opendir } ,  {@link  opendirSync } , or `fsPromises.opendir()`.\n\n```js import { opendir } from 'fs/promises';\n\ntry {   const dir = await opendir('./');   for await (const dirent of dir)     console.log(dirent.name); } catch (err) {   console.error(err); } ```\n\nWhen using the async iterator, the `fs.Dir` object will be automatically closed after the iterator exits.",
    "operationName": "fs-util"
  },
  "Dirent": {
    "name": "Dirent",
    "slug": "TsInterface",
    "id": "dirent",
    "description": "A representation of a directory entry, which can be a file or a subdirectory within the directory, as returned by reading from an `fs.Dir`. The directory entry is a combination of the file name and file type pairs.\n\nAdditionally, when  {@link  readdir }  or  {@link  readdirSync }  is called with the `withFileTypes` option set to `true`, the resulting array is filled with `fs.Dirent` objects, rather than strings or `Buffer` s.",
    "operationName": "fs-util"
  },
  "FolderPath": {
    "name": "FolderPath",
    "slug": "TsInterface",
    "id": "folderpath",
    "description": "DEPRECATED: just use ParsedPath",
    "operationName": "fs-util",
    "rawText": "\n/**\n * DEPRECATED: just use ParsedPath\n */\nexport type FolderPath = { relativeFolder: string | undefined; path: Path };"
  },
  "Fs": {
    "name": "Fs",
    "slug": "TsInterface",
    "id": "fs",
    "description": "all handy Fs types",
    "operationName": "fs-util",
    "rawText": "\n\n/**\n * all handy Fs types\n */\nexport type Fs = {\n  PathLike: PathLike;\n  Stats: Stats;\n  Dir: Dir;\n  Dirent: Dirent;\n};"
  },
  "NamedParameters<typeof findFileNameCaseInsensitive>": {
    "name": "NamedParameters<typeof findFileNameCaseInsensitive>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findfilenamecaseinsensitive",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof getFileName>": {
    "name": "NamedParameters<typeof getFileName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfilename",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof getFolder>": {
    "name": "NamedParameters<typeof getFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfolder",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof getLastFolder>": {
    "name": "NamedParameters<typeof getLastFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getlastfolder",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof getPathCombinations>": {
    "name": "NamedParameters<typeof getPathCombinations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpathcombinations",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof parseMd>": {
    "name": "NamedParameters<typeof parseMd>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parsemd",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof removeAllExcept>": {
    "name": "NamedParameters<typeof removeAllExcept>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removeallexcept",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof copyAllRelativeFiles>": {
    "name": "NamedParameters<typeof copyAllRelativeFiles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-copyallrelativefiles",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof getAllFoldersUntilFolder>": {
    "name": "NamedParameters<typeof getAllFoldersUntilFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getallfoldersuntilfolder",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof getFirstAvailableFilename>": {
    "name": "NamedParameters<typeof getFirstAvailableFilename>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfirstavailablefilename",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof getFolderSize>": {
    "name": "NamedParameters<typeof getFolderSize>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfoldersize",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof getFolderSizeObject>": {
    "name": "NamedParameters<typeof getFolderSizeObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfoldersizeobject",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof getOneFolderUpPath>": {
    "name": "NamedParameters<typeof getOneFolderUpPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getonefolderuppath",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof oneUp>": {
    "name": "NamedParameters<typeof oneUp>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-oneup",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof renameAndCreate>": {
    "name": "NamedParameters<typeof renameAndCreate>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-renameandcreate",
    "description": "",
    "operationName": "fs-util"
  },
  "NamedParameters<typeof updateSingleNestedJsonFile>": {
    "name": "NamedParameters<typeof updateSingleNestedJsonFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-updatesinglenestedjsonfile",
    "description": "",
    "operationName": "fs-util"
  },
  "PathLike": {
    "name": "PathLike",
    "slug": "TsInterface",
    "id": "pathlike",
    "description": "Valid types for path values in \"fs\".",
    "operationName": "fs-util"
  },
  "Path": {
    "name": "Path",
    "slug": "TsInterface",
    "id": "path",
    "description": "unlike PathLike, this is only a string\n\nFor now, we don't have a clear convention whether or not this string should be absolute or anything.",
    "operationName": "read-typescript-file"
  },
  "Stats": {
    "name": "Stats",
    "slug": "TsInterface",
    "id": "stats",
    "description": "A `fs.Stats` object provides information about a file.\n\nObjects returned from  {@link  stat } ,  {@link  lstat }  and  {@link  fstat }  and their synchronous counterparts are of this type. If `bigint` in the `options` passed to those methods is true, the numeric values will be `bigint` instead of `number`, and the object will contain additional nanosecond-precision properties suffixed with `Ns`.\n\n```console Stats {   dev: 2114,   ino: 48064969,   mode: 33188,   nlink: 1,   uid: 85,   gid: 100,   rdev: 0,   size: 527,   blksize: 4096,   blocks: 8,   atimeMs: 1318289051000.1,   mtimeMs: 1318289051000.1,   ctimeMs: 1318289051000.1,   birthtimeMs: 1318289051000.1,   atime: Mon, 10 Oct 2011 23:24:11 GMT,   mtime: Mon, 10 Oct 2011 23:24:11 GMT,   ctime: Mon, 10 Oct 2011 23:24:11 GMT,   birthtime: Mon, 10 Oct 2011 23:24:11 GMT } ```\n\n`bigint` version:\n\n```console BigIntStats {   dev: 2114n,   ino: 48064969n,   mode: 33188n,   nlink: 1n,   uid: 85n,   gid: 100n,   rdev: 0n,   size: 527n,   blksize: 4096n,   blocks: 8n,   atimeMs: 1318289051000n,   mtimeMs: 1318289051000n,   ctimeMs: 1318289051000n,   birthtimeMs: 1318289051000n,   atimeNs: 1318289051000000000n,   mtimeNs: 1318289051000000000n,   ctimeNs: 1318289051000000000n,   birthtimeNs: 1318289051000000000n,   atime: Mon, 10 Oct 2011 23:24:11 GMT,   mtime: Mon, 10 Oct 2011 23:24:11 GMT,   ctime: Mon, 10 Oct 2011 23:24:11 GMT,   birthtime: Mon, 10 Oct 2011 23:24:11 GMT } ```",
    "operationName": "fs-util"
  },
  "UnixTimestamp": {
    "name": "UnixTimestamp",
    "slug": "TsInterface",
    "id": "unixtimestamp",
    "description": "",
    "operationName": "fs-util",
    "rawText": "export type UnixTimestamp = number;"
  },
  "NamedParameters<typeof join>": {
    "name": "NamedParameters<typeof join>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-join",
    "description": "",
    "operationName": "fs-util-js"
  },
  "NamedParameters<typeof makeRelative>": {
    "name": "NamedParameters<typeof makeRelative>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-makerelative",
    "description": "",
    "operationName": "fs-util-js"
  },
  "Group": {
    "name": "Group",
    "slug": "TsInterface",
    "id": "group",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof getFunctionExecutions>": {
    "name": "NamedParameters<typeof getFunctionExecutions>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfunctionexecutions",
    "description": "",
    "operationName": "function-functions-node"
  },
  "NamedParameters<typeof getFunctionQueryPaths>": {
    "name": "NamedParameters<typeof getFunctionQueryPaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfunctionquerypaths",
    "description": "",
    "operationName": "function-functions-node"
  },
  "NamedParameters<typeof getPublicBundleConfig>": {
    "name": "NamedParameters<typeof getPublicBundleConfig>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpublicbundleconfig",
    "description": "",
    "operationName": "function-functions-node"
  },
  "NamedParameters<typeof getSrcRelativeFolderPath>": {
    "name": "NamedParameters<typeof getSrcRelativeFolderPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsrcrelativefolderpath",
    "description": "",
    "operationName": "function-functions-node"
  },
  "NamedParameters<typeof getTsFunction>": {
    "name": "NamedParameters<typeof getTsFunction>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettsfunction",
    "description": "",
    "operationName": "function-server-endpoints"
  },
  "AuthorizationInfo": {
    "name": "AuthorizationInfo",
    "slug": "TsInterface",
    "id": "authorizationinfo",
    "description": "",
    "operationName": "function-server-endpoints",
    "rawText": "\n\nexport type AuthorizationInfo = {\n  /**\n   * Whether or not the device is authorized to execute this function\n   */\n  hasAuthorization: boolean;\n  /**\n   * All authorizations for this device that may apply to this function.\n   *\n   * It comprises:\n   *\n   * - the `publicAuthorization` for this function\n   * - the custom authorizations for all `Person`s for the `Device`\n   * - the authorizations of all groups found for all `Person`s for the `Device`\n   */\n  authorizations: Authorization[];\n  /**\n   * Unique `Group`s for all `Person`s for this `Device`\n   */\n  groups: Group[];\n};"
  },
  "IPInfo": {
    "name": "IPInfo",
    "slug": "TsInterface",
    "id": "ipinfo",
    "description": "Information that is inferred from an IP",
    "operationName": "peer-types",
    "rawText": "\n\n/**\n * Information that is inferred from an IP\n */\nexport type IPInfo = {\n  /**\n   * The ip of the device. Can be a local IP or remote IP.\n   *\n   * NB: Port is not included\n   */\n  ip: string;\n  city?: string | undefined;\n  position?: Position | undefined;\n  positionRadiusKm?: number | undefined;\n  country?: string | undefined;\n  region?: string | undefined;\n  timezone?: string | undefined;\n};"
  },
  "IResult": {
    "name": "IResult",
    "slug": "TsInterface",
    "id": "iresult",
    "description": "",
    "operationName": "peer-types",
    "rawText": "\n\nexport interface IResult {\n  ua: string;\n  browser: IBrowser;\n  device: IDevice;\n  engine: IEngine;\n  os: IOS;\n  cpu: ICPU;\n}"
  },
  "NamedParameters<typeof calculateDeviceName>": {
    "name": "NamedParameters<typeof calculateDeviceName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-calculatedevicename",
    "description": "",
    "operationName": "function-server-endpoints"
  },
  "NamedParameters<typeof getAuthorizationInfo>": {
    "name": "NamedParameters<typeof getAuthorizationInfo>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getauthorizationinfo",
    "description": "",
    "operationName": "function-server-endpoints"
  },
  "NamedParameters<typeof isGetEndpoint>": {
    "name": "NamedParameters<typeof isGetEndpoint>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isgetendpoint",
    "description": "",
    "operationName": "function-server-endpoints"
  },
  "NamedParameters<typeof savePageVisit>": {
    "name": "NamedParameters<typeof savePageVisit>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-savepagevisit",
    "description": "",
    "operationName": "function-server-endpoints"
  },
  "NamedParameters<typeof storeFunctionExecution>": {
    "name": "NamedParameters<typeof storeFunctionExecution>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-storefunctionexecution",
    "description": "",
    "operationName": "function-server-endpoints"
  },
  "FunctionData": {
    "name": "FunctionData",
    "slug": "TsInterface",
    "id": "functiondata",
    "description": "",
    "operationName": "function-types",
    "rawText": "\nexport type FunctionData = {\n  tsFunction: TsFunction;\n};"
  },
  "FnMatch": {
    "name": "FnMatch",
    "slug": "TsInterface",
    "id": "fnmatch",
    "description": "",
    "operationName": "function-util",
    "rawText": "\n\nexport type FnMatch = {\n  matcher: string;\n  relativeOperationPath: string;\n} & TsFunction;"
  },
  "NamedParameters<typeof chat>": {
    "name": "NamedParameters<typeof chat>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-chat",
    "description": "",
    "operationName": "function-util"
  },
  "NamedParameters<typeof converse>": {
    "name": "NamedParameters<typeof converse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-converse",
    "description": "",
    "operationName": "function-util"
  },
  "NamedParameters<typeof doCli>": {
    "name": "NamedParameters<typeof doCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-docli",
    "description": "",
    "operationName": "function-util"
  },
  "NamedParameters<typeof executeSdkFunction>": {
    "name": "NamedParameters<typeof executeSdkFunction>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-executesdkfunction",
    "description": "",
    "operationName": "function-util"
  },
  "NamedParameters<typeof getCachedExportedFunctions>": {
    "name": "NamedParameters<typeof getCachedExportedFunctions>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcachedexportedfunctions",
    "description": "",
    "operationName": "function-util"
  },
  "NamedParameters<typeof getMenu>": {
    "name": "NamedParameters<typeof getMenu>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmenu",
    "description": "",
    "operationName": "function-util"
  },
  "NamedParameters<typeof getParameters>": {
    "name": "NamedParameters<typeof getParameters>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getparameters",
    "description": "",
    "operationName": "function-util"
  },
  "NamedParameters<typeof getParametersAndExecute>": {
    "name": "NamedParameters<typeof getParametersAndExecute>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getparametersandexecute",
    "description": "",
    "operationName": "function-util"
  },
  "NamedParameters<typeof getSdkFunctionPaths>": {
    "name": "NamedParameters<typeof getSdkFunctionPaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsdkfunctionpaths",
    "description": "",
    "operationName": "function-util"
  },
  "NamedParameters<typeof listen>": {
    "name": "NamedParameters<typeof listen>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-listen",
    "description": "",
    "operationName": "function-util"
  },
  "ImportStatement": {
    "name": "ImportStatement",
    "slug": "TsInterface",
    "id": "importstatement",
    "description": "",
    "operationName": "generate-index",
    "rawText": "\n\nexport type ImportStatement = {\n  type: \"variable\" | \"function\" | \"interface\";\n  name: string;\n  srcRelativeFileId: string;\n};"
  },
  "NamedParameters<typeof generateNamedIndex>": {
    "name": "NamedParameters<typeof generateNamedIndex>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatenamedindex",
    "description": "",
    "operationName": "generate-index"
  },
  "NamedParameters<typeof generateSimpleIndex>": {
    "name": "NamedParameters<typeof generateSimpleIndex>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatesimpleindex",
    "description": "",
    "operationName": "generate-index"
  },
  "NamedParameters<typeof isTestFn>": {
    "name": "NamedParameters<typeof isTestFn>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-istestfn",
    "description": "",
    "operationName": "generate-index"
  },
  "NamedParameters<typeof mapToImportStatement>": {
    "name": "NamedParameters<typeof mapToImportStatement>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-maptoimportstatement",
    "description": "",
    "operationName": "generate-index"
  },
  "FunctionsPerClassification": {
    "name": "FunctionsPerClassification",
    "slug": "TsInterface",
    "id": "functionsperclassification",
    "description": "relative",
    "operationName": "generate-sdk-operations",
    "rawText": "\n// relative\n\nexport type FunctionsPerClassification = {\n  [operationClassification in OperationClassification]: TsFunction[];\n};"
  },
  "NamedParameters<typeof generateDbSdk>": {
    "name": "NamedParameters<typeof generateDbSdk>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatedbsdk",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateDbSdkCli>": {
    "name": "NamedParameters<typeof generateDbSdkCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatedbsdkcli",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateEnvSdks>": {
    "name": "NamedParameters<typeof generateEnvSdks>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateenvsdks",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateEnvSdksCli>": {
    "name": "NamedParameters<typeof generateEnvSdksCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateenvsdkscli",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateFunctionPathsSdk>": {
    "name": "NamedParameters<typeof generateFunctionPathsSdk>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatefunctionpathssdk",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateFunctionSdks>": {
    "name": "NamedParameters<typeof generateFunctionSdks>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatefunctionsdks",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateFunctionSdksCli>": {
    "name": "NamedParameters<typeof generateFunctionSdksCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatefunctionsdkscli",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateInterfacePathsSdk>": {
    "name": "NamedParameters<typeof generateInterfacePathsSdk>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateinterfacepathssdk",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateInterfacePathsSdkCli>": {
    "name": "NamedParameters<typeof generateInterfacePathsSdkCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateinterfacepathssdkcli",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateOperationsSdk>": {
    "name": "NamedParameters<typeof generateOperationsSdk>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateoperationssdk",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateOperationsSdkCli>": {
    "name": "NamedParameters<typeof generateOperationsSdkCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateoperationssdkcli",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateSdkApi>": {
    "name": "NamedParameters<typeof generateSdkApi>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatesdkapi",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateSdkApiCli>": {
    "name": "NamedParameters<typeof generateSdkApiCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatesdkapicli",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateSdkApiWatcher>": {
    "name": "NamedParameters<typeof generateSdkApiWatcher>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatesdkapiwatcher",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateSdkOperations>": {
    "name": "NamedParameters<typeof generateSdkOperations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatesdkoperations",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof generateSdkOperationsCli>": {
    "name": "NamedParameters<typeof generateSdkOperationsCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatesdkoperationscli",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof getFunctionSdksContent>": {
    "name": "NamedParameters<typeof getFunctionSdksContent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfunctionsdkscontent",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof getSdkDescription>": {
    "name": "NamedParameters<typeof getSdkDescription>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsdkdescription",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof getSdkFunctionsPerClassification>": {
    "name": "NamedParameters<typeof getSdkFunctionsPerClassification>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsdkfunctionsperclassification",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof isNonUiOperationBuild>": {
    "name": "NamedParameters<typeof isNonUiOperationBuild>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isnonuioperationbuild",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof newEnvSdk>": {
    "name": "NamedParameters<typeof newEnvSdk>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-newenvsdk",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof newFunctionKeysSdkOperation>": {
    "name": "NamedParameters<typeof newFunctionKeysSdkOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-newfunctionkeyssdkoperation",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof newFunctionSdkOperation>": {
    "name": "NamedParameters<typeof newFunctionSdkOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-newfunctionsdkoperation",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof tsFunctionIsIndexable>": {
    "name": "NamedParameters<typeof tsFunctionIsIndexable>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tsfunctionisindexable",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof tsFunctionIsSdkable>": {
    "name": "NamedParameters<typeof tsFunctionIsSdkable>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tsfunctionissdkable",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "NamedParameters<typeof updateClassifications>": {
    "name": "NamedParameters<typeof updateClassifications>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-updateclassifications",
    "description": "",
    "operationName": "generate-sdk-operations"
  },
  "OperationClassificationObject": {
    "name": "OperationClassificationObject",
    "slug": "TsInterface",
    "id": "operationclassificationobject",
    "description": "",
    "operationName": "get-path",
    "rawText": "\n\nexport type OperationClassificationObject = {\n  [operationName: string]: OperationClassification;\n};"
  },
  "WatchEventType": {
    "name": "WatchEventType",
    "slug": "TsInterface",
    "id": "watcheventtype",
    "description": "Different event types for the watcher of the file system (chokidar)\n\n- add: a file got created\n- addDir: a folder got created\n- change: a file changed\n- unlink: a file got removed\n- unlinkDir: a folder got removed",
    "operationName": "watch-types",
    "rawText": "/**\n * Different event types for the watcher of the file system (chokidar)\n *\n * - add: a file got created\n * - addDir: a folder got created\n * - change: a file changed\n * - unlink: a file got removed\n * - unlinkDir: a folder got removed\n *\n */\nexport type WatchEventType =\n  | \"add\"\n  | \"addDir\"\n  | \"change\"\n  | \"unlink\"\n  | \"unlinkDir\";"
  },
  "NamedParameters<typeof canSeeFile>": {
    "name": "NamedParameters<typeof canSeeFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-canseefile",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof canSeeFileContent>": {
    "name": "NamedParameters<typeof canSeeFileContent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-canseefilecontent",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof expandFrontmatter>": {
    "name": "NamedParameters<typeof expandFrontmatter>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-expandfrontmatter",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof findClosestAbsolutePath>": {
    "name": "NamedParameters<typeof findClosestAbsolutePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findclosestabsolutepath",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof getContextualPromptResults>": {
    "name": "NamedParameters<typeof getContextualPromptResults>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcontextualpromptresults",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof getContextualPrompts>": {
    "name": "NamedParameters<typeof getContextualPrompts>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcontextualprompts",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof getContextualPromptsArray>": {
    "name": "NamedParameters<typeof getContextualPromptsArray>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcontextualpromptsarray",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof getFirstFile>": {
    "name": "NamedParameters<typeof getFirstFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfirstfile",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof getFolderRelativeScopeDbFilePath>": {
    "name": "NamedParameters<typeof getFolderRelativeScopeDbFilePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfolderrelativescopedbfilepath",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof getReaderPageProps>": {
    "name": "NamedParameters<typeof getReaderPageProps>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getreaderpageprops",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof readerPageGetStaticPaths>": {
    "name": "NamedParameters<typeof readerPageGetStaticPaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readerpagegetstaticpaths",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof readerPageGetStaticProps>": {
    "name": "NamedParameters<typeof readerPageGetStaticProps>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readerpagegetstaticprops",
    "description": "",
    "operationName": "generative-functions-node"
  },
  "NamedParameters<typeof Dataset>": {
    "name": "NamedParameters<typeof Dataset>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-dataset",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof FileActions>": {
    "name": "NamedParameters<typeof FileActions>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fileactions",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof Menu>": {
    "name": "NamedParameters<typeof Menu>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-menu",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof PromptButton>": {
    "name": "NamedParameters<typeof PromptButton>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-promptbutton",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof ReaderPage>": {
    "name": "NamedParameters<typeof ReaderPage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readerpage",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof ReaderPageNext>": {
    "name": "NamedParameters<typeof ReaderPageNext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readerpagenext",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof setConfig>": {
    "name": "NamedParameters<typeof setConfig>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-setconfig",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof SettingsPage>": {
    "name": "NamedParameters<typeof SettingsPage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-settingspage",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof useAdmin>": {
    "name": "NamedParameters<typeof useAdmin>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-useadmin",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof useFileActions>": {
    "name": "NamedParameters<typeof useFileActions>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usefileactions",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof useQueryPath>": {
    "name": "NamedParameters<typeof useQueryPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usequerypath",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof useVariantResult>": {
    "name": "NamedParameters<typeof useVariantResult>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usevariantresult",
    "description": "",
    "operationName": "generative-ui"
  },
  "NamedParameters<typeof VariantSelector>": {
    "name": "NamedParameters<typeof VariantSelector>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-variantselector",
    "description": "",
    "operationName": "generative-ui"
  },
  "Address": {
    "name": "Address",
    "slug": "TsInterface",
    "id": "address",
    "description": "The old location interface I made up had multiple references, but I don't think this is needed. We can simply use the category interface\n\n\nexport interface Location extends SlugModelType {\ncontinent_locationSlug: Slug;\ncountry_locationSlug?: Slug;\nregionProvinceState_locationSlug?: Slug;\ncity_locationSlug?: Slug;\n}",
    "operationName": "geo-types",
    "rawText": "\n\n/**\n\nThe old location interface I made up had multiple references, but I don't think this is needed. We can simply use the category interface\n\n\nexport interface Location extends SlugModelType {\n  continent_locationSlug: Slug;\n  country_locationSlug?: Slug;\n  regionProvinceState_locationSlug?: Slug;\n  city_locationSlug?: Slug;\n}\n\n*/\n\nexport interface Address extends SlugModelType {\n  locationSlug: Slug;\n  location?: Location;\n  postalCode: string;\n  street: string;\n  houseNumber: string;\n  area?: Area;\n  description?: Markdown;\n}"
  },
  "Area": {
    "name": "Area",
    "slug": "TsInterface",
    "id": "area",
    "description": "in the UI this should be a special input type, where you can draw a polygon or circles on the map and the center will be calculated",
    "operationName": "geo-types",
    "rawText": "\n\n/**\n * in the UI this should be a special input type, where you can draw a polygon or circles on the map and the center will be calculated\n */\nexport interface Area extends SlugModelType {\n  polygon?: Position[];\n  circles?: Circle[];\n  center?: {\n    latitude: number;\n    longitude: number;\n  };\n}"
  },
  "Circle": {
    "name": "Circle",
    "slug": "TsInterface",
    "id": "circle",
    "description": "",
    "operationName": "geo-types",
    "rawText": "\n\nexport interface Circle {\n  diameterMeters: number;\n  position: Position;\n}"
  },
  "City": {
    "name": "City",
    "slug": "TsInterface",
    "id": "city",
    "description": "",
    "operationName": "geo-types",
    "rawText": "\n\nexport interface City extends SlugModelType {\n  name: string;\n  latitude: number;\n  longitude: number;\n  population: number;\n  countrySlug: Slug;\n  country?: Country;\n}"
  },
  "Country": {
    "name": "Country",
    "slug": "TsInterface",
    "id": "country",
    "description": "",
    "operationName": "geo-types",
    "rawText": "\n\nexport interface Country extends SlugModelType {\n  name: string;\n  continent: string;\n  subContinent: string;\n  latitude: number;\n  longitude: number;\n  polygons: Polygon[];\n}"
  },
  "DistantObject": {
    "name": "DistantObject",
    "slug": "TsInterface",
    "id": "distantobject",
    "description": "",
    "operationName": "geo-types",
    "rawText": "export type DistantObject = {\n  type: \"moon\" | \"planet\" | \"star\" | \"blackHole\" | \"asteroid\" | \"galaxy\";\n  position: SpacePosition;\n};"
  },
  "Location": {
    "name": "Location",
    "slug": "TsInterface",
    "id": "location",
    "description": "locations are hierarchically categorized pieces of information.\n\na city can refer to the area, the area can refer the the country, the country to the continent, etc.\n\nthere are multiple ways to categorize it, but this depends on the application.",
    "operationName": "social-media-types"
  },
  "Polygon": {
    "name": "Polygon",
    "slug": "TsInterface",
    "id": "polygon",
    "description": "",
    "operationName": "geo-types",
    "rawText": "\n\nexport type Polygon = Position[];"
  },
  "Position": {
    "name": "Position",
    "slug": "TsInterface",
    "id": "position",
    "description": "",
    "operationName": "peer-types"
  },
  "SpacePosition": {
    "name": "SpacePosition",
    "slug": "TsInterface",
    "id": "spaceposition",
    "description": "IDK HOW TO DO DIS :(",
    "operationName": "geo-types",
    "rawText": "\n\n/**\n * IDK HOW TO DO DIS :(\n */\nexport type SpacePosition = unknown;"
  },
  "NamedParameters<typeof getAllOperationSourcePaths>": {
    "name": "NamedParameters<typeof getAllOperationSourcePaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getalloperationsourcepaths",
    "description": "",
    "operationName": "get-all-operation-source-paths"
  },
  "NamedParameters<typeof getImportedDependencies>": {
    "name": "NamedParameters<typeof getImportedDependencies>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getimporteddependencies",
    "description": "",
    "operationName": "get-imported-dependencies"
  },
  "NamedParameters<typeof getPackage>": {
    "name": "NamedParameters<typeof getPackage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpackage",
    "description": "",
    "operationName": "get-imported-dependencies"
  },
  "NamedParameters<typeof isAbsoluteImport>": {
    "name": "NamedParameters<typeof isAbsoluteImport>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isabsoluteimport",
    "description": "",
    "operationName": "get-imported-dependencies"
  },
  "NamedParameters<typeof calculatePackageJsonDependencies>": {
    "name": "NamedParameters<typeof calculatePackageJsonDependencies>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-calculatepackagejsondependencies",
    "description": "",
    "operationName": "get-imports-exports"
  },
  "NamedParameters<typeof findAndWriteImportsExports>": {
    "name": "NamedParameters<typeof findAndWriteImportsExports>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findandwriteimportsexports",
    "description": "",
    "operationName": "get-imports-exports"
  },
  "NamedParameters<typeof getImportsExportsTest>": {
    "name": "NamedParameters<typeof getImportsExportsTest>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getimportsexportstest",
    "description": "",
    "operationName": "get-imports-exports"
  },
  "NamedParameters<typeof getPackageNameFromAbsoluteImport>": {
    "name": "NamedParameters<typeof getPackageNameFromAbsoluteImport>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpackagenamefromabsoluteimport",
    "description": "",
    "operationName": "get-imports-exports"
  },
  "NamedParameters<typeof isAbsoluteImportBuiltin>": {
    "name": "NamedParameters<typeof isAbsoluteImportBuiltin>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isabsoluteimportbuiltin",
    "description": "",
    "operationName": "get-imports-exports"
  },
  "NamedParameters<typeof isImportFromOptionalFile>": {
    "name": "NamedParameters<typeof isImportFromOptionalFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isimportfromoptionalfile",
    "description": "",
    "operationName": "get-imports-exports"
  },
  "NamedParameters<typeof isImportGenerated>": {
    "name": "NamedParameters<typeof isImportGenerated>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isimportgenerated",
    "description": "",
    "operationName": "get-imports-exports"
  },
  "NamedParameters<typeof writeResult>": {
    "name": "NamedParameters<typeof writeResult>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-writeresult",
    "description": "",
    "operationName": "get-imports-exports"
  },
  "NamedParameters<typeof getOperationBins>": {
    "name": "NamedParameters<typeof getOperationBins>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationbins",
    "description": "",
    "operationName": "get-package-json"
  },
  "NamedParameters<typeof getOperationPackageName>": {
    "name": "NamedParameters<typeof getOperationPackageName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationpackagename",
    "description": "",
    "operationName": "get-package-json"
  },
  "NamedParameters<typeof getPackageJson>": {
    "name": "NamedParameters<typeof getPackageJson>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpackagejson",
    "description": "",
    "operationName": "get-package-json"
  },
  "NamedParameters<typeof getPackageSourcePaths>": {
    "name": "NamedParameters<typeof getPackageSourcePaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpackagesourcepaths",
    "description": "",
    "operationName": "get-package-source-paths"
  },
  "ModuleKind": {
    "name": "ModuleKind",
    "slug": "TsInterface",
    "id": "modulekind",
    "description": "",
    "operationName": "get-path"
  },
  "ModuleResolutionKind": {
    "name": "ModuleResolutionKind",
    "slug": "TsInterface",
    "id": "moduleresolutionkind",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof findOperationBasePath>": {
    "name": "NamedParameters<typeof findOperationBasePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findoperationbasepath",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof findOperationBasePathWithClassification>": {
    "name": "NamedParameters<typeof findOperationBasePathWithClassification>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findoperationbasepathwithclassification",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getAllPackageJsonDependencies>": {
    "name": "NamedParameters<typeof getAllPackageJsonDependencies>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getallpackagejsondependencies",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getCommonAncestor>": {
    "name": "NamedParameters<typeof getCommonAncestor>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcommonancestor",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getOperationClassification>": {
    "name": "NamedParameters<typeof getOperationClassification>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationclassification",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getOperationClassificationObject>": {
    "name": "NamedParameters<typeof getOperationClassificationObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationclassificationobject",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getOperationPath>": {
    "name": "NamedParameters<typeof getOperationPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationpath",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getOperationPathParse>": {
    "name": "NamedParameters<typeof getOperationPathParse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationpathparse",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getOperationRelativePath>": {
    "name": "NamedParameters<typeof getOperationRelativePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationrelativepath",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getPathParse>": {
    "name": "NamedParameters<typeof getPathParse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpathparse",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getPathsWithOperations>": {
    "name": "NamedParameters<typeof getPathsWithOperations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpathswithoperations",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getProjectRoot>": {
    "name": "NamedParameters<typeof getProjectRoot>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getprojectroot",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getRelativeLinkPath>": {
    "name": "NamedParameters<typeof getRelativeLinkPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getrelativelinkpath",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getRelativePath>": {
    "name": "NamedParameters<typeof getRelativePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getrelativepath",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getSrcRelativeFileId>": {
    "name": "NamedParameters<typeof getSrcRelativeFileId>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsrcrelativefileid",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getSubExtensions>": {
    "name": "NamedParameters<typeof getSubExtensions>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsubextensions",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof hasDependency>": {
    "name": "NamedParameters<typeof hasDependency>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-hasdependency",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof hasProjectRootFile>": {
    "name": "NamedParameters<typeof hasProjectRootFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-hasprojectrootfile",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof isBundle>": {
    "name": "NamedParameters<typeof isBundle>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isbundle",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof isOperation>": {
    "name": "NamedParameters<typeof isOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isoperation",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof isUiOperation>": {
    "name": "NamedParameters<typeof isUiOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isuioperation",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof isWorkspaceRoot>": {
    "name": "NamedParameters<typeof isWorkspaceRoot>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isworkspaceroot",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof packageCompilesTs>": {
    "name": "NamedParameters<typeof packageCompilesTs>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-packagecompilests",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof tsconfigCompilesEsm>": {
    "name": "NamedParameters<typeof tsconfigCompilesEsm>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tsconfigcompilesesm",
    "description": "",
    "operationName": "get-path"
  },
  "NamedParameters<typeof getTsConfig>": {
    "name": "NamedParameters<typeof getTsConfig>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettsconfig",
    "description": "",
    "operationName": "get-ts-config"
  },
  "CommentRange": {
    "name": "CommentRange",
    "slug": "TsInterface",
    "id": "commentrange",
    "description": "",
    "operationName": "index-typescript"
  },
  "CompleteOperationPathParse": {
    "name": "CompleteOperationPathParse",
    "slug": "TsInterface",
    "id": "completeoperationpathparse",
    "description": "",
    "operationName": "index-typescript",
    "rawText": "\n\nexport type CompleteOperationPathParse = OperationPathParse & {\n  filePath: string;\n};"
  },
  "Config": {
    "name": "Config",
    "slug": "TsInterface",
    "id": "config",
    "description": "",
    "operationName": "index-typescript"
  },
  "JSONSchema7": {
    "name": "JSONSchema7",
    "slug": "TsInterface",
    "id": "jsonschema7",
    "description": "",
    "operationName": "schema-util"
  },
  "MorphInterfaceInfo": {
    "name": "MorphInterfaceInfo",
    "slug": "TsInterface",
    "id": "morphinterfaceinfo",
    "description": "",
    "operationName": "index-typescript",
    "rawText": "export type MorphInterfaceInfo = {\n  raw: string;\n  name: string;\n  description?: string;\n  extensions: string[];\n  isExported: boolean;\n  hasGeneric: boolean;\n};"
  },
  "NamedParameters<typeof cli>": {
    "name": "NamedParameters<typeof cli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-cli",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof findCommentTypes>": {
    "name": "NamedParameters<typeof findCommentTypes>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findcommenttypes",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof generateSchema>": {
    "name": "NamedParameters<typeof generateSchema>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateschema",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof getDbStorageMethod>": {
    "name": "NamedParameters<typeof getDbStorageMethod>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdbstoragemethod",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof getFrontmatterDbStorageMethod>": {
    "name": "NamedParameters<typeof getFrontmatterDbStorageMethod>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfrontmatterdbstoragemethod",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof getIndexId>": {
    "name": "NamedParameters<typeof getIndexId>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getindexid",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof getMaxIndentationDepth>": {
    "name": "NamedParameters<typeof getMaxIndentationDepth>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmaxindentationdepth",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof getNumberOfLines>": {
    "name": "NamedParameters<typeof getNumberOfLines>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getnumberoflines",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof getParametersFromInterfaces>": {
    "name": "NamedParameters<typeof getParametersFromInterfaces>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getparametersfrominterfaces",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof getPossibleRefs>": {
    "name": "NamedParameters<typeof getPossibleRefs>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpossiblerefs",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof getSizeSummary>": {
    "name": "NamedParameters<typeof getSizeSummary>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsizesummary",
    "description": "",
    "operationName": "path-util"
  },
  "NamedParameters<typeof getSpecialExtensionDbStorageMethod>": {
    "name": "NamedParameters<typeof getSpecialExtensionDbStorageMethod>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getspecialextensiondbstoragemethod",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof getValidatedOperationPathParse>": {
    "name": "NamedParameters<typeof getValidatedOperationPathParse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getvalidatedoperationpathparse",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof hasDefinition>": {
    "name": "NamedParameters<typeof hasDefinition>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-hasdefinition",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof hasTypescriptFileChanged>": {
    "name": "NamedParameters<typeof hasTypescriptFileChanged>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-hastypescriptfilechanged",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof indexTypescript>": {
    "name": "NamedParameters<typeof indexTypescript>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-indextypescript",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof indexTypescriptFile>": {
    "name": "NamedParameters<typeof indexTypescriptFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-indextypescriptfile",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof makeTsComment>": {
    "name": "NamedParameters<typeof makeTsComment>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-maketscomment",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof schemaToTsInterface>": {
    "name": "NamedParameters<typeof schemaToTsInterface>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-schematotsinterface",
    "description": "",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof tryCreateSchema>": {
    "name": "NamedParameters<typeof tryCreateSchema>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-trycreateschema",
    "description": "",
    "operationName": "index-typescript"
  },
  "Project": {
    "name": "Project",
    "slug": "TsInterface",
    "id": "project",
    "description": "Project that holds source files.",
    "operationName": "index-typescript"
  },
  "NamedParameters<typeof fetchWithTimeout>": {
    "name": "NamedParameters<typeof fetchWithTimeout>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fetchwithtimeout",
    "description": "",
    "operationName": "is-online"
  },
  "NamedParameters<typeof isOnline>": {
    "name": "NamedParameters<typeof isOnline>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isonline",
    "description": "",
    "operationName": "is-online"
  },
  "NamedParameters<typeof isSystemBusy>": {
    "name": "NamedParameters<typeof isSystemBusy>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-issystembusy",
    "description": "",
    "operationName": "is-system-busy"
  },
  "NamedParameters<typeof concatenate>": {
    "name": "NamedParameters<typeof concatenate>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-concatenate",
    "description": "",
    "operationName": "js-util"
  },
  "NamedParameters<typeof getParameterAtLocation>": {
    "name": "NamedParameters<typeof getParameterAtLocation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getparameteratlocation",
    "description": "",
    "operationName": "js-util"
  },
  "NamedParameters<typeof hasAllLetters>": {
    "name": "NamedParameters<typeof hasAllLetters>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-hasallletters",
    "description": "",
    "operationName": "js-util"
  },
  "NamedParameters<typeof isArrayEqual>": {
    "name": "NamedParameters<typeof isArrayEqual>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isarrayequal",
    "description": "",
    "operationName": "js-util"
  },
  "NamedParameters<typeof mergeNestedObjectTest>": {
    "name": "NamedParameters<typeof mergeNestedObjectTest>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-mergenestedobjecttest",
    "description": "",
    "operationName": "js-util"
  },
  "NamedParameters<typeof replaceLastOccurence>": {
    "name": "NamedParameters<typeof replaceLastOccurence>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-replacelastoccurence",
    "description": "",
    "operationName": "js-util"
  },
  "NamedParameters<typeof reverseString>": {
    "name": "NamedParameters<typeof reverseString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-reversestring",
    "description": "",
    "operationName": "js-util"
  },
  "NamedParameters<typeof trimSlashes>": {
    "name": "NamedParameters<typeof trimSlashes>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-trimslashes",
    "description": "",
    "operationName": "js-util"
  },
  "O": {
    "name": "O",
    "slug": "TsInterface",
    "id": "o",
    "description": "",
    "operationName": "js-util",
    "rawText": "export type O = { [key: string]: any };"
  },
  "NamedParameters<typeof getSimpleJsonString>": {
    "name": "NamedParameters<typeof getSimpleJsonString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsimplejsonstring",
    "description": "",
    "operationName": "json-util"
  },
  "NamedParameters<typeof dev>": {
    "name": "NamedParameters<typeof dev>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-dev",
    "description": "",
    "operationName": "k-dev"
  },
  "NamedParameters<typeof devCli>": {
    "name": "NamedParameters<typeof devCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-devcli",
    "description": "",
    "operationName": "k-dev"
  },
  "NamedParameters<typeof benchmark>": {
    "name": "NamedParameters<typeof benchmark>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-benchmark",
    "description": "",
    "operationName": "k-explore"
  },
  "NamedParameters<typeof exploreOperationFolders>": {
    "name": "NamedParameters<typeof exploreOperationFolders>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-exploreoperationfolders",
    "description": "",
    "operationName": "k-explore"
  },
  "NamedParameters<typeof findAllDocsFolderPaths>": {
    "name": "NamedParameters<typeof findAllDocsFolderPaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findalldocsfolderpaths",
    "description": "",
    "operationName": "k-explore"
  },
  "NamedParameters<typeof findAllFoldersWithName>": {
    "name": "NamedParameters<typeof findAllFoldersWithName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findallfolderswithname",
    "description": "",
    "operationName": "k-explore"
  },
  "NamedParameters<typeof findAllPackages>": {
    "name": "NamedParameters<typeof findAllPackages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findallpackages",
    "description": "",
    "operationName": "k-explore"
  },
  "NamedParameters<typeof findAllTodoFolderPaths>": {
    "name": "NamedParameters<typeof findAllTodoFolderPaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findalltodofolderpaths",
    "description": "",
    "operationName": "k-explore"
  },
  "NamedParameters<typeof getArgument>": {
    "name": "NamedParameters<typeof getArgument>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getargument",
    "description": "",
    "operationName": "k-explore"
  },
  "NamedParameters<typeof getFolderTypescriptFiles>": {
    "name": "NamedParameters<typeof getFolderTypescriptFiles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfoldertypescriptfiles",
    "description": "",
    "operationName": "k-explore"
  },
  "NamedParameters<typeof pathArrayIsOperation>": {
    "name": "NamedParameters<typeof pathArrayIsOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-patharrayisoperation",
    "description": "",
    "operationName": "k-explore"
  },
  "NamedParameters<typeof runTestsForOperation>": {
    "name": "NamedParameters<typeof runTestsForOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-runtestsforoperation",
    "description": "",
    "operationName": "k-test"
  },
  "NamedParameters<typeof sum>": {
    "name": "NamedParameters<typeof sum>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-sum",
    "description": "",
    "operationName": "k-test"
  },
  "KeyValueMarkdownParse": {
    "name": "KeyValueMarkdownParse",
    "slug": "TsInterface",
    "id": "keyvaluemarkdownparse",
    "description": "",
    "operationName": "model-types",
    "rawText": "\n\nexport type KeyValueMarkdownParse = {\n  parameters: Frontmatter;\n  data: KeyValueMarkdownModelType[];\n};"
  },
  "MarkdownChunk": {
    "name": "MarkdownChunk",
    "slug": "TsInterface",
    "id": "markdownchunk",
    "description": "",
    "operationName": "markdown-types",
    "rawText": "\n\nexport type MarkdownChunk = {\n  level: MarkdownContentLevel;\n  content?: string;\n  markdownEmbed?: MarkdownEmbed;\n  markdownLink?: MarkdownLink;\n  /**\n   * NB: title can also be an empty string (\"\")\n   */\n  title?: string;\n  /**\n   * all content until the next title. it's either a content array if there's any titles found, or a string[] if it's paragraphs\n   */\n  children?: MarkdownChunk[];\n};"
  },
  "NamedParameters<typeof flattenMarkdownChunks>": {
    "name": "NamedParameters<typeof flattenMarkdownChunks>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-flattenmarkdownchunks",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "NamedParameters<typeof getKvmdItemsRecursively>": {
    "name": "NamedParameters<typeof getKvmdItemsRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getkvmditemsrecursively",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "NamedParameters<typeof getParagraphsRecursively>": {
    "name": "NamedParameters<typeof getParagraphsRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getparagraphsrecursively",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "NamedParameters<typeof kvmdDataMap>": {
    "name": "NamedParameters<typeof kvmdDataMap>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-kvmddatamap",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "NamedParameters<typeof kvmdDataToString>": {
    "name": "NamedParameters<typeof kvmdDataToString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-kvmddatatostring",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "NamedParameters<typeof kvmdParseToMarkdownString>": {
    "name": "NamedParameters<typeof kvmdParseToMarkdownString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-kvmdparsetomarkdownstring",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "NamedParameters<typeof markdownStringToKvmdParse>": {
    "name": "NamedParameters<typeof markdownStringToKvmdParse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownstringtokvmdparse",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "NamedParameters<typeof parseKvmdLine>": {
    "name": "NamedParameters<typeof parseKvmdLine>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parsekvmdline",
    "description": "",
    "operationName": "key-value-markdown-js"
  },
  "CoreWordMatrixWord": {
    "name": "CoreWordMatrixWord",
    "slug": "TsInterface",
    "id": "corewordmatrixword",
    "description": "",
    "operationName": "language-types",
    "rawText": "\n\nexport type CoreWordMatrixWord = {\n  /**\n   * Priority level is how important this word is to communicate...\n   *\n   *\n   * TITLE: Priority level (defaults to low)\n   *\n   * critical: toki pona word (top 150)\n   * high: top 500\n   * medium: top 2500\n   * low (default): less occurence\n   */\n  priorityLevel?: WordPriority;\n\n  /**\n   * TITLE: Rank (How common this word is in the english language?)\n   */\n  rank?: number;\n\n  /**\n   * amount used across the whole monorepo\n   */\n  usageCountCalculated?: number;\n\n  /**\n   * All ways the word is conjucated from the root word\n   */\n  conjucations?: WordConjucation[];\n\n  /**\n   * SECTION: Relations to other words...\n   *\n   * TITLE: Root word\n   *\n   * DESCRIPTION: If the word is a certain conjugation of a root word, this should be a reference to the root word\n   */\n  root_wordMatrixSlug?: Slug;\n  root_word?: WordMatrix;\n\n  /**\n   * TITLE: Opposite word\n   *\n   * DESCRIPTION: If there's another word that's the complete opposite of this one, you can declare it here\n   */\n  opposite_wordMatrixSlug?: Slug;\n  opposite_wordMatrix?: WordMatrix;\n\n  /**\n   * TITLE: Common Synonym\n   *\n   * DESCRIPTION: f the word is a synonym to a more common word, this should be a reference to the more common synonym. This is a 1:1 synonym only\n   */\n  common_wordMatrixSlug?: Slug;\n  common_wordMatrix?: WordMatrix;\n\n  /**\n   * TITLE: Toki-Pona words\n   *\n   * DESCRIPTION: The closest way to express this word in toki pona terms.\n   *\n   * NB: should be an array (order is important here) of slugs of words containing the \"tk\" property. This needs to be a reference so we can also give information about the individual toki pona words\n   */\n  tokiPona_wordMatrixSlugs?: Slug[];\n  tokiPona_wordMatrixs?: WordMatrix[];\n\n  /**\n   * TITLE: Emoji Words\n   *\n   * The closest way to express this word in emoji terms should be an array (order is important here) of slugs of words containing \"emoji\" property\n   *\n   * This needs to be a reference so we can also give information about the individual emojis\n   */\n  emoji_wordMatrixSlugs?: Slug[];\n  emoji_wordMatrixs?: WordMatrix[];\n\n  /**\n   * SECTION: Translations\n   *\n   * DESCRIPTION: Single emoji describing this word 1:1 (if it are more emojis of multiple words, please use the reference instead)\n   */\n  emoji?: string;\n};"
  },
  "KvmdWord": {
    "name": "KvmdWord",
    "slug": "TsInterface",
    "id": "kvmdword",
    "description": "Should later be migrated to `WordMatrix`",
    "operationName": "language-types",
    "rawText": "\n\n/**\n * Should later be migrated to `WordMatrix`\n */\nexport interface KvmdWord extends KeyValueMarkdownModelType {}"
  },
  "Language": {
    "name": "Language",
    "slug": "TsInterface",
    "id": "language",
    "description": "all currently supported languages",
    "operationName": "writer-types"
  },
  "MappedWordMatrix": {
    "name": "MappedWordMatrix",
    "slug": "TsInterface",
    "id": "mappedwordmatrix",
    "description": "Mapped Object for performance reasons",
    "operationName": "language-types",
    "rawText": "\n\n/** Mapped Object for performance reasons */\nexport interface MappedWordMatrix extends MappedObject<WordMatrix> {\n  [baseLanguageWord: string]: WordMatrix;\n}"
  },
  "MarkdownWord": {
    "name": "MarkdownWord",
    "slug": "TsInterface",
    "id": "markdownword",
    "description": "Should later be migrated to `WordMatrix`",
    "operationName": "language-types",
    "rawText": "\n\n/**\n * Should later be migrated to `WordMatrix`\n */\nexport interface MarkdownWord extends MarkdownModelType {}"
  },
  "NepaliEnglishTranslationMatrix": {
    "name": "NepaliEnglishTranslationMatrix",
    "slug": "TsInterface",
    "id": "nepalienglishtranslationmatrix",
    "description": "",
    "operationName": "language-types",
    "rawText": "\n\nexport interface NepaliEnglishTranslationMatrix extends DefaultModelType {\n  en: string;\n  index: number;\n  ne: string;\n}"
  },
  "Statement": {
    "name": "Statement",
    "slug": "TsInterface",
    "id": "statement",
    "description": "\nStatement model:\n\nMotivation:\n\n- create a database of the belief system of one or multiple entities (Person, Algorithm, species, etc.)\n- use this belief system for fact-checking, differentiative checking, value checking, and more.",
    "operationName": "language-types",
    "rawText": "\n\n/**\n---\ndbStorageMethod: jsonSingle\n---\n\nStatement model:\n\nMotivation:\n\n- create a database of the belief system of one or multiple entities (Person, Algorithm, species, etc.)\n- use this belief system for fact-checking, differentiative checking, value checking, and more.\n\n */\nexport interface Statement extends DefaultModelType {\n  /**\n   * your statement: definition, fact, question, quote\n   */\n  description: string;\n\n  /**\n   * source of the statement, if the statement was a non-original one found online somewhere\n   */\n  url?: string;\n\n  author_personId?: Id;\n\n  /**\n   * Number [0-1] representing agreement of admin\n   *\n   * - 1 meaning 100% agreement\n   * - 0 means 0% agreement or complete disagreement\n   */\n  agreement?: number;\n\n  /**\n   * Number [0,1] representing agreement of readers\n   *\n   * 1 reader can vote once\n   */\n  readersAgreement?: number;\n  readersAgreementVotedCount?: number;\n\n  /**\n   * defaults to 0.5 meaning average importancy\n   * this could be either a calculated or set property.\n   * could it be calculated on your value hierarchy?\n   * not sure if this is practical (yet) but still a very interesting property to have, or somehow calculate.\n   */\n  importancy?: number;\n  /**\n   * by default, importancy is calculated by one or multiple systems. As the admin you can change it\n   *\n   * TODO: once this is all working, possibly add reader-importancy and readersImportancyVotedCount\n   */\n  isImportancySet?: boolean;\n\n  /**\n   * A statement can connect to one or more words. This can be calculated automatically I guess, by looking at all WordMatrix words and WordCombinations that are inside of the statement. However, we may not want to put all of them in there.\n   *\n   * For now, let's skip this, since it's probably better to calculate it on the fly, not index it.\n   */\n  wordMatrixSlugs?: Slug[];\n  wordMatrixs?: WordMatrix[];\n}"
  },
  "TokiPonaMatrix": {
    "name": "TokiPonaMatrix",
    "slug": "TsInterface",
    "id": "tokiponamatrix",
    "description": "DEPRECATED: to be migrated to `WordMatrix`",
    "operationName": "language-types",
    "rawText": "\n\n/**\n * DEPRECATED: to be migrated to `WordMatrix`\n */\nexport interface TokiPonaMatrix extends DefaultModelType {\n  category: string;\n  type: string;\n  tok?: string;\n  nl?: string;\n  en?: string;\n  np?: string;\n  \"pt-br\"?: string;\n  em: string;\n}"
  },
  "Translation": {
    "name": "Translation",
    "slug": "TsInterface",
    "id": "translation",
    "description": "We could have a Translation model that collects any translation for any key for any model for any language.\nThe original source text is still stored in the models itself, and every model has just one language.\n\nIf you want a markdown or text key to be translated, add `{parameter}_TranslationId` to the model. The translation can then be generated on-demand and improved afterwards.",
    "operationName": "language-types",
    "rawText": "\n\n/**\n * We could have a Translation model that collects any translation for any key for any model for any language.\n * The original source text is still stored in the models itself, and every model has just one language.\n *\n * If you want a markdown or text key to be translated, add `{parameter}_TranslationId` to the model. The translation can then be generated on-demand and improved afterwards.\n */\nexport interface Translation extends DefaultModelType {\n  /**\n   * Not sure if this is needed. Do we need to know where any given translation comes from? It would be a lot of searching otherwise, maybe. Maybe this should even be an array if we want to avoid duplication, but this seems to make everything more complex. Maybe just skip sourcePath for the POC.\n   */\n  sourcePath: string;\n  language: Language;\n  markdown: Markdown;\n  text: Text;\n}"
  },
  "Word": {
    "name": "Word",
    "slug": "TsInterface",
    "id": "word",
    "description": "The goal of the words model is to provide a definition for every word we use, in any language.\n\nDEPRECATED: Should be replaced with `WordMatrix`",
    "operationName": "language-types",
    "rawText": "\n\n/**\n * The goal of the words model is to provide a definition for every word we use, in any language.\n *\n * DEPRECATED: Should be replaced with `WordMatrix`\n */\nexport interface Word extends SlugModelType {\n  /**\n   * The word\n   */\n  name: string;\n\n  /**\n   * How common this word is in the english language\n   */\n  rank?: number;\n\n  /**\n   * amount used across the whole monorepo\n   */\n  usageCountCalculated?: number;\n\n  /**\n   * if the word isn't in english already, this can be a reference to the english word that represents this word the most\n   */\n  english_wordSlug?: Slug;\n  english_word?: Word;\n\n  /**\n   * if the word is a certain conjugation of a root word, this should be a reference to the root word\n   */\n  root_wordSlug?: Slug;\n  root_word?: Word;\n\n  /**\n   * if the word is a synonym to a more common word, this should be a reference to the more common synonym. This is a 1:1 synonym only\n   */\n  common_wordSlug?: Slug;\n  common_word?: Word;\n\n  /**\n   * The closest way to express this word in toki pona terms should be an array (order is important here) of slugs of toki pona words\n   */\n  tokiPona_wordSlugs?: Slug[];\n  tokiPona_words?: Word[];\n\n  /**\n   * If the word is defined, this reference should lead to its definition statement\n   *\n   * unlike the word, definition statements are always in english.\n   *\n   * The definitions should only be made of the words that are\n   * - english\n   * - most common\n   * - root\n   */\n  definition_statementId?: Id;\n  definition_statement?: Statement;\n\n  /**\n   * if the word is also used as a ParameterName, this will refer to the ParameterName.\n   */\n  parameterNameSlug?: Slug;\n  parameterName?: ParameterName;\n}"
  },
  "WordCategory": {
    "name": "WordCategory",
    "slug": "TsInterface",
    "id": "wordcategory",
    "description": "Different ways to categorise a word semantically",
    "operationName": "language-types",
    "rawText": "\n\n/**\n * Different ways to categorise a word semantically\n */\nexport interface WordCategory extends SlugModelType {\n  description: Markdown;\n}"
  },
  "WordCombination": {
    "name": "WordCombination",
    "slug": "TsInterface",
    "id": "wordcombination",
    "description": "Best way to combine words if you don't want to specify all language specific info for a new word. You can refer to words from the WordMatrix instead!",
    "operationName": "language-types",
    "rawText": "\n\n/**\n * Best way to combine words if you don't want to specify all language specific info for a new word. You can refer to words from the WordMatrix instead!\n */\nexport interface WordCombination extends SlugModelType, WordInfo {\n  /**\n   * Should be autofilled based on the combination of the base words\n   */\n  name: string;\n  /**\n   * Should be auto filled in based on the combination of the base words\n   */\n  slug: string;\n  /**\n   * Which words is this a combination of?\n   */\n  wordMatrixSlugs?: Slug[];\n}"
  },
  "WordConjucation": {
    "name": "WordConjucation",
    "slug": "TsInterface",
    "id": "wordconjucation",
    "description": "In linguistics, conjugation is the creation of derived forms of a verb from its principal parts by inflection\n\nBesides this, there are also other ways to alter a word to add/change meaning, this should be summed up using this enum.",
    "operationName": "language-types",
    "rawText": "\n/**\n * In linguistics, conjugation is the creation of derived forms of a verb from its principal parts by inflection\n *\n * Besides this, there are also other ways to alter a word to add/change meaning, this should be summed up using this enum.\n */\nexport type WordConjucation = \"plural\" | \"female\" | \"male\" | \"past\" | \"future\";"
  },
  "WordInfo": {
    "name": "WordInfo",
    "slug": "TsInterface",
    "id": "wordinfo",
    "description": "",
    "operationName": "language-types",
    "rawText": "\n\nexport type WordInfo = {\n  /**\n   * Unique name of the word in English. Can usually be the word itself...\n   */\n  name: string;\n  slug: Slug;\n  /**\n   * Definition of the word (in english)\n   */\n  description?: Markdown;\n  descriptionAudio?: BackendAsset;\n\n  image?: BackendAsset;\n\n  wordCategorySlugs?: Slug[];\n  wordCategorys?: WordCategory[];\n\n  type?: WordType;\n};"
  },
  "WordLanguageInfo": {
    "name": "WordLanguageInfo",
    "slug": "TsInterface",
    "id": "wordlanguageinfo",
    "description": "Language specific word information",
    "operationName": "language-types",
    "rawText": "\n\n/**\n * Language specific word information\n */\nexport type WordLanguageInfo = {\n  /**\n   * TITLE: Latin writing (if common)\n   * DESCRIPTION: the latin standard written representation for this word\n   */\n  latin?: LanguageLatin;\n  /**\n   * TITLE: Alternative writing (if common)\n   *\n   * DESCRIPTION: the alternative written representation for this word, if any (if the language commonly uses a different script, this can be noted here)\n   */\n  alternative?: LanguageAlternative;\n  /**\n   * TITLE: Phonetic writing\n   *\n   * DESCRIPTION: Phonetic writing is used to describe how the word is pronounced\n   */\n  phonetic?: LanguagePhonetic;\n  /**\n   * TITLE: Spoken word\n   *\n   * DESCRIPTION: Audio fragment containing the spoken word.\n   */\n  audio?: LanguageAudio;\n  /**\n   * DESCRIPTION: A list of examples of usage of this word (can contain both a text and audio)\n   */\n  examples?: LanguageExample[];\n};"
  },
  "WordLanguageInfoObject": {
    "name": "WordLanguageInfoObject",
    "slug": "TsInterface",
    "id": "wordlanguageinfoobject",
    "description": "",
    "operationName": "language-types",
    "rawText": "\n\nexport type WordLanguageInfoObject = {\n  [languageKey in Language]?: WordLanguageInfo;\n};"
  },
  "WordMatrix": {
    "name": "WordMatrix",
    "slug": "TsInterface",
    "id": "wordmatrix",
    "description": "\nWordMatrix is a matrix that contains as much information about a word as possible in as many languages as possible. Easy to use for 1:1 translation\n\n@see Language",
    "operationName": "language-types",
    "rawText": "\n/**\n * ---\n * dbStorageMethod: jsonMultiple\n * ---\n *\n * WordMatrix is a matrix that contains as much information about a word as possible in as many languages as possible. Easy to use for 1:1 translation\n *\n * @see Language\n */\nexport type WordMatrix = WordLanguageInfoObject &\n  WordInfo &\n  CoreWordMatrixWord &\n  SlugModelType;"
  },
  "WordPriority": {
    "name": "WordPriority",
    "slug": "TsInterface",
    "id": "wordpriority",
    "description": "",
    "operationName": "writer-types"
  },
  "WordType": {
    "name": "WordType",
    "slug": "TsInterface",
    "id": "wordtype",
    "description": "",
    "operationName": "language-types",
    "rawText": "\n\nexport type WordType = \"noun\" | \"adjective\" | \"verb\";"
  },
  "NamedParameters<typeof Header>": {
    "name": "NamedParameters<typeof Header>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-header",
    "description": "",
    "operationName": "reader-ui"
  },
  "NamedParameters<typeof PingApi>": {
    "name": "NamedParameters<typeof PingApi>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-pingapi",
    "description": "",
    "operationName": "layout"
  },
  "NamedParameters<typeof preIndexLint>": {
    "name": "NamedParameters<typeof preIndexLint>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-preindexlint",
    "description": "",
    "operationName": "lint"
  },
  "LockInfo": {
    "name": "LockInfo",
    "slug": "TsInterface",
    "id": "lockinfo",
    "description": "",
    "operationName": "lock-system",
    "rawText": "\n\nexport type LockInfo = { updatedAt: number; status: string };"
  },
  "NamedParameters<typeof isLocked>": {
    "name": "NamedParameters<typeof isLocked>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-islocked",
    "description": "",
    "operationName": "lock-util"
  },
  "NamedParameters<typeof lock>": {
    "name": "NamedParameters<typeof lock>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-lock",
    "description": "",
    "operationName": "lock-util"
  },
  "NamedParameters<typeof unlock>": {
    "name": "NamedParameters<typeof unlock>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-unlock",
    "description": "",
    "operationName": "lock-util"
  },
  "GlobalLogConfig": {
    "name": "GlobalLogConfig",
    "slug": "TsInterface",
    "id": "globallogconfig",
    "description": "a logging configuration object that you can set using a file in the root of your operation or project.",
    "operationName": "log",
    "rawText": "\n/**\n * a logging configuration object that you can set using a file in the root of your operation or project.\n */\nexport type GlobalLogConfig = {\n  showDebug?: boolean;\n  showDefault?: boolean;\n  sayTitles?: boolean;\n  /**\n   * Folder where logs can be stored. If i can access the caller location this can be the operation db.\n   */\n  logFolder?: string;\n};"
  },
  "LogConfig": {
    "name": "LogConfig",
    "slug": "TsInterface",
    "id": "logconfig",
    "description": "",
    "operationName": "log",
    "rawText": "\n\nexport type LogConfig = {\n  /**\n   * The title of this log. If not given, a title will still be parsed from your message by taking the first sentence.\n   */\n  title?: string;\n  /**\n   * how it should look and feel for the user\n   */\n  type?: LogType;\n  /**\n   * Overwrite the global log config\n   */\n  customConfig?: GlobalLogConfig;\n};"
  },
  "LogType": {
    "name": "LogType",
    "slug": "TsInterface",
    "id": "logtype",
    "description": "how should it look and feel?",
    "operationName": "log",
    "rawText": "\n\n/**\nhow should it look and feel?\n */\nexport type LogType =\n  | \"debug\"\n  | \"error\"\n  | \"warning\"\n  | \"success\"\n  | \"important\"\n  | \"default\";"
  },
  "NamedParameters<typeof getCallerFileName>": {
    "name": "NamedParameters<typeof getCallerFileName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcallerfilename",
    "description": "",
    "operationName": "log"
  },
  "NamedParameters<typeof log>": {
    "name": "NamedParameters<typeof log>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-log",
    "description": "",
    "operationName": "log"
  },
  "NamedParameters<typeof parseTitle>": {
    "name": "NamedParameters<typeof parseTitle>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parsetitle",
    "description": "",
    "operationName": "log"
  },
  "OperationLogConfig": {
    "name": "OperationLogConfig",
    "slug": "TsInterface",
    "id": "operationlogconfig",
    "description": "",
    "operationName": "log",
    "rawText": "\n\nexport type OperationLogConfig = {\n  config: GlobalLogConfig;\n  fileConfig?: { [srcRelativeFilePath: string]: GlobalLogConfig };\n  functionConfig?: { [functionName: string]: GlobalLogConfig };\n};"
  },
  "ProjectLogConfig": {
    "name": "ProjectLogConfig",
    "slug": "TsInterface",
    "id": "projectlogconfig",
    "description": "",
    "operationName": "log",
    "rawText": "\n\nexport type ProjectLogConfig = {\n  config: GlobalLogConfig;\n  operationConfig: {\n    [key: string]: OperationLogConfig;\n  };\n};"
  },
  "MailDataFromOptional": {
    "name": "MailDataFromOptional",
    "slug": "TsInterface",
    "id": "maildatafromoptional",
    "description": "From is optional for sending an email because it will be filled in by the OsConfig default.",
    "operationName": "mail",
    "rawText": "\n/**\n * From is optional for sending an email because it will be filled in by the OsConfig default.\n */\nexport type MailDataFromOptional = Omit<MailDataRequired, \"from\"> & {\n  /**\n   * If you don't fill this in, the `OsConfig` default will be used.\n   */\n  from?: string;\n};"
  },
  "NamedParameters<typeof sendMail>": {
    "name": "NamedParameters<typeof sendMail>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-sendmail",
    "description": "",
    "operationName": "mail"
  },
  "NamedParameters<typeof makeFileType>": {
    "name": "NamedParameters<typeof makeFileType>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-makefiletype",
    "description": "",
    "operationName": "make-file-type"
  },
  "CodeblockMode": {
    "name": "CodeblockMode",
    "slug": "TsInterface",
    "id": "codeblockmode",
    "description": "",
    "operationName": "markdown",
    "rawText": "\nexport type CodeblockMode = \"preview\" | \"scroll\" | \"full\";"
  },
  "MarkdownParse": {
    "name": "MarkdownParse",
    "slug": "TsInterface",
    "id": "markdownparse",
    "description": "",
    "operationName": "writer-input"
  },
  "MarkdownParseRenderConfig": {
    "name": "MarkdownParseRenderConfig",
    "slug": "TsInterface",
    "id": "markdownparserenderconfig",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof getRealSrc>": {
    "name": "NamedParameters<typeof getRealSrc>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getrealsrc",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof getUrlFromRelativeUrl>": {
    "name": "NamedParameters<typeof getUrlFromRelativeUrl>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-geturlfromrelativeurl",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof getYoutubeId>": {
    "name": "NamedParameters<typeof getYoutubeId>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getyoutubeid",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof MarkdownCodeblock>": {
    "name": "NamedParameters<typeof MarkdownCodeblock>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdowncodeblock",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof MarkdownContent>": {
    "name": "NamedParameters<typeof MarkdownContent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdowncontent",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof MarkdownContentRender>": {
    "name": "NamedParameters<typeof MarkdownContentRender>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdowncontentrender",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof Parameter>": {
    "name": "NamedParameters<typeof Parameter>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parameter",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof renderFrontmatter>": {
    "name": "NamedParameters<typeof renderFrontmatter>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-renderfrontmatter",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof renderMarkdownChunk>": {
    "name": "NamedParameters<typeof renderMarkdownChunk>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rendermarkdownchunk",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof renderMarkdownContent>": {
    "name": "NamedParameters<typeof renderMarkdownContent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rendermarkdowncontent",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof renderMarkdownParse>": {
    "name": "NamedParameters<typeof renderMarkdownParse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rendermarkdownparse",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof renderMarkdownTitle>": {
    "name": "NamedParameters<typeof renderMarkdownTitle>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rendermarkdowntitle",
    "description": "",
    "operationName": "markdown"
  },
  "NamedParameters<typeof useOpenHashDetails>": {
    "name": "NamedParameters<typeof useOpenHashDetails>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-useopenhashdetails",
    "description": "",
    "operationName": "markdown"
  },
  "MarkdownParagraphChunk": {
    "name": "MarkdownParagraphChunk",
    "slug": "TsInterface",
    "id": "markdownparagraphchunk",
    "description": "",
    "operationName": "markdown-parse-js",
    "rawText": "\n\nexport type MarkdownParagraphChunk = {\n  isNewline?: boolean;\n  codeblock?: MarkdownCodeblock;\n  text?: string;\n  isBolded?: boolean;\n  isItalic?: boolean;\n  isBackticked?: boolean;\n  reference?: MarkdownReference;\n};"
  },
  "MarkdownParseConfig": {
    "name": "MarkdownParseConfig",
    "slug": "TsInterface",
    "id": "markdownparseconfig",
    "description": "",
    "operationName": "markdown-parse-js",
    "rawText": "\n\nexport type MarkdownParseConfig = {\n  /**\n  \n  setting this to true will \n  \n  - not trim strings in frontmatter\n  \n     */\n  noFinal?: boolean;\n  /**\n  if you want frontmatter to be parsed in correct shape, add frontmatterSchema\n     */\n  frontmatterSchema?: SimplifiedSchema;\n};"
  },
  "MarkdownReference": {
    "name": "MarkdownReference",
    "slug": "TsInterface",
    "id": "markdownreference",
    "description": "",
    "operationName": "markdown-parse-js",
    "rawText": "export type MarkdownReference = {\n  /**\n   * Alternate text inside of the reference, if available\n   */\n  alt?: string;\n  /**\n   * Absolute path to the refered object\n   */\n  path: string;\n  /**\n   * if true, it's an asset (with !)\n   *\n   * otherwise, it's a link\n   */\n  isAsset?: boolean;\n};"
  },
  "NamedParameters<typeof chunkToStringRecursively>": {
    "name": "NamedParameters<typeof chunkToStringRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-chunktostringrecursively",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof getChunkParagraphsRecursively>": {
    "name": "NamedParameters<typeof getChunkParagraphsRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getchunkparagraphsrecursively",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof getImplicitId>": {
    "name": "NamedParameters<typeof getImplicitId>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getimplicitid",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof getMarkdownIntro>": {
    "name": "NamedParameters<typeof getMarkdownIntro>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmarkdownintro",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof getMarkdownParseParagraphs>": {
    "name": "NamedParameters<typeof getMarkdownParseParagraphs>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmarkdownparseparagraphs",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof getMarkdownReferencePaths>": {
    "name": "NamedParameters<typeof getMarkdownReferencePaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmarkdownreferencepaths",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof getMarkdownReferencesFromParagraph>": {
    "name": "NamedParameters<typeof getMarkdownReferencesFromParagraph>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmarkdownreferencesfromparagraph",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof markdownParseToMarkdownString>": {
    "name": "NamedParameters<typeof markdownParseToMarkdownString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownparsetomarkdownstring",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof markdownParseToMarkdownStringFromContent>": {
    "name": "NamedParameters<typeof markdownParseToMarkdownStringFromContent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownparsetomarkdownstringfromcontent",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof mdContentParseRecursively>": {
    "name": "NamedParameters<typeof mdContentParseRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-mdcontentparserecursively",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof mdToJsonParse>": {
    "name": "NamedParameters<typeof mdToJsonParse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-mdtojsonparse",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof parseFrontmatterMarkdownString>": {
    "name": "NamedParameters<typeof parseFrontmatterMarkdownString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parsefrontmattermarkdownstring",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof parseMarkdownParagraph>": {
    "name": "NamedParameters<typeof parseMarkdownParagraph>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parsemarkdownparagraph",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof parseMdToChunks>": {
    "name": "NamedParameters<typeof parseMdToChunks>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parsemdtochunks",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "NamedParameters<typeof removeHeaderPrefix>": {
    "name": "NamedParameters<typeof removeHeaderPrefix>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removeheaderprefix",
    "description": "",
    "operationName": "markdown-parse-js"
  },
  "DependantCountObject": {
    "name": "DependantCountObject",
    "slug": "TsInterface",
    "id": "dependantcountobject",
    "description": "interface that lets us count the amount of dependant files in different item types",
    "operationName": "markdown-parsings",
    "rawText": "\n\n/**\n * interface that lets us count the amount of dependant files in different item types\n */\nexport type DependantCountObject = {\n  externalDependantFiles: string[];\n} & StatementItem;"
  },
  "JsonPart": {
    "name": "JsonPart",
    "slug": "TsInterface",
    "id": "jsonpart",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": "\n\nexport type JsonPart = { identifier?: string; json: Json };"
  },
  "MergedMarkdownOutlineUrl": {
    "name": "MergedMarkdownOutlineUrl",
    "slug": "TsInterface",
    "id": "mergedmarkdownoutlineurl",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": "\n\nexport type MergedMarkdownOutlineUrl = { title: string; hashtagPath: string };"
  },
  "NamedParameters<typeof addDependantCount>": {
    "name": "NamedParameters<typeof addDependantCount>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-adddependantcount",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof bundleFolderWithMarkdown>": {
    "name": "NamedParameters<typeof bundleFolderWithMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-bundlefolderwithmarkdown",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof bundleToBookMarkdown>": {
    "name": "NamedParameters<typeof bundleToBookMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-bundletobookmarkdown",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof bundleToMarkdown>": {
    "name": "NamedParameters<typeof bundleToMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-bundletomarkdown",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof concatMarkdownFiles>": {
    "name": "NamedParameters<typeof concatMarkdownFiles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-concatmarkdownfiles",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof createMinimizedSection>": {
    "name": "NamedParameters<typeof createMinimizedSection>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-createminimizedsection",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof createMinimizedSectionMarkdown>": {
    "name": "NamedParameters<typeof createMinimizedSectionMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-createminimizedsectionmarkdown",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof deployToVercel>": {
    "name": "NamedParameters<typeof deployToVercel>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-deploytovercel",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof emailMarkdownParse>": {
    "name": "NamedParameters<typeof emailMarkdownParse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-emailmarkdownparse",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof generateStaticSite>": {
    "name": "NamedParameters<typeof generateStaticSite>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatestaticsite",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof getJsonSchemaSummary>": {
    "name": "NamedParameters<typeof getJsonSchemaSummary>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getjsonschemasummary",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof getMarkdownContents>": {
    "name": "NamedParameters<typeof getMarkdownContents>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmarkdowncontents",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof getMergedMarkdownOutlineUrl>": {
    "name": "NamedParameters<typeof getMergedMarkdownOutlineUrl>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmergedmarkdownoutlineurl",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof getOperationSummary>": {
    "name": "NamedParameters<typeof getOperationSummary>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationsummary",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof getOutline>": {
    "name": "NamedParameters<typeof getOutline>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoutline",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof getPublicMarkdownNestedPathObject>": {
    "name": "NamedParameters<typeof getPublicMarkdownNestedPathObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpublicmarkdownnestedpathobject",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof getTitlesRecursively>": {
    "name": "NamedParameters<typeof getTitlesRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettitlesrecursively",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof getTypeDescriptorRecursive>": {
    "name": "NamedParameters<typeof getTypeDescriptorRecursive>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettypedescriptorrecursive",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof isConventionFileStatement>": {
    "name": "NamedParameters<typeof isConventionFileStatement>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isconventionfilestatement",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof isUpperCase>": {
    "name": "NamedParameters<typeof isUpperCase>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isuppercase",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof makeOutlineMarkdownString>": {
    "name": "NamedParameters<typeof makeOutlineMarkdownString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-makeoutlinemarkdownstring",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof makePropertiesTable>": {
    "name": "NamedParameters<typeof makePropertiesTable>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-makepropertiestable",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof markdownChunksToMarkdownStringRecursive>": {
    "name": "NamedParameters<typeof markdownChunksToMarkdownStringRecursive>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownchunkstomarkdownstringrecursive",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof markdownChunkToMarkdownStringRecursive>": {
    "name": "NamedParameters<typeof markdownChunkToMarkdownStringRecursive>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownchunktomarkdownstringrecursive",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof markdownToSayable>": {
    "name": "NamedParameters<typeof markdownToSayable>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdowntosayable",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof mdToPdf>": {
    "name": "NamedParameters<typeof mdToPdf>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-mdtopdf",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof mergeMarkdownParse>": {
    "name": "NamedParameters<typeof mergeMarkdownParse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-mergemarkdownparse",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof noNewlines>": {
    "name": "NamedParameters<typeof noNewlines>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-nonewlines",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof operationRadio>": {
    "name": "NamedParameters<typeof operationRadio>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-operationradio",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof operationToMarkdown>": {
    "name": "NamedParameters<typeof operationToMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-operationtomarkdown",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof print>": {
    "name": "NamedParameters<typeof print>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-print",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof printNestedTitles>": {
    "name": "NamedParameters<typeof printNestedTitles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-printnestedtitles",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof projectToMarkdown>": {
    "name": "NamedParameters<typeof projectToMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-projecttomarkdown",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof propertyToTableRow>": {
    "name": "NamedParameters<typeof propertyToTableRow>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-propertytotablerow",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof sayablesToMp3>": {
    "name": "NamedParameters<typeof sayablesToMp3>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-sayablestomp3",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof selectRandomOperation>": {
    "name": "NamedParameters<typeof selectRandomOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-selectrandomoperation",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof simplifiedSchemaToMarkdownString>": {
    "name": "NamedParameters<typeof simplifiedSchemaToMarkdownString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-simplifiedschematomarkdownstring",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof statementItemToMarkdown>": {
    "name": "NamedParameters<typeof statementItemToMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-statementitemtomarkdown",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof tsFunctionToMarkdownString>": {
    "name": "NamedParameters<typeof tsFunctionToMarkdownString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tsfunctiontomarkdownstring",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof tsInterfaceToMarkdownString>": {
    "name": "NamedParameters<typeof tsInterfaceToMarkdownString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tsinterfacetomarkdownstring",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof tsVariableToMarkdownString>": {
    "name": "NamedParameters<typeof tsVariableToMarkdownString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tsvariabletomarkdownstring",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NamedParameters<typeof upMarkdownChunkLevelRecursively>": {
    "name": "NamedParameters<typeof upMarkdownChunkLevelRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-upmarkdownchunklevelrecursively",
    "description": "",
    "operationName": "markdown-parsings"
  },
  "NestedTitle": {
    "name": "NestedTitle",
    "slug": "TsInterface",
    "id": "nestedtitle",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": "\n\nexport type NestedTitle = string | NestedTitle[];"
  },
  "OperationSummary": {
    "name": "OperationSummary",
    "slug": "TsInterface",
    "id": "operationsummary",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": "\n\nexport type OperationSummary = {\n  operationFolderPath: string;\n  operationName: string;\n  classification: OperationClassification | undefined;\n  description: string | undefined;\n  size: FolderSummary | undefined;\n  coreDependenciesString: string;\n  operationDependenciesString: string;\n  packageDependenciesString: string;\n  cliItems: StatementItem[];\n  testItems: StatementItem[];\n  internalItems: StatementItem[];\n  externalItems: StatementItem[];\n  docs: { relativePath: string; content: string }[] | undefined;\n};"
  },
  "Sayable": {
    "name": "Sayable",
    "slug": "TsInterface",
    "id": "sayable",
    "description": "GOAL:\n- distribute read only (and audio only) material of my codebase\n- it is also a fundament for other applications in the future",
    "operationName": "markdown-parsings",
    "rawText": "/**\nGOAL:\n- distribute read only (and audio only) material of my codebase\n- it is also a fundament for other applications in the future\n */\n\nexport type Sayable = {\n  sayableText?: string;\n  voiceFileRelativePath?: string;\n};"
  },
  "StatementItem": {
    "name": "StatementItem",
    "slug": "TsInterface",
    "id": "statementitem",
    "description": "",
    "operationName": "markdown-parsings",
    "rawText": "\n\nexport type StatementItem = {\n  tsFunction?: TsFunction;\n  tsInterface?: TsInterface;\n  tsVariable?: TsVariable;\n};"
  },
  "MarkdownCallToAction": {
    "name": "MarkdownCallToAction",
    "slug": "TsInterface",
    "id": "markdowncalltoaction",
    "description": "",
    "operationName": "read-markdown-file"
  },
  "NamedParameters<typeof copyStaticAssets>": {
    "name": "NamedParameters<typeof copyStaticAssets>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-copystaticassets",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof copyStaticAssetsCli>": {
    "name": "NamedParameters<typeof copyStaticAssetsCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-copystaticassetscli",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof docsGetStaticPaths>": {
    "name": "NamedParameters<typeof docsGetStaticPaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-docsgetstaticpaths",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof docsGetStaticProps>": {
    "name": "NamedParameters<typeof docsGetStaticProps>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-docsgetstaticprops",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof getAllMarkdownReaderPages>": {
    "name": "NamedParameters<typeof getAllMarkdownReaderPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getallmarkdownreaderpages",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof getChildren>": {
    "name": "NamedParameters<typeof getChildren>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getchildren",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof getFolderExplorationInfo>": {
    "name": "NamedParameters<typeof getFolderExplorationInfo>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfolderexplorationinfo",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof getMarkdownModelPages>": {
    "name": "NamedParameters<typeof getMarkdownModelPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmarkdownmodelpages",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof getMarkdownPageInfo>": {
    "name": "NamedParameters<typeof getMarkdownPageInfo>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmarkdownpageinfo",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof getMarkdownReaderQueryPaths>": {
    "name": "NamedParameters<typeof getMarkdownReaderQueryPaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmarkdownreaderquerypaths",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof getOperationPages>": {
    "name": "NamedParameters<typeof getOperationPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationpages",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof getReaderTodoPages>": {
    "name": "NamedParameters<typeof getReaderTodoPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getreadertodopages",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof markdownReaderGetStaticPaths>": {
    "name": "NamedParameters<typeof markdownReaderGetStaticPaths>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownreadergetstaticpaths",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof markdownReaderGetStaticProps>": {
    "name": "NamedParameters<typeof markdownReaderGetStaticProps>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownreadergetstaticprops",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof markdownReaderGetStaticPropsFromPages>": {
    "name": "NamedParameters<typeof markdownReaderGetStaticPropsFromPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownreadergetstaticpropsfrompages",
    "description": "",
    "operationName": "markdown-reader-functions"
  },
  "NamedParameters<typeof getQueryPath>": {
    "name": "NamedParameters<typeof getQueryPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getquerypath",
    "description": "",
    "operationName": "markdown-reader-functions-js"
  },
  "ParsedUrlQuery": {
    "name": "ParsedUrlQuery",
    "slug": "TsInterface",
    "id": "parsedurlquery",
    "description": "",
    "operationName": "next-types",
    "rawText": "export interface ParsedUrlQuery extends NodeJS.Dict<string | string[]> {}"
  },
  "NestedWebPage": {
    "name": "NestedWebPage",
    "slug": "TsInterface",
    "id": "nestedwebpage",
    "description": "Only used for menu, so can be undefined because it shouldn't be available",
    "operationName": "webpage-types",
    "rawText": "\n\n/**\n * Only used for menu, so can be undefined because it shouldn't be available\n */\nexport type NestedWebPage = ChildObject<WebPage<null>>;"
  },
  "ReaderPageContentProps": {
    "name": "ReaderPageContentProps",
    "slug": "TsInterface",
    "id": "readerpagecontentprops",
    "description": "",
    "operationName": "reader-ui"
  },
  "CreatorMarkdownFile": {
    "name": "CreatorMarkdownFile",
    "slug": "TsInterface",
    "id": "creatormarkdownfile",
    "description": "",
    "operationName": "markdown-types",
    "rawText": "\n\nexport interface CreatorMarkdownFile\n  extends MarkdownModelType,\n    CreatorMarkdownProperties {}"
  },
  "CreatorMarkdownProperties": {
    "name": "CreatorMarkdownProperties",
    "slug": "TsInterface",
    "id": "creatormarkdownproperties",
    "description": "",
    "operationName": "markdown-types",
    "rawText": "export type CreatorMarkdownProperties = {\n  /**\n  DESCRIPTION: Only accessible to admin\n   */\n  isPrivate?: boolean;\n\n  /**\n   * DESCRIPTION: Don't show in the file explorer if you don't have access to this file. NB: only works in combination with pricing or `.isPrivate: true`\n   */\n  isSecret?: boolean;\n\n  /**\n   * Not sure how I should make this possible yet, but the biggest reason for having persona's is because you may want to do things anonymously. If persona's are truly not really needed, just anonymous and non-anonymous, then we can greatly simplify things by removing that model altogether.\n   *\n   * Also you'd have much fine-grained control over what's anonymous and what isn't in this way. I like this a lot.\n   */\n  isAnonymous?: boolean;\n\n  /**\n   * DESCRIPTION: If authorizedGroup is set, file content will not be available for people that aren't part of this group.\n   */\n  authorizedGroup?: \"\" | \"premium\" | \"enterprise\";\n\n  /**\n   * DESCRIPTION:If true, will not show up in reader ui's\n   */\n  isDraft?: boolean;\n\n  /**\n   * DESCRIPTION: If this is a date in the future, the file won't be available until that date\n   */\n  isAvailableFromDateAt?: number;\n};"
  },
  "ExtendedMarkdownProperties": {
    "name": "ExtendedMarkdownProperties",
    "slug": "TsInterface",
    "id": "extendedmarkdownproperties",
    "description": "Some properties for on any `MarkdownModelType` model that are quite general purpose and yet aren't included into the `MarkdownModel` because we may not always want them.",
    "operationName": "markdown-types",
    "rawText": "\n/**\n * Some properties for on any `MarkdownModelType` model that are quite general purpose and yet aren't included into the `MarkdownModel` because we may not always want them.\n */\nexport interface ExtendedMarkdownProperties {\n  /**\n   * Should be stored as textual date like `YYYY-MM-DD`\n   */\n  updatedAt: number;\n\n  /**\n   * Should be stored as textual date like `YYYY-MM-DD`\n   */\n  createdAt: number;\n\n  /**\n   * Either filled in or detected\n   */\n  language?: Language;\n\n  /**\n   * If true, will not auto-detect the language\n   */\n  isLanguageCustom?: boolean;\n}"
  },
  "MarkdownContentLevel": {
    "name": "MarkdownContentLevel",
    "slug": "TsInterface",
    "id": "markdowncontentlevel",
    "description": "0 is a paragraph\n1-6 is h1 until h6",
    "operationName": "markdown-types",
    "rawText": "\n\n/**\n * 0 is a paragraph\n * 1-6 is h1 until h6\n */\nexport type MarkdownContentLevel = number;"
  },
  "MarkdownEmbed": {
    "name": "MarkdownEmbed",
    "slug": "TsInterface",
    "id": "markdownembed",
    "description": "Anything in the format `![alt](src)`\n\nNB: I need to be very clear how this one works",
    "operationName": "markdown-types",
    "rawText": "\n\n/**\n * Anything in the format `![alt](src)`\n *\n * NB: I need to be very clear how this one works\n */\nexport type MarkdownEmbed = {\n  alt: string;\n  src: string;\n  type: AssetType;\n};"
  },
  "MarkdownHeader": {
    "name": "MarkdownHeader",
    "slug": "TsInterface",
    "id": "markdownheader",
    "description": "",
    "operationName": "markdown-types",
    "rawText": "\n\nexport type MarkdownHeader = {\n  level: MarkdownContentLevel;\n  title: string;\n};"
  },
  "MarkdownIndex": {
    "name": "MarkdownIndex",
    "slug": "TsInterface",
    "id": "markdownindex",
    "description": "Every time a markdown file comes in (watcher), can we do some default functions and GPT for it.",
    "operationName": "markdown-types",
    "rawText": "/**\n * Every time a markdown file comes in (watcher), can we do some default functions and GPT for it.\n */\nexport type MarkdownIndex = {\n  createdAt?: number;\n  updatedAt?: number;\n  source?: string;\n  isSource?: boolean;\n\n  title?: string;\n  seoTitle?: string;\n  keywords?: string[];\n  seoKeywords?: string[];\n\n  statements?: string[];\n\n  takeAways?: string[];\n\n  socialMediaPosts?: string[];\n\n  /**\n   *  GPT to get visual descriptions for any markdown file, which in turn can be turned into images\n   */\n  imagePromptDescritpions?: string[];\n\n  /**\n   * summary of the file\n   */\n  summary?: string;\n\n  /**\n   * Interesting standalone snippet finding in bigger video/audio\n   */\n  snippets?: { firstLine: string; lastLine: string }[];\n\n  /**\n   * Using GPT to determine suggested location where this file should go\n   */\n  suggestedLocation?: string;\n};"
  },
  "MarkdownLink": {
    "name": "MarkdownLink",
    "slug": "TsInterface",
    "id": "markdownlink",
    "description": "Anything in the format `[alt](href)`\n\nIt needs to be clear how this works. There is a convention for this, and I should implement that as good as possible, and document it here",
    "operationName": "markdown-types",
    "rawText": "\n\n/**\n * Anything in the format `[alt](href)`\n *\n * It needs to be clear how this works. There is a convention for this, and I should implement that as good as possible, and document it here\n */\nexport type MarkdownLink = {\n  alt: string;\n  href: string;\n  /**\n   * Can be inferred from href\n   */\n  type: AssetType;\n};"
  },
  "MarkdownParagraph": {
    "name": "MarkdownParagraph",
    "slug": "TsInterface",
    "id": "markdownparagraph",
    "description": "",
    "operationName": "markdown-types",
    "rawText": "\n\nexport type MarkdownParagraph = {\n  /** the raw text of this paragraph */\n  paragraph: string;\n  /**\n   * the parent stack\n   */\n  categoryStack: CategoryStack;\n  /**\n   * if the paragraph is\n   * NB: not always used!\n   */\n  level?: MarkdownContentLevel;\n};"
  },
  "NamedParameters<typeof markdownParseToMarkdownModelType>": {
    "name": "NamedParameters<typeof markdownParseToMarkdownModelType>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownparsetomarkdownmodeltype",
    "description": "",
    "operationName": "markdown-types"
  },
  "NamedParameters<typeof parseMarkdownModelTimestamp>": {
    "name": "NamedParameters<typeof parseMarkdownModelTimestamp>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parsemarkdownmodeltimestamp",
    "description": "",
    "operationName": "markdown-types"
  },
  "NamedParameters<typeof tryParseDate>": {
    "name": "NamedParameters<typeof tryParseDate>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tryparsedate",
    "description": "",
    "operationName": "markdown-types"
  },
  "PostableProperties": {
    "name": "PostableProperties",
    "slug": "TsInterface",
    "id": "postableproperties",
    "description": "`Postable` is not extending a modeltype anymore, it can be attached to any `MarkdownModelType` model",
    "operationName": "markdown-types",
    "rawText": "\n\n/**\n * `Postable` is not extending a modeltype anymore, it can be attached to any `MarkdownModelType` model\n */\nexport interface PostableProperties {\n  /**\n   * A way to store messagepresets in markdown. the headers are the different categories. If the first alinea is bolded, it will be parsed to be the title, and will be removed from the message.\n   */\n  isPreset?: boolean;\n  /**\n   * if `.isPlanned` is set to true, this will be converted into `MediaPost`\n   */\n  isPostable?: boolean;\n  /**\n   * If true, this thing should be parsed into a codestory, after which the `.isPostable: true` will be added.\n   */\n  isCodestory?: boolean;\n  // NB: optionally, connect the post to keep it in the system nearby a certain model instance....\n\n  tsInterfaceIds?: Id[];\n  tsInterfaces?: TsInterface[];\n  tsFunctionIds?: Id[];\n  tsFunctions?: TsFunction[];\n  bundleConfigSlugs?: Slug[];\n  bundleConfigs?: BundleConfig[];\n  operationIds?: Id[];\n  operations?: Operation[];\n  reference_assets?: BackendAsset[];\n}"
  },
  "TextJson": {
    "name": "TextJson",
    "slug": "TsInterface",
    "id": "textjson",
    "description": "TODO: Rename",
    "operationName": "markdown-types",
    "rawText": "\n/**\n * TODO: Rename\n */\nexport interface TextJson {\n  /**\n   * only available if it's a json file\n   */\n  json?: any;\n  /**\n   * only available if it's a typescript file\n   */\n  typescriptJson?: unknown;\n  /**\n   * only available if it's a markdown file\n   */\n  markdownJson?: MarkdownParse;\n  /**\n   * full absolute path to the file or folder\n   */\n  path: string;\n  isFolder: boolean;\n  /**\n   * only returned if `includeStats` is true\n   */\n  stats?: PathStats;\n  /**\n   * only returned if `includeMetaData` is set to true\n   */\n  metaData?: FileContentInfo;\n  /** if true, this means this path is given back because it was the last opened base path that searching was canceled on because of the cancelRecursionOn prop */\n  isCancelRecursionResult?: boolean;\n}"
  },
  "WebMarkdownFile": {
    "name": "WebMarkdownFile",
    "slug": "TsInterface",
    "id": "webmarkdownfile",
    "description": "Every markdown file meant for the web, should have these optional parameters that can be declared as its frontmatter\n\nNB: This is not part of MarkdownModelType, because MarkdownModelType is very barebones general purpose, not only for the web!",
    "operationName": "reader-ui"
  },
  "WebMarkdownProperties": {
    "name": "WebMarkdownProperties",
    "slug": "TsInterface",
    "id": "webmarkdownproperties",
    "description": "",
    "operationName": "markdown-types",
    "rawText": "\n\nexport interface WebMarkdownProperties\n  /**\n   * NB: it extends WebsiteHeader here because the MarkdownModelType needs to be flat, and cannot have objects\n   *\n   * We won't make the websiteHeader into an object, although, that would also be a possibility.\n   */\n  extends WebsiteHeaderProperties {\n  /**\n   * Domainname for this file (or folder if it's applied on a readme).\n   *\n   * On top of this, we can build automation that:\n   *\n   * - Infers social media channel names for the domain and creates them\n   * - Buys the domain and sets the DNS if you don't own it yet\n   * - Connects the domain to a Vercel project with the right environment variables if it's not already\n   *\n   * Furthermore we can:\n   *\n   * - create a feature where domains are suggested for subsets of your content and you can easily choose one of the suggested domains to buy it automatically and set it in the file\n   * - cleans up your domains if it seems you don't use them anymore (or at least detects unused domains, so you can also potentially sell them)\n   * - show domain authority for your domains and possible ways to improve it (this can, again, have a whole lot of automations built on top of it)\n   */\n  domain?: string;\n\n  markdownCallToActionSlugs?: Slug[];\n  markdownCallToActions?: MarkdownCallToAction[];\n  /**\n   * Refers to an `Item` from the shop\n   */\n  shop_itemIds?: Id[];\n  //shop_items:Item[];\n\n  /**\n   * Author, reference to persons\n   */\n  author_personSlugs?: Slug[];\n  //author_persons: Person[];\n\n  /**\n   * Labels referring to interests\n   */\n  interestSlugs?: Slug[];\n  //interests: Interest[];\n\n  /**\n   * Price for this file\n   *\n   * NB: in case the file is a README file, the price applies to all files in this folder, recursively, PER FILE.\n   */\n  price?: Price;\n}"
  },
  "WebsiteHeader": {
    "name": "WebsiteHeader",
    "slug": "TsInterface",
    "id": "websiteheader",
    "description": "",
    "operationName": "markdown-types",
    "rawText": "\n\nexport interface WebsiteHeader extends SlugModelType, WebsiteHeaderProperties {}"
  },
  "WebsiteHeaderProperties": {
    "name": "WebsiteHeaderProperties",
    "slug": "TsInterface",
    "id": "websiteheaderproperties",
    "description": "",
    "operationName": "markdown-types",
    "rawText": "\n\nexport type WebsiteHeaderProperties = {\n  headerImage?: BackendAsset;\n  headerTitle?: string;\n  headerBig?: boolean;\n  headerSubTitle?: string;\n  header_markdownCallToActionSlugs?: Slug[];\n  header_markdownCallToActions?: MarkdownCallToAction[];\n};"
  },
  "NamedParameters<typeof findCodeblocks>": {
    "name": "NamedParameters<typeof findCodeblocks>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findcodeblocks",
    "description": "",
    "operationName": "marked-util"
  },
  "NamedParameters<typeof findCodespans>": {
    "name": "NamedParameters<typeof findCodespans>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findcodespans",
    "description": "",
    "operationName": "marked-util"
  },
  "NamedParameters<typeof findEmbeds>": {
    "name": "NamedParameters<typeof findEmbeds>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findembeds",
    "description": "",
    "operationName": "marked-util"
  },
  "NamedParameters<typeof findEmbedsTest>": {
    "name": "NamedParameters<typeof findEmbedsTest>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findembedstest",
    "description": "",
    "operationName": "marked-util"
  },
  "NamedParameters<typeof findLinks>": {
    "name": "NamedParameters<typeof findLinks>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findlinks",
    "description": "",
    "operationName": "marked-util"
  },
  "NamedParameters<typeof cleanupTimer>": {
    "name": "NamedParameters<typeof cleanupTimer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-cleanuptimer",
    "description": "",
    "operationName": "measure-performance"
  },
  "NamedParameters<typeof generateUniqueId>": {
    "name": "NamedParameters<typeof generateUniqueId>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateuniqueid",
    "description": "",
    "operationName": "measure-performance"
  },
  "NamedParameters<typeof getNewPerformance>": {
    "name": "NamedParameters<typeof getNewPerformance>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getnewperformance",
    "description": "",
    "operationName": "measure-performance"
  },
  "NamedParameters<typeof minifyBuild>": {
    "name": "NamedParameters<typeof minifyBuild>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-minifybuild",
    "description": "",
    "operationName": "minify-build"
  },
  "CategoryModelType": {
    "name": "CategoryModelType",
    "slug": "TsInterface",
    "id": "categorymodeltype",
    "description": "\nTODO: make this be able to hold more than just the KV. If that's not really needed just throw this away...\n\nSimple recursive data structure for hierarchical categories. Should be used to make any category model\n\nMake sure, when extending this, to provide a reference `xxxSlug` and its content `xxx` as optional parameters to its parent categories.\n\nE.g. for a `CountryCategory`, you should provide `countryCategorySlug` and `countryCategory`",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * ---\n * isDbModel: false\n * ---\n *\n * TODO: make this be able to hold more than just the KV. If that's not really needed just throw this away...\n *\n * Simple recursive data structure for hierarchical categories. Should be used to make any category model\n *\n * Make sure, when extending this, to provide a reference `xxxSlug` and its content `xxx` as optional parameters to its parent categories.\n *\n * E.g. for a `CountryCategory`, you should provide `countryCategorySlug` and `countryCategory`\n */\nexport interface CategoryModelType extends KeyValueMarkdownModelType {}"
  },
  "CreatedAt": {
    "name": "CreatedAt",
    "slug": "TsInterface",
    "id": "createdat",
    "description": "",
    "operationName": "model-types",
    "rawText": "\nexport type CreatedAt = Time;"
  },
  "CreatedFirstAt": {
    "name": "CreatedFirstAt",
    "slug": "TsInterface",
    "id": "createdfirstat",
    "description": "in some cases, data can be created before it was created in our system. In this case, use CreatedFirstAt if this information is important.",
    "operationName": "model-types",
    "rawText": "\n/**\n * in some cases, data can be created before it was created in our system. In this case, use CreatedFirstAt if this information is important.\n */\nexport type CreatedFirstAt = Time;"
  },
  "Credit": {
    "name": "Credit",
    "slug": "TsInterface",
    "id": "credit",
    "description": "",
    "operationName": "peer-types"
  },
  "DeletedAt": {
    "name": "DeletedAt",
    "slug": "TsInterface",
    "id": "deletedat",
    "description": "",
    "operationName": "model-types",
    "rawText": "\nexport type DeletedAt = Time;"
  },
  "Email": {
    "name": "Email",
    "slug": "TsInterface",
    "id": "email",
    "description": "",
    "operationName": "model-types",
    "rawText": "\n\nexport type Email = string;"
  },
  "Euro": {
    "name": "Euro",
    "slug": "TsInterface",
    "id": "euro",
    "description": "",
    "operationName": "model-types",
    "rawText": "export type Euro = number;"
  },
  "Index": {
    "name": "Index",
    "slug": "TsInterface",
    "id": "index",
    "description": "used for md files. index is the line",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * used for md files. index is the line\n */\nexport type Index = number;"
  },
  "KvmdLine": {
    "name": "KvmdLine",
    "slug": "TsInterface",
    "id": "kvmdline",
    "description": "all things that can be parsed from a single line",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * all things that can be parsed from a single line\n */\nexport type KvmdLine = {\n  /**\n   * same as slug, used for model compatibility\n   */\n  id: string;\n  /**\n   * key\n   *\n   * should be english because it's kind of part of the codebase!\n   */\n  name: string;\n  /**\n   * calculated: slug for this key (kebab case form of the name)\n   */\n  slug: string;\n\n  /**\n   * value behind the semicolom (:). If not given, will be undefined.\n   *\n   * If possible, will be parsed to a number, boolean, null or undefined... otherwise it's a string\n   *\n   * can be any language that we can detect\n   */\n  value: string | number | boolean | null | undefined;\n\n  /** comment in html syntax. if not given, will be null */\n  comment: string | null;\n};"
  },
  "NamedParameters<typeof generateId>": {
    "name": "NamedParameters<typeof generateId>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateid",
    "description": "",
    "operationName": "model-types"
  },
  "NamedParameters<typeof generatePassword>": {
    "name": "NamedParameters<typeof generatePassword>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatepassword",
    "description": "",
    "operationName": "model-types"
  },
  "NamedParameters<typeof generateRandomString>": {
    "name": "NamedParameters<typeof generateRandomString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generaterandomstring",
    "description": "",
    "operationName": "model-types"
  },
  "NamedParameters<typeof generateTime>": {
    "name": "NamedParameters<typeof generateTime>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatetime",
    "description": "",
    "operationName": "model-types"
  },
  "NamedParameters<typeof isEmail>": {
    "name": "NamedParameters<typeof isEmail>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isemail",
    "description": "",
    "operationName": "model-types"
  },
  "PhoneNumber": {
    "name": "PhoneNumber",
    "slug": "TsInterface",
    "id": "phonenumber",
    "description": "country code without +",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * country code without +\n */\nexport type PhoneNumber = number;"
  },
  "RelationType": {
    "name": "RelationType",
    "slug": "TsInterface",
    "id": "relationtype",
    "description": "This probably doesn't work, but it would be great if it would. This way I'd like to say that any model can have keys that end with \"Id\". These keys should always refer to Ids from other models.\nAlso, if a model has a key like this, it is inferred that there is also a key without the Id suffix which does or doesn't cointain the actual model specified by the id.\n\nIf this cannot be done in typescript, it can be convention, and we can create a linter for this.\n\nWooh!\n\n```\nconst relations: RelationType = {\nhelloId: \"hoi\",\nbyeId: \"bye\",\n};\n```\n\nThe above seems to be working fine, so it IS possible!\n\nTODO: think about it... should the name of the parameter be dependent on the strategy of how the model is stored? Maybe just call it all id, right? We can also make the index a string by just prepending a string to it.",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * This probably doesn't work, but it would be great if it would. This way I'd like to say that any model can have keys that end with \"Id\". These keys should always refer to Ids from other models.\n * Also, if a model has a key like this, it is inferred that there is also a key without the Id suffix which does or doesn't cointain the actual model specified by the id.\n *\n * If this cannot be done in typescript, it can be convention, and we can create a linter for this.\n *\n * Wooh!\n *\n * ```\nconst relations: RelationType = {\n  helloId: \"hoi\",\n  byeId: \"bye\",\n};\n```\n\nThe above seems to be working fine, so it IS possible!\n\nTODO: think about it... should the name of the parameter be dependent on the strategy of how the model is stored? Maybe just call it all id, right? We can also make the index a string by just prepending a string to it.\n */\nexport type RelationType = {\n  [key: `${string}Id`]: Id | undefined;\n  [key: `${string}Slug`]: Slug | undefined;\n};"
  },
  "ShouldNotBeStored": {
    "name": "ShouldNotBeStored",
    "slug": "TsInterface",
    "id": "shouldnotbestored",
    "description": "Parameters that should not be stored into the database",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * Parameters that should not be stored into the database\n */\nexport type ShouldNotBeStored =\n  | \"operationName\"\n  | \"projectRelativePath\"\n  | \"operationRelativePath\";"
  },
  "SlugModelProperties": {
    "name": "SlugModelProperties",
    "slug": "TsInterface",
    "id": "slugmodelproperties",
    "description": "",
    "operationName": "model-types",
    "rawText": "\n\nexport type SlugModelProperties = {\n  /**\n   * kebab-case of the name, should be unique\n   */\n  slug: Slug;\n  name: string;\n  /**\n   * @default en\n   */\n  language: Language;\n};"
  },
  "Time": {
    "name": "Time",
    "slug": "TsInterface",
    "id": "time",
    "description": "Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time.\nI can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
    "operationName": "model-types",
    "rawText": "/**Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time.\nI can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()\n*/\nexport type Time = number;"
  },
  "TimeTypes": {
    "name": "TimeTypes",
    "slug": "TsInterface",
    "id": "timetypes",
    "description": "TimeTypes is often extended with modelTypes.",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * TimeTypes is often extended with modelTypes.\n */\nexport type TimeTypes = {\n  createdAt: CreatedAt;\n  updatedAt: UpdatedAt;\n  deletedAt: DeletedAt;\n  createdFirstAt: CreatedFirstAt;\n};"
  },
  "UpdatedAt": {
    "name": "UpdatedAt",
    "slug": "TsInterface",
    "id": "updatedat",
    "description": "",
    "operationName": "model-types",
    "rawText": "\n\nexport type UpdatedAt = Time;"
  },
  "Url": {
    "name": "Url",
    "slug": "TsInterface",
    "id": "url",
    "description": "valid url, can be validated",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * valid url, can be validated\n */\nexport type Url = string;"
  },
  "NamedParameters<typeof getAssetInputType>": {
    "name": "NamedParameters<typeof getAssetInputType>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getassetinputtype",
    "description": "",
    "operationName": "name-conventions"
  },
  "NamedParameters<typeof getParameterContentType>": {
    "name": "NamedParameters<typeof getParameterContentType>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getparametercontenttype",
    "description": "",
    "operationName": "name-conventions"
  },
  "NamedParameters<typeof isCalculatedParameter>": {
    "name": "NamedParameters<typeof isCalculatedParameter>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-iscalculatedparameter",
    "description": "",
    "operationName": "name-conventions"
  },
  "NamedParameters<typeof isGeneratedParameterName>": {
    "name": "NamedParameters<typeof isGeneratedParameterName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isgeneratedparametername",
    "description": "",
    "operationName": "name-conventions"
  },
  "PatternMatcher": {
    "name": "PatternMatcher",
    "slug": "TsInterface",
    "id": "patternmatcher",
    "description": "",
    "operationName": "name-conventions",
    "rawText": "\n\nexport type PatternMatcher = {\n  pattern: string;\n  matches: string;\n  /**\n   * if true, this indicates that all instances of the matched are single words. This makes it possible to use this patternmatcher directly after another patternmatcher without loosing information.\n   */\n  isSingleWord?: boolean;\n};"
  },
  "ExpandedObject": {
    "name": "ExpandedObject",
    "slug": "TsInterface",
    "id": "expandedobject",
    "description": "",
    "operationName": "nested-menu",
    "rawText": "\n\nexport type ExpandedObject = {\n  [queryPath: string]: boolean;\n};"
  },
  "NamedParameters<typeof useExpanded>": {
    "name": "NamedParameters<typeof useExpanded>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-useexpanded",
    "description": "",
    "operationName": "nested-menu"
  },
  "NamedParameters<typeof getAvailableOperationName>": {
    "name": "NamedParameters<typeof getAvailableOperationName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getavailableoperationname",
    "description": "",
    "operationName": "new-template"
  },
  "NamedParameters<typeof newOperation>": {
    "name": "NamedParameters<typeof newOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-newoperation",
    "description": "",
    "operationName": "new-template"
  },
  "NamedParameters<typeof newOperationCli>": {
    "name": "NamedParameters<typeof newOperationCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-newoperationcli",
    "description": "",
    "operationName": "new-template"
  },
  "NamedParameters<typeof newOperationWithFiles>": {
    "name": "NamedParameters<typeof newOperationWithFiles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-newoperationwithfiles",
    "description": "",
    "operationName": "new-template"
  },
  "NamedParameters<typeof newTemplate>": {
    "name": "NamedParameters<typeof newTemplate>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-newtemplate",
    "description": "",
    "operationName": "new-template"
  },
  "NamedParameters<typeof newTemplateCli>": {
    "name": "NamedParameters<typeof newTemplateCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-newtemplatecli",
    "description": "",
    "operationName": "new-template"
  },
  "NamedParameters<typeof getFullPath>": {
    "name": "NamedParameters<typeof getFullPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfullpath",
    "description": "",
    "operationName": "next-paths"
  },
  "NamedParameters<typeof getLastPathsChunk>": {
    "name": "NamedParameters<typeof getLastPathsChunk>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getlastpathschunk",
    "description": "",
    "operationName": "next-paths"
  },
  "NamedParameters<typeof usePath>": {
    "name": "NamedParameters<typeof usePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usepath",
    "description": "",
    "operationName": "next-paths"
  },
  "PreviewData": {
    "name": "PreviewData",
    "slug": "TsInterface",
    "id": "previewdata",
    "description": "",
    "operationName": "next-types",
    "rawText": "\n\nexport type PreviewData = string | false | object | undefined;"
  },
  "NamedParameters<typeof nodemon>": {
    "name": "NamedParameters<typeof nodemon>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-nodemon",
    "description": "",
    "operationName": "nodemon"
  },
  "NamedParameters<typeof getDependenciesSummary>": {
    "name": "NamedParameters<typeof getDependenciesSummary>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdependenciessummary",
    "description": "",
    "operationName": "operation-util"
  },
  "NamedParameters<typeof getOperationMetaData>": {
    "name": "NamedParameters<typeof getOperationMetaData>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationmetadata",
    "description": "",
    "operationName": "operation-util"
  },
  "NamedParameters<typeof recalculateOperationIndexJson>": {
    "name": "NamedParameters<typeof recalculateOperationIndexJson>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-recalculateoperationindexjson",
    "description": "",
    "operationName": "operation-util"
  },
  "OperationMetaData": {
    "name": "OperationMetaData",
    "slug": "TsInterface",
    "id": "operationmetadata",
    "description": "",
    "operationName": "operation-util",
    "rawText": "\n\nexport type OperationMetaData = {\n  operationBasePath: string;\n  operation: Operation | undefined;\n  operationName: string;\n  srcPath: string;\n  operationFolderName: string;\n  /**\n   * where the operation is located relative to the project root\n   */\n  relativeOperationLocationPath: string;\n};"
  },
  "NamedParameters<typeof parsePrimitive>": {
    "name": "NamedParameters<typeof parsePrimitive>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parseprimitive",
    "description": "",
    "operationName": "parse-primitive"
  },
  "NamedParameters<typeof parsePrimitiveArray>": {
    "name": "NamedParameters<typeof parsePrimitiveArray>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parseprimitivearray",
    "description": "",
    "operationName": "parse-primitive"
  },
  "NamedParameters<typeof parsePrimitiveBoolean>": {
    "name": "NamedParameters<typeof parsePrimitiveBoolean>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parseprimitiveboolean",
    "description": "",
    "operationName": "parse-primitive"
  },
  "NamedParameters<typeof parsePrimitiveString>": {
    "name": "NamedParameters<typeof parsePrimitiveString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parseprimitivestring",
    "description": "",
    "operationName": "parse-primitive"
  },
  "PrimitiveResult": {
    "name": "PrimitiveResult",
    "slug": "TsInterface",
    "id": "primitiveresult",
    "description": "",
    "operationName": "parse-primitive",
    "rawText": "\n\nexport type PrimitiveResult =\n  | boolean\n  | null\n  | undefined\n  | number\n  | string\n  | string[];"
  },
  "NamedParameters<typeof byteCount>": {
    "name": "NamedParameters<typeof byteCount>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-bytecount",
    "description": "",
    "operationName": "path-util"
  },
  "NamedParameters<typeof getFolderSummary>": {
    "name": "NamedParameters<typeof getFolderSummary>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfoldersummary",
    "description": "",
    "operationName": "path-util"
  },
  "NamedParameters<typeof sumSizeSummary>": {
    "name": "NamedParameters<typeof sumSizeSummary>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-sumsizesummary",
    "description": "",
    "operationName": "path-util"
  },
  "NamedParameters<typeof calculatePathMetaData>": {
    "name": "NamedParameters<typeof calculatePathMetaData>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-calculatepathmetadata",
    "description": "",
    "operationName": "path-util"
  },
  "NamedParameters<typeof categorizeFiles>": {
    "name": "NamedParameters<typeof categorizeFiles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-categorizefiles",
    "description": "",
    "operationName": "path-util"
  },
  "NamedParameters<typeof getPathMainComment>": {
    "name": "NamedParameters<typeof getPathMainComment>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpathmaincomment",
    "description": "",
    "operationName": "path-util"
  },
  "NamedParameters<typeof addPeer>": {
    "name": "NamedParameters<typeof addPeer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-addpeer",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof addPeerMessage>": {
    "name": "NamedParameters<typeof addPeerMessage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-addpeermessage",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof augmentDevice>": {
    "name": "NamedParameters<typeof augmentDevice>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-augmentdevice",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof deviceGetAppsCalculated>": {
    "name": "NamedParameters<typeof deviceGetAppsCalculated>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-devicegetappscalculated",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof getAllAppOperations>": {
    "name": "NamedParameters<typeof getAllAppOperations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getallappoperations",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof getAugmentedPersons>": {
    "name": "NamedParameters<typeof getAugmentedPersons>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getaugmentedpersons",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof getFirstEmoji>": {
    "name": "NamedParameters<typeof getFirstEmoji>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfirstemoji",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof getNestedPathObject>": {
    "name": "NamedParameters<typeof getNestedPathObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getnestedpathobject",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof getPeerMessages>": {
    "name": "NamedParameters<typeof getPeerMessages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpeermessages",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof getPeerPeople>": {
    "name": "NamedParameters<typeof getPeerPeople>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpeerpeople",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof getPeersFromPeersRecursively>": {
    "name": "NamedParameters<typeof getPeersFromPeersRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpeersfrompeersrecursively",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof getPublicFolderNestedPathObject>": {
    "name": "NamedParameters<typeof getPublicFolderNestedPathObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpublicfoldernestedpathobject",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof getPublicFolderNestedPathObjectFromPeer>": {
    "name": "NamedParameters<typeof getPublicFolderNestedPathObjectFromPeer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpublicfoldernestedpathobjectfrompeer",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof getPublicPeers>": {
    "name": "NamedParameters<typeof getPublicPeers>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpublicpeers",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof isPortUsed>": {
    "name": "NamedParameters<typeof isPortUsed>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isportused",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof lateFetchPeerMessageSync>": {
    "name": "NamedParameters<typeof lateFetchPeerMessageSync>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-latefetchpeermessagesync",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof ping>": {
    "name": "NamedParameters<typeof ping>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-ping",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof proactivePushAddPeerMessage>": {
    "name": "NamedParameters<typeof proactivePushAddPeerMessage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-proactivepushaddpeermessage",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof removePeer>": {
    "name": "NamedParameters<typeof removePeer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removepeer",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof sortDevices>": {
    "name": "NamedParameters<typeof sortDevices>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-sortdevices",
    "description": "",
    "operationName": "peer-functions"
  },
  "NamedParameters<typeof updatePeer>": {
    "name": "NamedParameters<typeof updatePeer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-updatepeer",
    "description": "",
    "operationName": "peer-functions"
  },
  "Person": {
    "name": "Person",
    "slug": "TsInterface",
    "id": "person",
    "description": "Model to describe a human person. This model gathers and stores all persons around the world, except for yourself. Kind of a user-like model...\n\n\nThe data inside this model is coming from the `Person` itself but also from the owner of the OS server. It should be possible for the person to automatically push information into any of their instances on any server, but the OS owner can augment this.\n\nNB: This is a `DefaultModelType`, which means name and slug need not to be unique, but it is highly preferred.",
    "operationName": "todo-types"
  },
  "Achievement": {
    "name": "Achievement",
    "slug": "TsInterface",
    "id": "achievement",
    "description": "",
    "operationName": "peer-types",
    "rawText": "\n\nexport interface Achievement {\n  emoji: string;\n  name: string;\n  description: string;\n  /**\n   * in case the developer attained the achievement, this will be set to his level\n   */\n  level?: number;\n  /**\n   * if it's quantifyable, you can add the levels here\n   */\n  levels?: number[];\n}"
  },
  "AppOperation": {
    "name": "AppOperation",
    "slug": "TsInterface",
    "id": "appoperation",
    "description": "",
    "operationName": "peer-types",
    "rawText": "export type AppOperation = {\n  name: string;\n  port: number;\n  description: string | undefined;\n  isOnline?: boolean;\n  /**\n   * Emoji that should be used as the app icon. Can be calculated from the `OPERATION.md`\n   */\n  emoji?: string;\n};"
  },
  "AuthenticationMethod": {
    "name": "AuthenticationMethod",
    "slug": "TsInterface",
    "id": "authenticationmethod",
    "description": "",
    "operationName": "server-login"
  },
  "Developer": {
    "name": "Developer",
    "slug": "TsInterface",
    "id": "developer",
    "description": "",
    "operationName": "peer-types",
    "rawText": "\n\nexport interface Developer extends Person {\n  achievements: Achievement[];\n}"
  },
  "HandleObject": {
    "name": "HandleObject",
    "slug": "TsInterface",
    "id": "handleobject",
    "description": "can be used on multiple models.",
    "operationName": "peer-types",
    "rawText": "\n\n/**\n * can be used on multiple models.\n */\nexport type HandleObject = {\n  [platform: Platform[\"slug\"]]: string;\n};"
  },
  "IBrowser": {
    "name": "IBrowser",
    "slug": "TsInterface",
    "id": "ibrowser",
    "description": "NB: copied from ua-parser-js ^1.0.32 because they weren't indexed",
    "operationName": "peer-types",
    "rawText": "/**\n * NB: copied from ua-parser-js ^1.0.32 because they weren't indexed\n */\n\nexport interface IBrowser {\n  /**\n   * Possible values :\n   * Amaya, Android Browser, Arora, Avant, Baidu, Blazer, Bolt, Camino, Chimera, Chrome,\n   * Chromium, Comodo Dragon, Conkeror, Dillo, Dolphin, Doris, Edge, Epiphany, Fennec,\n   * Firebird, Firefox, Flock, GoBrowser, iCab, ICE Browser, IceApe, IceCat, IceDragon,\n   * Iceweasel, IE [Mobile], Iron, Jasmine, K-Meleon, Konqueror, Kindle, Links,\n   * Lunascape, Lynx, Maemo, Maxthon, Midori, Minimo, MIUI Browser, [Mobile] Safari,\n   * Mosaic, Mozilla, Netfront, Netscape, NetSurf, Nokia, OmniWeb, Opera [Mini/Mobi/Tablet],\n   * Phoenix, Polaris, QQBrowser, RockMelt, Silk, Skyfire, SeaMonkey, SlimBrowser, Swiftfox,\n   * Tizen, UCBrowser, Vivaldi, w3m, Yandex\n   *\n   */\n  name: string | undefined;\n\n  /**\n   * Determined dynamically\n   */\n  version: string | undefined;\n\n  /**\n   * Determined dynamically\n   * @deprecated\n   */\n  major: string | undefined;\n}"
  },
  "ICPU": {
    "name": "ICPU",
    "slug": "TsInterface",
    "id": "icpu",
    "description": "",
    "operationName": "peer-types",
    "rawText": "\n\nexport interface ICPU {\n  /**\n   * Possible architecture:\n   *  68k, amd64, arm, arm64, avr, ia32, ia64, irix, irix64, mips, mips64, pa-risc,\n   *  ppc, sparc, sparc64\n   */\n  architecture: string | undefined;\n}"
  },
  "IDevice": {
    "name": "IDevice",
    "slug": "TsInterface",
    "id": "idevice",
    "description": "",
    "operationName": "peer-types",
    "rawText": "\n\nexport interface IDevice {\n  /**\n   * Determined dynamically\n   */\n  model: string | undefined;\n\n  /**\n   * Possible type:\n   * console, mobile, tablet, smarttv, wearable, embedded\n   */\n  type: string | undefined;\n\n  /**\n   * Possible vendor:\n   * Acer, Alcatel, Amazon, Apple, Archos, Asus, BenQ, BlackBerry, Dell, GeeksPhone,\n   * Google, HP, HTC, Huawei, Jolla, Lenovo, LG, Meizu, Microsoft, Motorola, Nexian,\n   * Nintendo, Nokia, Nvidia, Ouya, Palm, Panasonic, Polytron, RIM, Samsung, Sharp,\n   * Siemens, Sony-Ericsson, Sprint, Xbox, ZTE\n   */\n  vendor: string | undefined;\n}"
  },
  "IEngine": {
    "name": "IEngine",
    "slug": "TsInterface",
    "id": "iengine",
    "description": "",
    "operationName": "peer-types",
    "rawText": "\n\nexport interface IEngine {\n  /**\n   * Possible name:\n   * Amaya, EdgeHTML, Gecko, iCab, KHTML, Links, Lynx, NetFront, NetSurf, Presto,\n   * Tasman, Trident, w3m, WebKit\n   */\n  name: string | undefined;\n  /**\n   * Determined dynamically\n   */\n  version: string | undefined;\n}"
  },
  "Interest": {
    "name": "Interest",
    "slug": "TsInterface",
    "id": "interest",
    "description": "",
    "operationName": "social-media-types",
    "rawText": "\n\nexport interface Interest extends KeyValueMarkdownModelType {\n  parent_interestSlug: Slug;\n  parent_interest: Interest;\n}"
  },
  "IOS": {
    "name": "IOS",
    "slug": "TsInterface",
    "id": "ios",
    "description": "",
    "operationName": "peer-types",
    "rawText": "\n\nexport interface IOS {\n  /**\n   * Possible 'os.name'\n   * AIX, Amiga OS, Android, Arch, Bada, BeOS, BlackBerry, CentOS, Chromium OS, Contiki,\n   * Fedora, Firefox OS, FreeBSD, Debian, DragonFly, Gentoo, GNU, Haiku, Hurd, iOS,\n   * Joli, Linpus, Linux, Mac OS, Mageia, Mandriva, MeeGo, Minix, Mint, Morph OS, NetBSD,\n   * Nintendo, OpenBSD, OpenVMS, OS/2, Palm, PCLinuxOS, Plan9, Playstation, QNX, RedHat,\n   * RIM Tablet OS, RISC OS, Sailfish, Series40, Slackware, Solaris, SUSE, Symbian, Tizen,\n   * Ubuntu, UNIX, VectorLinux, WebOS, Windows [Phone/Mobile], Zenwalk\n   */\n  name: string | undefined;\n  /**\n   * Determined dynamically\n   */\n  version: string | undefined;\n}"
  },
  "MediaCredential": {
    "name": "MediaCredential",
    "slug": "TsInterface",
    "id": "mediacredential",
    "description": "",
    "operationName": "social-media-types",
    "rawText": "\n\nexport interface MediaCredential extends DefaultModelType {\n  mediaType: MediaPlatformEnum;\n  email?: string;\n  password: string;\n  username?: string;\n  phoneNumber?: string;\n}"
  },
  "PageVisit": {
    "name": "PageVisit",
    "slug": "TsInterface",
    "id": "pagevisit",
    "description": "Any visit tracked based on a server request\n\nNB: TODO: it might occur that a page fetches multiple api endpoints, which will create duplicate data here. How do I fix that?",
    "operationName": "peer-types",
    "rawText": "\n\n/**\n * Any visit tracked based on a server request\n *\n * NB: TODO: it might occur that a page fetches multiple api endpoints, which will create duplicate data here. How do I fix that?\n */\nexport interface PageVisit extends DefaultModelType {\n  deviceId: string;\n  /**\n   * complete url of the page that was visited\n   */\n  path: string;\n  /**\n   * When was the page visited\n   */\n  createdAt: number;\n  ipInfo: IPInfo;\n}"
  },
  "PeerMessage": {
    "name": "PeerMessage",
    "slug": "TsInterface",
    "id": "peermessage",
    "description": "DEPRECTATED: should be replaced by `MediaPost`. MediaPost can  have many channels, and this is just one of them",
    "operationName": "peer-types",
    "rawText": "\n\n/**\n * DEPRECTATED: should be replaced by `MediaPost`. MediaPost can  have many channels, and this is just one of them\n */\nexport interface PeerMessage extends DefaultModelType {\n  /**\n   * In  this case, this should be the createdAt of the original source! :)\n   */\n  createdFirstAt: number;\n  /**\n   * The peer this message has been posted by\n   */\n  peerSlug: Slug;\n  message: string;\n}"
  },
  "Persona": {
    "name": "Persona",
    "slug": "TsInterface",
    "id": "persona",
    "description": "Highly private model.\n\nConfiguration for a person identity that you say that is you.\n\nAs a OS user you can have multiple personas between which you can easily switch.\n\nThe difference from `Person` is that `Person` stores other people, whereas `Persona` stores different identities you give to yourself.\n\nNB: brands should also be able to be personas, and since some brands are shared between people, you should be able to share Persona's with other `Person`s into their OS...\n\n> Persona: A persona, depending on the context, is the public image of one's personality, the social role that one adopts, or simply a fictional character. The word derives from Latin, where it originally referred to a theatrical mask. On the social web, users develop virtual personas as online identities. (Wikipedia)",
    "operationName": "peer-types",
    "rawText": "\n/**\n * Highly private model.\n *\n * Configuration for a person identity that you say that is you.\n *\n * As a OS user you can have multiple personas between which you can easily switch.\n *\n * The difference from `Person` is that `Person` stores other people, whereas `Persona` stores different identities you give to yourself.\n *\n * NB: brands should also be able to be personas, and since some brands are shared between people, you should be able to share Persona's with other `Person`s into their OS...\n *\n * > Persona: A persona, depending on the context, is the public image of one's personality, the social role that one adopts, or simply a fictional character. The word derives from Latin, where it originally referred to a theatrical mask. On the social web, users develop virtual personas as online identities. (Wikipedia)\n */\nexport interface Persona extends SlugModelType {\n  /**\n   * If this is set to true, this persona instance will be selected when searching for a persona. Ensure that there is just one default persona!\n   *\n   * If none are `isPrimary`, the first persona instance can be selected\n   */\n  isPrimary?: boolean;\n  /**\n   * If true, this will pop up in persona selection\n   *\n   * If not, you can still find it using auto-complete, though\n   */\n  isFavorite?: boolean;\n\n  /**\n   * Some pictures that can be used that show this person\n   */\n  pictureImages?: BackendAsset[];\n\n  /**\n   * You can give different characteristics to your personas if you wish\n   */\n  dataEntries: PersonInformationValue[];\n\n  /** Interests this persona has\n   *\n   * Can be matched against a channel to be the recommended persona\n   */\n  interestSlugs?: Slug[];\n  interests?: Interest[];\n\n  /**\n   * Where does this persona reside? can be multiple locations\n   *\n   * Can be matched against a channel to be the recommended persona\n   */\n  locationSlugs?: Slug[];\n  locations?: Location[];\n\n  /**\n   * Languages that this persona can speak\n   *\n   * Can be matched against a channel to be the recommended persona\n   */\n  spokenLanguages: Language[];\n\n  /**\n   * NB: should have a custom input in the `SimplifiedSchemaForm`\n   */\n  stripeSecret?: string;\n\n  twilioAccountSid?: string;\n  twilioAuthToken?: string;\n  /**\n   * Provide the phone number you are using by default for sending SMS messages\n   */\n  twilioFromPhoneNumber?: string;\n\n  sendgridApiKey?: string;\n  sendgridFromEmail?: string;\n\n  /**\n   * Github stuff\n   */\n  githubEmail?: string;\n  /**\n   * Personal access token\n   */\n  githubAccessToken?: string;\n  githubOrganisation?: string;\n  useGithubOrganisation?: boolean;\n\n  mediaCredentialIds?: Id[];\n  mediaCredentials?: MediaCredential[];\n\n  apiKey2Captcha?: string;\n  openAiPassword?: string;\n  openAiEmail?: string;\n  openAiToken?: string;\n\n  linkedinEmail?: string;\n  linkedinPassword?: string;\n\n  /**\n   * phone, email or username\n   */\n  twitterLoginHandle?: string;\n  twitterPassword?: string;\n\n  facebookLoginHandle?: string;\n  facebookPassword?: string;\n\n  mediumLoginHandle?: string;\n  mediumPassword?: string;\n\n  redditLoginHandle?: string;\n  redditPassword?: string;\n\n  devtoLoginHandle?: string;\n  devtoPassword?: string;\n\n  slackLoginHandle?: string;\n  slackPassword?: string;\n\n  huggingfaceAuthToken?: string;\n\n  uberduckApiKey?: string;\n  uberduckSecret?: string;\n\n  bananadevApiKey?: string;\n  bananadevModelKeys?: {\n    [key: string]: string;\n  };\n\n  email: string;\n  phone: string;\n}"
  },
  "PersonInformation": {
    "name": "PersonInformation",
    "slug": "TsInterface",
    "id": "personinformation",
    "description": "categorisation model for informormation about a person\n\n- the keys are the things you want to store\n- the values are the descriptions of the thing to be stored\n- the categories can organise the things you want to store better",
    "operationName": "peer-types",
    "rawText": "\n\n/**\n * categorisation model for informormation about a person\n *\n * - the keys are the things you want to store\n * - the values are the descriptions of the thing to be stored\n * - the categories can organise the things you want to store better\n */\nexport interface PersonInformation extends KeyValueMarkdownModelType {\n  parent_personInformationSlug?: Slug;\n  parent_personInformation?: PersonInformation;\n}"
  },
  "PersonInformationValue": {
    "name": "PersonInformationValue",
    "slug": "TsInterface",
    "id": "personinformationvalue",
    "description": "key value data storage model for information about a person\n\n- the filename must identify the person this is about (`personSlug`)\n- the categories are the different people and the person information categories\n- the keys are the person information datapoints\n- the values are the values of the datapoints that you stored about this user\n\nExample:\n\nthe file `person-information-values/abraham-lincoln.md` could contain something like this:\n\n```md\n# life\nborn: 11-01-1777\ndied: 20-12-1812\n\n# identification\nfirstName: Abraham\nlastName: Lincoln\n```\n\nNB: It's not going to be easy to keep this model in sync with the model it relies on!\n\nTODO: figure out if this kan be a `KeyValueMarkdownModelType` or `MarkdownModelType`",
    "operationName": "peer-types",
    "rawText": "\n\n/** key value data storage model for information about a person\n *\n * - the filename must identify the person this is about (`personSlug`)\n * - the categories are the different people and the person information categories\n * - the keys are the person information datapoints\n * - the values are the values of the datapoints that you stored about this user\n *\n * Example:\n *\n * the file `person-information-values/abraham-lincoln.md` could contain something like this:\n *\n * ```md\n * # life\n * born: 11-01-1777\n * died: 20-12-1812\n *\n * # identification\n * firstName: Abraham\n * lastName: Lincoln\n * ```\n *\n * NB: It's not going to be easy to keep this model in sync with the model it relies on!\n *\n * TODO: figure out if this kan be a `KeyValueMarkdownModelType` or `MarkdownModelType`\n */\nexport interface PersonInformationValue extends DefaultModelType {\n  personId: Id;\n  personInformationSlug: Slug;\n  value: string;\n}"
  },
  "PersonPlatformConnection": {
    "name": "PersonPlatformConnection",
    "slug": "TsInterface",
    "id": "personplatformconnection",
    "description": "Forgive the long name, but this model connects the user with the people they have a connection with on specific platforms\n\ne.g. John Doe is connected with me on LinkedIn with the handle `johndoe123`\n\nNot sure if this is the best way to do this, there may be limitations... For example, both I and the other person can have multiple social media accounts on a single platform",
    "operationName": "peer-types",
    "rawText": "\n\n/**\n * Forgive the long name, but this model connects the user with the people they have a connection with on specific platforms\n *\n * e.g. John Doe is connected with me on LinkedIn with the handle `johndoe123`\n *\n * Not sure if this is the best way to do this, there may be limitations... For example, both I and the other person can have multiple social media accounts on a single platform\n */\nexport interface PersonPlatformConnection extends DefaultModelType {\n  /** which person */\n  personId: Id;\n  person: Person;\n  /** is it a follow, or a connection? */\n  isFollow: boolean;\n  /** when did we last verify and update the connection? */\n  scrapeSucceededAt: number | null;\n  /** when did we last try to scrape but failed? */\n  scrapedFailedAt: number | null;\n  /** on which platform */\n  platformSlug: Slug;\n  /** how can the connection be identified on that platform? */\n  platformConnectionId: string;\n}"
  },
  "PersonSocialMedia": {
    "name": "PersonSocialMedia",
    "slug": "TsInterface",
    "id": "personsocialmedia",
    "description": "media (mediums) that a person uses, e.g. linkedin, twitter, whatsapp, sms, calling, and irl",
    "operationName": "peer-types",
    "rawText": "\n\n/**\n * media (mediums) that a person uses, e.g. linkedin, twitter, whatsapp, sms, calling, and irl\n */\nexport type PersonSocialMedia = {\n  /** medium where the person is a user */\n  platformSlug: Slug;\n  /** used to find the user on the platform */\n  path: string;\n  //  probably not needed\n  // /** if needed an additional, platform specific ID for the User can be stored here, e.g. a message channel ID on LinkedIn */\n  // additionalId?: string;\n  /** (if available) whether or not the user has a premium account */\n  isPremium: boolean;\n  /** (if available) a tagline for the user of the platform */\n  tagline?: string;\n  /** (if available) a bio for the user of the platform */\n  bio?: string;\n};"
  },
  "Platform": {
    "name": "Platform",
    "slug": "TsInterface",
    "id": "platform",
    "description": "Collection of platforms that can be found on the internet\n\ne.g. linkedin would have `userUrlPrefix: https://linkedin.com/in/` and `userUrlSuffix:\"\"`",
    "operationName": "peer-types",
    "rawText": "\n\n/**\n * Collection of platforms that can be found on the internet\n *\n * e.g. linkedin would have `userUrlPrefix: https://linkedin.com/in/` and `userUrlSuffix:\"\"`\n */\nexport interface Platform extends SlugModelType {\n  userUrlPrefix: string;\n  userUrlSuffix: string;\n}"
  },
  "PublicPersonKeys": {
    "name": "PublicPersonKeys",
    "slug": "TsInterface",
    "id": "publicpersonkeys",
    "description": "",
    "operationName": "peer-types",
    "rawText": "\n\nexport type PublicPersonKeys = typeof publicPersonKeys[number];"
  },
  "NamedParameters<typeof getPrimaryPersona>": {
    "name": "NamedParameters<typeof getPrimaryPersona>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getprimarypersona",
    "description": "",
    "operationName": "persona-functions-node"
  },
  "NamedParameters<typeof isPlural>": {
    "name": "NamedParameters<typeof isPlural>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isplural",
    "description": "",
    "operationName": "pluralize"
  },
  "NamedParameters<typeof isSingular>": {
    "name": "NamedParameters<typeof isSingular>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-issingular",
    "description": "",
    "operationName": "pluralize"
  },
  "NamedParameters<typeof pluralize>": {
    "name": "NamedParameters<typeof pluralize>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-pluralize",
    "description": "",
    "operationName": "pluralize"
  },
  "NamedParameters<typeof singularize>": {
    "name": "NamedParameters<typeof singularize>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-singularize",
    "description": "",
    "operationName": "pluralize"
  },
  "NamedParameters<typeof deleteApp>": {
    "name": "NamedParameters<typeof deleteApp>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-deleteapp",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof deleteAppCli>": {
    "name": "NamedParameters<typeof deleteAppCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-deleteappcli",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof listApps>": {
    "name": "NamedParameters<typeof listApps>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-listapps",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof listAppsCli>": {
    "name": "NamedParameters<typeof listAppsCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-listappscli",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof logApp>": {
    "name": "NamedParameters<typeof logApp>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-logapp",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof logTableObject>": {
    "name": "NamedParameters<typeof logTableObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-logtableobject",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof pm2Connect>": {
    "name": "NamedParameters<typeof pm2Connect>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-pm2connect",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof restartApp>": {
    "name": "NamedParameters<typeof restartApp>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-restartapp",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof restartAppCli>": {
    "name": "NamedParameters<typeof restartAppCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-restartappcli",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof startApp>": {
    "name": "NamedParameters<typeof startApp>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-startapp",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof startAppCli>": {
    "name": "NamedParameters<typeof startAppCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-startappcli",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof stopAllAppsExcept>": {
    "name": "NamedParameters<typeof stopAllAppsExcept>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stopallappsexcept",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof stopAllAppsExceptCli>": {
    "name": "NamedParameters<typeof stopAllAppsExceptCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stopallappsexceptcli",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof stopApps>": {
    "name": "NamedParameters<typeof stopApps>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stopapps",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof stopAppsCli>": {
    "name": "NamedParameters<typeof stopAppsCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stopappscli",
    "description": "",
    "operationName": "pm2-util"
  },
  "NamedParameters<typeof ContextualPromptResultsTab>": {
    "name": "NamedParameters<typeof ContextualPromptResultsTab>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-contextualpromptresultstab",
    "description": "",
    "operationName": "prompt-components"
  },
  "NamedParameters<typeof FilePromptSelect>": {
    "name": "NamedParameters<typeof FilePromptSelect>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-filepromptselect",
    "description": "",
    "operationName": "prompt-components"
  },
  "Browser": {
    "name": "Browser",
    "slug": "TsInterface",
    "id": "browser",
    "description": "A Browser is created when Puppeteer connects to a Chromium instance, either through\n{@link  PuppeteerNode.launch }  or  {@link  Puppeteer.connect } .",
    "operationName": "puppeteer-utils"
  },
  "FacebookLoginPropsType": {
    "name": "FacebookLoginPropsType",
    "slug": "TsInterface",
    "id": "facebookloginpropstype",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": "\n\nexport type FacebookLoginPropsType = {\n  email: string;\n  password: string;\n  page: Page;\n};"
  },
  "GmailLoginPropsType": {
    "name": "GmailLoginPropsType",
    "slug": "TsInterface",
    "id": "gmailloginpropstype",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": "\n\nexport type GmailLoginPropsType = {\n  email: string;\n  password: string;\n  page: Page;\n};"
  },
  "NamedParameters<typeof getChromeExecutablePath>": {
    "name": "NamedParameters<typeof getChromeExecutablePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getchromeexecutablepath",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof clickOnSpanTag>": {
    "name": "NamedParameters<typeof clickOnSpanTag>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-clickonspantag",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof delay>": {
    "name": "NamedParameters<typeof delay>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-delay",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof facebookLogin>": {
    "name": "NamedParameters<typeof facebookLogin>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-facebooklogin",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof foundOrNot>": {
    "name": "NamedParameters<typeof foundOrNot>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-foundornot",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof foundOrNotXpath>": {
    "name": "NamedParameters<typeof foundOrNotXpath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-foundornotxpath",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof getBrowser>": {
    "name": "NamedParameters<typeof getBrowser>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getbrowser",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof getBrowserPageById>": {
    "name": "NamedParameters<typeof getBrowserPageById>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getbrowserpagebyid",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof getBrowserTabs>": {
    "name": "NamedParameters<typeof getBrowserTabs>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getbrowsertabs",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof getConnectedBrowsers>": {
    "name": "NamedParameters<typeof getConnectedBrowsers>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getconnectedbrowsers",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof getIdlePage>": {
    "name": "NamedParameters<typeof getIdlePage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getidlepage",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof getNewPage>": {
    "name": "NamedParameters<typeof getNewPage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getnewpage",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof gmailLogin>": {
    "name": "NamedParameters<typeof gmailLogin>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gmaillogin",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof isCaptchaExist>": {
    "name": "NamedParameters<typeof isCaptchaExist>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-iscaptchaexist",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof logConsoleIfDebug>": {
    "name": "NamedParameters<typeof logConsoleIfDebug>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-logconsoleifdebug",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof openMultiTabs>": {
    "name": "NamedParameters<typeof openMultiTabs>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-openmultitabs",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof openNewBrowser>": {
    "name": "NamedParameters<typeof openNewBrowser>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-opennewbrowser",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof openNewBrowserOnChildProcess>": {
    "name": "NamedParameters<typeof openNewBrowserOnChildProcess>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-opennewbrowseronchildprocess",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof openPage>": {
    "name": "NamedParameters<typeof openPage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-openpage",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof racePromises>": {
    "name": "NamedParameters<typeof racePromises>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-racepromises",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof retryClickAndWaitSelector>": {
    "name": "NamedParameters<typeof retryClickAndWaitSelector>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-retryclickandwaitselector",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof retryWaitSelector>": {
    "name": "NamedParameters<typeof retryWaitSelector>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-retrywaitselector",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof runBrowser>": {
    "name": "NamedParameters<typeof runBrowser>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-runbrowser",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof setBrowserPageIdle>": {
    "name": "NamedParameters<typeof setBrowserPageIdle>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-setbrowserpageidle",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof setBrowserSession>": {
    "name": "NamedParameters<typeof setBrowserSession>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-setbrowsersession",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof setInnerHtml>": {
    "name": "NamedParameters<typeof setInnerHtml>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-setinnerhtml",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof solveReptcha>": {
    "name": "NamedParameters<typeof solveReptcha>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-solvereptcha",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof trueClick>": {
    "name": "NamedParameters<typeof trueClick>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-trueclick",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof twitterLogin>": {
    "name": "NamedParameters<typeof twitterLogin>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-twitterlogin",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof typeInTheInputField>": {
    "name": "NamedParameters<typeof typeInTheInputField>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-typeintheinputfield",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof typeOnTheTargetWithXpathSelector>": {
    "name": "NamedParameters<typeof typeOnTheTargetWithXpathSelector>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-typeonthetargetwithxpathselector",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NamedParameters<typeof waitMilliseconds>": {
    "name": "NamedParameters<typeof waitMilliseconds>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-waitmilliseconds",
    "description": "",
    "operationName": "puppeteer-utils"
  },
  "NewPageProps": {
    "name": "NewPageProps",
    "slug": "TsInterface",
    "id": "newpageprops",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": "\n\nexport type NewPageProps = {\n    pageId?: string;\n};"
  },
  "OpenMultiTabProps": {
    "name": "OpenMultiTabProps",
    "slug": "TsInterface",
    "id": "openmultitabprops",
    "description": "",
    "operationName": "puppeteer-utils",
    "rawText": "\n\nexport type OpenMultiTabProps = {\n  noOfTabs: number;\n  tabUrl: string;\n  browser: Browser;\n};"
  },
  "Queue": {
    "name": "Queue",
    "slug": "TsInterface",
    "id": "queue",
    "description": "Model for a Queue system so you can execute functions when ram/internet is available",
    "operationName": "queue-types",
    "rawText": "\n/**\nModel for a Queue system so you can execute functions when ram/internet is available\n*/\nexport interface Queue extends DefaultModelType {\n  functionName: string;\n  parameters: any[];\n  /**\n   * JSON result of the function\n   */\n  result?: any;\n\n  /**\n   * Will be set after the function starts\n   */\n  startedAt?: number;\n\n  /**\n   * If true, queue item will be kept on completion\n   */\n  shouldKeepOnCompleted?: boolean;\n\n  /**\n   * Will be set (if `.shouldKeepOnCompleted: true`.)\n   */\n  completedAt?: number;\n\n  /**\n   * Can be set to show the status of the function to the user, for example, with a conversion, a percentage indicator for completeness\n   */\n  statusMessage?: string;\n\n  /**\n   * if set to high, will go before others\n   */\n  priority?: \"high\";\n\n  /**\n   * notify via email, for now, after n seconds, if the queue item has not been executed before that.\n   */\n  notifyLateAfterSeconds?: number;\n\n  hasNotifiedLate?: boolean;\n  /**\n   * notify via email, for now\n   */\n  shouldNotifyOnResult?: boolean;\n  /**\n   * device authToken of who executed this\n   * not necesarily a `Person` yet, because it may be done unauthenticated.\n   *\n   * IDK what happens if you don't provide this!\n   */\n  executionAuthToken?: string;\n}"
  },
  "NamedParameters<typeof getTailwindModules>": {
    "name": "NamedParameters<typeof getTailwindModules>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettailwindmodules",
    "description": "",
    "operationName": "react-with-native"
  },
  "NamedParameters<typeof joinClassNames>": {
    "name": "NamedParameters<typeof joinClassNames>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-joinclassnames",
    "description": "",
    "operationName": "react-with-native"
  },
  "NamedParameters<typeof Svg>": {
    "name": "NamedParameters<typeof Svg>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-svg",
    "description": "",
    "operationName": "react-with-native"
  },
  "NamedParameters<typeof trimClassName>": {
    "name": "NamedParameters<typeof trimClassName>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-trimclassname",
    "description": "",
    "operationName": "react-with-native"
  },
  "NamedParameters<typeof wrapInTextIfNeeded>": {
    "name": "NamedParameters<typeof wrapInTextIfNeeded>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-wrapintextifneeded",
    "description": "",
    "operationName": "react-with-native"
  },
  "SvgType": {
    "name": "SvgType",
    "slug": "TsInterface",
    "id": "svgtype",
    "description": "",
    "operationName": "react-with-native",
    "rawText": "export type SvgType = {\n  src: any;\n  width?: number;\n  height?: number;\n  className?: string;\n  style?: any;\n};"
  },
  "NamedParameters<typeof AlertProvider>": {
    "name": "NamedParameters<typeof AlertProvider>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-alertprovider",
    "description": "",
    "operationName": "react-with-native-alert"
  },
  "NamedParameters<typeof useAlert>": {
    "name": "NamedParameters<typeof useAlert>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usealert",
    "description": "",
    "operationName": "react-with-native-alert"
  },
  "MapLocation": {
    "name": "MapLocation",
    "slug": "TsInterface",
    "id": "maplocation",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": "\n\nexport type MapLocation = {\n  latitude: number;\n  longitude: number;\n  zoom: number;\n};"
  },
  "PluginInputType": {
    "name": "PluginInputType",
    "slug": "TsInterface",
    "id": "plugininputtype",
    "description": "",
    "operationName": "react-with-native-form-inputs"
  },
  "Suggestion": {
    "name": "Suggestion",
    "slug": "TsInterface",
    "id": "suggestion",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": "\n\nexport type Suggestion = {\n  bbox: number[];\n  center: [number, number];\n  id: string;\n  place_name: string;\n  place_type: string[];\n  text: string;\n};"
  },
  "ViewPort": {
    "name": "ViewPort",
    "slug": "TsInterface",
    "id": "viewport",
    "description": "",
    "operationName": "react-with-native-form-inputs",
    "rawText": "\n\nexport type ViewPort = MapLocation & {\n  width: string | number;\n  height: string | number;\n};"
  },
  "NamedParameters<typeof Modal>": {
    "name": "NamedParameters<typeof Modal>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-modal",
    "description": "",
    "operationName": "react-with-native-modal"
  },
  "NamedParameters<typeof ModalProvider>": {
    "name": "NamedParameters<typeof ModalProvider>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-modalprovider",
    "description": "",
    "operationName": "react-with-native-modal"
  },
  "NamedParameters<typeof useModal>": {
    "name": "NamedParameters<typeof useModal>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usemodal",
    "description": "",
    "operationName": "react-with-native-modal"
  },
  "NamedParameters<typeof useModalState>": {
    "name": "NamedParameters<typeof useModalState>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usemodalstate",
    "description": "",
    "operationName": "react-with-native-modal"
  },
  "NamedParameters<typeof useNavigation>": {
    "name": "NamedParameters<typeof useNavigation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usenavigation",
    "description": "",
    "operationName": "react-with-native-router"
  },
  "NamedParameters<typeof useRouter>": {
    "name": "NamedParameters<typeof useRouter>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-userouter",
    "description": "",
    "operationName": "react-with-native-router"
  },
  "ID": {
    "name": "ID",
    "slug": "TsInterface",
    "id": "id",
    "description": "",
    "operationName": "react-with-native-select",
    "rawText": "\n\nexport type ID = string | number | undefined;"
  },
  "NamedParameters<typeof getItem>": {
    "name": "NamedParameters<typeof getItem>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getitem",
    "description": "",
    "operationName": "react-with-native-store"
  },
  "NamedParameters<typeof getItemSync>": {
    "name": "NamedParameters<typeof getItemSync>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getitemsync",
    "description": "",
    "operationName": "react-with-native-store"
  },
  "NamedParameters<typeof setItem>": {
    "name": "NamedParameters<typeof setItem>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-setitem",
    "description": "",
    "operationName": "react-with-native-store"
  },
  "NamedParameters<typeof readCsvFile>": {
    "name": "NamedParameters<typeof readCsvFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readcsvfile",
    "description": "",
    "operationName": "read-csv-file"
  },
  "NamedParameters<typeof readCsvFileSync>": {
    "name": "NamedParameters<typeof readCsvFileSync>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readcsvfilesync",
    "description": "",
    "operationName": "read-csv-file"
  },
  "NamedParameters<typeof readJsonFile>": {
    "name": "NamedParameters<typeof readJsonFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readjsonfile",
    "description": "",
    "operationName": "read-json-file"
  },
  "NamedParameters<typeof readJsonFileSync>": {
    "name": "NamedParameters<typeof readJsonFileSync>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readjsonfilesync",
    "description": "",
    "operationName": "read-json-file"
  },
  "NamedParameters<typeof readProjectRelativeJsonFile>": {
    "name": "NamedParameters<typeof readProjectRelativeJsonFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readprojectrelativejsonfile",
    "description": "",
    "operationName": "read-json-file"
  },
  "NamedParameters<typeof readKvmdFile>": {
    "name": "NamedParameters<typeof readKvmdFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readkvmdfile",
    "description": "",
    "operationName": "read-kvmd-file"
  },
  "NamedParameters<typeof readMarkdownFile>": {
    "name": "NamedParameters<typeof readMarkdownFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readmarkdownfile",
    "description": "",
    "operationName": "read-markdown-file"
  },
  "NamedParameters<typeof readMarkdownFileToModel>": {
    "name": "NamedParameters<typeof readMarkdownFileToModel>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readmarkdownfiletomodel",
    "description": "",
    "operationName": "read-markdown-file"
  },
  "IndexFilter": {
    "name": "IndexFilter",
    "slug": "TsInterface",
    "id": "indexfilter",
    "description": "",
    "operationName": "read-typescript-file",
    "rawText": "\n\nexport type IndexFilter = {\n  /**\n   * if set, only returns comments containing specific types\n   */\n  hasCommentTypes?: CommentType[];\n  /**\n   * if true, only returns interfaces which are db models\n   */\n  interfaceIsDbModel?: boolean;\n};"
  },
  "NamedParameters<typeof getFolderTypescriptIndex>": {
    "name": "NamedParameters<typeof getFolderTypescriptIndex>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfoldertypescriptindex",
    "description": "",
    "operationName": "read-typescript-file"
  },
  "NamedParameters<typeof getOperationIndexModel>": {
    "name": "NamedParameters<typeof getOperationIndexModel>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getoperationindexmodel",
    "description": "",
    "operationName": "read-typescript-file"
  },
  "NamedParameters<typeof readTypescriptFile>": {
    "name": "NamedParameters<typeof readTypescriptFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readtypescriptfile",
    "description": "",
    "operationName": "read-typescript-file"
  },
  "NamedParameters<typeof uniqueNames>": {
    "name": "NamedParameters<typeof uniqueNames>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-uniquenames",
    "description": "",
    "operationName": "read-typescript-file"
  },
  "FilePage": {
    "name": "FilePage",
    "slug": "TsInterface",
    "id": "filepage",
    "description": "",
    "operationName": "webpage-types",
    "rawText": "\n\nexport type FilePage = {\n  projectRelativeFilePath: string;\n  internalLinkWord?: string | null;\n  imagePath?: string | null;\n  /**\n   * One line description of the content\n   */\n  shortDescription?: string | null;\n  /**\n   * Intor, usually the first alinea of the page, may contain markdown\n   */\n  introDescription?: string;\n};"
  },
  "NamedParameters<typeof AugmentedWordComponent>": {
    "name": "NamedParameters<typeof AugmentedWordComponent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-augmentedwordcomponent",
    "description": "",
    "operationName": "reader-ui"
  },
  "NamedParameters<typeof Dictionary>": {
    "name": "NamedParameters<typeof Dictionary>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-dictionary",
    "description": "",
    "operationName": "reader-ui"
  },
  "NamedParameters<typeof DocsReaderLayout>": {
    "name": "NamedParameters<typeof DocsReaderLayout>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-docsreaderlayout",
    "description": "",
    "operationName": "reader-ui"
  },
  "NamedParameters<typeof Layout>": {
    "name": "NamedParameters<typeof Layout>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-layout",
    "description": "",
    "operationName": "reader-ui"
  },
  "NamedParameters<typeof ReaderPageContent>": {
    "name": "NamedParameters<typeof ReaderPageContent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readerpagecontent",
    "description": "",
    "operationName": "reader-ui"
  },
  "NamedParameters<typeof ReaderPageHeader>": {
    "name": "NamedParameters<typeof ReaderPageHeader>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-readerpageheader",
    "description": "",
    "operationName": "reader-ui"
  },
  "NamedParameters<typeof clearTsDatabase>": {
    "name": "NamedParameters<typeof clearTsDatabase>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-cleartsdatabase",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof executeCommandQuietUnlessFail>": {
    "name": "NamedParameters<typeof executeCommandQuietUnlessFail>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-executecommandquietunlessfail",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof exitIfProcessDependenciesChanged>": {
    "name": "NamedParameters<typeof exitIfProcessDependenciesChanged>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-exitifprocessdependencieschanged",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof generateJsonSchemas>": {
    "name": "NamedParameters<typeof generateJsonSchemas>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generatejsonschemas",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof getAllDbModels>": {
    "name": "NamedParameters<typeof getAllDbModels>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getalldbmodels",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof getFileIds>": {
    "name": "NamedParameters<typeof getFileIds>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfileids",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof getIndexFileIds>": {
    "name": "NamedParameters<typeof getIndexFileIds>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getindexfileids",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof getSrcIds>": {
    "name": "NamedParameters<typeof getSrcIds>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsrcids",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof isOperationBuildNeeded>": {
    "name": "NamedParameters<typeof isOperationBuildNeeded>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isoperationbuildneeded",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof isSdkOperation>": {
    "name": "NamedParameters<typeof isSdkOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-issdkoperation",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof rebuildAllOperations>": {
    "name": "NamedParameters<typeof rebuildAllOperations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rebuildalloperations",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof rebuildOperation>": {
    "name": "NamedParameters<typeof rebuildOperation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rebuildoperation",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof rebuildOperationCli>": {
    "name": "NamedParameters<typeof rebuildOperationCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-rebuildoperationcli",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof shouldSkip>": {
    "name": "NamedParameters<typeof shouldSkip>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-shouldskip",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof yarnBuild>": {
    "name": "NamedParameters<typeof yarnBuild>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-yarnbuild",
    "description": "",
    "operationName": "rebuild-operation"
  },
  "NamedParameters<typeof getMenuPagesObject>": {
    "name": "NamedParameters<typeof getMenuPagesObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmenupagesobject",
    "description": "",
    "operationName": "recursive-util"
  },
  "NamedParameters<typeof queryPathsArrayToNestedPathObject>": {
    "name": "NamedParameters<typeof queryPathsArrayToNestedPathObject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-querypathsarraytonestedpathobject",
    "description": "",
    "operationName": "recursive-util"
  },
  "NamedParameters<typeof reduceQueryPathsRecursively>": {
    "name": "NamedParameters<typeof reduceQueryPathsRecursively>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-reducequerypathsrecursively",
    "description": "",
    "operationName": "recursive-util"
  },
  "NestedPathObject": {
    "name": "NestedPathObject",
    "slug": "TsInterface",
    "id": "nestedpathobject",
    "description": "A different way to represent a path array in a nested object of folders\n\n{  \"folderName\": {    \"file1\": null,    \"file2\": null  },  \"folderName2\": {    \"file1\": null,    \"file2\": null  } }",
    "operationName": "recursive-util"
  },
  "NamedParameters<typeof findTemplates>": {
    "name": "NamedParameters<typeof findTemplates>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findtemplates",
    "description": "",
    "operationName": "rename-template-files"
  },
  "NamedParameters<typeof isEqualArray>": {
    "name": "NamedParameters<typeof isEqualArray>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isequalarray",
    "description": "",
    "operationName": "rename-template-files"
  },
  "NamedParameters<typeof renameTemplateFiles>": {
    "name": "NamedParameters<typeof renameTemplateFiles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-renametemplatefiles",
    "description": "",
    "operationName": "rename-template-files"
  },
  "NamedParameters<typeof renameTemplateToNormalFile>": {
    "name": "NamedParameters<typeof renameTemplateToNormalFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-renametemplatetonormalfile",
    "description": "",
    "operationName": "rename-template-files"
  },
  "NamedParameters<typeof renameToTemplateFile>": {
    "name": "NamedParameters<typeof renameToTemplateFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-renametotemplatefile",
    "description": "",
    "operationName": "rename-template-files"
  },
  "NamedParameters<typeof bodyFromQueryString>": {
    "name": "NamedParameters<typeof bodyFromQueryString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-bodyfromquerystring",
    "description": "",
    "operationName": "rest-util"
  },
  "NamedParameters<typeof getFirstQueryStrings>": {
    "name": "NamedParameters<typeof getFirstQueryStrings>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfirstquerystrings",
    "description": "",
    "operationName": "rest-util"
  },
  "NamedParameters<typeof getQueryPart>": {
    "name": "NamedParameters<typeof getQueryPart>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getquerypart",
    "description": "",
    "operationName": "rest-util"
  },
  "NamedParameters<typeof isValidEntry>": {
    "name": "NamedParameters<typeof isValidEntry>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isvalidentry",
    "description": "",
    "operationName": "rest-util"
  },
  "NamedParameters<typeof toQueryString>": {
    "name": "NamedParameters<typeof toQueryString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-toquerystring",
    "description": "",
    "operationName": "rest-util"
  },
  "QueryableObject": {
    "name": "QueryableObject",
    "slug": "TsInterface",
    "id": "queryableobject",
    "description": "",
    "operationName": "rest-util",
    "rawText": "export type QueryableObject = { [key: string]: string | string[] | undefined };"
  },
  "NamedParameters<typeof runChildProcess>": {
    "name": "NamedParameters<typeof runChildProcess>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-runchildprocess",
    "description": "",
    "operationName": "run-child-process"
  },
  "NamedParameters<typeof sayDutch>": {
    "name": "NamedParameters<typeof sayDutch>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-saydutch",
    "description": "",
    "operationName": "say"
  },
  "NamedParameters<typeof sayLanguage>": {
    "name": "NamedParameters<typeof sayLanguage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-saylanguage",
    "description": "",
    "operationName": "say"
  },
  "NamedParameters<typeof sayNepali>": {
    "name": "NamedParameters<typeof sayNepali>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-saynepali",
    "description": "",
    "operationName": "say"
  },
  "NamedParameters<typeof saySomething>": {
    "name": "NamedParameters<typeof saySomething>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-saysomething",
    "description": "",
    "operationName": "say"
  },
  "NamedParameters<typeof textToMp3>": {
    "name": "NamedParameters<typeof textToMp3>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-texttomp3",
    "description": "",
    "operationName": "say"
  },
  "SayLanguageEnum": {
    "name": "SayLanguageEnum",
    "slug": "TsInterface",
    "id": "saylanguageenum",
    "description": "",
    "operationName": "say",
    "rawText": "\n\nexport type SayLanguageEnum = \"np\" | \"nl\" | \"en\";"
  },
  "SayOptions": {
    "name": "SayOptions",
    "slug": "TsInterface",
    "id": "sayoptions",
    "description": "",
    "operationName": "say",
    "rawText": "\nexport type SayOptions = {\n  /**\n   * Specify an absolute path to a file with some text\n   */\n  filePath?: string;\n  /**\n   * message string to be said\n   */\n  message?: string;\n  speechRate?: number;\n  voice?: string;\n  outputFilePath?: string;\n  audioDevice?: string;\n  showProgress?: boolean;\n  interactive?: string;\n  fileFormat?: string;\n  dataFormat?: string;\n  bitRate?: number;\n  quality?: number;\n};"
  },
  "JSONSchema7Definition": {
    "name": "JSONSchema7Definition",
    "slug": "TsInterface",
    "id": "jsonschema7definition",
    "description": "JSON Schema v7",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof findFirstCommentTypes>": {
    "name": "NamedParameters<typeof findFirstCommentTypes>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findfirstcommenttypes",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof getDataParameterNames>": {
    "name": "NamedParameters<typeof getDataParameterNames>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getdataparameternames",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof getPossibleReferenceParameterNames>": {
    "name": "NamedParameters<typeof getPossibleReferenceParameterNames>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpossiblereferenceparameternames",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof getProperties>": {
    "name": "NamedParameters<typeof getProperties>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getproperties",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof getReferencableModels>": {
    "name": "NamedParameters<typeof getReferencableModels>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getreferencablemodels",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof getReferenceParameterInfo>": {
    "name": "NamedParameters<typeof getReferenceParameterInfo>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getreferenceparameterinfo",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof getRefLink>": {
    "name": "NamedParameters<typeof getRefLink>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getreflink",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof getSchema>": {
    "name": "NamedParameters<typeof getSchema>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getschema",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof getSchemaItems>": {
    "name": "NamedParameters<typeof getSchemaItems>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getschemaitems",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof simplifiedSchemaToTypeDefinitionString>": {
    "name": "NamedParameters<typeof simplifiedSchemaToTypeDefinitionString>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-simplifiedschematotypedefinitionstring",
    "description": "",
    "operationName": "schema-util"
  },
  "NamedParameters<typeof simplifySchema>": {
    "name": "NamedParameters<typeof simplifySchema>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-simplifyschema",
    "description": "",
    "operationName": "schema-util"
  },
  "ReferenceParameterInfo": {
    "name": "ReferenceParameterInfo",
    "slug": "TsInterface",
    "id": "referenceparameterinfo",
    "description": "",
    "operationName": "simplified-schema-form"
  },
  "SchemaItem": {
    "name": "SchemaItem",
    "slug": "TsInterface",
    "id": "schemaitem",
    "description": "",
    "operationName": "schema-util",
    "rawText": "\n\nexport type SchemaItem = {\n  /**\n   * name in case of it being a reference, otherwise null\n   */\n  name: string | null;\n  schema: Schema;\n};"
  },
  "NamedParameters<typeof addAuthenticationMethod>": {
    "name": "NamedParameters<typeof addAuthenticationMethod>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-addauthenticationmethod",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof addDeviceAuthenticationMethodConfirm>": {
    "name": "NamedParameters<typeof addDeviceAuthenticationMethodConfirm>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-adddeviceauthenticationmethodconfirm",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof addDeviceAuthenticationMethodWithContext>": {
    "name": "NamedParameters<typeof addDeviceAuthenticationMethodWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-adddeviceauthenticationmethodwithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof addPersonAuthenticationMethodWithContext>": {
    "name": "NamedParameters<typeof addPersonAuthenticationMethodWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-addpersonauthenticationmethodwithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof findAuthenticatedPersonWithHandle>": {
    "name": "NamedParameters<typeof findAuthenticatedPersonWithHandle>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findauthenticatedpersonwithhandle",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof findLoggedinPersonsWithContext>": {
    "name": "NamedParameters<typeof findLoggedinPersonsWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findloggedinpersonswithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof getMeWithContext>": {
    "name": "NamedParameters<typeof getMeWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getmewithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof getPublicPerson>": {
    "name": "NamedParameters<typeof getPublicPerson>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpublicperson",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof getPublicPersons>": {
    "name": "NamedParameters<typeof getPublicPersons>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getpublicpersons",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof isPhoneNumber>": {
    "name": "NamedParameters<typeof isPhoneNumber>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isphonenumber",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof isValidPassword>": {
    "name": "NamedParameters<typeof isValidPassword>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isvalidpassword",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof loginWithContext>": {
    "name": "NamedParameters<typeof loginWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-loginwithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof loginWithPasswordWithContext>": {
    "name": "NamedParameters<typeof loginWithPasswordWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-loginwithpasswordwithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof logoutWithContext>": {
    "name": "NamedParameters<typeof logoutWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-logoutwithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof removeDeviceAuthenticationMethodWithContext>": {
    "name": "NamedParameters<typeof removeDeviceAuthenticationMethodWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removedeviceauthenticationmethodwithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof removePersonAuthenticationMethodWithContext>": {
    "name": "NamedParameters<typeof removePersonAuthenticationMethodWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-removepersonauthenticationmethodwithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof signupWithContext>": {
    "name": "NamedParameters<typeof signupWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-signupwithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof signupWithPasswordWithContext>": {
    "name": "NamedParameters<typeof signupWithPasswordWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-signupwithpasswordwithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof switchCurrentPersonWithContext>": {
    "name": "NamedParameters<typeof switchCurrentPersonWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-switchcurrentpersonwithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "NamedParameters<typeof updateMeWithContext>": {
    "name": "NamedParameters<typeof updateMeWithContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-updatemewithcontext",
    "description": "",
    "operationName": "server-login"
  },
  "SignupPersonData": {
    "name": "SignupPersonData",
    "slug": "TsInterface",
    "id": "signuppersondata",
    "description": "",
    "operationName": "server-login",
    "rawText": "\n\nexport type SignupPersonData = Pick<\n  Person,\n  | \"credit\"\n  | \"dataEntries\"\n  | \"interestSlugs\"\n  | \"media\"\n  | \"name\"\n  | \"slug\"\n  | \"pictureImage\"\n  | \"groupSlugs\"\n>;"
  },
  "NamedParameters<typeof setJsonKey>": {
    "name": "NamedParameters<typeof setJsonKey>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-setjsonkey",
    "description": "",
    "operationName": "set-json-key"
  },
  "NamedParameters<typeof setKeyAtLocation>": {
    "name": "NamedParameters<typeof setKeyAtLocation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-setkeyatlocation",
    "description": "",
    "operationName": "set-json-key"
  },
  "NamedParameters<typeof Share>": {
    "name": "NamedParameters<typeof Share>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-share",
    "description": "",
    "operationName": "share"
  },
  "NamedParameters<typeof useAllText>": {
    "name": "NamedParameters<typeof useAllText>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usealltext",
    "description": "",
    "operationName": "share"
  },
  "NamedParameters<typeof useLastSelection>": {
    "name": "NamedParameters<typeof useLastSelection>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-uselastselection",
    "description": "",
    "operationName": "share"
  },
  "NamedParameters<typeof useProjectRelativeScreenshot>": {
    "name": "NamedParameters<typeof useProjectRelativeScreenshot>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-useprojectrelativescreenshot",
    "description": "",
    "operationName": "share"
  },
  "NamedParameters<typeof useScreenshot>": {
    "name": "NamedParameters<typeof useScreenshot>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usescreenshot",
    "description": "",
    "operationName": "share"
  },
  "NamedParameters<typeof findAudioWithViewsArray>": {
    "name": "NamedParameters<typeof findAudioWithViewsArray>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-findaudiowithviewsarray",
    "description": "",
    "operationName": "short-markdown-parser-js"
  },
  "NamedParameters<typeof markdownParseToShortMarkdown>": {
    "name": "NamedParameters<typeof markdownParseToShortMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownparsetoshortmarkdown",
    "description": "",
    "operationName": "short-markdown-parser-js"
  },
  "NamedParameters<typeof shortMarkdownToMarkdownParse>": {
    "name": "NamedParameters<typeof shortMarkdownToMarkdownParse>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-shortmarkdowntomarkdownparse",
    "description": "",
    "operationName": "short-markdown-parser-js"
  },
  "AudioWithViews": {
    "name": "AudioWithViews",
    "slug": "TsInterface",
    "id": "audiowithviews",
    "description": "",
    "operationName": "short-markdown-types",
    "rawText": "export type AudioWithViews = {\n  audioPath: string | null;\n  /**\n   * Unique key for the audio\n   */\n  audioKey?: string;\n  audioDurationMs?: number;\n  viewEmbeds: ViewEmbed[];\n};"
  },
  "DialogueSentence": {
    "name": "DialogueSentence",
    "slug": "TsInterface",
    "id": "dialoguesentence",
    "description": "",
    "operationName": "short-markdown-parser-node",
    "rawText": "export type DialogueSentence = {\n  remotePath?: string;\n  uuid?: string;\n  voice?: string;\n  sentence: string;\n};"
  },
  "NamedParameters<typeof augmentShortMarkdown>": {
    "name": "NamedParameters<typeof augmentShortMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-augmentshortmarkdown",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "NamedParameters<typeof fetchVoices>": {
    "name": "NamedParameters<typeof fetchVoices>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fetchvoices",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "NamedParameters<typeof fetchVoicesTest>": {
    "name": "NamedParameters<typeof fetchVoicesTest>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-fetchvoicestest",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "NamedParameters<typeof generateAugmentedShortMarkdown>": {
    "name": "NamedParameters<typeof generateAugmentedShortMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateaugmentedshortmarkdown",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "NamedParameters<typeof generateAugmentedShortMarkdownTest>": {
    "name": "NamedParameters<typeof generateAugmentedShortMarkdownTest>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-generateaugmentedshortmarkdowntest",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "NamedParameters<typeof getOrGenerateShortMarkdown>": {
    "name": "NamedParameters<typeof getOrGenerateShortMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getorgenerateshortmarkdown",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "NamedParameters<typeof parseDialogue>": {
    "name": "NamedParameters<typeof parseDialogue>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parsedialogue",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "NamedParameters<typeof uberduckGetPath>": {
    "name": "NamedParameters<typeof uberduckGetPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-uberduckgetpath",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "NamedParameters<typeof uberduckSpeak>": {
    "name": "NamedParameters<typeof uberduckSpeak>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-uberduckspeak",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "NamedParameters<typeof voiceCloneDialogue>": {
    "name": "NamedParameters<typeof voiceCloneDialogue>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-voiceclonedialogue",
    "description": "",
    "operationName": "short-markdown-parser-node"
  },
  "ShortMarkdown": {
    "name": "ShortMarkdown",
    "slug": "TsInterface",
    "id": "shortmarkdown",
    "description": "",
    "operationName": "short-markdown-writer-input"
  },
  "AudioTrackItem": {
    "name": "AudioTrackItem",
    "slug": "TsInterface",
    "id": "audiotrackitem",
    "description": "",
    "operationName": "short-markdown-types",
    "rawText": "\n\n/**\n *\n */\nexport type AudioTrackItem = {\n  relativeAudioFilePath: string;\n  durationMs?: number;\n  startMs?: number;\n};"
  },
  "ViewEmbed": {
    "name": "ViewEmbed",
    "slug": "TsInterface",
    "id": "viewembed",
    "description": "",
    "operationName": "short-markdown-types",
    "rawText": "\n\nexport type ViewEmbed = {\n  /**\n   * Unique key for the belonging audio, used to find the desired audio\n   */\n  audioKey?: string;\n  /**\n   * Either viewPath or title is required\n   */\n  title?: string;\n  /**\n   * Either viewPath or title is required\n   */\n  viewPath?: string;\n\n  /**\n   * Text in the alt of the image or video, but only if the alt is wrapped in quotes (e.g. \"your spoken text\"). Can be parsed into an audio and subtitles, and also a duration.\n   */\n  spokenText?: string;\n  /**\n   * Added afterwards\n   */\n  durationMs?: number;\n};"
  },
  "NamedParameters<typeof ShortMarkdownPlayer>": {
    "name": "NamedParameters<typeof ShortMarkdownPlayer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-shortmarkdownplayer",
    "description": "",
    "operationName": "short-markdown-writer-input"
  },
  "NamedParameters<typeof useMultiAudio>": {
    "name": "NamedParameters<typeof useMultiAudio>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usemultiaudio",
    "description": "",
    "operationName": "short-markdown-writer-input"
  },
  "NamedParameters<typeof getReferencedModelDataItem>": {
    "name": "NamedParameters<typeof getReferencedModelDataItem>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getreferencedmodeldataitem",
    "description": "",
    "operationName": "simplified-schema-form"
  },
  "NamedParameters<typeof useReferencableModelData>": {
    "name": "NamedParameters<typeof useReferencableModelData>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usereferencablemodeldata",
    "description": "",
    "operationName": "simplified-schema-form"
  },
  "ReferencedModelDataItem": {
    "name": "ReferencedModelDataItem",
    "slug": "TsInterface",
    "id": "referencedmodeldataitem",
    "description": "",
    "operationName": "simplified-schema-form",
    "rawText": "\nexport type ReferencedModelDataItem = ReferenceParameterInfo &\n  ReferenceItemsObject;"
  },
  "ReferenceItem": {
    "name": "ReferenceItem",
    "slug": "TsInterface",
    "id": "referenceitem",
    "description": "",
    "operationName": "simplified-schema-form",
    "rawText": "\n\nexport type ReferenceItem = {\n  id: string;\n  slug?: string;\n  name?: string;\n  categoryStack?: CategoryStack;\n};"
  },
  "ReferenceItemsObject": {
    "name": "ReferenceItemsObject",
    "slug": "TsInterface",
    "id": "referenceitemsobject",
    "description": "",
    "operationName": "simplified-schema-form",
    "rawText": "\n\nexport type ReferenceItemsObject = {\n  data?: ReferenceItem[];\n  isLoading?: boolean;\n};"
  },
  "NamedParameters<typeof sendDailyAlarmSms>": {
    "name": "NamedParameters<typeof sendDailyAlarmSms>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-senddailyalarmsms",
    "description": "",
    "operationName": "sms"
  },
  "NamedParameters<typeof sendSms>": {
    "name": "NamedParameters<typeof sendSms>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-sendsms",
    "description": "",
    "operationName": "sms"
  },
  "MediaChannel": {
    "name": "MediaChannel",
    "slug": "TsInterface",
    "id": "mediachannel",
    "description": "channel where messages can be posted to\n\nexamples:\n- facebook group\n- slack channel\n- whatsapp pm\n- facebook pm",
    "operationName": "social-media-types",
    "rawText": "\n/** channel where messages can be posted to\n *\n * examples:\n * - facebook group\n * - slack channel\n * - whatsapp pm\n * - facebook pm\n */\nexport interface MediaChannel extends DefaultModelType {\n  platformSlug: Slug;\n  /**\n   * way to identify the channel on the platform\n   *\n   * e.g. on slack we can say `xyz/meet` for the `#meet` channel on the `xyz` slack\n   */\n  platformChannelId: string;\n  url?: string;\n  name: string;\n  slug: string;\n  description?: string;\n\n  /**\n   * Person this channel is connected to\n   *\n   * Can be indexed once the `MediaChannel` is found, and it seems to be a person. Then the person neds to be created as well and the `.personId` needs to be attached to the `MediaChannel`\n   */\n  personId?: Id;\n\n  // person?:Person;\n\n  /** if true, this channel is a group */\n  isGroup?: boolean;\n\n  /**\n   * Ids that each identify a `Person` that is part of this channel. Isn't always available\n   */\n  member_personIds?: Id[];\n\n  /**\n   * The below parameters should ONLY be used if the instance is a channel for a group.\n   * if this is a channel for a person, the interests should be stored on the person instead.\n   */\n\n  /** group-only: interests this group has */\n  interestSlugs?: Slug[];\n  interests?: Interest[];\n\n  /** group-only: most specific location of the people in this channel (if any) */\n  locationSlug?: Slug;\n  location?: Location;\n\n  /** group-only: preferred spoken language in this channel. `Postable` should be translated into this language */\n  language: Language;\n\n  /**\n   * Which account do you want to use to post something in this channel?\n   *\n   * TODO: maybe refactor this to use `Persona` and match the persona automatically based on interests, location, and language, then get the mediaCredential for the platform from the `Persona` that matches this channel the most...\n   */\n  mediaCredentialId?: Id;\n  mediaCredential?: MediaCredential;\n\n  /** when did you make your last post? */\n  myLastPostAt: number;\n}"
  },
  "MediaPlatformEnum": {
    "name": "MediaPlatformEnum",
    "slug": "TsInterface",
    "id": "mediaplatformenum",
    "description": "",
    "operationName": "social-media-types",
    "rawText": "export type MediaPlatformEnum =\n  | \"facebook\"\n  | \"twitter\"\n  | \"medium\"\n  | \"reddit\"\n  | \"devto\"\n  | \"linkedin\"\n  //   medias for personal messaging and groups\n  | \"whatsapp\"\n  | \"slack\";"
  },
  "MediaPost": {
    "name": "MediaPost",
    "slug": "TsInterface",
    "id": "mediapost",
    "description": "Post/message on any medium.",
    "operationName": "social-media-types",
    "rawText": "\n\n/**\n * Post/message on any medium.\n */\nexport interface MediaPost extends MarkdownModelType {\n  /**\n   * Parsed content from the postable content, every social media platform parses in a different way\n   *\n   * For example, a big blog could be parsed into multiple tweets.\n   *\n   * Another example: maybe in some cases we need to remove images or audio\n   *\n   * Another example: markdown is mostly unsupported!\n   */\n  mediaPlatform: MediaPlatformEnum;\n  posted_messageChannelId?: string;\n  posted_messageChannel?: MediaChannel;\n\n  isVerified?: boolean;\n  isPostable: boolean;\n  unpostableReason?: string;\n  isPosted?: boolean;\n\n  /**\n   * URL that leads directly to the posted message\n   */\n  postedUrl?: string;\n  postedAt?: number;\n  channelOrGroupName?: string;\n\n  /**\n   * projectRelativePath referring to the file that has been parsed into this MediaPost\n   */\n  webMarkdownFile_projectRelativePath?: string;\n  /**\n * \n * \n * the following are DEPRECATED, use `markdown` and parse the title, content, and potential asset  from there\n\n  - parsedTitle\n  - parsedContent\n\n */\n  markdown: string;\n\n  /**\n   * Calculated from `.markdown`\n   */\n  parsedTitleCalculated?: string;\n  /**\n   * Calculated from `.markdown`\n   */\n  parsedContentCalculated?: string;\n  /**\n   * Calculated from `.markdown`\n   */\n  parsedAssetCalculated?: BackendAsset;\n\n  /**\n   * After it has been posted, this should be filled and frequently updated\n   *\n   * Omitted from the form in writer-input because it's indexed\n   */\n  postedDetailsIndexed?: {\n    views?: number;\n    /**\n     * can also be `likes` for example\n     */\n    reactions?: number;\n    /**\n     * e.g. retweet or shares\n     */\n    shares?: number;\n    /**\n     * can be `comments`, for example\n     */\n    interactions?: number;\n\n    statisticsUpdatedAt: number;\n  };\n}"
  },
  "SocialMediaPostTypeReturnType": {
    "name": "SocialMediaPostTypeReturnType",
    "slug": "TsInterface",
    "id": "socialmediaposttypereturntype",
    "description": "",
    "operationName": "social-media-types",
    "rawText": "export interface SocialMediaPostTypeReturnType {\n  isSuccess: boolean;\n  message: string;\n  postUrl?: string;\n}"
  },
  "JSONValue": {
    "name": "JSONValue",
    "slug": "TsInterface",
    "id": "jsonvalue",
    "description": "",
    "operationName": "string-to-json",
    "rawText": "export type JSONValue =\n  | null\n  | undefined\n  | boolean\n  | number\n  | string\n  | { [key: string]: JSONValue }\n  | JSONValue[];"
  },
  "NamedParameters<typeof objectStringToJson>": {
    "name": "NamedParameters<typeof objectStringToJson>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-objectstringtojson",
    "description": "",
    "operationName": "string-to-json"
  },
  "NamedParameters<typeof parseIfJson>": {
    "name": "NamedParameters<typeof parseIfJson>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parseifjson",
    "description": "",
    "operationName": "string-to-json"
  },
  "NamedParameters<typeof parsePrimitiveJson>": {
    "name": "NamedParameters<typeof parsePrimitiveJson>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-parseprimitivejson",
    "description": "",
    "operationName": "string-to-json"
  },
  "NamedParameters<typeof stringToJson>": {
    "name": "NamedParameters<typeof stringToJson>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-stringtojson",
    "description": "",
    "operationName": "string-to-json"
  },
  "NamedParameters<typeof SwipeHomepage>": {
    "name": "NamedParameters<typeof SwipeHomepage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-swipehomepage",
    "description": "",
    "operationName": "swipe-homepage"
  },
  "SwipeItem": {
    "name": "SwipeItem",
    "slug": "TsInterface",
    "id": "swipeitem",
    "description": "",
    "operationName": "swipe-homepage",
    "rawText": "\n\nexport type SwipeItem = {\n  imagePath?: string | null;\n  description?: string;\n  markdown?: string;\n  isMarkdownNoLimit?: boolean;\n\n  markdownSourcePath?: string;\n  title: string;\n  /**\n   * if given,href for the title and description (when clicking on one of those)\n   */\n  href?: string;\n};"
  },
  "EncodingOpts": {
    "name": "EncodingOpts",
    "slug": "TsInterface",
    "id": "encodingopts",
    "description": "",
    "operationName": "text-or-binary",
    "rawText": "\n\nexport interface EncodingOpts {\n  /** Defaults to 24 */\n  chunkLength?: number;\n\n  /** If not provided, will check the start, beginning, and end */\n  chunkBegin?: number;\n}"
  },
  "NamedParameters<typeof getChunkBegin>": {
    "name": "NamedParameters<typeof getChunkBegin>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getchunkbegin",
    "description": "",
    "operationName": "text-or-binary"
  },
  "NamedParameters<typeof getChunkEnd>": {
    "name": "NamedParameters<typeof getChunkEnd>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getchunkend",
    "description": "",
    "operationName": "text-or-binary"
  },
  "NamedParameters<typeof getEncoding>": {
    "name": "NamedParameters<typeof getEncoding>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getencoding",
    "description": "",
    "operationName": "text-or-binary"
  },
  "NamedParameters<typeof isBinary>": {
    "name": "NamedParameters<typeof isBinary>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isbinary",
    "description": "",
    "operationName": "text-or-binary"
  },
  "NamedParameters<typeof isFirstByteOf2ByteChar>": {
    "name": "NamedParameters<typeof isFirstByteOf2ByteChar>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isfirstbyteof2bytechar",
    "description": "",
    "operationName": "text-or-binary"
  },
  "NamedParameters<typeof isFirstByteOf3ByteChar>": {
    "name": "NamedParameters<typeof isFirstByteOf3ByteChar>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isfirstbyteof3bytechar",
    "description": "",
    "operationName": "text-or-binary"
  },
  "NamedParameters<typeof isFirstByteOf4ByteChar>": {
    "name": "NamedParameters<typeof isFirstByteOf4ByteChar>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isfirstbyteof4bytechar",
    "description": "",
    "operationName": "text-or-binary"
  },
  "NamedParameters<typeof isLaterByteOfUtf8>": {
    "name": "NamedParameters<typeof isLaterByteOfUtf8>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-islaterbyteofutf8",
    "description": "",
    "operationName": "text-or-binary"
  },
  "NamedParameters<typeof isText>": {
    "name": "NamedParameters<typeof isText>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-istext",
    "description": "",
    "operationName": "text-or-binary"
  },
  "NamedParameters<typeof time>": {
    "name": "NamedParameters<typeof time>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-time",
    "description": "",
    "operationName": "time"
  },
  "ReviewSummary": {
    "name": "ReviewSummary",
    "slug": "TsInterface",
    "id": "reviewsummary",
    "description": "",
    "operationName": "todo-types",
    "rawText": "\n\nexport type ReviewSummary = {\n  scoreYourselfSlider: number;\n  scoreYourselfDescription: string;\n  coderOfTheWeekVote_personId: string;\n  coderOfTheWeekVoteDescription: string;\n};"
  },
  "SelfSprintReview": {
    "name": "SelfSprintReview",
    "slug": "TsInterface",
    "id": "selfsprintreview",
    "description": "\n\nGOAL:\n\n- provide a good way for freelancers and students to self-assess\n- structure the data to provide tools for self-analysis\n\nTODO: PREREQUISITE:\n\n- auth layer\n- p2p\n- create a **model-agnostic-ui** that renders this type of models nicely (many checkmarks, some sliders, some descriptions). can simply be converted into text for the most part\n- make the DB crud component\n- which also allows extra columns\n- which also has an option to use the **model-agnostic-ui**\n- add `Dataset`s support to DB crud\n- make sure the form shows nicely\n- slider component and convention\n- show description by ensuring that, if the trimmed description is an empty string, it shows everything on all lines after, until the next variable\n- monetisation\n\nTHOUGHTS:\n\n- this was just one hour of work, and it kind of is a product (given I make all the general purpose prerequisites). I can make it a bundle that devs can install and BOOM! you got a SaaS... just charge 1$ per entry xD\n- think about other things that can be assessed, can/should they be automated too? not only for teams, also for intimate groups of people to assess private things, also for yourself completely\n- if I have more things like this, which are basically scoring sheets, I can easily reuse the statistics part of the UI that I make for this\n\nTODO: CUSTOM:\n\n- make a `ui-web` operation that has just this crud (or add to the Todo UI)\n- add nice flow for showing the \"coder of the week\"\n- add a column to share an item on social media if it's your own (may be super reusable too)\n- later add things like summaries, history, comparisons, insights (but do it as generic as possible)\n- later provide more auto-filled datapoints (xyzIndexed) for different things\n- later let user auto-share things with the marketstack xD",
    "operationName": "todo-types",
    "rawText": "\n\n/**\n---\ndbStorageMethod: jsonSingle\n---\n\n\nGOAL:\n\n- provide a good way for freelancers and students to self-assess\n- structure the data to provide tools for self-analysis\n\nTODO: PREREQUISITE:\n\n- auth layer\n- p2p\n- create a **model-agnostic-ui** that renders this type of models nicely (many checkmarks, some sliders, some descriptions). can simply be converted into text for the most part\n- make the DB crud component\n  - which also allows extra columns\n  - which also has an option to use the **model-agnostic-ui**\n- add `Dataset`s support to DB crud\n- make sure the form shows nicely\n  - slider component and convention\n  - show description by ensuring that, if the trimmed description is an empty string, it shows everything on all lines after, until the next variable\n- monetisation\n\nTHOUGHTS:\n\n- this was just one hour of work, and it kind of is a product (given I make all the general purpose prerequisites). I can make it a bundle that devs can install and BOOM! you got a SaaS... just charge 1$ per entry xD\n- think about other things that can be assessed, can/should they be automated too? not only for teams, also for intimate groups of people to assess private things, also for yourself completely\n- if I have more things like this, which are basically scoring sheets, I can easily reuse the statistics part of the UI that I make for this\n\nTODO: CUSTOM:\n\n- make a `ui-web` operation that has just this crud (or add to the Todo UI) \n- add nice flow for showing the \"coder of the week\"\n- add a column to share an item on social media if it's your own (may be super reusable too)\n- later add things like summaries, history, comparisons, insights (but do it as generic as possible)\n- later provide more auto-filled datapoints (xyzIndexed) for different things\n- later let user auto-share things with the marketstack xD\n\n*/\nexport type SelfSprintReview = ReviewSummary & {\n  personId: string;\n  person?: Person;\n  /**\n  DESCRIPTION:\n\n  - ensure code gets reviewed\n  - document well\n  - clear naming and simple, elegant code\n  - apply all conventions\n  - use all king OS libraries\n  */\n  codeQuality: ReviewSummary & {\n    lastWeeksCodeGotReviewedThisWeek: boolean;\n    allCodeDocumented: boolean;\n  };\n\n  /**\n  DESCRIPTION:\n\n  - full time?\n  - at least 50% coding editor time?\n  - provide screen time statistics\n\n  */\n  timeManagement: ReviewSummary & {\n    screenTimeHours: number;\n    vscodeHours: number;\n    distractedHours: number;\n    projectBrowserHours: number;\n    englishLearningHours: number;\n    screenshotImages: BackendAsset[];\n  };\n  /**\n  \n  DESCRIPTION:\n\n  - daily networking session on linkedin (and maybe others) (<30m)\n  - attract an audience by creating valueable content for your niche\n  - have conversations and (video) calls with recruiters and companies, record and share them\n\n */\n  networking: ReviewSummary & {\n    dailyNetworkingSession: boolean;\n    contentCreatedThisWeek: boolean;\n    recruiterOrCompanyMeetingThisWeek: boolean;\n  };\n\n  /**\n\n  DESCRIPTION:\n\n  - Build some project of your own on the side (or as main thing)\n  - Progress on this every week, keep us updated\n  - Learn how to find a good idea, validate it, form a product, market it, get interested users, get feedback, monetise it.\n\n  */\n  entrepreneurship: ReviewSummary & {\n    workedOnPassionProject: boolean;\n    progressUpdateDescription: string;\n  };\n\n  /**\nDESCRIPTION:\n\n- daily todo list\n- daily done list\n- good sprint planning statement\n- good sprint review statement\n- ask sharp questions\n- never be stuck, ensure you're never blocked\n- share code (changes) and demos frequently\n- if you can't uphold agreement, communicate this asap (better beforehand and as early as possible) and honestly\n- be present and on time (sharp) at all meetings\n- share payment request once per month, on time\n- share hours worked (with proof: wakatime, screentime) at least every week\n- share accomplishments\n- present bigger topics, be proactive about this\n\n    */\n  clientCommunication: ReviewSummary & {\n    dailyTodoList: boolean;\n    dailyDoneList: boolean;\n    goodSprintPlanningStatement: boolean;\n    goodSprintReviewStatement: boolean;\n    iAskSharpQuestions: boolean;\n    iAmNeverBlocked: boolean;\n    iShareCodeChangesDaily: boolean;\n    upheldAgreement: boolean;\n    presentAndOnTimeAtMeetings: boolean;\n    sharePaymentRequest: boolean;\n    shareHoursWorked: boolean;\n  };\n\n  problemsDescription: string;\n  solutionsDescription: string;\n  proudOfDescription: string;\n} & DefaultModelType;"
  },
  "SpecialKvmdModelType": {
    "name": "SpecialKvmdModelType",
    "slug": "TsInterface",
    "id": "specialkvmdmodeltype",
    "description": "Should be a model that can be taken from the database like kvmd, but for parsing, it needs its own parse methods (from and to json)\n\nThese methods can be given in the configuration of `createDb`.\n\nThese methods can be found.",
    "operationName": "todo-types",
    "rawText": "\n\n/**\n * Should be a model that can be taken from the database like kvmd, but for parsing, it needs its own parse methods (from and to json)\n *\n * These methods can be given in the configuration of `createDb`.\n *\n * These methods can be found.\n */\nexport type SpecialKvmdModelType = KeyValueMarkdownModelType;"
  },
  "Todo": {
    "name": "Todo",
    "slug": "TsInterface",
    "id": "todo",
    "description": "The `Todo` KVMD model parses a `TodoFile` to find individual todos, their status, category, and more structured metadata.\n\nCan be chosen to be used for a `TodoFile` to create an alternative UI\n\n`TodoFile`s can be parsed to find this datastructure\n\nWill be great for insights.",
    "operationName": "todo-types",
    "rawText": "\n\n/**\n * The `Todo` KVMD model parses a `TodoFile` to find individual todos, their status, category, and more structured metadata.\n *\n * Can be chosen to be used for a `TodoFile` to create an alternative UI\n *\n * `TodoFile`s can be parsed to find this datastructure\n *\n * Will be great for insights.\n */\nexport interface Todo extends SpecialKvmdModelType {\n  /**\n   * If line contains a bolded text at the start, this will be the title\n   */\n  title?: string;\n\n  /**\n   * unix timestamp indicating when this thing needs to be done\n   *\n   * can be inferred from the line like:\n   *\n   * `(< 2023-08-20)`\n   */\n  deadlineAt?: number;\n\n  /**\n   * Inferred from the line\n   */\n  todo: string;\n\n  /**\n   * Can be indicated with\n   *\n   * ✅ = done\n   * ❌ = wontdo\n   * 🔧 = doing (maybe use 🟠?)\n   *\n   * (none = todo)\n   */\n  status: \"todo\" | \"doing\" | \"wontdo\" | \"done\";\n  /**\n   * can be indicated with '🚫'\n   */\n  isBlocked: boolean;\n  /**\n   * can be indicated with '❗️'\n   */\n  isCritical: boolean;\n  /**\n   * can be indicated with '🌐'\n   */\n  isInternetRequired: boolean;\n  /**\n   * can be inferred from @[PersonSlug]\n   */\n  assigned_personId?: Id;\n  /**\n   * can be inferred from a time indicator between parenthesises at the end of the sentence\n   *\n   * e.g. `(3h)` or `(20m)` or `(5d)`\n   */\n  duration?: number;\n  durationTimeIndicator: \"hours\" | \"days\" | \"minutes\";\n}"
  },
  "TodoFile": {
    "name": "TodoFile",
    "slug": "TsInterface",
    "id": "todofile",
    "description": "Any markdown file in the todo folder should become this model",
    "operationName": "todo-types",
    "rawText": "\n\n/**\n * Any markdown file in the todo folder should become this model\n */\nexport interface TodoFile\n  extends MarkdownModelType,\n    ExtendedMarkdownProperties,\n    WebMarkdownProperties,\n    PostableProperties,\n    TodoFileProperties {}"
  },
  "TodoFileProperties": {
    "name": "TodoFileProperties",
    "slug": "TsInterface",
    "id": "todofileproperties",
    "description": "",
    "operationName": "todo-types",
    "rawText": "\n\nexport interface TodoFileProperties {\n  priority?: TodoPriority;\n\n  // `TodoOffer` config. Must be flat because it's a `MarkdownModelType`\n\n  /**\n   * overwrites visibility for freelancer\n   *\n   * by default a todo is visible, unless specifically hiding it\n   *\n   * by default a todo with `isDraft: true` is hidden, unless specifically making it visible\n   */\n  isHiddenForFreelancer?: boolean;\n\n  /**\n   * make todo claimable by a freelancer\n   */\n  isClaimable?: boolean;\n\n  /**\n   * Price to be paid, that, if offered by a freelancer, will be accepted.\n   */\n  doNowPrice?: Price;\n\n  /**\n   * admin can specify when this needs to be finished\n   */\n  deadlineAt?: number;\n\n  /**\n   * Source needed from these operations, can be made accessible after accepting the offer\n   */\n  codeRequired_operationSlugs: Id[];\n  todoOffersCalculated?: TodoOffer[];\n\n  owner_personId?: Slug;\n\n  /**\n   * special categories that augment todo-ui functionality:\n   *\n   * - `ideas` can have altered visibility, according to config\n   * - `done` can have altered visibility, according to config\n   * - `backlog` can have altered visibility, according to config\n   * - `codestories` should be turned into codestories\n   *\n   * Not sure if this should really be fixed, but a convention is always good.\n   */\n  categoryStack: CategoryStack;\n}"
  },
  "TodoOffer": {
    "name": "TodoOffer",
    "slug": "TsInterface",
    "id": "todooffer",
    "description": "Freelancers can offer their services for a todofile",
    "operationName": "todo-types",
    "rawText": "\n\n/**\n * Freelancers can offer their services for a todofile\n */\nexport interface TodoOffer extends DefaultModelType {\n  /**\n   * price the freelancer offers to do this todo\n   *\n   * NB: once offer is accepted, freelancer nor admin can edit the `offerPrice`\n   */\n  offerPrice: Price;\n  personId: Id;\n  todoFileId: Id;\n  /**\n   * mark offer as paid\n   */\n  isPaid?: boolean;\n\n  status: TodoOfferStatus;\n\n  /**\n   * Any assets that are related to this offer can be placed and removed both by freelancer and admin\n   */\n  assets: BackendAsset[];\n\n  /**\n   * markdown of the `TodoFile` when the offer was placed or offerPrice edited\n   *\n   * after offer was accepted, should not be edited\n   */\n  offeredTodoFileMarkdown: Markdown;\n\n  /**\n   * freelancer and admin can both edit the `offeredMarkdown` freely after accepting\n   *\n   * since there's also still a link to the `TodoFile`, admin can also opt to edit that one because it may be applied to all offers. freelancer can't edit the original todo.\n   */\n  editableTodoFileMarkdown: Markdown;\n}"
  },
  "TodoOfferStatus": {
    "name": "TodoOfferStatus",
    "slug": "TsInterface",
    "id": "todoofferstatus",
    "description": "Status of an offer to do some todolist\n\n- `offered`: offer placed, has not been accepted yet. freelancer can still edit offer or remove it\n- `rejected`: offer can be rejected by admin (before accepting)\n- `canceled`: freelancer and admin can cancel an previously accepted offer\n- `accepted`: offer is accepted by admin\n- `todo`: freelancer has said it still needs to be done\n- `doing` freelancer has said it's in progress\n- `done` freelancer said it's done\n- `approved` approved by admin, offer should become archived",
    "operationName": "todo-types",
    "rawText": "/**\n * Status of an offer to do some todolist\n *\n * - `offered`: offer placed, has not been accepted yet. freelancer can still edit offer or remove it\n * - `rejected`: offer can be rejected by admin (before accepting)\n * - `canceled`: freelancer and admin can cancel an previously accepted offer\n * - `accepted`: offer is accepted by admin\n * - `todo`: freelancer has said it still needs to be done\n * - `doing` freelancer has said it's in progress\n * - `done` freelancer said it's done\n * - `approved` approved by admin, offer should become archived\n */\nexport type TodoOfferStatus =\n  | \"offered\"\n  | \"rejected\"\n  | \"accepted\"\n  | \"todo\"\n  | \"doing\"\n  | \"done\"\n  | \"approved\";"
  },
  "TodoPriority": {
    "name": "TodoPriority",
    "slug": "TsInterface",
    "id": "todopriority",
    "description": "",
    "operationName": "todo-types",
    "rawText": "export type TodoPriority = \"low\" | \"medium\" | \"high\";"
  },
  "NamedParameters<typeof tryParseJson>": {
    "name": "NamedParameters<typeof tryParseJson>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-tryparsejson",
    "description": "",
    "operationName": "try-parse-json"
  },
  "NamedParameters<typeof getAllTsMorphSourceFiles>": {
    "name": "NamedParameters<typeof getAllTsMorphSourceFiles>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getalltsmorphsourcefiles",
    "description": "",
    "operationName": "ts-morph-util"
  },
  "NamedParameters<typeof getTsMorphProject>": {
    "name": "NamedParameters<typeof getTsMorphProject>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gettsmorphproject",
    "description": "",
    "operationName": "ts-morph-util"
  },
  "NamedParameters<typeof createCodeblockMarkdown>": {
    "name": "NamedParameters<typeof createCodeblockMarkdown>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-createcodeblockmarkdown",
    "description": "",
    "operationName": "ui-util"
  },
  "CustomUrlStoreConfig": {
    "name": "CustomUrlStoreConfig",
    "slug": "TsInterface",
    "id": "customurlstoreconfig",
    "description": "",
    "operationName": "use-url-store",
    "rawText": "\n\nexport type CustomUrlStoreConfig = {\n  type: \"string\" | \"number\" | \"boolean\";\n  isArray?: boolean;\n  allowUndefined?: boolean;\n};"
  },
  "NamedParameters<typeof useCustomUrlStore>": {
    "name": "NamedParameters<typeof useCustomUrlStore>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-usecustomurlstore",
    "description": "",
    "operationName": "use-url-store"
  },
  "NamedParameters<typeof getOpenableFilePath>": {
    "name": "NamedParameters<typeof getOpenableFilePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getopenablefilepath",
    "description": "",
    "operationName": "vscode-open"
  },
  "NamedParameters<typeof vscodeOpen>": {
    "name": "NamedParameters<typeof vscodeOpen>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-vscodeopen",
    "description": "",
    "operationName": "vscode-open"
  },
  "OpenableFile": {
    "name": "OpenableFile",
    "slug": "TsInterface",
    "id": "openablefile",
    "description": "",
    "operationName": "vscode-open",
    "rawText": "\n\nexport type OpenableFile = {\n  projectRelativePath?: string;\n  /**\n   *\n   */\n  operationName?: string;\n  operationRelativeFilePath?: string;\n  line?: number;\n};"
  },
  "NamedParameters<typeof watchAll>": {
    "name": "NamedParameters<typeof watchAll>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-watchall",
    "description": "",
    "operationName": "watch-all"
  },
  "NamedParameters<typeof watchAllCli>": {
    "name": "NamedParameters<typeof watchAllCli>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-watchallcli",
    "description": "",
    "operationName": "watch-all"
  },
  "NamedParameters<typeof pickWatcher>": {
    "name": "NamedParameters<typeof pickWatcher>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-pickwatcher",
    "description": "",
    "operationName": "watch-folders"
  },
  "NamedParameters<typeof exitIfOperationsChange>": {
    "name": "NamedParameters<typeof exitIfOperationsChange>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-exitifoperationschange",
    "description": "",
    "operationName": "watch-operations"
  },
  "NamedParameters<typeof gitCommitAllCron>": {
    "name": "NamedParameters<typeof gitCommitAllCron>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-gitcommitallcron",
    "description": "",
    "operationName": "watch-operations"
  },
  "NamedParameters<typeof watchOperations>": {
    "name": "NamedParameters<typeof watchOperations>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-watchoperations",
    "description": "",
    "operationName": "watch-operations"
  },
  "CrudPage": {
    "name": "CrudPage",
    "slug": "TsInterface",
    "id": "crudpage",
    "description": "Data needed to make a `WebPage`<CrudPage>",
    "operationName": "webpage-types",
    "rawText": "\n/**\n * Data needed to make a `WebPage`<CrudPage>\n */\nexport type CrudPage = {\n  modelName: string;\n  datasetSlugs?: string[];\n  canCreate?: boolean;\n  canRead?: boolean;\n  canUpdate?: boolean;\n  canDelete?: boolean;\n  itemActionFunctionNames?: string[];\n  pageActionFunctionNames?: string[];\n};"
  },
  "CustomWebPage": {
    "name": "CustomWebPage",
    "slug": "TsInterface",
    "id": "customwebpage",
    "description": "different kinds of WebPages",
    "operationName": "webpage-types",
    "rawText": "\n\n//different kinds of WebPages\nexport type CustomWebPage = WebPage<null>;"
  },
  "FileWebPage": {
    "name": "FileWebPage",
    "slug": "TsInterface",
    "id": "filewebpage",
    "description": "",
    "operationName": "webpage-types",
    "rawText": "\nexport type FileWebPage = WebPage<FilePage>;"
  },
  "FunctionFormPage": {
    "name": "FunctionFormPage",
    "slug": "TsInterface",
    "id": "functionformpage",
    "description": "Data needed to make a `WebPage`<FunctionFormPage>",
    "operationName": "webpage-types",
    "rawText": "\n\n/**\n * Data needed to make a `WebPage`<FunctionFormPage>\n */\nexport type FunctionFormPage = {\n  functionName: string;\n  actionWithResult?: string;\n  routeOnIsSuccessful?: string;\n  customTitle?: string;\n  isMenuHidden?: boolean;\n};"
  },
  "NamedParameters<typeof crudPageToWebPages>": {
    "name": "NamedParameters<typeof crudPageToWebPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-crudpagetowebpages",
    "description": "",
    "operationName": "webpage-types"
  },
  "NamedParameters<typeof functionFormPageToWebPage>": {
    "name": "NamedParameters<typeof functionFormPageToWebPage>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-functionformpagetowebpage",
    "description": "",
    "operationName": "webpage-types"
  },
  "WriterWebPage": {
    "name": "WriterWebPage",
    "slug": "TsInterface",
    "id": "writerwebpage",
    "description": "",
    "operationName": "webpage-types",
    "rawText": "\nexport type WriterWebPage = FileWebPage;"
  },
  "NamedParameters<typeof writeToAssets>": {
    "name": "NamedParameters<typeof writeToAssets>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-writetoassets",
    "description": "",
    "operationName": "write-to-assets"
  },
  "NamedParameters<typeof copyPath>": {
    "name": "NamedParameters<typeof copyPath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-copypath",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof deleteFileOrFolder>": {
    "name": "NamedParameters<typeof deleteFileOrFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-deletefileorfolder",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof getFileContents>": {
    "name": "NamedParameters<typeof getFileContents>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getfilecontents",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof getWriterWebPages>": {
    "name": "NamedParameters<typeof getWriterWebPages>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getwriterwebpages",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof getWriterWebPagesMenu>": {
    "name": "NamedParameters<typeof getWriterWebPagesMenu>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getwriterwebpagesmenu",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof movePath>": {
    "name": "NamedParameters<typeof movePath>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-movepath",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof newFile>": {
    "name": "NamedParameters<typeof newFile>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-newfile",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof newFolder>": {
    "name": "NamedParameters<typeof newFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-newfolder",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof processAssetUpload>": {
    "name": "NamedParameters<typeof processAssetUpload>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-processassetupload",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof renameFileOrFolder>": {
    "name": "NamedParameters<typeof renameFileOrFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-renamefileorfolder",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof saveFileContents>": {
    "name": "NamedParameters<typeof saveFileContents>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-savefilecontents",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof trashFileOrFolder>": {
    "name": "NamedParameters<typeof trashFileOrFolder>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-trashfileorfolder",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof updateFrontmatter>": {
    "name": "NamedParameters<typeof updateFrontmatter>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-updatefrontmatter",
    "description": "",
    "operationName": "writer-functions"
  },
  "NamedParameters<typeof Completion>": {
    "name": "NamedParameters<typeof Completion>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-completion",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof editSubtextSubwordConfig>": {
    "name": "NamedParameters<typeof editSubtextSubwordConfig>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-editsubtextsubwordconfig",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof getContext>": {
    "name": "NamedParameters<typeof getContext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getcontext",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof getSubtext>": {
    "name": "NamedParameters<typeof getSubtext>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getsubtext",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof getWriterTypeFromContent>": {
    "name": "NamedParameters<typeof getWriterTypeFromContent>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-getwritertypefromcontent",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof isAugmentedWordMatch>": {
    "name": "NamedParameters<typeof isAugmentedWordMatch>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-isaugmentedwordmatch",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof isTypescript>": {
    "name": "NamedParameters<typeof isTypescript>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-istypescript",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof MarkdownCompletions>": {
    "name": "NamedParameters<typeof MarkdownCompletions>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdowncompletions",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof MarkdownParsePresentation>": {
    "name": "NamedParameters<typeof MarkdownParsePresentation>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownparsepresentation",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof MarkdownView>": {
    "name": "NamedParameters<typeof MarkdownView>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markdownview",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof MarkedToken>": {
    "name": "NamedParameters<typeof MarkedToken>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-markedtoken",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof omitSpecialCharactersFromStart>": {
    "name": "NamedParameters<typeof omitSpecialCharactersFromStart>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-omitspecialcharactersfromstart",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof SpannedSentence>": {
    "name": "NamedParameters<typeof SpannedSentence>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-spannedsentence",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof SubtextContainer>": {
    "name": "NamedParameters<typeof SubtextContainer>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-subtextcontainer",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof testAllContentEditableRenderComponents>": {
    "name": "NamedParameters<typeof testAllContentEditableRenderComponents>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-testallcontenteditablerendercomponents",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof trimAround>": {
    "name": "NamedParameters<typeof trimAround>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-trimaround",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof trimLeft>": {
    "name": "NamedParameters<typeof trimLeft>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-trimleft",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof TypescriptCompletions>": {
    "name": "NamedParameters<typeof TypescriptCompletions>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-typescriptcompletions",
    "description": "",
    "operationName": "writer-input"
  },
  "NamedParameters<typeof WriterConfigForm>": {
    "name": "NamedParameters<typeof WriterConfigForm>",
    "slug": "TsInterface",
    "id": "namedparameterstypeof-writerconfigform",
    "description": "",
    "operationName": "writer-input"
  },
  "SubtextConfig": {
    "name": "SubtextConfig",
    "slug": "TsInterface",
    "id": "subtextconfig",
    "description": "Configuration of what should be shown in the subtext",
    "operationName": "writer-types",
    "rawText": "\n\n/**\n * Configuration of what should be shown in the subtext\n */\nexport type SubtextConfig = {\n  /**\n   * TITLE: Enable\n   */\n  isEnabled?: boolean;\n\n  /**\n   * You can show multiple translations in the subtext\n   */\n  translations?: {\n    language: Language;\n    showAlternative?: boolean;\n    showPhonetic?: boolean;\n    showLatin?: boolean;\n    showTokiPona?: boolean;\n    showCommon?: boolean;\n  }[];\n\n  showEmojiTranslation?: boolean;\n\n  /**\n   * show definitions of words occuring in this paragraph\n   */\n  showDefinitionsWithPriority?: WordPriority[];\n\n  /**\n   * Related stuff related to this paragraph, e.g. other articles/markdown\n   */\n  showRelated?: SubtextRelatedThing[];\n};"
  },
  "SubwordConfig": {
    "name": "SubwordConfig",
    "slug": "TsInterface",
    "id": "subwordconfig",
    "description": "Configurate what should be shown about words",
    "operationName": "writer-types",
    "rawText": "\n\n/**\n * Configurate what should be shown about words\n */\nexport type SubwordConfig = {\n  /**\n   * TITLE: Enable\n   */\n  isEnabled?: boolean;\n  /**\n   * Optionally, make the subwords smaller for a better overview\n   */\n  subwordSize?: \"normal\" | \"mini\" | \"micro\";\n  /**\n   * show subwords for one or multiple languages\n   */\n  translations?: Language[];\n  translationsViewMode?: SubwordViewMode;\n  /**\n   * Show definition (always in tooltip)\n   */\n  showDefinition?: boolean;\n  /**\n   * Show occurrence amount\n   */\n  occurenceAmountViewMode?: SubwordViewMode;\n\n  /**\n   * Blur the word unless it's special for one reason or another. Might be useful for skimming (or maybe more)\n   */\n  blurMode?: \"disabled\" | \"special\";\n\n  /**\n   * Audio for `WordMatrix` word can be played\n   */\n  audioMode?: SubwordViewMode;\n\n  /**\n   * if \"translate\" is selected, first language from `translations` will be used\n   *\n   * `alternative` picks the alternative writing using the `WordMatrix` if available\n   *\n   * `phonetic` picks the phonetic writing using the `WordMatrix` if available\n   */\n  replaceWordMode?:\n    | \"disabled\"\n    | \"translate\"\n    | \"alternative\"\n    | \"phonetic\"\n    | \"tokiPona\"\n    | \"emoji\";\n\n  /**\n   * colour words with heat having different meanings\n   */\n  heatmapMode?: \"disabled\" | \"projectFrequency\" | \"englishFrequency\";\n};"
  },
  "TextEditingContext": {
    "name": "TextEditingContext",
    "slug": "TsInterface",
    "id": "texteditingcontext",
    "description": "",
    "operationName": "writer-input",
    "rawText": "export type TextEditingContext = {\n  wordAtPosition: string;\n  positionIndex: number;\n};"
  },
  "WriterConfigFormValue": {
    "name": "WriterConfigFormValue",
    "slug": "TsInterface",
    "id": "writerconfigformvalue",
    "description": "",
    "operationName": "writer-input",
    "rawText": "\n\nexport type WriterConfigFormValue = [\n  subtextConfig: SubtextConfig,\n  subwordConfig: SubwordConfig\n];"
  },
  "SubtextRelatedThing": {
    "name": "SubtextRelatedThing",
    "slug": "TsInterface",
    "id": "subtextrelatedthing",
    "description": "",
    "operationName": "writer-types",
    "rawText": "\n\nexport type SubtextRelatedThing = {\n  type: \"image\" | \"asset\" | \"pages\" | \"data\" | \"code\";\n  quantity: \"single\" | \"short\" | \"all\";\n};"
  },
  "SubwordViewMode": {
    "name": "SubwordViewMode",
    "slug": "TsInterface",
    "id": "subwordviewmode",
    "description": "",
    "operationName": "writer-types",
    "rawText": "\n\nexport type SubwordViewMode = \"disabled\" | \"tooltip\" | \"context\" | \"subword\";"
  },
  "WriterViewEnum": {
    "name": "WriterViewEnum",
    "slug": "TsInterface",
    "id": "writerviewenum",
    "description": "",
    "operationName": "writer-types",
    "rawText": "\n\nexport type WriterViewEnum =\n  | \"config\"\n  | \"view\"\n  | \"edit\"\n  | \"presentation\"\n  | \"frontmatter\"\n  | \"todoOffers\"\n  | \"postable\"\n  | \"shortStudio\"\n  | \"prompts\"\n  | \"prompt-results\";"
  },
  "MyApp": {
    "name": "MyApp",
    "slug": "TsFunction",
    "id": "zamjgtvqfmtbjeyyyqxwlvcm",
    "description": "",
    "operationName": "writer-web",
    "rawText": "\n\n// Only holds serverRuntimeConfig and publicRuntimeConfig\n\nfunction MyApp({ Component, pageProps }: AppProps) {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Head>\n        <title>Writer</title>\n\n        <link\n          rel=\"stylesheet\"\n          href=\"https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.6.0/build/styles/default.min.css\"\n        />\n      </Head>\n      <ToastContainer />\n      <AlertProvider>\n        <StoreProvider>\n          <ModalProvider>\n            <MyLayout pageProps={pageProps} nextPage={Component} />\n          </ModalProvider>\n        </StoreProvider>\n      </AlertProvider>\n    </QueryClientProvider>\n  );\n}"
  },
  "useReactMediaRecorder": {
    "name": "useReactMediaRecorder",
    "slug": "TsFunction",
    "id": "adzjcgehieogjcqnogbghdai",
    "description": "",
    "operationName": "asset-input",
    "rawText": "\n\nexport function useReactMediaRecorder({\n  audio = true,\n  video = false,\n  onStop = () => null,\n  onStart = () => null,\n  blobPropertyBag,\n  screen = false,\n  mediaRecorderOptions = undefined,\n  customMediaStream = null,\n  stopStreamsOnStop = true,\n  askPermissionOnMount = false,\n}: ReactMediaRecorderHookProps): ReactMediaRecorderRenderProps {\n  const mediaRecorder = useRef<IMediaRecorder | null>(null);\n  const mediaChunks = useRef<Blob[]>([]);\n  const mediaStream = useRef<MediaStream | null>(null);\n  const [status, setStatus] = useState<StatusMessages>(\"idle\");\n  const [isAudioMuted, setIsAudioMuted] = useState<boolean>(false);\n  const [mediaBlobUrl, setMediaBlobUrl] = useState<string | undefined>(\n    undefined\n  );\n  const [error, setError] = useState<keyof typeof RecorderErrors>(\"NONE\");\n\n  useEffect(() => {\n    let messagePort: MessagePort | undefined = undefined;\n    const setup = async () => {\n      try {\n        // NB: try to connect, if it fails, don't crash, just assume it already is there\n        messagePort = await connect();\n        await register(messagePort);\n      } catch (e) {\n        console.log(\"errrie\", e);\n      }\n    };\n    setup();\n\n    // NB: need to clean it up!\n    return () => {\n      if (messagePort) {\n        disconnect(messagePort);\n      }\n    };\n  }, []);\n\n  const getMediaStream = useCallback(async () => {\n    setStatus(\"acquiring_media\");\n    const requiredMedia: MediaStreamConstraints = {\n      audio: typeof audio === \"boolean\" ? !!audio : audio,\n      video: typeof video === \"boolean\" ? !!video : video,\n    };\n    try {\n      if (customMediaStream) {\n        mediaStream.current = customMediaStream;\n      } else if (screen) {\n        const stream = (await window.navigator.mediaDevices.getDisplayMedia({\n          video: video || true,\n        })) as MediaStream;\n        stream.getVideoTracks()[0].addEventListener(\"ended\", () => {\n          stopRecording();\n        });\n        if (audio) {\n          const audioStream = await window.navigator.mediaDevices.getUserMedia({\n            audio,\n          });\n\n          audioStream\n            .getAudioTracks()\n            .forEach((audioTrack) => stream.addTrack(audioTrack));\n        }\n        mediaStream.current = stream;\n      } else {\n        const stream = await window.navigator.mediaDevices.getUserMedia(\n          requiredMedia\n        );\n        mediaStream.current = stream;\n      }\n      setStatus(\"idle\");\n    } catch (error: any) {\n      setError(error.name);\n      setStatus(\"idle\");\n    }\n  }, [audio, video, screen]);\n\n  useEffect(() => {\n    if (!window.MediaRecorder) {\n      throw new Error(\"Unsupported Browser\");\n    }\n\n    if (screen) {\n      if (!window.navigator.mediaDevices.getDisplayMedia) {\n        throw new Error(\"This browser doesn't support screen capturing\");\n      }\n    }\n\n    const checkConstraints = (mediaType: MediaTrackConstraints) => {\n      const supportedMediaConstraints =\n        navigator.mediaDevices.getSupportedConstraints();\n      const unSupportedConstraints = Object.keys(mediaType).filter(\n        (constraint) =>\n          !(supportedMediaConstraints as { [key: string]: any })[constraint]\n      );\n\n      if (unSupportedConstraints.length > 0) {\n        console.error(\n          `The constraints ${unSupportedConstraints.join(\n            \",\"\n          )} doesn't support on this browser. Please check your ReactMediaRecorder component.`\n        );\n      }\n    };\n\n    if (typeof audio === \"object\") {\n      checkConstraints(audio);\n    }\n    if (typeof video === \"object\") {\n      checkConstraints(video);\n    }\n\n    if (mediaRecorderOptions && mediaRecorderOptions.mimeType) {\n      if (!MediaRecorder.isTypeSupported(mediaRecorderOptions.mimeType)) {\n        console.error(\n          `The specified MIME type you supplied for MediaRecorder doesn't support this browser`\n        );\n      }\n    }\n\n    if (!mediaStream.current && askPermissionOnMount) {\n      getMediaStream();\n    }\n\n    return () => {\n      if (mediaStream.current) {\n        const tracks = mediaStream.current.getTracks();\n        tracks.forEach((track) => track.clone().stop());\n      }\n    };\n  }, [\n    audio,\n    screen,\n    video,\n    getMediaStream,\n    mediaRecorderOptions,\n    askPermissionOnMount,\n  ]);\n\n  // Media Recorder Handlers\n\n  const startRecording = async () => {\n    setError(\"NONE\");\n    if (!mediaStream.current) {\n      await getMediaStream();\n    }\n    if (mediaStream.current) {\n      const isStreamEnded = mediaStream.current\n        .getTracks()\n        .some((track) => track.readyState === \"ended\");\n      if (isStreamEnded) {\n        await getMediaStream();\n      }\n\n      // User blocked the permissions (getMediaStream errored out)\n      if (!mediaStream.current.active) {\n        return;\n      }\n      mediaRecorder.current = new ExtendableMediaRecorder(\n        mediaStream.current,\n        mediaRecorderOptions || undefined\n      );\n      mediaRecorder.current.ondataavailable = onRecordingActive;\n      mediaRecorder.current.onstop = onRecordingStop;\n      mediaRecorder.current.onstart = onRecordingStart;\n      mediaRecorder.current.onerror = () => {\n        setError(\"NO_RECORDER\");\n        setStatus(\"idle\");\n      };\n      mediaRecorder.current.start();\n      setStatus(\"recording\");\n    }\n  };\n\n  const onRecordingActive = ({ data }: BlobEvent) => {\n    mediaChunks.current.push(data);\n  };\n\n  const onRecordingStart = () => {\n    onStart();\n  };\n\n  const onRecordingStop = () => {\n    const [chunk] = mediaChunks.current;\n    const blobProperty: BlobPropertyBag = Object.assign(\n      { type: chunk.type },\n      blobPropertyBag || (video ? { type: \"video/mp4\" } : { type: \"audio/wav\" })\n    );\n    const blob = new Blob(mediaChunks.current, blobProperty);\n    const url = URL.createObjectURL(blob);\n    setStatus(\"stopped\");\n    setMediaBlobUrl(url);\n    onStop(url, blob);\n  };\n\n  const muteAudio = (mute: boolean) => {\n    setIsAudioMuted(mute);\n    if (mediaStream.current) {\n      mediaStream.current\n        .getAudioTracks()\n        .forEach((audioTrack) => (audioTrack.enabled = !mute));\n    }\n  };\n\n  const pauseRecording = () => {\n    if (mediaRecorder.current && mediaRecorder.current.state === \"recording\") {\n      setStatus(\"paused\");\n      mediaRecorder.current.pause();\n    }\n  };\n  const resumeRecording = () => {\n    if (mediaRecorder.current && mediaRecorder.current.state === \"paused\") {\n      setStatus(\"recording\");\n      mediaRecorder.current.resume();\n    }\n  };\n\n  const stopRecording = () => {\n    if (mediaRecorder.current) {\n      if (mediaRecorder.current.state !== \"inactive\") {\n        setStatus(\"stopping\");\n        mediaRecorder.current.stop();\n        if (stopStreamsOnStop) {\n          mediaStream.current &&\n            mediaStream.current.getTracks().forEach((track) => track.stop());\n        }\n        mediaChunks.current = [];\n      }\n    }\n  };\n\n  return {\n    error: RecorderErrors[error],\n    muteAudio: () => muteAudio(true),\n    unMuteAudio: () => muteAudio(false),\n    startRecording,\n    pauseRecording,\n    resumeRecording,\n    stopRecording,\n    mediaBlobUrl,\n    status,\n    isAudioMuted,\n    previewStream: mediaStream.current\n      ? new MediaStream(mediaStream.current.getVideoTracks())\n      : null,\n    previewAudioStream: mediaStream.current\n      ? new MediaStream(mediaStream.current.getAudioTracks())\n      : null,\n    clearBlobUrl: () => {\n      if (mediaBlobUrl) {\n        URL.revokeObjectURL(mediaBlobUrl);\n      }\n      setMediaBlobUrl(undefined);\n      setStatus(\"idle\");\n    },\n  };\n}"
  },
  "getTypescriptErrorsFromFiles": {
    "name": "getTypescriptErrorsFromFiles",
    "slug": "TsFunction",
    "id": "larmjwdmppkfcwkrqnzgebij",
    "description": "/**\n * uses official typescript compiler to check all given files for compilation errors\n */",
    "operationName": "compile-typescript",
    "rawText": "\n\n/**\n * uses official typescript compiler to check all given files for compilation errors\n */\nexport function getTypescriptErrorsFromFiles({\n  filePaths,\n  debug,\n}: {\n  basePath: string;\n  filePaths: string[];\n  compilerOptions: TsConfig[\"compilerOptions\"];\n  packageJson: PackageJson;\n  debug?: boolean;\n}): Creation<TsBuildError>[] {\n  try {\n    const program = typescript.createProgram(filePaths, {});\n    const emitResult = program.emit(undefined, (fileName) => {\n      if (debug) console.log(`emitted ${fileName}, not writing.`);\n    });\n\n    const allDiagnostics = typescript\n      .getPreEmitDiagnostics(program)\n      .concat(emitResult.diagnostics);\n\n    const buildErrors = allDiagnostics\n      .map((diagnostic) => {\n        let buildError: null | Creation<TsBuildError> = null;\n\n        // TODO: Fix this! Obviously this isn't correct\n        const filePath = filePaths[0];\n\n        const operationBasePath = findOperationBasePath(filePath);\n        if (!operationBasePath) return;\n\n        const operationPathParse = getOperationPathParse(filePath);\n        if (!operationPathParse) return;\n\n        const operationName = getLastFolder(operationBasePath);\n        const operationRelativeTypescriptFilePath =\n          operationPathParse.operationRelativeTypescriptFilePath;\n\n        if (diagnostic.file && diagnostic.start) {\n          const { line, character } = typescript.getLineAndCharacterOfPosition(\n            diagnostic.file,\n            diagnostic.start\n          );\n          const message = typescript.flattenDiagnosticMessageText(\n            diagnostic.messageText,\n            \"\\n\"\n          );\n\n          buildError = {\n            message,\n            operationName,\n            operationRelativeTypescriptFilePath,\n            line: line + 1,\n            character: character + 1,\n            id: generateId(),\n            // TODO: later I can give this the name of the error maybe\n            name: \"TsBuildError\",\n            slug: \"ts-build-error\",\n          };\n          // console.log(\n          //   `${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`\n          // );\n        } else {\n          const message = typescript.flattenDiagnosticMessageText(\n            diagnostic.messageText,\n            \"\\n\"\n          );\n          buildError = {\n            id: generateId(),\n            message,\n            // TODO: later I can give this the name of the error maybe\n            name: \"TsBuildError\",\n            slug: \"ts-build-error\",\n            operationRelativeTypescriptFilePath:\n              operationPathParse.operationRelativeTypescriptFilePath,\n          };\n        }\n\n        return buildError;\n      })\n      .filter(notEmpty);\n\n    return buildErrors;\n  } catch (e) {\n    log(`WTF raar ${e}`, { type: \"error\" });\n    return [];\n  }\n}"
  },
  "fileSlugify": {
    "name": "fileSlugify",
    "slug": "TsFunction",
    "id": "hffjrsjyrizawdxiydeefaxw",
    "description": "/**\n * Slugification for filepaths in specific\n */",
    "operationName": "convert-case",
    "rawText": "\n\n/**\n * Slugification for filepaths in specific\n */\nexport function fileSlugify(string: string) {\n  const a =\n    \"àáâäæãåāăąçćčđďèéêëēėęěğǵḧîïíīįìıİłḿñńǹňôöòóœøōõőṕŕřßśšşșťțûüùúūǘůűųẃẍÿýžźż·,:;\";\n  const b =\n    \"aaaaaaaaaacccddeeeeeeeegghiiiiiiiilmnnnnoooooooooprrsssssttuuuuuuuuuwxyyzzz----\";\n  const p = new RegExp(a.split(\"\").join(\"|\"), \"g\");\n\n  return (\n    string\n      .toString()\n      .replace(/\\s+/g, \"-\") // Replace spaces with -\n      .replace(p, (c) => b.charAt(a.indexOf(c))) // Replace special characters\n      .replace(/&/g, \"-and-\") // Replace & with 'and'\n      // .replace(/[^\\w\\-]+/g, \"\") // Remove all non-word characters\n      .replace(/\\-\\-+/g, \"-\") // Replace multiple - with single -\n      .replace(/^-+/, \"\") // Trim - from start of text\n      .replace(/-+$/, \"\")\n  ); // Trim - from end of text\n}"
  },
  "slugify": {
    "name": "slugify",
    "slug": "TsFunction",
    "id": "fmsokgbftkxpaxfooiuhvcsq",
    "description": "/**\n * this function does the same as kebabCase but it also does some more transformation on top\n *\n * useful for making simple URLs and filenames. Kebacase is not enough\n *\n * NB: this is no two way transformation. When slugifying something, information is lost and it cannot be converted back in the original name.\n *\n * TODO: make the tranformations that are done here into smaller util functions and make a clean function that can be ran before running every casing conversion (maybe in a config)\n */",
    "operationName": "convert-case",
    "rawText": "/**\n * this function does the same as kebabCase but it also does some more transformation on top\n *\n * useful for making simple URLs and filenames. Kebacase is not enough\n *\n * NB: this is no two way transformation. When slugifying something, information is lost and it cannot be converted back in the original name.\n *\n * TODO: make the tranformations that are done here into smaller util functions and make a clean function that can be ran before running every casing conversion (maybe in a config)\n */\nexport function slugify(string: string) {\n  const a =\n    \"àáâäæãåāăąçćčđďèéêëēėęěğǵḧîïíīįìıİłḿñńǹňôöòóœøōõőṕŕřßśšşșťțûüùúūǘůűųẃẍÿýžźż·/_,:;\";\n  const b =\n    \"aaaaaaaaaacccddeeeeeeeegghiiiiiiiilmnnnnoooooooooprrsssssttuuuuuuuuuwxyyzzz------\";\n  const p = new RegExp(a.split(\"\").join(\"|\"), \"g\");\n\n  return string\n    .toString()\n    .toLowerCase()\n    .replace(/\\s+/g, \"-\") // Replace spaces with -\n    .replace(p, (c) => b.charAt(a.indexOf(c))) // Replace special characters\n    .replace(/&/g, \"-and-\") // Replace & with 'and'\n    .replace(/[^\\w\\-]+/g, \"\") // Remove all non-word characters\n    .replace(/\\-\\-+/g, \"-\") // Replace multiple - with single -\n    .replace(/^-+/, \"\") // Trim - from start of text\n    .replace(/-+$/, \"\"); // Trim - from end of text\n}"
  },
  "handleExplicitValidation": {
    "name": "handleExplicitValidation",
    "slug": "TsFunction",
    "id": "yhpbgmiqjvwfipinazcamaau",
    "description": "",
    "operationName": "index-typescript",
    "rawText": "\n\nfunction handleExplicitValidation(\n  type: string,\n  schema: any,\n  decorators: Decorator[] = []\n): SimpleJsonSchema {\n  decorators.forEach((d) => {\n    const dName = d.getName();\n    switch (dName) {\n      case \"min\":\n      case \"max\": {\n        const firstArgumentTextNumber = +d.getArguments()[0].getText();\n        schema = merge(\n          schema,\n          getMinMaxValidation(dName, type, firstArgumentTextNumber)\n        );\n        break;\n      }\n      case \"time\":\n      case \"date\":\n      case \"dateTime\":\n      case \"duration\":\n      case \"uri\":\n      case \"uriReference\":\n      case \"uriTemplate\":\n      case \"email\":\n      case \"hostname\":\n      case \"ipv4\":\n      case \"ipv6\":\n      case \"uuid\":\n      case \"jsonPointer\":\n      case \"relativeJsonPointer\": {\n        schema = merge(schema, { format: toSnack(dName) });\n        break;\n      }\n    }\n  });\n  return schema;\n}"
  },
  "hasDefinition": {
    "name": "hasDefinition",
    "slug": "TsFunction",
    "id": "piiteoztpzwfjhicqhnjmdyb",
    "description": "",
    "operationName": "index-typescript",
    "rawText": "\n\nexport function hasDefinition(\n  maybeInterface: MaybeInteface\n): maybeInterface is TsInterface {\n  return maybeInterface.type.typeDefinition !== null;\n}"
  },
  "arrayGenerator": {
    "name": "arrayGenerator",
    "slug": "TsFunction",
    "id": "brxeaxxxtbrtbpfyymtpcqcr",
    "description": "/**\n * NB: Do I really need this? Would be nice not to use generators.\n */",
    "operationName": "js-util",
    "rawText": "\n\n/**\n * NB: Do I really need this? Would be nice not to use generators.\n */\nfunction* arrayGenerator(array: any[]): ArrayGenerator {\n  for (let index = 0; index < array.length; index++) {\n    const currentValue = array[index];\n    const generatorTuple: [any, number, any[]] = [currentValue, index, array];\n    yield generatorTuple;\n  }\n}"
  },
  "notEmpty": {
    "name": "notEmpty",
    "slug": "TsFunction",
    "id": "qyxeujgkrewaaeyrkaqmnxse",
    "description": "",
    "operationName": "react-with-native-form",
    "rawText": "\n\nexport function notEmpty<TValue>(\n  value: TValue | null | undefined\n): value is TValue {\n  return value !== null && value !== undefined;\n}"
  },
  "onlyUnique": {
    "name": "onlyUnique",
    "slug": "TsFunction",
    "id": "qzyqmtutoipoxvabpffelkiv",
    "description": "/**\n * DEPRECATED: should refactor everything to use onlyUnique2 and call it onlyUnique again\n *\n * to be used as a filter. removes duplicates\n */",
    "operationName": "js-util",
    "rawText": "\n\n/**\n * DEPRECATED: should refactor everything to use onlyUnique2 and call it onlyUnique again\n *\n * to be used as a filter. removes duplicates\n */\nexport function onlyUnique<T extends unknown>(\n  value: T,\n  index: number,\n  self: T[]\n) {\n  return self.findIndex((v) => v === value) === index;\n}"
  },
  "worker": {
    "name": "worker",
    "slug": "TsFunction",
    "id": "zhtabtspnfitgxkkfiakvwjs",
    "description": "",
    "operationName": "js-util",
    "rawText": "\n\nasync function worker(\n  id: number,\n  generator: ArrayGenerator,\n  mapFn: MapFn<any, any>,\n  result: any[]\n) {\n  //console.time(`Worker ${id}`);\n  for (let [currentValue, index, array] of generator) {\n    //console.time(`Worker ${id} --- index ${index} item ${currentValue}`);\n\n    const mappedResult = await mapItem(mapFn, currentValue, index, array);\n\n    // NB: if mappedResult gets rejected, change nothing!\n    if (mappedResult.status === \"fulfilled\") {\n      result[index] = mappedResult.value;\n    }\n\n    //console.timeEnd(`Worker ${id} --- index ${index} item ${currentValue}`);\n  }\n  //console.timeEnd(`Worker ${id}`);\n}"
  },
  "generatePassword": {
    "name": "generatePassword",
    "slug": "TsFunction",
    "id": "gyvrjpabvolvhcryxwihfjpo",
    "description": "/**\n * generates a password. By default, uses a length of 14\n */",
    "operationName": "model-types",
    "rawText": "\n\n/**\n * generates a password. By default, uses a length of 14\n */\nexport function generatePassword(passwordLength: number = 14) {\n  return generateRandomString(passwordLength);\n}"
  },
  "isEmail": {
    "name": "isEmail",
    "slug": "TsFunction",
    "id": "oyiwenfeeqoswmtkxabrnwxt",
    "description": "",
    "operationName": "model-types",
    "rawText": "\n\nexport function isEmail(email: string) {\n  var re =\n    /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n  return re.test(String(email).toLowerCase());\n}"
  },
  "byteCount": {
    "name": "byteCount",
    "slug": "TsFunction",
    "id": "xfedlzbwsebxxuimeozoxyjy",
    "description": "/**\n * This function will return the byte size of any UTF-8 string you pass to it.\n */",
    "operationName": "path-util",
    "rawText": "\n\n/**\n * This function will return the byte size of any UTF-8 string you pass to it.\n */\nexport function byteCount(s: string) {\n  return encodeURI(s).split(/%..|./).length - 1;\n}"
  },
  "isObject": {
    "name": "isObject",
    "slug": "TsFunction",
    "id": "iqieemkdxutcmpdnvhvxrdxf",
    "description": "",
    "operationName": "react-with-native-form",
    "rawText": "\n\nexport function isObject(object: any): object is object {\n  return object != null && typeof object === \"object\";\n}"
  },
  "Modal": {
    "name": "Modal",
    "slug": "TsFunction",
    "id": "jzcggvxkjsxpdlwipygaiibg",
    "description": "",
    "operationName": "react-with-native-modal",
    "rawText": "\n\nexport function Modal() {\n  const [inside, setInside] = useState(false);\n  let { modalContent, title, handleModal, showModal } =\n    useContext(ModalContext);\n\n  if (showModal) {\n    return (\n      <>\n        <Div\n          onClick={() => !inside && handleModal(null)}\n          className=\"fixed inset-0 z-50 flex items-center justify-center overflow-x-hidden overflow-y-auto outline-none focus:outline-none\"\n        >\n          <Div\n            onMouseEnter={() => setInside(true)}\n            onMouseLeave={() => setInside(false)}\n            className=\"relative w-auto max-w-3xl mx-auto my-6 lg:w-10/12 lg:h-10/12\"\n          >\n            {/*content*/}\n            <Div className=\"relative flex flex-col w-full bg-white border-0 rounded-lg shadow-lg outline-none focus:outline-none\">\n              {/*header*/}\n              <Div className=\"flex items-start justify-between p-5 border-b border-gray-200 border-solid rounded-t\">\n                <h3 className=\"text-3xl font-semibold\">{title}</h3>\n                <Button\n                  className=\"float-right p-1 ml-auto text-3xl font-semibold leading-none text-black bg-transparent border-0 outline-none opacity-5 focus:outline-none\"\n                  onClick={() => handleModal(null)}\n                >\n                  <span className=\"block w-6 h-6 text-2xl text-black bg-transparent outline-none opacity-5 focus:outline-none\">\n                    x\n                  </span>\n                </Button>\n              </Div>\n              {/*body*/}\n              <Div className=\"relative flex-auto p-6\">\n                <p className=\"my-4 text-lg leading-relaxed text-gray-500\">\n                  {modalContent}\n                </p>\n              </Div>\n              {/*footer*/}\n              <Div className=\"flex items-center justify-end p-6 border-t border-gray-200 border-solid\">\n                <Button\n                  className=\"px-6 py-2 mb-1 mr-1 text-sm font-bold text-red-500 uppercase transition-all duration-150 ease-linear outline-none background-transparent focus:outline-none\"\n                  onClick={() => handleModal(null)}\n                >\n                  Close...\n                </Button>\n              </Div>\n            </Div>\n          </Div>\n        </Div>\n        <Div className=\"fixed inset-0 z-40 bg-black opacity-50\"></Div>\n      </>\n    );\n  } else return null;\n}"
  },
  "useNavigation": {
    "name": "useNavigation",
    "slug": "TsFunction",
    "id": "bbiexasrpyjlznzepbxnpbka",
    "description": "",
    "operationName": "react-with-native-router",
    "rawText": "\n\nexport function useNavigation() {\n  const router = useRouter();\n\n  return {\n    addListener: () => {},\n    canGoBack: () => true,\n    dispatch: () => {},\n    getParent: () => {},\n    getState: () => {},\n    goBack: () => {\n      router.back();\n    },\n    isFocused: () => {},\n    removeListener: () => {},\n    reset: () => {},\n    setOptions: () => {},\n    setParams: () => {},\n\n    navigate: (screen: string, params?: { [key: string]: any }) => {\n      router.push(screen, { query: params });\n    },\n  };\n}"
  },
  "useIsInViewport": {
    "name": "useIsInViewport",
    "slug": "TsFunction",
    "id": "iucwqfsrprzvdbsjnwikankc",
    "description": "",
    "operationName": "react-with-native-table",
    "rawText": "\n\nexport function useIsInViewport(ref: React.MutableRefObject<Element | null>) {\n  const [isIntersecting, setIsIntersecting] = useState(false);\n\n  const observer = useMemo(\n    () =>\n      typeof window !== \"undefined\"\n        ? new IntersectionObserver(([entry]) =>\n            setIsIntersecting(entry.isIntersecting)\n          )\n        : undefined,\n    []\n  );\n\n  useEffect(() => {\n    if (!ref.current) return;\n\n    observer?.observe(ref.current);\n\n    return () => {\n      observer?.disconnect();\n    };\n  }, [ref, observer]);\n\n  return isIntersecting;\n}"
  },
  "setKeyAtLocation": {
    "name": "setKeyAtLocation",
    "slug": "TsFunction",
    "id": "fhokdhwjugwhlawqsmbyquur",
    "description": "",
    "operationName": "set-json-key",
    "rawText": "\nexport function setKeyAtLocation(path: string, value: any, object: any) {\n  var schema = object; // a moving reference to internal objects within obj\n  var pList = path.split(\".\");\n  var len = pList.length;\n  for (var i = 0; i < len - 1; i++) {\n    var elem = pList[i];\n    if (!schema[elem]) schema[elem] = {};\n    schema = schema[elem];\n  }\n\n  schema[pList[len - 1]] = value;\n}"
  },
  "getChunkBegin": {
    "name": "getChunkBegin",
    "slug": "TsFunction",
    "id": "dpqqbtzpcjosgsgqqhcekrup",
    "description": "",
    "operationName": "text-or-binary",
    "rawText": "\n\n// ====================================\n// The functions below are created to handle multibyte utf8 characters.\n// To understand how the encoding works, check this article: https://en.wikipedia.org/wiki/UTF-8#Encoding\n// @todo add documentation for these\n\nfunction getChunkBegin(buf: Buffer, chunkBegin: number) {\n  // If it's the beginning, just return.\n  if (chunkBegin === 0) {\n    return 0;\n  }\n\n  if (!isLaterByteOfUtf8(buf[chunkBegin])) {\n    return chunkBegin;\n  }\n\n  let begin = chunkBegin - 3;\n\n  if (begin >= 0) {\n    if (isFirstByteOf4ByteChar(buf[begin])) {\n      return begin;\n    }\n  }\n\n  begin = chunkBegin - 2;\n\n  if (begin >= 0) {\n    if (\n      isFirstByteOf4ByteChar(buf[begin]) ||\n      isFirstByteOf3ByteChar(buf[begin])\n    ) {\n      return begin;\n    }\n  }\n\n  begin = chunkBegin - 1;\n\n  if (begin >= 0) {\n    // Is it a 4-byte, 3-byte utf8 character?\n    if (\n      isFirstByteOf4ByteChar(buf[begin]) ||\n      isFirstByteOf3ByteChar(buf[begin]) ||\n      isFirstByteOf2ByteChar(buf[begin])\n    ) {\n      return begin;\n    }\n  }\n\n  return -1;\n}"
  },
  "getChunkEnd": {
    "name": "getChunkEnd",
    "slug": "TsFunction",
    "id": "nymqhubidznczyjsslhujzcx",
    "description": "",
    "operationName": "text-or-binary",
    "rawText": "\n\nfunction getChunkEnd(buf: Buffer, chunkEnd: number) {\n  // If it's the end, just return.\n  if (chunkEnd === buf.length) {\n    return chunkEnd;\n  }\n\n  let index = chunkEnd - 3;\n\n  if (index >= 0) {\n    if (isFirstByteOf4ByteChar(buf[index])) {\n      return chunkEnd + 1;\n    }\n  }\n\n  index = chunkEnd - 2;\n\n  if (index >= 0) {\n    if (isFirstByteOf4ByteChar(buf[index])) {\n      return chunkEnd + 2;\n    }\n\n    if (isFirstByteOf3ByteChar(buf[index])) {\n      return chunkEnd + 1;\n    }\n  }\n\n  index = chunkEnd - 1;\n\n  if (index >= 0) {\n    if (isFirstByteOf4ByteChar(buf[index])) {\n      return chunkEnd + 3;\n    }\n\n    if (isFirstByteOf3ByteChar(buf[index])) {\n      return chunkEnd + 2;\n    }\n\n    if (isFirstByteOf2ByteChar(buf[index])) {\n      return chunkEnd + 1;\n    }\n  }\n\n  return chunkEnd;\n}"
  },
  "getEncoding": {
    "name": "getEncoding",
    "slug": "TsFunction",
    "id": "epjrqljlchloshvaootvgigu",
    "description": "/**\n * Get the encoding of a buffer.\n * Checks the start, middle, and end of the buffer for characters that are unrecognized within UTF8 encoding.\n * History has shown that inspection at all three locations is necessary.\n * @returns Will be `null` if `buffer` was not provided. Otherwise will be either `'utf8'` or `'binary'`\n */",
    "operationName": "text-or-binary",
    "rawText": "\n\n/**\n * Get the encoding of a buffer.\n * Checks the start, middle, and end of the buffer for characters that are unrecognized within UTF8 encoding.\n * History has shown that inspection at all three locations is necessary.\n * @returns Will be `null` if `buffer` was not provided. Otherwise will be either `'utf8'` or `'binary'`\n */\nexport function getEncoding(\n  buffer: Buffer | null,\n  opts?: EncodingOpts\n): \"utf8\" | \"binary\" | null {\n  // Check\n  if (!buffer) return null;\n\n  // Prepare\n  const textEncoding = \"utf8\";\n  const binaryEncoding = \"binary\";\n  const chunkLength = opts?.chunkLength ?? 24;\n  let chunkBegin = opts?.chunkBegin ?? 0;\n\n  // Discover\n  if (opts?.chunkBegin == null) {\n    // Start\n    let encoding = getEncoding(buffer, { chunkLength, chunkBegin });\n    if (encoding === textEncoding) {\n      // Middle\n      chunkBegin = Math.max(0, Math.floor(buffer.length / 2) - chunkLength);\n      encoding = getEncoding(buffer, {\n        chunkLength,\n        chunkBegin,\n      });\n      if (encoding === textEncoding) {\n        // End\n        chunkBegin = Math.max(0, buffer.length - chunkLength);\n        encoding = getEncoding(buffer, {\n          chunkLength,\n          chunkBegin,\n        });\n      }\n    }\n\n    // Return\n    return encoding;\n  } else {\n    // Extract\n    chunkBegin = getChunkBegin(buffer, chunkBegin);\n    if (chunkBegin === -1) {\n      return binaryEncoding;\n    }\n\n    const chunkEnd = getChunkEnd(\n      buffer,\n      Math.min(buffer.length, chunkBegin + chunkLength)\n    );\n\n    if (chunkEnd > buffer.length) {\n      return binaryEncoding;\n    }\n\n    const contentChunkUTF8 = buffer.toString(\n      textEncoding,\n      chunkBegin,\n      chunkEnd\n    );\n\n    // Detect encoding\n    for (let i = 0; i < contentChunkUTF8.length; ++i) {\n      const charCode = contentChunkUTF8.charCodeAt(i);\n      if (charCode === 65533 || charCode <= 8) {\n        // 8 and below are control characters (e.g. backspace, null, eof, etc.)\n        // 65533 is the unknown character\n        // console.log(charCode, contentChunkUTF8[i])\n        return binaryEncoding;\n      }\n    }\n\n    // Return\n    return textEncoding;\n  }\n}"
  },
  "isBinary": {
    "name": "isBinary",
    "slug": "TsFunction",
    "id": "omispmttzeaebwomjooqdpho",
    "description": "/**\n * Determine if the filename and/or buffer is binary.\n * Determined by extension checks first (if filename is available), otherwise if unknown extension or no filename, will perform a slower buffer encoding detection.\n * This order is done, as extension checks are quicker, and also because encoding checks cannot guarantee accuracy for chars between utf8 and utf16.\n * The extension checks are performed using the resources https://github.com/bevry/textextensions and https://github.com/bevry/binaryextensions\n * @param filename The filename for the file/buffer if available\n * @param buffer The buffer for the file if available\n * @returns Will be `null` if neither `filename` nor `buffer` were provided. Otherwise will be a boolean value with the detection result.\n */",
    "operationName": "text-or-binary",
    "rawText": "\n\n/**\n * Determine if the filename and/or buffer is binary.\n * Determined by extension checks first (if filename is available), otherwise if unknown extension or no filename, will perform a slower buffer encoding detection.\n * This order is done, as extension checks are quicker, and also because encoding checks cannot guarantee accuracy for chars between utf8 and utf16.\n * The extension checks are performed using the resources https://github.com/bevry/textextensions and https://github.com/bevry/binaryextensions\n * @param filename The filename for the file/buffer if available\n * @param buffer The buffer for the file if available\n * @returns Will be `null` if neither `filename` nor `buffer` were provided. Otherwise will be a boolean value with the detection result.\n */\nexport function isBinary(filename?: string | null, buffer?: Buffer | null) {\n  const text = isText(filename, buffer);\n  if (text == null) return null;\n  return !text;\n}"
  },
  "isFirstByteOf2ByteChar": {
    "name": "isFirstByteOf2ByteChar",
    "slug": "TsFunction",
    "id": "wimwuapiyqrarypchvvjupfb",
    "description": "",
    "operationName": "text-or-binary",
    "rawText": "\n\nfunction isFirstByteOf2ByteChar(byte: number) {\n  // eslint-disable-next-line no-bitwise\n  return byte >> 5 === 6; // 110xxxxx?\n}"
  },
  "isFirstByteOf3ByteChar": {
    "name": "isFirstByteOf3ByteChar",
    "slug": "TsFunction",
    "id": "mwsubapdtyinkdohghkyizll",
    "description": "",
    "operationName": "text-or-binary",
    "rawText": "\n\nfunction isFirstByteOf3ByteChar(byte: number) {\n  // eslint-disable-next-line no-bitwise\n  return byte >> 4 === 14; // 1110xxxx?\n}"
  },
  "isFirstByteOf4ByteChar": {
    "name": "isFirstByteOf4ByteChar",
    "slug": "TsFunction",
    "id": "qlviaziftpfbzvnieugpixac",
    "description": "",
    "operationName": "text-or-binary",
    "rawText": "\n\nfunction isFirstByteOf4ByteChar(byte: number) {\n  // eslint-disable-next-line no-bitwise\n  return byte >> 3 === 30; // 11110xxx?\n}"
  },
  "isLaterByteOfUtf8": {
    "name": "isLaterByteOfUtf8",
    "slug": "TsFunction",
    "id": "gwibaodbvgypyeqtbrfmtrmb",
    "description": "",
    "operationName": "text-or-binary",
    "rawText": "\n\nfunction isLaterByteOfUtf8(byte: number) {\n  // eslint-disable-next-line no-bitwise\n  return byte >> 6 === 2; // 10xxxxxx?\n}"
  },
  "isText": {
    "name": "isText",
    "slug": "TsFunction",
    "id": "xxahekicfxlpjdndjwcdsyyu",
    "description": "/**\n * Determine if the filename and/or buffer is text.\n * Determined by extension checks first (if filename is available), otherwise if unknown extension or no filename, will perform a slower buffer encoding detection.\n * This order is done, as extension checks are quicker, and also because encoding checks cannot guarantee accuracy for chars between utf8 and utf16.\n * The extension checks are performed using the resources https://github.com/bevry/textextensions and https://github.com/bevry/binaryextensions\n * @param filename The filename for the file/buffer if available\n * @param buffer The buffer for the file if available\n * @returns Will be `null` if neither `filename` nor `buffer` were provided. Otherwise will be a boolean value with the detection result.\n */",
    "operationName": "text-or-binary",
    "rawText": "\n\n/**\n * Determine if the filename and/or buffer is text.\n * Determined by extension checks first (if filename is available), otherwise if unknown extension or no filename, will perform a slower buffer encoding detection.\n * This order is done, as extension checks are quicker, and also because encoding checks cannot guarantee accuracy for chars between utf8 and utf16.\n * The extension checks are performed using the resources https://github.com/bevry/textextensions and https://github.com/bevry/binaryextensions\n * @param filename The filename for the file/buffer if available\n * @param buffer The buffer for the file if available\n * @returns Will be `null` if neither `filename` nor `buffer` were provided. Otherwise will be a boolean value with the detection result.\n */\nexport function isText(\n  filename?: string | null,\n  buffer?: Buffer | null\n): boolean | null {\n  // Test extensions\n  if (filename) {\n    // Extract filename\n    const parts = pathUtil.basename(filename).split(\".\").reverse();\n\n    // Cycle extensions\n    for (const extension of parts) {\n      if (textExtensions.indexOf(extension) !== -1) {\n        return true;\n      }\n      if (binaryExtensions.indexOf(extension) !== -1) {\n        return false;\n      }\n    }\n  }\n\n  // Fallback to encoding if extension check was not enough\n  if (buffer) {\n    return getEncoding(buffer) === \"utf8\";\n  }\n\n  // No buffer was provided\n  return null;\n}"
  },
  "useOnScreen": {
    "name": "useOnScreen",
    "slug": "TsFunction",
    "id": "kztgthtfkhtxmlphfssxugor",
    "description": "/**\n * checks wheter or not a certain element is in the browsers screen view, or not.\n */",
    "operationName": "use-on-screen",
    "rawText": "\n\n/**\n * checks wheter or not a certain element is in the browsers screen view, or not.\n */\nexport function useOnScreen(ref: RefObject<HTMLDivElement>) {\n  const [isIntersecting, setIntersecting] = useState(false);\n\n  const observer =\n    typeof window === \"undefined\"\n      ? null\n      : new IntersectionObserver(([entry]) =>\n          setIntersecting(entry.isIntersecting)\n        );\n\n  useEffect(() => {\n    if (observer) {\n      if (ref.current) {\n        observer?.observe(ref.current);\n      }\n      // Remove the observer as soon as the component is unmounted\n      return () => {\n        observer?.disconnect();\n      };\n    }\n  }, [observer]);\n\n  return isIntersecting;\n}"
  },
  "makeSubscription": {
    "name": "makeSubscription",
    "slug": "TsFunction",
    "id": "pyvickbisxyossytsgysxiad",
    "description": "",
    "operationName": "watch-folders",
    "rawText": "\n\n// `watch` is obtained from `resp.watch` in the `watch-project` response.\n// `relative_path` is obtained from `resp.relative_path` in the\n// `watch-project` response.\nexport function makeSubscription(\n  client: watchman.Client,\n  watchBaseFolder: string,\n  watchRelativePath: string,\n  debug: boolean\n) {\n  /**\n   * this can probably be optimised\n   */\n  const sub = {\n    // Match any `.js` file in the dir_of_interest\n    expression: [\"allof\", [\"match\", \"*.*\"]],\n    // Which fields we're interested in\n    fields: [\"name\", \"size\", \"mtime_ms\", \"exists\", \"type\"],\n    relative_root: undefined as undefined | string,\n    // add our time constraint\n  };\n\n  if (watchRelativePath) {\n    sub.relative_root = watchRelativePath;\n  }\n\n  const subName = getSubName(watchBaseFolder, watchRelativePath);\n\n  client.command(\n    [\"subscribe\", watchBaseFolder, subName, sub],\n    function (error, resp) {\n      if (error) {\n        // Probably an error in the subscription criteria\n        console.error(\"Failed to subscribe: \", error);\n        return;\n      }\n      if (debug) {\n        console.log(\n          \"New subscription:\",\n          \"subscription \" + resp.subscribe + \" established\"\n        );\n      }\n    }\n  );\n\n  return subName;\n}"
  },
  "codestorys-web": {
    "name": "codestorys-web",
    "slug": "Operation",
    "id": "ulxdvwhgearuudloknysrfiz",
    "operationName": "codestorys-web"
  },
  "function-server": {
    "name": "function-server",
    "slug": "Operation",
    "id": "mWmyXwGmxjHGDraW",
    "operationName": "function-server"
  },
  "markdown-reader-web": {
    "name": "markdown-reader-web",
    "slug": "Operation",
    "id": "oqRhxGziXSELxSxM",
    "operationName": "markdown-reader-web"
  },
  "search-web": {
    "name": "search-web",
    "slug": "Operation",
    "id": "txlcixkjcqlbnmtxydskvjzp",
    "operationName": "search-web"
  },
  "todo-web": {
    "name": "todo-web",
    "slug": "Operation",
    "id": "mykoqlebootgziemsvfbewtu",
    "operationName": "todo-web"
  },
  "writer-web": {
    "name": "writer-web",
    "slug": "Operation",
    "id": "tntfebpigyuqzszbxuglslsa",
    "operationName": "writer-web"
  },
  "codestorys-node": {
    "name": "codestorys-node",
    "slug": "Operation",
    "id": "csdmeiggslgvtqzybrxcxaqy",
    "operationName": "codestorys-node"
  },
  "collect-static-assets": {
    "name": "collect-static-assets",
    "slug": "Operation",
    "id": "edprvcqxqoapkijitcbmgrpn",
    "operationName": "collect-static-assets"
  },
  "sdk-api": {
    "name": "sdk-api",
    "slug": "Operation",
    "operationName": "sdk-api"
  },
  "sdk-api-keys": {
    "name": "sdk-api-keys",
    "slug": "Operation",
    "operationName": "sdk-api-keys"
  },
  "sdk-db": {
    "name": "sdk-db",
    "slug": "Operation",
    "description": "This operation is used to collect all typebase database models in the entire project, and export them, wrapped in a `DbModels` interface. This is needed for creating a function that can access the entire database (see `database` operation)\n",
    "operationName": "sdk-db"
  },
  "sdk-env-private": {
    "name": "sdk-env-private",
    "slug": "Operation",
    "description": "This operation contains all **private** environment variables that can be used on the frontend and backend of your application(s).\n\nGenerated for bundles (to be set in `BundleConfig`), manually set for King OS.\n\nNB: make sure not to import this in any frontend operations, because it may contain private keys and other secrets!\n",
    "operationName": "sdk-env-private"
  },
  "sdk-env-public": {
    "name": "sdk-env-public",
    "slug": "Operation",
    "description": "This operation contains all public environment variables that can be used on the frontend and backend of your application(s).\n\nGenerated for bundles (to be set in `BundleConfig`), manually set for King OS.\n",
    "operationName": "sdk-env-public"
  },
  "sdk-function-paths": {
    "name": "sdk-function-paths",
    "slug": "Operation",
    "operationName": "sdk-function-paths"
  },
  "sdk-interface-paths": {
    "name": "sdk-interface-paths",
    "slug": "Operation",
    "operationName": "sdk-interface-paths"
  },
  "sdk-js": {
    "name": "sdk-js",
    "slug": "Operation",
    "description": "operation that imports all `js` functions and variables in the entire project (OS or bundle) and exports an object that has all of them.\n\ncan be generated\n",
    "operationName": "sdk-js"
  },
  "sdk-operations": {
    "name": "sdk-operations",
    "slug": "Operation",
    "description": "Generated operation that exports an object that contains all names of all operations as keys, and all project relative paths to those operations as values.\n\nNeeded to find files more quickly in a more performant way.\n\nWhen moving operations around, ensure to regenerate this to avoid conflicts.\n",
    "operationName": "sdk-operations"
  },
  "sdk-ui": {
    "name": "sdk-ui",
    "slug": "Operation",
    "operationName": "sdk-ui"
  },
  "make-codestory": {
    "name": "make-codestory",
    "slug": "Operation",
    "id": "fwszeynoqsiqirywndizvimt",
    "operationName": "make-codestory"
  },
  "ai-functions-node": {
    "name": "ai-functions-node",
    "slug": "Operation",
    "id": "rwvbjpqgulkhwdsourbfwwye",
    "operationName": "ai-functions-node"
  },
  "ai-types": {
    "name": "ai-types",
    "slug": "Operation",
    "id": "rzgsitofuukkatcuriaoazvg",
    "operationName": "ai-types"
  },
  "all": {
    "name": "all",
    "slug": "Operation",
    "id": "iKazVukMuqrUgIBQ",
    "operationName": "all"
  },
  "api-store": {
    "name": "api-store",
    "slug": "Operation",
    "id": "pplunkcemarwirhhsvkbszuv",
    "operationName": "api-store"
  },
  "api-types": {
    "name": "api-types",
    "slug": "Operation",
    "id": "YROAWZykJeSsJSKv",
    "operationName": "api-types"
  },
  "apps-menu": {
    "name": "apps-menu",
    "slug": "Operation",
    "id": "kptmrhirsvgbkwunrnkyuxxx",
    "operationName": "apps-menu"
  },
  "asset-functions-js": {
    "name": "asset-functions-js",
    "slug": "Operation",
    "id": "pytnclcnhwrwajqwucxoadrl",
    "operationName": "asset-functions-js"
  },
  "asset-functions-node": {
    "name": "asset-functions-node",
    "slug": "Operation",
    "id": "HEMfUzpVNjsHgvYv",
    "operationName": "asset-functions-node"
  },
  "asset-input": {
    "name": "asset-input",
    "slug": "Operation",
    "id": "oMLGSgwZucEahFtW",
    "operationName": "asset-input"
  },
  "asset-type": {
    "name": "asset-type",
    "slug": "Operation",
    "id": "oLDXQDgzLzmvRLWs",
    "description": "",
    "operationName": "asset-type"
  },
  "asset-view": {
    "name": "asset-view",
    "slug": "Operation",
    "id": "yiqycykmfrkrufuhrdysvyzu",
    "operationName": "asset-view"
  },
  "augmented-word-node": {
    "name": "augmented-word-node",
    "slug": "Operation",
    "id": "dcohqfmxjbbcsffijbgovdau",
    "operationName": "augmented-word-node"
  },
  "augmented-word-types": {
    "name": "augmented-word-types",
    "slug": "Operation",
    "id": "ndsyirxazfqtanmjjvedeohx",
    "operationName": "augmented-word-types"
  },
  "auth-types": {
    "name": "auth-types",
    "slug": "Operation",
    "id": "fpjrnpgbsnvwcxtvlhacwfli",
    "operationName": "auth-types"
  },
  "authentication": {
    "name": "authentication",
    "slug": "Operation",
    "id": "hdvslqxxvwqpttxpqpdouyxc",
    "operationName": "authentication"
  },
  "big-button": {
    "name": "big-button",
    "slug": "Operation",
    "id": "mRyOhwUgEveAAJrO",
    "operationName": "big-button"
  },
  "breadcrumbs": {
    "name": "breadcrumbs",
    "slug": "Operation",
    "id": "kxoxrxhnzsqioawgipytghha",
    "operationName": "breadcrumbs"
  },
  "browser-types": {
    "name": "browser-types",
    "slug": "Operation",
    "id": "pgxybusbmtajhxcyzrccvxiq",
    "operationName": "browser-types"
  },
  "bundle-types": {
    "name": "bundle-types",
    "slug": "Operation",
    "id": "ooSLOVvBfJIKPyNI",
    "operationName": "bundle-types"
  },
  "bundle-util": {
    "name": "bundle-util",
    "slug": "Operation",
    "id": "sDuCZxdPfWnSMouU",
    "operationName": "bundle-util"
  },
  "chatgpt-controller": {
    "name": "chatgpt-controller",
    "slug": "Operation",
    "id": "xwgqotrxkqssqbtgmmwsaxzq",
    "operationName": "chatgpt-controller"
  },
  "child-process-helper": {
    "name": "child-process-helper",
    "slug": "Operation",
    "id": "TANPFBYnjjeOJmwd",
    "operationName": "child-process-helper"
  },
  "cleanup-typescript-database": {
    "name": "cleanup-typescript-database",
    "slug": "Operation",
    "id": "MQXgyYPDztaTqZDK",
    "operationName": "cleanup-typescript-database"
  },
  "clickable-icon": {
    "name": "clickable-icon",
    "slug": "Operation",
    "id": "UEpOSpVemdWqtXEI",
    "operationName": "clickable-icon"
  },
  "code-types": {
    "name": "code-types",
    "slug": "Operation",
    "id": "OPfmHygUKpSTTntc",
    "operationName": "code-types"
  },
  "comment-util": {
    "name": "comment-util",
    "slug": "Operation",
    "id": "geHTGIqdrUnTUVLt",
    "operationName": "comment-util"
  },
  "compile-typescript": {
    "name": "compile-typescript",
    "slug": "Operation",
    "id": "AvWuSXOnPmDqTnlH",
    "operationName": "compile-typescript"
  },
  "context-menu": {
    "name": "context-menu",
    "slug": "Operation",
    "id": "enhounuvwosisfhtmpvpvuoc",
    "operationName": "context-menu"
  },
  "convert-case": {
    "name": "convert-case",
    "slug": "Operation",
    "id": "jZgNJgiTtJkeAhry",
    "operationName": "convert-case"
  },
  "cool-toast": {
    "name": "cool-toast",
    "slug": "Operation",
    "id": "zutfzbjcvazexarsypjwzekh",
    "operationName": "cool-toast"
  },
  "csv-util": {
    "name": "csv-util",
    "slug": "Operation",
    "id": "iISehUGBHgtHVUce",
    "operationName": "csv-util"
  },
  "database": {
    "name": "database",
    "slug": "Operation",
    "id": "zppfFLZGjSFDZIPj",
    "operationName": "database"
  },
  "db-crud": {
    "name": "db-crud",
    "slug": "Operation",
    "id": "lirieiteddugaafnaaeyjbds",
    "operationName": "db-crud"
  },
  "db-recipes": {
    "name": "db-recipes",
    "slug": "Operation",
    "id": "dbWxqZljJGXXfdTi",
    "operationName": "db-recipes"
  },
  "db-util": {
    "name": "db-util",
    "slug": "Operation",
    "id": "kIgLAmFgWErGaDrQ",
    "operationName": "db-util"
  },
  "docs-get-pages": {
    "name": "docs-get-pages",
    "slug": "Operation",
    "operationName": "docs-get-pages"
  },
  "encrypt-password": {
    "name": "encrypt-password",
    "slug": "Operation",
    "id": "abmvwsdhfxtqpkialrsakdut",
    "operationName": "encrypt-password"
  },
  "explore-project": {
    "name": "explore-project",
    "slug": "Operation",
    "id": "XjzbnkYOuSNFZWzl",
    "operationName": "explore-project"
  },
  "fancy-loader": {
    "name": "fancy-loader",
    "slug": "Operation",
    "id": "pJcfNyjiMXrbMeeW",
    "operationName": "fancy-loader"
  },
  "ffmpeg-util": {
    "name": "ffmpeg-util",
    "slug": "Operation",
    "id": "ahawlqtlqdfmfhkvnfcgmbph",
    "operationName": "ffmpeg-util"
  },
  "file-explorer-open": {
    "name": "file-explorer-open",
    "slug": "Operation",
    "id": "hotfxksjiugdbklpfenmlcyq",
    "operationName": "file-explorer-open"
  },
  "file-icons": {
    "name": "file-icons",
    "slug": "Operation",
    "id": "omjkuceilskauoedaqurtwyw",
    "operationName": "file-icons"
  },
  "file-search": {
    "name": "file-search",
    "slug": "Operation",
    "id": "rbnagrbhytcltontdhdjzhul",
    "operationName": "file-search"
  },
  "file-tabs": {
    "name": "file-tabs",
    "slug": "Operation",
    "id": "yxjrqsojvivmtfykswhaezlh",
    "operationName": "file-tabs"
  },
  "file-writer": {
    "name": "file-writer",
    "slug": "Operation",
    "id": "eeoxcjsmleyuvdgfpizfdxlb",
    "operationName": "file-writer"
  },
  "filename-conventions": {
    "name": "filename-conventions",
    "slug": "Operation",
    "id": "tqWQClwFnPpjYMtz",
    "operationName": "filename-conventions"
  },
  "find-all-dependency-operations": {
    "name": "find-all-dependency-operations",
    "slug": "Operation",
    "id": "HdAdnbXfJAgtncKi",
    "operationName": "find-all-dependency-operations"
  },
  "folder-get-updated-at": {
    "name": "folder-get-updated-at",
    "slug": "Operation",
    "id": "kREgIzDSkHtqybGG",
    "operationName": "folder-get-updated-at"
  },
  "frontmatter-util": {
    "name": "frontmatter-util",
    "slug": "Operation",
    "id": "zwaaklbewcghwrndndsxvnum",
    "operationName": "frontmatter-util"
  },
  "fs-orm": {
    "name": "fs-orm",
    "slug": "Operation",
    "id": "KyZBnDkelitkjOpb",
    "description": "ORM that works with JSON and FS",
    "operationName": "fs-orm"
  },
  "fs-util": {
    "name": "fs-util",
    "slug": "Operation",
    "id": "IPFeFRXDRUiclwih",
    "description": "",
    "operationName": "fs-util"
  },
  "fs-util-js": {
    "name": "fs-util-js",
    "slug": "Operation",
    "id": "wtywoiemkrpenkgcxyzophmp",
    "operationName": "fs-util-js"
  },
  "function-context-type": {
    "name": "function-context-type",
    "slug": "Operation",
    "id": "gxhwkphayiynopvlstqqefdb",
    "operationName": "function-context-type"
  },
  "function-form": {
    "name": "function-form",
    "slug": "Operation",
    "id": "cJEZBYPBhcdnfoHB",
    "operationName": "function-form"
  },
  "function-functions-node": {
    "name": "function-functions-node",
    "slug": "Operation",
    "id": "nwxdvcemhjxnshvyimslpusa",
    "operationName": "function-functions-node"
  },
  "function-server-endpoints": {
    "name": "function-server-endpoints",
    "slug": "Operation",
    "id": "ngYzqrtHoOBkeAuZ",
    "description": "This operation wraps the sdk and creates a server-endpoint for every sdk function form the sdk package. It also adds raw context functions (both get and post) It can be included into any server so the endpoints can be exposed that way.",
    "operationName": "function-server-endpoints"
  },
  "function-types": {
    "name": "function-types",
    "slug": "Operation",
    "id": "ozvpmyyzqlomnozlvceebulr",
    "operationName": "function-types"
  },
  "function-util": {
    "name": "function-util",
    "slug": "Operation",
    "id": "HejhllnaKbSgGFZu",
    "operationName": "function-util"
  },
  "generate-index": {
    "name": "generate-index",
    "slug": "Operation",
    "id": "mIFyRAZdIyMVeaNT",
    "operationName": "generate-index"
  },
  "generate-sdk-operations": {
    "name": "generate-sdk-operations",
    "slug": "Operation",
    "id": "xLOocRnSwCufGLeV",
    "operationName": "generate-sdk-operations"
  },
  "generative-functions-node": {
    "name": "generative-functions-node",
    "slug": "Operation",
    "id": "eatosihbotjdxslswtdiybvq",
    "operationName": "generative-functions-node"
  },
  "generative-ui": {
    "name": "generative-ui",
    "slug": "Operation",
    "id": "kfsjdkljfklsjklfdsjkflsdj",
    "operationName": "generative-ui"
  },
  "geo-types": {
    "name": "geo-types",
    "slug": "Operation",
    "id": "zmZNhwbpZoNRTrBq",
    "operationName": "geo-types"
  },
  "get-all-operation-source-paths": {
    "name": "get-all-operation-source-paths",
    "slug": "Operation",
    "id": "WSDeMsLYIktDGsCu",
    "operationName": "get-all-operation-source-paths"
  },
  "get-imported-dependencies": {
    "name": "get-imported-dependencies",
    "slug": "Operation",
    "id": "AUtLmurLbrNUzJTU",
    "operationName": "get-imported-dependencies"
  },
  "get-imports-exports": {
    "name": "get-imports-exports",
    "slug": "Operation",
    "id": "lRCCIhkcZmIEUuFr",
    "operationName": "get-imports-exports"
  },
  "get-package-json": {
    "name": "get-package-json",
    "slug": "Operation",
    "id": "pbuegxIIACKiiLjl",
    "operationName": "get-package-json"
  },
  "get-package-source-paths": {
    "name": "get-package-source-paths",
    "slug": "Operation",
    "id": "nkRNpxpdpuOQaEui",
    "operationName": "get-package-source-paths"
  },
  "get-path": {
    "name": "get-path",
    "slug": "Operation",
    "id": "dryPyPWnCUmLjarA",
    "operationName": "get-path"
  },
  "get-ts-config": {
    "name": "get-ts-config",
    "slug": "Operation",
    "id": "KDQDhuKmgVOmWJmD",
    "operationName": "get-ts-config"
  },
  "hotkeys": {
    "name": "hotkeys",
    "slug": "Operation",
    "id": "mhtiahtbjrotfleivmecjpmd",
    "operationName": "hotkeys"
  },
  "index-typescript": {
    "name": "index-typescript",
    "slug": "Operation",
    "id": "IcOyBmsRzHfoLRuh",
    "description": "This repo is used to generate the typescript index.\n\nSome important conventions I'm applying:\n\n1. The generated index doesn't know the absolute location, which makes it possible to move around the Project in the OS\n\n2. The generated index only tells you information about this very operation. All links with other operations should be done in postprocessing\n\n3. Every generated index has an `IndexId`",
    "operationName": "index-typescript"
  },
  "is-online": {
    "name": "is-online",
    "slug": "Operation",
    "id": "bvvjvydchfuzsfhbfqzktksk",
    "operationName": "is-online"
  },
  "is-system-busy": {
    "name": "is-system-busy",
    "slug": "Operation",
    "operationName": "is-system-busy"
  },
  "js-util": {
    "name": "js-util",
    "slug": "Operation",
    "id": "LZEMcPKjXKrmGtyo",
    "operationName": "js-util"
  },
  "json-util": {
    "name": "json-util",
    "slug": "Operation",
    "id": "luPEMFyMIRGcjCYW",
    "operationName": "json-util"
  },
  "k-dev": {
    "name": "k-dev",
    "slug": "Operation",
    "id": "UWnbXcZjuZVykeJY",
    "operationName": "k-dev"
  },
  "k-explore": {
    "name": "k-explore",
    "slug": "Operation",
    "id": "CjtxcuPobvSETpNJ",
    "description": "",
    "operationName": "k-explore"
  },
  "k-test": {
    "name": "k-test",
    "slug": "Operation",
    "id": "uzdtgVTjvwNzUtBE",
    "operationName": "k-test"
  },
  "key-value-markdown-js": {
    "name": "key-value-markdown-js",
    "slug": "Operation",
    "id": "GKqeDzGAZNiBMdhR",
    "operationName": "key-value-markdown-js"
  },
  "labeled-button": {
    "name": "labeled-button",
    "slug": "Operation",
    "id": "yhBwbsOSNWakshDe",
    "operationName": "labeled-button"
  },
  "language-types": {
    "name": "language-types",
    "slug": "Operation",
    "id": "MDGCBVVEJDNAZFnc",
    "operationName": "language-types"
  },
  "layout": {
    "name": "layout",
    "slug": "Operation",
    "id": "wawdrsmykhqbtpmblsexbxiq",
    "operationName": "layout"
  },
  "lint": {
    "name": "lint",
    "slug": "Operation",
    "id": "FbqlLZAgfQkcdjcs",
    "operationName": "lint"
  },
  "lock-system": {
    "name": "lock-system",
    "slug": "Operation",
    "operationName": "lock-system"
  },
  "lock-util": {
    "name": "lock-util",
    "slug": "Operation",
    "operationName": "lock-util"
  },
  "mail": {
    "name": "mail",
    "slug": "Operation",
    "id": "soofejieszawuyozxhlnvxae",
    "operationName": "mail"
  },
  "make-file-type": {
    "name": "make-file-type",
    "slug": "Operation",
    "id": "xiEEhmhKrjFXlAPd",
    "operationName": "make-file-type"
  },
  "make-test": {
    "name": "make-test",
    "slug": "Operation",
    "id": "BedsrLKBmpfyubBq",
    "operationName": "make-test"
  },
  "markdown": {
    "name": "markdown",
    "slug": "Operation",
    "id": "kizrquhyzzljipgcekjjtedi",
    "operationName": "markdown"
  },
  "markdown-parse-js": {
    "name": "markdown-parse-js",
    "slug": "Operation",
    "id": "MAgsnxSMgHQFmLwQ",
    "operationName": "markdown-parse-js"
  },
  "markdown-parsings": {
    "name": "markdown-parsings",
    "slug": "Operation",
    "id": "vMOVaTybLMZCbMxF",
    "operationName": "markdown-parsings"
  },
  "markdown-reader-functions": {
    "name": "markdown-reader-functions",
    "slug": "Operation",
    "id": "bollpwzntnlfggwaozdgzouh",
    "operationName": "markdown-reader-functions"
  },
  "markdown-reader-functions-js": {
    "name": "markdown-reader-functions-js",
    "slug": "Operation",
    "id": "jjtsjmhpxodqfzancabgcdwb",
    "operationName": "markdown-reader-functions-js"
  },
  "markdown-reader-types": {
    "name": "markdown-reader-types",
    "slug": "Operation",
    "id": "mmhddgzrootleqtfakivowbg",
    "operationName": "markdown-reader-types"
  },
  "markdown-types": {
    "name": "markdown-types",
    "slug": "Operation",
    "id": "lfjxdzqmyqzatibtsvmvwnlu",
    "operationName": "markdown-types"
  },
  "marked-util": {
    "name": "marked-util",
    "slug": "Operation",
    "id": "nwuyvleykklklazutgnonxys",
    "operationName": "marked-util"
  },
  "matter-types": {
    "name": "matter-types",
    "slug": "Operation",
    "id": "zmHiKRECDSMTZFZJ",
    "operationName": "matter-types"
  },
  "measure-performance": {
    "name": "measure-performance",
    "slug": "Operation",
    "id": "kgowshxmokprmggbdvxcmgbv",
    "operationName": "measure-performance"
  },
  "menu": {
    "name": "menu",
    "slug": "Operation",
    "id": "ccxtwtiwzwtgjheoikeqhrxs",
    "operationName": "menu"
  },
  "minify-build": {
    "name": "minify-build",
    "slug": "Operation",
    "id": "BxtliSGWFpCDLiTF",
    "operationName": "minify-build"
  },
  "model-types": {
    "name": "model-types",
    "slug": "Operation",
    "id": "IXDTUWkcNmDrRNZr",
    "operationName": "model-types"
  },
  "name-conventions": {
    "name": "name-conventions",
    "slug": "Operation",
    "id": "KYgjCfCEZaJqxGAZ",
    "operationName": "name-conventions"
  },
  "nested-menu": {
    "name": "nested-menu",
    "slug": "Operation",
    "id": "UTkxpBtFXEwRtTqK",
    "operationName": "nested-menu"
  },
  "nested-menu-types": {
    "name": "nested-menu-types",
    "slug": "Operation",
    "id": "zcgsduhmgvbryrkojblugamd",
    "operationName": "nested-menu-types"
  },
  "new-template": {
    "name": "new-template",
    "slug": "Operation",
    "id": "WmtmpZUgcnRixKhs",
    "description": "Package to create a new King OS template (template or some other boilerplate)",
    "operationName": "new-template"
  },
  "next-a-link": {
    "name": "next-a-link",
    "slug": "Operation",
    "id": "eYjXWFLCrqXdeneP",
    "operationName": "next-a-link"
  },
  "next-paths": {
    "name": "next-paths",
    "slug": "Operation",
    "id": "slentyitwfkamdqsbtvmlfva",
    "operationName": "next-paths"
  },
  "next-types": {
    "name": "next-types",
    "slug": "Operation",
    "id": "mcvrsqtxyouxgtsvczlovvss",
    "operationName": "next-types"
  },
  "one-by-one": {
    "name": "one-by-one",
    "slug": "Operation",
    "id": "rYEcHzTwPVdXNgDV",
    "operationName": "one-by-one"
  },
  "operation-util": {
    "name": "operation-util",
    "slug": "Operation",
    "id": "ijohgpnKYOINMKGK",
    "operationName": "operation-util"
  },
  "parse-primitive": {
    "name": "parse-primitive",
    "slug": "Operation",
    "id": "WwNnCKBujPifBhZN",
    "operationName": "parse-primitive"
  },
  "path-util": {
    "name": "path-util",
    "slug": "Operation",
    "id": "QeSbBbHgeEbynPXh",
    "operationName": "path-util"
  },
  "peer-functions": {
    "name": "peer-functions",
    "slug": "Operation",
    "id": "STZJGyqPOGISGkCo",
    "operationName": "peer-functions"
  },
  "peer-types": {
    "name": "peer-types",
    "slug": "Operation",
    "id": "hvMDXibXiSQYwWSD",
    "operationName": "peer-types"
  },
  "persona-functions-node": {
    "name": "persona-functions-node",
    "slug": "Operation",
    "id": "uvlsdhymohxzavizeimkaalt",
    "operationName": "persona-functions-node"
  },
  "pm2-util": {
    "name": "pm2-util",
    "slug": "Operation",
    "id": "zxFlNEXoXXPZaswv",
    "operationName": "pm2-util"
  },
  "port-conventions": {
    "name": "port-conventions",
    "slug": "Operation",
    "id": "ibUKZMpiVNxJrzhg",
    "operationName": "port-conventions"
  },
  "prompt-components": {
    "name": "prompt-components",
    "slug": "Operation",
    "id": "vqykiaraonhamykiyozkjhsx",
    "operationName": "prompt-components"
  },
  "puppeteer-utils": {
    "name": "puppeteer-utils",
    "slug": "Operation",
    "id": "jOxKunDQGygYBOWr",
    "operationName": "puppeteer-utils"
  },
  "queue-types": {
    "name": "queue-types",
    "slug": "Operation",
    "operationName": "queue-types"
  },
  "react-with-native": {
    "name": "react-with-native",
    "slug": "Operation",
    "id": "LrYgJCZCgKRrjsKj",
    "description": "HTML elements with React Native capabilities.",
    "operationName": "react-with-native"
  },
  "react-with-native-alert": {
    "name": "react-with-native-alert",
    "slug": "Operation",
    "id": "HRCvBKzhcQmtavKi",
    "description": "Alert for web and native",
    "operationName": "react-with-native-alert"
  },
  "react-with-native-form": {
    "name": "react-with-native-form",
    "slug": "Operation",
    "id": "QDSihJHrNrMynEee",
    "description": "Create forms, fast",
    "operationName": "react-with-native-form"
  },
  "react-with-native-form-asset-input": {
    "name": "react-with-native-form-asset-input",
    "slug": "Operation",
    "id": "xstmiipzrabkocwcfctmjjyg",
    "operationName": "react-with-native-form-asset-input"
  },
  "react-with-native-form-inputs": {
    "name": "react-with-native-form-inputs",
    "slug": "Operation",
    "id": "nioyXlkpzdsdbrGZ",
    "operationName": "react-with-native-form-inputs"
  },
  "react-with-native-modal": {
    "name": "react-with-native-modal",
    "slug": "Operation",
    "id": "HtONHJUCgYpeRlAf",
    "description": "",
    "operationName": "react-with-native-modal"
  },
  "react-with-native-notification": {
    "name": "react-with-native-notification",
    "slug": "Operation",
    "id": "BpXbOAxWSlAaCPPy",
    "description": "",
    "operationName": "react-with-native-notification"
  },
  "react-with-native-router": {
    "name": "react-with-native-router",
    "slug": "Operation",
    "id": "RZVwdhmfmdetZNej",
    "description": "",
    "operationName": "react-with-native-router"
  },
  "react-with-native-select": {
    "name": "react-with-native-select",
    "slug": "Operation",
    "id": "ikNZbbUMqkXxVJPs",
    "description": "",
    "operationName": "react-with-native-select"
  },
  "react-with-native-store": {
    "name": "react-with-native-store",
    "slug": "Operation",
    "id": "eXOcmzdxLiHCsOky",
    "description": "Simple localStorage/asyncStorage-based and fully typed redux replacement with global persisted storage by default for react and react-native apps.",
    "operationName": "react-with-native-store"
  },
  "react-with-native-table": {
    "name": "react-with-native-table",
    "slug": "Operation",
    "id": "SdhvsYtyLKPmzDWq",
    "operationName": "react-with-native-table"
  },
  "react-with-native-ui": {
    "name": "react-with-native-ui",
    "slug": "Operation",
    "id": "JYbdtPKKzYgRSNIQ",
    "description": "Simple basic Tailwind class strings for sensible UI components",
    "operationName": "react-with-native-ui"
  },
  "read-csv-file": {
    "name": "read-csv-file",
    "slug": "Operation",
    "id": "ygAZcXXNqmgqODiC",
    "operationName": "read-csv-file"
  },
  "read-json-file": {
    "name": "read-json-file",
    "slug": "Operation",
    "id": "IGzRtGgKipiDNcid",
    "operationName": "read-json-file"
  },
  "read-kvmd-file": {
    "name": "read-kvmd-file",
    "slug": "Operation",
    "id": "DXHsjiFjXFmNVcPy",
    "operationName": "read-kvmd-file"
  },
  "read-markdown-file": {
    "name": "read-markdown-file",
    "slug": "Operation",
    "id": "tXARCsgZzVfslPOp",
    "operationName": "read-markdown-file"
  },
  "read-typescript-file": {
    "name": "read-typescript-file",
    "slug": "Operation",
    "id": "OyQKHnjNlITPxIpQ",
    "operationName": "read-typescript-file"
  },
  "reader-ui": {
    "name": "reader-ui",
    "slug": "Operation",
    "id": "dmrxxyobafgmvgnfcrwzhoqw",
    "operationName": "reader-ui"
  },
  "rebuild-operation": {
    "name": "rebuild-operation",
    "slug": "Operation",
    "id": "BejGVIBFtLzwZoTB",
    "operationName": "rebuild-operation"
  },
  "recursive-types": {
    "name": "recursive-types",
    "slug": "Operation",
    "id": "btbhbxywtoukushkbfwtbpmu",
    "operationName": "recursive-types"
  },
  "recursive-util": {
    "name": "recursive-util",
    "slug": "Operation",
    "id": "mrbcdmxycfnpcesizugqjcio",
    "operationName": "recursive-util"
  },
  "rename-template-files": {
    "name": "rename-template-files",
    "slug": "Operation",
    "id": "FZFoOSVaQSECmexN",
    "operationName": "rename-template-files"
  },
  "rest-util": {
    "name": "rest-util",
    "slug": "Operation",
    "id": "cOeSLUvQqLDlgLLO",
    "operationName": "rest-util"
  },
  "run-child-process": {
    "name": "run-child-process",
    "slug": "Operation",
    "id": "jErGyuybqueevsjw",
    "operationName": "run-child-process"
  },
  "say": {
    "name": "say",
    "slug": "Operation",
    "id": "ilXwGuLYVpwmgrhQ",
    "operationName": "say"
  },
  "schema-util": {
    "name": "schema-util",
    "slug": "Operation",
    "id": "vqDgdVlYDPjQItuA",
    "description": "It's hard to work with them if you don't know what means what. In this operation I'll summarize everything and give examples.",
    "operationName": "schema-util"
  },
  "search": {
    "name": "search",
    "slug": "Operation",
    "id": "enaZdzaIcJtxsuCc",
    "operationName": "search"
  },
  "server-api-url": {
    "name": "server-api-url",
    "slug": "Operation",
    "id": "YIaKrUxDlcIGSKGv",
    "operationName": "server-api-url"
  },
  "server-login": {
    "name": "server-login",
    "slug": "Operation",
    "id": "figgjjgfvhincexqpsqtbnsl",
    "operationName": "server-login"
  },
  "set-json-key": {
    "name": "set-json-key",
    "slug": "Operation",
    "id": "FoMhQoDjGoMeIfOD",
    "description": "Update a JSON using the CLI",
    "operationName": "set-json-key"
  },
  "share": {
    "name": "share",
    "slug": "Operation",
    "id": "xuznentfkkennkrlzrcqilwx",
    "operationName": "share"
  },
  "short-markdown-parser-js": {
    "name": "short-markdown-parser-js",
    "slug": "Operation",
    "id": "gzmufipbybdblxzlufntghdz",
    "operationName": "short-markdown-parser-js"
  },
  "short-markdown-parser-node": {
    "name": "short-markdown-parser-node",
    "slug": "Operation",
    "id": "yltrnbpxfsatfgydzudjkzxf",
    "operationName": "short-markdown-parser-node"
  },
  "short-markdown-types": {
    "name": "short-markdown-types",
    "slug": "Operation",
    "id": "ehgqnctflsdulfxhffvfembg",
    "operationName": "short-markdown-types"
  },
  "short-markdown-writer-input": {
    "name": "short-markdown-writer-input",
    "slug": "Operation",
    "id": "xhjznnhvilrykjrgpzyhnaqs",
    "operationName": "short-markdown-writer-input"
  },
  "simplified-schema-form": {
    "name": "simplified-schema-form",
    "slug": "Operation",
    "id": "DwZyUDgyJrucAuwy",
    "operationName": "simplified-schema-form"
  },
  "sms": {
    "name": "sms",
    "slug": "Operation",
    "id": "ffbdkbtmgfrxvlldvgddegzq",
    "operationName": "sms"
  },
  "social-media-types": {
    "name": "social-media-types",
    "slug": "Operation",
    "id": "SZLSdBVDzaXWYAEI",
    "description": "I want a type interface collection that is able to collect all data from all social networks and put them together.",
    "operationName": "social-media-types"
  },
  "string-to-json": {
    "name": "string-to-json",
    "slug": "Operation",
    "id": "rwXIwlmtTtNkEuCI",
    "operationName": "string-to-json"
  },
  "swipe-homepage": {
    "name": "swipe-homepage",
    "slug": "Operation",
    "id": "rmeomqfyhekatjqcdpuwodxf",
    "operationName": "swipe-homepage"
  },
  "tabs": {
    "name": "tabs",
    "slug": "Operation",
    "id": "igcpkjecedylbmppjpdavgzk",
    "operationName": "tabs"
  },
  "text-or-binary": {
    "name": "text-or-binary",
    "slug": "Operation",
    "id": "hoxluuxxijqxnzlkiabobody",
    "operationName": "text-or-binary"
  },
  "timeline": {
    "name": "timeline",
    "slug": "Operation",
    "id": "bswaoubjnbnemdsmavjukrzk",
    "operationName": "timeline"
  },
  "todo-types": {
    "name": "todo-types",
    "slug": "Operation",
    "id": "hcnakrerkamuzptdswbxscwz",
    "operationName": "todo-types"
  },
  "tooltip": {
    "name": "tooltip",
    "slug": "Operation",
    "id": "ehhnbkdyoqiebbhkkolyvzgu",
    "operationName": "tooltip"
  },
  "try-parse-json": {
    "name": "try-parse-json",
    "slug": "Operation",
    "id": "hxwsvvtpdhydoltzegqiutdf",
    "operationName": "try-parse-json"
  },
  "ts-morph-util": {
    "name": "ts-morph-util",
    "slug": "Operation",
    "id": "buvDfxDAGVPQBAzK",
    "operationName": "ts-morph-util"
  },
  "ui-util": {
    "name": "ui-util",
    "slug": "Operation",
    "id": "JSSQvyMnmCHPaPMF",
    "operationName": "ui-util"
  },
  "use-on-screen": {
    "name": "use-on-screen",
    "slug": "Operation",
    "id": "jtaapwhmogwjvgbcvnoxjlzv",
    "operationName": "use-on-screen"
  },
  "use-url-store": {
    "name": "use-url-store",
    "slug": "Operation",
    "id": "gUYkfVUCnjCcqSUE",
    "operationName": "use-url-store"
  },
  "vscode-open": {
    "name": "vscode-open",
    "slug": "Operation",
    "id": "kMJHiijRTzoVZkmu",
    "operationName": "vscode-open"
  },
  "watch-all": {
    "name": "watch-all",
    "slug": "Operation",
    "id": "wdrlkzjoriemaynaejxldjgd",
    "operationName": "watch-all"
  },
  "watch-folders": {
    "name": "watch-folders",
    "slug": "Operation",
    "id": "RGfqpcRRDJboWKFJ",
    "operationName": "watch-folders"
  },
  "watch-operations": {
    "name": "watch-operations",
    "slug": "Operation",
    "id": "WXrwkTFdfBDyGtaH",
    "operationName": "watch-operations"
  },
  "watch-types": {
    "name": "watch-types",
    "slug": "Operation",
    "id": "fqainblkfoklcbftrwkdgvtm",
    "operationName": "watch-types"
  },
  "webpage-types": {
    "name": "webpage-types",
    "slug": "Operation",
    "id": "lnwhnaoqskdjejvofpnoecrv",
    "operationName": "webpage-types"
  },
  "write-to-assets": {
    "name": "write-to-assets",
    "slug": "Operation",
    "id": "znfCBjyUQumbKlRe",
    "operationName": "write-to-assets"
  },
  "writer-functions": {
    "name": "writer-functions",
    "slug": "Operation",
    "id": "xkhhpdbucaopovxzzfodmtvo",
    "operationName": "writer-functions"
  },
  "writer-input": {
    "name": "writer-input",
    "slug": "Operation",
    "id": "cogvbrxlirmddlfvbnrhrdha",
    "operationName": "writer-input"
  },
  "writer-types": {
    "name": "writer-types",
    "slug": "Operation",
    "id": "bewcxueuynedlzvljjsciqab",
    "operationName": "writer-types"
  }
}